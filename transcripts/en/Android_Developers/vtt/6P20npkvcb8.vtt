WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.952
[MUSIC PLAYING]

00:00:08.310 --> 00:00:10.110
JAMES LAU: Thank you.

00:00:10.110 --> 00:00:12.310
Thanks for being
here this morning.

00:00:12.310 --> 00:00:16.190
My name is James, and I'm part
of the Kotlin team at Google.

00:00:16.190 --> 00:00:20.160
Today, I have the pleasure
of introducing a very

00:00:20.160 --> 00:00:23.580
special guest from
JetBrains, who really

00:00:23.580 --> 00:00:26.078
requires no introduction.

00:00:28.950 --> 00:00:34.410
Now, all of you know
that Kotlin is now

00:00:34.410 --> 00:00:37.260
one of the most
loved programming

00:00:37.260 --> 00:00:38.710
languages in the world.

00:00:44.870 --> 00:00:47.510
And at Google I/O,
it's very rare for us

00:00:47.510 --> 00:00:49.580
to have external speakers.

00:00:49.580 --> 00:00:52.580
But this person
was here last year,

00:00:52.580 --> 00:00:56.630
and we invited him back because
we couldn't think of anybody

00:00:56.630 --> 00:00:59.990
else better to teach
Kotlin, other than one

00:00:59.990 --> 00:01:02.210
of the people who invented it.

00:01:02.210 --> 00:01:05.420
So please help me welcome
the lead language designer

00:01:05.420 --> 00:01:08.015
for Kotlin, Andrey Breslav.

00:01:08.015 --> 00:01:09.995
[APPLAUSE]

00:01:12.965 --> 00:01:14.450
ANDREY BRESLAV:
Thank you, James.

00:01:14.450 --> 00:01:16.070
Thanks for a great introduction.

00:01:16.070 --> 00:01:16.790
Hello, everybody.

00:01:16.790 --> 00:01:19.150
I'm very glad to see you here.

00:01:19.150 --> 00:01:22.670
Today, I'm going to talk
about what can it be--

00:01:22.670 --> 00:01:24.290
Kotlin-- I guess.

00:01:24.290 --> 00:01:28.650
And I really am going
to do a live demo,

00:01:28.650 --> 00:01:32.030
so please bring my demo on.

00:01:32.030 --> 00:01:36.770
So the reason why I have this
horrible code in the slides

00:01:36.770 --> 00:01:40.910
is that we are all learning,
and our old habits sometimes

00:01:40.910 --> 00:01:42.260
get in the way.

00:01:42.260 --> 00:01:47.180
So I'll be presenting today on
the topic of how you get out

00:01:47.180 --> 00:01:50.810
of your Java habits and
get to your Kotlin habits.

00:01:50.810 --> 00:01:53.330
So we all come from different
backgrounds, of course.

00:01:53.330 --> 00:01:56.480
And many of us started with
the Java programming language

00:01:56.480 --> 00:01:59.720
and built up our knowledge
of programming through this.

00:01:59.720 --> 00:02:01.460
So we remember many things.

00:02:01.460 --> 00:02:05.340
And the thing is Kotlin has
been inspired by many languages,

00:02:05.340 --> 00:02:07.230
including the Java
programming language.

00:02:07.230 --> 00:02:11.660
So you can reproduce many of
the Java constructs in Kotlin.

00:02:11.660 --> 00:02:12.890
And it will work.

00:02:12.890 --> 00:02:15.630
You can get your
job done this way,

00:02:15.630 --> 00:02:19.120
but it can be, in many
cases, improved dramatically.

00:02:19.120 --> 00:02:23.420
So this particular example
is about declaring classes.

00:02:23.420 --> 00:02:26.240
And you can see here that I
have a Kotlin class on the left

00:02:26.240 --> 00:02:28.010
and the Java class on the right.

00:02:28.010 --> 00:02:29.700
And they look very similar.

00:02:29.700 --> 00:02:32.910
But this is definitely not
how we write Kotlin code.

00:02:32.910 --> 00:02:34.660
So what do you are
actually supposed to do

00:02:34.660 --> 00:02:37.790
is remove all the
unnecessary stuff.

00:02:37.790 --> 00:02:40.700
What I have to say here is
two properties, one class.

00:02:40.700 --> 00:02:41.810
That's it, right?

00:02:41.810 --> 00:02:44.210
So I can try to
transform it by hand,

00:02:44.210 --> 00:02:46.790
but I actually want to
show off a nice tool.

00:02:46.790 --> 00:02:49.600
And simply copy and paste
the code from the Java side

00:02:49.600 --> 00:02:53.000
to the Kotlin side, so it
will use the Java to Kotlin

00:02:53.000 --> 00:02:57.280
converter built into the
IDE, and do it for me.

00:02:57.280 --> 00:02:59.900
So boom, there it is.

00:02:59.900 --> 00:03:02.450
A single line that's
actually all you

00:03:02.450 --> 00:03:08.150
needed to declare one
class, two properties.

00:03:08.150 --> 00:03:08.900
That's it.

00:03:08.900 --> 00:03:11.385
All I have here is a class
with a primary constructor.

00:03:11.385 --> 00:03:13.760
So it has two parameters and
both of them are properties.

00:03:13.760 --> 00:03:15.950
And that's all
you wanted to say.

00:03:15.950 --> 00:03:19.520
So this is one of
the things that

00:03:19.520 --> 00:03:23.960
demonstrates how cheap
declaring classes is in Kotlin.

00:03:23.960 --> 00:03:26.390
And there's a
consequence to this.

00:03:26.390 --> 00:03:28.560
So look at this code.

00:03:28.560 --> 00:03:31.940
Here, it's obviously not how
you're supposed to write code

00:03:31.940 --> 00:03:33.410
in any language, actually.

00:03:33.410 --> 00:03:35.930
I wanted to parse a full
name into a first name

00:03:35.930 --> 00:03:37.350
and a last name.

00:03:37.350 --> 00:03:39.530
And so that's what
I'm doing here.

00:03:39.530 --> 00:03:43.100
But how do I pack the result
to put it out of the function?

00:03:43.100 --> 00:03:46.110
I don't have a way of returning
two things from a function.

00:03:46.110 --> 00:03:47.360
I have to put into one object.

00:03:47.360 --> 00:03:52.670
And I'm abusing a list here,
then awkwardly taking out one

00:03:52.670 --> 00:03:55.940
and the other to make a
first name and a last name.

00:03:55.940 --> 00:03:57.790
Don't do this in any language.

00:03:57.790 --> 00:04:00.700
But there is kind of
a psychological reason

00:04:00.700 --> 00:04:03.440
to doing this, at least
in our old habits,

00:04:03.440 --> 00:04:05.810
because declaring classes
is expensive, right?

00:04:05.810 --> 00:04:09.530
You have to create a new
file, put a lot of code in it.

00:04:09.530 --> 00:04:10.610
It's kind of awkward.

00:04:10.610 --> 00:04:12.320
But in Kotlin, you
don't have to do this.

00:04:12.320 --> 00:04:15.380
All you need to say,
my class, full name,

00:04:15.380 --> 00:04:21.050
with first and last
names as properties.

00:04:21.050 --> 00:04:26.630
And then, all I need to do
here is just return that.

00:04:26.630 --> 00:04:29.780
So my full name.

00:04:29.780 --> 00:04:30.620
Here it goes.

00:04:30.620 --> 00:04:35.510
And now instead of indices, I
can say first and last right

00:04:35.510 --> 00:04:36.450
here.

00:04:36.450 --> 00:04:38.936
So that's the idea.

00:04:38.936 --> 00:04:40.310
Classes being
cheap is not always

00:04:40.310 --> 00:04:42.310
saving you time at
the declaration site,

00:04:42.310 --> 00:04:43.880
it's saving you mental effort.

00:04:43.880 --> 00:04:47.780
You can represent your
multiple return as a class

00:04:47.780 --> 00:04:49.210
and it doesn't
cost you anything.

00:04:49.210 --> 00:04:52.430
So if I run this, you'll
see that my equals

00:04:52.430 --> 00:04:56.360
doesn't work, obviously, because
that's a single-line class.

00:04:56.360 --> 00:05:01.120
And so now I'll go to
declare equals there,

00:05:01.120 --> 00:05:03.360
and then a hash code there,
and so on and so forth.

00:05:03.360 --> 00:05:04.310
It's so verbose.

00:05:04.310 --> 00:05:06.770
But I really don't need
to do this in Kotlin,

00:05:06.770 --> 00:05:08.720
because you probably
know that there is

00:05:08.720 --> 00:05:10.730
something called data classes.

00:05:10.730 --> 00:05:12.950
Who knows data classes?

00:05:12.950 --> 00:05:14.510
Many people, good.

00:05:14.510 --> 00:05:17.000
So you know that I simply
put this single keyword there

00:05:17.000 --> 00:05:19.590
and the compiler generates many
things for me-- it's equal,

00:05:19.590 --> 00:05:21.170
it's hash code,
it's to a string,

00:05:21.170 --> 00:05:22.670
and many other
convenient methods.

00:05:22.670 --> 00:05:24.980
So that's it.

00:05:24.980 --> 00:05:28.760
Change your mind about
how expensive a class is.

00:05:28.760 --> 00:05:33.890
You can use it easily in
all your abstractions.

00:05:33.890 --> 00:05:38.550
So more or less done
with the warm up.

00:05:38.550 --> 00:05:40.970
Let's look at something else--

00:05:40.970 --> 00:05:42.300
properties.

00:05:42.300 --> 00:05:43.770
So we talked about classes.

00:05:43.770 --> 00:05:46.950
We'll go through properties,
and then go over to functions.

00:05:46.950 --> 00:05:49.880
So here is a property done
the way you shouldn't do it

00:05:49.880 --> 00:05:51.570
in Kotlin, again.

00:05:51.570 --> 00:05:54.050
So the problems that
I showed you before

00:05:54.050 --> 00:05:57.040
were kind of one-liners where
both the getter and setter is

00:05:57.040 --> 00:05:57.890
trivial.

00:05:57.890 --> 00:05:59.870
If you want a custom
setter, you definitely

00:05:59.870 --> 00:06:01.820
don't define functions for that.

00:06:01.820 --> 00:06:05.644
You have your custom setter
syntax, as you probably know.

00:06:05.644 --> 00:06:07.310
If you know data
classes, you know that.

00:06:07.310 --> 00:06:10.950
So inside a custom setter,
you have field to--

00:06:10.950 --> 00:06:13.810
not filed, but field--

00:06:13.810 --> 00:06:16.270
to write to your backend
storage, but that's it.

00:06:16.270 --> 00:06:20.270
You don't need to introduce
extra names in anything else.

00:06:20.270 --> 00:06:21.910
So that's
straightforward, right?

00:06:21.910 --> 00:06:24.880
But then look at this code.

00:06:24.880 --> 00:06:28.330
So here is already
some sensible logic.

00:06:28.330 --> 00:06:33.280
I have two properties, one
of them private and nullable

00:06:33.280 --> 00:06:34.900
and mutable.

00:06:34.900 --> 00:06:37.930
And on my first access, I'm
checking if that's null,

00:06:37.930 --> 00:06:40.330
and then I compute a
value and write into it.

00:06:40.330 --> 00:06:44.530
And then I output,
return it from my getter.

00:06:44.530 --> 00:06:45.250
So what is it?

00:06:45.250 --> 00:06:47.020
It's a lazy property, right?

00:06:47.020 --> 00:06:49.220
I personally wrote
dozens and thousands

00:06:49.220 --> 00:06:52.250
of those in Java and
many other languages,

00:06:52.250 --> 00:06:54.460
so I got kind of bored by that.

00:06:54.460 --> 00:06:57.100
And that's why Kotlin has an
abstraction mechanism called

00:06:57.100 --> 00:06:58.930
delegation for properties.

00:06:58.930 --> 00:07:02.850
So delegated properties
let you get rid

00:07:02.850 --> 00:07:05.680
of all the repetition
of this lazy logic.

00:07:05.680 --> 00:07:07.880
All we care about is
this expression here.

00:07:07.880 --> 00:07:10.590
So let's just do it.

00:07:10.590 --> 00:07:16.680
Implement my property by
just lazy of all this.

00:07:21.180 --> 00:07:22.610
This is it.

00:07:22.610 --> 00:07:25.010
So what I'm having
now, I'm saying

00:07:25.010 --> 00:07:29.120
my property is not simply
initialized by something.

00:07:29.120 --> 00:07:32.450
It's delegated to
this lazy thing here.

00:07:32.450 --> 00:07:35.400
And upon first access, this
lambda will be executed.

00:07:35.400 --> 00:07:38.120
And then, the rest will
be stored by the library.

00:07:38.120 --> 00:07:39.860
So lazy is not a
language construct,

00:07:39.860 --> 00:07:42.020
it's just a library function.

00:07:42.020 --> 00:07:43.760
You can define your own.

00:07:43.760 --> 00:07:46.950
And the library provides
you with many other things.

00:07:46.950 --> 00:07:50.210
So the takeaway
here is that if you

00:07:50.210 --> 00:07:55.260
have a common kind of property,
like observable for example,

00:07:55.260 --> 00:07:58.860
when you need to be notified
that something was modified,

00:07:58.860 --> 00:08:00.900
use a library or write your own.

00:08:00.900 --> 00:08:04.850
So here, delegates.observable
does the job

00:08:04.850 --> 00:08:06.200
from the standard library.

00:08:06.200 --> 00:08:10.970
But if you like, you don't
have to write code like this.

00:08:10.970 --> 00:08:14.720
When you have one property,
and then the other property,

00:08:14.720 --> 00:08:17.870
and the other doing the same and
same thing over and over again,

00:08:17.870 --> 00:08:20.600
all you need to do
is this, actually.

00:08:20.600 --> 00:08:24.050
Declare a single class
that encapsulates

00:08:24.050 --> 00:08:27.350
the logic of your property,
like your generic getter

00:08:27.350 --> 00:08:28.837
and generic setter.

00:08:28.837 --> 00:08:29.420
And that's it.

00:08:29.420 --> 00:08:33.320
You can now simply refer to
this class in many properties

00:08:33.320 --> 00:08:37.159
and get your business
logic database access,

00:08:37.159 --> 00:08:38.630
all kinds of validation.

00:08:38.630 --> 00:08:42.500
Anything you like can be
abstracted as a library

00:08:42.500 --> 00:08:45.220
and then reused
across your project.

00:08:45.220 --> 00:08:47.830
Does it make sense?

00:08:47.830 --> 00:08:49.909
Who uses this already?

00:08:49.909 --> 00:08:50.450
I don't know.

00:08:50.450 --> 00:08:51.074
So many people.

00:08:51.074 --> 00:08:52.040
You actually should.

00:08:52.040 --> 00:08:55.290
I'm sure you can
benefit from this.

00:08:55.290 --> 00:08:58.360
So this is more or less
it about properties.

00:08:58.360 --> 00:08:59.910
And now, let's get to functions.

00:08:59.910 --> 00:09:01.920
Functions are very
important, right?

00:09:01.920 --> 00:09:05.330
So again, this is
very horrible code.

00:09:05.330 --> 00:09:07.910
Don't write code like
this in Kotlin, please.

00:09:07.910 --> 00:09:10.130
This is very much
inspired by our habits

00:09:10.130 --> 00:09:12.200
in the Java programming
language, when I have

00:09:12.200 --> 00:09:14.570
to put everything into a class.

00:09:14.570 --> 00:09:18.470
So StringUtil-- does your
project has its own StringUtil

00:09:18.470 --> 00:09:20.375
class?

00:09:20.375 --> 00:09:25.480
Oh, if it doesn't, it's just
a very new project, right?

00:09:25.480 --> 00:09:28.692
So any of my projects have them.

00:09:28.692 --> 00:09:30.900
But the thing is, in Kotlin,
it's a little different.

00:09:30.900 --> 00:09:32.420
You don't have to use a class.

00:09:32.420 --> 00:09:35.750
Well, first of all, Kotlin
classes don't have statics.

00:09:35.750 --> 00:09:38.060
So to use these functions
from this class,

00:09:38.060 --> 00:09:40.890
you have to say a
StringUtil, parentheses,

00:09:40.890 --> 00:09:42.789
which makes a new object.

00:09:42.789 --> 00:09:44.330
I don't want a new
object every time.

00:09:44.330 --> 00:09:48.450
I want it like this, so I turn
this class into an object.

00:09:48.450 --> 00:09:50.610
It's a little bit of an
improvement in my insanity,

00:09:50.610 --> 00:09:51.110
right?

00:09:51.110 --> 00:09:52.730
So I was creating
an object every time

00:09:52.730 --> 00:09:53.896
I wanted to call a function.

00:09:53.896 --> 00:09:55.410
That's crazy.

00:09:55.410 --> 00:09:59.300
But really, in Kotlin, I don't
need any enclosing container

00:09:59.300 --> 00:10:02.920
at all because I have
top-level functions.

00:10:02.920 --> 00:10:06.050
So this may seem obvious like
functions, what are they?

00:10:06.050 --> 00:10:07.630
They're just
declarations, right?

00:10:07.630 --> 00:10:10.760
But some languages have them
only in classes and many people

00:10:10.760 --> 00:10:13.940
learn this and rely on this.

00:10:13.940 --> 00:10:15.800
So this is a lot
more of a Kotlin way,

00:10:15.800 --> 00:10:18.320
but it's still
not great in terms

00:10:18.320 --> 00:10:21.710
of what you can achieve with
Kotlin, because here, you

00:10:21.710 --> 00:10:23.830
have two overloads.

00:10:23.830 --> 00:10:27.610
So getFirstWord is
supposed to parse a string,

00:10:27.610 --> 00:10:32.010
find a first space, and take
the first word, and return it.

00:10:32.010 --> 00:10:35.240
But what if the separator
is not a space, but a comma

00:10:35.240 --> 00:10:36.840
or something?

00:10:36.840 --> 00:10:39.170
So here is a more
full-featured version.

00:10:39.170 --> 00:10:41.270
And then, this is how
you'll call it actually

00:10:41.270 --> 00:10:43.460
in most contexts.

00:10:43.460 --> 00:10:47.380
So what I wanted to express
here is just a default value.

00:10:47.380 --> 00:10:50.510
In Java, we are used to
using overloads for this,

00:10:50.510 --> 00:10:53.240
and also some people
use nullable parameters

00:10:53.240 --> 00:10:56.870
like pass and null here, and
I'll give you a default value.

00:10:56.870 --> 00:10:58.040
Don't do this in Kotlin.

00:10:58.040 --> 00:10:59.240
You don't need to.

00:10:59.240 --> 00:11:03.580
So all you need to do actually,
is simply specify your default.

00:11:03.580 --> 00:11:05.360
My default is space, here.

00:11:05.360 --> 00:11:07.210
That's it.

00:11:07.210 --> 00:11:10.090
So there was no need
to emulate defaults.

00:11:10.090 --> 00:11:11.660
They are both into the language.

00:11:11.660 --> 00:11:15.350
And same for when you
have many, many default

00:11:15.350 --> 00:11:17.150
parameters with
different values,

00:11:17.150 --> 00:11:19.340
like multiple Booleans,
so on, so forth.

00:11:19.340 --> 00:11:24.500
You can just use named parameter
syntax to express which of them

00:11:24.500 --> 00:11:25.250
you actually need.

00:11:25.250 --> 00:11:28.560
And all of the rest
will be used by default.

00:11:28.560 --> 00:11:31.520
So this makes functions
fewer in the first place,

00:11:31.520 --> 00:11:35.221
and then a lot more expressive.

00:11:35.221 --> 00:11:35.720
OK.

00:11:35.720 --> 00:11:37.535
Good with functions, right?

00:11:37.535 --> 00:11:41.360
Well, actually, this
function is kind of midway

00:11:41.360 --> 00:11:45.740
between the Kotlin
style and the Java style

00:11:45.740 --> 00:11:48.350
because it's actually
working on strings.

00:11:48.350 --> 00:11:52.000
Very much a good idea to put
this into a string class.

00:11:52.000 --> 00:11:53.690
Oh, wait, it's not.

00:11:53.690 --> 00:11:55.970
Because the string class
is not controlled by you,

00:11:55.970 --> 00:11:58.610
you can't put everything
into the string class.

00:11:58.610 --> 00:12:02.570
And you really want to keep
the string API minimal.

00:12:02.570 --> 00:12:04.540
So what I would
really like to do

00:12:04.540 --> 00:12:08.240
is something like this,
where I can say my string,

00:12:08.240 --> 00:12:11.270
getFirstWord, and that's it.

00:12:11.270 --> 00:12:13.830
So it looks like a method.

00:12:13.830 --> 00:12:16.142
It's called an extension
function, actually.

00:12:16.142 --> 00:12:17.600
It's not sitting
in a string class.

00:12:17.600 --> 00:12:22.061
I didn't go into the JDK and
alter the class I can control.

00:12:22.061 --> 00:12:23.310
But still, it works like this.

00:12:23.310 --> 00:12:27.610
So this is the
mechanism you can use.

00:12:27.610 --> 00:12:31.400
I'll do it manually to
illustrate how it works here.

00:12:31.400 --> 00:12:33.490
So I have a receiver
of type string.

00:12:33.490 --> 00:12:35.890
Now, I don't need this
parameter anymore.

00:12:35.890 --> 00:12:41.560
And I can say this dot
here, and use my this here

00:12:41.560 --> 00:12:45.710
or omit all of this
on the left-hand side.

00:12:45.710 --> 00:12:50.620
So now, I'll be able
to use it this way.

00:12:50.620 --> 00:12:52.150
Make sense?

00:12:52.150 --> 00:12:53.670
I can do the same
with a property.

00:12:53.670 --> 00:12:57.340
Actually, it would be very
nice to do it this way--

00:12:57.340 --> 00:13:00.850
just so I have first
word as a property name.

00:13:00.850 --> 00:13:03.972
And you can have an
extension property.

00:13:03.972 --> 00:13:05.680
Of course, there will
be no customization

00:13:05.680 --> 00:13:10.290
for the separator, but
otherwise you're good to go.

00:13:10.290 --> 00:13:13.030
Yep, I'll just need
to put a space here.

00:13:13.030 --> 00:13:13.840
And that's it.

00:13:13.840 --> 00:13:16.360
So extension functions,
extension properties--

00:13:16.360 --> 00:13:17.860
it's actually a
very important idea.

00:13:17.860 --> 00:13:19.720
It's not only just convenience.

00:13:19.720 --> 00:13:23.380
It allows you to keep your
classes really minimal.

00:13:23.380 --> 00:13:26.320
So look at the string
class in Kotlin.

00:13:26.320 --> 00:13:29.412
It's only five methods.

00:13:29.412 --> 00:13:31.870
If you compare that to Java,
it will be screens and screens

00:13:31.870 --> 00:13:34.070
of declarations.

00:13:34.070 --> 00:13:36.100
So you can keep
your API minimal.

00:13:36.100 --> 00:13:39.400
And all the utility
functions can be extensions,

00:13:39.400 --> 00:13:42.280
can sit in different libraries,
can be modularized like this.

00:13:42.280 --> 00:13:47.910
And that's a very important
tool for designing APIs.

00:13:47.910 --> 00:13:51.690
Do you have questions?

00:13:51.690 --> 00:13:52.534
OK.

00:13:52.534 --> 00:13:53.700
I couldn't take them anyway.

00:13:56.930 --> 00:13:59.630
OK, now, let's have
a look at this.

00:13:59.630 --> 00:14:02.060
Here, I'm doing
something very typical.

00:14:02.060 --> 00:14:03.360
I'm traversing a hierarchy.

00:14:03.360 --> 00:14:06.244
So I have containers
and leaf elements.

00:14:06.244 --> 00:14:07.910
Containers can be
nested in one another.

00:14:07.910 --> 00:14:09.150
Leaf elements sit there.

00:14:09.150 --> 00:14:10.670
All leaf elements
hold text and I

00:14:10.670 --> 00:14:13.280
want to extract all the
text from this hierarchy.

00:14:13.280 --> 00:14:14.600
Pretty straightforward.

00:14:14.600 --> 00:14:18.791
So my classes are
three lines of code--

00:14:18.791 --> 00:14:19.290
not much.

00:14:19.290 --> 00:14:20.081
There's an element.

00:14:20.081 --> 00:14:22.720
There's a container with
the list of children.

00:14:22.720 --> 00:14:24.440
There is text.

00:14:24.440 --> 00:14:26.450
Now, I'm traversing this.

00:14:26.450 --> 00:14:28.220
So I'm using
extension functions.

00:14:28.220 --> 00:14:31.430
I'm using top-level functions,
everything as I told you.

00:14:31.430 --> 00:14:34.610
So it's all right, but
I don't like this code.

00:14:34.610 --> 00:14:36.020
Why don't I like it?

00:14:36.020 --> 00:14:40.170
Here, to traverse a
hierarchy, I need recursion.

00:14:40.170 --> 00:14:43.430
So I need to pass the string
builder down the stack

00:14:43.430 --> 00:14:48.160
and add to it as I'm
going down the tree.

00:14:48.160 --> 00:14:51.500
But then, I end up with
top-level function that's

00:14:51.500 --> 00:14:53.900
only needed by this one here.

00:14:53.900 --> 00:14:56.900
So this one is not
really needed anywhere

00:14:56.900 --> 00:14:58.410
but inside this function.

00:14:58.410 --> 00:15:02.840
So what I'd really like to
do is just put it inside--

00:15:02.840 --> 00:15:07.700
just go here and make
it a local function.

00:15:07.700 --> 00:15:12.260
So again, it's just expressing
that nobody else needs this.

00:15:12.260 --> 00:15:13.990
You don't need private
helpers anymore--

00:15:13.990 --> 00:15:15.897
a look for local helpers.

00:15:15.897 --> 00:15:17.480
And this can be
improved a little bit.

00:15:17.480 --> 00:15:20.690
You can actually
make use of closure.

00:15:20.690 --> 00:15:25.610
So I can create my
string builder right here

00:15:25.610 --> 00:15:27.260
and get rid of all this.

00:15:27.260 --> 00:15:31.190
So I don't need to return
or take parameters here.

00:15:31.190 --> 00:15:36.560
All I need here is use
whatever is declared above.

00:15:36.560 --> 00:15:41.660
And then I just do
extractText of e right here

00:15:41.660 --> 00:15:46.080
and return string
builder toString.

00:15:46.080 --> 00:15:49.100
ExtractText-- oh, sorry-- it's
an extension function, right?

00:15:52.120 --> 00:15:54.310
No, sorry.

00:15:54.310 --> 00:15:58.680
Yeah, so here is how it goes.

00:15:58.680 --> 00:16:01.710
You can turn something into
a local function and leverage

00:16:01.710 --> 00:16:02.470
closure.

00:16:02.470 --> 00:16:05.110
So this variable is declared
outside my function.

00:16:05.110 --> 00:16:08.340
It's not accessible to
anyone outside the outer.

00:16:08.340 --> 00:16:11.310
And I'm using it
here and that's it.

00:16:11.310 --> 00:16:16.090
Now, local functions, extension
functions, top-level functions,

00:16:16.090 --> 00:16:17.580
default parameters-- use these.

00:16:17.580 --> 00:16:19.470
They will make your code nicer.

00:16:19.470 --> 00:16:23.480
Now, let's look at
what's still there.

00:16:23.480 --> 00:16:25.820
Do you see grey code?

00:16:25.820 --> 00:16:27.379
Grey code is useless.

00:16:27.379 --> 00:16:29.670
The IDE and the compiler show
you that something is not

00:16:29.670 --> 00:16:32.130
needed there, and
it actually isn't.

00:16:32.130 --> 00:16:36.210
This class is redundant because
we have this is check here.

00:16:36.210 --> 00:16:38.250
So you simply can remove this.

00:16:38.250 --> 00:16:39.640
And I don't know if you see--

00:16:39.640 --> 00:16:40.710
oh, yeah, you do--

00:16:40.710 --> 00:16:43.640
but the text variable
has gone green.

00:16:43.640 --> 00:16:44.310
Why is it green?

00:16:44.310 --> 00:16:47.310
It's because the compiler can
figure out the casts for you.

00:16:47.310 --> 00:16:48.570
It's actually much safer.

00:16:48.570 --> 00:16:49.660
It's not only convenient.

00:16:49.660 --> 00:16:53.140
I'm really annoyed at my
casts all over the place.

00:16:53.140 --> 00:16:56.220
So I know it's text.

00:16:56.220 --> 00:16:57.100
Why don't you know?

00:16:57.100 --> 00:16:59.010
Well, now it knows.

00:16:59.010 --> 00:17:01.740
And actually, you don't
need this variable either

00:17:01.740 --> 00:17:05.440
because it's the only usage.

00:17:05.440 --> 00:17:07.470
And it's same thing here.

00:17:07.470 --> 00:17:10.599
And then, my container
can be inline as well.

00:17:10.599 --> 00:17:12.210
So here it is.

00:17:12.210 --> 00:17:13.740
I can use smart casts.

00:17:13.740 --> 00:17:16.349
It makes your code
safer, more concise.

00:17:16.349 --> 00:17:18.930
And actually, it makes
all the casts that still

00:17:18.930 --> 00:17:20.310
are in your program meaningful.

00:17:20.310 --> 00:17:23.849
So when you see an as
operator in Kotlin now,

00:17:23.849 --> 00:17:25.210
you know it means something.

00:17:25.210 --> 00:17:28.260
It's not just a useless
compliment to the

00:17:28.260 --> 00:17:29.730
is check above.

00:17:29.730 --> 00:17:35.490
Also this thing here is kind of
stupid because what I'm doing,

00:17:35.490 --> 00:17:38.005
I'm just applying the same
function to everything.

00:17:38.005 --> 00:17:39.130
And it's a single function.

00:17:39.130 --> 00:17:43.500
So what I want to do
is something like this.

00:17:43.500 --> 00:17:47.580
That's a little
bit nicer looking.

00:17:47.580 --> 00:17:50.000
And then, let's look
at what we have.

00:17:50.000 --> 00:17:51.850
We are traversing a hierarchy.

00:17:51.850 --> 00:17:52.590
I have my leaves.

00:17:52.590 --> 00:17:54.150
I have my containers.

00:17:54.150 --> 00:17:56.230
And that's what I want
to express, right?

00:17:56.230 --> 00:17:58.420
I'm checking different cases.

00:17:58.420 --> 00:18:03.320
So to do that, it's a lot
nicer to use a when statement.

00:18:03.320 --> 00:18:07.330
When can switch in
types right here.

00:18:07.330 --> 00:18:09.750
But there is an
annoying thing about it.

00:18:09.750 --> 00:18:12.210
And it's again, coming
from my old habits.

00:18:12.210 --> 00:18:14.700
I'm declaring a close hierarchy.

00:18:14.700 --> 00:18:16.720
I have only containers
and text, right?

00:18:16.720 --> 00:18:19.460
I don't have anything else.

00:18:19.460 --> 00:18:23.111
But now, I have this pretty
annoying else case right here.

00:18:23.111 --> 00:18:23.610
Why?

00:18:23.610 --> 00:18:25.660
Because the compiler
has no idea.

00:18:25.660 --> 00:18:27.690
I don't have anything
but containers and text.

00:18:27.690 --> 00:18:31.690
It's just an abstract class
and I have some cases there.

00:18:31.690 --> 00:18:36.660
But you can actually express
this in Kotlin with sealed.

00:18:36.660 --> 00:18:38.520
I can have a sealed
class, which means

00:18:38.520 --> 00:18:39.960
all the subclasses are known.

00:18:39.960 --> 00:18:42.090
You can declare them
outside this file.

00:18:42.090 --> 00:18:43.920
And this way, the
IDE and the compiler

00:18:43.920 --> 00:18:46.210
know that this else is useless.

00:18:46.210 --> 00:18:49.740
So we went from almost
two screens of code

00:18:49.740 --> 00:18:53.700
to less than one, simply
applying the idioms of Kotlin

00:18:53.700 --> 00:18:54.900
to this code.

00:18:54.900 --> 00:18:56.951
Do you have questions?

00:18:56.951 --> 00:18:57.450
I'm sorry.

00:19:00.220 --> 00:19:00.720
All right.

00:19:03.550 --> 00:19:05.880
So now, let's just
continue with this exercise

00:19:05.880 --> 00:19:10.020
and look at some more examples
of expressions that are written

00:19:10.020 --> 00:19:12.020
like with old habits in mind.

00:19:12.020 --> 00:19:16.750
And we'll try to transform
them into something better.

00:19:16.750 --> 00:19:20.190
So the first thing that
really stands out here is var.

00:19:20.190 --> 00:19:22.350
I can't say never use var.

00:19:22.350 --> 00:19:24.030
Vars are useful.

00:19:24.030 --> 00:19:28.260
Mutable variables can be
used for many nice things.

00:19:28.260 --> 00:19:30.930
But it's kind of discouraged.

00:19:30.930 --> 00:19:32.990
If you need a var, you
need a very good reason.

00:19:32.990 --> 00:19:36.210
Here is not good reason
using a val, definitely.

00:19:36.210 --> 00:19:39.270
Then here, let's
look at these three.

00:19:39.270 --> 00:19:40.270
It's repetition.

00:19:40.270 --> 00:19:41.340
Repetition is ugly.

00:19:41.340 --> 00:19:43.350
Repetition is
error-prone, especially

00:19:43.350 --> 00:19:47.280
if this was not a single
name, but many things chained.

00:19:47.280 --> 00:19:49.440
So I would like to get
rid of this repetition.

00:19:49.440 --> 00:19:53.010
What I can do is say, with ex.

00:19:53.010 --> 00:19:56.040
Does anyone remember Pascal?

00:19:56.040 --> 00:19:57.245
Pascal, anyone?

00:19:57.245 --> 00:19:58.450
Oh, good.

00:19:58.450 --> 00:19:58.950
Good.

00:19:58.950 --> 00:20:01.200
I started in Pascal, almost.

00:20:01.200 --> 00:20:04.000
So it had this weird thing,
which was a building construct.

00:20:04.000 --> 00:20:06.257
In Kotlin, it's a function.

00:20:06.257 --> 00:20:06.840
We can use it.

00:20:06.840 --> 00:20:10.110
And here, we can get
rid of all the ex things

00:20:10.110 --> 00:20:12.970
here, just like this.

00:20:12.970 --> 00:20:14.790
And now it looks even
more stupid, right?

00:20:14.790 --> 00:20:16.230
I'm just assigning to
the same variables.

00:20:16.230 --> 00:20:16.813
Don't do that.

00:20:19.650 --> 00:20:23.400
OK, so now I have a print line
with string plus something,

00:20:23.400 --> 00:20:25.660
string plus something,
string plus something.

00:20:25.660 --> 00:20:26.460
It's awkward.

00:20:26.460 --> 00:20:28.780
Most languages now have
string interpolation.

00:20:28.780 --> 00:20:30.190
Kotlin has that as well.

00:20:30.190 --> 00:20:34.420
So what you actually
need here is this.

00:20:34.420 --> 00:20:37.860
OK, done with this one.

00:20:37.860 --> 00:20:40.270
Import things into
your scope with with.

00:20:40.270 --> 00:20:43.050
Use string
interpolation, it's nice.

00:20:43.050 --> 00:20:48.390
Now here, I'm creating
a map the old way.

00:20:48.390 --> 00:20:52.560
I can kind of make it a
little nicer like this

00:20:52.560 --> 00:20:55.710
by using my operators,
but it's really much nicer

00:20:55.710 --> 00:20:58.600
if I just use a
builder function.

00:20:58.600 --> 00:21:06.768
So what I can do here is replace
all my map things with pairs.

00:21:06.768 --> 00:21:13.560
Oh, not pairs, but pair, sorry.

00:21:13.560 --> 00:21:15.570
Typing when talking
is difficult.

00:21:15.570 --> 00:21:17.840
Yeah, so a map can be
constructed of pairs, right?

00:21:17.840 --> 00:21:21.500
And map was only a set of
pairs from key to value.

00:21:21.500 --> 00:21:25.030
But actually, pairs are
kind of redundant in this,

00:21:25.030 --> 00:21:29.652
so we're usually using
the to function here.

00:21:29.652 --> 00:21:31.860
It's not a built-in operator,
just a library function

00:21:31.860 --> 00:21:34.260
here, so this is how
you create a map.

00:21:34.260 --> 00:21:35.940
And when you want
to traverse the map,

00:21:35.940 --> 00:21:42.810
you can say here, key
and value, and just

00:21:42.810 --> 00:21:46.230
have your variables
like this, which makes

00:21:46.230 --> 00:21:49.470
for loops a lot more concise.

00:21:49.470 --> 00:21:53.010
This example of code,
with my if statement,

00:21:53.010 --> 00:21:57.060
is something I really hated
about my code in Java.

00:21:57.060 --> 00:22:03.490
Because these assignments here,
they all fall apart so easily,

00:22:03.490 --> 00:22:07.950
so I really like to do
things like this in Kotlin.

00:22:07.950 --> 00:22:11.860
So if, and many other things,
are actually expressions.

00:22:11.860 --> 00:22:13.590
This is something
pretty unfamiliar

00:22:13.590 --> 00:22:16.210
for the C language family.

00:22:16.210 --> 00:22:19.290
We are used to dividing
our code into statements

00:22:19.290 --> 00:22:20.370
and expressions, right?

00:22:20.370 --> 00:22:22.080
Statements are things
that have effects.

00:22:22.080 --> 00:22:24.210
Expressions are things
that have values.

00:22:24.210 --> 00:22:27.660
So you assign expressions to
variables and write statements

00:22:27.660 --> 00:22:29.790
to assign things to things.

00:22:29.790 --> 00:22:33.180
So Kotlin is halfway between
this procedural tradition

00:22:33.180 --> 00:22:34.560
and functional tradition.

00:22:34.560 --> 00:22:37.410
So we have a lot more
expressions than you're

00:22:37.410 --> 00:22:38.980
used to in other languages.

00:22:38.980 --> 00:22:40.080
So you can do this here.

00:22:40.080 --> 00:22:42.910
And of course, you
don't have to use a var.

00:22:42.910 --> 00:22:45.980
You don't have to
make a different line.

00:22:45.980 --> 00:22:47.710
And you can assign
it right away.

00:22:47.710 --> 00:22:50.474
So if expression, make it nicer.

00:22:50.474 --> 00:22:52.140
By the way, the result
of the expression

00:22:52.140 --> 00:22:55.380
is the last thing in the block.

00:22:55.380 --> 00:22:57.852
So the same for when.

00:22:57.852 --> 00:23:01.520
When is not simply
switch case on steroids,

00:23:01.520 --> 00:23:05.560
it's largely and
importantly, an expression.

00:23:05.560 --> 00:23:10.320
So you can also do
it like this, right?

00:23:10.320 --> 00:23:13.107
So not many returns
here, but one return here

00:23:13.107 --> 00:23:13.940
will be a lot nicer.

00:23:13.940 --> 00:23:17.520
Also you don't have to repeat
yourself, of course, this much.

00:23:17.520 --> 00:23:21.837
And you can say even this.

00:23:21.837 --> 00:23:24.420
By the way, if you want to check
if something is odd and even,

00:23:24.420 --> 00:23:25.770
don't do it like me.

00:23:25.770 --> 00:23:27.992
It's only for demo purposes.

00:23:27.992 --> 00:23:28.950
Don't try this at home.

00:23:28.950 --> 00:23:30.366
It will hurt.

00:23:33.200 --> 00:23:38.220
Yeah, so this one can be
further simplified like this.

00:23:38.220 --> 00:23:40.730
So again, you're trying
to remove the noise.

00:23:40.730 --> 00:23:42.320
When you see code
like this, just

00:23:42.320 --> 00:23:43.940
try to get rid of the noise.

00:23:43.940 --> 00:23:47.840
Noise is harmful for your brain.

00:23:47.840 --> 00:23:49.940
Last thing, just a
quick demo of what

00:23:49.940 --> 00:23:51.161
do you do with nullability.

00:23:51.161 --> 00:23:53.660
So these question marks-- who's
familiar with nullable types

00:23:53.660 --> 00:23:55.014
in Kotlin?

00:23:55.014 --> 00:23:55.680
How many people?

00:23:55.680 --> 00:23:57.750
I'll go really, really quick.

00:23:57.750 --> 00:23:59.720
So you can nullable types.

00:23:59.720 --> 00:24:02.310
And compiler makes you
do things like this.

00:24:02.310 --> 00:24:04.312
So it's in there now.

00:24:04.312 --> 00:24:05.270
The string is nullable.

00:24:05.270 --> 00:24:06.950
You can dereference it.

00:24:06.950 --> 00:24:10.330
You can either do this,
which says just safely

00:24:10.330 --> 00:24:11.336
dereference me--

00:24:11.336 --> 00:24:12.710
which by the way,
you can do here

00:24:12.710 --> 00:24:18.380
as well so you don't have
to write an if around it.

00:24:18.380 --> 00:24:21.770
And you can actually
simplify it like this.

00:24:21.770 --> 00:24:24.050
Another nice thing
is that you can

00:24:24.050 --> 00:24:32.870
use an elvis operator like
this, so to simplify your longer

00:24:32.870 --> 00:24:34.250
if statements into something.

00:24:34.250 --> 00:24:37.820
And this is kind of curious
because this is definitely

00:24:37.820 --> 00:24:39.380
in an expression
position, right?

00:24:39.380 --> 00:24:41.740
So how elvis works?

00:24:41.740 --> 00:24:44.660
Elvis takes an expression to
the left-hand side of a string,

00:24:44.660 --> 00:24:47.690
asks are you a
null really nicely.

00:24:47.690 --> 00:24:51.429
And then if it's a null, it
evaluates the right-hand side.

00:24:51.429 --> 00:24:53.720
But the right-hand side has
to be an expression, right?

00:24:53.720 --> 00:24:57.080
Basically, it's supposed
to be a default.

00:24:57.080 --> 00:24:59.500
So if you are now on
the left-hand side,

00:24:59.500 --> 00:25:01.400
use a default on
the right-hand side.

00:25:01.400 --> 00:25:04.550
But your default can
be just a return,

00:25:04.550 --> 00:25:07.430
which means that you don't
compute any value there.

00:25:07.430 --> 00:25:09.920
You just jump out
of the function.

00:25:09.920 --> 00:25:12.350
And that's a quite interesting
thing from the type system

00:25:12.350 --> 00:25:14.320
standpoint, but I'm not
giving a lecture here.

00:25:14.320 --> 00:25:17.630
I'm doing a demo.

00:25:17.630 --> 00:25:20.640
OK, we're good with expressions.

00:25:20.640 --> 00:25:22.690
Let's look at some
functional style.

00:25:22.690 --> 00:25:25.595
So people very often
refer to Kotlin

00:25:25.595 --> 00:25:28.280
as a functional language.

00:25:28.280 --> 00:25:30.160
I don't think it is, actually.

00:25:30.160 --> 00:25:32.420
I think Kotlin is a
multi-paradigm language that

00:25:32.420 --> 00:25:33.810
supports functional style.

00:25:33.810 --> 00:25:35.870
You don't have to write
functional in Kotlin,

00:25:35.870 --> 00:25:39.110
but it's oftentimes
very nice to do it.

00:25:39.110 --> 00:25:41.130
So let's have a look at this.

00:25:41.130 --> 00:25:44.210
So in my Java old
days in mind, I

00:25:44.210 --> 00:25:49.160
wrote this code, which just
goes over a list of numbers

00:25:49.160 --> 00:25:52.490
and picks those that
are divisible by 16,

00:25:52.490 --> 00:25:56.050
and then converts them to hex.

00:25:56.050 --> 00:26:00.750
So what it actually does
is filter map, right?

00:26:00.750 --> 00:26:05.220
Map is this one, and
filter is this one.

00:26:05.220 --> 00:26:10.610
So what I can do, even with the
help of my IDE, I can do this.

00:26:10.610 --> 00:26:14.330
So newer versions of all
programming languages

00:26:14.330 --> 00:26:15.820
have something like this.

00:26:15.820 --> 00:26:17.870
It can definitely leverage this.

00:26:17.870 --> 00:26:20.540
So this filter is a function.

00:26:20.540 --> 00:26:23.150
This lambda is a function value.

00:26:23.150 --> 00:26:26.300
You don't have, by the way,
to declare it as a variable.

00:26:26.300 --> 00:26:29.670
You can just get rid of it.

00:26:29.670 --> 00:26:31.880
So that's a lambda parameter.

00:26:31.880 --> 00:26:35.630
Kotlin has some nice
semi-functional things,

00:26:35.630 --> 00:26:39.320
like you can say anywhere in
your code, you can say also.

00:26:39.320 --> 00:26:44.850
You have this value, also do
this for me please-- like print

00:26:44.850 --> 00:26:46.930
this list for me.

00:26:46.930 --> 00:26:48.680
And then proceed with
what you were doing.

00:26:48.680 --> 00:26:51.620
Like never mind this, it's
just debug output or some side

00:26:51.620 --> 00:26:53.090
effect I want to insert here.

00:26:53.090 --> 00:26:55.370
Side effects are not very
functional, on the one hand.

00:26:55.370 --> 00:26:57.560
On the other hand, this is
very handy for debugging.

00:26:57.560 --> 00:26:59.140
You don't have to break
your chain apart, and so on,

00:26:59.140 --> 00:27:00.160
so forth.

00:27:00.160 --> 00:27:05.540
Use also, use let, use
run, and so on, so forth.

00:27:05.540 --> 00:27:09.230
There is one very deep thing
about functional abstractions

00:27:09.230 --> 00:27:11.457
in non-functional languages.

00:27:11.457 --> 00:27:13.790
When I do something like this,
I have my repeat function

00:27:13.790 --> 00:27:14.610
right here, right?

00:27:14.610 --> 00:27:17.000
So what it does,
it takes a number

00:27:17.000 --> 00:27:18.620
of times I want to
repeat something,

00:27:18.620 --> 00:27:20.640
and this something
is a function.

00:27:20.640 --> 00:27:22.940
By the way, you don't have
to invent your own function

00:27:22.940 --> 00:27:26.000
interface every time, just
use the function types here.

00:27:26.000 --> 00:27:28.330
It's a function that takes
an int or it takes a unit.

00:27:28.330 --> 00:27:31.000
Unit is something
you don't care about.

00:27:31.000 --> 00:27:33.290
Then, it simply
repeats it, right?

00:27:33.290 --> 00:27:40.070
So when I say repeat, I'm always
very much conscious about what

00:27:40.070 --> 00:27:42.950
it's going to cost me.

00:27:42.950 --> 00:27:44.790
So it's a function.

00:27:44.790 --> 00:27:47.040
It takes a lambda
as a parameter.

00:27:47.040 --> 00:27:49.857
So it's actually just
another parameter.

00:27:49.857 --> 00:27:52.190
The Kotlin custom is to write
it outside the parentheses

00:27:52.190 --> 00:27:55.880
because it looks more like a
language construct like this.

00:27:55.880 --> 00:27:59.600
But then, OK, I'm running this.

00:27:59.600 --> 00:28:02.300
I have to create a
lambda object, right?

00:28:02.300 --> 00:28:05.150
I have to create a lambda
object every time I

00:28:05.150 --> 00:28:06.430
do anything like this.

00:28:06.430 --> 00:28:08.140
So there is a cost
to this abstraction.

00:28:08.140 --> 00:28:08.960
It's nice code.

00:28:08.960 --> 00:28:10.250
I can reuse things.

00:28:10.250 --> 00:28:13.460
I can raise the level of
abstraction in my code.

00:28:13.460 --> 00:28:16.460
But there is a toll on that.

00:28:16.460 --> 00:28:19.880
Actually in Kotlin, you
can very often get rid

00:28:19.880 --> 00:28:22.280
of the toll of green lambdas--

00:28:22.280 --> 00:28:25.640
lambda objects-- for you, by
just using inline functions.

00:28:25.640 --> 00:28:28.400
When I say inline, my
code doesn't change.

00:28:28.400 --> 00:28:32.972
So here, nothing happened at
the call site that I can see.

00:28:32.972 --> 00:28:39.330
But if I say show
Kotlin bytecode,

00:28:39.330 --> 00:28:41.340
and just decompile
this into to Java--

00:28:41.340 --> 00:28:43.070
just to scare you a little bit.

00:28:43.070 --> 00:28:48.280
It was much of an
easy talk so far.

00:28:48.280 --> 00:28:50.310
So if I do this--

00:28:50.310 --> 00:28:52.110
here it goes-- it's
a simple for loop.

00:28:55.530 --> 00:28:57.810
Where did my lambda go?

00:28:57.810 --> 00:29:00.250
Well, the compiler
simply optimized it away.

00:29:00.250 --> 00:29:02.370
You don't need a lambda.

00:29:02.370 --> 00:29:06.420
So if you simply have your loop
here and you inline everything,

00:29:06.420 --> 00:29:07.560
you end up with a loop.

00:29:07.560 --> 00:29:08.460
That's it.

00:29:08.460 --> 00:29:13.300
So the big difference
in the mindset

00:29:13.300 --> 00:29:15.370
when you go from the
Java programming language

00:29:15.370 --> 00:29:16.840
to the Kotlin
programming language

00:29:16.840 --> 00:29:19.144
is that you still use lambdas,
but some of your lambdas

00:29:19.144 --> 00:29:19.810
are really free.

00:29:19.810 --> 00:29:22.030
And by the way, these
all are free too.

00:29:22.030 --> 00:29:24.610
So many, many lambdas
in the standard library

00:29:24.610 --> 00:29:25.990
are free abstractions.

00:29:25.990 --> 00:29:28.470
You don't have to
pay for calling them.

00:29:28.470 --> 00:29:31.970
It's just code
generated for you.

00:29:31.970 --> 00:29:36.340
So functional in Kotlin is not
only convenient, but also quite

00:29:36.340 --> 00:29:37.510
cheap.

00:29:37.510 --> 00:29:42.820
Speaking of cheap, by the way,
let's look at this example.

00:29:42.820 --> 00:29:45.980
So here, I'm trying to do
a parallel computation.

00:29:45.980 --> 00:29:47.880
Well, it's a stupid sample.

00:29:47.880 --> 00:29:50.000
Nobody does parallel
computation in bare threads,

00:29:50.000 --> 00:29:53.150
so on, so forth, but I
want to illustrate a point.

00:29:53.150 --> 00:29:54.790
So what I'm doing
here is, again,

00:29:54.790 --> 00:30:03.650
with my old habits in mind,
I'm creating 100,000 threads--

00:30:03.650 --> 00:30:06.840
100,000 threads, each of
which does some work--

00:30:06.840 --> 00:30:09.360
actually, sleeps for one second
and just prints a number.

00:30:09.360 --> 00:30:12.480
And then, I have to
join all these threads

00:30:12.480 --> 00:30:14.110
to my main thread.

00:30:14.110 --> 00:30:15.660
So if I run this--

00:30:15.660 --> 00:30:19.450
oh, oh, oh, that
was an exception.

00:30:19.450 --> 00:30:21.120
What was that?

00:30:21.120 --> 00:30:24.660
The Java lang out
of memory error.

00:30:24.660 --> 00:30:27.510
Basically, what it's
telling me, hey, you

00:30:27.510 --> 00:30:31.740
can not create 100,000 threads.

00:30:31.740 --> 00:30:33.600
Are you crazy there?

00:30:33.600 --> 00:30:35.900
It's 100,000 stacks.

00:30:35.900 --> 00:30:38.690
It doesn't fit into memory.

00:30:38.690 --> 00:30:42.000
Just get reasonable.

00:30:42.000 --> 00:30:43.350
And that's fair.

00:30:43.350 --> 00:30:45.670
OS threads are not cheap.

00:30:45.670 --> 00:30:47.650
You have to allocate
resources for threads.

00:30:47.650 --> 00:30:50.400
So you don't do such
silly things with threads,

00:30:50.400 --> 00:30:54.630
but I have this example
down through coroutines.

00:30:54.630 --> 00:30:57.564
Who knows about
coroutines in Kotlin?

00:30:57.564 --> 00:30:59.310
Oh, good.

00:30:59.310 --> 00:31:01.880
Who uses them in production?

00:31:01.880 --> 00:31:05.137
OK, soon enough you all will
be using them, I'm sure.

00:31:05.137 --> 00:31:05.970
So have a look here.

00:31:05.970 --> 00:31:07.720
It's very much the same code.

00:31:07.720 --> 00:31:11.250
So I'll just put it
side by side here.

00:31:11.250 --> 00:31:15.040
Very much the same code,
but instead of threads here,

00:31:15.040 --> 00:31:19.560
I'm creating async tasks
which are using coroutines

00:31:19.560 --> 00:31:20.580
underneath.

00:31:20.580 --> 00:31:23.310
So I'm still waiting for
one second and printing.

00:31:23.310 --> 00:31:27.540
And if I run this, there
is no out of memory.

00:31:27.540 --> 00:31:31.440
It's printing all the
numbers and I'm good.

00:31:31.440 --> 00:31:34.680
So again, Kotlin
introduced coroutines

00:31:34.680 --> 00:31:37.080
as a means of making
your asynchronous

00:31:37.080 --> 00:31:38.820
computations nicer.

00:31:38.820 --> 00:31:42.150
And that works, but
what's the cost of that?

00:31:42.150 --> 00:31:44.580
So the cost of that
is at least cheaper

00:31:44.580 --> 00:31:46.860
than having a thread
per each computation.

00:31:46.860 --> 00:31:48.480
Of course, nobody
does that exactly,

00:31:48.480 --> 00:31:50.710
but still coroutines
are very cheap.

00:31:50.710 --> 00:31:54.600
You can spin off like
100,000 coroutines, a million

00:31:54.600 --> 00:31:57.720
coroutines, and it doesn't
cost you nearly as much

00:31:57.720 --> 00:32:00.210
as anything like
that old threads.

00:32:00.210 --> 00:32:02.310
Let me illustrate something
coroutines are really

00:32:02.310 --> 00:32:05.770
good for right here.

00:32:05.770 --> 00:32:12.180
So here is a legacy
interface or--

00:32:12.180 --> 00:32:14.730
I don't know-- or a [INAUDIBLE]
interface-- whatever.

00:32:14.730 --> 00:32:19.200
So what we very often have to
do to make things asynchronous

00:32:19.200 --> 00:32:22.140
or make things like
reverse our dependencies,

00:32:22.140 --> 00:32:24.540
so on, so forth, is callbacks.

00:32:24.540 --> 00:32:27.709
So just ask me to do something.

00:32:27.709 --> 00:32:28.500
I'll do it for you.

00:32:28.500 --> 00:32:30.240
And I'll let you
know when I'm done.

00:32:30.240 --> 00:32:34.620
So here, I have my mock service,
a request, and a callback

00:32:34.620 --> 00:32:37.170
function that's passed to it.

00:32:37.170 --> 00:32:41.170
So when the work in
the comments are done,

00:32:41.170 --> 00:32:45.980
I'm calling the callback and
just passing my answer there.

00:32:45.980 --> 00:32:46.890
So that's all right.

00:32:46.890 --> 00:32:50.070
It's working for
everyone, right?

00:32:50.070 --> 00:32:51.990
But this is what the
code looks like when

00:32:51.990 --> 00:32:54.660
I want to exchange messages
between two services.

00:32:54.660 --> 00:32:59.430
So I just want to basically
send two messages in sequence.

00:32:59.430 --> 00:33:01.890
And here is what I have to do.

00:33:01.890 --> 00:33:03.590
First, request.

00:33:03.590 --> 00:33:04.350
Then a callback.

00:33:04.350 --> 00:33:05.880
This is the result
of the request.

00:33:05.880 --> 00:33:06.660
I print it.

00:33:06.660 --> 00:33:09.810
Then next request
inside that callback.

00:33:09.810 --> 00:33:10.950
And then print inside.

00:33:10.950 --> 00:33:13.860
So you see the staircase
right here, right?

00:33:13.860 --> 00:33:16.560
One step-- oh, sorry.

00:33:16.560 --> 00:33:18.780
One step, two
steps, three steps.

00:33:18.780 --> 00:33:20.820
And you can actually
get quite deep

00:33:20.820 --> 00:33:24.870
down this staircase,
which is not nice.

00:33:24.870 --> 00:33:26.820
So what I would
really love to do

00:33:26.820 --> 00:33:28.730
is something a little
more straightforward,

00:33:28.730 --> 00:33:30.910
but so this is
kind of tolerable.

00:33:30.910 --> 00:33:32.820
But what if-- just
imagine-- what if you

00:33:32.820 --> 00:33:35.940
needed to do like n calls?

00:33:35.940 --> 00:33:39.250
Just a number-- like
make a list of calls.

00:33:39.250 --> 00:33:42.940
So this is the code I came up
with, which isn't nice at all.

00:33:42.940 --> 00:33:44.580
So I definitely need
recursion there,

00:33:44.580 --> 00:33:46.470
because I have to nest a
callback inside a callback

00:33:46.470 --> 00:33:47.511
inside a callback, right?

00:33:47.511 --> 00:33:48.892
So I need recursion.

00:33:48.892 --> 00:33:50.850
This is the shortest code
I could come up with.

00:33:50.850 --> 00:33:52.140
It copies arrays.

00:33:52.140 --> 00:33:53.016
Don't do that.

00:33:53.016 --> 00:33:54.390
It's wasteful in
terms of memory,

00:33:54.390 --> 00:33:56.490
wasteful in terms of time.

00:33:56.490 --> 00:33:57.534
It's quadratic.

00:33:57.534 --> 00:33:58.950
But basically, you
have to come up

00:33:58.950 --> 00:34:00.870
with something like
this-- like nest callbacks

00:34:00.870 --> 00:34:02.120
into callbacks into callbacks.

00:34:02.120 --> 00:34:06.570
And so you can't just say, OK,
repeat this five times, right?

00:34:06.570 --> 00:34:10.440
So what I really
want to be able to do

00:34:10.440 --> 00:34:16.110
is something like this, where I
just say, OK, send one request,

00:34:16.110 --> 00:34:19.469
wait for results, send
the other request.

00:34:19.469 --> 00:34:21.150
And then if I want
to repeat something,

00:34:21.150 --> 00:34:22.441
just repeat it with a for loop.

00:34:25.010 --> 00:34:29.699
So this code here is actually
using the same callbacks.

00:34:29.699 --> 00:34:33.030
Only the coroutine abstractions
are distributing this away

00:34:33.030 --> 00:34:34.650
from me.

00:34:34.650 --> 00:34:39.840
So actually, you can take any
callback-based API you have

00:34:39.840 --> 00:34:41.900
now, and turn it into this--

00:34:41.900 --> 00:34:44.489
like make it straightforward--

00:34:44.489 --> 00:34:46.170
with just a few lines of code.

00:34:46.170 --> 00:34:47.159
I'll show you.

00:34:47.159 --> 00:34:49.409
So this is calling
the same services,

00:34:49.409 --> 00:34:53.320
because I have this
function right here.

00:34:53.320 --> 00:34:56.219
So what I'm doing, I'm
just turning the request

00:34:56.219 --> 00:35:01.450
into a suspension function
through this simple construct.

00:35:01.450 --> 00:35:04.990
That's an extension function
of my callback service.

00:35:04.990 --> 00:35:07.650
The first thing I say there
is suspend my coroutines.

00:35:07.650 --> 00:35:09.390
So I'm assuming
I'm in a coroutine,

00:35:09.390 --> 00:35:12.570
I suspended it right away,
I get my continuation,

00:35:12.570 --> 00:35:14.201
and I do my request.

00:35:14.201 --> 00:35:14.700
That's it.

00:35:14.700 --> 00:35:15.360
I'm suspended.

00:35:15.360 --> 00:35:17.170
I'm waiting for a request.

00:35:17.170 --> 00:35:18.960
So there it is.

00:35:18.960 --> 00:35:23.790
And when the request is done,
I just say resume to coroutine.

00:35:23.790 --> 00:35:24.810
That's it.

00:35:24.810 --> 00:35:30.360
So this simple lines of code
turns your callback-based API

00:35:30.360 --> 00:35:33.980
into a coroutine API
and so makes this--

00:35:33.980 --> 00:35:37.920
oh, sorry-- makes
this code into this,

00:35:37.920 --> 00:35:40.500
which is a lot more
readable to my sense.

00:35:40.500 --> 00:35:42.668
How do you like it?

00:35:42.668 --> 00:35:44.480
OK, I see some nods
in the audience.

00:35:44.480 --> 00:35:45.630
Thank you.

00:35:45.630 --> 00:35:48.370
Yeah, well, actually,
if you wanted

00:35:48.370 --> 00:35:52.290
to be a lot more prudent here--

00:35:52.290 --> 00:35:54.000
and I'm sure you want to--

00:35:54.000 --> 00:35:55.680
you need a catch exceptions.

00:35:55.680 --> 00:36:02.670
So catching-- handling your
exceptions is very important.

00:36:02.670 --> 00:36:05.280
And that's as easy as this.

00:36:05.280 --> 00:36:07.050
Just catch your exception.

00:36:07.050 --> 00:36:09.900
Whatever happens on
the-- oh, so sorry.

00:36:09.900 --> 00:36:11.110
Not here, of course.

00:36:11.110 --> 00:36:16.980
Whatever happens
with your request,

00:36:16.980 --> 00:36:21.210
just catch it and
resumeWithException.

00:36:21.210 --> 00:36:24.660
So this will propagate
exceptions through coroutines

00:36:24.660 --> 00:36:25.350
very nicely.

00:36:25.350 --> 00:36:28.980
And you'll be able to write
try catch around here--

00:36:28.980 --> 00:36:31.840
like surround this
with try catch--

00:36:31.840 --> 00:36:35.280
I'm sorry, whatever-- and
catch exceptions there,

00:36:35.280 --> 00:36:36.810
as if it was sequential code.

00:36:36.810 --> 00:36:38.760
But underneath, it's
all asynchronous.

00:36:38.760 --> 00:36:43.890
You can do HTTP requests like
this, asyncio, file systems.

00:36:43.890 --> 00:36:47.160
You can do background
threads-- everything you need.

00:36:47.160 --> 00:36:50.520
See how isn't it nice?

00:36:50.520 --> 00:36:54.390
And I guess, the last example
I'll be showing you today

00:36:54.390 --> 00:36:55.240
is this one.

00:36:55.240 --> 00:36:58.690
It's just another showoff for
how coroutines can help you.

00:37:02.160 --> 00:37:03.460
Take a look.

00:37:03.460 --> 00:37:07.260
So what I want to
do is to create

00:37:07.260 --> 00:37:09.360
an infinite stream of numbers.

00:37:09.360 --> 00:37:11.250
Who likes infinite
streams of numbers?

00:37:11.250 --> 00:37:14.730
I eat them for breakfast.

00:37:14.730 --> 00:37:18.270
So I want just a Fibonacci
sequence to be generated here.

00:37:18.270 --> 00:37:20.370
And then, I can take 20 of them.

00:37:20.370 --> 00:37:22.290
Here, just a sequence of 20.

00:37:22.290 --> 00:37:24.360
I can take 200, 2,000.

00:37:24.360 --> 00:37:27.780
I can filter, map,
slice, whatever.

00:37:27.780 --> 00:37:31.350
So this buildSequence
function is a library function

00:37:31.350 --> 00:37:33.270
in the Kotlin standard library.

00:37:33.270 --> 00:37:36.294
And it's actually based on the
same mechanism as coroutines.

00:37:36.294 --> 00:37:37.960
It doesn't do any
background processing.

00:37:37.960 --> 00:37:40.410
It's all in the same thread.

00:37:40.410 --> 00:37:43.465
What it does, it takes all the
yield statements from here,

00:37:43.465 --> 00:37:44.840
and just puts them
in a sequence.

00:37:44.840 --> 00:37:50.260
So if I want to yield something
here, I'll just do it.

00:37:50.260 --> 00:37:53.260
I insert 2 into my sequence.

00:37:53.260 --> 00:37:54.690
If I want to--

00:37:54.690 --> 00:37:59.570
say, if tmp is greater
than 10, continue--

00:37:59.570 --> 00:38:04.590
I can skip pieces of my logic.

00:38:04.590 --> 00:38:07.360
So that's as straightforward
as any coroutine.

00:38:07.360 --> 00:38:12.180
It gives you a lazy sequence.

00:38:12.180 --> 00:38:15.450
So takeaways--
classes are cheap.

00:38:15.450 --> 00:38:18.030
Functions are
top-level or local.

00:38:18.030 --> 00:38:22.160
No overloading to emulate
your default values.

00:38:22.160 --> 00:38:26.340
Use properties, use delegated
properties, use coroutines.

00:38:26.340 --> 00:38:28.710
Have a nice Kotlin.

00:38:28.710 --> 00:38:33.520
And I want to advertise
some more activities today.

00:38:33.520 --> 00:38:36.870
So if you still have questions
that I couldn't take,

00:38:36.870 --> 00:38:41.940
you can come over to an office
hour we're having at 12:30.

00:38:41.940 --> 00:38:43.740
You can come over
to the sandbox area

00:38:43.740 --> 00:38:47.970
C, where we're at the
Kotlin booth, some

00:38:47.970 --> 00:38:49.140
of the day at least.

00:38:49.140 --> 00:38:51.120
And right after my
talk, there will

00:38:51.120 --> 00:38:53.580
be a talk by Jake Wharton
about Android KDX, which

00:38:53.580 --> 00:38:54.620
is very exciting.

00:38:54.620 --> 00:38:57.520
I believe it's on stage two,
so you're welcome there.

00:38:57.520 --> 00:38:59.532
Thank you very much
for your attention.

00:38:59.532 --> 00:39:00.945
[APPLAUSE]

00:39:01.887 --> 00:39:05.080
[MUSIC PLAYING]

