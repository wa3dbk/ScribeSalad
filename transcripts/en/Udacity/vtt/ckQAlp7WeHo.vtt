WEBVTT
Kind: captions
Language: en

00:00:00.320 --> 00:00:04.970
So before we discuss branch station, let's have a reminder of what a branch does

00:00:04.970 --> 00:00:10.870
in a pipeline. A branch instruction like this will compare registers R1 and

00:00:10.870 --> 00:00:15.570
R2. And if they are equal, jump to the label.

00:00:15.570 --> 00:00:19.420
This is usually implemented by having, in the immediate part of

00:00:19.420 --> 00:00:24.470
the instruction field, the difference between the next instructions PC and

00:00:24.470 --> 00:00:29.060
the PC that should be at the label. So that the branch effectively, if R1 and

00:00:29.060 --> 00:00:34.130
R2 are equal, would just add the immediate operand to its current PC.

00:00:34.130 --> 00:00:38.805
So that the branch, if R1 and R2 are equal, will add the immediate

00:00:38.805 --> 00:00:43.580
operand to the PC that it computed for the next instruction. Now the problem

00:00:43.580 --> 00:00:48.590
with branches is that if the branch condition is not met, just increment the PC.

00:00:48.590 --> 00:00:52.020
For example, if the size of the branch instruction is four, then the PC

00:00:52.020 --> 00:00:57.420
will just move by 4 bytes. However, if the branch condition is satisfied,

00:00:57.420 --> 00:01:02.790
in this case if R2 and R1 are equal, then the branch will increment the PC and

00:01:02.790 --> 00:01:06.510
also add the immediate to it, so the next instruction we fetch will be

00:01:06.510 --> 00:01:11.595
at this label. Now let's look at what happens when a branch goes to a pipeline.

00:01:11.595 --> 00:01:16.410
Let's say we have a classical pipeline with a Fetch, Read, ALU, Memory and

00:01:16.410 --> 00:01:19.880
Write stages. And let's say that towards the end of the ALU stage is,

00:01:19.880 --> 00:01:24.230
we actually figure out if a branch is taken or not. In the first cycle,

00:01:24.230 --> 00:01:28.210
we fetched this branch. In the second cycle, the branch moves here,

00:01:28.210 --> 00:01:30.383
where it reads the operand. So it's reading R1 and R2 but

00:01:30.383 --> 00:01:32.637
we have no chance of telling whether the branch will be taken or not.

00:01:32.637 --> 00:01:35.320
So it's no telling whether the branch will be taken or not.

00:01:35.320 --> 00:01:40.401
So we either don't fetch anything here or we fetch something here. Let's say we

00:01:40.401 --> 00:01:44.840
fetch some sort of a green instruction here. At the end of this cycle,

00:01:44.840 --> 00:01:48.698
we still don't know whether the branch will be taken. We have now read R1 and

00:01:48.698 --> 00:01:54.130
R2, but we haven't compared them yet. So when the branch is in the ALU stage,

00:01:54.130 --> 00:01:57.960
the green instruction we have fetched after the branch moves here, and

00:01:57.960 --> 00:02:02.100
we fetch another instruction, let's say that is a purple instruction.

00:02:02.100 --> 00:02:06.140
At the end of this cycle, we finally know whether the branch is taken.

00:02:06.140 --> 00:02:08.910
Now there are two possibilities. Either we

00:02:08.910 --> 00:02:13.190
have fetched the correct instructions, for example, the branch is not taken, and

00:02:13.190 --> 00:02:16.880
we have taken the instructions that follow the branch. The branch is not taken,

00:02:16.880 --> 00:02:20.240
that means the PC just gets incremented and we fetched the right instructions.

00:02:20.240 --> 00:02:23.900
In which case, we have no bubble in our pipeline. We can just proceed. We just

00:02:23.900 --> 00:02:28.050
fetched the right instructions. The second possibility is that the branch for

00:02:28.050 --> 00:02:32.480
example is taken and we fetched the next instructions. In which case,

00:02:32.480 --> 00:02:36.690
we have to cancel these instructions. In the next cycle,

00:02:36.690 --> 00:02:40.740
these two cancelled instructions move on through the pipeline. And

00:02:40.740 --> 00:02:45.090
we finally fetch the instruction that we know is correctly fetched. So

00:02:45.090 --> 00:02:49.880
what happens is if we correctly guessed what should be fetched after the branch,

00:02:49.880 --> 00:02:54.670
then there is no penalty. The branch finishes and then the next instruction will

00:02:54.670 --> 00:02:59.230
finish right after the branch. However, if we mispredicted what will happen

00:02:59.230 --> 00:03:03.730
during the branch and refreshed the wrong things, then the branch effectively

00:03:03.730 --> 00:03:07.750
took three cycles to execute because the branch actually finishes in one cycle.

00:03:07.750 --> 00:03:11.850
But then there are two empty cycles when we don't finish anything. So, overall,

00:03:11.850 --> 00:03:15.700
the cost of the branch was really three cycles instead of one inner pipeline.

00:03:15.700 --> 00:03:19.520
Meaning, the branch cost us one cycle, which is normal for

00:03:19.520 --> 00:03:23.140
every instruction, plus two cycles because of a misprediction.

00:03:23.140 --> 00:03:28.510
Now you also see why it never pays to not fetch something after the branch.

00:03:28.510 --> 00:03:32.740
If we don't fetch anything after the branch until we are sure what to fetch,

00:03:32.740 --> 00:03:37.195
then we are guaranteed to have two empty slots after the branch. So,

00:03:37.195 --> 00:03:41.290
somehow, in that case, regardless of whether we would have guessed correctly or

00:03:41.290 --> 00:03:45.860
not, we have a two-cycle penalty. So we'd rather have the two-cycle penalty some

00:03:45.860 --> 00:03:49.800
of the time than all of the time. Another thing that is important to

00:03:49.800 --> 00:03:55.100
note is that at the end of the fetch cycle where we fetch the branch,

00:03:55.100 --> 00:03:57.860
we don't really know anything about this instruction yet.

00:03:57.860 --> 00:04:02.110
We have just obtained the instruction word, meaning, the 4 bytes that

00:04:02.110 --> 00:04:06.280
present an instruction. But we haven't even begun decoding the branch. So

00:04:06.280 --> 00:04:10.690
what happens is next cycle we have to fetch something based only on

00:04:10.690 --> 00:04:16.170
the knowledge of the branch address. We don't even know whether its a branch or

00:04:16.170 --> 00:04:21.399
not. So when we are fetching an instruction, we don't it is a branch but

00:04:21.399 --> 00:04:25.220
we already have to make a prediction of whether it's a taken branch.

