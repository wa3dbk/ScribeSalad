WEBVTT
Kind: captions
Language: en

00:00:00.200 --> 00:00:04.334
Recall that our original purpose was the
find a transformation of the formula,

00:00:04.334 --> 00:00:07.482
such that a truth assignment
satisfied the original, if and

00:00:07.482 --> 00:00:10.461
only if it could be extended
to the transformed formula.

00:00:10.461 --> 00:00:13.880
And we've seen how to do this
transformation for a single clause.

00:00:13.880 --> 00:00:15.750
But actually, this is enough.

00:00:15.750 --> 00:00:18.500
We can just transform
each clause individually.

00:00:18.500 --> 00:00:21.150
Introducing a new set of variables for
each.

00:00:21.150 --> 00:00:23.020
All the same arguments
about extending or

00:00:23.020 --> 00:00:25.250
restricting the truth
assignment will hold.

00:00:25.250 --> 00:00:28.260
Let's illustrate what a transformation
of a multi clause formula

00:00:28.260 --> 00:00:29.500
looks like with an example.

00:00:30.670 --> 00:00:32.330
Consider this formula here,

00:00:32.330 --> 00:00:35.960
where I've indexed the literal
Z with two indices now.

00:00:35.960 --> 00:00:37.880
The first,
referring to the clause it's in,

00:00:37.880 --> 00:00:42.230
and the second being it's
enumeration within the clause.

00:00:42.230 --> 00:00:44.320
The first clause only has two literals.

00:00:44.320 --> 00:00:48.362
So we transform it into these
two clauses with three literals

00:00:48.362 --> 00:00:51.068
by introducing a new variable, y11.

00:00:51.068 --> 00:00:54.990
It gets the first one because it
was generated by the first clause.

00:00:54.990 --> 00:01:00.732
We transform the second clause with
five literals into these three clauses,

00:01:00.732 --> 00:01:04.546
introducing two new variables y21,
and y22.

00:01:04.546 --> 00:01:08.295
Note that these are different from the
variables used in the clauses generated

00:01:08.295 --> 00:01:09.780
by the first original clause.

00:01:10.910 --> 00:01:13.130
Since all these sets of
variables are disjoint,

00:01:13.130 --> 00:01:15.430
we can assign them
independently of each other and

00:01:15.430 --> 00:01:18.970
apply all the same arguments as
we did to individual clauses.

00:01:18.970 --> 00:01:22.462
That's how CNF can be reduced to 3-CNF.

00:01:22.462 --> 00:01:25.284
And of course, this transformation
runs in polynomial time,

00:01:25.284 --> 00:01:27.460
making the reduction polynomial.

00:01:27.460 --> 00:01:30.710
We just reduced the problem of
finding a satisfying assignment to

00:01:30.710 --> 00:01:31.892
a general CNF formula,

00:01:31.892 --> 00:01:35.511
to the problem of finding a satisfying
assignment to a 3-CNF formula.

00:01:35.511 --> 00:01:39.000
At this point, it's natural to ask,
can we go any further?

00:01:39.000 --> 00:01:41.690
Can we reduce this problem to a 2-CNF?

00:01:41.690 --> 00:01:44.283
Well, no, not unless p is equal to np.

00:01:44.283 --> 00:01:46.121
There is a polynomial time algorithm for

00:01:46.121 --> 00:01:48.664
finding a satisfying
assignment to a 2-CNF formula,

00:01:48.664 --> 00:01:51.430
based of finding strongly
connected components in a graph.

00:01:52.550 --> 00:01:56.910
Therefore, if we could reduce 3-CNF to
2-CNF, then p would be equal to np.

00:01:57.990 --> 00:02:01.680
So, 3-CNF is as simple as
the satisfiability question gets.

00:02:01.680 --> 00:02:04.810
And it admits some very clean and
easy to visualize reductions

00:02:04.810 --> 00:02:06.990
that allow us to show that
other problems are np complete.

00:02:08.080 --> 00:02:09.370
We'll go over two of these.

00:02:09.370 --> 00:02:13.640
First, the reduction to independent set,
or clique, and then to subset sum.

