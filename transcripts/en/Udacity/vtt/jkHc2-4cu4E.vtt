WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
This idea was developed by Andrew Yao in the 1980s,

00:00:03.000 --> 00:00:08.000
and it gives a way to perform any function as a secure computation.

00:00:08.000 --> 00:00:12.000
The idea is that any discrete, fixed-size function can be turned into logic gates,

00:00:12.000 --> 00:00:16.000
and then if we can find a way to implement logic gates securely,

00:00:16.000 --> 00:00:18.000
we can implement a whole function this way.

00:00:18.000 --> 00:00:23.000
We can think of a logic gate as the truth table. Let's take for example the function AND.

00:00:23.000 --> 00:00:26.000
AND takes 2 inputs and produces 1 output.

00:00:26.000 --> 00:00:30.000
And we can describe that AND with the table of values.

00:00:30.000 --> 00:00:34.000
We'll use 0 to represent false and 1 to represent true.

00:00:34.000 --> 00:00:36.000
This is a regular AND gate.

00:00:36.000 --> 00:00:40.000
If we evaluate the AND gate, we need to know the actual values of A and B.

00:00:40.000 --> 00:00:44.000
Suppose the value of A is 1 and the value of B is 0,

00:00:44.000 --> 00:00:49.000
then we would take this line from the truth table and know that output has the value 0.

00:00:49.000 --> 00:00:53.000
Our goal is to encrypt the circuit in such a way that we can still evaluate it

00:00:53.000 --> 00:00:57.000
without actually knowing what the inputs are and without learning what the output is

00:00:57.000 --> 00:01:02.000
but still producing output that we can use as the input to the next circuit.

00:01:02.000 --> 00:01:07.000
If we can evaluate each gate this way, keeping the inputs and outputs encrypted,

00:01:07.000 --> 00:01:09.000
we can evaluate the whole circuit.

00:01:09.000 --> 00:01:13.000
At the end, we can map the final result to a meaningful value.

00:01:13.000 --> 00:01:18.000
Our first step to creating an encrypted circuit is to replace the inputs with encrypted values.

00:01:18.000 --> 00:01:22.000
That means we need some way to represent a 0 on this wire and some way to represent a 1.

00:01:22.000 --> 00:01:28.000
Same for this wire. We're going to place this 0 and 1 in the table with encrypted values.

00:01:28.000 --> 00:01:30.000
We'll just look at those as randomized.

00:01:30.000 --> 00:01:35.000
We're going to pick some random value to represent 0 on this wire. Let's call that A0.

00:01:35.000 --> 00:01:39.000
We'll pick some random value to represent 1. We'll call that A1.

00:01:39.000 --> 00:01:41.000
And we'll do the same thing for the other wire.

00:01:41.000 --> 00:01:43.000
And we'll do the same thing for the output.

00:01:43.000 --> 00:01:45.000
Here's our new truth table.

00:01:45.000 --> 00:01:49.000
Well, if we keep things in the same order, we haven't hidden anything.

00:01:49.000 --> 00:01:53.000
Let's randomly permute it, and now suppose we got a table like this.

00:01:53.000 --> 00:01:59.000
That means that A0 is either 0010 or 1010.

00:01:59.000 --> 00:02:02.000
Now the question is can you determine what is the value of B0.

00:02:02.000 --> 00:02:07.000
If you could, that would mean you know the semantic value of B.

00:02:07.000 --> 00:02:12.000
You can tell if it's equal to B0 or not and that would mean you're evaluating the circuit

00:02:12.000 --> 00:02:14.000
and you're learning the values in the circuit,

00:02:14.000 --> 00:02:17.000
so you don't have the secured computation you wanted to.

00:02:17.000 --> 99:59:59.000
Can you determine the value of the 0 knowing this garbled table?

