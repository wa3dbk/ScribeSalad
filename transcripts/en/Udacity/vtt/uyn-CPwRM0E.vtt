WEBVTT
Kind: captions
Language: en

00:00:00.240 --> 00:00:02.270
So, what does the E state do?

00:00:02.270 --> 00:00:07.070
The M state gives us exclusive access,
so we can both read and

00:00:07.070 --> 00:00:11.730
write and
makes us the owner of a dirty block.

00:00:11.730 --> 00:00:15.880
So, we have to respond with the data and
also update memory.

00:00:15.880 --> 00:00:20.800
The S state gives us shared access so
that we can only read and

00:00:20.800 --> 00:00:24.080
we are not responsible for
giving others our data and

00:00:24.080 --> 00:00:27.270
also we are not responsible for
updating memory.

00:00:27.270 --> 00:00:33.920
We have seen that the O state also give
us shared access so we can do reads.

00:00:33.920 --> 00:00:37.680
But makes us responsible for updating
memory and giving data to others, so

00:00:37.680 --> 00:00:41.410
that we avoid memory writes that
occur when we don't have the state.

00:00:41.410 --> 00:00:46.310
What E does is it gives us exclusive,
so that we can read and

00:00:46.310 --> 00:00:49.440
write, although
the block is still clean.

00:00:49.440 --> 00:00:51.890
The memory still doesn't
need to be updated.

00:00:51.890 --> 00:00:56.350
So when a core does read
A followed by Write A.

00:00:56.350 --> 00:01:02.240
In the MSI protocol we move from
invalid to shared and suffer a miss,

00:01:02.240 --> 00:01:08.360
and then we move from shared to modified
and need to send out an invalidation.

00:01:08.360 --> 00:01:10.780
So we have two bus accesses.

00:01:10.780 --> 00:01:13.530
If we have the MOSI

00:01:13.530 --> 00:01:18.730
we have the same sequence because really
the O state is not helping us here.

00:01:18.730 --> 00:01:21.900
It's helping us save memory accesses
after we had the write, and

00:01:21.900 --> 00:01:23.470
others start reading.

00:01:23.470 --> 00:01:26.940
If we have the MESI, with no O-state,

00:01:26.940 --> 00:01:32.410
or a protocol that combines all
of the states, when we do a read,

00:01:32.410 --> 00:01:38.630
we now detect that although we have read
the block, we're the only one having it.

00:01:38.630 --> 00:01:43.050
So instead of going to the shared
state we go to the E state and

00:01:43.050 --> 00:01:44.620
we suffer a miss.

00:01:44.620 --> 00:01:49.330
But the VNR is that when a write
to A occurs we know we have

00:01:49.330 --> 00:01:54.340
exclusive access so we can just write
without telling anybody although

00:01:54.340 --> 00:01:59.710
we have to transition to the N state now
because now the block is also dirty.

00:01:59.710 --> 00:02:03.660
So now we get the same
behavior that we would get

00:02:03.660 --> 00:02:09.220
if we did this sequence of accesses
on a cache in a uniprocessor.

00:02:09.220 --> 00:02:13.590
So this is not a shared block here, and
we want to get the same number of misses

00:02:13.590 --> 00:02:18.650
and accesses as we do in a uniprocessor
that doesn't share data.

00:02:18.650 --> 00:02:20.290
So here we will have a miss.

00:02:20.290 --> 00:02:22.070
Followed by a cache hit.

00:02:22.070 --> 00:02:27.660
We want to have a cache hit here and
the E state allows us to achieve that.

