WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
Welcome back. This is Unit 6 of Programming Languages.

00:00:04.000 --> 00:00:07.000
And the story, thus far, is that we started

00:00:07.000 --> 00:00:13.000
with a big Web page that might contain embedded JavaScript.

00:00:13.000 --> 00:00:16.000
And we did Lexing or Lexical Analysis

00:00:16.000 --> 00:00:18.000
to break it up into a list of tokens.

00:00:18.000 --> 00:00:22.000
And once we had that list of tokens, we did Parsing

00:00:22.000 --> 00:00:24.000
to check those tokens against a formal grammar

00:00:24.000 --> 00:00:26.000
and produce a Parse Tree.

00:00:26.000 --> 00:00:28.000
More recently, we've learned how to do

00:00:28.000 --> 00:00:31.000
Interpreting to walk up and down a parse tree--

00:00:31.000 --> 00:00:35.000
with an environment--and figure out what the final result is supposed to be.

00:00:35.000 --> 00:00:38.000
We often call that Meaning or Semantics.

00:00:38.000 --> 00:00:41.000
In this Unit, we're going to put that all together

00:00:41.000 --> 00:00:43.000
to build a unified Web browser,

00:00:43.000 --> 00:00:45.000
and it's going to require all the tricks that we've learned,

00:00:45.000 --> 00:00:48.000
up to this point--including things like

00:00:48.000 --> 00:00:50.000
how to debug or what can go wrong

00:00:50.000 --> 00:00:53.000
if you interpret a program with an infinite loop.

00:00:53.000 --> 00:00:56.000
Let's talk about the Architecture for our Web browser.

00:00:56.000 --> 00:00:59.000
Just as engineers or architects that build buildings in the Real World

00:00:59.000 --> 00:01:02.000
like to have blueprints or plans--or some

00:01:02.000 --> 00:01:04.000
notion of how that design is going to come together--

00:01:04.000 --> 00:01:07.000
we try to do the same thing in software engineering.

00:01:07.000 --> 00:01:09.000
We want to have a software architecture,

00:01:09.000 --> 00:01:13.000
a list of major components, and a design that incorporates all of them.

00:01:13.000 --> 00:01:16.000
Our first step is to find our Web page

00:01:16.000 --> 00:01:19.000
and lex it and parse it until we have an Abstract Syntax Tree.

00:01:19.000 --> 00:01:21.000
Most commonly, our HTML interpreter

00:01:21.000 --> 00:01:26.000
will walk over the Abstract Syntax Tree that we got from the parsing,

00:01:26.000 --> 00:01:29.000
and it may find elements in there that are embedded JavaScript.

00:01:29.000 --> 00:01:31.000
So then we'll have to call the JavaScript interpreter on them.

00:01:31.000 --> 00:01:35.000
In most cases, at some point the JavaScript code from the user

00:01:35.000 --> 00:01:38.000
will call "write" or "document_write",

00:01:38.000 --> 00:01:40.000
and that's that function that says:

00:01:40.000 --> 00:01:44.000
If I'm in JavaScript, display this on the resulting Web page.

00:01:44.000 --> 00:01:47.000
Because the meaning of a JavaScript program that calls "write"

00:01:47.000 --> 00:01:49.000
is that that text should be displayed,

00:01:49.000 --> 00:01:53.000
we'll definitely want to store all of the text from "write"

00:01:53.000 --> 00:01:55.000
so that we remember to include it in the Web page later.

00:01:55.000 --> 00:01:58.000
Eventually, the JavaScript fragments will be done executing

00:01:58.000 --> 00:02:01.000
and will be back to the HTML interpreter,

00:02:01.000 --> 00:02:04.000
which will have received all of those

00:02:04.000 --> 00:02:06.000
strings from "write", and it will take them--

00:02:06.000 --> 00:02:08.000
plus all of the normal HTML elements--

00:02:08.000 --> 00:02:12.000
and call the graphics library to make a pretty picture of them.

00:02:12.000 --> 00:02:14.000
Eventually, at the end of the day--

00:02:14.000 --> 00:02:16.000
we end up with an image of the Web page,

00:02:16.000 --> 09:59:59.000
and that's what we wanted from our simple Web browser.

