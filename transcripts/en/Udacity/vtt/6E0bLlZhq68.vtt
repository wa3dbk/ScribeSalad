WEBVTT
Kind: captions
Language: en

00:00:00.490 --> 00:00:03.640
Normally, when we think about routing of packets on

00:00:03.640 --> 00:00:08.210
the internet, typically what happens is. At the source

00:00:08.210 --> 00:00:10.890
node, you create a network packet and go through

00:00:10.890 --> 00:00:14.300
the layers of software stack on the sending node, and

00:00:14.300 --> 00:00:17.010
send the packet out on the network. And this

00:00:17.010 --> 00:00:21.230
network packet has a desired destination. And of course,

00:00:21.230 --> 00:00:22.870
it has to go through a whole number of

00:00:22.870 --> 00:00:26.980
intermediate routers in order to get to its eventual destination.

00:00:26.980 --> 00:00:30.090
And the routers on the Internet that are intermediate between

00:00:30.090 --> 00:00:33.540
the source and the destination, they don't inspect the packet for

00:00:33.540 --> 00:00:35.990
the contents or anything like that. All that they're doing is

00:00:35.990 --> 00:00:39.310
when the packet comes in, they're looking at the destination known

00:00:39.310 --> 00:00:42.140
for that packet and figuring out what is the next

00:00:42.140 --> 00:00:45.720
hub that I have to send the packet to. So each

00:00:45.720 --> 00:00:48.720
router is making the determination of the next hub for the

00:00:48.720 --> 00:00:52.190
package, and it makes the determination by doing a table lookup.

00:00:52.190 --> 00:00:54.470
So every router has a routing table, and the

00:00:54.470 --> 00:00:58.250
routing table is telling. Given a particular destination, what

00:00:58.250 --> 00:01:00.960
is the next hop? And that's how the packet

00:01:00.960 --> 00:01:04.060
flows from source to destination through a whole bunch of

00:01:04.060 --> 00:01:06.740
intermediate routers and finally gets to the destination. So

00:01:06.740 --> 00:01:10.130
in other words, the routers en route to the destination

00:01:10.130 --> 00:01:14.510
from the source, are simply forwarding packets. That is,

00:01:14.510 --> 00:01:17.350
the nodes are passive. And they're just doing a table

00:01:17.350 --> 00:01:19.520
lookup in order to figure out what is the

00:01:19.520 --> 00:01:21.390
next hop that I have to send this packet

00:01:21.390 --> 00:01:23.880
to? Now, what does it mean to make the

00:01:23.880 --> 00:01:27.230
nodes active? What we mean by making the node

00:01:27.230 --> 00:01:31.270
active is that the next hop for sending this

00:01:31.270 --> 00:01:34.670
package towards a destination is not simply a table

00:01:34.670 --> 00:01:38.150
look up. But it is actually determined by the

00:01:38.150 --> 00:01:42.840
router executing code that is actively as opposed to doing

00:01:42.840 --> 00:01:46.010
just a passive table look up. So, in other

00:01:46.010 --> 00:01:49.840
words, the packet in addition to the payload that

00:01:49.840 --> 00:01:52.850
is intended for the destination also carries code with

00:01:52.850 --> 00:01:55.370
it. And the code is being executed by the

00:01:55.370 --> 00:01:57.790
router in order to make a determination as to

00:01:57.790 --> 00:01:59.970
what to do with this packet in terms of

00:01:59.970 --> 00:02:03.900
routing it towards the desired destination. This sounds really

00:02:03.900 --> 00:02:08.070
clever because it can provide customized service for networks

00:02:08.070 --> 00:02:10.788
flows that are going through the network. And every

00:02:10.788 --> 00:02:15.140
network can have its own way of choosing what

00:02:15.140 --> 00:02:17.890
may be the desired route, in terms of going

00:02:17.890 --> 00:02:20.280
from source to destination. And so in other words

00:02:20.280 --> 00:02:23.850
we're saying. Well, this is an opportunity to virtualize

00:02:23.850 --> 00:02:28.090
the traffic flow from my network traffic independent of

00:02:28.090 --> 00:02:30.730
other network flows. This should be very familiar to

00:02:30.730 --> 00:02:33.800
you all because we've been talking about customizing operating

00:02:33.800 --> 00:02:37.040
system services in the SPIN operating system, and

00:02:37.040 --> 00:02:38.870
the XO kernel and so on. But, of

00:02:38.870 --> 00:02:41.600
course, the problem that we're talking about here,

00:02:41.600 --> 00:02:45.730
much, much, harder because the network is wide open.

00:02:45.730 --> 00:02:47.880
Our network traffic flow is going through the

00:02:47.880 --> 00:02:51.150
public internet infrastructure ,and we are talking about

00:02:51.150 --> 00:02:55.410
specializing the network flow for every network flow

00:02:55.410 --> 00:02:59.170
independent of others. There are lots of challenges to

00:02:59.170 --> 00:03:03.480
this values of active network. In particular, how can we

00:03:03.480 --> 00:03:06.700
write such code that we can distribute and send it

00:03:06.700 --> 00:03:09.870
over the wire so that routers can execute it. And

00:03:09.870 --> 00:03:13.290
who can write such code? And how can we be sure

00:03:13.290 --> 00:03:16.060
that the injected code does not break the network? Or

00:03:16.060 --> 00:03:18.430
in other words, for a particular network flow, there is

00:03:18.430 --> 00:03:20.880
a code that is going to be centered on. How do

00:03:20.880 --> 00:03:24.660
we make sure that is not going to in some way [UNKNOWN]

00:03:24.660 --> 00:03:26.820
other network flows? These are things that we

00:03:26.820 --> 00:03:29.320
have to worry about and sort of opening up

00:03:29.320 --> 00:03:32.370
the router and saying that we're going to take

00:03:32.370 --> 00:03:36.450
network flow specific decisions in each of the routers.

