WEBVTT
Kind: captions
Language: en

00:00:00.440 --> 00:00:04.680
So here's how we could define factorial. And,

00:00:04.680 --> 00:00:09.160
we should go back to our mathematical definition. That's

00:00:09.160 --> 00:00:11.500
what we want to turn into code. We had our

00:00:11.500 --> 00:00:13.850
base case where factorial is 0. The result should

00:00:13.850 --> 00:00:17.172
be 1. And we had our recursive case, where

00:00:17.172 --> 00:00:20.050
there is input is greater than 0. We want to

00:00:20.050 --> 00:00:22.380
have the result be n times factorial of n

00:00:22.380 --> 00:00:25.780
minus 1. So we can turn that fairly straightforwardly

00:00:25.780 --> 00:00:30.670
into code, so here's the code. We're going to define

00:00:30.670 --> 00:00:34.840
a procedure. Just like the previous definition, we have

00:00:34.840 --> 00:00:39.140
one input, it's a number. We'll call it n. Now we need to have the code, so we

00:00:39.140 --> 00:00:41.140
need to first check if we've reached the base

00:00:41.140 --> 00:00:43.830
case, so we'll use an if for that. And

00:00:43.830 --> 00:00:47.250
we're going to check if if n is equal to

00:00:47.250 --> 00:00:50.660
0, remember we need the double equals for the comparison.

00:00:50.660 --> 00:00:52.615
That means we've reached the base case. And we

00:00:52.615 --> 00:00:57.613
defined that value factorial as 0, is defined as

00:00:57.613 --> 00:01:00.285
1. So that means when n equals 0, what

00:01:00.285 --> 00:01:03.510
we should do is return the value of 1. When

00:01:03.510 --> 00:01:08.870
it is not equal to 0, we'll use else for the case where n is not equal to 0.

00:01:08.870 --> 00:01:11.160
Well then we have the recursive case. And that

00:01:11.160 --> 00:01:15.120
was given by the definition, that the factorial of n,

00:01:16.300 --> 00:01:23.424
for numbers greater than 0, is equal to n times factorial of n minus 1. So

00:01:23.424 --> 00:01:25.088
that's exactly what we want to do in the

00:01:25.088 --> 00:01:29.010
Python kid. We'll turn the new result, which

00:01:29.010 --> 00:01:36.410
is n times the result we get, calling factorial passing in n minus 1. And this

00:01:36.410 --> 00:01:38.720
may seem strange that we're defining factorial using

00:01:38.720 --> 00:01:41.930
factorial. It seems like that's kind of circular,

00:01:41.930 --> 00:01:44.130
but the reason that it's not circular, is because we

00:01:44.130 --> 00:01:47.180
have this base case. That we have a case, where we

00:01:47.180 --> 00:01:50.600
do stop, we stop once we reach the case where

00:01:50.600 --> 00:01:53.260
n is equal to 0, and because every time we call

00:01:53.260 --> 00:01:55.960
factorial, instead of passing in the same value of n

00:01:55.960 --> 00:01:59.370
that we started with, we're passing in n minus 1. It's

00:01:59.370 --> 00:02:02.660
getting smaller. Eventually we're going to get to 0, assuming that we

00:02:02.660 --> 00:02:07.070
started with n as some positive whole number. So we eventually

00:02:07.070 --> 00:02:10.150
stop, return one. And on the way there,

00:02:10.150 --> 00:02:12.800
we're going to be multiplying in all these values.

00:02:12.800 --> 00:02:14.870
So let's step through what happens when we

00:02:14.870 --> 00:02:17.870
run this code. So let's look at an example.

00:02:17.870 --> 00:02:22.540
Suppose we called factorial passing and three. So

00:02:22.540 --> 00:02:25.190
that means we're going to enter the procedure here.

00:02:25.190 --> 00:02:28.520
The value that n refers to is going to

00:02:28.520 --> 00:02:32.230
be 3 inside the body of factorial. We're going to

00:02:33.380 --> 00:02:35.480
try the comparison. It is not equal to 0, so

00:02:35.480 --> 00:02:38.860
we don't return 1. So we're going to go to the else.

00:02:38.860 --> 00:02:41.270
And that means we're going to return the value of n

00:02:41.270 --> 00:02:45.250
times factorial of n minus 1. So that means we're computing

00:02:45.250 --> 00:02:48.670
the value of n times factorial then and n minus

00:02:48.670 --> 00:02:52.010
1, well, n was 3, so n minus 1 is 2.

00:02:52.010 --> 00:02:54.380
That's what happened as a result in the first call.

00:02:55.810 --> 00:02:58.296
But we're not done, right. We still need to evaluate this,

00:02:58.296 --> 00:03:01.980
so now we're evaluating factorial of 2. That means we're

00:03:01.980 --> 00:03:05.060
entering factorial again. This time the value of n will

00:03:05.060 --> 00:03:07.515
refer to 2. We do the comparison, n is not

00:03:07.515 --> 00:03:09.990
equal to 0 so we go to the else clause.

00:03:09.990 --> 00:03:13.542
Now, we're going to return the result of n times factorial

00:03:13.542 --> 00:03:15.840
n minus 1. In this case, the value of n

00:03:15.840 --> 00:03:18.920
is 2. So the value of factorial of 2 will

00:03:18.920 --> 00:03:23.860
be 2 times the result we get by calling factorial,

00:03:23.860 --> 00:03:27.510
passing in the value of n minus 1, so calling

00:03:27.510 --> 00:03:30.150
factorial passing in 1. And remember that was part of

00:03:30.150 --> 00:03:33.190
the return, where we had 3 times factorial 2. So

00:03:33.190 --> 00:03:35.900
we still have the 3 times. But now we're getting

00:03:35.900 --> 00:03:38.910
the result of factorial 2. It's 2 times something. We're

00:03:38.910 --> 00:03:41.470
calling factorial again. We still don't know what factorial of

00:03:41.470 --> 00:03:45.320
1 is. So that means we're going to reenter factorial. We

00:03:45.320 --> 00:03:48.980
finished here. We're doing the call. We're going to re-enter factorial,

00:03:48.980 --> 00:03:54.850
but this time the value of n now refers to 1. And now again

00:03:54.850 --> 00:04:00.050
this test is false. So we go to the else clause. And now we're going to return n

00:04:00.050 --> 00:04:06.690
which is 1 times the result of factorial 0. So now, we're calling factorial 0.

00:04:06.690 --> 00:04:13.320
We're going back into the procedure. Now, the value of n refers to is 0. And,

00:04:14.530 --> 00:04:17.990
now, this test is actually true, n equals 0.

00:04:17.990 --> 00:04:21.390
So, we'll go to the return here. We return 1,

00:04:21.390 --> 00:04:23.970
that means the result of factorial 0 is 1,

00:04:23.970 --> 00:04:27.700
so to get the result of factorial 1, we had

00:04:27.700 --> 00:04:30.650
1 times factorial 0, that's 1 times 1, which

00:04:30.650 --> 00:04:33.670
is 1, and now to get the result back from

00:04:33.670 --> 00:04:36.230
factorial 2, we had 2 times factorial 1, which we

00:04:36.230 --> 00:04:39.678
now know is 1. So we're going to have, the result

00:04:39.678 --> 00:04:42.746
here as 2. And to get the result for factorial

00:04:42.746 --> 00:04:45.903
3, we have 3 times factorial 2, which we know

00:04:45.903 --> 00:04:48.937
has the value 2, will get the result, as 6.

00:04:48.937 --> 00:04:51.732
And note the way we've defined it, well if we tried

00:04:51.732 --> 00:04:55.242
instead, factorial 4, if we started with factorial 4, what

00:04:55.242 --> 00:04:58.232
would have happened is the first time we go through, we

00:04:58.232 --> 00:05:01.300
get 4 times factorial 3. So factorial 4 would be

00:05:01.300 --> 00:05:04.910
4 times factorial 3. Well we had factorial 3 as 6,

00:05:04.910 --> 00:05:11.063
4 times 6 would give us 24, which is the result of factorial 4.

