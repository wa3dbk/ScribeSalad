WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Let's zoom back to finite state machines at 88 miles an hour.

00:00:03.000 --> 00:00:08.000
Here's a finite state machine that corresponds to the regular expression "a+1+".

00:00:08.000 --> 00:00:13.000
Let's just verify that by tracing out the input, aa1, on this finite state machine.

00:00:13.000 --> 00:00:15.000
We start in the start state. We haven't seen anything yet.

00:00:15.000 --> 00:00:17.000
We see the a. We're in state 2.

00:00:17.000 --> 00:00:21.000
We see the a, self-loop back to state 2. We see the 1. We're in state 3.

00:00:21.000 --> 00:00:25.000
Oh! State 3 is an accepting state. Ha-za!

00:00:25.000 --> 00:00:29.000
Surprisingly, this super high-tech sounding "tracing with my finger" approach

00:00:29.000 --> 00:00:35.000
is actually pretty much exactly what computers do under the hood to check strings

00:00:35.000 --> 00:00:38.000
against regular expressions or evaluate finite state machines.

00:00:38.000 --> 00:00:42.000
You really only have to keep track of where you are in the input and which state you're in

00:00:42.000 --> 00:00:44.000
and not much else.

00:00:44.000 --> 00:00:45.000
So let's do this together.

00:00:45.000 --> 00:00:49.000
We'll write a computer program in Python to check to see if a finite state machine

00:00:49.000 --> 00:00:51.000
accepts a string.

00:00:51.000 --> 00:00:55.000
So if I somehow give it this finite state machine an aa1 as input,

00:00:55.000 --> 00:00:57.000
it should say, true.

00:00:57.000 --> 00:01:02.000
If I instead give it aa1b, it should say false because that string is not accepted.

00:01:02.000 --> 00:01:06.000
But the first big design decision is, how do we represent this finite state machine?

00:01:06.000 --> 00:01:12.000
By now, we know how to pass a Python program a number or a string or a list,

00:01:12.000 --> 00:01:15.000
but how do I pass in a picture?

00:01:15.000 --> 00:01:19.000
Well, for the states 1, 2, 3, presumably, I could just pass in a list of the states.

00:01:19.000 --> 00:01:22.000
It's these edges, these arrows that go anywhere.

00:01:22.000 --> 00:01:23.000
That's what really matters.

00:01:23.000 --> 00:01:28.000
What we really want to know from an edge is, if I'm in state 1, and the next input is "a",

00:01:28.000 --> 00:01:30.000
where do I go?

00:01:30.000 --> 00:01:35.000
So let's use Python dictionaries or maps to do this.

00:01:35.000 --> 00:01:38.000
I'll make a Python dictionary or map called edges,

00:01:38.000 --> 00:01:42.000
and I'll just pass in my current state and the input letter,

00:01:42.000 --> 00:01:45.000
and it will give me the new state at the end.

00:01:45.000 --> 00:01:51.000
Before we dive into it though, let's have a little refresher on maps and also tuples.

00:01:51.000 --> 00:01:54.000
You may have seen them before in a previous CS class,

00:01:54.000 --> 00:01:56.000
but if you haven't, I'll just go over them right now.

00:01:56.000 --> 00:02:01.000
You make a new map or dictionary in Python using open curly braces

00:02:01.000 --> 00:02:02.000
and closed curly braces.

00:02:02.000 --> 00:02:09.000
The purpose of a map is to associate 1 thing with another.

00:02:09.000 --> 00:02:12.000
For example, here I'm making a map that's going to help me keep track of which things

00:02:12.000 --> 00:02:16.000
in the world are flowers because I might easily forget this critical knowledge.

00:02:16.000 --> 00:02:22.000
So I can update my map by saying, oh, 'roses' should map to true in the is_flower dictionary.

00:02:22.000 --> 00:02:25.000
But 'dog' is not a flower, so that should map to false.

00:02:25.000 --> 00:02:29.000
Then if I go look it up later, is_flower of 'rose' will return true.

00:02:29.000 --> 00:02:32.000
There's an alternative notation for specifying a map.

00:02:32.000 --> 00:02:35.000
Inside the curly braces you use to make a new map, you can actually just put

00:02:35.000 --> 00:02:41.000
all of the bindings--'rose' maps to true. Colon. 'Dog' maps to false.

00:02:41.000 --> 00:02:42.000
There's a colon in the center.

00:02:42.000 --> 00:02:46.000
Now at this point you're probably thinking, what's in a name?

00:02:46.000 --> 00:02:50.000
Is this word, 'rose' really important, or would a 'rose' by any other name still smell as sweet?

00:02:50.000 --> 00:02:54.000
Well, we may be able to tell synonyms, but Python cannot.

00:02:54.000 --> 00:02:59.000
So if I try something like, is_flower 'juliet', that's not defined in this mapping,

00:02:59.000 --> 00:03:03.000
so we will get some sort of key error element not found exception.

00:03:03.000 --> 00:03:06.000
For Python dictionaries, you need to get the name exactly right.

00:03:06.000 --> 00:03:11.000
Dictionaries and mappings are synonyms. They both refer to the same thing.

00:03:11.000 --> 00:03:14.000
A Python tuple is just an immutable list.

00:03:14.000 --> 00:03:16.000
Immutable means you cannot change it.

00:03:16.000 --> 00:03:19.000
Once you make it, it is etched in stone.

00:03:19.000 --> 00:03:23.000
For example, I can make a tuple to hold the Cartesian coordinates of some object.

00:03:23.000 --> 00:03:26.000
Maybe my point on the grid is at (1, 5).

00:03:26.000 --> 00:03:29.000
I can access its elements the same way I would for a list.

00:03:29.000 --> 00:03:33.000
The 0th part of point is 1. The 1th part of point is 5.

00:03:33.000 --> 00:03:36.000
And while Cartesian points may not be super exciting,

00:03:36.000 --> 00:03:41.000
many of you may have done navigation or taken long trips and used GPS coordinates

00:03:41.000 --> 00:03:43.000
or longitude and latitude.

00:03:43.000 --> 00:03:46.000
The Taj Mahal is a UNESCO world-heritage site in India.

00:03:46.000 --> 09:59:59.000
These are its actual GPS coordinates. Go check it out!

