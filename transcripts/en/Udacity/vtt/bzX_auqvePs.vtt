WEBVTT
Kind: captions
Language: en

00:00:00.160 --> 00:00:02.780
Let's go ahead and
create our first application in Flask.

00:00:02.780 --> 00:00:05.840
Create a file named project.py
in the same directory

00:00:05.840 --> 00:00:07.907
as the database setup.py file.

00:00:07.907 --> 00:00:11.120
A minimal Flask application
looks something like this.

00:00:11.120 --> 00:00:13.920
Let's take a look at this code
together and see what's going on.

00:00:13.920 --> 00:00:17.540
First, I imported this Flask
class from the Flask library.

00:00:17.540 --> 00:00:21.120
Next, I create an instance of this class
with the name of the running application

00:00:21.120 --> 00:00:22.030
as the argument.

00:00:22.030 --> 00:00:25.650
Anytime we run an application in Python,
a special variable called name gets

00:00:25.650 --> 00:00:28.560
defined for the application and
all of the imports it uses.

00:00:28.560 --> 00:00:32.354
The application run by the Python
interpreter gets a name variable set to

00:00:32.354 --> 00:00:37.360
__main__ whereas all the other imported
Python files get a double underscore,

00:00:37.360 --> 00:00:41.420
name double underscore variable set to
the actual name of the Python file.

00:00:41.420 --> 00:00:45.310
Next, I have this thing that looks like
a function, but starts with an @ symbol.

00:00:45.310 --> 00:00:47.210
This is called a decorator in Python.

00:00:47.210 --> 00:00:50.718
This decorator essentially wraps our
function inside the app.route function

00:00:50.718 --> 00:00:52.560
that Flask has already created.

00:00:52.560 --> 00:00:54.840
So if either of these routes
get sent from the browser,

00:00:54.840 --> 00:00:57.340
the function that we
define here gets executed.

00:00:57.340 --> 00:00:59.420
If this is difficult to follow,
it's okay.

00:00:59.420 --> 00:01:01.970
I'll provide a link in the instructor
notes if you're interested in learning

00:01:01.970 --> 00:01:03.695
more about decorator functions.

00:01:03.695 --> 00:01:06.675
Just know that this
@app.route piece of code

00:01:06.675 --> 00:01:09.185
will call the function that
follows it whenever the web server

00:01:09.185 --> 00:01:12.045
receives a request with a URL
that matches its argument.

00:01:12.045 --> 00:01:16.570
So in this case, if we visit the root
of my site at local host port 5000 or

00:01:16.570 --> 00:01:20.808
local host port 5000/hello, this
HelloWorld function will be invoked.

00:01:20.808 --> 00:01:23.280
Inside my HelloWorld function,

00:01:23.280 --> 00:01:26.082
I return the message I want to
display to the user's browser.

00:01:26.082 --> 00:01:28.160
Jumping to the last line of our code,

00:01:28.160 --> 00:01:31.380
I use the run function to run
the local server with our application.

00:01:31.380 --> 00:01:34.860
The if statement here makes sure
the server only runs if the script is

00:01:34.860 --> 00:01:37.630
executed directly from
the Python interpreter, and

00:01:37.630 --> 00:01:39.450
not used as an imported module.

00:01:39.450 --> 00:01:41.550
So basically, this line of code says,

00:01:41.550 --> 00:01:44.900
if you're executing me with
the Python interpreter, then do this.

00:01:44.900 --> 00:01:48.590
But if you're importing me into
another Python file don't do this, but

00:01:48.590 --> 00:01:50.840
you still have access to
the rest of the code.

00:01:50.840 --> 00:01:54.110
By default, the server is only
accessible from the host machine and

00:01:54.110 --> 00:01:55.560
not from any other computer.

00:01:55.560 --> 00:01:57.960
This is the default
because in debugging mode,

00:01:57.960 --> 00:02:02.080
a user of the application can execute
arbitrary Python code on your computer.

00:02:02.080 --> 00:02:05.820
Since we're using a vagrant environment
for this course, we must make our server

00:02:05.820 --> 00:02:09.810
publicly available by changing the call
of the run method to look like this.

00:02:09.810 --> 00:02:13.220
This tells the web server on my vagrant
machine to listen on all public

00:02:13.220 --> 00:02:14.400
IP addresses.

00:02:14.400 --> 00:02:17.480
Restarting our server each time we
make a modification to our code

00:02:17.480 --> 00:02:20.478
can get pretty annoying but
Flask can take care of this for us.

00:02:20.478 --> 00:02:23.510
If you enable debug support
the server will reload itself

00:02:23.510 --> 00:02:24.860
each time it notices a code change.

00:02:24.860 --> 00:02:28.000
It will also provide you a helpful
debugger in the browser if

00:02:28.000 --> 00:02:29.230
things go wrong.

00:02:29.230 --> 00:02:33.050
I'll save this code as project.py in the
same directory as my restaurant menu db

00:02:33.050 --> 00:02:35.950
file and
execute it with the Python interpreter.

00:02:35.950 --> 00:02:38.083
Visiting localhost port 500, or

00:02:38.083 --> 00:02:42.070
localhost port 5000/hello,
I see the output of my code.

00:02:42.070 --> 00:02:44.460
To stop the server, I hit Ctrl+C.

00:02:44.460 --> 00:02:46.450
So we see that with much
fewer lines of code,

00:02:46.450 --> 00:02:49.700
I executed a similar version of
our Hello World from lesson two.

00:02:49.700 --> 00:02:52.320
Notice that with Flask we don't
have to explicitly write out

00:02:52.320 --> 00:02:53.190
response codes anymore.

00:02:53.190 --> 00:02:55.790
You will soon see that this
is just one of the several

00:02:55.790 --> 00:02:58.620
features frameworks take care of
automatically for the developer.

