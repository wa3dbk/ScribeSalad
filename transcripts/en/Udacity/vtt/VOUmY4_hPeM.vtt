WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:02.300
So why is building software matter?

00:00:02.300 --> 00:00:04.850
Historically, it used to be that
building was just compiling and

00:00:04.850 --> 00:00:06.170
packing your source code.

00:00:06.170 --> 00:00:08.900
Today, builds are responsible for
so much more.

00:00:08.900 --> 00:00:12.170
They run our tests, can buy coded
resources from multiple sources,

00:00:12.170 --> 00:00:14.980
generate documentation,
create multiple build variance,

00:00:14.980 --> 00:00:17.640
publish our applications,
and manage dependencies.

00:00:17.640 --> 00:00:20.750
Because of this, the build has
become the software factory,

00:00:20.750 --> 00:00:24.270
in which we can continually change,
test, and release our apps.

00:00:24.270 --> 00:00:26.680
Think of Gradle as the one stop shop for
defining and

00:00:26.680 --> 00:00:29.700
integrating all the parts of
your software delivery process.

00:00:29.700 --> 00:00:33.580
For example, for Gradle users, the
process that executes the modern IDs,

00:00:33.580 --> 00:00:35.220
like Android studio, or

00:00:35.220 --> 00:00:39.100
CI front end products like Jenkins,
is all defining Gradle.

00:00:39.100 --> 00:00:41.900
In this day and age,
an app store Android developer unable to

00:00:41.900 --> 00:00:46.610
ship changes into production faster and
faster will fail behind the competition,

00:00:46.610 --> 00:00:50.200
in the end automation is
the key to making this happen.

00:00:50.200 --> 00:00:52.070
So why Gradle?

00:00:52.070 --> 00:00:55.820
The biggest reason is that Google has
selected Gradle as the build system for

00:00:55.820 --> 00:00:57.250
Android Studio.

00:00:57.250 --> 00:01:00.110
In fact, Android Studio
delegates the entire process of

00:01:00.110 --> 00:01:02.130
building Android Apps to Gradle.

00:01:02.130 --> 00:01:05.410
When I hit the run button, Android
Studio just sets Gradle in motion and

00:01:05.410 --> 00:01:06.980
sits back to watch.

00:01:06.980 --> 00:01:09.930
By learning about Gradle,
we can extend this default behavior

00:01:09.930 --> 00:01:13.070
to build even more and more capable and
well tested Android apps.

00:01:14.200 --> 00:01:16.810
Obviously, Google is full
of very smart engineers.

00:01:16.810 --> 00:01:19.400
And one measure of their smarts is
that they felt they didn't need to

00:01:19.400 --> 00:01:21.580
reinvent the wheel with build systems.

00:01:22.730 --> 00:01:26.370
Gradle solves some the most hard
problems faced by Android developers.

00:01:26.370 --> 00:01:30.280
How to automate building and testing
apps to achieve rapid productivity.

00:01:30.280 --> 00:01:32.020
And how to manage dependencies and

00:01:32.020 --> 00:01:34.960
variations that allow professional
developers to pump out

00:01:34.960 --> 00:01:39.570
dozens of variances of their apps with
one click, or build a suite of apps and

00:01:39.570 --> 00:01:42.510
deal officially with
apps that are very large.

00:01:42.510 --> 00:01:45.390
Another key insight is that
many Android developers work in

00:01:45.390 --> 00:01:46.950
header genius environments.

00:01:46.950 --> 00:01:49.873
With differing and
complex technology stacks,

00:01:49.873 --> 00:01:53.100
Gradle is the dominant multi
platform build system.

00:01:53.100 --> 00:01:55.130
Other strengths of Gradle
include the compact and

00:01:55.130 --> 00:01:57.870
powerful build language used
to write its build scripts and

00:01:57.870 --> 00:02:00.920
the rich domain model that allows
Gradle to reason about your build.

