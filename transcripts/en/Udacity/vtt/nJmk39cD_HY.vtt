WEBVTT
Kind: captions
Language: en

00:00:00.720 --> 00:00:03.240
Some of the posts on which I
have photos along with them,

00:00:03.240 --> 00:00:05.290
we want to cache those too.

00:00:05.290 --> 00:00:08.310
At the moment we're only caching
resources at install time.

00:00:08.310 --> 00:00:12.220
Whereas appear over the lifetime
of the app with the posts.

00:00:12.220 --> 00:00:14.420
So we want to cache
photos as they appear.

00:00:14.420 --> 00:00:17.570
We could put these photos in IDB
along with the rest of the post data.

00:00:17.570 --> 00:00:20.130
But that means we need to
read the pixel data and

00:00:20.130 --> 00:00:23.190
convert it into a blob
that's kind of complicated.

00:00:23.190 --> 00:00:26.050
It also loses streaming,
which has a performance impact.

00:00:27.430 --> 00:00:30.520
When we get an item from a database,
we have to take the whole thing out in

00:00:30.520 --> 00:00:34.410
one lump, then convert it into image
data, then add it to the page.

00:00:35.410 --> 00:00:39.280
Whereas if we get the image from
a cache, it will stream the data.

00:00:39.280 --> 00:00:42.480
So we don't need to wait for the whole
thing before we display anything.

00:00:43.490 --> 00:00:45.040
This is more memory efficient and

00:00:45.040 --> 00:00:48.770
leads to faster renders, even if
the data is coming from the disk.

00:00:48.770 --> 00:00:51.510
For that reason,
the cache API is a much better fit.

00:00:52.700 --> 00:00:55.150
But since we're into the advanced
stages of the course,

00:00:55.150 --> 00:00:57.700
I haven't made this
totally straightforward.

00:00:57.700 --> 00:01:00.830
Here's the code for the image,
it's a responsive image,

00:01:00.830 --> 00:01:03.720
because images can appear at
a variety of different widths,

00:01:03.720 --> 00:01:06.980
this responsive image let's the browser
decide which image to load

00:01:06.980 --> 00:01:10.640
based on the width of the window and
also the network conditions.

00:01:10.640 --> 00:01:13.210
So when the post error arrives
through the web socket,

00:01:13.210 --> 00:01:15.180
which version do we cache?

00:01:15.180 --> 00:01:18.460
Well we wait until the browser
makes the request.

00:01:18.460 --> 00:01:20.950
Then we hear about it
in the service worker.

00:01:20.950 --> 00:01:21.880
We go to the network for

00:01:21.880 --> 00:01:25.770
the image and once we get a response,
we put it in the cache.

00:01:25.770 --> 00:01:28.740
But the same time we
send it on to the page.

00:01:28.740 --> 00:01:31.420
Note that we put the image into
a separate cache to the rest of

00:01:31.420 --> 00:01:33.050
the static content.

00:01:33.050 --> 00:01:36.930
We reset the content of our static cache
whenever we update our JavaScript or

00:01:36.930 --> 00:01:40.610
CSS, but we want these photos to
live between versions of our app.

00:01:41.750 --> 00:01:43.010
Next time we get a request for

00:01:43.010 --> 00:01:46.170
an image that we already have cached,
we simply return it.

00:01:47.260 --> 00:01:50.230
But here's the trick,
we'll return image from the cache

00:01:50.230 --> 00:01:53.906
even if the browser requests
a different size of the same image.

00:01:53.906 --> 00:01:57.340
Post on are short lived, so if
the browser requests a bigger version of

00:01:57.340 --> 00:02:01.290
the same image returning a smaller one
from the cache isn't really a problem.

00:02:02.440 --> 00:02:05.590
Returning a bigger image then
the one the browns asked for

00:02:05.590 --> 00:02:09.250
that's perfectly fine too We're not
wasting bandwidth by doing that.

00:02:09.250 --> 00:02:12.400
In fact, getting a smaller version
of something we already have cached,

00:02:12.400 --> 00:02:14.650
that would be a waste of bandwidth.

00:02:14.650 --> 00:02:16.810
Also this resizing windows back and

00:02:16.810 --> 00:02:19.371
forth, it's only really
something web developers do.

00:02:20.420 --> 00:02:23.580
We've covered most of the APIs you
need to be able to cache images,

00:02:23.580 --> 00:02:25.530
there's only one thing left to cover.

00:02:25.530 --> 00:02:28.850
You can only use the body of a response,
once.

00:02:28.850 --> 00:02:34.230
As in, if you read the responses json,
you cannot then read it as a blob, this

00:02:34.230 --> 00:02:38.930
is because the original data has gone,
keeping it in memory would be a waste.

00:02:38.930 --> 00:02:42.460
Also respondWith uses the body
of the response as well.

00:02:42.460 --> 00:02:44.030
So you cannot later read it again.

00:02:45.040 --> 00:02:48.490
In most cases, this is great because if
the response was like a free gigabyte

00:02:48.490 --> 00:02:50.960
video going to a video
element on the page,

00:02:50.960 --> 00:02:54.060
the browser doesn't need to keep
the whole free gigabytes in memory.

00:02:54.060 --> 00:02:55.070
It only needs to keep the bit,

00:02:55.070 --> 00:02:57.900
it's currently playing plus
a little bit extra for buffering.

00:02:59.030 --> 00:03:00.640
However, this is a problem for

00:03:00.640 --> 00:03:04.565
our photos, we want to open a cache,
fetch from the network, and

00:03:04.565 --> 00:03:08.315
send the response to both the cache and
back to the browser.

00:03:08.315 --> 00:03:11.145
Using the body twice
like this doesn't work.

00:03:11.145 --> 00:03:14.595
But we can fix this by cloning
the response we send to the cache.

00:03:15.615 --> 00:03:20.035
So now a clone goes to the cache, and
the original gets sent back to the page.

00:03:20.035 --> 00:03:23.065
The browser keeps enough of
the original request around to satisfy

00:03:23.065 --> 00:03:23.955
all of the clones.

