WEBVTT
Kind: captions
Language: en

00:00:00.260 --> 00:00:04.210
During dispatch, we haven't consider a situation when more than one instruction

00:00:04.210 --> 00:00:08.820
is ready to execute. So let's do that. So here's a situation where we have

00:00:08.820 --> 00:00:13.910
a similar broadcast to the previous case where we have reorganization station 1

00:00:13.910 --> 00:00:18.940
is broadcasting these out of minus 0.29. So we're still going to

00:00:18.940 --> 00:00:23.600
free a reservation station 1 as before. We will still going to capture all of

00:00:23.600 --> 00:00:29.400
the results that hasn't changed. So here we're going to match minus 0.29.

00:00:29.400 --> 00:00:34.450
This doesn't need to match anything. Here because we already have a value.

00:00:34.450 --> 00:00:39.300
Here we're going to also latch zero point twenty nine, and here we're going to

00:00:39.300 --> 00:00:43.640
do the same thing. But now we have a situation where for the multiplication and

00:00:43.640 --> 00:00:47.290
divide unit it's pretty clear that this the instruction that gets to execute. So

00:00:47.290 --> 00:00:50.975
this is easy. But here, we have to choose between one of these two.

00:00:50.975 --> 00:00:54.805
Because assuming that the adder can only handle one instruction per cycle.

00:00:54.805 --> 00:00:59.410
We need to pick one of these. And, now we have to figure out which one.

00:00:59.410 --> 00:01:02.150
So there needs to be some logic that's going to pick one of these instructions,

00:01:02.150 --> 00:01:06.410
because both of them cannot go. Now we need to figure out, you know, are there

00:01:06.410 --> 00:01:10.400
any good rules about which one should go first? So our question is basically,

00:01:10.400 --> 00:01:16.860
should we dispatch RS1 or RS2? Well, ideally we will dispatch that instruction

00:01:16.860 --> 00:01:21.610
that allows us to kind of get to future instructions as early as possible. So

00:01:21.610 --> 00:01:24.790
basically we would choose the instruction that leads to the highest performance.

00:01:24.790 --> 00:01:27.990
Unfortunately that requires knowledge of the future.

00:01:27.990 --> 00:01:32.250
And this is something that hardware is pretty bad at doing.

00:01:32.250 --> 00:01:35.386
Because we only can really look here at these instructions here.

00:01:35.386 --> 00:01:38.534
And maybe the next couple of instructions in the instruction queue.

00:01:38.534 --> 00:01:41.374
While in reality the situation might change, for

00:01:41.374 --> 00:01:46.060
example this instruction. Might have a lot of dependent instructions later on,

00:01:46.060 --> 00:01:49.970
and this one might have a few. But we don't know that until we see those a lot

00:01:49.970 --> 00:01:54.290
of instructions later on. So, it's very difficult to decide that based on kind

00:01:54.290 --> 00:01:59.510
of perfect knowledge of the future. So, how do we choose these instructions?

00:01:59.510 --> 00:02:03.160
Well, there are some heuristics. We can not really do a perfect job of it, but

00:02:03.160 --> 00:02:08.020
we can make some reasonably good guesses. One choice that usually makes a lot of

00:02:08.020 --> 00:02:11.460
sense is oldest first. So pretty much whichever, whichever of these instructions

00:02:11.460 --> 00:02:16.130
has been sitting here longer will be allowed to go first. Why? Well because for

00:02:16.130 --> 00:02:20.020
an older instruction all other things being equal, it's more likely that more

00:02:20.020 --> 00:02:23.620
instructions are by now waiting for it. Simply you know, if an instruction is

00:02:23.620 --> 00:02:28.874
older. By now you could have seen more instructions that will use it's values.

00:02:28.874 --> 00:02:32.526
And also this allows us to kind of, you know, mark of some instructions as done.

00:02:32.526 --> 00:02:36.430
So basically oldest first is a typical heuristic that gets done this way.

00:02:36.430 --> 00:02:39.710
Another one that could be used is something like most dependencies first where

00:02:39.710 --> 00:02:44.170
we will check. How many other instructions need the value from each one of

00:02:44.170 --> 00:02:48.410
these. And then use the one, I mean, you know, dispatch the one that will,

00:02:48.410 --> 00:02:51.650
that will can free up more, the most of the other instructions. But

00:02:51.650 --> 00:02:54.920
this one would be very, this, how would I say, would be difficult to implement.

00:02:54.920 --> 00:02:57.800
Because we have to actually like search a lot of stuff,

00:02:57.800 --> 00:03:01.440
which is going to be very power hungry and so on. So typically,

00:03:01.440 --> 00:03:06.243
if we do anything, we will just do the oldest first. Another choice would be,

00:03:06.243 --> 00:03:09.513
to just randomly select the instruction. Like for example, whichever is

00:03:09.513 --> 00:03:12.542
comes first in order of preservation stations or something like that. So

00:03:12.542 --> 00:03:16.378
something that has nothing to do with their age in the preservation station, or

00:03:16.378 --> 00:03:20.790
whoever has most dependencies. This strategy also works because, note that.

00:03:20.790 --> 00:03:25.443
If we don't send the oldest first, we will eventually run out of things to do.

00:03:25.443 --> 00:03:27.836
Because all of the things will depend on the oldest instruction,

00:03:27.836 --> 00:03:31.206
at which point it will rot. So basically, it's not a problem regarding

00:03:31.206 --> 00:03:34.434
correctness if we choose something other than oldest first or

00:03:34.434 --> 00:03:38.530
dependence first. It's just an issue of kind of what works reasonably well. So

00:03:38.530 --> 00:03:43.010
typically, all this first does help somewhat with like releasing instructions.

00:03:43.010 --> 00:03:48.060
&gt;From here, while, you know, random is okay as far as just, you know,

00:03:48.060 --> 00:03:51.800
correctness is concerned. So pretty much anyone of these three would work.

00:03:51.800 --> 00:03:54.734
It's just a matter of, you know, which one would lead to the best performance.

00:03:54.734 --> 00:03:58.620
And we kind of choose an oldest first as a kind of compromise between,

00:03:58.620 --> 00:04:03.270
what we have to look at. And you know what gives us good performance. So

00:04:03.270 --> 00:04:05.660
would random give us kind of the worse performance, and

00:04:05.660 --> 00:04:08.600
this would give us the best performance. But this is kind of easy to do so

00:04:08.600 --> 00:04:09.990
we kind of compromise between the two.

