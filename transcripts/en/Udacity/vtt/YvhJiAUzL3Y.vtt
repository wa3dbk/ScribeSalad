WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:04.263
A common use for loops is in programs that simulate some activity, such as

00:00:04.263 --> 00:00:10.141
customers in a supermarket, cars on a road, particles in a physical system. And

00:00:10.141 --> 00:00:13.789
in such simulations you want to have a degree of randomness, just to model how

00:00:13.789 --> 00:00:19.112
the real world works. For example, some random time might elapse. Until the

00:00:19.112 --> 00:00:23.010
next customer arrives, or the customer might buy a random number of articles.

00:00:23.010 --> 00:00:27.362
So let me show you how to generate random numbers in Java. You construct an

00:00:27.362 --> 00:00:30.670
object of the Random class. And then you can ask it to give you another

00:00:30.670 --> 00:00:35.085
integer. You have to give it an upper limit, and you get an integer between

00:00:35.085 --> 00:00:40.696
zero and n minus one. You can also generate a random floating point number, and

00:00:40.696 --> 00:00:45.065
then you always get a number that's at least zero but less than one. Let me

00:00:45.065 --> 00:00:49.528
show you the random number generator in blue jay. let's make an object by going

00:00:49.528 --> 00:00:53.554
to the tools menu, use library class, and here in the class field we type in

00:00:53.554 --> 00:00:59.689
java.util .random and hit the Enter key. Select this constructor and here we

00:00:59.689 --> 00:01:04.825
have a random number generator. Let's ask it for next double, and we get .05

00:01:04.825 --> 00:01:09.925
and change and that looks pretty random. Next time when we ask it we get a

00:01:09.925 --> 00:01:15.460
different random number, .19 and so on. For integers we'll pick this method

00:01:15.460 --> 00:01:20.356
over here. We asked for an upper bound and now get a number between zero and

00:01:20.356 --> 00:01:26.084
999. In this case I get 781. When I do it again I get a different number. Of

00:01:26.084 --> 00:01:29.926
course every once in awhile I might get the same number twice. It's random. Now

00:01:29.926 --> 00:01:33.840
I'll let you play with this. We want to simulate a die and that we get random

00:01:33.840 --> 00:01:38.056
numbers between one and six. Or actually we might as well model a die with an

00:01:38.056 --> 00:01:41.631
arbitrary number of sides, and your job is to implement the cast method so that

00:01:41.631 --> 00:01:47.946
every time that. It's called, it returns a different number between one and the

00:01:47.946 --> 00:01:53.625
number of sides of the die. There's just a catch. You're going to have to call

00:01:53.625 --> 00:01:57.915
the next int method, which naturally gives you numbers between zero and n minus

00:01:57.915 --> 00:02:02.404
one. You want numbers from one to n and I'll leave it to you to figure out how

00:02:02.404 --> 00:02:07.737
to change one to the other. Has the construction parameter for debugging it's

00:02:07.737 --> 00:02:13.452
handy to give the random number generator what's called a seed. And as long as

00:02:13.452 --> 00:02:17.916
you seed a generator with a particular value, then it gives always the same

00:02:17.916 --> 00:02:23.256
stream of seemingly random numbers. Here we're using a fixed seed, so that you

00:02:23.256 --> 00:02:27.033
and I get the same answers. And practical applications, people do all sorts of

00:02:27.033 --> 00:02:31.398
things for a seeding, such as using the time of day. Or when true randomness is

00:02:31.398 --> 00:02:35.351
desired, they actually have a white noise generator attached to their computer

00:02:35.351 --> 00:02:39.850
and sample it, so go ahead and implement the cast method.

