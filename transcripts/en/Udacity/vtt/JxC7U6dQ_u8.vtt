WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:05.810
So we have talked about buffer
overflows and how programs that have

00:00:05.810 --> 00:00:10.910
this vulnerability can get exploited, in
particular letting attackers or giving

00:00:10.910 --> 00:00:16.720
them the ability to execute arbitrary
code with the host services privileges.

00:00:16.720 --> 00:00:18.400
It's not a good thing.

00:00:18.400 --> 00:00:21.670
We shouldn't write code that
has those vulnerabilities, but

00:00:21.670 --> 00:00:26.880
if such code is out there deployed
on systems, we need to find ways to

00:00:26.880 --> 00:00:31.780
defend against attacks that are going to
exploit these kind of vulnerabilities.

00:00:31.780 --> 00:00:34.680
So we're going to talk
about a number of defenses

00:00:34.680 --> 00:00:40.290
that help us counter attacks that
rely on these buffer overflows.

00:00:40.290 --> 00:00:44.870
The first one we're going to talk about
is your choice of programming language.

00:00:44.870 --> 00:00:47.690
What language are you
writing your program in?

00:00:47.690 --> 00:00:51.730
There are actually going to be languages
where this kind of problem goes away,

00:00:51.730 --> 00:00:53.405
you don't have buffer overflows.

00:00:53.405 --> 00:00:59.150
And these languages are languages
that are strongly typed, that do lot

00:00:59.150 --> 00:01:03.560
of memory management they do automatic
automatically, so they do bounds check.

00:01:03.560 --> 00:01:07.670
Remember one of the problems that we had
was that we declared a string variable

00:01:07.670 --> 00:01:11.540
of size 12 and
we said you can read any amount into it.

00:01:11.540 --> 00:01:15.810
There is no way unless I
explicitly inserted a check,

00:01:15.810 --> 00:01:19.990
the language didn't do that, unless I
explicitly inserted a check that said

00:01:19.990 --> 00:01:22.610
giving it more than 12 bites,
that's not good.

00:01:22.610 --> 00:01:25.460
The language didn't
stop me from clobbering

00:01:25.460 --> 00:01:29.110
whatever was next to
the password string that we had.

00:01:29.110 --> 00:01:30.648
Not all languages do that.

00:01:30.648 --> 00:01:34.620
There are languages that say you
have an object of size this,

00:01:34.620 --> 00:01:37.170
this is how much it could be,
it can't be any more.

00:01:37.170 --> 00:01:41.740
So what type of variable it is,
how much memory is required for

00:01:41.740 --> 00:01:45.990
it or is allocated to it, and how much
memory you can access when you access

00:01:45.990 --> 00:01:48.730
that variable, this bounds
check that we're talking about.

00:01:48.730 --> 00:01:51.480
And if you manage this
memory automatically,

00:01:51.480 --> 00:01:54.270
the problem of memory overflow,

00:01:54.270 --> 00:01:59.770
or abusing memory the way we did when we
have buffer overflows, that goes away.

00:01:59.770 --> 00:02:03.245
So, languages that do
are called safe languages,

00:02:03.245 --> 00:02:08.264
because you can rely on type safety and
you don't make these kind of mistakes.

00:02:08.264 --> 00:02:14.250
So there are several examples of these
languages, Java, C++, and others.

00:02:14.250 --> 00:02:20.244
So if you write code in these kind of
languages that have type safety and

00:02:20.244 --> 00:02:22.130
that do the kind of things
that we're talking about,

00:02:22.130 --> 00:02:24.710
buffer overflow would not be a problem.

00:02:24.710 --> 00:02:29.320
The buffer overflow typically
comes because we don't do

00:02:29.320 --> 00:02:33.350
either strong type checking or this
bounds checks that I was talking about,

00:02:33.350 --> 00:02:37.130
which is what low level kind of
languages are notorious for that.

00:02:37.130 --> 00:02:41.300
But these object oriented strongly typed
languages make that problem go away.

