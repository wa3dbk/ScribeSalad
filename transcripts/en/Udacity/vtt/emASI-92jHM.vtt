WEBVTT
Kind: captions
Language: en

00:00:00.310 --> 00:00:03.030
Accessing array elements
is straightforward.

00:00:03.030 --> 00:00:06.550
You can access a particular element
by referring to its row and

00:00:06.550 --> 00:00:09.330
column number inside
the square brackets.

00:00:09.330 --> 00:00:12.200
The first integer over here
denotes to the row number and

00:00:12.200 --> 00:00:15.940
the second integer denotes
to the column number.

00:00:15.940 --> 00:00:19.640
Let's see which element do
we get at position 3,2.

00:00:19.640 --> 00:00:25.450
Observe that the element we get
actually belongs to the fourth row and

00:00:25.450 --> 00:00:31.170
the tall column, but note that the row
and the column indexing start from zero.

00:00:31.170 --> 00:00:35.670
Hence if you want an element of
the fourth row and tall column,

00:00:35.670 --> 00:00:39.670
you pass the parameter as we did,
that is 3,2.

00:00:39.670 --> 00:00:44.660
Now let's do some interesting stuff,
accessing elements and ranges.

00:00:44.660 --> 00:00:47.560
If I would want to access
elements from first

00:00:47.560 --> 00:00:52.380
through third column in the zeroed row,
here is how I would do it.

00:00:52.380 --> 00:00:56.990
This operation is called slicing,
as explained before using data frame.

00:00:56.990 --> 00:00:59.400
Let's read out this slicing operation.

00:00:59.400 --> 00:01:01.210
For the 0 through,

00:01:01.210 --> 00:01:07.060
get values from first through third
column excluding the third column.

00:01:07.060 --> 00:01:08.070
Now let's run this.

00:01:09.320 --> 00:01:10.940
So here's the output.

00:01:10.940 --> 00:01:16.610
For the 0 through, first through the
third column excluding the third column.

00:01:16.610 --> 00:01:18.570
This was just column slicing.

00:01:18.570 --> 00:01:23.390
We can combine row and column slicing
and get a subset of the array.

00:01:23.390 --> 00:01:27.310
If I would like to access the top
left corner of the array,

00:01:27.310 --> 00:01:29.980
I would do this as follows.

00:01:29.980 --> 00:01:35.060
We can combine row and column slicing
and get the subset of the array.

00:01:36.200 --> 00:01:41.316
Here is the top left corner,
which has elements at position 0,

00:01:41.316 --> 00:01:44.270
0, 0, 1, 1, 0, and 1, 1.

00:01:44.270 --> 00:01:46.730
One last interesting thing in slicing,

00:01:46.730 --> 00:01:49.770
which I would like to
bring in front of you.

00:01:49.770 --> 00:01:54.630
You see a lot of numbers over here,
so let's break it down and read it.

00:01:54.630 --> 00:01:59.980
The three number separated by the colon,
this is not accessing the tall access.

00:01:59.980 --> 00:02:04.650
But a slicing of the form,
n is to m is to t,

00:02:04.650 --> 00:02:10.710
will give you values in the range n
before m, but in steps of size t,

00:02:10.710 --> 00:02:14.730
hence this statement will give
you values of the column 0.

00:02:14.730 --> 00:02:19.630
Skip the values of the column one, and
then give the values of the column 2.

00:02:19.630 --> 00:02:20.760
Let's run this.

00:02:21.870 --> 00:02:27.010
As explained, you get the 0, and
the second column with all the rows.

00:02:27.010 --> 00:02:28.290
Seems like magic, right?

