WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:04.566
If you never wrote any program in Python, here is

00:00:04.566 --> 00:00:09.654
some advice on the specifics of Python. If you

00:00:09.654 --> 00:00:12.439
know your way around Python simply skip this

00:00:12.439 --> 00:00:15.994
segment. To indicate that the rest of the line is

00:00:15.994 --> 00:00:19.947
a comment, simply put a # in front of that line

00:00:19.947 --> 00:00:24.777
to create variables simply type the name and

00:00:24.777 --> 00:00:28.258
write equals whatever you want, you do not

00:00:28.258 --> 00:00:31.924
specific the type of a variable, unlike in C or

00:00:31.924 --> 00:00:36.056
in Java or in C++ or in C#, Python is

00:00:36.056 --> 00:00:39.875
going to figure out the type on its own, like

00:00:39.875 --> 00:00:42.441
Javascript if you will. So that’s an allowed name.

00:00:42.441 --> 00:00:46.326
answer = 42, radius underscore of underscore earth

00:00:46.326 --> 00:00:52.869
is an allowed name, 6.371 times 10 to the 6.

00:00:52.869 --> 00:00:58.012
I’m writing comment M to say meters

00:00:58.012 --> 00:01:00.961
by just simplest way of indicating what the

00:01:00.961 --> 00:01:03.386
measurement unit would be. And you must not

00:01:03.386 --> 00:01:08.028
start names with digits: 13test, too is not a

00:01:08.028 --> 00:01:11.107
correct name. The print command, print out,

00:01:11.107 --> 00:01:14.562
what you’ve given after it, very simple. If you

00:01:14.562 --> 00:01:17.120
want to specify more things, simply use commas.

00:01:17.120 --> 00:01:20.579
This now shows some basic arithmetic’s advantage
I wrote it first

00:01:20.579 --> 00:01:24.228
for us to discuss the results. 42 is assigned to

00:01:24.228 --> 00:01:29.504
answer, 6.37 something times 10 to the 6 is

00:01:29.504 --> 00:01:32.629
assigned to radius underscore of underscore earth,

00:01:32.629 --> 00:01:36.385
now we do some computation of three times

00:01:36.385 --> 00:01:40.102
answer plus four and the result is assigned to a

00:01:40.102 --> 00:01:44.659
variable called A. Note that multiplication and

00:01:44.659 --> 00:01:48.363
division are executed before plus and minus.

00:01:48.363 --> 00:01:50.819
Now we take the radius of earth to the second

00:01:50.819 --> 00:01:54.504
power. Asteric asteric (**) represents the power

00:01:54.504 --> 00:01:58.395
operator in Python unlike C, unlike Java.

00:01:58.395 --> 00:02:02.273
Parenthesis work as they work in school and

00:02:02.273 --> 00:02:05.920
again the power operator 0.5 of course meaning

00:02:05.920 --> 00:02:08.151
this is the square root, that’s one way of

00:02:08.151 --> 00:02:12.394
writing this square root of A+3, the result

00:02:12.394 --> 00:02:14.749
is assigned to B. See this is what our output

00:02:14.749 --> 00:02:18.330
here. The second one gets pretty ugly. The

00:02:18.330 --> 00:02:21.664
content of answer is incremented by seven.

00:02:21.664 --> 00:02:24.864
Plus equals seven, that’s the same as in C and

00:02:24.864 --> 00:02:27.676
in Java and in Javascript. The increment operates

00:02:27.676 --> 00:02:31.558
on the same work for minus equals time equals

00:02:31.558 --> 00:02:34.904
divided equals. What you can’t do is plus, plus

00:02:34.904 --> 00:02:38.427
unlike C and its sibling. If you want to do plus

00:02:38.427 --> 00:02:41.760
plus you have to write plus equals one. This again

00:02:41.760 --> 00:02:44.818
is similar to C, if you divide integer numbers

00:02:44.818 --> 00:02:48.501
five divided by four, the result is an integer

00:02:48.501 --> 00:02:51.608
number. let's look at up. C is the fourth one

00:02:51.608 --> 00:02:57.086
one, two, three, four.. 1... 5 / 4 is 1

00:02:57.086 --> 00:03:01.241
in Python as is for C and for Java and so on.

00:03:01.241 --> 00:03:03.385
If you want to see a floating point division at

00:03:03.385 --> 00:03:05.602
least one of these two numbers has to be of

00:03:05.602 --> 00:03:08.600
floating point numbers, simply write 4. (i.e., 4 dot)

00:03:08.600 --> 00:03:15.677
d.. Let's look at the second to last.. 1.25.. it works.. or 1.0

00:03:15.677 --> 00:03:20.108
times five divided by 4, Python starts from the

00:03:20.108 --> 00:03:26.499
left as does C, as does Java 1.0 times five is

00:03:26.499 --> 00:03:28.782
a floating point number that’s divided by the

00:03:28.782 --> 00:03:31.835
integer number results of floating point number.

00:03:31.835 --> 00:03:35.216
Keep that in mind, there is something that easy

00:03:35.216 --> 00:03:38.413
leads to not so obvious errors. There is more to

00:03:38.413 --> 00:03:41.650
mathematics than arithmetic’s. To do more we

00:03:41.650 --> 00:03:44.981
need to import the math library. This is

00:03:44.981 --> 00:03:47.965
done best at the start of a program when we need

00:03:47.965 --> 00:03:51.157
the square root, we then can then write math.sqrt(4)

00:03:51.157 --> 00:03:53.602
which actually is the

00:03:53.602 --> 00:03:57.850
same as four asteric asteric 0.5, if we need the sin

00:03:57.850 --> 00:04:02.230
function its math.sin parenthesis, the angle.

00:04:02.230 --> 00:04:05.274
Of course this angle is specified in radians,

00:04:05.274 --> 00:04:09.441
not in angular degrees. To convert from angular

00:04:09.441 --> 00:04:12.800
degrees to radians multiplie by pi - math.pi,

00:04:12.800 --> 00:04:17.322
it’s a built-in constant, divided by 180.

00:04:17.322 --> 00:04:20.887
If lines get longer, we may need to break the line

00:04:20.887 --> 00:04:23.974
to keep it readable, if there is an open

00:04:23.974 --> 00:04:27.107
parenthesis, you can break at any point then

00:04:27.107 --> 00:04:30.185
sometime close that parenthesis. If lines get

00:04:30.185 --> 00:04:33.114
longer, we may need to break them to make

00:04:33.114 --> 00:04:35.999
things – to keep things readable. Python is picky

00:04:35.999 --> 00:04:40.258
about lines. You cannot break anywhere; that’s

00:04:40.258 --> 00:04:43.665
unlike C and Java. But if there is an open

00:04:43.665 --> 00:04:47.439
parenthesis you can break anywhere. Python

00:04:47.439 --> 00:04:50.662
is going to wait for that closing parenthesis.

00:04:50.662 --> 00:04:53.138
For the standard mathematical functions, such as

00:04:53.138 --> 00:04:56.080
square root and sign, we need to import the

00:04:56.080 --> 00:04:59.813
math library. This is done best at the beginning

00:04:59.813 --> 00:05:03.471
of a program and then you invoke the square

00:05:03.471 --> 00:05:07.269
root for instance by typing math.square root and

00:05:07.269 --> 00:05:10.824
the argument is given in parenthesis. That’s

00:05:10.824 --> 00:05:14.297
pretty similar to Java and to C#. The result,

00:05:14.297 --> 00:05:17.532
of course, is 2.0. We could also have written four

00:05:17.532 --> 00:05:22.242
to the 0.5 power. The sin function is math.sin.

00:05:22.242 --> 00:05:25.367
The cosine would be math.cos and so on. The

00:05:25.367 --> 00:05:29.724
constant pi is included as math.pi. The sin

00:05:29.724 --> 00:05:33.718
function and it's friends work with radians,

00:05:33.718 --> 00:05:38.581
not with angular degrees. So if 23.4 is an angular

00:05:38.581 --> 00:05:41.857
degrees, we need to convert it. For instance, by

00:05:41.857 --> 00:05:46.388
multiplying with pi and dividing by 180. If lines

00:05:46.388 --> 00:05:49.506
get longer, you may want to break them to keep

00:05:49.506 --> 00:05:52.225
things readable, Python is picky about line

00:05:52.225 --> 00:05:56.573
breaks. That’s very much unlike C and Java. You

00:05:56.573 --> 00:06:00.311
cannot break a line at any place, but if there

00:06:00.311 --> 00:06:02.291
is at least one open parenthesis, you can

00:06:02.291 --> 00:06:04.884
break the line. This is what I’m using here.

00:06:04.884 --> 00:06:07.712
If you need something to be done a given number

00:06:07.712 --> 00:06:12.262
of times, you can use the 'for' loop, which looks

00:06:12.262 --> 00:06:15.961
quite different from C. The first thing that you notice

00:06:15.961 --> 00:06:19.211
is a colon at the end, no braces, but a

00:06:19.211 --> 00:06:22.187
colon here, at the end of the first line, and

00:06:22.187 --> 00:06:25.328
indentation. The indentation and that colon

00:06:25.328 --> 00:06:28.288
replace what C users know as curly braces.

00:06:28.303 --> 00:06:34.093
What happens here? h starts with 0, gets 1,

00:06:34.093 --> 00:06:38.059
2 and so on and at the end its 6 and then the

00:06:38.059 --> 00:06:41.814
loop terminates. So you do not write 'for h =0;'

00:06:41.814 --> 00:06:47.284
and so on. h &lt; 7, you write 'for h in range 7'

00:06:47.284 --> 00:06:51.407
That’s the Python way. So if we look

00:06:51.407 --> 00:06:56.590
at the result... so it prints out square numbers

00:06:56.590 --> 00:07:02.625
starting with 0, and eventually terminating at 6

00:07:02.625 --> 00:07:05.236
to the second power. The 'while' loop is good for

00:07:05.236 --> 00:07:09.435
loops that run as long as something has to be done.

00:07:09.435 --> 00:07:13.430
So in this case, this loop runs as long as K is less

00:07:13.430 --> 00:07:21.566
than 130 or M is equal 140. So unlike C, you do

00:07:21.566 --> 00:07:27.155
not write '|| 4', you simply spell out 'or'. The same for &amp;&amp;.

00:07:27.155 --> 00:07:31.034
Don’t forget the colon, so

00:07:31.034 --> 00:07:35.657
we see that K runs up to 130, this first

00:07:35.657 --> 00:07:38.788
condition fails and the second one is not

00:07:38.788 --> 00:07:43.561
true either because M is 7,000 something.

00:07:43.561 --> 00:07:48.648
Now to conditional execution - if the value of K

00:07:48.648 --> 00:07:52.305
is larger than 42, don’t forget the colon,

00:07:52.305 --> 00:07:56.146
output 'Hi'. The text string and single quotes

00:07:56.146 --> 00:07:59.610
and 'elif' – that means if K was not larger than

00:07:59.610 --> 00:08:05.625
42, check if M is larger than 43. If so, output

00:08:05.625 --> 00:08:09.860
'Hello', if not which means if M is not larger than

00:08:09.860 --> 00:08:16.476
43, output "Buy". And of course K is larger than 42,

00:08:16.476 --> 00:08:19.920
its 130. So we output "Hi" and never see the rest.

00:08:19.920 --> 00:08:24.864
The 'else' is optional and the 'elif' is optional.

00:08:24.864 --> 00:08:28.469
We need to work with long lists of data. This

00:08:28.469 --> 00:08:31.877
package called numpy; it comes in handy, yeah.

00:08:31.877 --> 00:08:37.155
numpy.zeros creates a one dimensional array and this

00:08:37.155 --> 00:08:41.053
case with five entries numbered from 0 to 4, like in

00:08:41.053 --> 00:08:45.134
C. Here I change the entry number 0 and here

00:08:45.134 --> 00:08:48.310
I change the entry number 4, which is the last entry.

00:08:48.310 --> 00:08:50.913
I print the complete array and here I print the

00:08:50.913 --> 00:08:54.878
ultimate entry. This comes in very handy and is

00:08:54.878 --> 00:08:58.735
different from C and other languages. So the

00:08:58.735 --> 00:09:04.659
complete array contains 20,0,0,0,99 because I

00:09:04.659 --> 00:09:08.151
changed the entry number 0 and I changed the entry

00:09:08.151 --> 00:09:12.509
number 4. And the entry number if you will, minus

00:09:12.509 --> 00:09:16.077
1 is simply the last one. Often we do not get

00:09:16.077 --> 00:09:19.501
away with one dimensional lists, we’ve to use

00:09:19.501 --> 00:09:23.750
two dimensional tables. This creates a table

00:09:23.750 --> 00:09:29.263
that’s filled with 0s and has two rows and 3 columns.

00:09:29.263 --> 00:09:33.831
Here I change the entry that’s in the upper row,

00:09:33.831 --> 00:09:38.041
row number 0 and in the middle column, column

00:09:38.041 --> 00:09:43.729
number 1 (column is ranged from 0, 1 to 2) to 7.

00:09:43.729 --> 00:09:47.813
And here I change the entry in the lower row,

00:09:47.813 --> 00:09:51.313
the rows are 0 and 1 and in the right most

00:09:51.313 --> 00:09:57.127
column to 8, I output that. And then I do some

00:09:57.127 --> 00:10:00.659
arithmetic’s with matrices that is we’re

00:10:00.659 --> 00:10:03.260
going to cover that later, one plus twice

00:10:03.260 --> 00:10:05.976
the complete table that I built here.

00:10:05.976 --> 00:10:09.224
Let’s look at the output. So, that’s our array.

00:10:09.224 --> 00:10:15.462
0,7,0 is the row number 0. 0,0.8 is the row number 1.

00:10:15.462 --> 00:10:20.312
We changed the entry second column,

00:10:20.312 --> 00:10:23.950
row number 1 to 8. Thats this guy . And

00:10:23.950 --> 00:10:29.209
here I computed the one plus twice the array as

00:10:29.209 --> 00:10:34.439
above. The 7 becomes one plus two times 7,

00:10:34.439 --> 00:10:39.715
15, the 8 becomes one plus two times 8, 17.

00:10:39.715 --> 00:10:42.655
This again is something that you can’t do with

00:10:42.655 --> 00:10:45.841
regular arrays and C or in Java. This comes

00:10:45.841 --> 00:10:49.651
very handy for mathematics. And there is one

00:10:49.651 --> 00:10:52.565
more thing that resembles arrays in C and

00:10:52.565 --> 00:10:56.249
arrays in Java, if you think you copy that array,

00:10:56.249 --> 00:10:59.224
you didn’t actually create a copy, you just

00:10:59.224 --> 00:11:03.186
created a reference to the very same thing in

00:11:03.186 --> 00:11:07.206
memory. So yeah, it seem to create a copy Q

00:11:07.206 --> 00:11:12.724
equals P, I changed the copy to make the left

00:11:12.724 --> 00:11:16.904
– the top most left entry equal to 42. And then

00:11:16.904 --> 00:11:22.774
I output P and you see, if I look at P its too has the

00:11:22.774 --> 00:11:26.633
value 42 in here. There is just one instance

00:11:26.633 --> 00:11:30.549
of that array in memory; both Q and P refer to the

00:11:30.549 --> 00:11:34.549
same instance and memory.

00:11:34.549 --> 00:11:36.792
This is how we define functions in Python. We say def

00:11:36.792 --> 00:11:41.433
function name, the parameters that we want

00:11:41.433 --> 00:11:44.047
to hand over to the function, colon and

00:11:44.047 --> 00:11:46.575
then comes what the function should do.

00:11:46.575 --> 00:11:51.133
Again, of course, with indentation. And you call

00:11:51.133 --> 00:11:54.404
this function like you call math.sin and other

00:11:54.404 --> 00:11:57.457
build in functions: with parenthesis, similar to

00:11:57.457 --> 00:12:02.001
C and Java. So in this case U is set to 1,

00:12:02.001 --> 00:12:08.255
we compute two times U, R becomes 2

00:12:08.255 --> 00:12:12.563
and we return 2 plus 1 equals 3 and then

00:12:12.563 --> 00:12:16.530
this case its 7, U is set to 7, R becomes

00:12:16.530 --> 00:12:20.530
14 and we return 14 plus 7, that is 21.

