WEBVTT
Kind: captions
Language: en

00:00:00.550 --> 00:00:03.298
In this example, how can Git tell if B prime and

00:00:03.298 --> 00:00:05.837
B double prime are modified versions of B or

00:00:05.837 --> 00:00:10.158
if the users just deleted B and wrote entirely new lines in the same area?

00:00:10.158 --> 00:00:13.538
Rather than expending a lot of effort trying to figure this sort of thing out,

00:00:13.538 --> 00:00:17.150
Git just notes that the lines are different and goes from there.

00:00:17.150 --> 00:00:20.770
So how does Git know whether or not there should be a merge conflict?

00:00:20.770 --> 00:00:22.690
Consider the following two examples.

00:00:22.690 --> 00:00:26.460
In both cases, we start with two identical copies of the same file.

00:00:26.460 --> 00:00:27.720
In the first case,

00:00:27.720 --> 00:00:32.150
two different contributors add new functions to the bottom of the files.

00:00:32.150 --> 00:00:34.590
These are different functions that don't interact with each other and

00:00:34.590 --> 00:00:36.320
have nothing to do with one another.

00:00:36.320 --> 00:00:39.890
However, in the second case, two different contributors add

00:00:39.890 --> 00:00:44.630
different implementations of the same function with different names.

00:00:44.630 --> 00:00:48.320
In the first case, you pretty clearly want both functions to be included, but

00:00:48.320 --> 00:00:52.020
in the second situation, you probably only want one version of the function,

00:00:52.020 --> 00:00:54.370
probably whichever one is either more memory efficient or

00:00:54.370 --> 00:00:56.360
faster, depending on what you're going for.

00:00:56.360 --> 00:00:58.300
But Git can't really tell these two options apart.

00:00:58.300 --> 00:01:01.469
It would take some pretty sophisticated machine learning to do this.

00:01:01.469 --> 00:01:03.840
And this is only one possible scenario.

00:01:03.840 --> 00:01:07.045
Making Git smart enough to figure out all the possible cases where you'd want to

00:01:07.045 --> 00:01:09.220
auto-merge would be a huge undertaking.

00:01:09.220 --> 00:01:12.360
So instead, Git just assumes that if you're merging together two commits that

00:01:12.360 --> 00:01:16.660
have changes in the same general area, the authors will want to know about it

00:01:16.660 --> 00:01:19.720
and have the chance to figure out for themselves which change to keep.

00:01:19.720 --> 00:01:22.610
This decision to ask the user whenever there's any ambiguity at

00:01:22.610 --> 00:01:26.660
all does sometimes lead to situations where it seems really obvious to you,

00:01:26.660 --> 00:01:30.010
as an expert on the content, how to resolve the conflict.

00:01:30.010 --> 00:01:32.620
But Git brings it to your attention anyway.

00:01:32.620 --> 00:01:36.120
While this may be annoying, it's significantly better than if Git tried to

00:01:36.120 --> 00:01:39.700
guess too often, which could lead to weird conglomerate changes that don't

00:01:39.700 --> 00:01:42.850
really make any sense and probably wouldn't compile or run.

