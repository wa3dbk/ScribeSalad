WEBVTT
Kind: captions
Language: en

00:00:00.340 --> 00:00:03.980
You just made a very important observation. Some scripts don't modify the DOM or

00:00:03.980 --> 00:00:06.410
the CSSOM. And really, they shouldn't block

00:00:06.410 --> 00:00:09.440
rendering. And Analytics is a great example.

00:00:09.440 --> 00:00:11.590
&gt;&gt; Yeah. I wish we had some way to tell the browser exactly that.

00:00:12.660 --> 00:00:15.920
&gt;&gt; Actually, we can. One strategy would be to load the script after the page is

00:00:15.920 --> 00:00:18.370
loaded. So when the browser fires the onload

00:00:18.370 --> 00:00:21.100
event. And we could execute the script then.

00:00:21.100 --> 00:00:22.920
&gt;&gt; All right, how would I do that?

00:00:22.920 --> 00:00:25.780
&gt;&gt; The browser fires an on load event when the page is is finished loading.

00:00:25.780 --> 00:00:28.490
And you can wait for that and then execute your script

00:00:28.490 --> 00:00:32.009
then. Check the instructor notes for instructions on how to do that.

00:00:32.009 --> 00:00:34.380
&gt;&gt; Okay, will do. Is there anything else?

00:00:34.380 --> 00:00:35.890
&gt;&gt; Yeah, the on load technique is a good one

00:00:35.890 --> 00:00:38.250
to have in your back pocket, but there's actually an even

00:00:38.250 --> 00:00:40.440
simpler strategy that we could use. All we need is

00:00:40.440 --> 00:00:43.430
an extra attribute on the script tag. Let me show you.

00:00:43.430 --> 00:00:44.790
&gt;&gt; Cool.

00:00:44.790 --> 00:00:46.700
&gt;&gt; I've pulled out our analytics code into a

00:00:46.700 --> 00:00:50.800
separate file and added the async attribute to the

00:00:50.800 --> 00:00:55.290
script tag. This attribute has two important properties. First,

00:00:55.290 --> 00:00:57.080
it tells the browser that it does not have

00:00:57.080 --> 00:01:00.160
to block DOM construction. When it encounters the script

00:01:00.160 --> 00:01:03.260
side. As a result, the browser dispatches the script request,

00:01:03.260 --> 00:01:07.070
and continues parsing the DOM. Second, the execution of

00:01:07.070 --> 00:01:10.220
the script does not block on the CSS Object

00:01:10.220 --> 00:01:13.310
Module. So, if the script is available before the

00:01:13.310 --> 00:01:16.130
CSS Object Module is ready. It can still be executed

00:01:16.130 --> 00:01:17.380
right there and then.

00:01:17.380 --> 00:01:19.960
&gt;&gt; Oh wow, that's handy. So async basically means

00:01:19.960 --> 00:01:22.230
that the script does not block the critical routing path.

00:01:22.230 --> 00:01:25.490
&gt;&gt; Exactly. The browser will download and execute the script but

00:01:25.490 --> 00:01:28.480
it won't block the parcer, and it won't block on CSS.

00:01:28.480 --> 00:01:32.690
&gt;&gt; What about inline scripts? Can I put an async attribute on an inline script?

00:01:32.690 --> 00:01:36.110
&gt;&gt; Unfortunately that wouldn't work. Inline scripts will always block on the

00:01:36.110 --> 00:01:41.820
CSS Object Model. Well, with one exception. If you put your JavaScript

00:01:41.820 --> 00:01:46.700
above your CSS, then it will execute without blocking on CSS.

00:01:46.700 --> 00:01:49.620
To learn more about this pattern and async scripts, check out

00:01:49.620 --> 00:01:52.170
the link in the instructor notes. Let's do a quick exercise

00:01:52.170 --> 00:01:54.610
to see if you can spot the difference between these patterns.

