WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.000
Before we get to today's homework, let us see how we can make delta debugging faster.

00:00:05.000 --> 00:00:09.000
We must realize that delta debugging is a rather dumb algorithm

00:00:09.000 --> 00:00:14.000
where dumb means it's rather economical in terms of assumptions.

00:00:14.000 --> 00:00:18.000
It assumes nothing about the input structure, which requires little,

00:00:18.000 --> 00:00:20.000
but on the other hand, it gets the job done.

00:00:20.000 --> 00:00:26.000
The interesting thing is that the more knowledge about the structure of the input

00:00:26.000 --> 00:00:30.000
you put into delta debugging, the more efficient delta debugging becomes.

00:00:30.000 --> 00:00:32.000
Let me illustrate this by an example.

00:00:32.000 --> 00:00:36.000
When faced with a 20-character input, delta debugging would have to split this

00:00:36.000 --> 00:00:38.000
into two halves in the beginning.

00:00:38.000 --> 00:00:41.000
But since delta debugging doesn't know about the structure,

00:00:41.000 --> 00:00:44.000
the division will be right in the middle of the input.

00:00:44.000 --> 00:00:51.000
If delta debugging knew, however, that the input was html then it may come up with the split

00:00:51.000 --> 00:00:55.000
that would occur at the boundaries between htlml tokens and actual texts

00:00:55.000 --> 00:00:57.000
something like this for example.

00:00:57.000 --> 00:01:00.000
And if you repeat this now for the first substring,

00:01:00.000 --> 00:01:04.000
you will see that we were able to simplify the input much faster

00:01:04.000 --> 00:01:08.000
because now our simplification follows the structure of the input.

00:01:08.000 --> 00:01:10.000
Let me illustrate this with our example.

00:01:10.000 --> 00:01:12.000
Here again, we have delta debugging as is,

00:01:12.000 --> 00:01:15.000
and we're applying it on this very input as we just saw.

00:01:15.000 --> 00:01:18.000
When I press on run, we cannot see the individual runs.

00:01:18.000 --> 00:01:25.000
And in the end, one character after one character is being removed until we finally see after 29 tests

00:01:25.000 --> 00:01:29.000
and one assertion we see the final result, a simplified input select.

00:01:29.000 --> 00:01:32.000
How can we make delta debugging aware of the input structure?

00:01:32.000 --> 00:01:37.000
We have already seen that delta debugging works on lists as well as on character strings.

00:01:37.000 --> 00:01:44.000
So what we could is we could split the string into individual substrings according to the input structure

00:01:44.000 --> 00:01:47.000
and have delta debugging work on that list of elements instead.

00:01:47.000 --> 00:01:53.000
This is such a list of elements. First, we have the select tag, then foo, and then the end of select.

00:01:53.000 --> 00:01:56.000
Now, what we might have to do is we have to adjust our test function

00:01:56.000 --> 00:02:01.000
such that it will merge the individual parts of the list back again into a string, which we do up here.

00:02:01.000 --> 00:02:06.000
We're using the Python join function, which takes all the elements in the list

00:02:06.000 --> 00:02:09.000
and concatenate them with the first string as separator.

00:02:09.000 --> 00:02:11.000
In our case, an empty string.

00:02:11.000 --> 00:02:16.000
So the effect of this is that all the elements that are in s right will be merged together.

00:02:16.000 --> 00:02:20.000
And then, in the reconstructed entire string, again, we search for the selector.

00:02:20.000 --> 00:02:26.000
In our initial setting, it took us 30 tests until we minimized the input.

00:02:26.000 --> 00:02:30.000
So, on characters, we have seen it took ddmin 29 tests

00:02:30.000 --> 00:02:33.000
again excluding the assertion to simplify the input.

00:02:33.000 --> 00:02:39.000
How many tests will it take on a list of tokens that is on this list of tokens?

00:02:39.000 --> 00:02:43.000
And here a token is a substring with a decisive meaning.

00:02:43.000 --> 00:02:46.000
You can try this out for yourself or just estimate.

00:02:46.000 --> 00:02:48.000
Is this 4 tests? Is this 6 tests? Is that 12 tests? Or is that 29 tests? Over to you.

