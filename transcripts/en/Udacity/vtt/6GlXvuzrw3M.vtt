WEBVTT
Kind: captions
Language: en

00:00:00.480 --> 00:00:03.469
SO in this lesson, we are going to be looking at how to improve the IPC

00:00:03.469 --> 00:00:08.850
without a folder execution and how to design actual hardware that does that. For

00:00:08.850 --> 00:00:13.780
improving the IPC we have seen that the ILP can be good, it can be significantly

00:00:13.780 --> 00:00:19.370
larger than one. Usually it is way over four, but to achieve

00:00:19.370 --> 00:00:24.320
something close to that ILP, we need to handle the control dependencies. And

00:00:24.320 --> 00:00:29.700
we have seen how branch prediction can help eliminate control dependencies if

00:00:29.700 --> 00:00:33.530
branch prediction is correct. So if our branch prediction is very good, which,

00:00:33.530 --> 00:00:38.490
on today's process it is, then as far as control dependencies are concerned,

00:00:38.490 --> 00:00:43.190
our IPC will be very close to the ILP. Then we have to consider the write after

00:00:43.190 --> 00:00:49.050
write, and write after read data dependencies, also known as false dependencies,

00:00:49.050 --> 00:00:53.330
and we have seen that at technique called register renaming can completely

00:00:53.330 --> 00:00:56.430
eliminate these dependencies so that you simply don't have them anymore in

00:00:56.430 --> 00:01:00.290
your program at which point they're not going to be a problem for out IPC. And

00:01:00.290 --> 00:01:03.610
then the, we have seen that there are these write after read also known as true

00:01:03.610 --> 00:01:08.960
data dependencies. And we have seen that it helps a lot when you can execute

00:01:08.960 --> 00:01:12.510
instructions out of order, meaning you don't simply follow the program order,

00:01:12.510 --> 00:01:15.570
you simply find instructions whose inputs are ready and

00:01:15.570 --> 00:01:20.200
you execute them then. That is how ILP mostly was good. And finally,

00:01:20.200 --> 00:01:23.830
there are these structural dependencies, which is when you cannot execute things

00:01:23.830 --> 00:01:28.240
simply because you don't have enough resources in the processor. But that can be

00:01:28.240 --> 00:01:31.980
solved simply by investing in a, into a wider issue processor, meaning we

00:01:31.980 --> 00:01:36.190
need a processor that can handle. A bunch of instructions in each cycle and

00:01:36.190 --> 00:01:39.060
not have to delay instructions just because it doesn't have resources for

00:01:39.060 --> 00:01:44.640
it. So among these, we really need to figure out how to do these three. And

00:01:44.640 --> 00:01:48.810
first, we will focus on this. So, how do we actually do register renaming and

00:01:48.810 --> 00:01:53.610
out of order execution in a way that can be amenable to hardware implementation?

00:01:53.610 --> 00:01:57.390
So we know how to do it kind of manually on paper, but how does a processor

00:01:57.390 --> 00:02:02.520
actually do it? So this lesson will really focus on how to do this for real

