WEBVTT
Kind: captions
Language: en

00:00:00.150 --> 00:00:04.260
Okay, let's work on the solution for our ROB timing quiz this time.

00:00:04.260 --> 00:00:07.100
So the question is, when does the add and multiply issue and

00:00:07.100 --> 00:00:11.320
when do they commit. For issue, the add will try to issue in the third cycle,

00:00:11.320 --> 00:00:14.240
if we have a reservation station available, and we do, because we

00:00:14.240 --> 00:00:18.364
are currently using both of the multiply dividers reservation station, but

00:00:18.364 --> 00:00:22.870
the add 1 is free. So the add issues in cycle three. And the next instruction,

00:00:22.870 --> 00:00:25.850
multiplication, we'll try to issue in cycle 4.

00:00:25.850 --> 00:00:30.510
The question is whether we have a free reservation station. Indeed we do,

00:00:30.510 --> 00:00:34.660
because we have begun executing the multiplication in cycle 3 here.

00:00:34.660 --> 00:00:38.490
That has freed one of the two reservation stations we were holding. So,

00:00:38.490 --> 00:00:42.050
pretty much, at cycle 4 both of the multiplied divided reservation stations

00:00:42.050 --> 00:00:46.810
are actually available so we can issue in cycle four. So I'll put this here,

00:00:46.810 --> 00:00:51.780
so we have 3 and 4. When does this execute? Because, to figure out the commit,

00:00:51.780 --> 00:00:53.990
we actually have to figure out also when do they execute and

00:00:53.990 --> 00:00:58.470
write the results? The add D uses R7 and R8. Those are not written by any of

00:00:58.470 --> 00:01:02.710
the previous instructions so the add can actually begin execution cycle 4.

00:01:02.710 --> 00:01:07.040
And because it takes only one cycle it will try to write the result in cycle 5.

00:01:07.040 --> 00:01:11.250
Now the multiplication is already writing the result in cycle 5.

00:01:11.250 --> 00:01:15.120
But we said that we can't broadcast one add result and

00:01:15.120 --> 00:01:19.960
one multiply result in the same cycle. This is a multiply, this is a divide, so

00:01:19.960 --> 00:01:23.380
they can actually go in the same cycle, so this will broadcast the result,

00:01:23.380 --> 00:01:27.730
also in cycle 5, now let's see what happens with the multiplication here.

00:01:27.730 --> 00:01:32.860
It issues in cycle 4, it uses R1 and R2. So it actually

00:01:32.860 --> 00:01:37.030
cannot execute until both of those results have been written by instructions,

00:01:37.030 --> 00:01:40.831
divide and multiply here. So we have to wait for the later of these two,

00:01:40.831 --> 00:01:45.770
which is cycle 6. That's when we dispatch, we can begin execution in cycle 7.

00:01:45.770 --> 00:01:50.510
This is a multiplication, these two cycles. So,

00:01:50.510 --> 00:01:56.710
in cycles 7 and 8, it is executing in cycle 9, it will write its result.

00:01:56.710 --> 00:02:01.260
Now we are ready to figure out the commit. We said that we can commit up to two

00:02:01.260 --> 00:02:06.050
instructions per cycle. In cycle 8 we are committing the multiplication here.

00:02:06.050 --> 00:02:09.074
The question is can we commit another instruction the same cycle,

00:02:09.074 --> 00:02:12.400
because normally we could if the instruction is done? And

00:02:12.400 --> 00:02:16.450
indeed it is because this instruction has been ready to commit since cycle 5,

00:02:16.450 --> 00:02:19.790
all it was waiting for is for the commit point to reach there.

00:02:19.790 --> 00:02:24.170
So in cycle 8 here we will commit it, thus the correct answer for

00:02:24.170 --> 00:02:27.910
the commit here is eight. And now finally, we need to figure out,

00:02:27.910 --> 00:02:31.800
when does the multiplication commit. Well, it cannot commit in cycle 9,

00:02:31.800 --> 00:02:36.150
because it doesn't have a result written yet, then. But it will try to commit in

00:02:36.150 --> 00:02:39.730
cycle 10, and by that time, previous instructions have committed,

00:02:39.730 --> 00:02:44.470
we have a result. So indeed, it commits in cycle 10. So we can write 10 here.

