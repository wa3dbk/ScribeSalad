WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:03.810
Now to implement a bag we need
the concept of a pennant.

00:00:03.810 --> 00:00:05.010
So what's that?

00:00:05.010 --> 00:00:06.720
Here's the formal definition.

00:00:06.720 --> 00:00:11.690
A pennant is a tree with two to
the k nodes and a unary root and

00:00:11.690 --> 00:00:13.115
that root has a child.

00:00:13.115 --> 00:00:17.735
And the child is the root of
a complete binary subtree.

00:00:17.735 --> 00:00:20.415
Okay, that was a lot of words,
here's a picture.

00:00:20.415 --> 00:00:22.705
This pennant has a root and one child.

00:00:22.705 --> 00:00:26.485
And notice that the child is the parent
of a complete binary subtree.

00:00:26.485 --> 00:00:29.915
Now a pennant has to have
a power of two number of nodes.

00:00:29.915 --> 00:00:32.485
Now remember that a complete
binary tree has to have

00:00:32.485 --> 00:00:36.870
almost a power of two number of nodes,
in particular, 2 to the k minus 1.

00:00:36.870 --> 00:00:39.366
And therefore, when we add the root,
we get a power of 2.

00:00:39.366 --> 00:00:45.420
Okay, now let's see how we can quickly
do interesting operations on pennants.

00:00:45.420 --> 00:00:47.670
Let's call the root little x and

00:00:47.670 --> 00:00:52.690
let's call its complete binary
sub-tree child, capital X sub s.

00:00:52.690 --> 00:00:54.210
Now suppose I give you a second pennant.

00:00:55.220 --> 00:01:00.730
This pennant has a root node, little y,
and a child sub-tree, capital Y sub s.

00:01:00.730 --> 00:01:04.260
And let's further suppose that these
pennants have exactly the same size

00:01:04.260 --> 00:01:06.960
even though I haven't
really drawn them to scale.

00:01:06.960 --> 00:01:11.320
So how do you quickly combine these
two pennants into a new pennant?

00:01:11.320 --> 00:01:12.360
Here's one way,

00:01:12.360 --> 00:01:15.150
let's choose one of the roots to be
the new root of a combined pennant.

00:01:16.160 --> 00:01:18.410
Let's pick x for example.

00:01:18.410 --> 00:01:22.760
So let's chop X off and let's make
it the root of the new pennant.

00:01:22.760 --> 00:01:27.020
Let's take the other root and
let's make it the new only child of X.

00:01:27.020 --> 00:01:29.240
So that X is unary.

00:01:29.240 --> 00:01:32.030
Now since we have two
complete subtrees left and

00:01:32.030 --> 00:01:37.720
the subtrees are both exactly the same
size, I can make them both children of y

00:01:37.720 --> 00:01:40.320
and together they'll still be
a compete binary sub tree.

00:01:41.590 --> 00:01:44.935
Now notice that this new
blob is still a pennant.

00:01:44.935 --> 00:01:48.670
It's got a unary root and
it's got a complete binary sub tree.

00:01:49.760 --> 00:01:51.960
Now both of the original
pennants were size 2 to the k.

00:01:51.960 --> 00:01:57.355
So that means the combined pennant will
have 2 to the k plus 2 to the k or

00:01:57.355 --> 00:01:59.640
2 to the k plus 1 nodes.

00:01:59.640 --> 00:02:02.870
So combining two equal sized
pennants into a new pennant is

00:02:02.870 --> 00:02:04.560
pretty quick and easy.

00:02:04.560 --> 00:02:07.930
Similarly, you can split a pennant
into two smaller pennants and

00:02:07.930 --> 00:02:11.980
it will be just as easy, essentially by
running the same steps in reverse and

00:02:11.980 --> 00:02:13.590
rearranging pointers accordingly.

