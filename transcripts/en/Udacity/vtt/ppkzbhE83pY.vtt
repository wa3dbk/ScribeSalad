WEBVTT
Kind: captions
Language: en

00:00:00.150 --> 00:00:05.030
One approach that was taken to solve
the problem with the 17 instructions,

00:00:05.030 --> 00:00:09.230
was to rewrite the binary
of the guest VM so

00:00:09.230 --> 00:00:12.920
that it never really issues
any one of these operations.

00:00:12.920 --> 00:00:15.610
This process is called
binary translation.

00:00:15.610 --> 00:00:19.520
This approach was pioneered by
research at Stanford University,

00:00:19.520 --> 00:00:22.410
by a group led by
Professor Mendel Rosenblum.

00:00:22.410 --> 00:00:25.830
And subsequently,
this was commercialized as VMware.

00:00:25.830 --> 00:00:31.260
Now some 15 plus years and 30,
$40 billion later, VMware still

00:00:31.260 --> 00:00:36.300
owns by far the largest share of the
virtualized cores in the server market.

00:00:36.300 --> 00:00:40.140
Rosenblum later received
the ACM Fellow reward, and

00:00:40.140 --> 00:00:45.830
in the recognition he was specifically
credited for reinventing virtualization.

00:00:45.830 --> 00:00:50.150
He served as VMware's chief
scientist for about ten years and

00:00:50.150 --> 00:00:52.170
now is back full time at Stanford.

00:00:52.170 --> 00:00:56.940
Let me give you now a brief description
of what binary translation actually is.

00:00:56.940 --> 00:01:01.924
A key thing to note is that the goal
that's pursued by VMware is to run

00:01:01.924 --> 00:01:04.819
unmodified guest operating systems.

00:01:04.819 --> 00:01:08.344
Meaning that we don't need to
install any special drivers,

00:01:08.344 --> 00:01:11.869
or policies or otherwise to change
the guest OS in order to run

00:01:11.869 --> 00:01:14.330
in a virtualized environment.

00:01:14.330 --> 00:01:18.230
As a startup, they clearly couldn't
tell Microsoft to modify Windows so

00:01:18.230 --> 00:01:21.240
that VMware can improve it's,
it's success rate.

00:01:21.240 --> 00:01:24.960
So, this type of virtualization
where the guest OS is not modified

00:01:24.960 --> 00:01:27.140
is called full virtualization.

00:01:27.140 --> 00:01:29.660
The basic approach
consists of the following.

00:01:29.660 --> 00:01:34.392
Instruction sequences that are about
to be executed are dynamically

00:01:34.392 --> 00:01:37.920
captured from the VM binary,
and this is typically done at

00:01:37.920 --> 00:01:42.680
some meaningful granularity like a basic
block such as a loop or a function.

00:01:42.680 --> 00:01:46.360
Now the reason that this is done
dynamically versus statically,

00:01:46.360 --> 00:01:51.100
so up front before any code is actually
run, is because the exact execution

00:01:51.100 --> 00:01:55.900
sequence may depend on the parameters
that are available at runtime.

00:01:55.900 --> 00:01:57.720
So it's input dependent.

00:01:57.720 --> 00:02:03.160
So you cannot really do all of this in
an efficient way statically up front.

00:02:03.160 --> 00:02:06.590
Or in some cases you just cannot do it
all because you don't have the input

00:02:06.590 --> 00:02:07.820
parameters.

00:02:07.820 --> 00:02:12.150
So then you dynamically capture these
code blocks and then inspect them to see

00:02:12.150 --> 00:02:16.680
whether any of these 17 infamous
instructions is about to be issued.

00:02:16.680 --> 00:02:19.380
If it turns out that the code
block doesn't have any of

00:02:19.380 --> 00:02:22.720
these bad instructions,
it's marked as save and

00:02:22.720 --> 00:02:25.780
allowed to execute natively
at hardware speeds.

00:02:25.780 --> 00:02:29.780
However, if one of the bad instructions
is found in the code block,

00:02:29.780 --> 00:02:33.510
then that particular instruction
is translated into some other

00:02:33.510 --> 00:02:37.600
instruction sequence that avoids
the undesired instruction and

00:02:37.600 --> 00:02:40.420
in some way,
emulates the desired behavior.

00:02:40.420 --> 00:02:45.680
This can possibly be achieved, even by
bypassing a trap to the hypervisor.

00:02:45.680 --> 00:02:48.750
Certainly, binary translation
adds overheads, and

00:02:48.750 --> 00:02:52.700
the number of mechanisms are
incorporated specifically in the viewer

00:02:52.700 --> 00:02:56.240
solutions, in order to improve
the efficiency of the process.

00:02:56.240 --> 00:02:59.160
These things include mechanisms such as,

00:02:59.160 --> 00:03:03.780
caching code fragments that correspond
to the translated basic blocks.

00:03:03.780 --> 00:03:07.010
So that the translation process
can be avoided in the future.

00:03:07.010 --> 00:03:09.990
Also, the steps like
distinguishing which portions of

00:03:09.990 --> 00:03:11.990
the binary should be analyzed.

00:03:11.990 --> 00:03:15.270
For instance, distinguishing between
the kernel and the application code and

00:03:15.270 --> 00:03:18.590
making sure that the kernel code
is the one that's analyzed and

00:03:18.590 --> 00:03:19.930
various other optimizations.

