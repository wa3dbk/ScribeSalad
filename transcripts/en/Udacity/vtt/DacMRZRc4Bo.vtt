WEBVTT
Kind: captions
Language: en

00:00:00.330 --> 00:00:05.030
During the context switch discussion, we said that P1 and P2 were going back and

00:00:05.030 --> 00:00:09.090
forth between running and idling.

00:00:09.090 --> 00:00:09.970
So they were in two states.

00:00:09.970 --> 00:00:12.410
They were either running or idling.

00:00:12.410 --> 00:00:17.245
When a process is running, it can be interrupted and context-switched.

00:00:18.590 --> 00:00:23.340
At this point, the process is idle, but it's in what we call a ready state.

00:00:23.340 --> 00:00:25.390
It is ready to execute,

00:00:25.390 --> 00:00:29.820
except it is not the current process that is running from the CPU.

00:00:29.820 --> 00:00:34.430
At some later point, the scheduler would schedule that process again, and

00:00:34.430 --> 00:00:39.230
it will start executing on the CPU, so it will move into the running state.

00:00:39.230 --> 00:00:41.480
What other states can a process be in?

00:00:42.520 --> 00:00:44.670
And how is that determined?

00:00:44.670 --> 00:00:49.100
To answer that question, let's look at a general illustration of

00:00:49.100 --> 00:00:53.520
the states that a process is going through throughout its life cycle.

00:00:53.520 --> 00:00:58.250
Initially, when a process is created, it enters the new state.

00:00:58.250 --> 00:01:01.260
This is when the OS will perform admission control, and

00:01:01.260 --> 00:01:05.580
if it's determined that it's okay, the operating system will allocate and

00:01:05.580 --> 00:01:10.310
initiate a process control block and some initial resources for this process.

00:01:10.310 --> 00:01:13.980
Provided that there are some minimum available resources,

00:01:13.980 --> 00:01:19.400
the process is admitted, and at that point, it is ready to start executing.

00:01:19.400 --> 00:01:24.430
It is ready to start executing, but it isn't actually executing on the CPU.

00:01:24.430 --> 00:01:29.670
It will have to wait in this ready state until the scheduler is ready

00:01:29.670 --> 00:01:35.210
to move it into a running state when it schedules it on the CPU.

00:01:35.210 --> 00:01:38.460
So, once the scheduler gives the CPU to a ready process,

00:01:38.460 --> 00:01:41.370
that ready process is in the running state.

00:01:41.370 --> 00:01:43.342
And from here, a number of things can happen.

00:01:43.342 --> 00:01:46.265
First, the running process can be interrupted so

00:01:46.265 --> 00:01:48.910
that a context switch is performed.

00:01:48.910 --> 00:01:52.480
This would move the running process back into the ready state.

00:01:52.480 --> 00:01:55.090
Another possibility is that a running process may

00:01:55.090 --> 00:01:59.490
need to initiate some longer operation, like reading data from disk or

00:01:59.490 --> 00:02:03.710
to wait on some event like a timer or input from a keyboard.

00:02:03.710 --> 00:02:07.080
At that point, the process enters a waiting state.

00:02:07.080 --> 00:02:08.669
When the event occurs or

00:02:08.669 --> 00:02:13.580
the I/O operation completes, the process will become ready again.

00:02:13.580 --> 00:02:18.355
Finally, when a running process finishes all operations in the program or

00:02:18.355 --> 00:02:21.786
when it encounters some kind of error, it will exit.

00:02:21.786 --> 00:02:25.103
It will return the appropriate exit code, either success or

00:02:25.103 --> 00:02:28.170
error, and at that point, the process is terminated.

