WEBVTT
Kind: captions
Language: en

00:00:00.750 --> 00:00:03.910
The solution approach is to
add specific interfaces for

00:00:03.910 --> 00:00:08.660
the Mark IV that inherit from or
implement our abstract classes.

00:00:09.780 --> 00:00:13.200
We can also factor out the specific
communication mechanisms by

00:00:13.200 --> 00:00:15.710
which the sensors are accessed.

00:00:15.710 --> 00:00:19.110
Have a look at Martin's
specific Java implementation

00:00:19.110 --> 00:00:21.580
which is provided on
the class Resources page.

00:00:22.620 --> 00:00:26.020
&gt;&gt; So for the part about
we could either inherit or

00:00:26.020 --> 00:00:28.740
implement these abstract classes for
our design.

00:00:28.740 --> 00:00:35.190
I guess the situation for inheriting
the abstract classes if we want to

00:00:35.190 --> 00:00:39.480
find some more policies about maybe
a particular class of coffee makers.

00:00:39.480 --> 00:00:42.652
Like if we have, for instance,
our containment vessel, and

00:00:42.652 --> 00:00:45.763
it has these abstract things
that the containment vessels,

00:00:45.763 --> 00:00:48.510
the concrete classes
would need to provide.

00:00:48.510 --> 00:00:53.300
Then we have maybe a slew of
coffee makers that has this

00:00:53.300 --> 00:00:56.820
style of containment vessel that's
a little bit more particular but

00:00:56.820 --> 00:01:00.040
still we want to have
another kind of inherited,

00:01:00.040 --> 00:01:04.584
abstract class and
not like an implemented, concrete class.

00:01:04.584 --> 00:01:06.600
[CROSSTALK]
&gt;&gt; Let me comment a little bit and

00:01:06.600 --> 00:01:09.986
then see if you can refine
the question here a little bit.

00:01:09.986 --> 00:01:15.791
So different object-oriented languages
provide different capabilities for

00:01:15.791 --> 00:01:17.266
doing refinement.

00:01:17.266 --> 00:01:24.092
Java has both interfaces and subclasses
but it only has single inheritance.

00:01:24.092 --> 00:01:28.054
C++ has multiple inheritance but
it doesn't have interfaces,

00:01:28.054 --> 00:01:31.170
although they both
have abstract classes.

00:01:31.170 --> 00:01:35.380
So when I said about inherent or
implement,

00:01:35.380 --> 00:01:40.250
I was really being generic across
the programming languages, okay?

00:01:40.250 --> 00:01:41.220
But in general,

00:01:46.380 --> 00:01:51.820
implementation of abstract interfaces is
nice because in the abstract interface,

00:01:51.820 --> 00:01:54.860
you've captured something
that is purely abstract.

00:01:54.860 --> 00:02:00.920
In an abstract class you can
also have concrete methods.

00:02:00.920 --> 00:02:07.340
So if it's purely abstract you really
captured the essence of something and

00:02:07.340 --> 00:02:13.460
we could even imagine a situation
where each of the roles

00:02:13.460 --> 00:02:20.840
that is expressed by a class is
defined in a separate interface.

00:02:20.840 --> 00:02:25.877
So we might have a relatively vanilla

00:02:25.877 --> 00:02:31.700
class that implements three roles, okay?

00:02:31.700 --> 00:02:33.790
And just provides
the details of doing that.

00:02:33.790 --> 00:02:36.920
And then, if we wanted to change one
of the roles or one of the use-cases,

00:02:36.920 --> 00:02:39.850
we just can go look at that
one particular interface.

00:02:41.100 --> 00:02:44.730
So, given that,
you want to re-ask your question?

00:02:44.730 --> 00:02:48.390
&gt;&gt; I think that covers
kind of my question,

00:02:48.390 --> 00:02:50.300
I guess I have a better understanding,
I think now.

00:02:51.300 --> 00:02:56.264
I guess the takeaway seems to be that
with a very abstractly defined system

00:02:56.264 --> 00:03:00.586
like this, it's kind of like
saying well, I don't care how you

00:03:00.586 --> 00:03:05.250
provide the isReady ready function for
the containment vessel.

00:03:05.250 --> 00:03:07.150
As long as whatever you
implement provides it,

00:03:07.150 --> 00:03:10.040
it's going to fit with this abstract
definition of how our system works.

00:03:10.040 --> 00:03:13.690
So, you should be able to extend and
have some kind of wild and

00:03:13.690 --> 00:03:16.980
crazy thing that does, isReady or
maybe your more typical Mark IV

00:03:16.980 --> 00:03:20.200
design of how the containment
vessel becomes isReady.

00:03:20.200 --> 00:03:24.490
&gt;&gt; So, one way of thinking about this
is you're really, at this stage,

00:03:24.490 --> 00:03:26.100
designing policy.

00:03:26.100 --> 00:03:29.860
And that policy can take
the form of protocols that is

00:03:29.860 --> 00:03:33.050
the names of the abstract
methods that have to be called.

00:03:34.370 --> 00:03:40.080
And the attitude here is to
be as abstract as possible,

00:03:40.080 --> 00:03:43.890
or at least the more abstract you
are the more flexible you are with

00:03:43.890 --> 00:03:45.390
changes in the future.

00:03:45.390 --> 00:03:49.260
Of course you can go
overboard if you're only

00:03:49.260 --> 00:03:51.320
ever going to have one
version of this thing.

00:03:51.320 --> 00:03:55.810
You might not want to spend
a lot of time abstracting on it.

00:03:55.810 --> 00:03:58.930
And maybe there's
a sweet spot in between.

00:03:58.930 --> 00:04:05.360
But in general, and reflecting back on
some of what we've talked about earlier,

00:04:06.490 --> 00:04:11.270
respect to maintainability
of the modules and so on.

00:04:11.270 --> 00:04:18.670
You want to provide as much abstractness
as you can in support of eventual reuse.

