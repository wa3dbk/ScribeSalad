WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:03.150
In this problem we’re going to build the part of

00:00:03.150 --> 00:00:06.234
our javascript parser that handles javascript

00:00:06.234 --> 00:00:09.423
expressions. This is pretty straightforward, just

00:00:09.423 --> 00:00:11.493
like the last problem where we’re essentially

00:00:11.493 --> 00:00:14.753
numerating all the rules that we’ve predefined

00:00:14.753 --> 00:00:18.086
for our javascript language. So let’s go right

00:00:18.086 --> 00:00:21.786
through the I, the E.

00:00:21.786 --> 00:00:23.594
So here we have the supply code for the

00:00:23.594 --> 00:00:27.283
problem and if we look closely, we see that

00:00:27.283 --> 00:00:30.068
almost all the parse float are numerated to

00:00:30.068 --> 00:00:33.447
exactly what they should be. We have Identifier,

00:00:33.447 --> 00:00:37.333
numbers, strings, true and false, how to handle a

00:00:37.333 --> 00:00:40.673
not keyword do the opposite and then for

00:00:40.673 --> 00:00:45.025
expressions. We are also given an enumeration

00:00:45.025 --> 00:00:48.378
of the precedence and the associativity for each

00:00:48.378 --> 00:00:49.946
of these operations.

00:00:49.946 --> 00:00:53.044
So really we have everything we need in the

00:00:53.044 --> 00:00:55.278
problem description to do this problem. And as

00:00:55.278 --> 00:00:57.462
you can see here, I’ve already filled in the

00:00:57.462 --> 00:01:00.855
precedence ordering for the operations. And this

00:01:00.855 --> 00:01:04.432
has simply taken almost exactly right from the

00:01:04.432 --> 00:01:07.603
comment given in the problem where or is listed

00:01:07.603 --> 00:01:10.593
at the lowest precedence and we go all the way

00:01:10.593 --> 00:01:13.828
up to division, right here. I’ve also added not

00:01:13.828 --> 00:01:16.556
just to make it work.

00:01:16.556 --> 00:01:20.886
So let’s start filling in the rules. My first rule is

00:01:20.886 --> 00:01:23.893
going to handle. If we add a matching left and

00:01:23.893 --> 00:01:26.948
right parenthesis, the expression that is equal to

00:01:26.948 --> 00:01:29.864
is simply the contents of the parenthesis, pretty

00:01:29.864 --> 00:01:33.225
straightforward. And now I have four rules for

00:01:33.225 --> 00:01:36.536
some of our literal values. We have a number,

00:01:36.536 --> 00:01:38.656
we’re going to say number and then the contents

00:01:38.656 --> 00:01:42.277
of that string, just simply say the word string,

00:01:42.277 --> 00:01:44.745
we’ve matched true or false, we’re going to

00:01:44.745 --> 00:01:48.944
return the specified tuples. If we see a notch,

00:01:48.944 --> 00:01:52.707
then we simply have in our Pastry that we’re not

00:01:52.707 --> 00:01:56.000
and then the contents that are being.

00:01:56.000 --> 00:01:59.352
Afterwards, we have about a dozen or so binary

00:01:59.352 --> 00:02:04.803
rules. Addition, subtraction, times, modulus

00:02:04.803 --> 00:02:07.667
division etcetera, etcetera and to save some time

00:02:07.667 --> 00:02:12.250
I could enumerate each function, but I want to

00:02:12.250 --> 00:02:15.734
take a short cut. So here I’ve said if we match

00:02:15.734 --> 00:02:18.817
any of these things, I’m calling it a binary

00:02:18.817 --> 00:02:23.400
operation. For the first element is new left,

00:02:23.400 --> 00:02:26.916
upper end of the binary operation. The next

00:02:26.916 --> 00:02:29.968
entry in our tuple is going to be the operation

00:02:29.968 --> 00:02:32.852
being used and the last one its going to be the

00:02:32.852 --> 00:02:37.381
right upper hand of the binary operation.

00:02:37.381 --> 00:02:41.527
And now I have the expressions for function

00:02:41.527 --> 00:02:44.454
calls, not just decorations, which we had in the

00:02:44.454 --> 00:02:47.070
last problem. A function call is going to be

00:02:47.070 --> 00:02:50.457
identifier, with optional argument in between

00:02:50.457 --> 00:02:54.299
parenthesis. And the code for handling optional

00:02:54.299 --> 00:02:57.324
arguments is almost exactly the same as the

00:02:57.324 --> 00:03:01.661
code we use to handle, optional arguments in

00:03:01.661 --> 00:03:04.886
the function decoration. In fact, I think it is

00:03:04.886 --> 00:03:08.084
exactly the same. And with all that, we’ve done

00:03:08.084 --> 00:03:12.084
it. It’s about 50 lines a code and we are happy.

