WEBVTT
Kind: captions
Language: en

00:00:00.200 --> 00:00:02.090
Now for the analysis.

00:00:02.090 --> 00:00:04.930
Mostly, I'll just try
to share the intuition.

00:00:04.930 --> 00:00:09.800
We want to show that order E
times V augmentations are used.

00:00:09.800 --> 00:00:12.910
To see this, we define
something called a level graph.

00:00:12.910 --> 00:00:16.420
The level of a vertex is defined
to be the shortest path distance

00:00:16.420 --> 00:00:18.410
from the source vertex f.

00:00:18.410 --> 00:00:21.310
The level graph then,
is a sub graph of the original,

00:00:21.310 --> 00:00:26.790
that includes only those edges from one
level to a level that's one higher.

00:00:26.790 --> 00:00:30.140
For example,
if this were my directed graph here,

00:00:30.140 --> 00:00:33.240
then the level graph would
be this sub graph down here.

00:00:33.240 --> 00:00:35.390
These edges here have been deleted,

00:00:35.390 --> 00:00:38.780
because they go between
vertices within the same level.

00:00:38.780 --> 00:00:40.140
And this one has been deleted,

00:00:40.140 --> 00:00:43.790
because it went backwards or
up a level, in the graph.

00:00:43.790 --> 00:00:46.810
We first observed that augmenting
along a shortest path,

00:00:46.810 --> 00:00:49.850
only creates paths that are longer ones.

00:00:49.850 --> 00:00:52.860
Say that we push flow
along this path here.

00:00:52.860 --> 00:00:55.430
Then we've introduced back
edges along this path.

00:00:56.630 --> 00:00:59.090
Note, however,
that these edges are useless for

00:00:59.090 --> 00:01:01.340
creating a path of the same length.

00:01:01.340 --> 00:01:05.930
In fact, because they go back up
a level, any path that uses one of them,

00:01:05.930 --> 00:01:10.900
must use two more edges than
the augmenting path that we just used,

00:01:10.900 --> 00:01:12.930
the one that was the shortest path.

00:01:12.930 --> 00:01:15.770
Next, we observe that
the shortest path distance

00:01:15.770 --> 00:01:18.380
must increase every E iterations.

00:01:18.380 --> 00:01:20.300
Every time that we use
an augmenting path,

00:01:20.300 --> 00:01:22.830
we delete an edge from the level graph.

00:01:22.830 --> 00:01:24.640
The edge that got saturated.

00:01:24.640 --> 00:01:28.930
Maybe this one here got saturated in
an augmentation along this path, so

00:01:28.930 --> 00:01:30.340
we would delete that.

00:01:30.340 --> 00:01:33.030
And then maybe we'd push another
flow along this path, and

00:01:33.030 --> 00:01:34.550
end up deleting this edge.

00:01:34.550 --> 00:01:37.110
These edges won't come
back into the level graph,

00:01:37.110 --> 00:01:40.110
until the minimum path
length has increased.

00:01:40.110 --> 00:01:43.070
As we've already argued,
the reverse edges are useless.

00:01:43.070 --> 00:01:45.060
Until we are allowed
to use a longer path.

00:01:46.110 --> 00:01:49.910
So if each augmentation deletes
one edge from the level graph,

00:01:49.910 --> 00:01:53.400
then certainly after E iterations,
the level graph would be empty.

00:01:53.400 --> 00:01:54.140
And then clearly,

00:01:54.140 --> 00:01:59.110
there are no ST paths in this level
graph, and so we need to build a bigger

00:01:59.110 --> 00:02:03.340
one that includes longer paths in order
to be able to augment any further.

00:02:03.340 --> 00:02:06.590
And lastly, there are only V
possible shortest path lengths.

00:02:06.590 --> 00:02:08.400
So that completes the theorem.

00:02:08.400 --> 00:02:12.520
For each possible path link,
we might have up to E iterations.

00:02:13.590 --> 00:02:17.010
Going back to the theorem, note that
we've eliminated the dependence to

00:02:17.010 --> 00:02:18.490
the running time on the capacities.

00:02:19.590 --> 00:02:22.790
This means that the algorithm
is now strongly polynomial.

00:02:22.790 --> 00:02:23.580
And actually,

00:02:23.580 --> 00:02:26.900
we can eliminate the requirement that
the capacities be integers entirely.

