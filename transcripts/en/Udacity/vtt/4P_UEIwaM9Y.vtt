WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.480
And the answer here, surprisingly,

00:00:02.480 --> 00:00:04.050
at least I think it's very surprising

00:00:04.050 --> 00:00:07.280
this algorithm is capable of finding any combination

00:00:07.280 --> 00:00:10.260
of program and input that halts,

00:00:10.260 --> 00:00:13.030
and the reason is simple; if a program halts,

00:00:13.030 --> 00:00:15.100
then the program has a finite length,

00:00:15.100 --> 00:00:17.800
the input has a finite length, and the number of steps in which

00:00:17.800 --> 00:00:20.410
the program can run on the input, if it halts,

00:00:20.410 --> 00:00:22.430
is finite, and at a certain point in time,

00:00:22.430 --> 00:00:24.660
since this loop here is infinite,

00:00:24.660 --> 00:00:27.520
max length will be larger than any of those 3 constraints,

00:00:27.520 --> 00:00:29.810
and once max length has become large enough,

00:00:29.810 --> 00:00:32.940
we will find that P terminates on the input

00:00:32.940 --> 00:00:34.810
after a certain number of steps,

00:00:34.810 --> 00:00:36.160
and so we will print it.

00:00:36.160 --> 00:00:39.360
The only reason why the algorithm could not find the certain combination of

00:00:39.360 --> 00:00:41.350
program and input is that

00:00:41.350 --> 00:00:43.390
the program does not halt on that input.

00:00:43.390 --> 00:00:45.900
The first one, amazingly,

00:00:45.900 --> 00:00:48.370
means that the algorithm is indeed correct.

00:00:48.370 --> 00:00:51.390
Of course it is totally infeasible in practice, as well,

00:00:51.390 --> 00:00:53.080
because if you think about it,

00:00:53.080 --> 00:00:55.140
a program is a text string;

00:00:55.140 --> 00:00:58.860
now even for very, very, very small values of max length

00:00:58.860 --> 00:01:01.440
the number of these text strings for the program

00:01:01.440 --> 00:01:04.400
and of course also the number of text strings for this input here

00:01:04.400 --> 00:01:06.690
becomes exponentially huge,

00:01:06.690 --> 00:01:09.330
so it's a purely theoretical construct,

00:01:09.330 --> 00:01:12.350
but it explains at least in some theoretical computer science courses,

00:01:12.350 --> 00:01:15.590
you will hear that the Halting Problem is referred to as

00:01:15.590 --> 00:01:17.300
recursively enumerable.

00:01:17.300 --> 00:01:19.330
So the algorithm is totally impractical,

00:01:19.330 --> 00:01:21.310
but it is nevertheless correct,

00:01:21.310 --> 00:01:24.860
and that is the reason why the combination of programs and inputs

00:01:24.860 --> 00:01:27.140
for which the program halts on the input

00:01:27.140 --> 00:01:29.670
is called recursively enumerable,

00:01:29.670 --> 00:01:32.040
at least in some theoretical computer science courses.

00:01:32.040 --> 00:01:35.280
Now this one is interesting; can this algorithm be modified

00:01:35.280 --> 00:01:37.290
to output any programs that don't halt?

00:01:37.290 --> 00:01:39.490
And the answer here of course is no,

00:01:39.490 --> 00:01:41.770
because this technique here clearly only works

00:01:41.770 --> 00:01:43.990
when the program stops.

00:01:43.990 --> 00:01:45.470
As long as the program goes on,

00:01:45.470 --> 00:01:47.470
we can not make any statement about it.

00:01:47.470 --> 00:01:49.050
We cannot say it's a program,

00:01:49.050 --> 00:01:52.190
will it still continues running, if it will stop at a certain point in time,

00:01:52.190 --> 00:01:55.000
and that is the reason why we can't modify this algorithm,

00:01:55.000 --> 00:01:58.230
so that it finds combinations of programs that input that don't halt.

00:01:58.230 --> 00:02:01.910
This of course also tells you again why the problem is semi decidable

00:02:01.910 --> 00:02:04.720
because we can find those combinations here,

00:02:04.720 --> 99:59:59.000
but we can not find those over here.

