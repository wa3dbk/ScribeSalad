WEBVTT
Kind: captions
Language: en

00:00:00.310 --> 00:00:02.770
To understand really what's going on with faults, errors, and

00:00:02.770 --> 00:00:06.000
failures let's look at an example. Things always start with

00:00:06.000 --> 00:00:10.220
a fault. And our fault example is a programming mistake.

00:00:10.220 --> 00:00:14.000
And let's say that programming mistake is an add function that

00:00:14.000 --> 00:00:16.536
we wrote for our program. It works just fine in

00:00:16.536 --> 00:00:19.052
all cases, except when we give it to add five

00:00:19.052 --> 00:00:21.908
and three in which case it returns seven instead of

00:00:21.908 --> 00:00:25.890
eight. This type of fault we also call a latent error.

00:00:25.890 --> 00:00:28.620
It's not really an error until we do something

00:00:28.620 --> 00:00:30.790
like this, but this type of a fault we

00:00:30.790 --> 00:00:33.590
call latent error because it's only a matter of

00:00:33.590 --> 00:00:36.860
time when it's going to be activated. So when we

00:00:36.860 --> 00:00:40.790
actually execute 5 plus 3 and get 7 in

00:00:40.790 --> 00:00:44.330
some register, we now have an error. If the

00:00:44.330 --> 00:00:47.350
error is a result of some sort of a

00:00:47.350 --> 00:00:50.950
latent error like this, basically a programming error, we say

00:00:50.950 --> 00:00:53.720
that the fault has been activated or that we

00:00:53.720 --> 00:00:56.900
now have an effective error as opposed to a latent

00:00:56.900 --> 00:01:00.175
one. In our case we get the effective error

00:01:00.175 --> 00:01:03.150
once we call the add function with 5 and 3

00:01:03.150 --> 00:01:05.700
and get 7 instead of 8, and then we

00:01:05.700 --> 00:01:09.740
put that value in some variable. We get the failure

00:01:09.740 --> 00:01:13.978
when the system deviates from specified behavior. For example,

00:01:13.978 --> 00:01:16.026
in this case it might be that the time we

00:01:16.026 --> 00:01:18.586
were computing is the time to schedule a meeting

00:01:18.586 --> 00:01:21.082
for, and now we schedule a meeting for seven,

00:01:21.082 --> 00:01:24.560
instead of eight, as expected. And this is basically

00:01:24.560 --> 00:01:27.920
the failure of the system because it didn't effectively schedule

00:01:27.920 --> 00:01:31.040
the meeting for when it was supposed to. It

00:01:31.040 --> 00:01:35.180
is important to note here that you need a fault

00:01:35.180 --> 00:01:37.420
of some sort in order to get an error,

00:01:37.420 --> 00:01:41.380
but not every fault becomes an error. For the fault

00:01:41.380 --> 00:01:46.240
of this type, for example, to become an error, it needs to be activated. We

00:01:46.240 --> 00:01:50.610
need to actually use the function in a way that makes it produce incorrect

00:01:50.610 --> 00:01:55.730
results, even though it always had a fault. It always was faulty in this

00:01:55.730 --> 00:02:01.690
way. Similarly, we can have an error and never get a failure.

00:02:01.690 --> 00:02:06.478
For example here, if this value seven was never used, and programs

00:02:06.478 --> 00:02:09.250
often do this, then we have an error, a

00:02:09.250 --> 00:02:12.610
variable has the wrong value, but we don't get

00:02:12.610 --> 00:02:16.347
a failure as a result. Another example here would

00:02:16.347 --> 00:02:19.590
be something like, if we check for example whether this

00:02:19.590 --> 00:02:23.040
function returns something larger than zero, then when it

00:02:23.040 --> 00:02:25.938
returns seven instead of eight and we store that in

00:02:25.938 --> 00:02:28.698
a register, compare it to zero, see that it's

00:02:28.698 --> 00:02:31.941
still larger than zero, now we got an effective error,

00:02:31.941 --> 00:02:34.770
because a register held the wrong value, but the

00:02:34.770 --> 00:02:37.392
only thing we did with this value still caused

00:02:37.392 --> 00:02:41.570
the program to function normally. So in this case,

00:02:41.570 --> 00:02:43.940
we have an error, but we don't have a failure.

