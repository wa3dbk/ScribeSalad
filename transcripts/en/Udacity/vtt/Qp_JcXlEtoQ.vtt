WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.354
If a program fails in the field, rather than in the lab,

00:00:03.354 --> 00:00:05.454
this makes reproduction hard at first

00:00:05.454 --> 00:00:09.744
because you lack all the data you might need to do efficient debugging.

00:00:09.762 --> 00:00:15.915
However, having programs that execute in the field can actually also ease debugging.

00:00:15.915 --> 00:00:21.065
The basic idea is to exploit the many runs that are out there in the field.

00:00:21.065 --> 00:00:24.032
Suppose you have a number of runs, hopefully few, that fail

00:00:24.032 --> 00:00:29.631
and a number of runs, hopefully many, that pass. Or that don't fail.

00:00:29.631 --> 00:00:33.397
What you could look for is features of the execution

00:00:33.397 --> 00:00:35.881
that statistically correlate with failure.

00:00:35.881 --> 00:00:40.313
One such feature could be the execution of individual parts of the program.

00:00:40.313 --> 00:00:43.830
If you knew, for instance, that in all the nonfailing runs

00:00:43.830 --> 00:00:46.562
a specific function is never called,

00:00:46.562 --> 00:00:50.844
whereas the same function is always called in all the failing runs,

00:00:50.844 --> 00:00:53.064
and this information goes to you,

00:00:53.064 --> 00:00:57.162
of course the first thing you would do is to look at the function, F,

00:00:57.162 --> 00:01:00.980
in order to see what is it that could possibly go wrong in here.

00:01:00.980 --> 00:01:04.763
Instead of F, you could also come up with other execution features.

00:01:04.763 --> 00:01:09.580
For instance, this could be a specific line, or a specific return value,

00:01:09.580 --> 00:01:11.762
or a specific variable value.

00:01:11.762 --> 00:01:16.280
All of these features could possibly correlate with success or failure

00:01:16.280 --> 00:01:20.381
and thus provide important hints when it comes to the debugging.

00:01:20.381 --> 00:01:24.047
To get this to work, we need to collect these execution features.

00:01:24.047 --> 00:01:26.511
And we'll start with executed lines

00:01:26.511 --> 00:01:29.964
because this is plain and simple coverage.

00:01:29.964 --> 00:01:32.463
The idea, again, is to use a tracing function,

00:01:32.463 --> 00:01:36.897
and the tracing function would record for every single line in the file,

00:01:36.897 --> 00:01:38.645
whether it has been reached.

00:01:38.645 --> 00:01:42.895
So we have this global coverage variable and if we reach a new line,

00:01:42.895 --> 00:01:45.913
we extract the file name and the line number.

00:01:45.913 --> 00:01:50.030
And what we now do, if we do have the file name and the line number,

00:01:50.030 --> 00:01:53.363
is we check whether we've seen the file name before,

00:01:53.363 --> 00:01:56.663
and if we haven't, we create a new empty set.

00:01:56.663 --> 00:02:01.762
Then we add the line number to the set we found for this file name.

00:02:01.762 --> 00:02:06.580
Here again we set the tracer, and now we simply invoke this on a simple text

00:02:06.580 --> 00:02:08.696
without HTML markup.

00:02:08.696 --> 00:02:10.895
Let's see which lines are actually covered.

00:02:10.895 --> 00:02:12.763
Click on run, and here's the set.

00:02:12.763 --> 00:02:15.596
Lines 4, 5, 6, 8, 9, and so on,

00:02:15.596 --> 00:02:17.330
are being covered in here.

00:02:17.330 --> 00:02:21.745
Let's go and mark these lines, which are covered here in the code.

00:02:21.745 --> 00:02:29.263
There's line 4, 5, 6, 8, 9, 11, 13, 15, 16, and 18.

00:02:29.263 --> 00:02:33.413
The lines that are not covered are line 10, line 12, and line 14.

00:02:33.413 --> 00:02:37.029
That is all the lines that would set tag to specific values,

00:02:37.029 --> 00:02:39.297
or set quote to specific values.

00:02:39.297 --> 00:02:44.131
Since the result of passing some text without HTML markup is actually correct,

00:02:44.131 --> 00:02:47.846
we could now deduce that maybe we should come up with tests

00:02:47.846 --> 00:02:50.895
that check for these lines which we haven't covered yet,

00:02:50.895 --> 00:02:53.694
and see whether these fail, and then we could find out

00:02:53.694 --> 00:02:57.646
that errors would actually be related to the execution of these lines.

00:02:57.646 --> 00:03:00.880
But first, let's come up with an automatic mechanism

00:03:00.880 --> 00:03:05.396
to produce this markup; that is, whether a line is executed or not.

00:03:05.396 --> 00:03:08.631
The idea is to produce the program as output

00:03:08.631 --> 00:03:13.380
and prefix every single line with a star if it has been executed

00:03:13.380 --> 00:03:15.662
and with a blank if not.

00:03:15.662 --> 00:03:21.279
So we need to turn this set into the code prefixed with stars or not.

00:03:21.279 --> 00:03:22.813
Here is a starting point.

00:03:22.813 --> 00:03:27.095
Since we already have the file name, we can actually open the file name

00:03:27.095 --> 00:03:30.680
and read its context as an array of lines.

00:03:30.680 --> 00:03:32.846
Let's see whether this works.

00:03:32.846 --> 00:03:37.584
Indeed, what we get is a list of the individual lines in the program.

