WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.590
Complexity theory deals a lot with problems and with algorithms,

00:00:04.590 --> 00:00:08.260
so we should say a little bit more about each one of the two.

00:00:08.260 --> 00:00:10.600
So, a problem normally consists of 3 parts.

00:00:10.600 --> 00:00:12.380
The first one is very simple.

00:00:12.380 --> 00:00:16.180
It's just a name that we give to the problem so that when we talk about it,

00:00:16.180 --> 00:00:18.380
we know how to reference it.

00:00:18.380 --> 00:00:22.350
In this case we're going to find a better name for that soon, but in this case,

00:00:22.350 --> 00:00:25.540
we'll just call the problem that Alice was working on 'Alice's problem.'

00:00:25.540 --> 00:00:28.750
For each problem, we also need to say something about the input

00:00:28.750 --> 00:00:30.620
that we're expecting for it.

00:00:30.620 --> 00:00:35.030
So in this case, here, it's a network of communication centers.

00:00:35.030 --> 00:00:37.830
And, of course, we also need to say something about the output

00:00:37.830 --> 00:00:39.380
that we are expecting.

00:00:39.380 --> 00:00:44.720
So in this case, here, it would be the minimum number of monitoring devices

00:00:44.720 --> 00:00:47.410
to cover all cables or all connections.

00:00:47.410 --> 00:00:52.460
Of course the most useful output would be to know not only the minimum number

00:00:52.460 --> 00:00:55.200
of monitoring devices, but where we should actually put them.

00:00:55.200 --> 00:00:58.270
But you're soon going to see that it doesn't really make much of a difference

00:00:58.270 --> 00:01:02.140
most of the time if we are just asking for the minimum number

00:01:02.140 --> 00:01:04.920
or if we are actually asking for the communication centers

00:01:04.920 --> 00:01:06.460
where we need to put those devices.

00:01:06.460 --> 00:01:11.850
Now, what Alice devised to solve this problem was a possible algorithm.

00:01:11.850 --> 00:01:17.470
Now, there's no really accepted definition of what an algorithm actually is.

00:01:17.470 --> 00:01:21.870
But, for us, it's enough to say that whenever we talk about an algorithm,

00:01:21.870 --> 00:01:27.870
we'll be talking about the description of a computer program that is able to solve

00:01:27.870 --> 00:01:29.620
the problem that we are given.

00:01:29.620 --> 00:01:34.050
Now the question that we want to answer for Alice's problem--

00:01:34.050 --> 00:01:37.780
since the algorithm that she has found is not very good--

00:01:37.780 --> 00:01:43.430
is if the problem that she's working on is a hard problem or an easy problem.

00:01:43.430 --> 00:01:48.720
And what we mean by that is if it's possible to find a more efficient algorithm

00:01:48.720 --> 00:01:50.290
for this problem.

00:01:50.290 --> 00:01:53.600
If that is the case, then we would call this problem an easy problem.

00:01:53.600 --> 00:01:56.410
Or, we will soon have a more precise definition of that, actually.

00:01:56.410 --> 00:01:59.860
And if it's not possible to find a better algorithm for the problem,

00:01:59.860 --> 00:02:03.280
then this would be considered a hard problem.

00:02:03.280 --> 00:02:08.400
Now, the hardness of a problem tells you how fast and with how many resources

00:02:08.400 --> 00:02:09.870
you can solve the problem.

00:02:09.870 --> 00:02:12.350
But, of course, that would require you to find

00:02:12.350 --> 00:02:15.390
the best possible algorithm for that problem.

00:02:15.390 --> 00:02:20.730
And 'best' is not a very scientific term, so we'll have to say a little bit more about

00:02:20.730 --> 99:59:59.000
the analysis of algorithms.

