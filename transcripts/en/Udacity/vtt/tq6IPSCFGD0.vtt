WEBVTT
Kind: captions
Language: en

00:00:00.620 --> 00:00:03.510
So, similar to microkernel-based operating system

00:00:03.510 --> 00:00:08.070
design that we have discussed before, functionalities

00:00:08.070 --> 00:00:11.800
in the Tornado operating system are contained

00:00:11.800 --> 00:00:14.890
in these clustered objects. And these clustered

00:00:14.890 --> 00:00:17.320
objects have to communicate with one another

00:00:17.320 --> 00:00:19.960
in order to implement the services. Because

00:00:19.960 --> 00:00:22.400
it's not a monolithic kernel anymore, it's

00:00:22.400 --> 00:00:26.510
a micro kernel where the functionalities contained

00:00:26.510 --> 00:00:29.840
in these objects. And so we need efficient

00:00:29.840 --> 00:00:35.350
inter process communication via object calls that go between

00:00:35.350 --> 00:00:39.230
an object that can be a client, can, can be thought of as a client and an

00:00:39.230 --> 00:00:40.400
object that can be thought of as a

00:00:40.400 --> 00:00:45.430
server. For instance The FCM object may need to

00:00:45.430 --> 00:00:52.080
contact the DRAM object in order to get a page frame. So, in that case, the FCM

00:00:52.080 --> 00:00:57.860
object is a client and the DRAM object is a server that is serving the request.

00:00:57.860 --> 00:01:03.960
And the way the request is satisfied is through the IPC realized by a protective

00:01:03.960 --> 00:01:07.250
procedure call mechanism. And if the calling object

00:01:07.250 --> 00:01:09.750
and the called object, the client and the

00:01:09.750 --> 00:01:13.038
server, they are on the same processor then

00:01:13.038 --> 00:01:17.460
Tornado use this handle scheduling between the calling

00:01:17.460 --> 00:01:19.560
object and the called object. It's very similar

00:01:19.560 --> 00:01:23.000
to what we discussed in the LRPC paper on

00:01:23.000 --> 00:01:26.050
how we can have efficient communication without a context

00:01:26.050 --> 00:01:29.130
switch. So local protected procedure call, you don't have

00:01:29.130 --> 00:01:31.090
to have a context switch, because you can

00:01:31.090 --> 00:01:35.610
implement this by handoff scheduling. Between the calling object

00:01:35.610 --> 00:01:38.640
and the called object. On the other hand, if

00:01:38.640 --> 00:01:43.270
the called obgject is on a remorte processor then

00:01:43.270 --> 00:01:44.820
you have to have a full context switch

00:01:44.820 --> 00:01:47.080
in order to go across to the other processor

00:01:47.080 --> 00:01:49.370
and execute the protective procedure call. And this

00:01:49.370 --> 00:01:54.510
ICP mechanism is fundamental to the tornado system. Both

00:01:54.510 --> 00:01:57.140
for implementing any service as a collection of

00:01:57.140 --> 00:02:01.180
cluster objects, and even for managing the replicas of

00:02:01.180 --> 00:02:04.760
objects. So for instance, I mentioned that you might

00:02:04.760 --> 00:02:08.600
decide based on usage pattern that I want to have

00:02:08.600 --> 00:02:12.110
replicas of the region object which represents a particular

00:02:12.110 --> 00:02:14.430
portion of the address space. If you have a

00:02:14.430 --> 00:02:17.780
region object that is replicated it's equivalent to a

00:02:17.780 --> 00:02:21.240
page table, has mappings between virtual pages and physical

00:02:21.240 --> 00:02:23.860
pages. If I replicate it, then I have to

00:02:23.860 --> 00:02:26.990
make sure that the replicas remain consistent. Whose job

00:02:26.990 --> 00:02:29.630
is it? It is a job of the clustered

00:02:29.630 --> 00:02:33.640
object implementation to make sure that replicas are kept consistent.

00:02:33.640 --> 00:02:36.910
So, when you modify one replica, you have to make

00:02:36.910 --> 00:02:39.720
a particular procedure called the other replicas to deflect the

00:02:39.720 --> 00:02:42.810
other changes that you made In the first replica. So

00:02:42.810 --> 00:02:45.090
all of these are things that are happening under the

00:02:45.090 --> 00:02:47.350
collar, so the key thing that you'll notice is that

00:02:47.350 --> 00:02:50.520
all of the management of replicas and so on is

00:02:50.520 --> 00:02:54.090
managed in software, we're not relying on the hardware cache

00:02:54.090 --> 00:02:58.760
coherence because the hardware cache coherence only works on physical memory.

00:02:58.760 --> 00:03:01.710
Now if it replicated. The physical memory is not the same

00:03:01.710 --> 00:03:04.380
anymore. But is a replica that is known only to the

00:03:04.380 --> 00:03:08.470
software. The system software. So, to the management of the replica,

00:03:08.470 --> 00:03:11.980
that is, that has to be managed by the operating system.

