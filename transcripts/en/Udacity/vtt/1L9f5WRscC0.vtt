WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Now, what I've shown you so far is not really an algorithm,

00:00:03.000 --> 00:00:05.000
but it has some elements in common with them.

00:00:05.000 --> 00:00:08.000
Algorithms are really cool. That's what the focus of this class is about.

00:00:08.000 --> 00:00:11.000
One of the reasons algorithms are cool is that they're really useful.

00:00:11.000 --> 00:00:15.000
Without careful algorithm design we just don't see fast enough responses from

00:00:15.000 --> 00:00:18.000
things like websites and user interfaces--stuff that we really depend on

00:00:18.000 --> 00:00:21.000
to be able to have the computers react quickly.

00:00:21.000 --> 00:00:24.000
Another is that they're really clever. They're really pretty, mathematically.

00:00:24.000 --> 00:00:27.000
Just like a magic trick, sometimes learning how it does what it does

00:00:27.000 --> 00:00:30.000
can be just as exciting as what it actually does accomplishes.

00:00:30.000 --> 00:00:35.000
The practical part of algorithm design is trying to figure out how to make your programs fly--

00:00:35.000 --> 00:00:37.000
that is to say, go really, really fast.

00:00:37.000 --> 00:00:40.000
There are a couple different ways that you can do this when you're programming.

00:00:40.000 --> 00:00:43.000
One, you should take a great deal of care in organizing your programs

00:00:43.000 --> 00:00:45.000
so that they're not doing a lot of wasteful stuff.

00:00:45.000 --> 00:00:47.000
That goes without saying, but I said it anyway.

00:00:47.000 --> 00:00:52.000
There's a lot of time that you can spend tweaking loops and other things in your program

00:00:52.000 --> 00:00:56.000
to just get rid of little bits and pieces of inefficiency, and that's important.

00:00:56.000 --> 00:00:59.000
But perhaps the most important thing is good algorithm design.

00:00:59.000 --> 00:01:03.000
Whenever your program is doing something that involves a great deal of computation

00:01:03.000 --> 00:01:06.000
you need to think hard about how to organize that computation

00:01:06.000 --> 00:01:08.000
so it does what you want it to do, but it does it fast.

00:01:08.000 --> 00:01:10.000
That's the focus of this course.

00:01:10.000 --> 00:01:13.000
We can think of the problem of developing algorithms for particular problems

00:01:13.000 --> 00:01:15.000
as a kind of algorithm itself.

00:01:15.000 --> 00:01:18.000
Here I've written it as kind of faux Python. You can't actually run this.

00:01:18.000 --> 00:01:22.000
I would not suggest running this, but it should give you a sense of the flow here.

00:01:22.000 --> 00:01:25.000
What we start off with is some kind of problem specification.

00:01:25.000 --> 00:01:28.000
We'll talk about a couple different examples of those over the course of the course.

00:01:28.000 --> 00:01:31.000
For the problems specification we're currently concerned with,

00:01:31.000 --> 00:01:34.000
what we're going to do is we're going to start off devising an algorithm for that problem.

00:01:34.000 --> 00:01:38.000
That mean thinking about it, coming up with some kind of strategy or plan

00:01:38.000 --> 00:01:41.000
for doing the computation. We'll call that our algorithm.

00:01:41.000 --> 00:01:44.000
They're not really done yet. We need to make sure that this algorithm is actually correct.

00:01:44.000 --> 00:01:47.000
The first thing that we want to do when we propose an algorithm

00:01:47.000 --> 00:01:51.000
is actually analyze the correctness with respect to the problem specification

00:01:51.000 --> 00:01:55.000
to see if it actually accomplishes what the problem says you're supposed to accomplish.

00:01:55.000 --> 00:01:58.000
Sometimes that is kind of obvious and straightforward.

00:01:58.000 --> 00:02:00.000
Sometimes that involves a fair amount of mathematical analysis.

00:02:00.000 --> 00:02:02.000
We'll see different examples of those as we go.

00:02:02.000 --> 00:02:05.000
Once we've analyzed our algorithm to make sure that it's correct,

00:02:05.000 --> 00:02:07.000
we can analyze it's efficiency.

00:02:07.000 --> 00:02:10.000
It does what it's supposed to do, but does it to it fast enough?

00:02:10.000 --> 00:02:13.000
We eventually determine the running time of the algorithm.

00:02:13.000 --> 00:02:15.000
If it's not correct or if it's not fast enough,

00:02:15.000 --> 00:02:19.000
then we need to continue this process, redevise an algorithm, and reanalyze it,

00:02:19.000 --> 00:02:22.000
and keep doing this until we have something that both solves the problem

00:02:22.000 --> 00:02:24.000
and solves it fast enough.

00:02:24.000 --> 09:59:59.000
That's the algorithm that we declare to be our solution.

