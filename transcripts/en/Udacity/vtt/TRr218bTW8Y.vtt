WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
Hopefully what you learned from the previous example is that building

00:00:04.000 --> 00:00:06.000
a random test case generator doesn't have to be very difficult.

00:00:06.000 --> 00:00:10.000
But realistically, it's usually a little bit more involved than the one we just saw.

00:00:10.000 --> 00:00:13.000
And the key problem is generating inputs that are valid.

00:00:13.000 --> 00:00:15.000
Or another way to say that is generating inputs that are part of the input domain

00:00:15.000 --> 00:00:17.000
for the software under test.

00:00:17.000 --> 00:00:19.000
What I wanted to do here is look at the entire space of random inputs.

00:00:19.000 --> 00:00:22.000
And what I mean by entire space of random inputs is we haven't ruled anything out.

00:00:22.000 --> 00:00:25.000
So what we get is random 1s and 0s.

00:00:25.000 --> 00:00:27.000
And so remember that request to constructing random inputs,

00:00:27.000 --> 00:00:30.000
we're going to be feeding those into some software under test

00:00:30.000 --> 00:00:34.000
and we're looking for outputs in the range of the software under test.

00:00:34.000 --> 00:00:37.000
And let's say for the sake of argument that we're testing a web browser.

00:00:37.000 --> 00:00:42.000
And so the question we have to ask ourselves is how much of the space of totally random 1s and 0s

00:00:42.000 --> 00:00:46.000
constitutes a valid input for a web browser and when I say the word testing, they're rendering

00:00:46.000 --> 00:00:51.000
it in part of a web browser so we're testing what happens when data comes over the web

00:00:51.000 --> 00:00:53.000
to the web browser in response to an HTTP request

00:00:53.000 --> 00:00:55.000
and now the web browser wants to render that.

00:00:55.000 --> 00:00:57.000
So we have total random 1s and 0s.

00:00:57.000 --> 00:01:01.000
And as you might expect almost all arbitrary combinations of 1s and 0s

00:01:01.000 --> 00:01:07.000
fail to create valid web pages so there's going to be some small subset of the set of random inputs

00:01:07.000 --> 00:01:11.000
that constitutes valid inputs to the web browser and if we take one of these other inputs

00:01:11.000 --> 00:01:15.000
and hand it to the web browser there's going to mapped to a part of the output space

00:01:15.000 --> 00:01:18.000
that corresponds to a malformed HTML.

00:01:18.000 --> 00:01:23.000
One thing we might ask is, "Isn't it a good thing to test web browsers with completely invalid inputs

00:01:23.000 --> 00:01:27.000
to see if for example instead of returning a page error it's easily possible

00:01:27.000 --> 00:01:31.000
that some subset of this space corresponds to browser crashes?"

00:01:31.000 --> 00:01:35.000
The answer is yes. We definitely do want to test our web browser with completely random inputs.

00:01:35.000 --> 00:01:40.000
But on the other hand, the amount of code in the web browser that serves to classify codes as

00:01:40.000 --> 00:01:42.000
renderable versus not renderable

00:01:42.000 --> 00:01:46.000
there's some very tiny fraction of the total amount of code in the web browser.

00:01:46.000 --> 00:01:52.000
And if the fraction of valid HTML is very low, we're going to spend almost all of our time testing

00:01:52.000 --> 00:01:54.000
this very small part of the web browser.

00:01:54.000 --> 00:01:59.000
What we probably want to do is take some tests from this broader set of completely random inputs

00:01:59.000 --> 00:02:02.000
but take most of our tests from a set of valid webpages.

00:02:02.000 --> 00:02:05.000
These are the ones which when we select a random input in here are going to

00:02:05.000 --> 00:02:09.000
with some probability end up exposing something like cross-site scripting bugs.

00:02:09.000 --> 00:02:12.000
Now I'm just going to ignore the little details like the fact that we probably would need to be

00:02:12.000 --> 00:02:16.000
generating JavaScript as well in order to make these kind of bugs happen.

00:02:16.000 --> 00:02:19.000
We're mostly trying to look at the abstract problem.

