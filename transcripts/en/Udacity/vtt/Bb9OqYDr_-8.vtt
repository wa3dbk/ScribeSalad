WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:04.090
The solution to these problems is called gamma correction. We have two separate

00:00:04.090 --> 00:00:07.198
wishes. We want to compute our renderings in a linear space, and we want to

00:00:07.198 --> 00:00:11.635
compensate for the power curve of monitors when we're displaying. At its

00:00:11.635 --> 00:00:15.182
simplest, the equation's just this. You take the computed channel value, you

00:00:15.182 --> 00:00:18.256
raise it to the 1 over 2.2 power, and that gives you the value you need to

00:00:18.256 --> 00:00:24.006
display. This value of 2.2 is called the gamma correction value. Older Mac

00:00:24.006 --> 00:00:29.425
displays used 1.8 or so, but now 2.2 is the norm for all monitors. For example,

00:00:29.425 --> 00:00:32.950
say we have a value of 1.0, 0.6, 0.2 in our linear compute space. We raise 1 to

00:00:32.950 --> 00:00:43.135
this power and we get 1 back. 0.6 raised to the power gets 0.793. Finally 0.2

00:00:43.135 --> 00:00:48.301
gives us 0.481. Notice how each channel changes by a different factor. 1.0

00:00:48.301 --> 00:00:52.880
didn't change at all. 0.2 more then doubles. This is why color shifting can

00:00:52.880 --> 00:00:56.588
occur if you don't gamma correct. Gamma correction is something that's applied

00:00:56.588 --> 00:00:59.840
to the whole image just before display. If you try to do it yourself you have

00:00:59.840 --> 00:01:03.702
to be aware of precision problems with your input data. For example, if you

00:01:03.702 --> 00:01:06.616
have only 8 bits per channel coming in, you won't be able to get 8 bits of good

00:01:06.616 --> 00:01:11.410
data coming out. The good news is that Three.js has gamma correction built in.

00:01:11.410 --> 00:01:14.931
All you have to do for it is ask. One last detail is that when you look at a

00:01:14.931 --> 00:01:17.845
color swatch or a texture on the screen, you're seeing the monitor's power

00:01:17.845 --> 00:01:22.218
curve version of the data. If you want to use that data properly when computing

00:01:22.218 --> 00:01:25.452
lighting effects, you actually have to raise each channel's value to a power of

00:01:25.452 --> 00:01:28.441
2.2 before using it for anything, either making mipmaps or making images

00:01:28.441 --> 00:01:33.861
themselves. Three.js uses an on-the-fly approximation, squaring the texture's

00:01:33.861 --> 00:01:38.290
color when it is sampled. To sum up, whatever we see on the screen is in this

00:01:38.290 --> 00:01:42.145
nonlinear gamma space. To use it in lighting computations, we want to make the

00:01:42.145 --> 00:01:47.102
data linear. So we raise each channel's value to the 2.2 power. We perform our

00:01:47.102 --> 00:01:50.762
lighting calculations, then at the end we go back to the monitor space by

00:01:50.762 --> 00:01:55.777
raising to 1 over 2.2. Here are the corresponding Three.js calls. Some GPUs and

00:01:55.777 --> 00:02:00.688
APIs have built-in capabilities for dealing with gamma properly. Unfortunately,

00:02:00.688 --> 00:02:04.272
these aren't currently accessible through WebGL or Three.js. Internally in

00:02:04.272 --> 00:02:08.229
Three.js, there's some approximation of gamma. So a value might be squared,

00:02:08.229 --> 00:02:13.170
instead of raised to the 2.2 power, to bring it into linear computation space.

00:02:13.170 --> 00:02:16.080
To see the effect of gamma correction, take a look at the demo that follows.

