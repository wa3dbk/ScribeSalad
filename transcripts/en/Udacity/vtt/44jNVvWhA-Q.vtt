WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Now I'd like to talk about being great at testing software,

00:00:03.000 --> 00:00:05.000
and this involves a number of different elements.

00:00:05.000 --> 00:00:08.000
First of all, we need to recognize that testing and development

00:00:08.000 --> 00:00:11.000
are fundamentally different roles, even if they're often

00:00:11.000 --> 00:00:13.000
played by the same exact people.

00:00:13.000 --> 00:00:15.000
A developer's primary attitude is 

00:00:15.000 --> 00:00:17.000
I want this code to succeed.

00:00:17.000 --> 00:00:21.000
A tester's main attitude is I want this code to fail,

00:00:21.000 --> 00:00:24.000
and of course, the reason the tester wants the code to fail

00:00:24.000 --> 00:00:26.000
is that the tester's end goal is creating stronger code

00:00:26.000 --> 00:00:28.000
which later on doesn't fail.

00:00:28.000 --> 00:00:31.000
If we look at these requirements a little bit we can see that for the same person

00:00:31.000 --> 00:00:34.000
to be a great tester and a great developer

00:00:34.000 --> 00:00:36.000
there might be a little bit of doublethink involved,

00:00:36.000 --> 00:00:39.000
and so those of you who read Orwell will know that the doublethink is the 

00:00:39.000 --> 00:00:43.000
ability to hold 2 contradictory beliefs in one's mind simultaneously,

00:00:43.000 --> 00:00:48.000
and there is a bit of that required in order to be a great tester and a great developer.

00:00:48.000 --> 00:00:52.000
And of course, really the contradictory nature of these 2 beliefs

00:00:52.000 --> 00:00:55.000
is only apparent because, of course, the developers and the testers

00:00:55.000 --> 00:00:58.000
in the end want the same thing, which is to create a great software.

00:00:58.000 --> 00:01:02.000
The second element of being great at testing is to learn to test creatively,

00:01:02.000 --> 00:01:04.000
and I showed the example earlier of testing an ARM assembler and disassembler 

00:01:04.000 --> 00:01:08.000
by exploiting the fact that they were inverses of each other

00:01:08.000 --> 00:01:11.000
and also exploiting the fact that the ARM instruction space 

00:01:11.000 --> 00:01:13.000
could be fully enumerated, and that's something that I consider to be a great example

00:01:13.000 --> 00:01:16.000
of creative testing, and if we can think of creative ways to test

00:01:16.000 --> 00:01:20.000
we often do a much better job than rote testing,

00:01:20.000 --> 00:01:23.000
and furthermore, do a much better job than just

00:01:23.000 --> 00:01:25.000
rote testing with the most obvious inputs.

00:01:25.000 --> 00:01:28.000
The third thing is that great testers never ignore

00:01:28.000 --> 00:01:30.000
weird things that they notice.

00:01:30.000 --> 00:01:32.000
It turns out that at least in my experience

00:01:32.000 --> 00:01:35.000
it's very often the case that we get little hints of things wrong

00:01:35.000 --> 00:01:39.000
with the software that lead to threads that if tugged on

00:01:39.000 --> 00:01:42.000
would have led us to discover problems that were really quite serious.

00:01:42.000 --> 00:01:45.000
On the other hand, if we see these little things wrong 

00:01:45.000 --> 00:01:47.000
and we paper over them, we ignore them,

00:01:47.000 --> 00:01:50.000
we end up not finding those problems until later.

00:01:50.000 --> 00:01:53.000
I'm going to end up today with the claim

00:01:53.000 --> 00:01:55.000
that great testing is a lot of fun because 

00:01:55.000 --> 00:01:58.000
it's fun to break software, and it's very satisfying

00:01:58.000 --> 00:02:00.000
to produce software that's really great

00:02:00.000 --> 00:02:04.000
because it's been well tested, and great testing can also be profitable.

00:02:04.000 --> 00:02:06.000
And what I mean here is that testing is a separate career 

00:02:06.000 --> 00:02:09.000
at many companies like Microsoft and that companies 

00:02:09.000 --> 00:02:13.000
like Google and Mozilla offer bug bounties,

00:02:13.000 --> 00:02:17.000
and what this means is if you find a security critical bug in, 

00:02:17.000 --> 00:02:19.000
for example, Google Chrome, they'll pay you up to $20,000,

00:02:19.000 --> 00:02:21.000
and this isn't at all theoretical.

00:02:21.000 --> 00:02:24.000
I was recently talking to a software testing researcher

00:02:24.000 --> 00:02:27.000
who wrote an automatic tester and applied it to Chrome and to Mozilla,

00:02:27.000 --> 00:02:30.000
and their research group, over the course of a few months,

00:02:30.000 --> 00:02:32.000
made about $50,000.

