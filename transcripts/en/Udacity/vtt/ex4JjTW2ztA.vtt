WEBVTT
Kind: captions
Language: en

00:00:00.370 --> 00:00:03.849
So let's compare update and
invalidate coherence approaches.

00:00:03.849 --> 00:00:07.516
We will compare them for different
things that the applications often do.

00:00:07.516 --> 00:00:10.599
Here we will say, what the update
protocols are going to do and

00:00:10.599 --> 00:00:13.322
here's what an invalidate
protocol is going to do.

00:00:13.322 --> 00:00:18.102
If the application has a burst of writes
to one address and if the address is

00:00:18.102 --> 00:00:22.516
shared, then each write will send
an update in an update protocol.

00:00:22.516 --> 00:00:27.591
This is bad, because each updates
results in competing for the bus,

00:00:27.591 --> 00:00:33.638
so it creates bus contention and also it
consumes energy and makes writes slower.

00:00:33.638 --> 00:00:37.944
In an invalidate protocol, only the
first write send out an invalidation and

00:00:37.944 --> 00:00:42.053
the remaining writes are just going to
be cache hits that don't result in any

00:00:42.053 --> 00:00:43.280
bus traffic.

00:00:43.280 --> 00:00:44.370
That is good.

00:00:44.370 --> 00:00:48.142
Why would an application burst
of writes to one address?

00:00:48.142 --> 00:00:50.398
Well, because when we
are computing something,

00:00:50.398 --> 00:00:53.575
we may need to update it several times
until we get to the final result.

00:00:53.575 --> 00:00:56.457
Another common behavior is
when an application writes to

00:00:56.457 --> 00:00:58.265
different words in the same block.

00:00:58.265 --> 00:01:01.216
For example,
when we are initializing the block,

00:01:01.216 --> 00:01:03.489
we will write every word of that block.

00:01:03.489 --> 00:01:08.618
If that block is shared, an update
protocol will send an update for

00:01:08.618 --> 00:01:10.548
each word that we write.

00:01:10.548 --> 00:01:15.378
That is bad, because it means that one
cache line worth of writes might result

00:01:15.378 --> 00:01:17.398
in something like ten updates.

00:01:17.398 --> 00:01:20.161
In an invalidation-based protocol,

00:01:20.161 --> 00:01:24.929
the first write that we have is going to
invalidate the other copies and

00:01:24.929 --> 00:01:29.783
then the remaining accesses to the block
or different words are going to

00:01:29.783 --> 00:01:34.260
be just cache hits that
don't result in bus traffic.

00:01:34.260 --> 00:01:38.570
So this is again good for
the invalidate, bad for the update.

00:01:38.570 --> 00:01:42.730
And the final scenario we will consider
is the producer-consumer scenario,

00:01:42.730 --> 00:01:50.670
where the one core keeps writing data
and another core is supposed to read it.

00:01:50.670 --> 00:01:53.348
In this case for the update protocol,

00:01:53.348 --> 00:01:57.953
the producer will send updates
every time it modifies the data and

00:01:57.953 --> 00:02:01.230
the consumer then finds
the data in its cache.

00:02:01.230 --> 00:02:05.201
For example, if there is a buffer, the
first pass through the buffer will put

00:02:05.201 --> 00:02:08.638
it in the cache and then reading
the buffer, keeps it in the cache.

00:02:08.638 --> 00:02:11.520
And here, writes are going to
put new data in the buffer, so

00:02:11.520 --> 00:02:14.535
that the consumer just keeps
getting it from its own cache.

00:02:14.535 --> 00:02:18.195
This is not great, the producer sends
updates, but it's kind of the best we

00:02:18.195 --> 00:02:21.640
can do, because the data really has
to get from one place to the other.

00:02:21.640 --> 00:02:24.774
So this is about as good
as this scenario gets.

00:02:24.774 --> 00:02:27.645
In an invalidation-based protocol,
however,

00:02:27.645 --> 00:02:31.485
the producer will do a write that
invalidates the reader's copy.

00:02:31.485 --> 00:02:34.522
So when the reader,
the consumer wants to read,

00:02:34.522 --> 00:02:38.818
it's going to be a cache miss and it
has to get the data from the writer and

00:02:38.818 --> 00:02:43.230
then a new write will happen and
invalidate the copy and so on.

00:02:43.230 --> 00:02:47.830
So this is about as bad as it gets for
this scenario, because not only do we

00:02:47.830 --> 00:02:52.660
create bus traffic when we invalidate,
we then have to have a cache miss and

00:02:52.660 --> 00:02:55.460
have another bus operation
to get the data.

00:02:55.460 --> 00:02:58.390
So as we can see from
this table update and

00:02:58.390 --> 00:03:02.260
invalidate based protocols
have different advantages.

00:03:02.260 --> 00:03:05.290
So which one do we choose in practice?

00:03:05.290 --> 00:03:10.246
Well, it turns out that all modern
processors use the invalidate

00:03:10.246 --> 00:03:14.224
type protocol, but
not exactly for these reasons.

00:03:14.224 --> 00:03:17.676
As we can see, invalidate-based
protocols have some strengths and

00:03:17.676 --> 00:03:18.635
some weaknesses.

00:03:18.635 --> 00:03:23.605
Overall, they tend to be slightly
stronger than update on average, but

00:03:23.605 --> 00:03:28.341
that's not really the knock out
punch that makes them win handedly.

00:03:28.341 --> 00:03:32.537
What really makes them win with no
contest is when a thread moves to

00:03:32.537 --> 00:03:33.542
another core.

00:03:33.542 --> 00:03:35.246
So a thread was using one core and

00:03:35.246 --> 00:03:39.710
then simply the operating system
decides to move it to another core.

00:03:39.710 --> 00:03:43.856
So what happens in the update protocol
is that it now will keep updating

00:03:43.856 --> 00:03:45.273
the old core's cache.

00:03:45.273 --> 00:03:48.454
Note that our working
set was in one cache.

00:03:48.454 --> 00:03:50.753
Now, it moved to another one.

00:03:50.753 --> 00:03:55.373
But in reality, the other cache still
has blocks that correspond to our data.

00:03:55.373 --> 00:03:59.817
So what happens is all the writes
that we make in the near future

00:03:59.817 --> 00:04:04.174
are going to be updating the other
course cache until that cache

00:04:04.174 --> 00:04:09.000
replaces those blocks by running
another core, for example.

00:04:09.000 --> 00:04:12.860
This is pretty horrible,
because a thread movement,

00:04:12.860 --> 00:04:16.990
ideally what would happen is we
would just move the data over and

00:04:16.990 --> 00:04:20.190
continue working privately
on our private data.

00:04:20.190 --> 00:04:22.860
So let's see how this
horrible scenario for

00:04:22.860 --> 00:04:25.470
updates works when we
have invalid dates.

00:04:25.470 --> 00:04:26.444
In that case,

00:04:26.444 --> 00:04:31.484
the first write to each of the blocks
will have to invalidate the old copy.

00:04:31.484 --> 00:04:35.755
But after that initial period,
there will be no traffic anymore.

00:04:35.755 --> 00:04:39.119
So this is about as good as it
gets without actually taking

00:04:39.119 --> 00:04:44.020
the content of the old cache and
copying it explicitly to the new cache.

00:04:44.020 --> 00:04:47.321
And again, this is pretty common
operating system behavior.

00:04:47.321 --> 00:04:50.201
So we really want it to
perform horribly and

00:04:50.201 --> 00:04:54.202
because invalidate-based
protocols are commonly used,

00:04:54.202 --> 00:04:59.575
we will now look at invalidation-based
protocols for the rest of this lesson.

