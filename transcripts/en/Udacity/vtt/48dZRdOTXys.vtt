WEBVTT
Kind: captions
Language: en

00:00:00.008 --> 00:00:03.843
The position GL_Position, and the color vColor, were generated by the vertex

00:00:03.843 --> 00:00:08.039
shader. These are passed on to the rasterizer, which interpolates these across

00:00:08.039 --> 00:00:11.850
the triangle and creates fragments. Each fragment is then passed through the

00:00:11.850 --> 00:00:15.593
fragment shader. You'll be happy to hear this shader is very simple. All this

00:00:15.593 --> 00:00:18.631
shader does is takes the interpolated color, vColor, and copies it over to

00:00:18.631 --> 00:00:21.669
gl_FragColor, the built-in output variable for what color appears on the

00:00:21.669 --> 00:00:26.106
screen. The fourth coordinate is set to the alpha value, which says how solid

00:00:26.106 --> 00:00:30.185
the surface is. This is normally 1. Notice how the language elegantly

00:00:30.185 --> 00:00:34.357
understands vectors. VColor is a vector with three coordinates. We construct

00:00:34.357 --> 00:00:37.891
the gl_FragColor, a four-element vector, by using vColor and appending a

00:00:37.891 --> 00:00:42.145
number. GLSL knows what this means. In general, the language is very aware of

00:00:42.145 --> 00:00:46.108
common vector and scalar operations. Here's another example of vector

00:00:46.108 --> 00:00:50.015
operations. Say we have an input specular color and a specular amount. We've

00:00:50.015 --> 00:00:52.394
computed a value for the specular variable, how much it should affect the

00:00:52.394 --> 00:00:56.230
fragment's color. In this line of code we multiply this variable, a single

00:00:56.230 --> 00:01:00.278
floating point number, by a vector with three elements. We add this to the

00:01:00.278 --> 00:01:04.063
fragment color by specifying which components we want changed. Here the R, G,

00:01:04.063 --> 00:01:08.592
and B components are modified. The component names for the 4 elements are XYZW

00:01:08.592 --> 00:01:14.787
for points and vectors, RGBA for colors, and STPQ for texture coordinates. S

00:01:14.787 --> 00:01:17.756
and T are sort of like U and V. I won't go into all the features of the

00:01:17.756 --> 00:01:20.814
language, see the additional course materials for full references. One thing

00:01:20.814 --> 00:01:24.690
worth mentioning is that there all sorts of built-in functions. Some you'll

00:01:24.690 --> 00:01:28.344
probably be familiar with, such as absolute value, sign, power, and square

00:01:28.344 --> 00:01:32.214
root. Others are more specific to graphic, such as normalize, dot, cross

00:01:32.214 --> 00:01:36.780
product, and reflect. For debugging shader code, the browser's debug console

00:01:36.780 --> 00:01:40.518
can often give useful errors. For example, in this line of code, I put a

00:01:40.518 --> 00:01:44.214
representation for a floating point number that's perfectly valid in C, but is

00:01:44.214 --> 00:01:49.481
not part of the GLSL language, so it was flagged here. Sometimes the errors are

00:01:49.481 --> 00:01:54.475
a bit cryptic. In this case the 0 should be 0.0. GLSL is very picky about

00:01:54.475 --> 00:01:58.616
having a floating point number have a decimal point. In either case, you'll get

00:01:58.616 --> 00:02:02.012
a blank screen or not much warning otherwise. I sometimes found myself adding a

00:02:02.012 --> 00:02:05.622
line or two at a time and seeing if everything stays on the screen. If not, I

00:02:05.622 --> 00:02:09.217
comment out the lines until my scene reappears. I call this binary search

00:02:09.217 --> 00:02:09.940
debugging.

