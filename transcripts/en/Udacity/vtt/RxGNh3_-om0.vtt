WEBVTT
Kind: captions
Language: en

00:00:00.250 --> 00:00:05.440
So, to summarize, the approach where we have the conditional move instructions,

00:00:05.440 --> 00:00:09.480
we need the compiler support to do an if conversion.

00:00:09.480 --> 00:00:14.340
If the compiler doesn't do anything, the code will be just left with a branch.

00:00:14.340 --> 00:00:18.910
So this is not a fully backwards-compatible approach in that if we

00:00:18.910 --> 00:00:23.100
add the conditional move instructions to the ISA, we're only allowing

00:00:23.100 --> 00:00:28.340
the compiler to take advantage of that. But old code will still not use these

00:00:28.340 --> 00:00:32.790
conditional instructions. This approach will remove hard to predict branches. So

00:00:32.790 --> 00:00:35.440
if we have a hard to predict branch, for example,

00:00:35.440 --> 00:00:39.710
through profiling we determine that a particular branch is difficult to predict,

00:00:39.710 --> 00:00:42.460
we can perform if conversion to get rid of it.

00:00:42.460 --> 00:00:47.430
If conversion typically requires use of more registers than the original code.

00:00:47.430 --> 00:00:52.520
Because we need to keep all the results from both of the paths, and

00:00:52.520 --> 00:00:58.080
also, more instructions will be executed as a result of if conversion because

00:00:58.080 --> 00:01:03.160
we're executing instructions from both paths, not just one. And also because we

00:01:03.160 --> 00:01:07.220
need to add the conditional move instructions to select the actual results,

00:01:07.220 --> 00:01:11.080
the ones we want to keep, from among the results that we have generated from

00:01:11.080 --> 00:01:16.110
both paths. Some of these are necessary in order to do if conversion. For

00:01:16.110 --> 00:01:20.040
example, the compiler support is okay, we need that.

00:01:20.040 --> 00:01:24.900
It will remove the conditional branches that are hard to predict, so that,

00:01:24.900 --> 00:01:29.600
we want to stay the way it is. But the need for more registers, for

00:01:29.600 --> 00:01:34.900
example. Can we do something about that? More instructions are executed because

00:01:34.900 --> 00:01:40.660
we execute both paths. This again is okay, that's how we do if conversion, but

00:01:40.660 --> 00:01:44.930
do we really have to have additional instructions just to select the results.

00:01:44.930 --> 00:01:50.000
To get rid of this and this problem, we can change our ISA so

00:01:50.000 --> 00:01:55.860
that every instruction is now conditional. Every instruction computes its result

00:01:55.860 --> 00:02:00.730
and then writes it or doesn't write it to the destination register, depending on

00:02:00.730 --> 00:02:07.180
whether a condition is true or not. This approach is called full predication.

00:02:07.180 --> 00:02:10.530
And it requires extensive support in the instruction set.

