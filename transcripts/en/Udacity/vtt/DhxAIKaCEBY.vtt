WEBVTT
Kind: captions
Language: en

00:00:00.600 --> 00:00:06.550
Now, let's see how for this same cache,
we use this address to access the cache.

00:00:06.550 --> 00:00:08.610
To make things easier to represent,

00:00:08.610 --> 00:00:12.760
we will draw the lines in
the same set horizontally, so

00:00:12.760 --> 00:00:17.550
these are the lines that belong to set
zero then we will have additional lines.

00:00:17.550 --> 00:00:21.220
And there will be lines
that belong to set 15.

00:00:21.220 --> 00:00:23.320
There are 16 sets if you remember.

00:00:24.440 --> 00:00:29.670
So the way we access this cache
is we take the index bits and

00:00:29.670 --> 00:00:31.450
they tell us which set we have.

00:00:31.450 --> 00:00:33.020
Let's say we have set 0.

00:00:33.020 --> 00:00:39.140
We then read the tag invalid bits for
all of the blocks in that set.

00:00:39.140 --> 00:00:42.990
The tag bits that we read
are compared to the tag.

00:00:44.010 --> 00:00:49.100
The valid bit needs to be also
1 in order to have a hit.

00:00:49.100 --> 00:00:54.770
And we do this for each of these
blocks in the set simultaneously.

00:00:54.770 --> 00:00:59.150
So the tag is distributed
to all of them to compare.

00:00:59.150 --> 00:01:03.730
As you can see, there is four separate
activities in order to determine for

00:01:03.730 --> 00:01:05.860
each of these whether it's a hit.

00:01:05.860 --> 00:01:11.460
And then there is OR circuit that
checks if any of these is one.

00:01:11.460 --> 00:01:15.360
If that OR returns a one,
that means that we have a hit.

00:01:15.360 --> 00:01:19.730
In that case, what we do is we
find which one had the hit and

00:01:19.730 --> 00:01:22.450
go back and read out the data for
that block.

00:01:22.450 --> 00:01:28.220
Once the data is read out, let's say
this is our 64 bytes of data, we use

00:01:28.220 --> 00:01:33.760
the offset to tell us where our actual
data to return to the processor is.

00:01:33.760 --> 00:01:38.220
If this was a write, then this
offset tells us where to write.

00:01:38.220 --> 00:01:41.880
And if this is a write,
we will also set the dirty bit here.

00:01:41.880 --> 00:01:44.680
Note that we don't actually check
the dirty bit if it's zero and

00:01:44.680 --> 00:01:46.440
set it if it's zero.

00:01:46.440 --> 00:01:48.960
We just set it to one
regardless of what it was.

00:01:48.960 --> 00:01:52.180
It's faster to just set it than
to check it and then set it.

00:01:52.180 --> 00:01:54.850
So if we have a hit,
this is how we find the data.

00:01:54.850 --> 00:01:56.050
What if we have a miss?

00:01:56.050 --> 00:01:59.200
What if all of these have returned zero?

00:01:59.200 --> 00:02:04.860
In that case, we will check the LRU
counters In these to find the one

00:02:04.860 --> 00:02:08.750
that is 0,
check the dirty bit of that block.

00:02:08.750 --> 00:02:13.470
If it is 1, we will first take this
data and write it to memory and

00:02:13.470 --> 00:02:15.300
then put the new block here.

00:02:15.300 --> 00:02:18.830
If it is 0,
then we simply bring in the new block.

00:02:18.830 --> 00:02:21.550
We update the tag and everything here.

00:02:21.550 --> 00:02:24.320
We set the LRU counters accordingly and

00:02:24.320 --> 00:02:26.560
we then supply the data
to the processor.

00:02:26.560 --> 00:02:30.800
So as you can see all of the stuff that
we have been talking about in the cache

00:02:30.800 --> 00:02:35.470
really happens kind of simultaneously on
every axis all of this needs to happen.

00:02:35.470 --> 00:02:37.470
If it's a hit up to here.

00:02:37.470 --> 00:02:40.330
If it's a miss all the way
to writing back to memory,

00:02:40.330 --> 00:02:43.707
fetching another block from memory and
updating the tag invalid bits.

