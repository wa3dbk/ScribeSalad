WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
So that suggests a strategy for finding a large prime--

00:00:03.000 --> 00:00:06.000
which is to keep trying guesses until we find one that's prime.

00:00:06.000 --> 00:00:10.000
If it's not a prime, then we add 1 and we try again.

00:00:10.000 --> 00:00:14.000
Because of what we know about the number of primes being finite

00:00:14.000 --> 00:00:19.000
and the density of primes, we know that after a reasonable number of iterations

00:00:19.000 --> 00:00:22.000
this will actually find a prime and return that value.

00:00:22.000 --> 00:00:26.000
We could do a little better if we assume we start with an odd number

00:00:26.000 --> 00:00:29.000
and we'll assert that X is not divisible by 2

00:00:29.000 --> 00:00:32.000
since that is very obvious that it would be prime

00:00:32.000 --> 00:00:34.000
and increment by 2 here.

00:00:34.000 --> 00:00:37.000
What's missing is we need some way to do this "is prime" test.

00:00:37.000 --> 00:00:41.000
So here is a naive way to test to the finest prime.

00:00:41.000 --> 00:00:44.000
We're going to go through the numbers from 2 to X minus 1,

00:00:44.000 --> 00:00:48.000
checking whether X is divisible by each of those.

00:00:48.000 --> 00:00:50.000
If it is divisible by any of those,

00:00:50.000 --> 00:00:52.000
that would mean that it is a composite number

00:00:52.000 --> 00:00:54.000
and we should return False.

00:00:54.000 --> 00:00:57.000
If we try them all and it's not divisible by any of those, well then it's prime.

00:00:57.000 --> 00:00:59.000
So the question is: Would this work?

00:00:59.000 --> 00:01:02.000
The possible answers are: Yes, this would work fine.

00:01:02.000 --> 00:01:07.000
No, it's too slow because the running time is exponential in the value of X.

00:01:07.000 --> 00:01:11.000
No because it's too slow because the running time is exponential in the size of X.

00:01:11.000 --> 00:01:14.000
And no, because there's a silly bug in my Python code.

