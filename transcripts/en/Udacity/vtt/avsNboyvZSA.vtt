WEBVTT
Kind: captions
Language: en

00:00:00.380 --> 00:00:03.570
At the beginning of each module all I
ask you to open up a playground file

00:00:03.570 --> 00:00:04.970
like this one.

00:00:04.970 --> 00:00:07.930
That file will contain the examples
I will walk through so

00:00:07.930 --> 00:00:09.640
you can follow along.

00:00:09.640 --> 00:00:13.680
A second file will contain exercises for
you to do on your own.

00:00:13.680 --> 00:00:16.960
You can download all the files for the
course from the link in the instructors

00:00:16.960 --> 00:00:18.910
notes at the beginning of each lesson.

00:00:18.910 --> 00:00:21.729
Go ahead and download the playground
files for lesson one now.

00:00:22.960 --> 00:00:27.930
Then open up the file entitled
Lesson One, Types and Operators.

00:00:27.930 --> 00:00:29.880
If your playground doesn't
look like this, but

00:00:29.880 --> 00:00:32.159
instead has a bunch of green comments.

00:00:32.159 --> 00:00:35.790
You'll want to change one of
the settings up here in the editor menu.

00:00:35.790 --> 00:00:39.920
Go down to here where where my
menu says show ROM mark up.

00:00:39.920 --> 00:00:42.790
Yours might say show rendered markup.

00:00:42.790 --> 00:00:45.560
So you want to click on it if
it says show rendered markup.

00:00:46.590 --> 00:00:48.680
Then it should look like this.

00:00:48.680 --> 00:00:51.270
I'm going to start by quickly
running through the definitions of

00:00:51.270 --> 00:00:53.060
Swift's primitive types.

00:00:53.060 --> 00:00:55.990
Swift's primitive types don't
have too many surprises.

00:00:55.990 --> 00:00:59.990
Here in this light switch class
the on property is a bool.

00:00:59.990 --> 00:01:03.160
Swift booleans always have
a value of true or false.

00:01:03.160 --> 00:01:08.500
They can't be assigned to zero or one as
in C, or yes or no as in Objective C.

00:01:08.500 --> 00:01:11.740
If you don't recognize any
of this syntax, don't worry.

00:01:11.740 --> 00:01:13.320
That's to be expected.

00:01:13.320 --> 00:01:14.280
I'll explain class and

00:01:14.280 --> 00:01:18.100
property definitions soon,
along with this dot syntax.

00:01:18.100 --> 00:01:20.860
For now just focus on the data types.

00:01:20.860 --> 00:01:23.570
For properties that need
to hold continuous values,

00:01:23.570 --> 00:01:26.550
we might want to use the int type,
which holds an integer.

00:01:26.550 --> 00:01:28.655
For example if our light
switch had a dimmer.

00:01:28.655 --> 00:01:31.025
I'll give our light
switch a dimmer property.

00:01:31.025 --> 00:01:33.455
And then I'll set that dimmer
property to be of type int.

00:01:34.715 --> 00:01:37.645
What if we wanted to
set our dimmer to pi.

00:01:37.645 --> 00:01:41.365
If we want this dimmer property
to be able to represent decimals,

00:01:41.365 --> 00:01:43.485
we can try using a float
instead of an int.

00:01:45.090 --> 00:01:49.740
Of course if we use a double then we can
get a more precise representation of pi.

00:01:49.740 --> 00:01:51.770
Here I've carried it
out to eleven digits.

00:01:51.770 --> 00:01:52.800
Between float and double,

00:01:52.800 --> 00:01:56.070
you can decide which type to use based
on the level of precision you need.

00:01:57.200 --> 00:02:00.950
Strings and characters in Swift
are pretty much as you would expect.

00:02:00.950 --> 00:02:03.570
Naturally the character type
holds a single character,

00:02:03.570 --> 00:02:08.650
and the string type represents
an ordered collection of characters.

00:02:08.650 --> 00:02:11.180
The Swift string type comes
with a handy bag of tricks,

00:02:11.180 --> 00:02:13.920
that makes string manipulations nice and
concise.

00:02:13.920 --> 00:02:15.700
Like this simple string concatenation.

00:02:15.700 --> 00:02:20.010
Here in the playground sidebar you
can see the concatenated string.

00:02:20.010 --> 00:02:23.730
We'll have more fun with strings and
the exercises at the end of the lesson.

00:02:23.730 --> 00:02:27.440
There are two other Swift types
that require a deeper dive.

00:02:27.440 --> 00:02:31.190
The first is the optional type,
which is the focus of the next lesson.

00:02:31.190 --> 00:02:35.510
And the second is tuples, which we'll
talk about in the collections lesson.

00:02:35.510 --> 00:02:38.430
For now, just know of their existence.

00:02:38.430 --> 00:02:42.050
Before we finish,
there's a secret I haven't revealed.

00:02:42.050 --> 00:02:44.989
See how I've indicated the type for
each of these variables?

00:02:46.120 --> 00:02:49.260
I can actually take all of
these type indicators out.

00:02:51.540 --> 00:02:54.910
But the compiler is having no
problem inferring the correct type.

00:02:54.910 --> 00:02:59.460
And we can even test that by taking
a look at the type of these variables.

00:02:59.460 --> 00:03:01.950
Let's try this concatenated string.

00:03:01.950 --> 00:03:06.690
This dynamic type property can be
used to investigate any objects type.

00:03:06.690 --> 00:03:10.740
And we can see over here in the sidebar
that the type of concatenated string

00:03:10.740 --> 00:03:12.140
is a Swift string.

00:03:12.140 --> 00:03:14.070
And the compiler was able to infer that,

00:03:14.070 --> 00:03:17.640
even though we didn't indicate
it directly in the definition.

00:03:17.640 --> 00:03:20.710
In the upcoming quiz,
you get to play the role of compiler and

00:03:20.710 --> 00:03:22.140
do some type inference of your own.

