WEBVTT
Kind: captions
Language: en

00:00:00.180 --> 00:00:02.680
So once I've done the double act, then I

00:00:02.680 --> 00:00:05.890
can set up the current node's next pointer to point

00:00:05.890 --> 00:00:08.680
to me. And then I'll be done with joining the

00:00:08.680 --> 00:00:12.000
cube and then I can await the predecessor to signal

00:00:12.000 --> 00:00:16.180
me. So, I'm spinning on the got-it variable. And

00:00:16.180 --> 00:00:18.440
how will I know that I've got the lock? Well,

00:00:18.440 --> 00:00:21.720
my predecessor who is currently using the lock will eventually

00:00:21.720 --> 00:00:25.200
come around And call this unlocked function. And the unlocked

00:00:25.200 --> 00:00:29.680
function is basically taking, again, two arguments. One argument

00:00:29.680 --> 00:00:33.680
being the name of the lock, and, and the other

00:00:33.680 --> 00:00:35.820
argument is the guy that's making the unlock call,

00:00:35.820 --> 00:00:38.080
in this case, the current node that's making the unlock

00:00:38.080 --> 00:00:41.960
call. And what it does is to remove current

00:00:41.960 --> 00:00:44.810
from. On the list and it is going to signal

00:00:44.810 --> 00:00:47.440
the successor. And the way the successor is going to

00:00:47.440 --> 00:00:50.320
be signalled is because the current node has an x

00:00:50.320 --> 00:00:52.820
pointer and the x pointer says he's the next

00:00:52.820 --> 00:00:56.140
guy waiting in line for getting this particular lock. And

00:00:56.140 --> 00:00:58.470
he's pinning on the got it variable. So he's

00:00:58.470 --> 00:01:01.930
just going to signal the successor. By setting the guarded variable

00:01:01.930 --> 00:01:04.500
for the successor to be true, and that will

00:01:04.500 --> 00:01:08.100
get me out of my spin loop, and I'll have

00:01:08.100 --> 00:01:11.780
the lock. And I'm now running inside the critical section

00:01:11.780 --> 00:01:16.260
having obtained the lock that's protecting the data structure associated

00:01:16.260 --> 00:01:18.670
with that critical section. So now I'm in my

00:01:18.670 --> 00:01:22.130
critical section. And eventually I'll get done with my

00:01:22.130 --> 00:01:24.090
critical section. When I get done with my critical

00:01:24.090 --> 00:01:27.170
section I have to unlock and I call the unlock

00:01:27.170 --> 00:01:33.200
function. Normally the unlock function involves me removing myself

00:01:33.200 --> 00:01:37.300
from this link list and then signaling the successor.

00:01:37.300 --> 00:01:38.520
So these are the two things I have to

00:01:38.520 --> 00:01:41.960
do. Remove myself from the list, and signal any successor.

00:01:41.960 --> 00:01:44.800
The special case occurs. When there is no successor to

00:01:44.800 --> 00:01:48.380
me. The special case when that occurs what I have to

00:01:48.380 --> 00:01:51.880
do is I have to set the headnode, the dummy

00:01:51.880 --> 00:01:56.090
node, of the link, link list, namely l to null to

00:01:56.090 --> 00:01:59.370
indicate that there is no request... Waiting for this lock.

00:01:59.370 --> 00:02:02.140
So that's a special case. And so if I look at

00:02:02.140 --> 00:02:04.220
this picture here, what I have to do is I have

00:02:04.220 --> 00:02:07.810
to set this L to null, and then I'll be done.

00:02:07.810 --> 00:02:10.780
I don't have a successor signal. But wait, there could

00:02:10.780 --> 00:02:13.290
be a new request that is forming. And if a new

00:02:13.290 --> 00:02:17.350
request is forming, now this guy what you would have done

00:02:17.350 --> 00:02:21.170
is To do a fetch and store. And, and if you

00:02:21.170 --> 00:02:24.360
did a fetch and store on this linked list, what

00:02:24.360 --> 00:02:27.780
would have happened is that he would've gotten my coordinates, and

00:02:27.780 --> 00:02:30.440
you'd have set the list to point to him. So the

00:02:30.440 --> 00:02:34.300
new request is forming, but it will not form completely yet.

00:02:34.300 --> 00:02:37.290
In other words, the next pointer in me is

00:02:37.290 --> 00:02:40.030
not pointing to this new request yet. And this

00:02:40.030 --> 00:02:42.190
is the classic race condition that can occur in

00:02:42.190 --> 00:02:46.010
parallel programs, and in this particular case, the race condition

00:02:46.010 --> 00:02:49.790
is between the unlocker, that is me, and the

00:02:49.790 --> 00:02:52.350
new requester that is coming to put himself on the

00:02:52.350 --> 00:02:55.370
queue. And such race conditions are the bane of

00:02:55.370 --> 00:02:59.480
parallel programs. And one has to be very, very watchful

00:02:59.480 --> 00:03:02.500
for such [INAUDIBLE] conditions. And being an operating

00:03:02.500 --> 00:03:05.830
system designer, you have to be ultra careful

00:03:05.830 --> 00:03:09.650
to ensure that your synchronization algorithm is implemented

00:03:09.650 --> 00:03:12.570
correctly. You don't want to give the user the experience

00:03:12.570 --> 00:03:14.900
of the blue screen of death. You have

00:03:14.900 --> 00:03:18.370
to think through any corner case that can happen

00:03:18.370 --> 00:03:21.010
In this kind of scenario and design the

00:03:21.010 --> 00:03:24.620
software in such a way, operating system in particular,

00:03:24.620 --> 00:03:26.370
to make sure that all sets of

00:03:26.370 --> 00:03:29.610
these conditions are completely avoided. Now, let's

00:03:29.610 --> 00:03:33.180
return to this particular case and see how we can take care of this situation.

