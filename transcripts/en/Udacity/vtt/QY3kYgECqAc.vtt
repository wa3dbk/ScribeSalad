WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.274
Consider the case where you have way more data, way more work than processors.

00:00:05.274 --> 00:00:09.463
In this case, your implementation speed is limited by the number of processors

00:00:09.463 --> 00:00:11.619
because your processors are busy all the time.

00:00:11.619 --> 00:00:15.902
So you'd prefer the implementation that is more work efficient.

00:00:15.902 --> 00:00:19.270
Firstly, let's say you have more processors than work.

00:00:19.270 --> 00:00:24.570
In this case, you have plenty of processors, so you're limited instead by the number of steps in the algorithm,

00:00:24.570 --> 00:00:27.845
and you'd be willing to do more work to get fewer steps.

00:00:27.845 --> 00:00:30.461
You've got more than enough processors to handle the extra work,

00:00:30.461 --> 00:00:34.333
so you'd pick the implementation that is more step efficient.

00:00:34.333 --> 00:00:39.257
There are a number of interesting parallel algorithms that have a pattern that looks like this.

00:00:39.257 --> 00:00:44.422
You start off with a lot of work. You narrow down to not very much work.

00:00:44.422 --> 00:00:46.829
And then, you widen back out to a lot of work.

00:00:46.829 --> 00:00:50.441
An example of this is the Blelloch scan that we just looked at.

00:00:50.441 --> 00:00:52.700
You start reducing with a large number of items.

00:00:52.700 --> 00:00:54.276
You get down to a small number of items.

00:00:54.276 --> 00:00:58.242
And then during down-sweep, you widen out to a large number of items again.

00:00:58.242 --> 00:01:01.840
In this case, an advanced but good strategy is to start off

00:01:01.840 --> 00:01:05.233
with a work efficient algorithm when there's lots of work.

00:01:05.233 --> 00:01:09.775
Once you get down to not very much work, you switch to a step efficient algorithm,

00:01:09.775 --> 00:01:12.013
when you have more processors than work.

00:01:12.013 --> 00:01:16.073
And then, as you start to widen back out, you switch back to a work efficient algorithm,

00:01:16.073 --> 00:01:18.748
when you have enough work to fill the machine again.

00:01:18.748 --> 00:01:23.360
So now, as a quiz, we're going to look at 3 different scenarios of things

00:01:23.360 --> 00:01:26.523
that we want to scan and given a particular hardware configuration.

00:01:26.523 --> 00:01:30.359
Your task is to figure out which best suited--the serial algorithm,

00:01:30.359 --> 00:01:33.169
the step efficient Hillis and Steele algorithm,

00:01:33.169 --> 00:01:35.234
or the work efficient Blelloch algorithm.

00:01:35.234 --> 00:01:38.357
And the scenarios are, you have a 512 element vector

00:01:38.357 --> 00:01:41.506
and a machine like a GPU that has 512 processors,

00:01:41.506 --> 00:01:45.744
you have a 1 million element input vector in 512 processors,

00:01:45.744 --> 00:01:49.190
or a 128K element vector with one processor.

