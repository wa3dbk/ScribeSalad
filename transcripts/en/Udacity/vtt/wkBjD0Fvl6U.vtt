WEBVTT
Kind: captions
Language: en

00:00:00.540 --> 00:00:02.350
In addition to having multiple tapes,

00:00:02.350 --> 00:00:05.400
there are other curious variance
of the basic turning machine.

00:00:05.400 --> 00:00:06.410
We can restrict them so

00:00:06.410 --> 00:00:09.910
that a symbol on any given
square can only be changed once.

00:00:09.910 --> 00:00:12.640
We can let them have
two way infinite tapes.

00:00:12.640 --> 00:00:14.750
Or even let them be non-deterministic.

00:00:14.750 --> 00:00:16.580
We'll examine this idea
when we get to complexity.

00:00:17.680 --> 00:00:20.410
All these things are equivalent to
turning machines in the sense that we've

00:00:20.410 --> 00:00:22.860
been talking about, and it's good
to know that they're equivalent.

00:00:23.910 --> 00:00:24.980
Ultimately, however,

00:00:24.980 --> 00:00:28.160
I doubt that the equivalent of those
models does much to convince anyone that

00:00:28.160 --> 00:00:30.740
Turing machines capture
the common notion of computation.

00:00:31.760 --> 00:00:35.010
To make that argument, we'll show that
a Turing machine is equivalent to

00:00:35.010 --> 00:00:38.610
the random access model,
which very closely resembles the basic

00:00:38.610 --> 00:00:42.819
CPU register memory paradigm behind
the design of modern computers.

00:00:44.290 --> 00:00:45.960
Here is a representation
of the RAM Model.

00:00:46.960 --> 00:00:50.010
Instead of operating with a finite
alphabet like a Turing machine,

00:00:50.010 --> 00:00:53.120
the RAM model operates with
non-negative integers,

00:00:53.120 --> 00:00:54.540
which can be arbitrarily large.

00:00:55.540 --> 00:01:00.224
It has registers, useful for storing
operands for basic operations, and

00:01:00.224 --> 00:01:05.146
an infinite storage device analogous to
the tape of a regular Turing machine.

00:01:05.146 --> 00:01:07.909
I'll call this memory,
for obvious reasons.

00:01:07.909 --> 00:01:10.347
There are two key differences
between this memory and

00:01:10.347 --> 00:01:12.960
the tape of a regular Turing machine.

00:01:12.960 --> 00:01:17.090
One is that each position on
this device stores a number.

00:01:17.090 --> 00:01:20.935
And the other is that any element can
be read with a single instruction

00:01:20.935 --> 00:01:24.315
instead of having to move ahead
over the tape to the right spot.

00:01:24.315 --> 00:01:28.735
In addition to this storage, the machine
also contains the program itself,

00:01:28.735 --> 00:01:31.212
expressed as a sequence of instructions.

00:01:31.212 --> 00:01:34.002
And a special register
called the program counter,

00:01:34.002 --> 00:01:38.032
which keeps track of which
instruction should be executed next.

00:01:38.032 --> 00:01:40.492
Every instruction is one of a finite set

00:01:40.492 --> 00:01:43.942
that closely resembles
the instructions of assembly code.

00:01:43.942 --> 00:01:46.752
For instance,
we have the read instruction,

00:01:46.752 --> 00:01:51.860
read j, which reads the contents
from the jth address on the memory.

00:01:51.860 --> 00:01:53.450
And places it in register zero.

00:01:54.490 --> 00:01:57.380
Register zero, by the way,
has a special status.

00:01:57.380 --> 00:01:59.910
And is involved in
almost every operation.

00:01:59.910 --> 00:02:02.245
We also have a write operation,

00:02:02.245 --> 00:02:05.971
which writes to the jth
address in memory from R0.

00:02:05.971 --> 00:02:11.470
If we're moving data between registers,
we have load, which writes to R0.

00:02:11.470 --> 00:02:14.474
And store, which writes from it,

00:02:14.474 --> 00:02:19.146
as well as add which increases
R0 by the amount in Rj.

00:02:19.146 --> 00:02:22.853
All of these operations cause the
program counter to be incremented by one

00:02:22.853 --> 00:02:24.990
after they're finished.

00:02:24.990 --> 00:02:27.490
To jump around in the list however,

00:02:27.490 --> 00:02:30.460
we have a series of
special jump instructions

00:02:30.460 --> 00:02:34.740
that changed the program counter,
sometimes depending on the value in R0.

00:02:34.740 --> 00:02:39.330
And finally, of course, we have the halt
instruction to end the program.

00:02:39.330 --> 00:02:44.660
The final value in R0 determines
whether we accept or reject.

00:02:44.660 --> 00:02:47.550
Note that in our definition
here there's no multiplication,

00:02:47.550 --> 00:02:49.340
we can achieve that
through repeated addition.

00:02:50.420 --> 00:02:53.460
We won't have much use for
the notation surrounding the RAM model.

00:02:53.460 --> 00:02:56.100
But nevertheless it's good to write
things down mathematically as

00:02:56.100 --> 00:02:58.830
this sometimes sharpens
our understanding.

00:02:58.830 --> 00:03:03.050
In this spirit, we say that a random
access Turing machine consists of

00:03:03.050 --> 00:03:06.940
a natural number K indicating
the number of registers, and

00:03:06.940 --> 00:03:09.510
a sequence of instructions pi.

00:03:09.510 --> 00:03:14.020
The configuration of a random access
machine is defined by the counter value

00:03:14.020 --> 00:03:16.090
which is 0 for the state.

00:03:16.090 --> 00:03:19.890
And indicates the next instruction
to be executed otherwise.

00:03:19.890 --> 00:03:22.160
Also, we have the register values and

00:03:22.160 --> 00:03:24.980
the values in memory,
which can be expressed as a function.

00:03:26.100 --> 00:03:30.162
Note that only a finite number of the
addresses will contain a nonzero value,

00:03:30.162 --> 00:03:33.048
so this function always has
a finite representation.

00:03:33.048 --> 00:03:35.290
We'll use one-based indexing.

00:03:35.290 --> 00:03:39.485
Hence the domain for the tape is
the natural numbers starting from 1.

