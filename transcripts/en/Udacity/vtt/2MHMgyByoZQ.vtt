WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.464
In this example, I have a client side
application that logs in with Google and

00:00:04.464 --> 00:00:06.606
is provided a one time use auth code.

00:00:06.606 --> 00:00:10.657
The client sends this auth code off to
my server in which in turn communicates

00:00:10.657 --> 00:00:15.170
with Google in order to exchange
the code for an authorization token.

00:00:15.170 --> 00:00:18.628
The client then sends off this
code to my server, which in turn

00:00:18.628 --> 00:00:22.897
communicates with Google in order to
exchange the code for an access token.

00:00:22.897 --> 00:00:25.883
If the exchange is successful,
then I create my own token,

00:00:25.883 --> 00:00:29.723
which I can send back off to the client
to authenticate with my application.

00:00:29.723 --> 00:00:32.864
Letâ€™s start by registering our
application with Google in order to get

00:00:32.864 --> 00:00:34.220
a client ID.

00:00:34.220 --> 00:00:37.510
We can download our credentials into
a JSON file our code can then point to.

00:00:38.730 --> 00:00:41.110
A more detailed walk through is
provided in the instructor notes.

00:00:42.130 --> 00:00:43.004
Now in the code,

00:00:43.004 --> 00:00:47.254
let's start by refactoring my user model
to take advantage of some of the profile

00:00:47.254 --> 00:00:49.892
information I can get from
my OAuth access token.

00:00:49.892 --> 00:00:54.444
A user's name, email and profile picture
can be easily obtained with OAuth.

00:00:54.444 --> 00:00:56.368
So, I will add these fields now.

00:00:56.368 --> 00:00:59.225
I can look up users by their
unique email addresses, so

00:00:59.225 --> 00:01:01.780
I will index my database
based on emails as well.

00:01:04.000 --> 00:01:07.909
Now that I've used that pi,
I will add a new endpoint called

00:01:07.909 --> 00:01:11.250
/oauth/provider that
responds to a post request.

00:01:12.630 --> 00:01:17.540
We will first get the one time auth
code if the parameter is set to Google,

00:01:17.540 --> 00:01:20.680
then we'll take this auth code and
send it off to Google in exchange for

00:01:20.680 --> 00:01:21.470
an access token.

00:01:22.530 --> 00:01:25.770
Once I've successfully received
an access token from Google,

00:01:25.770 --> 00:01:30.080
I can use it to send an API request to
Google to get my users' information.

00:01:30.080 --> 00:01:33.613
I will look up an user based on
the provided email address from

00:01:33.613 --> 00:01:34.591
the Google API.

00:01:34.591 --> 00:01:37.771
If a user exist,
I will receive that user object.

00:01:37.771 --> 00:01:40.377
Otherwise, I will just
make a new user object and

00:01:40.377 --> 00:01:42.612
store their information in my database.

00:01:42.612 --> 00:01:44.148
Now that I have a user object,

00:01:44.148 --> 00:01:48.019
I can generate an off token to allow
that user to access protected endpoints

00:01:48.019 --> 00:01:51.670
without having to provide
a user name and password.

00:01:51.670 --> 00:01:54.740
And since this course doesn't focus on
creating the client side application

00:01:54.740 --> 00:01:57.550
that will send off this
authorization code, I have

00:01:57.550 --> 00:02:00.950
added a template that signs into Google
and displays the one time auth code.

00:02:02.100 --> 00:02:03.580
View the Instructor Notes to see and

00:02:03.580 --> 00:02:05.030
play around with the code
from this video.

