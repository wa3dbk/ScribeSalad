WEBVTT
Kind: captions
Language: en

00:00:00.025 --> 00:00:07.063
Modula-3 is a strongly typed language with built-in safety and encapsulation

00:00:07.063 --> 00:00:14.710
mechanisms. It does automatic management of memory. That is, since it does

00:00:14.710 --> 00:00:20.170
automatic storage management, there are no memory leaks. Modula-3 supports

00:00:20.170 --> 00:00:25.590
a data abstraction called an object with well defined entry points. Only the

00:00:25.590 --> 00:00:31.210
entry points are known outside the object, not the implementation of

00:00:31.210 --> 00:00:35.560
the code for that entry point, or the data structures that are contained within

00:00:35.560 --> 00:00:40.910
an object. And therefore there's no cheating possible as you can do with

00:00:40.910 --> 00:00:45.590
a language like C. And modula-3 allows exposing the

00:00:45.590 --> 00:00:51.275
externally visible methods inside an object using

00:00:51.275 --> 00:00:57.460
generic interfaces. And it also supports the notion of threads that execute in

00:00:57.460 --> 00:00:59.910
the context of the object, and it

00:00:59.910 --> 00:01:04.980
allows raising exceptions, for example, when there

00:01:04.980 --> 00:01:09.330
is a memory access violation. All of the features that I mentioned here in

00:01:09.330 --> 00:01:13.740
a nutshell allows implementing system services as

00:01:13.740 --> 00:01:17.342
an object with well defined entry points.

00:01:17.342 --> 00:01:20.930
This modula-3 allows the creation of logical

00:01:20.930 --> 00:01:25.050
protection domains. What you can do from outside

00:01:25.050 --> 00:01:30.880
the object is what the entry point methods that are inside the object will let

00:01:30.880 --> 00:01:35.450
you do and no more. In other words, we are getting the safety property of

00:01:35.450 --> 00:01:39.710
a monolithic kernel without having to put

00:01:39.710 --> 00:01:43.420
system code in a separate hardware address space.

00:01:43.420 --> 00:01:50.440
So in other words the logical protection domains give you both protection and

00:01:50.440 --> 00:01:52.880
performance, the two things that we

00:01:52.880 --> 00:01:56.610
strive for. Now, what about flexibility? Well,

00:01:56.610 --> 00:01:59.650
the genetic interface mechanism allows you

00:01:59.650 --> 00:02:02.430
to have multiple instances of the same

00:02:02.430 --> 00:02:09.910
service. And a given application may be able to exploit the different instances

00:02:09.910 --> 00:02:13.160
of services that are available, that cater

00:02:13.160 --> 00:02:15.730
to the same generic interface, and that's

00:02:15.730 --> 00:02:17.870
the way you can get flexibility as

00:02:17.870 --> 00:02:23.380
well. And objects that implement specific services

00:02:23.380 --> 00:02:25.970
can be the desired granularity of the

00:02:25.970 --> 00:02:29.360
system designer. It can be fine-grained, or

00:02:29.360 --> 00:02:31.140
it can be a collection. You can

00:02:31.140 --> 00:02:35.460
think of individual hardware resources as fine-grained object.

00:02:35.460 --> 00:02:40.930
For example, a page frame and what you can do with a particular page frame.

00:02:40.930 --> 00:02:44.090
You can have interfaces that provide a

00:02:44.090 --> 00:02:48.200
certain functionality. That can be what an object

00:02:48.200 --> 00:02:54.720
is. For example a page allocation module can be on object. And it can also

00:02:54.720 --> 00:02:56.880
make a collection of interfaces into an

00:02:56.880 --> 00:03:01.110
object. For example, an entire virtual memory subsystem

00:03:01.110 --> 00:03:06.760
can be an object that is hierarchically composed of page allocation module,

00:03:06.760 --> 00:03:12.900
and within that, you may have hardware resources defined as objects as well. And

00:03:12.900 --> 00:03:19.170
all of these objects, whether it is at the course level of a collection of

00:03:19.170 --> 00:03:26.180
interfaces, or individual interface that is a component of this collection,

00:03:26.180 --> 00:03:31.390
or specific hardware resources, all of those are accessible via

00:03:31.390 --> 00:03:36.620
capabilities. Now the word capability may give you jitters, because I just now

00:03:36.620 --> 00:03:40.680
said that capabilities traditionally in

00:03:40.680 --> 00:03:43.870
the operating system parlance signifies a

00:03:43.870 --> 00:03:46.890
heavyweight mechanism. But because we are

00:03:46.890 --> 00:03:50.800
dealing with a strongly typed language,

00:03:50.800 --> 00:03:56.144
capabilities to objects can be supported as pointers.

00:03:56.144 --> 00:04:00.680
Or in other words, the programming language supported pointers can

00:04:00.680 --> 00:04:05.880
serve as capabilities to the objects. So now, with this

00:04:05.880 --> 00:04:10.990
idea access to the resources, that is entry point functions

00:04:10.990 --> 00:04:16.440
within an object that is representing a specific resource,

00:04:16.440 --> 00:04:21.529
is provided via capabilities that are simply language supported pointers.

00:04:22.570 --> 00:04:26.530
And because they are language supported pointers, these capabilities that

00:04:26.530 --> 00:04:29.820
we are talking about here, are much cheaper compared to

00:04:29.820 --> 00:04:34.610
real capabilities as was used in the hydra operating system.

