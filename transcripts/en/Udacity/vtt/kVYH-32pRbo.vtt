WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:03.390
Let's compare notes. When I ran this, surprisingly, I did not get the answer,

00:00:03.390 --> 00:00:07.800
they are the same. Here's what I got. It says, firstAndSecond is Udacity. So

00:00:07.800 --> 00:00:13.260
why isn't it the same as third, which is also Udacity? Let me explain.

00:00:13.260 --> 00:00:17.830
FirstAndSecond is a variable. Any object variable contains a reference to the

00:00:17.830 --> 00:00:23.669
object, like this. The string object contains the letters Udacity. Let's look

00:00:23.669 --> 00:00:28.070
at our other variable. Again, a variable just holds a reference. Now, reference

00:00:28.070 --> 00:00:32.329
to which object? Is it a reference to the same string object or to a different

00:00:32.329 --> 00:00:38.830
one? And that is the key question. The equal equal operator. Checks whether the

00:00:38.830 --> 00:00:43.320
contents of these two variables is exactly the same. In other words, whether

00:00:43.320 --> 00:00:49.575
both variables refer the exact same object. Now actually, they don't. Because

00:00:49.575 --> 00:00:54.131
if you remember what happened, firstAndSecond was obtained by gluing together

00:00:54.131 --> 00:00:59.520
this string and that string. And a brand new object had to be created to hold

00:00:59.520 --> 00:01:04.144
that content the third string was initialized with the literal string, Udacity,

00:01:04.144 --> 00:01:11.115
which came from elsewhere. So, in this case, the objects are different. But we

00:01:11.115 --> 00:01:15.035
don't actually care about that. What we care about is, do they have the same

00:01:15.035 --> 00:01:21.134
contents? And to compare the contents, one has to use the equals method. And

00:01:21.134 --> 00:01:27.606
not the equal, equal operator. Let's do that. Over here, I will check whether

00:01:27.606 --> 00:01:33.031
firstAndSecond equals third. Here's the test. We call the equals method on

00:01:33.031 --> 00:01:39.361
firstAndSecond and pass it third as a parameter. Now when we run the program,

00:01:39.361 --> 00:01:45.689
it will work as expected. The program prints, they are the same. So the take

00:01:45.689 --> 00:01:49.654
away is, when comparing strings, use the equals method and not the equal equal

00:01:49.654 --> 00:01:55.960
operator. And as a reminder, when comparing decimal numbers. Be sure to check

00:01:55.960 --> 00:02:00.780
whether the numbers are close to each other, and also don't use equal equal.

00:02:00.780 --> 00:02:04.676
Now when do you use equal equal? For integers, of course.

