WEBVTT
Kind: captions
Language: en

00:00:00.338 --> 00:00:02.790
Now that you got the basic
structure of Rules down,

00:00:02.790 --> 00:00:05.450
let's talk specifically
about validation rules.

00:00:05.450 --> 00:00:09.300
Validation rules are primarily used for
enforcing the structure of your data and

00:00:09.300 --> 00:00:10.960
the format of your content.

00:00:10.960 --> 00:00:12.290
Take a look over here.

00:00:12.290 --> 00:00:14.330
This is the start of
a validation rule for

00:00:14.330 --> 00:00:17.140
a new value being written
in the listName field.

00:00:17.140 --> 00:00:19.290
And in plain English what it's saying,

00:00:19.290 --> 00:00:22.740
is that the value that's
written here must be a string.

00:00:22.740 --> 00:00:25.369
And it's placement where it's
nested inside userLists and

00:00:25.369 --> 00:00:29.620
then these two wildcard variables,
and the property name listName

00:00:29.620 --> 00:00:34.230
makes it specifically a rule that
affects the listName values.

00:00:34.230 --> 00:00:36.690
So let's take an actual
look at the variables and

00:00:36.690 --> 00:00:39.459
methods that are used within
this expression itself.

00:00:39.459 --> 00:00:42.562
First I'd like to point out
this variable called newData.

00:00:42.562 --> 00:00:46.240
When you're writing your validation
rules, you're almost always going to

00:00:46.240 --> 00:00:49.352
need a way to refer to the value
that is either currently there, or

00:00:49.352 --> 00:00:52.120
that their users try to
write to that location.

00:00:52.120 --> 00:00:54.970
Because of this,
the Firebase rules language provides two

00:00:54.970 --> 00:00:57.656
predefined variables specifically for
these values.

00:00:57.656 --> 00:01:00.279
And they are data and newData.

00:01:00.279 --> 00:01:02.840
You can use these anywhere
within your rules.

00:01:02.840 --> 00:01:05.832
Now data refers to the data
as it currently is, and

00:01:05.832 --> 00:01:09.266
newData refers to the data
after a write has taken place.

00:01:09.266 --> 00:01:14.079
In the rules language, these have
the variable types of RuleDataSnapshots.

00:01:14.079 --> 00:01:17.524
And they're called DataSnapshots,
because they can either be a single

00:01:17.524 --> 00:01:20.730
value or a whole portion of
data in the Firebase database.

00:01:20.730 --> 00:01:23.290
So just to be explicit,
if I had a shopping list

00:01:23.290 --> 00:01:26.390
with something like Lyla's List,
and then I went to edit it.

00:01:26.390 --> 00:01:30.130
Lyla's List would be the current value,
which would be stored in data.

00:01:30.130 --> 00:01:31.450
Awesome List.

00:01:31.450 --> 00:01:35.090
Lyla's Awesome List, would be
the value that'd be stored in newData.

00:01:35.090 --> 00:01:40.372
Now as I stated, both data and newData
are what's known as RuledDataSnapshots.

00:01:40.372 --> 00:01:44.190
And RuledDataSnapshots have a bunch of
methods that you can use in the rules.

00:01:44.190 --> 00:01:45.950
I'll go ahead and link to the API docs,

00:01:45.950 --> 00:01:49.510
where you can read to your heart's
content about all of these methods.

00:01:49.510 --> 00:01:51.620
But here are a couple of interest.

00:01:51.620 --> 00:01:55.770
Because these are DataSnapshots,
which know their location in the tree.

00:01:55.770 --> 00:01:59.950
You can use the parent or child method
to navigate to other nodes in the tree.

00:01:59.950 --> 00:02:03.000
This let's you do cool things like create
rules that compare one of the database

00:02:03.000 --> 00:02:04.610
to another part of the database.

00:02:04.610 --> 00:02:09.150
For example, if you wanted to access
the owner value from your listName rule,

00:02:09.150 --> 00:02:10.520
you could write newData.parent,

00:02:10.520 --> 00:02:14.860
which would take you from
listName up to the parent here.

00:02:14.860 --> 00:02:18.180
Then .child('owner'),
which would take you down to the owner.

00:02:18.180 --> 00:02:19.480
Then finally val,

00:02:19.480 --> 00:02:22.900
which is a method that let's you get
the current value at that variable.

00:02:22.900 --> 00:02:25.782
And for
the user lylafish at this specific node,

00:02:25.782 --> 00:02:28.720
this rule would return this value here.

00:02:28.720 --> 00:02:31.510
And then you could use it in
something like a comparison.

00:02:31.510 --> 00:02:34.330
In this case this is a kind of
silly validate rule that doesn't

00:02:34.330 --> 00:02:35.580
make much sense.

00:02:35.580 --> 00:02:38.660
It's saying that the newData
that you're writing for

00:02:38.660 --> 00:02:41.890
the listName must be the same
as the owner's email.

00:02:41.890 --> 00:02:44.720
So you'd have a bunch of
listNames named after owners.

00:02:44.720 --> 00:02:47.350
But hopefully that gives a little
bit more insight about how you might

00:02:47.350 --> 00:02:49.680
be able to use the parent or
child methods.

00:02:49.680 --> 00:02:53.549
Note that the ability to use parent in
the rules is somewhat different than

00:02:53.549 --> 00:02:56.830
the DataSnapshots that we've
been using in our Android app.

00:02:56.830 --> 00:02:59.460
When you get a DataSnapshot
on the client side, you

00:02:59.460 --> 00:03:03.260
can't see anything that is the parent
of the location that you requested.

00:03:03.260 --> 00:03:03.990
In the rules though,

00:03:03.990 --> 00:03:07.800
you can look at any other part of
the database in order to make a rule.

00:03:07.800 --> 00:03:09.700
Which is why you can use
a method like parent.

00:03:09.700 --> 00:03:11.750
Now as I mentioned,
you can use the value method,

00:03:11.750 --> 00:03:16.170
and that'll give you a primitive value
back from a data or newData object.

00:03:16.170 --> 00:03:19.460
In addition, you have methods that check
for the type at a current location.

00:03:19.460 --> 00:03:22.760
And exist is actually a really helpful
method to use when you're writing rules

00:03:22.760 --> 00:03:27.170
that are specific to whether
a value is being added or removed.

00:03:27.170 --> 00:03:32.220
And with that, we can see that this
isString method here, is one of the type

00:03:32.220 --> 00:03:38.130
method which is making sure that
the value stored in newData is a string.

00:03:38.130 --> 00:03:41.910
Let's see an example of a little bit
of a more complicated rule here.

00:03:41.910 --> 00:03:45.260
So here we've added another
little bit to this rule.

00:03:45.260 --> 00:03:50.140
And basically what this says,
is that newData is both a string, and

00:03:50.140 --> 00:03:53.880
that this new listName has at
least one character in it.

00:03:53.880 --> 00:03:57.360
From this example,
you can see that JavaScript Logical and

00:03:57.360 --> 00:03:59.650
Comparison Operators
are available to you.

00:03:59.650 --> 00:04:03.190
In addition, when you're dealing
with values that are strings,

00:04:03.190 --> 00:04:05.610
there's a subset of
Javascript string methods and

00:04:05.610 --> 00:04:07.195
properties which are available to you.

00:04:07.195 --> 00:04:10.900
newData.val().length is
one such example,

00:04:10.900 --> 00:04:12.850
the length value is available to you.

00:04:12.850 --> 00:04:15.350
And another helpful one
is the matches method,

00:04:15.350 --> 00:04:18.290
which allows you to match a string
against a regular expression.

00:04:18.290 --> 00:04:21.940
For example, if you wanted to validate
data at a location to see if it's in

00:04:21.940 --> 00:04:25.890
the form of an email address, you could
use standard email address Regex.

00:04:25.890 --> 00:04:28.210
And then use matches to
do the actual comparison.

00:04:28.210 --> 00:04:31.770
So that's pretty much the summary of
writing a single validation rule.

00:04:31.770 --> 00:04:32.340
In addition,

00:04:32.340 --> 00:04:35.240
there are a few other things that
you might want to keep in mind.

00:04:35.240 --> 00:04:39.230
The first is that whenever you write
server side validation rules, you should

00:04:39.230 --> 00:04:43.130
also be writing the corresponding
client side validation rules.

00:04:43.130 --> 00:04:43.760
For example,

00:04:43.760 --> 00:04:47.930
in the dialog where somebody changes
a shopping lists listName, you should

00:04:47.930 --> 00:04:51.990
go ahead and check that that listName's
actually greater than zero characters.

00:04:51.990 --> 00:04:54.810
There's no sense wasting one
are your users' data plans,

00:04:54.810 --> 00:04:57.860
by pinging the database with
improperly formatted data.

00:04:57.860 --> 00:05:01.260
So go ahead and save them and
yourself that useless network traffic.

00:05:01.260 --> 00:05:03.790
Second, remember that validation
rules are only checked

00:05:03.790 --> 00:05:05.570
when you're actually writing data.

00:05:05.570 --> 00:05:08.358
This maybe pretty straightforward, but
they're not checked when you read data.

00:05:08.358 --> 00:05:12.720
And finally, validation rules are not
checked when you're deleting data,

00:05:12.720 --> 00:05:16.560
otherwise you'd basically never be able
to remove anything from the database.

00:05:16.560 --> 00:05:19.595
For example, if I try to set
a listName here to null, and

00:05:19.595 --> 00:05:23.405
it was checking validation rules, then
it would complain that null is neither

00:05:23.405 --> 00:05:25.935
a string nor
has a length greater than zero.

00:05:25.935 --> 00:05:27.635
But it doesn't do those checks, and

00:05:27.635 --> 00:05:31.395
instead you don't have any validation
checks when you're deleting something.

00:05:31.395 --> 00:05:33.515
Okay, so now that you know
how to write a single rule,

00:05:33.515 --> 00:05:35.496
let's talk about validating
an entire structure.

