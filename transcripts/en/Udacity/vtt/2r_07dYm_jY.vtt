WEBVTT
Kind: captions
Language: en

00:00:00.210 --> 00:00:04.190
So Layer Blocks sounds like
a powerful technology.

00:00:04.190 --> 00:00:08.870
Can you reflect any on
what change it's meant to

00:00:08.870 --> 00:00:13.460
people as they're confronted with
developing a new application?

00:00:13.460 --> 00:00:16.660
Do they think about the architecting
of it now any differently

00:00:16.660 --> 00:00:18.120
than they did in the past?

00:00:18.120 --> 00:00:21.700
&gt;&gt; Certainly, when we build new
instances of the forecaster.

00:00:23.110 --> 00:00:27.088
It changes dramatically how we
think about configuring that,

00:00:27.088 --> 00:00:31.817
because now there's a lot more structure
in place based on the existence of

00:00:31.817 --> 00:00:36.695
Layer Blocks itself and these assembly
specifications to allow us to plan for

00:00:36.695 --> 00:00:39.341
a new configuration of this capability.

00:00:39.341 --> 00:00:42.720
And to divvy up the parts
when executing it.

00:00:42.720 --> 00:00:47.906
In terms of new capabilities,
I think it's been a mixed bag in

00:00:47.906 --> 00:00:52.894
the sense of I think that people
often find it very difficult

00:00:52.894 --> 00:00:57.910
to come up with the right abstractions,
initially.

00:00:57.910 --> 00:01:00.240
So, even with Layer Blocks and

00:01:00.240 --> 00:01:04.769
with this approach kind of in the bag of
tools, we often don't immediately think,

00:01:04.769 --> 00:01:08.960
when we have a new problem to solve,
that it's going to be a product line.

00:01:08.960 --> 00:01:12.630
Or that's this is
the right way to solve it.

00:01:12.630 --> 00:01:14.390
And I don't know what to do about that.

00:01:14.390 --> 00:01:17.940
Perhaps if we got better at,

00:01:17.940 --> 00:01:21.810
kind of, a priori feature analysis,
it would be more obvious.

00:01:21.810 --> 00:01:29.180
Or perhaps maybe,
you have to build one or two products

00:01:29.180 --> 00:01:32.870
in a product line to recognize that you
have a product line there to begin with.

00:01:32.870 --> 00:01:35.900
I'm not really sure, I think it's
still kind of an open question.

00:01:35.900 --> 00:01:38.570
But that's been our experience to date.

00:01:38.570 --> 00:01:40.250
&gt;&gt; The other thing I'd
like to ask you is, for

00:01:40.250 --> 00:01:45.920
the benefit of the students who might
want to become software architects.

00:01:45.920 --> 00:01:49.658
Do you have any reflection on
the relationship between, kind of,

00:01:49.658 --> 00:01:53.199
the academic knowledge that you
learn about software design,

00:01:53.199 --> 00:01:54.736
software architecture and

00:01:54.736 --> 00:01:59.167
what you have to confront in the real
world with doing software architecture?

00:01:59.167 --> 00:02:01.688
&gt;&gt; So,
let me think of a few things that.

00:02:01.688 --> 00:02:03.069
It's all over the map.

00:02:03.069 --> 00:02:08.479
I've found that, in the last seven
years, I've used just about every

00:02:08.479 --> 00:02:13.441
thing that I've learned in
a software engineering course that,

00:02:13.441 --> 00:02:19.520
at the time, seemed very abstract and
perhaps I thought I'd never use this.

00:02:19.520 --> 00:02:20.028
I do.

00:02:20.028 --> 00:02:23.837
But let me try to be concrete about
things I've found that are definitely

00:02:23.837 --> 00:02:24.721
useful skills.

00:02:24.721 --> 00:02:28.910
So, maybe the biggest one for
me is, well two.

00:02:28.910 --> 00:02:33.907
One is data modeling,
be it data modelling using ER,

00:02:33.907 --> 00:02:36.803
or ORM, or UML, or whatever.

00:02:36.803 --> 00:02:41.740
Getting really good at
modeling at a conceptual level

00:02:41.740 --> 00:02:44.930
the structure of data in a system.

00:02:44.930 --> 00:02:46.860
If you're going to build any kind
of system like the ones I'm just

00:02:46.860 --> 00:02:48.840
mentioning, that is
a really critical skill.

00:02:48.840 --> 00:02:52.370
And even though it's taught pretty
well in database courses and

00:02:52.370 --> 00:02:54.170
a lot of people take database courses,

00:02:54.170 --> 00:02:58.680
you'd be amazed at just how rare
it is to be really good at that.

00:02:58.680 --> 00:03:01.700
So, getting facility and
data modeling and

00:03:01.700 --> 00:03:06.970
not applying it just to database design,
but to any kind of information design

00:03:06.970 --> 00:03:11.440
problem at all, I've found it extremely
useful and to really pay dividends.

00:03:11.440 --> 00:03:16.173
I've also found it really useful to
get really comfortable with many

00:03:16.173 --> 00:03:19.275
different models of
software composition,

00:03:19.275 --> 00:03:24.181
because you just never know when one
might be useful and they often are.

00:03:24.181 --> 00:03:29.098
So, when I was a student
at Georgia Tech,

00:03:29.098 --> 00:03:33.591
I spent a lot of time
learning how to use

00:03:33.591 --> 00:03:38.730
process algebras and CSP, FSP, LOTOS.

00:03:38.730 --> 00:03:41.450
There's a whole family of
these action languages

00:03:41.450 --> 00:03:44.090
that were very interesting to me.

00:03:44.090 --> 00:03:47.370
And we covered them in classes,
and we learned how to use them.

00:03:47.370 --> 00:03:52.900
And they have very nice compositional
capabilities that were very elegant and

00:03:52.900 --> 00:03:55.870
very clean and were very well-studied.

00:03:55.870 --> 00:03:59.810
But it wasn't really clear
how to use them in something.

00:03:59.810 --> 00:04:02.992
There was not a compiler that you would
write programs in this language to use

00:04:02.992 --> 00:04:04.495
to build a big piece of your system.

00:04:04.495 --> 00:04:06.921
But over time,
I've found that they come back a lot.

00:04:06.921 --> 00:04:11.377
In fact, we've started using them
in LogicBlox as the basis for

00:04:11.377 --> 00:04:16.248
building a batch automation framework
where you've got this problem

00:04:16.248 --> 00:04:18.079
of designing work flows.

00:04:18.079 --> 00:04:20.608
And you have to compose them, and
you need to compose them using

00:04:20.608 --> 00:04:22.670
a small number of very
clearly defined operators.

00:04:22.670 --> 00:04:24.780
And doing it cleanly and
being able to reason about it.

00:04:24.780 --> 00:04:26.250
So, things like that
have been very useful.

00:04:26.250 --> 00:04:30.750
Petri nets, which I studied many, many
years ago, and also seemed like a nice,

00:04:30.750 --> 00:04:37.120
elegant way to think about concurrency,
and data flows, and work flows.

00:04:38.270 --> 00:04:41.920
Again, it's not immediately obvious
how to just take that and use it, but

00:04:41.920 --> 00:04:44.820
you'll find that they'll inspire
designs that you'll see in the future.

00:04:44.820 --> 00:04:48.960
And they'll be just the right thing when
you run into some architectural problem.

00:04:48.960 --> 00:04:52.240
What are some others?

00:04:52.240 --> 00:04:56.830
Any kind of algebraic approach to
thinking about software composition,

00:04:56.830 --> 00:04:58.390
I think that, maybe,
is the underlying theme.

00:04:58.390 --> 00:05:03.222
If you can understand nice, clean,
elegant models of software composition.

00:05:03.222 --> 00:05:04.920
What are their properties?

00:05:04.920 --> 00:05:05.820
When are they useful?

00:05:07.320 --> 00:05:09.660
How can you use them to
inspire the designs?

00:05:09.660 --> 00:05:14.110
You'll find that a lot of infrastructure
work that you do tends to be better by

00:05:14.110 --> 00:05:18.423
having been inspired by these ideas that
have been worked out by a lot of very

00:05:18.423 --> 00:05:22.753
smart people over many years, rather
than try to come up with it yourself.

00:05:22.753 --> 00:05:26.875
And, I guess, maybe the last thing
I'd say is a segue from that, and

00:05:26.875 --> 00:05:30.784
that is this is not something that
we tend to to very well generally

00:05:30.784 --> 00:05:32.710
as software developers.

00:05:32.710 --> 00:05:37.080
But knowing a body of related work,
and when you start a new problem,

00:05:37.080 --> 00:05:39.940
try to relate your problem to
a problem that has already been seen,

00:05:39.940 --> 00:05:41.730
because chances are someone
has solved it or

00:05:41.730 --> 00:05:44.150
solved some variant of it that
you can heavily borrow from.

00:05:45.390 --> 00:05:48.620
I think that's huge, and I think that
that's maybe the biggest piece of

00:05:48.620 --> 00:05:50.660
advice I would give to
a budding software architect.

00:05:51.770 --> 00:05:55.620
&gt;&gt; So what I'm hearing is the world
is filled with all kinds of complex

00:05:55.620 --> 00:05:59.475
problems and the more weapons you
can bring to bear to solving them,

00:05:59.475 --> 00:06:02.021
the more likely you are to be able
get a handle on that complexity.

00:06:02.021 --> 00:06:02.955
&gt;&gt; Indeed, Indeed.

00:06:02.955 --> 00:06:08.874
&gt;&gt; Well, Kurt, this has been a wonderful
story you have to tell about this,

00:06:08.874 --> 00:06:13.743
and I'm glad that you were able
to apply some of your academic

00:06:13.743 --> 00:06:15.956
background to solving it.

00:06:15.956 --> 00:06:21.053
And I just want to thank you very much
for conveying that story to the class.

00:06:21.053 --> 00:06:23.370
&gt;&gt; You're very welcome, and thank you
for the opportunity to tell the story.

