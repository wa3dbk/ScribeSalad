WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:03.680
The Floyd-Warshall Algorithm has neat
connection to finding the transitive

00:00:03.680 --> 00:00:07.410
closure of mathematical relations
that I want to cover briefly.

00:00:07.410 --> 00:00:10.530
Consider a relation R over set A.

00:00:10.530 --> 00:00:14.150
That is to say,
R is a subset of A cross A.

00:00:14.150 --> 00:00:18.860
For example, A might represent sports
that one can watch on television and

00:00:18.860 --> 00:00:22.180
the relation might be
someone's viewing preferences.

00:00:22.180 --> 00:00:26.790
Maybe this individual prefers
NBA to college basketball and

00:00:26.790 --> 00:00:28.060
NBA to college football,

00:00:28.060 --> 00:00:32.369
and we also know that he prefers
college football to pro football.

00:00:33.410 --> 00:00:36.190
Since a relation is just
a collection of ordered pairs,

00:00:36.190 --> 00:00:39.460
it makes sense to represent
them as a directive graph.

00:00:39.460 --> 00:00:42.390
And given these preferences, we would
like to be able to infer that this

00:00:42.390 --> 00:00:46.500
individual prefers the NBA
over the NFL as well.

00:00:46.500 --> 00:00:50.110
In effect, if there's a path
from one vertex into another,

00:00:50.110 --> 00:00:53.050
we'd like to add a direct
edge between them.

00:00:53.050 --> 00:00:57.920
In set theory, this is called
the transitive closure of a relation.

00:00:57.920 --> 00:01:01.060
Given what we know already,
there's a fairly simple solution.

00:01:01.060 --> 00:01:05.459
Just give each edge weight 1,
and then run Floyd-Warshall.

00:01:05.459 --> 00:01:08.385
The distance will be infinity
if there's not a path,

00:01:08.385 --> 00:01:11.895
and it will be the minimum number
of edges traversed otherwise.

00:01:11.895 --> 00:01:14.830
This is more information
than we really need however.

00:01:14.830 --> 00:01:18.868
We really just want to know whether
there is a path, not how long it is.

00:01:18.868 --> 00:01:23.309
Hence, in this context, we use
a slight variant where the entries in

00:01:23.309 --> 00:01:28.360
the table are all booleans,
either 0 or 1, instead of integers.

00:01:28.360 --> 00:01:31.600
But otherwise, the algorithm is
going to be essentially the same.

00:01:31.600 --> 00:01:35.990
We initialize the table so
that the entry [i][j] is 1,

00:01:35.990 --> 00:01:39.400
if (ai, aj) is in the relation,
and 0 otherwise.

00:01:40.660 --> 00:01:44.630
Note that I'm letting a1
through an be the set A here.

00:01:44.630 --> 00:01:48.730
Then we keep on adding potential
intermediate elements, and

00:01:48.730 --> 00:01:51.218
updating the table accordingly.

00:01:51.218 --> 00:01:56.540
Here [i][j], are in the relation, if
they're either in the relation already

00:01:56.540 --> 00:02:00.740
or if k acts as a link between them.

00:02:00.740 --> 00:02:04.080
Often, we're interested not in
the transitive closure of relation, but

00:02:04.080 --> 00:02:06.630
in the reflexive transitive closure.

00:02:06.630 --> 00:02:07.140
In this case,

00:02:07.140 --> 00:02:10.860
we just set the diagonal elements
to be 1 from the beginning here.

