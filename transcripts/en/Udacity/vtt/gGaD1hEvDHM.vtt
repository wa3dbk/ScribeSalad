WEBVTT
Kind: captions
Language: en

00:00:00.330 --> 00:00:05.390
So let's do a concrete example of crossover. And so, it turns out that

00:00:05.390 --> 00:00:06.970
the crossover operation is always going to

00:00:06.970 --> 00:00:10.660
depend critically on how you represent the

00:00:10.660 --> 00:00:18.360
input space. So, let's say concretely that our input space is, is eight bit

00:00:18.360 --> 00:00:22.628
strings. So here's two parents, 01101100 and

00:00:22.628 --> 00:00:25.340
11010111. And we're going to introduce them to

00:00:25.340 --> 00:00:27.760
each other. All right, now they know each other.

00:00:27.760 --> 00:00:29.723
&gt;&gt; Mm-hm.

00:00:29.723 --> 00:00:32.350
&gt;&gt; And now we're going to use them

00:00:32.350 --> 00:00:35.010
to create a new individual, a new offspring.

00:00:35.010 --> 00:00:36.310
&gt;&gt; So they're really going to know each other.

00:00:36.310 --> 00:00:39.040
&gt;&gt; All right. Now we've put these two bit sequences together and

00:00:39.040 --> 00:00:41.730
we've lined up so that the bits correspond in each of the

00:00:41.730 --> 00:00:45.760
different positions and now we can ask. How can we use this?

00:00:45.760 --> 00:00:50.410
To generate a new individual that uses elements of the two individuals that

00:00:50.410 --> 00:00:52.530
we have. So if you can think of any ways to do that.

00:00:52.530 --> 00:00:53.396
&gt;&gt; I have some ideas. [LAUGH]

00:00:53.396 --> 00:00:54.368
&gt;&gt; Yeah okay, what you got?

00:00:54.368 --> 00:00:56.150
&gt;&gt; I have lots of ways but I don't think any

00:00:56.150 --> 00:00:59.120
of them can be reproduced for the purposes of this learning lesson.

00:00:59.120 --> 00:01:00.520
&gt;&gt; All right well so let's, let's do ones

00:01:00.520 --> 00:01:02.410
that really kind of stick to the bit patterns.

00:01:02.410 --> 00:01:04.720
&gt;&gt; [LAUGH] I swear there's no way you can

00:01:04.720 --> 00:01:07.060
say this without getting in trouble Michael. All right.

00:01:07.060 --> 00:01:10.830
&gt;&gt; But that's okay. So how about, here's an obvious one. Right,

00:01:10.830 --> 00:01:16.760
if we really push the genetic notion as far as we can then

00:01:16.760 --> 00:01:18.790
each of those things represent, I don't

00:01:18.790 --> 00:01:22.140
know, alleles or some other biological term. And

00:01:22.140 --> 00:01:24.830
so what happens in genetics, right, is

00:01:24.830 --> 00:01:26.960
you mix and match your chromosones and alleles

00:01:26.960 --> 00:01:32.290
together. So why don't I say one child is The first four bits of this

00:01:32.290 --> 00:01:35.000
handsome Charles fellow and the last four

00:01:35.000 --> 00:01:40.430
bits of this beautiful and wonderful Sheila person.

00:01:40.430 --> 00:01:41.830
&gt;&gt; Alright, I see what you're

00:01:41.830 --> 00:01:44.670
doing there. So what you're saying is we're going to pick, well

00:01:44.670 --> 00:01:46.790
maybe this isn't quite what you said but I'm going to imagine

00:01:46.790 --> 00:01:48.800
what you said we're going to pick a random number along the

00:01:48.800 --> 00:01:52.940
sequence at the half-way point. And what we're going to do is

00:01:52.940 --> 00:01:57.950
now mix and match and create two offspring. One uses the first

00:01:57.950 --> 00:02:00.940
half of Charles and the second half of Sheila and then the

00:02:00.940 --> 00:02:03.330
other one is the other way around. And as you can see

00:02:03.330 --> 00:02:06.850
it's this last bit that determines the sex. Anyway, so these are the

00:02:06.850 --> 00:02:10.038
two offspring that these individuals have generated. And this

00:02:10.038 --> 00:02:13.080
particular way of, of combining where you randomly choose a

00:02:13.080 --> 00:02:19.930
position and then flip flop, is called one point crossover.

00:02:19.930 --> 00:02:21.840
Alright, so now I want you to think about this

00:02:21.840 --> 00:02:23.710
for a second Charles. So I don't know if it's

00:02:23.710 --> 00:02:25.710
an inductive bias, but what kind of bias do we

00:02:25.710 --> 00:02:28.640
put in? When we say well we're going to choose one

00:02:28.640 --> 00:02:32.040
of these points and we're going to flip flop based

00:02:32.040 --> 00:02:33.440
on where that point is chosen.

00:02:33.440 --> 00:02:35.460
&gt;&gt; What is that, what is that going to,

00:02:35.460 --> 00:02:37.250
what kind of offspring is that going to generate?

00:02:37.250 --> 00:02:40.800
&gt;&gt; Huh. Also, you know what, I see 2, I

00:02:40.800 --> 00:02:43.480
see 2 kind of assumptions built there. So, maybe that

00:02:43.480 --> 00:02:46.200
an inductive bias, so. Or a bias of some sort.

00:02:46.200 --> 00:02:50.460
So, one assumption is that locality of the bits matter. Good.

00:02:50.460 --> 00:02:54.170
&gt;&gt; Right. So the first by picking halfway through, you are saying,

00:02:54.170 --> 00:02:57.280
the first four bits are somehow related and the lsat four bits

00:02:57.280 --> 00:02:59.610
are somehow related because otherwise they wouldn't make any

00:02:59.610 --> 00:03:03.560
sense. Now to talk about them being together and that

00:03:03.560 --> 00:03:05.280
brings it to my second point which I guess really

00:03:05.280 --> 00:03:09.070
is just a first point. Which is that it assumes

00:03:09.070 --> 00:03:13.260
that there are subparts of the space that can be

00:03:13.260 --> 00:03:17.740
kind of independently optimized that you can then put together.

00:03:17.740 --> 00:03:19.700
Right, and in particular when I say sub spaces to

00:03:19.700 --> 00:03:22.180
optimize, I mean that they're independent part of the subspace,

00:03:22.180 --> 00:03:24.240
so that's actually the example that you gave before

00:03:24.240 --> 00:03:28.120
you said Well there's these two dimensions and each

00:03:28.120 --> 00:03:32.890
dimension kind of matters independently and the total reward

00:03:32.890 --> 00:03:35.910
or the total, the total fitness is some kind

00:03:35.910 --> 00:03:40.220
of linear combination of them. And so I can

00:03:40.220 --> 00:03:42.260
put them, cause if those two things aren't true

00:03:42.260 --> 00:03:44.570
than really doing crossover like this won't help you

00:03:44.570 --> 00:03:47.510
at all. You're just kind of randomly. Mixing things together.

00:03:47.510 --> 00:03:50.450
&gt;&gt; It's kind of an assumption about the way space works, in that,

00:03:50.450 --> 00:03:53.560
kind of like the example we did when we were doing bit guessing.

00:03:53.560 --> 00:03:57.150
That that you can be heading in a good direction, that they're pieces

00:03:57.150 --> 00:04:00.690
that are right and if we reuse those pieces we can get even righter.

00:04:00.690 --> 00:04:02.340
&gt;&gt; Sure.

00:04:02.340 --> 00:04:04.000
&gt;&gt; Alright so, and if it is the case that

00:04:04.000 --> 00:04:07.080
the sequence of the ordering of bits matters, we have this

00:04:07.080 --> 00:04:09.530
locality property. This is actually a fairly sensible thing to

00:04:09.530 --> 00:04:12.630
do. But can you imagine any other way of combing these

00:04:12.630 --> 00:04:14.640
bits together to get to get offspring?

00:04:14.640 --> 00:04:16.769
&gt;&gt; Well, I can think of lots.

00:04:16.769 --> 00:04:18.709
&gt;&gt; Well, so let's, let's focus, you

00:04:18.709 --> 00:04:20.190
know, you have many different possible ideas, but

00:04:20.190 --> 00:04:22.260
let's focus on ideas where we still

00:04:22.260 --> 00:04:25.540
have this subspace to optimize property. But we

00:04:25.540 --> 00:04:27.230
don't really have a locality of bits

00:04:27.230 --> 00:04:29.800
property. We don't really, the ordering doesn't matter

00:04:29.800 --> 00:04:32.450
anymore. So keeping them clumped together like that.

00:04:32.450 --> 00:04:33.720
We don't think that that's a useful thing.

00:04:33.720 --> 00:04:36.280
&gt;&gt; Okay. Well, what would that mean? Tell me what that means.

00:04:36.280 --> 00:04:38.390
&gt;&gt; Well, so,

00:04:38.390 --> 00:04:41.680
The one point crossover, when we talked about that. It really

00:04:41.680 --> 00:04:45.230
matters that you know, the two bits that are next to each

00:04:45.230 --> 00:04:48.940
other are very likely to stay connected, right? That is, it's, it's

00:04:48.940 --> 00:04:52.650
unlikely that the split will happen to happen exactly between them and

00:04:52.650 --> 00:04:54.700
so we'll tend to travel as a group. But, if we

00:04:54.700 --> 00:04:57.080
don't think it's important that the bits that are next to each

00:04:57.080 --> 00:05:00.670
other need to travel together. If we say that It should be

00:05:00.670 --> 00:05:03.960
equally likely for any of the bits to kind of remain together.

00:05:03.960 --> 00:05:07.230
We need to cross over a lot more than just that one time.

00:05:07.230 --> 00:05:10.620
In a sense we might need to cross over every time. Well so,

00:05:10.620 --> 00:05:12.430
what I'm trying to get at here is this notion that what we

00:05:12.430 --> 00:05:14.820
could do is we could generate individuals

00:05:14.820 --> 00:05:16.800
by just scrambling at each bit position.

00:05:16.800 --> 00:05:17.480
&gt;&gt; Okay.

00:05:17.480 --> 00:05:19.870
&gt;&gt; So. The first bit position, maybe

00:05:19.870 --> 00:05:22.400
which stays the same, the second one flips,

00:05:22.400 --> 00:05:25.400
the third one stays the same, the fourth

00:05:25.400 --> 00:05:29.070
one stays the same, the fifth one flips,

00:05:30.100 --> 00:05:32.690
the sixth one stays the same, the seventh one

00:05:32.690 --> 00:05:35.510
flips, and the eighth one stays the same. So now,

00:05:35.510 --> 00:05:39.510
we've got two individuals, and every bit from these individuals

00:05:39.510 --> 00:05:42.020
comes from one of the parents and so that means

00:05:42.020 --> 00:05:44.850
that if there is sub pieces that are current that

00:05:44.850 --> 00:05:48.340
maybe preserved in the offspring but no longer does it

00:05:48.340 --> 00:05:50.510
matter what the ordering is. We get exactly the same

00:05:50.510 --> 00:05:53.810
distribution over offspring, no matter how we order the bits.

00:05:53.810 --> 00:05:54.720
&gt;&gt; Okay.

00:05:54.720 --> 00:05:55.420
&gt;&gt; So

00:05:55.420 --> 00:05:58.220
this idea is sometimes called uniform crossover. And

00:05:58.220 --> 00:06:00.990
essentially, we are just randomizing at each bit position.

00:06:00.990 --> 00:06:03.960
This kind of crossover happens biologically at the level

00:06:03.960 --> 00:06:06.130
of genes right so we, we imagine that we

00:06:06.130 --> 00:06:10.040
get our genes from our parents but the, for

00:06:10.040 --> 00:06:11.670
each different gene like the gene for eyes and

00:06:11.670 --> 00:06:13.490
the gene for hair color are not particularly linked

00:06:13.490 --> 00:06:16.800
to each other they're uniformly chosen at each position.

