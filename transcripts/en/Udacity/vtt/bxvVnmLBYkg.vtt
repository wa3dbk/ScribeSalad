WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.920
Okay, so this is fairly basic so far. What is all this have to do with CS212.

00:00:03.920 --> 00:00:09.030
So in Unit 3, we introduce this memo decorator and the question that's still popping multiple times

00:00:09.030 --> 00:00:14.040
in the forums whereas how can a memorize function or specifically, how can multiple memorize functions

00:00:14.040 --> 00:00:17.940
all maintained their own separate cache when it appears that cache is defined here

00:00:17.940 --> 00:00:19.020
and so let's talk about that.

00:00:19.020 --> 00:00:23.840
And as a reminder, memo gets past the function f and returns a new function which we've called _f

00:00:23.840 --> 00:00:28.660
that contains this cache and this cache basically prevents us from repeating calculations,

00:00:28.660 --> 00:00:32.090
and so the best way to learn anything in programming is still do some experiments.

00:00:32.090 --> 00:00:35.760
So I've written a couple of simple functions here filled in square.

00:00:35.760 --> 00:00:38.890
Just as a reminder, let's take a look at what our main space

00:00:38.890 --> 00:00:41.280
or our global environment looks like like now.

00:00:41.280 --> 00:00:45.660
And now what we've done is we head to the global environment bindings between memo

00:00:45.660 --> 00:00:48.580
and its respective object and likewise, we filled in square.

00:00:48.580 --> 00:00:53.650
Know that we haven't created any new frames yet, any new environments because that doesn't happen

00:00:53.650 --> 00:00:56.760
until we actually call a function and we haven't called any of these functions.

00:00:56.760 --> 00:01:00.980
All right, so what I'm going to do now is I'm going to memorize these functions by adding

00:01:00.980 --> 00:01:05.550
the memo decorator and remember, this is the same--adding this decorator and memo

00:01:05.550 --> 00:01:09.380
is the same as saying fib equals memo of fib.

00:01:09.380 --> 00:01:13.460
This is just some nice syntactic sugar to put on the element, looks like a little nicer.

00:01:13.460 --> 00:01:18.260
And so before we start calling fib and square, I'm going to introduce this print statement into memo

00:01:18.260 --> 00:01:21.520
so that we can try to get an idea of what's going on.

00:01:21.520 --> 00:01:26.510
So here I'm going to print fib(4) and we can see the cache getting updated as we would expect.

00:01:26.510 --> 00:01:33.390
By the end, we will get the result 5 and also have this dictionary contain fib(3), (2), (1) and (0).

00:01:33.390 --> 00:01:35.590
So the cache is behaving as expected.

00:01:35.590 --> 00:01:40.870
Let's see what happens if I run now while making to print commands to fib(4)

00:01:40.870 --> 00:01:42.350
and this is interesting.

00:01:42.350 --> 00:01:47.100
The memorization now occurs in the first print statement in the first time we make these calls.

00:01:47.100 --> 00:01:50.400
By turning at the second call to fib(4), we already have our cache.

00:01:50.400 --> 00:01:54.950
We don't have to do all of these calls to fib. We just get 5. Great!

00:01:54.950 --> 00:02:01.940
Now, the big question--is this cache the same as the cache in the square function up here.

00:02:01.940 --> 00:02:04.400
You've probably have a good guess at the answer but let's just confirm.

00:02:04.400 --> 00:02:09.690
So same thing except when we call square twice and you can see, when I call square the first time,

00:02:09.690 --> 00:02:13.810
it's not telling me that the cache is the cache associated with fib--

00:02:13.810 --> 00:02:19.880
telling me it's empty as we expect, and when I call the second time, of course, we're all set.

00:02:19.880 --> 00:02:23.400
We have this mapping 4 to 16. Good. Now, how does this happen?

00:02:23.400 --> 00:02:28.580
Well, the trick is--a new environment isn't created until we call a function.

00:02:28.580 --> 00:02:33.220
So what happened here is we called memo and we set at_memo--so when we said at_memo

00:02:33.220 --> 00:02:37.540
of fib, we created a new environment what I'm going to call memo.

00:02:37.540 --> 00:02:41.660
In this environment, there was a binding from fib to the associated object.

00:02:41.660 --> 00:02:45.810
Actually, since I didn't do the update wrapper step that we did in class,

00:02:45.810 --> 00:02:50.440
this function name is actually still called _f, but again no separate environment

00:02:50.440 --> 00:02:52.580
for _f yet because we didn't call it yet.

00:02:52.580 --> 00:02:57.480
Likewise, when I plugged the decorator to square, a new environment was created with its own _f

00:02:57.480 --> 00:03:00.420
though this one points to the square function object.

00:03:00.420 --> 00:03:03.400
I almost forgot the important part--both of these have their own cache.

00:03:03.400 --> 00:03:08.700
Now, when I called fib, that's when this environment was created, and when we called fib,

00:03:08.700 --> 00:03:10.650
that's when we created this new environment.

00:03:10.650 --> 00:03:14.400
And we can see that when fib goes looking for cache, if it looks in its local environment

00:03:14.400 --> 00:03:18.940
and doesn't find one, it moves one step of the hierarchy, finds the cache associated

00:03:18.940 --> 00:03:24.060
with this call to memo, uses that, and doesn't care at all about this cache over here.

00:03:24.060 --> 00:03:27.850
Just because these have the same name, they live in totally separate environments,

00:03:27.850 --> 00:03:33.510
and since fib only has access to everything over here and square could only access

00:03:33.510 --> 00:03:39.310
everything over here, there was no correlation, no conflict at all that these both have the name cache

00:03:39.310 --> 00:03:42.340
and we can use the memo decorator exactly the way we want to.

00:03:42.340 --> 00:03:45.420
Thank you Python. Now, this is a lot to cover in a few minutes.

00:03:45.420 --> 00:03:50.010
If you're still confused, feel free to check out the links below on scope and closure,

00:03:50.010 --> 00:03:52.230
which is the topic that we didn't get to today--good luck.

