WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
The answer is: the first two of these do satisfy the correctness property,

00:00:04.000 --> 00:00:05.000
the third one does not.

00:00:05.000 --> 00:00:10.000
And to understand why--well, let's remember what the correctness property is.

00:00:10.000 --> 00:00:16.000
That's that for any message, and any key, we have the property that

00:00:16.000 --> 00:00:18.000
when we encrypt the message with that key,

00:00:18.000 --> 00:00:19.000
and decrypt it with the same key,

00:00:19.000 --> 00:00:21.000
we get the message back.

00:00:21.000 --> 00:00:26.000
And this is what we need for our encryption to be decryptable.

00:00:26.000 --> 00:00:27.000
We need these functions to be inverses.

00:00:27.000 --> 00:00:32.000
So, for the first choice, the encryption function is M + K,

00:00:32.000 --> 00:00:36.000
the decryption function takes that input--which is now called C--

00:00:36.000 --> 00:00:40.000
and subtracts K from it using the properties of arithmetic

00:00:40.000 --> 00:00:43.000
while this is indeed equal to M.

00:00:43.000 --> 00:00:47.000
For the second choice, the encryption function is the identity,

00:00:47.000 --> 00:00:48.000
that gives us M back.

00:00:48.000 --> 00:00:51.000
Certainly this does not provide the security properties that we need,

00:00:51.000 --> 00:00:54.000
we haven't hidden anything about the message.

00:00:54.000 --> 00:00:57.000
And then the decryption function is also the identity.

00:00:57.000 --> 00:00:59.000
Takes in M, gives us M back.

00:00:59.000 --> 00:01:04.000
So this satisfies correctness, certainly does not satisfy security.

00:01:04.000 --> 00:01:09.000
The third property doesn't satisfy the correctness property.

00:01:09.000 --> 00:01:16.000
And the easy way to see that is to observe that the output of this

00:01:16.000 --> 00:01:19.000
is a smaller set than the number of messages.

00:01:19.000 --> 00:01:23.000
So there--for some choices of message and key, this maps to the same value,

00:01:23.000 --> 00:01:30.000
and an example of that would be, if we choose K = 2, if M = 4,

00:01:30.000 --> 00:01:34.000
then the encryption of that message is equal to zero,

00:01:34.000 --> 00:01:40.000
because the remainder of dividing 4 by 2 is zero.

00:01:40.000 --> 00:01:43.000
But if we also choose to message 6, well then,

00:01:43.000 --> 00:01:47.000
the encryption with that same key of 6 is zero.

00:01:47.000 --> 00:01:50.000
Since two messages mapped to the same ciphertext,

00:01:50.000 --> 00:01:53.000
there's no way they could decrypt correctly,

00:01:53.000 --> 00:01:55.000
they can't both decrypt to different values,

00:01:55.000 --> 00:01:58.000
because decryption is just a function, it takes that input,

00:01:58.000 --> 00:02:01.000
it's going to produce the same output in both cases,

00:02:01.000 --> 00:02:03.000
in this case it's going to produce zero, it's not going to produce the message we need.

00:02:03.000 --> 00:02:06.000
So this is neither secure nor correct.

00:02:06.000 --> 00:02:10.000
But once it's not correct we know it's not useful.

00:02:10.000 --> 00:02:14.000
The first one, as it is, is not secure.

00:02:14.000 --> 00:02:17.000
But it's actually pretty close to being secure.

00:02:17.000 --> 00:02:20.000
And if we combine the first one with a modulo operator,

00:02:20.000 --> 00:02:24.000
and we never reuse keys, we'll end up with something that's perfectly secure.

00:02:24.000 --> 00:02:26.000
And that's what I'm going to talk about next.

00:02:26.000 --> 00:02:29.000
I'll introduce the first cipher that we'll talk about,

00:02:29.000 --> 99:59:59.000
and it's actually a cipher that is perfectly secure.

