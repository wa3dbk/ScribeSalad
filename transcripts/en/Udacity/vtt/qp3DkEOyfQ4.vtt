WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
In this homework you're going to solve the subpalindrome problem.

00:00:04.000 --> 00:00:09.000
Now, if you took 101, you saw that a palindrome is a string

00:00:09.000 --> 00:00:13.000
that reads the same forwards as it does backwards.

00:00:13.000 --> 00:00:16.000
R-A-D-A-R. R-A-D-A-R.

00:00:16.000 --> 00:00:22.000
We're going to allow palindromes where the case of the letters can be different.

00:00:22.000 --> 00:00:25.000
This would be a good palindrome even though there is a capital R here

00:00:25.000 --> 00:00:27.000
and a lowercase r there.

00:00:27.000 --> 00:00:33.000
Now, some people allow palindromes where the spaces and punctuation don't count.

00:00:33.000 --> 00:00:36.000
You can throw them in anywhere. We're not going to allow this.

00:00:36.000 --> 00:00:40.000
We're going to only allow cases where there is an exact match.

00:00:40.000 --> 00:00:46.000
This would be a palindrome. It has spaces, but they read the same forwards and backwards.

00:00:46.000 --> 00:00:49.000
That's a good one, and this would not be a palindrome,

00:00:49.000 --> 00:00:53.000
because the space does not occur in the same place forward and backward.

00:00:53.000 --> 00:00:59.000
Now you know what palindrome is, but the problem is to find a subpalindrome.

00:00:59.000 --> 00:01:02.000
Here is a string. We want to find the longest palindrome.

00:01:02.000 --> 00:01:08.000
It turns out that it occurs from here to here.

00:01:08.000 --> 00:01:10.000
Now, how would you find that?

00:01:10.000 --> 00:01:12.000
There's one obvious way to do it.

00:01:12.000 --> 00:01:15.000
It's to try every possible substring,

00:01:15.000 --> 00:01:20.000
so try every starting location--here, here, here, and so on--

00:01:20.000 --> 00:01:27.000
and every ending location--the string "w" by itself, "wh," "whe,"

00:01:27.000 --> 00:01:31.000
then "h" by itself, "he," "her," and so on.

00:01:31.000 --> 00:01:34.000
Try every single one and check to see if they're a palindrome.

00:01:34.000 --> 00:01:37.000
Now, that would work, but it would be slow.

00:01:37.000 --> 00:01:41.000
If there are N characters in the string, then there's N starting locations

00:01:41.000 --> 00:01:48.000
and N ending locations, and each of those substrings can have up to N characters.

00:01:48.000 --> 00:01:52.000
To check all of them out would be an order N-cubed operation.

00:01:52.000 --> 00:01:57.000
There'd be roughly N-cubed checks that you'd have to make to see if two characters are the same.

00:01:57.000 --> 00:02:01.000
What we're asking you to do is to come up with a solution that's faster than that

00:02:01.000 --> 00:02:08.000
that takes in the worst case, roughly N-squared rather than N-cubed comparisons,

00:02:08.000 --> 00:02:10.000
and in most cases will do better.

00:02:10.000 --> 00:02:13.000
When I say operations here, what do I count as an operation?

00:02:13.000 --> 00:02:18.000
I want you to write your routine so that all you do is pick out characters,

00:02:18.000 --> 00:02:24.000
so we pass you in a text and you pick out a character--text sub i, text sub j--

00:02:24.000 --> 00:02:27.000
and then you can do anything you want with the characters you pick out.

00:02:27.000 --> 00:02:31.000
You can convert them to uppercase to make it easier to compare if they're the same.

00:02:31.000 --> 00:02:33.000
You can compare two characters.

00:02:33.000 --> 00:02:39.000
All those operations will be free, but we'll be counting how many of these operations you do.

00:02:39.000 --> 00:02:44.000
Now the trick is to find a good way to go through the text and look at the characters.

00:02:44.000 --> 00:02:46.000
I'm going to tell you a bad way to enumerate through them,

00:02:46.000 --> 00:02:48.000
and you're going to have to come up with a good way.

00:02:48.000 --> 00:02:54.000
Let's say that we knew that text from i to j is a palindrome.

00:02:54.000 --> 00:02:57.000
Maybe that's abcba.

00:02:57.000 --> 00:03:03.000
If we then said let's try to expand this text and look at the next two characters,

00:03:03.000 --> 00:03:08.000
we could do that test, but we wouldn't have learned anything about whether or not

00:03:08.000 --> 00:03:11.000
this is a palindrome given that this is a palindrome.

00:03:11.000 --> 00:03:13.000
We'd have to do the whole test all over again.

00:03:13.000 --> 00:03:18.000
We haven't gained any advantage from what we know about a partial result

00:03:18.000 --> 00:03:20.000
to expand it to a bigger result.

00:03:20.000 --> 00:03:24.000
What we want to do is find some way of saying I know something about

00:03:24.000 --> 00:03:29.000
a palindrome somewhere in the string, and that's going to help me

00:03:29.000 --> 00:03:32.000
more efficiently figure out a bigger piece of the string.

00:03:32.000 --> 00:03:34.000
That's what you're being asked to do.

00:03:34.000 --> 00:03:38.000
I'm going to call our function longest<u>subpalindrome</u>slice.

00:03:38.000 --> 00:03:45.000
A "slice" meaning what I want you to return is the i and j indices of the start and the end,

00:03:45.000 --> 00:03:48.000
and j should be one character after the end

00:03:48.000 --> 00:03:52.000
so the same conventions that we use normally in Python

00:03:52.000 --> 00:03:55.000
such that text[i, j] is the longest palindrome.

00:03:55.000 --> 00:03:58.000
Why did I return the indices rather than the text itself?

00:03:58.000 --> 00:04:02.000
Because you might be interesting in where in the text the palindrome occurs.

00:04:02.000 --> 00:04:07.000
If you have i and j, it's easy to pull out the actual palindrome,

00:04:07.000 --> 00:04:10.000
but if I give you the actual palindrome, it's harder to find where it occurs.

00:04:10.000 --> 00:04:15.000
Here what I'm doing is making an abbreviation for this function.

00:04:15.000 --> 00:04:19.000
"Longest<u>subpalindrome</u>slice is just a variable which names a function.

00:04:19.000 --> 00:04:23.000
Now I'm just assigning another variable L to be equal to that.

00:04:23.000 --> 00:04:27.000
Now these two refer to the same function.

00:04:27.000 --> 00:04:29.000
I can go ahead and do that,

00:04:29.000 --> 00:04:34.000
and I can fit more tests on one line by using the shorter name rather than the longer name.

00:04:34.000 --> 00:04:36.000
Write your function so that all the tests pass.

00:04:36.000 --> 00:04:44.000
Add any other tests you think are useful and make sure you do it through an efficient recurrence relation.

