WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.260
We already have a pretty good tool set for NP completeness. We have SAT. We have vertex cover.

00:00:06.260 --> 00:00:09.310
We have independent set. We have clique.

00:00:09.310 --> 00:00:12.400
And we have shortest tour, and I guess also traveling salesman.

00:00:12.400 --> 00:00:18.260
In some way, it's amazing, isn't it? that all of those problems here are NP complete,

00:00:18.260 --> 00:00:22.360
which means in a way they are equally hard to solve, although they are all quite different.

00:00:22.360 --> 00:00:25.190
Now, I promise you a library of NP completeness.

00:00:25.190 --> 00:00:30.280
What I'm going to give you now is four additional NP complete problems

00:00:30.280 --> 00:00:33.250
that are often very very useful for showing NP completeness

00:00:33.250 --> 00:00:37.470
or also for recognizing NP completeness, because even before you do a formal proof,

00:00:37.470 --> 00:00:41.350
it's usually a good idea to say, "Oh, this problem just looks very close to SAT.

00:00:41.350 --> 00:00:44.290
We better be careful. This could NP complete."

00:00:44.290 --> 00:00:46.410
You don't always have to do the formal proof.

00:00:46.410 --> 00:00:49.390
It can also be a good indication of how hard a problem could be.

00:00:49.390 --> 00:00:54.330
Before additional problems, I would like to show you a problem called 3-SAT,

00:00:54.330 --> 00:01:00.290
a problem called k-coloring, a problem called packing, and a problem called common substring.

00:01:00.290 --> 00:01:05.320
So 3-SAT is basically SAT, but there's one restriction and that is that

00:01:05.320 --> 00:01:11.250
each clause has exactly three variables and that of course is a nice assumption to make in

00:01:11.250 --> 00:01:16.260
many proofs of NP completeness, because if you have exactly three variables in each clause,

00:01:16.260 --> 00:01:19.550
these proofs often become easier to read and much cleaner.

00:01:19.550 --> 00:01:26.350
As a side info, 2-SAT so where each clause has just two variables, a solvable in polynomial time.

00:01:26.350 --> 00:01:30.970
So one number here can make a difference, and the resulting 3-SAT formulas look like this.

00:01:30.970 --> 00:01:36.040
So you have three variables here in this clause then three variables here

00:01:36.040 --> 00:01:38.330
and of course with another index and so on.

00:01:38.330 --> 00:01:45.300
K-coloring asks if you can color a graph with k-colors so k is given as part of the input.

00:01:45.300 --> 00:01:50.020
And what is meant by coloring is that you give each vertex a color such as here.

00:01:50.020 --> 00:01:54.660
So we color this one red, this one red, this one green, and this one also green.

00:01:54.660 --> 00:02:00.680
The constraint is you cannot color two vertices with the same color if they are connected by an edge.

00:02:00.680 --> 00:02:04.590
So this here would not be allowed, and actually, the graph I've drawn here

00:02:04.590 --> 00:02:10.360
cannot be colored with just two colors so you need three colors to color this graph.

00:02:10.360 --> 00:02:13.430
This here for example would be one solution. It cannot be number two.

00:02:13.430 --> 00:02:19.180
And of course that's stated as a question. So is it possible to color the graph using k colors?

00:02:19.180 --> 00:02:23.350
For packing, you have given a number of containers and objects.

00:02:23.350 --> 00:02:30.270
And the containers have a capacity, and the objects have a value and a capacity requirement.

00:02:30.270 --> 00:02:34.310
So you have containers like these that come in different size and then you have objects.

00:02:34.310 --> 00:02:40.930
You have little objects. You big objects. You have very big objects. And they all have different values.

00:02:40.930 --> 00:02:47.460
So this might be not so valuable. This might be a little bit valuable, and this might be very valuable.

00:02:47.460 --> 00:02:51.320
So usually you cannot put all of these objects here into the containers.

00:02:51.320 --> 00:02:56.150
So the question is what is the maximum value that you can put into the containers?

00:02:56.150 --> 00:02:59.350
And of course, you could have the case that, for example, the bigger object

00:02:59.350 --> 00:03:04.260
is actually worth less than the smaller object so there are lots of different combinations here

00:03:04.260 --> 00:03:08.300
and will actually investigate this problem a little bit more in one of the next units.

00:03:08.300 --> 00:03:13.420
Now, common substring is actually a misleading name because some people use this in a wrong way

00:03:13.420 --> 00:03:18.370
I've seen this happened before. It actually should be called common subsequence.

00:03:18.370 --> 00:03:23.210
If somebody says common substring, better ask them if they don't mean common subsequence

00:03:23.210 --> 00:03:26.290
because common substring is actually not an NP complete problem,

00:03:26.290 --> 00:03:28.330
and common subsequence is the following problem.

00:03:28.330 --> 00:03:35.270
You're given two strings so string one and string two. Let's say lemonade and blender.

00:03:35.270 --> 00:03:37.350
And what's the difference between a substring and a subsequence?

00:03:37.350 --> 00:03:43.120
A substring is always lots of characters that are one after the other.

00:03:43.120 --> 00:03:46.910
For a subsequence, you can basically skip certain characters.

00:03:46.910 --> 00:03:52.480
So e, n, a, e is a subsequence of lemonade but not a substring.

00:03:52.480 --> 00:03:56.350
And actually, we will do this as a little brief quiz.

00:03:56.350 --> 99:59:59.000
What is the longest common subsequence of lemonade and blender?

