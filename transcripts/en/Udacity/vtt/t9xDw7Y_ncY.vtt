WEBVTT
Kind: captions
Language: en

00:00:00.200 --> 00:00:06.166
So far, all is good. But now I'm going to do the sneaky thing that I did in the last proof:

00:00:06.167 --> 00:00:11.166
I'm going to put inverse halt into this list of programs. So if inverse halt is run on itself,

00:00:11.167 --> 00:00:16.032
there can only be two cases, right? So, halt can either say yes or no.

00:00:16.033 --> 00:00:19.766
We know it has to be one of the two cases, because there's no other possibility.

00:00:19.767 --> 00:00:26.466
Now, just as above here, what would that mean? So if halt, on inverse halt and inverse halt, would say yes,

00:00:26.467 --> 00:00:33.532
that would mean that inverse halt--and I'm just going to write it like this, so inverse halt stops, given inverse halt as an input.

00:00:33.533 --> 00:00:38.199
And the other case, of course, would mean that inverse halt does not stop, given itself as an input.

00:00:38.200 --> 00:00:45.466
So this is what happens if we read the table in this way. Now, let's read it another way because what we noticed here is that,

00:00:45.467 --> 00:00:52.099
if the program stops when it's given itself as an input, inverse halt on this program should go into an infinite loop.

00:00:52.100 --> 00:00:57.399
In other words, if we transfer what we did here to down here, we would have to write the following.

00:00:57.400 --> 00:01:01.866
So now let's compare those two statements in this line here. And here we said inverse halt will go into an infinite loop

00:01:01.867 --> 00:01:08.866
when given inverse halt, which is just itself, as an input. So you have the same contradiction here as we had in the other proof.

00:01:08.867 --> 00:01:14.499
And of course, the same thing is true down here. So here we said inverse halt does not stop, given itself as an input.

00:01:14.500 --> 00:01:21.332
And here we said inverse halt does stop when given itself. So this table here is a nice way to introduce the kind of logic crash

00:01:21.333 --> 00:01:26.799
that we use in the proof by contradiction. Because there's two ways of constructing this table.

00:01:26.800 --> 00:01:33.166
So the first way is to construct it this way, basically. Meaning that we look at what halt says--either yes or no--

00:01:33.167 --> 00:01:39.399
so we arrive at the conclusion of what the program does, based on what halt has to say about that program.

00:01:39.400 --> 00:01:44.199
Now, the other way of constructing this table is more or less going this way.

00:01:44.200 --> 00:01:51.399
So, based on what halt will say that the program does, we can predict the behavior of inverse halt.

00:01:51.400 --> 00:01:57.199
And this construction works perfectly fine. So constructing it this way or this way, those are both compatible views.

00:01:57.200 --> 00:02:03.432
With one exception: Once we feed inverse halt into this table, these two logics crash,

00:02:03.433 --> 00:02:10.199
because the conclusions that we draw in this way are exactly the opposite of the conclusions that we draw in this way.

00:02:10.199 --> 00:02:14.866
And that is why the contradiction is happening. And actually, constructing the table this way or this way is perfectly fine.

00:02:14.867 --> 00:02:18.466
The only problem is making the assumption that this halt algorithm here actually exists,

00:02:18.467 --> 00:02:20.300
which you already know it doesn't.

