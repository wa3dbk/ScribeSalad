WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.290
And the answer here is that I would recommend that Alice run both algorithms

00:00:04.290 --> 00:00:08.780
because both algorithms, if you look at them, are very simple so they can be implemented

00:00:08.780 --> 00:00:12.560
to run very fast even if the input graph is very large.

00:00:12.560 --> 00:00:18.190
So if she can first, for example, run the take 2 algorithm and then she already has a solution

00:00:18.190 --> 00:00:22.670
for which she has a guaranteed, so running the take 2 algorithm will defer some information

00:00:22.670 --> 00:00:29.640
about an optimum solution and that is the optimum solution cannot be smaller than some quantity x.

00:00:29.640 --> 00:00:34.220
And if she then runs the greedy algorithm, she can just see if the greedy algorithm

00:00:34.220 --> 00:00:38.080
gives her a solution that is better than the take 2 algorithm.

00:00:38.080 --> 00:00:43.650
In this case, she should take the greedy solution or if it produces adverse solution,

00:00:43.650 --> 00:00:49.300
so if by some accident she's running it on a graph that has the same properties than the one that

00:00:49.300 --> 00:00:53.470
we just constructed to trick the algorithm, then she can take the solution,

00:00:53.470 --> 00:00:55.900
and in this way, she gets the best of both algorithms.

00:00:55.900 --> 00:01:00.260
She gets the good performance or the generally good performance of this algorithm,

00:01:00.260 --> 00:01:03.780
but she ensures that she is within certain guarantees.

00:01:03.780 --> 00:01:07.740
The important thing here to keep in mind is just because an approximation algorithm

00:01:07.740 --> 00:01:13.490
sounds like it make sens or sounds like it is a good idea, doesn't really mean that it is a good idea.

00:01:13.490 --> 00:01:16.500
It could be a good idea, but unless you analyze the algorithms

00:01:16.500 --> 99:59:59.000
and try to prove that properties--you'll never know.

