WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
So let's define that a little more precisely.

00:00:02.000 --> 00:00:04.000
So we're going to find our set of messages--

00:00:04.000 --> 00:00:10.000
is strings of 0s and 1s--so we'll use bits and some fixed length.

00:00:10.000 --> 00:00:14.000
So n is number that gives us the maximum length of a message.

00:00:14.000 --> 00:00:18.000
Our message is selected from all binary strings of length n.

00:00:18.000 --> 00:00:23.000
Our key is also selected from the set of all binary strings of length n.

00:00:23.000 --> 00:00:26.000
And then to do encryption--our encryption function--

00:00:26.000 --> 00:00:29.000
we're going to think of the message as being this sequence of bits

00:00:29.000 --> 00:00:32.000
and the key is also a sequence of bits.

00:00:32.000 --> 00:00:35.000
The result of our encryption is the ciphertext,

00:00:35.000 --> 00:00:37.000
which is a sequence of bits.

00:00:37.000 --> 00:00:40.000
So, length n, where the value of each ciphertext bit

00:00:40.000 --> 00:00:43.000
is equal to the XOR of the corresponding message bit

00:00:43.000 --> 00:00:45.000
and the corresponding key bit.

00:00:45.000 --> 00:00:46.000
So let's try an example.

00:00:46.000 --> 00:00:50.000
And for this example, I'm going to give you the ciphertext

00:00:50.000 --> 00:00:51.000
and the key and the message.

00:00:51.000 --> 00:00:54.000
So suppose our message is the string 'CS,'

00:00:54.000 --> 00:00:57.000
but our message space is in bits.

00:00:57.000 --> 00:01:00.000
Well, the first thing we need to do is to convert those strings to bits

00:01:00.000 --> 00:01:03.000
and we can do that in Python by using ord,

00:01:03.000 --> 00:01:06.000
that takes a one character string and turns it into

00:01:06.000 --> 00:01:07.000
a decimal number.

00:01:07.000 --> 00:01:11.000
And then we need to convert that decimal number into bits.

00:01:11.000 --> 00:01:13.000
Into a binary number.

00:01:13.000 --> 00:01:16.000
And we need to do this for each character in the string.

00:01:16.000 --> 00:01:19.000
We're going to convert it to a character, convert that to bits,

00:01:19.000 --> 00:01:22.000
and I'll show you the code for doing that,

00:01:22.000 --> 00:01:25.000
we'll leave the more interesting code for you to write.

00:01:25.000 --> 00:01:27.000
Here we're converting to bits.

00:01:27.000 --> 00:01:32.000
This is a fairly straightforward, but not the shortest way to do this.

00:01:32.000 --> 00:01:36.000
We're going to make an array of bits as our result for any decimal number

00:01:36.000 --> 00:01:42.000
if it's divisible by 2, we want to have a 0 at the beginning of a result.

00:01:42.000 --> 00:01:44.000
If it's not divisible by 2, that's going to be a 1.

00:01:44.000 --> 00:01:48.000
And then we divide the number by 2 as we go forward.

00:01:48.000 --> 00:01:49.000
So that's going to fill up all the places.

00:01:49.000 --> 00:01:53.000
We want our bits to be particular lengths,

00:01:53.000 --> 00:01:54.000
so we have a padding,

00:01:54.000 --> 00:01:57.000
and for all the characters, we'll use 7 bits.

00:01:57.000 --> 00:02:00.000
So we're going to pad the result with leading zeros

00:02:00.000 --> 00:02:02.000
until we get to that size.

00:02:02.000 --> 00:02:06.000
We can see this--so if we do ord we see that

00:02:06.000 --> 00:02:09.000
the number corresponding to the letter C is 67.

00:02:09.000 --> 00:02:13.000
If we convert that to bits--and we'll use 7 as our padding--

00:02:13.000 --> 00:02:16.000
that gives us enough for 128 different values

00:02:16.000 --> 00:02:19.000
which is enough for the ASCII character values

00:02:19.000 --> 00:02:20.000
that we get back from ord.

00:02:20.000 --> 00:02:23.000
We can see those bits as a list,

00:02:23.000 --> 00:02:26.000
and we can see that a little more easily as a string

00:02:26.000 --> 00:02:31.000
using the display bits procedure that just turned that into a string.

00:02:31.000 --> 00:02:33.000
So now we want to convert more than one character.

00:02:33.000 --> 00:02:36.000
To do that, we have a string to bits procedure

00:02:36.000 --> 00:02:39.000
that goes through all the characters in the string,

00:02:39.000 --> 00:02:42.000
converting each one to bits using convert to bits,

00:02:42.000 --> 00:02:44.000
and concatenating those all together to the result.

00:02:44.000 --> 00:02:47.000
So now we can do string to bits.

00:02:47.000 --> 00:02:50.000
For our two-letter string, and now we get 14 bits as a result.

00:02:50.000 --> 00:02:54.000
So if that's our message, then the value of M is what we got there.

00:02:54.000 --> 00:02:56.000
So this is our message.

00:02:56.000 --> 00:02:59.000
There are 14 bits, n is 14.

00:02:59.000 --> 00:03:01.000
That means--to encrypt this using a One-Time Pad,

00:03:01.000 --> 00:03:05.000
we need a key that also has 14 bits.

00:03:05.000 --> 00:03:07.000
So let's pick our key,

00:03:07.000 --> 00:03:10.000
and--we're just going to make up a random key now.

00:03:10.000 --> 00:03:14.000
Actually finding random values is very important in cryptography,

00:03:14.000 --> 00:03:16.000
and we'll talk about that in a later unit,

00:03:16.000 --> 00:03:18.000
but for now let's just make one up.

00:03:18.000 --> 00:03:19.000
So suppose this is our key.

00:03:19.000 --> 00:03:21.000
Then the ciphertext is just the result of XOR

00:03:21.000 --> 00:03:25.000
in each message bit with the corresponding key bit.

00:03:25.000 --> 00:03:26.000
So that's our ciphertext.

00:03:26.000 --> 00:03:29.000
So the question is, as an interceptor,

00:03:29.000 --> 00:03:31.000
you saw just this ciphertext, you don't know anything

00:03:31.000 --> 00:03:34.000
about the message or the key, and you're going to guess

00:03:34.000 --> 00:03:36.000
possible key values to try to figure out what the message is.

00:03:36.000 --> 00:03:38.000
And what key value would you guess

00:03:38.000 --> 00:03:41.000
that would mislead you to think that the message

00:03:41.000 --> 99:59:59.000
was actually BS instead of CS?

