WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
In this problem we've been asked to determine

00:00:03.000 --> 00:00:09.000
when given a grammar and a string if that string shows that this grammar is ambiguous.

00:00:09.000 --> 00:00:11.000
So how are we going to do that?

00:00:11.000 --> 00:00:16.000
The key here is going to be in writing out derivations of the string under that grammar.

00:00:16.000 --> 00:00:18.000
Let me show you an example.

00:00:18.000 --> 00:00:20.000
Here I've written out a grammar.

00:00:20.000 --> 00:00:24.000
For the sake of writing out the derivations, I'm going to label each rewrite rule

00:00:24.000 --> 00:00:28.000
with a number, just an identifier, so I can refer to this rule as rule 1.

00:00:28.000 --> 00:00:33.000
Let's say my given string is the string a and b.

00:00:33.000 --> 00:00:38.000
What are some ways I can derive ab given this grammar?

00:00:38.000 --> 00:00:42.000
Starting from s, I can take rule--let's do 0.

00:00:42.000 --> 00:00:44.000
That takes me to P.

00:00:44.000 --> 00:00:48.000
From P I can go to aT using rule 2.

00:00:48.000 --> 00:00:51.000
From aT I just need to get b.

00:00:51.000 --> 00:00:54.000
And fortunately, using rule 5, T goes to b.

00:00:54.000 --> 00:00:58.000
So there's 1 way to derive the string ab using this grammar.

00:00:58.000 --> 00:01:03.000
And later on when I do solve this problem, I'm going to refer to this derivation

00:01:03.000 --> 00:01:09.000
in the form of a list where I took rules 0, 2, and 5 to get ab.

00:01:09.000 --> 00:01:13.000
Now, to determine whether or not the grammar is ambiguous

00:01:13.000 --> 00:01:16.000
with regard to this string, I need to try and find another derivation.

00:01:16.000 --> 00:01:20.000
So if I take rule 1 instead of rule 0 starting from S,

00:01:20.000 --> 00:01:23.000
that gives me a and Q.

00:01:23.000 --> 00:01:25.000
From aQ I can take rule 4.

00:01:25.000 --> 00:01:29.000
Rule 4 goes to b, giving me ab.

00:01:29.000 --> 00:01:33.000
So the derivation is 1, 4.

00:01:33.000 --> 00:01:38.000
So I found 2 derivations--these are 2 very different derivations--for the string ab

00:01:38.000 --> 00:01:41.000
under this grammar starting from S.

00:01:41.000 --> 00:01:45.000
That's kind of a good example, but how does that help us solve the problem?

00:01:45.000 --> 00:01:49.000
So, just like an earlier problem in this homework assignment,

00:01:49.000 --> 00:01:51.000
we get to make an important assumption.

00:01:51.000 --> 00:01:56.000
The important assumption I'm making is that whatever grammars we feed into our function,

00:01:56.000 --> 00:01:58.000
they have a finite number of derivations.

00:01:58.000 --> 00:02:03.000
This actually means that there's a finite number of strings in the grammars.

00:02:03.000 --> 00:02:07.000
So they may not be all that interesting, but nonetheless,

00:02:07.000 --> 00:02:10.000
determining whether or not they're ambiguous is a very cool problem.

00:02:10.000 --> 00:02:13.000
So what does that allow us to do?

00:02:13.000 --> 00:02:17.000
It grants us the ability to get a very simple solution

00:02:17.000 --> 00:02:19.000
for detecting whether or not the grammar is ambiguous.

00:02:19.000 --> 00:02:23.000
What we're going to do is simply exhaustively enumerate

00:02:23.000 --> 00:02:26.000
all the derivations for that grammar.

00:02:26.000 --> 00:02:29.000
And the way we're going to do that is take the expand function

00:02:29.000 --> 00:02:32.000
that we wrote at the end of the lecture unit.

00:02:32.000 --> 00:02:36.000
Instead of enumerating just the strings, we're going to enumerate strings

00:02:36.000 --> 00:02:38.000
along with their derivation.

00:02:38.000 --> 00:02:45.000
Once we've enumerated all the derivations, we can check more than 1 derivation for that string.

00:02:45.000 --> 00:02:49.000
If we have found one, then the grammar is ambiguous.

00:02:49.000 --> 00:02:51.000
Otherwise, it's not.

00:02:51.000 --> 00:02:56.000
So if you're like me, you're eager to get right to the code. Let's do that.

00:02:56.000 --> 00:03:02.000
As the hint described, the first thing we're going to do is write our expand function.

00:03:02.000 --> 00:03:05.000
This is going to be taken almost right out of the lecture.

00:03:05.000 --> 00:03:08.000
If you don't remember or haven't seen this syntax before,

00:03:08.000 --> 00:03:13.000
this says I'm going to take the first and second values out of tokens and derivation

00:03:13.000 --> 00:03:16.000
and put them in the tuple (tokens, derivation).

00:03:16.000 --> 00:03:21.000
Here I have 2 loops that are going to enumerate each token in tokens

00:03:21.000 --> 00:03:23.000
and each rule in the grammar.

00:03:23.000 --> 00:03:29.000
I'm going to access them as I want given their position or index.

00:03:29.000 --> 00:03:32.000
So this gives me the rule out of the grammar.

00:03:32.000 --> 00:03:36.000
This says if the current token applies to this rule,

00:03:36.000 --> 00:03:40.000
it's on the left-hand side of this rule, then I'm going to do the following.

00:03:40.000 --> 00:03:44.000
I'm going to yield as part of this generator function a tuple

00:03:44.000 --> 00:03:50.000
where the first value in the tuple is the current state of the string.

00:03:50.000 --> 00:03:53.000
I'm going to make 1 substitution. That's what I'm doing here.

00:03:53.000 --> 00:03:55.000
I'm including everything to the left of the current token,

00:03:55.000 --> 00:04:00.000
making the 1 substitution, and then I'm including everything to the right of the token.

00:04:00.000 --> 00:04:03.000
And then I'm updating the derivation with the rule I used.

00:04:03.000 --> 00:04:05.000
So what does that look like?

00:04:05.000 --> 00:04:08.000
If I go back to the example I had here, let's say I pass in S.

00:04:08.000 --> 00:04:12.000
I am going to go through this list and see every rule that applies to S.

00:04:12.000 --> 00:04:18.000
Rule 0 and rule 1 both apply to S, so I'm going to yield 2 things.

00:04:18.000 --> 00:04:22.000
First one is going to be P because I'm substituting S for P,

00:04:22.000 --> 00:04:25.000
and then I'm going to return the derivation, which is using just rule 0.

00:04:25.000 --> 00:04:27.000
That's going to be the first thing I yield.

00:04:27.000 --> 00:04:33.000
The second thing I yield is going to be the substitution for the second rule, or rule 1.

00:04:33.000 --> 00:04:38.000
And so what I'm going to do in the body of is ambiguous now that I have the expand

00:04:38.000 --> 00:04:42.000
is I'm going to go back around and expand this expression even more.

00:04:42.000 --> 00:04:47.000
So when I expand this expression, I'm going to get 2 things.

00:04:47.000 --> 00:04:50.000
The first one is going to be using rule 2 to get aT,

00:04:50.000 --> 00:04:54.000
and the next one is going to be using rule 3 to just get c.

00:04:54.000 --> 00:04:57.000
So as you can see, I'm starting to build up all these derivations.

00:04:57.000 --> 00:05:00.000
So what I'm going to do in is ambiguous is I'm going to keep building up

00:05:00.000 --> 00:05:04.000
all these derivations until I can't expand anymore,

00:05:04.000 --> 00:05:07.000
and then I'm going to look at all the derivations

00:05:07.000 --> 00:05:09.000
that yield the string I was originally looking for,

00:05:09.000 --> 00:05:14.000
all the derivations once fully expanded yield ab,

00:05:14.000 --> 00:05:17.000
and then check to see if I got there the same way.

00:05:17.000 --> 00:05:20.000
If I got there in 2 different ways, then the grammar is ambiguous

00:05:20.000 --> 00:05:24.000
under the string I was looking for. Otherwise, it's not.

00:05:24.000 --> 00:05:26.000
So let's go write that function.

00:05:26.000 --> 00:05:28.000
I've declared my function.

00:05:28.000 --> 00:05:32.000
I've taken a grammar, a starting location, a starting symbol,

00:05:32.000 --> 00:05:34.000
and the utterance that I'm looking for.

00:05:34.000 --> 00:05:39.000
Enumerated is going to be all the possible strings in the grammar I've built up so far.

00:05:39.000 --> 00:05:42.000
Since I'm just going to start with start, the first value in the tuple

00:05:42.000 --> 00:05:47.000
is just going to be the string start or just the symbol start--

00:05:47.000 --> 00:05:52.000
it's a 1-symbol string--and an empty derivation since I haven't done anything yet.

00:05:52.000 --> 00:05:54.000
So what do I have here?

00:05:54.000 --> 00:05:59.000
I'm going to take my enumerated list, try to enumerate it more,

00:05:59.000 --> 00:06:02.000
try to expand it using the expand function,

00:06:02.000 --> 00:06:06.000
and if it changes, then I'm making progress, I'm finding new strings,

00:06:06.000 --> 00:06:08.000
I'm expanding the derivations,

00:06:08.000 --> 00:06:13.000
and so I should keep going until I've gone through all the finite number of derivations.

00:06:13.000 --> 00:06:16.000
If this hasn't been updated, I haven't done anything new,

00:06:16.000 --> 00:06:18.000
the expand function didn't find anything new,

00:06:18.000 --> 00:06:20.000
I'm just going to break because I'm done.

00:06:20.000 --> 00:06:23.000
I found all the derivations I was looking for.

00:06:23.000 --> 00:06:29.000
So what I'm doing here is I'm going through each entry in my enumerated list.

00:06:29.000 --> 00:06:33.000
I'm going to try expanding that entry.

00:06:33.000 --> 00:06:38.000
If I found something new, then I'm going to add it to my new enumerated list.

00:06:38.000 --> 00:06:40.000
Otherwise, I'm not going to do anything.

00:06:40.000 --> 00:06:43.000
So what this is going to do is it's going to update new enumerated

00:06:43.000 --> 00:06:46.000
for every new thing expand finds.

00:06:46.000 --> 00:06:52.000
So once I've done all that, I'm going to count how many derivations I found

00:06:52.000 --> 00:06:54.000
for my utterance.

00:06:54.000 --> 00:06:59.000
And if I found more than 1, then I've shown the grammar to be ambiguous.

00:06:59.000 --> 00:07:01.000
I'm doing that by doing a list comprehension

00:07:01.000 --> 00:07:06.000
that essentially filters out everything that's not related to the utterance

00:07:06.000 --> 00:07:08.000
and then taking the length of that list.

00:07:08.000 --> 00:07:12.000
If it's greater than 1, then I've found 2 derivations. Otherwise, I haven't.

00:07:12.000 --> 09:59:59.000
So that's how you solve this problem.

