WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.968
We'll look at step complexity first.

00:00:01.968 --> 00:00:07.575
The worst case is that an element has to move all the way from one side of the array to the other side of the array.

00:00:07.575 --> 00:00:10.379
So the example here is the number 5,

00:00:10.379 --> 00:00:14.216
which starts at the far left and then has to travel all the way to the right.

00:00:14.216 --> 00:00:15.936
So how quickly does one item move?

00:00:15.936 --> 00:00:21.857
Its maximum speed is moving 1 position per step since the best they can do is swap with its

00:00:21.857 --> 00:00:23.993
neighbor and move only 1 position away.

00:00:23.993 --> 00:00:30.133
So it takes on the order of n steps to get from 1 side to the other. And how much work does it do per step?

00:00:30.133 --> 00:00:35.105
Well, on every step if we have n items then we're going to do n over 2 comparisons,

00:00:35.105 --> 00:00:42.387
so in total we do order n steps and order n per step, totaling order of n squared.

00:00:42.387 --> 00:00:45.387
Overall, this is not a particularly efficient sort.

00:00:45.387 --> 00:00:49.259
We'd like to be able to do better than order of n squared steps.

00:00:49.259 --> 00:00:53.925
That being said, it's kind of a neat parallel algorithm because we can see that within a step

00:00:53.925 --> 00:00:57.527
each one of these comparisons can proceed completely in parallel.

00:00:57.527 --> 00:01:00.329
So at least, even though this isn't the most efficient algorithm,

00:01:00.329 --> 00:01:04.328
it's at least one that exploits a lot of parallelism in it's underlying structure.

