WEBVTT
Kind: captions
Language: en

00:00:00.410 --> 00:00:03.440
A Monolithic structure definitely gives you protection,

00:00:03.440 --> 00:00:06.220
no questions about that. And we also

00:00:06.220 --> 00:00:10.490
argued that it's performant because of the

00:00:10.490 --> 00:00:14.720
fact that border crossings are minimized and loss

00:00:14.720 --> 00:00:18.060
of locality is minimized. And, and sources

00:00:18.060 --> 00:00:21.000
of copying overhead are minimized. All of that

00:00:21.000 --> 00:00:22.570
add up to giving good performance for

00:00:22.570 --> 00:00:25.680
the Monolithic structure. On the other hand It's

00:00:25.680 --> 00:00:29.290
not easily extensible. Any change to

00:00:29.290 --> 00:00:32.670
the operating system would require rebuilding

00:00:32.670 --> 00:00:36.200
the monolithic structure with the changed

00:00:36.200 --> 00:00:39.300
characteristic of the system service. So, one

00:00:39.300 --> 00:00:45.796
size fits all is what you get with a monolithic structure. A DOS-like structure

00:00:45.796 --> 00:00:52.260
is performant because there is no separation between the application and

00:00:52.260 --> 00:00:56.090
the operating system and, therefore, an application

00:00:56.090 --> 00:00:59.410
can execute system services at the same speed

00:00:59.410 --> 00:01:02.490
as it would execute a procedure call that

00:01:02.490 --> 00:01:05.190
is part of that application itself. And it's

00:01:05.190 --> 00:01:09.140
also easily extensible because you can build

00:01:09.140 --> 00:01:11.960
new versions of system service. To cater to

00:01:11.960 --> 00:01:14.700
the needs of specific applications. But on the

00:01:14.700 --> 00:01:18.510
other hand, it fails on the safety attribute.

00:01:18.510 --> 00:01:21.560
Because there is no boundary separating the

00:01:21.560 --> 00:01:24.780
kernel from the user space. A micro-kernel

00:01:24.780 --> 00:01:28.040
based operating system also. Pays attention to

00:01:28.040 --> 00:01:31.850
protection because it makes sure that the applications

00:01:31.850 --> 00:01:34.600
and the servers are in distinct hardware

00:01:34.600 --> 00:01:37.730
address spaces separated from the microkernel itself

00:01:37.730 --> 00:01:40.420
and it is also easily extensible because

00:01:40.420 --> 00:01:43.860
you can have different servers that provide the

00:01:43.860 --> 00:01:50.600
same service. But differently to cater to the needs of the application but it

00:01:50.600 --> 00:01:54.390
may have performance flaws because of the

00:01:54.390 --> 00:01:57.170
need for so many border crossing that might

00:01:57.170 --> 00:02:03.350
be needed to go between applications and the server processes. Having said that

00:02:03.350 --> 00:02:08.930
I want to give a note of caution, on the surface it may appear That the

00:02:08.930 --> 00:02:14.400
microkernel based approach may not be performant because of the potential for

00:02:14.400 --> 00:02:19.940
frequent border crossings. I'll have a surprise for you on this aspect when we

00:02:19.940 --> 00:02:26.230
discuss the L3 microkernel later on in this course module where it is shown that

00:02:26.230 --> 00:02:33.860
a microkernel. Can be made performant by careful implementation, that's the key.

00:02:33.860 --> 00:02:36.720
I'll leave you with that thought, but we'll come back

00:02:36.720 --> 00:02:39.970
to a micro kernal base design using L3 later on.

