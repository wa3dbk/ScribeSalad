WEBVTT
Kind: captions
Language: en

00:00:00.300 --> 00:00:05.320
Suppose you have m sorted runs in
slow memory where each run is of size

00:00:05.320 --> 00:00:06.710
s items.

00:00:06.710 --> 00:00:11.730
The total number of items,
by the way, is n equals m times s.

00:00:11.730 --> 00:00:16.500
Your task is to merge all of these
sorted runs into a single sorted run

00:00:16.500 --> 00:00:19.210
that would complete
the merge sort algorithm.

00:00:19.210 --> 00:00:23.350
An easy scheme based on the classical
merge sort idea is to merge

00:00:23.350 --> 00:00:24.610
pairs of runs.

00:00:24.610 --> 00:00:29.110
And then pairs of pairs and so
on until you get a final single run.

00:00:29.110 --> 00:00:31.560
Now observe what happens at each level.

00:00:31.560 --> 00:00:36.850
At each level k starting at 0, the size
of the run is 2 to the k times s.

00:00:36.850 --> 00:00:40.360
Now it's probably not too
hard to sort out the details.

00:00:40.360 --> 00:00:43.200
But just to be clear,
let's quickly walk through the steps.

00:00:43.200 --> 00:00:48.780
Start by considering a pair of runs,
each of size 2 to the k minus 1 times s.

00:00:48.780 --> 00:00:50.910
Let's call these A and B.

00:00:50.910 --> 00:00:53.310
Initially A and B live in slow memory.

00:00:53.310 --> 00:00:55.380
Your goal is to produce a merged run,

00:00:55.380 --> 00:00:59.330
C, which will hold 2 to
the k times s items.

00:00:59.330 --> 00:01:01.530
Let's call the output buffer C.

00:01:01.530 --> 00:01:06.020
To execute this merge, let's maintain
three buffers in fast memory.

00:01:06.020 --> 00:01:09.610
Each fast memory buffer will
hold L elements corresponding to

00:01:09.610 --> 00:01:11.390
the transaction size.

00:01:11.390 --> 00:01:15.220
Let's use two of these buffers for
storing elements from A and B, and

00:01:15.220 --> 00:01:18.060
the third one for
storing elements of the output.

00:01:18.060 --> 00:01:22.370
I'll refer to the fast memory
buffers as A hat, B hat and C hat.

00:01:22.370 --> 00:01:27.000
To perform the merge, start by reading
one L sized block from each of A and

00:01:27.000 --> 00:01:30.330
B sitting in slow memory and
move them to fast memory.

00:01:30.330 --> 00:01:32.410
Then carry out the following steps.

00:01:32.410 --> 00:01:36.510
You'll iterate until you've
either read all of A or all of B.

00:01:36.510 --> 00:01:41.260
You'll locally merge elements
from A hat and B hat into C hat.

00:01:41.260 --> 00:01:44.720
Do that until you run out of
elements from A hat or B hat or

00:01:44.720 --> 00:01:47.280
until you fill the output
buffer of C hat.

00:01:47.280 --> 00:01:51.730
If you empty A hat or B hat then just
read more elements from slow memory.

00:01:51.730 --> 00:01:56.230
If you fill C Hat, then just flush the
result to slow memory and empty C Hat.

00:01:56.230 --> 00:01:58.080
Finally if you exhaust A or

00:01:58.080 --> 00:02:02.610
you exhaust B you just need to copy
the remaining elements from B or A.

00:02:02.610 --> 00:02:07.160
So when all is said and done, what does
it cost to merge the pair of runs A, B?

00:02:07.160 --> 00:02:11.690
This scheme only ever loads elements
from A or B from slow memory once.

00:02:12.730 --> 00:02:16.120
And it only writes a given
output block once.

00:02:16.120 --> 00:02:21.410
So, that's a total of 2 to
the K + 1 x S / L transfers.

00:02:21.410 --> 00:02:24.720
Regarding comparisons, there are also
just a linear number of them.

00:02:24.720 --> 00:02:27.600
Now, this is all just to
merge one pair A and B.

00:02:27.600 --> 00:02:30.270
So, let's go back to
the original merge tree.

00:02:30.270 --> 00:02:33.080
The analysis you did was just for
one pair.

00:02:33.080 --> 00:02:36.180
Now, at each level you can
count the number of pairs.

00:02:36.180 --> 00:02:39.450
That will be n divided
be 2 to the k times s.

00:02:39.450 --> 00:02:41.580
What about the total number of levels?

00:02:41.580 --> 00:02:44.610
That's just log base
2 of n divided by s.

00:02:44.610 --> 00:02:47.130
Combining these costs over all levels.

00:02:47.130 --> 00:02:49.254
Here then are the total costs.

00:02:49.254 --> 00:02:53.850
The number of transfers is two
times n over L log n over s.

00:02:53.850 --> 00:02:56.640
The comparisons are n log n over s.

00:02:56.640 --> 00:02:59.938
A good question to ask yourself now is,
self, is this good or bad?

