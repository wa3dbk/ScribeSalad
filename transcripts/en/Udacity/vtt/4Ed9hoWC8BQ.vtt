WEBVTT
Kind: captions
Language: en

00:00:00.170 --> 00:00:02.250
Let's look at the answer to our simple

00:00:02.250 --> 00:00:04.915
barrier quiz where we had this program where both

00:00:04.915 --> 00:00:07.840
threads are going to synchronize on a single barrier and

00:00:07.840 --> 00:00:10.895
then thread one finishes and then thread zero continues

00:00:10.895 --> 00:00:15.340
alone. The question is does a simple barrier implementation

00:00:15.340 --> 00:00:18.280
work for that? And the answer is yes, it

00:00:18.280 --> 00:00:21.799
does work. If we only do this barrier once,

00:00:21.799 --> 00:00:25.418
then the first thread that enters this critical section

00:00:25.418 --> 00:00:28.113
will set the release to zero and increment

00:00:28.113 --> 00:00:30.946
the count to one. The second thread that reaches

00:00:30.946 --> 00:00:33.078
this will increment the count to two. If

00:00:33.078 --> 00:00:36.396
the first thread ends up waiting for release, the

00:00:36.396 --> 00:00:39.003
second one will still see that the count

00:00:39.003 --> 00:00:42.005
is two, reset the count, set the release and

00:00:42.005 --> 00:00:46.884
eventually due to coherence. Remember that coherence guarantees that

00:00:46.884 --> 00:00:50.195
when we read the release eventually we'll see it,

00:00:50.195 --> 00:00:53.524
it's just that we can be arbitrarily delayed. But

00:00:53.524 --> 00:00:56.674
no matter how long we are delayed eventually we see

00:00:56.674 --> 00:00:59.670
it, and there is no way to get stuck here.

00:00:59.670 --> 00:01:02.890
So the thread that does the releasing leaves the barrier,

00:01:02.890 --> 00:01:07.045
that release leaves the barrier. Or it might happen

00:01:07.045 --> 00:01:10.330
that both of them execute this in very close proximity

00:01:10.330 --> 00:01:12.885
to each other, both of them now see the new

00:01:12.885 --> 00:01:15.732
count of two, and then both of them release and

00:01:15.732 --> 00:01:19.150
exit the barrier. Either way, nobody gets stuck.

00:01:19.150 --> 00:01:22.636
The reason why the simpler barrier is not entirely

00:01:22.636 --> 00:01:25.541
correct is not that it doesn't work on the

00:01:25.541 --> 00:01:29.200
first try, it's that it's not reusable. So the

00:01:29.200 --> 00:01:32.340
problem occurs if we try to use this

00:01:32.340 --> 00:01:35.200
barrier again after the first time we use it.

00:01:35.200 --> 00:01:38.308
In which case, somebody might be stuck still here

00:01:38.308 --> 00:01:40.824
and we reset this so that they never leave

00:01:40.824 --> 00:01:46.164
the first instance while everybody else is in the second instance. But unless

00:01:46.164 --> 00:01:51.180
we have that second instance of the barrier, this barrier works. So in this

00:01:51.180 --> 00:01:55.170
particular case if we are sure that we are going to use this barrier only

00:01:55.170 --> 00:01:59.770
once in the entire run of the program then this barrier does work correctly.

