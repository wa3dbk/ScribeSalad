WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:03.790
There are several syntactical tricks
available to make closure expressions

00:00:03.790 --> 00:00:05.240
super concise.

00:00:05.240 --> 00:00:09.230
In fact, this is one of the coolest
aspects of closure expressions in Swift.

00:00:09.230 --> 00:00:11.990
And at times,
one of the most confounding.

00:00:11.990 --> 00:00:15.100
I want to walk you through some of these
tricks using the filter method from

00:00:15.100 --> 00:00:16.630
the array class.

00:00:16.630 --> 00:00:20.290
The filter method is called by
an instance of the array class.

00:00:20.290 --> 00:00:22.640
It takes in a condition
as an argument and

00:00:22.640 --> 00:00:25.880
returns an array that's been
filtered based on that condition.

00:00:25.880 --> 00:00:28.290
The condition is passed in as a closure.

00:00:28.290 --> 00:00:30.540
Here I have an array of examGrades and

00:00:30.540 --> 00:00:33.740
I'm going to filter this array for
all the grades above 70.

00:00:33.740 --> 00:00:36.290
We'll call those grades passingGrades.

00:00:36.290 --> 00:00:39.830
So I call the filter method
with the object examGrades and

00:00:39.830 --> 00:00:42.810
I pass in a closure representing
the filter condition.

00:00:42.810 --> 00:00:44.986
The closure takes in a grade and
int, and

00:00:44.986 --> 00:00:48.990
returns a Bool representing
whether the condition is true.

00:00:48.990 --> 00:00:52.600
At this point, this looks a lot
like the syntax we saw for sort.

00:00:52.600 --> 00:00:53.990
Here's the first trick.

00:00:53.990 --> 00:00:57.100
The compiler can infer
closure expression types

00:00:57.100 --> 00:01:00.700
based on what parameter type
a given function expects.

00:01:00.700 --> 00:01:04.760
In this case, the compiler can infer
that the closure expression for filter.

00:01:04.760 --> 00:01:08.940
We'll take in a parameter that matches
the type of the array being filtered.

00:01:08.940 --> 00:01:12.930
The compiler can also infer that
this closure will return a Bool.

00:01:12.930 --> 00:01:18.280
So here we can leave out the word Int
and we can leave out the word Bool.

00:01:18.280 --> 00:01:22.050
And over here in the side bar, you can
see that we still get the same result.

00:01:23.130 --> 00:01:24.600
Onto the next check.

00:01:24.600 --> 00:01:27.240
If a closure is a single
expression like this one.

00:01:27.240 --> 00:01:30.890
It can be inferred that the result of
that expression should be returned, so

00:01:30.890 --> 00:01:33.250
we can remove the word return.

00:01:33.250 --> 00:01:38.010
And again, over here in the sidebar,
you can see that our filter still works.

00:01:38.010 --> 00:01:42.770
And now for the trick that's been known
to make some code reader's head spin.

00:01:42.770 --> 00:01:44.930
Shorthand argument names.

00:01:44.930 --> 00:01:48.760
Swift provides default argument
names for closure expressions.

00:01:48.760 --> 00:01:51.220
So instead of specifying
a first argument,

00:01:51.220 --> 00:01:54.230
the first argument is known as $0.

00:01:54.230 --> 00:01:57.830
The second argument is known as $1 and
so on.

00:01:57.830 --> 00:02:01.390
So here for example, we don't have
to give this argument a name.

00:02:01.390 --> 00:02:06.098
We don't have to use the name grade,
we can just use the default name for

00:02:06.098 --> 00:02:07.994
the first argument, $0.

00:02:07.994 --> 00:02:10.811
And since we're not giving
grade a name anymore,

00:02:10.811 --> 00:02:14.210
we can omit it here as well
along with the word in.

00:02:14.210 --> 00:02:16.610
Let's see all those
shortcuts one more time.

00:02:16.610 --> 00:02:19.740
We'll go back to the alphabeticalSoup
example from your quiz.

00:02:20.770 --> 00:02:24.700
The closure expression parameter and
return types can be inferred.

00:02:24.700 --> 00:02:31.180
So we can take out String, String and
Bool, along with the arrow of course.

00:02:31.180 --> 00:02:33.360
This is a single expression closure, so

00:02:33.360 --> 00:02:37.080
it can be inferred that it returns
the result of the single expression.

00:02:37.080 --> 00:02:41.690
So we can leave out return, and
we can use shorthand argument names for

00:02:41.690 --> 00:02:42.700
soup1 and soup2.

00:02:44.140 --> 00:02:47.950
And we're left with a statement
that truly is amazingly concise.

