WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.340
The answer here is that all of these six factors can influence the running time of an algorithm.

00:00:05.340 --> 00:00:10.230
So the size of the input, I think that's a rather obvious one so in the example of Alice--

00:00:10.230 --> 00:00:14.290
if she is running her algorithm on a very small network that takes much shorter time

00:00:14.290 --> 00:00:18.800
than if she is running it on the huge Python communication center network for example.

00:00:18.800 --> 00:00:23.740
The structure of the input can also influence the running time of an algorithm.

00:00:23.740 --> 00:00:29.930
So for example if the network was structured in a way that we find that it can be covered

00:00:29.930 --> 00:00:35.470
with one or two monitoring devices, then the algorithm could worked in a way that

00:00:35.470 --> 00:00:39.500
we could immediately stop and not need to look at more complex assignments.

00:00:39.500 --> 00:00:43.520
Finally, the type of computer that we're using that is also very obvious one.

00:00:43.520 --> 00:00:48.600
If you're using a computer that is much faster so say we're using a huge workstation

00:00:48.600 --> 00:00:53.430
instead of a super laptop, then the algorithm would run much faster.

00:00:53.430 --> 00:00:57.530
The amount of memory the computer has that can also be a very important factor,

00:00:57.530 --> 00:01:01.790
although it might not be obvious at first sight while the memory has to do with running time.

00:01:01.790 --> 00:01:06.720
Let's say the memory of your computer is not enough to keep all the data

00:01:06.720 --> 00:01:11.560
that the algorithm is using and it has to use the hard disk for example to do some of the work

00:01:11.560 --> 00:01:16.860
or the memory is not enough and the algorithm has to recalculate certain parts of the solution.

00:01:16.860 --> 00:01:21.160
Memory is also an important factor for running time.

00:01:21.160 --> 00:01:24.200
How the algorithm is implemented that is of course very important.

00:01:24.200 --> 00:01:31.180
So are you using an implementation that is very efficient or do you have unnecessary code or

00:01:31.180 --> 00:01:34.050
any data structures that are inefficient that can

00:01:34.050 --> 00:01:36.880
make a huge difference in the practice when we run an algorithm.

00:01:36.880 --> 00:01:41.020
And finally the programming language use that is of course a debate

00:01:41.020 --> 00:01:44.100
that many people like to have that it certainly a factor.

00:01:44.100 --> 00:01:48.260
So there are some programming languages that will make an algorithm run a lot faster

00:01:48.260 --> 00:01:51.270
than other programming languages.

00:01:51.270 --> 00:01:53.430
And so you need to think about if efficiency matters,

00:01:53.430 --> 00:01:56.760
they usually also use a programming language that is suited for that.

00:01:56.760 --> 00:02:01.180
That's quite a lot of factors to look at and actually, I think there are lots of other factors

00:02:01.180 --> 00:02:04.290
that would also determine the running time of an algorithm.

00:02:04.290 --> 00:02:08.410
So that's why when we talked about analyzing algorithms,

00:02:08.410 --> 00:02:12.800
we'll have to work with the number of simplifications to focus on what's really important

00:02:12.800 --> 99:59:59.000
and not have to take account of all these factors and all the countless others that you might think of.

