WEBVTT
Kind: captions
Language: en

00:00:00.370 --> 00:00:03.610
That concludes our discussion
of the Fast Fourier Transform.

00:00:03.610 --> 00:00:06.830
&gt;From a practical perspective, probably
the most important thing to remember

00:00:06.830 --> 00:00:10.870
from the lesson is that convolution
can be done in n log n time,

00:00:10.870 --> 00:00:12.820
not n squared as one
might naively think.

00:00:13.940 --> 00:00:17.110
Don't be needlessly intimidated by
the need to perform convolution in

00:00:17.110 --> 00:00:18.380
an application.

00:00:18.380 --> 00:00:21.350
And be aware that image and signal
processing libraries use this technique.

00:00:22.670 --> 00:00:24.690
&gt;From the perspective
of algorithm design,

00:00:24.690 --> 00:00:27.490
the Fast Fourier transform falls
in the category of divide and

00:00:27.490 --> 00:00:31.140
conquer algorithms, along with merge
sort and Strassen's algorithm for

00:00:31.140 --> 00:00:34.500
matrix multiplication, for those who
are familiar with those algorithms.

00:00:35.510 --> 00:00:38.900
It has some resemblance to dynamic
programming, too, however.

00:00:38.900 --> 00:00:42.160
Instead of just having one problem,
we have multiple problems

00:00:42.160 --> 00:00:44.990
as we want to evaluate
a polynomial at multiple values.

00:00:46.030 --> 00:00:49.170
And the associated subproblems
overlap in a way captured by that

00:00:49.170 --> 00:00:49.910
butterfly network.

00:00:49.910 --> 00:00:55.230
The butterfly network, by the way, is a
fascinating structure in its own way and

00:00:55.230 --> 00:00:58.300
it's sometimes used in
massively parallel computers.

00:00:58.300 --> 00:01:00.649
It also serves as an important
example in graph theory.

00:01:02.270 --> 00:01:05.260
Another thing to appreciate from
the lesson is the strange twists and

00:01:05.260 --> 00:01:07.370
turns that our development
of the algorithm took.

00:01:08.500 --> 00:01:11.220
We started by thinking about
the general problem of convolution,

00:01:11.220 --> 00:01:14.290
but the algorithm came
much more specifically

00:01:14.290 --> 00:01:17.380
from thinking about the special
case of polynomial multiplication.

00:01:18.790 --> 00:01:22.390
We started by only considering
sequences of integers yet,

00:01:22.390 --> 00:01:25.550
complex numbers became an essential
part of the algorithmic solution.

00:01:26.880 --> 00:01:30.450
Sometimes the ideas you need
come from unexpected places.

00:01:30.450 --> 00:01:33.280
So soak up as much
mathematics as you can.

00:01:33.280 --> 00:01:34.690
You never know when it
might come in handy.

