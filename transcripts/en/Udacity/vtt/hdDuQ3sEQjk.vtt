WEBVTT
Kind: captions
Language: en

00:00:00.360 --> 00:00:04.240
So more specific questions about building these applications

00:00:04.240 --> 00:00:10.390
include the following. One kind of question is, how do the clients know

00:00:10.390 --> 00:00:15.700
what capabilities are available to them? One approach, which is typically used,

00:00:15.700 --> 00:00:22.100
is naming. That is the client has the IP address or URL of server technology.

00:00:22.100 --> 00:00:26.950
Okay? And it, it essentially finds that service by providing that name.

00:00:26.950 --> 00:00:31.720
You can think of this as White Pages in the, in the telephone sense.

00:00:31.720 --> 00:00:37.815
An alternative to this approach is a client saying, I have a need for service x,

00:00:37.815 --> 00:00:44.590
and being able to try to find various resources that can find,

00:00:44.590 --> 00:00:48.040
can provide that service. That's similar to a Yellow Pages lookup.

00:00:49.240 --> 00:00:51.980
Some Yellow Pages technology have come out, but

00:00:51.980 --> 00:00:56.140
it hasn't proven quite as successful as maybe we had hoped.

00:00:56.140 --> 00:01:00.238
Second research question has to do with use of reflection and

00:01:00.238 --> 00:01:05.790
meta-object protocols. Recall that I mentioned that data can sometimes be

00:01:05.790 --> 00:01:10.510
self defining, that is the data itself reflects or

00:01:10.510 --> 00:01:13.930
represents its own structure. The same thing can hold with respect to,

00:01:13.930 --> 00:01:18.580
to programs, that is programs knowing what kind of services they provide

00:01:18.580 --> 00:01:24.950
even knowing how, they deal with non-functional considerations.

00:01:24.950 --> 00:01:27.910
How many transactions can they provide in a given unit of time and so on.

00:01:27.910 --> 00:01:33.660
The third category of questions has to do with data representations. For

00:01:33.660 --> 00:01:39.110
the past 20 years, relational databases have dominated the world, but

00:01:39.110 --> 00:01:45.390
now there's a recognition that one size does not fit all. The different

00:01:45.390 --> 00:01:49.260
kinds of applications might require different kinds of organizations for

00:01:49.260 --> 00:01:53.720
the data. Okay. This movement is sometimes called the NoSQL movement, and

00:01:53.720 --> 00:01:55.350
there is various commercial,

00:01:55.350 --> 00:02:00.130
even solutions out there that you can consider in building your applications.

00:02:00.130 --> 00:02:06.720
Another question is, fat versus thin. Particularly fat versus thin clients.

00:02:06.720 --> 00:02:11.320
This question has actually been with us for a long time. When we had applet's,

00:02:11.320 --> 00:02:17.350
originally developed by Java, the idea was that the client,

00:02:17.350 --> 00:02:24.090
that is the web browser, would, download functionality as needed.

00:02:24.090 --> 00:02:28.190
Be able to try to provide as much functionality close to the user as possible.

00:02:28.190 --> 00:02:33.610
This is sometimes called a fat client. The other extreme is to say, let's make

00:02:33.610 --> 00:02:39.150
the client as thin as possible. That is, all it is is really a user interface.

00:02:39.150 --> 00:02:45.640
Now we've gone back and forth between fat and thin clients. AJAX is a way of

00:02:45.640 --> 00:02:49.930
being able to reduce the overhead of client to server messaging,

00:02:51.050 --> 00:02:55.660
in particular client to server when a whole page is being re-written.

00:02:55.660 --> 00:03:00.460
AJAX is a way of making local changes to web pages without necessarily having

00:03:00.460 --> 00:03:06.080
full server interaction. Another class of questions has to do with the different

00:03:06.080 --> 00:03:11.310
kinds of devices that are now parts of distributed systems. Sometimes those

00:03:11.310 --> 00:03:17.610
devices are relatively constrained by their power consumption and batteries,

00:03:17.610 --> 00:03:23.160
which might mean that their memories and their chips are going to be smaller or

00:03:23.160 --> 00:03:27.390
slower. In which case the overall device is going to

00:03:27.390 --> 00:03:32.150
be somewhat limited that might be a reason to have a thinner client on it.

00:03:32.150 --> 00:03:35.910
Related to that is the whole question of mobility. If part of the application,

00:03:35.910 --> 00:03:39.400
if the client side of the application is moving around, what happens if

00:03:39.400 --> 00:03:43.300
it all suddenly goes in a tunnel, right, and you can't reach it? Your system man

00:03:43.300 --> 00:03:46.680
has to be more robust with dealing with that kind of uncertainty.

