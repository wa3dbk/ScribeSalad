WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.000
So we just saw how to evaluate Arithmetic expressions,

00:00:05.000 --> 00:00:08.000
like (1 + 1) evaluates to 2.

00:00:08.000 --> 00:00:10.000
But we can also consider more complicated expressions,

00:00:10.000 --> 00:00:13.000
like (1 + 2) is equal to 3.

00:00:13.000 --> 00:00:15.000
We can imagine evaluating this part, recursively,

00:00:15.000 --> 00:00:17.000
and getting the answer, 3--

00:00:17.000 --> 00:00:19.000
and then deciding that 3 is equal to 3,

00:00:19.000 --> 00:00:22.000
so this whole thing evaluates to True.

00:00:22.000 --> 00:00:26.000
And these may not seem like very complicated or powerful expressions yet.

00:00:26.000 --> 00:00:28.000
But these are really the building blocks that we're going to use

00:00:28.000 --> 00:00:30.000
to make a working Web browser.

00:00:30.000 --> 00:00:33.000
However, what if I give you an expression like this:

00:00:33.000 --> 00:00:36.000
We want to check and see if (x + 2) is equal to 3.

00:00:36.000 --> 00:00:38.000
What should this return?

00:00:38.000 --> 00:00:40.000
Actually, we're not certain.

00:00:40.000 --> 00:00:43.000
If (x) is currently equal to 1, then it should definitely return 3.

00:00:43.000 --> 00:00:46.000
But if (x) is something else, like negative 300,

00:00:46.000 --> 00:00:48.000
then this won't work out quite as well.

00:00:48.000 --> 00:00:51.000
We need to know the value of (x) to figure this out.

00:00:51.000 --> 00:00:53.000
And, in fact, we need to know the current value of (x)

00:00:53.000 --> 00:00:56.000
because a lot of variables change.

00:00:56.000 --> 00:00:59.000
In fact, we can see this same sort of thing in natural language.

00:00:59.000 --> 00:01:02.000
Here, I've written out a sentence, The king of France is bald,

00:01:02.000 --> 00:01:06.000
that is, syntactically, entirely valid.

00:01:06.000 --> 00:01:10.000
We can imagine trying to figure out if this sentence is True or False,

00:01:10.000 --> 00:01:14.000
but knowing what it means--whether it represents the world correctly or not--

00:01:14.000 --> 00:01:16.000
depends on knowing the current state of the world.

00:01:16.000 --> 00:01:19.000
For example, as of the time of this recording,

00:01:19.000 --> 00:01:22.000
there is no king of France; France is not a monarchy.

00:01:22.000 --> 00:01:26.000
So it's not clear what it means to talk about the hair of the king of France

00:01:26.000 --> 00:01:28.000
when there is no king of France.

00:01:28.000 --> 00:01:30.000
Similarly, if you're writing a Python program

00:01:30.000 --> 00:01:32.000
and you write (x + 1) equals equals 2,

00:01:32.000 --> 00:01:34.000
and you haven't yet defined (x)--

00:01:34.000 --> 00:01:36.000
if there is no king of France--

00:01:36.000 --> 00:01:38.000
it's not clear what this means

00:01:38.000 --> 00:01:40.000
and the Python interpreter is going to give you a run time error,

00:01:40.000 --> 00:01:42.000
a run time error if (x) is not yet defined.

00:01:42.000 --> 00:01:44.000
That's not the only kind of run time error--

00:01:44.000 --> 00:01:47.000
there are many ways things can go wrong--

00:01:47.000 --> 00:01:49.000
but it's one of the most common.

00:01:49.000 --> 00:01:53.000
Now let's just briefly review evaluating expressions in context,

00:01:53.000 --> 00:01:55.000
in the form of a quiz.

00:01:55.000 --> 00:01:58.000
Try it out: I've written a 6-line Python program

00:01:58.000 --> 00:02:02.000
and I would really like it to print out True three times.

00:02:02.000 --> 00:02:04.000
So each of these print statements should have its argument

00:02:04.000 --> 00:02:06.000
evaluate to True.

00:02:06.000 --> 00:02:08.000
What I'd like you to do is fill in each blank

00:02:08.000 --> 00:02:12.000
so that that happens, but you can only fill in blanks with x, y, or z.

00:02:12.000 --> 00:02:14.000
This is kind of a puzzle--

00:02:14.000 --> 00:02:16.000
can you solve constraints or do backwards reasoning

00:02:16.000 --> 09:59:59.000
to figure out how things would have to go.

