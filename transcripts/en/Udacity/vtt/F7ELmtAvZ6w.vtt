WEBVTT
Kind: captions
Language: en

00:00:00.210 --> 00:00:04.510
An optimization similar to inlining, as far as benefits are concerned,

00:00:04.510 --> 00:00:09.660
is called function call inlining. And it takes code that calls a function. So

00:00:09.660 --> 00:00:14.070
we do some work. Then we prepare the function parameters. For example, put them

00:00:14.070 --> 00:00:18.190
in the right registers, according to the calling convention. Then we call

00:00:18.190 --> 00:00:23.690
a function, and then we do more work after that. And when we call a function.

00:00:23.690 --> 00:00:27.780
let's say that the function itself was just adding the first two parameters, and

00:00:27.780 --> 00:00:33.210
putting that in the return value and then returning. So this sends us back here.

00:00:33.210 --> 00:00:36.740
And then we continue with the more work. So this is what a normal function call

00:00:36.740 --> 00:00:41.760
looks like. So now we can try to avoid the overheads of calling the function and

00:00:41.760 --> 00:00:45.130
returning from it, by doing our work.

00:00:45.130 --> 00:00:49.070
Then, we don't have to prepare the function parameters anymore.

00:00:49.070 --> 00:00:52.500
Now what we do is we simply take the work of the function and

00:00:52.500 --> 00:00:57.470
just plug it in here. So in this case, we add up adding the registers for

00:00:57.470 --> 00:01:00.870
example that did contain the values that we eventually ended up parsing here.

00:01:00.870 --> 00:01:03.750
So we didn't need to copy these registers to A0 and

00:01:03.750 --> 00:01:07.560
A1. And we put the result exactly where we need it, for example, R7,

00:01:07.560 --> 00:01:11.340
instead of maybe having to copy from RV to R7.

00:01:11.340 --> 00:01:16.380
And then we can continue with our work. So the first benefit of

00:01:16.380 --> 00:01:20.640
function call inlining is that it eliminates the calling and

00:01:20.640 --> 00:01:26.000
returning overheads, which include not only the function call. Instruction and

00:01:26.000 --> 00:01:31.610
the return instructions themselves. But also the code that prepares the function

00:01:31.610 --> 00:01:35.130
parameters according to the coding convention. And the code that possibly in

00:01:35.130 --> 00:01:38.650
function itself needs to. For example, pull parameters from the stack and

00:01:38.650 --> 00:01:42.870
so on. And then possibly also the work here after we return to get

00:01:42.870 --> 00:01:46.330
the return value into the register where we need it. All of that can be

00:01:46.330 --> 00:01:51.130
done by simply inlining the function and then just using the registers we want.

00:01:51.130 --> 00:01:56.000
And just like loop unrolling which helped scheduling do better, so

00:01:56.000 --> 00:02:00.580
does function call inlining. Because really what we have is. This is where we

00:02:00.580 --> 00:02:05.530
can do scheduling. And then we need to call the function. So these instructions

00:02:05.530 --> 00:02:10.880
cannot be moving around beyond this point. We can do scheduling here but again,

00:02:10.880 --> 00:02:16.540
we cannot do much of this work before the call. And then the function itself.

00:02:16.540 --> 00:02:21.840
Can be scheduled but we have to do it within this. We have three separate

00:02:21.840 --> 00:02:25.720
pieces of code, each of which can be scheduled. But we can not for example take

00:02:25.720 --> 00:02:31.060
something from here and use it to fill an empty spot here. On the other hand,

00:02:31.060 --> 00:02:36.060
after in lining this is just code with no function calls or anything so

00:02:36.060 --> 00:02:40.750
now all of this work is schedulable. For example the work from the function can

00:02:40.750 --> 00:02:45.170
easily be moved around, assuming that the dependencies allow it.

00:02:45.170 --> 00:02:49.910
So inlining also let's us do better scheduling just like loop and rolling did and

00:02:49.910 --> 00:02:54.550
for the same reason. Now we have more work that we can play with.

00:02:54.550 --> 00:02:58.470
Just like loop and rolling the elimination of the overheads for

00:02:58.470 --> 00:03:02.580
calling, returning and so on will reduce the number of instructions.

00:03:02.580 --> 00:03:06.720
The better scheduling will let us reduce the CPI. And

00:03:06.720 --> 00:03:12.000
that means that we can usually improve the execution time by quite a bit.

00:03:12.000 --> 00:03:16.790
The smaller the function, the more benefits from both of these. Because if

00:03:16.790 --> 00:03:21.330
the function is very small, the overheads of calling and returning are high,

00:03:21.330 --> 00:03:26.640
relative to the work we are actually doing. And also if the function is small,

00:03:26.640 --> 00:03:31.140
scheduling within the function is not going to do much, but if we put it.

00:03:31.140 --> 00:03:35.920
Into the existing code, suddenly this instruction here can probably be squeezed

00:03:35.920 --> 00:03:40.600
into an existing cycle without really adding another cycle. And finally there is

00:03:40.600 --> 00:03:45.180
a downside to inlining, and it's very similar to what we had for loop unrolling.

