WEBVTT
Kind: captions
Language: en

00:00:00.590 --> 00:00:03.620
We'll start with the playground from
scratch and go through the code.

00:00:03.620 --> 00:00:07.530
However you can also download a rich
playground with more information for

00:00:07.530 --> 00:00:08.360
your reference.

00:00:08.360 --> 00:00:11.230
You may find the link in
the instructor notes.

00:00:11.230 --> 00:00:15.880
So what does it mean for a closure to be
a first class citizen of the language?

00:00:15.880 --> 00:00:20.300
It means you can use closures just
like any other type, such as ants,

00:00:20.300 --> 00:00:22.050
floats, strings.

00:00:22.050 --> 00:00:23.360
Whatever.

00:00:23.360 --> 00:00:26.840
You can assign them to variables or
constants.

00:00:26.840 --> 00:00:29.550
Put them inside arrays or dictionaries.

00:00:29.550 --> 00:00:33.020
Return them,
as the result of a function or closure.

00:00:33.020 --> 00:00:37.700
And even receive them as parameters
of another function or closure.

00:00:37.700 --> 00:00:39.740
That last part seems
a little bit weird so

00:00:39.740 --> 00:00:41.940
let's start with the most obvious part.

00:00:41.940 --> 00:00:48.170
First of all, we're going to assign
a closure to the Bar or a constant.

00:00:48.170 --> 00:00:53.350
Ok so here we are creating
a closure using Syntax closure.

00:00:53.350 --> 00:00:57.010
And we're assigning that
closure to a constant.

00:00:57.010 --> 00:01:00.890
So that's a little bit different,
and And this closure to six.

00:01:00.890 --> 00:01:06.950
When integer returns another integer and
within the body of it,

00:01:06.950 --> 00:01:12.730
it should be x by the way,
it adds 42 to x.

00:01:12.730 --> 00:01:15.490
Okay so it's a pretty simple closure.

00:01:15.490 --> 00:01:17.460
And closures have types too.

00:01:17.460 --> 00:01:21.070
Look right here in this result sidebar.

00:01:21.070 --> 00:01:26.500
And you'll see that the type of
this closure is Int arrow Int.

00:01:26.500 --> 00:01:31.010
It means it takes one integer and
returns an integer.

00:01:31.010 --> 00:01:35.340
And we can call this closure just
like we would call any function or

00:01:35.340 --> 00:01:36.270
any other closure.

00:01:36.270 --> 00:01:37.630
So, let's give it a try.

00:01:38.790 --> 00:01:44.010
So, the bottom line is we can use the
closure that we saved into the constant

00:01:44.010 --> 00:01:47.920
F, in the normal way,
using the regular syntax.

00:01:48.960 --> 00:01:53.000
However, try to call it passing
the string as a parameter.

00:01:53.000 --> 00:01:56.730
This will cause an error and by now you
should already know what's going on.

00:01:56.730 --> 00:01:59.970
It's not the type that
the closure accepts, so

00:01:59.970 --> 00:02:03.600
it works exactly as functions, so far.

00:02:03.600 --> 00:02:05.010
Let's get rid of this, and

00:02:05.010 --> 00:02:09.080
now let's try something fancier, let's
put a bunch of closures inside an array.

00:02:09.080 --> 00:02:10.720
Let's see if it's possible.

00:02:10.720 --> 00:02:12.860
So here we have an array
called closures.

00:02:12.860 --> 00:02:16.080
With just one closure,
inside and the type,

00:02:16.080 --> 00:02:21.350
is as you would expect,
an array of int to int.

00:02:21.350 --> 00:02:25.205
So this defines what kind of
closure we can put inside.

00:02:25.205 --> 00:02:26.365
Try this array.

00:02:26.365 --> 00:02:30.065
As long as the closure takes one int and

00:02:30.065 --> 00:02:32.895
returns an int,
which would be able to put it in there.

00:02:32.895 --> 00:02:33.825
Let's add a few more.

00:02:35.985 --> 00:02:40.685
Okay, so here we have the final array
with several closures in there.

00:02:41.765 --> 00:02:43.825
All these closures have
one thing in common.

00:02:43.825 --> 00:02:44.775
They have the same type.

00:02:44.775 --> 00:02:46.760
They take an int and return an int.

00:02:46.760 --> 00:02:48.310
How does the compiler know that?

00:02:48.310 --> 00:02:49.990
Because of the first one.

00:02:49.990 --> 00:02:53.730
So this sets the type of
closure that can go in there.

00:02:53.730 --> 00:03:01.130
The second one over here has the full
closure syntax with type information.

00:03:01.130 --> 00:03:06.120
For the parameter and the return type,
that's not really necessary,

00:03:06.120 --> 00:03:08.950
because the compiler has
that information already.

00:03:08.950 --> 00:03:14.950
So the next one avoids the type
information, and it works fine.

00:03:15.990 --> 00:03:17.310
The other one, the next one.

00:03:18.320 --> 00:03:19.980
Doesn't have the return, why?

00:03:19.980 --> 00:03:23.320
Because when a closure
just has one statement,

00:03:23.320 --> 00:03:26.160
one line, the return is implicit.

00:03:26.160 --> 00:03:30.630
So, the compliant knows it
should return x times x.

00:03:30.630 --> 00:03:35.780
And last but not least,
we have this ultra simple version

00:03:35.780 --> 00:03:41.410
where we don't even provide a name for
the parameter because in Swift,

00:03:41.410 --> 00:03:47.880
closures and functions can access
their parameters or arguments.

00:03:47.880 --> 00:03:52.920
By the position so
dollar zero means position zero.

00:03:52.920 --> 00:03:59.260
The first parameter times 42 and

00:03:59.260 --> 00:04:02.740
return that.

00:04:02.740 --> 00:04:07.130
Could we call those closures that
are stored in the India rate.

00:04:07.130 --> 00:04:08.620
Yes, definitely yes.

00:04:08.620 --> 00:04:09.780
So let's give it a try.

00:04:11.350 --> 00:04:17.269
So right here, we're iterating
through the array of closures and

00:04:17.269 --> 00:04:21.639
for each closure we call it passing 42.

00:04:21.639 --> 00:04:25.180
And here you can see the results.

00:04:25.180 --> 00:04:29.070
You can also see it this way.

00:04:29.070 --> 00:04:29.570
Ok.

00:04:31.060 --> 00:04:32.480
Now I've got an exercise for you.

00:04:32.480 --> 00:04:35.390
Try to create an array
with two closures.

00:04:35.390 --> 00:04:40.080
One that takes two integers and
returns the sum as another integer.

00:04:40.080 --> 00:04:45.000
And the other closure should take two
floats and return the sum as a float.

00:04:45.000 --> 00:04:45.910
Would this compile?

00:04:46.980 --> 00:04:47.480
Think why.

