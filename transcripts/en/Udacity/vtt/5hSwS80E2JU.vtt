WEBVTT
Kind: captions
Language: en

00:00:00.350 --> 00:00:02.550
So this is how our history with shared counters

00:00:02.550 --> 00:00:06.096
would work. We have the program counter. We take

00:00:06.096 --> 00:00:08.934
some of the lower most bits, use that to

00:00:08.934 --> 00:00:11.943
index into what we will call PHT or Pattern

00:00:11.943 --> 00:00:16.100
History Table. This is a table that simply keeps

00:00:16.100 --> 00:00:20.032
the history bits alone for that branch. So if

00:00:20.032 --> 00:00:22.612
we have an 11-bit history, this table will have

00:00:22.612 --> 00:00:26.420
11-bits per entry, so it doesn't have the 2-bit counters.

00:00:26.420 --> 00:00:28.420
But we do need the 2-bit counter to eventually

00:00:28.420 --> 00:00:30.470
tell us whether the branch is supposed to be taken

00:00:30.470 --> 00:00:32.613
or not taken. So what we do is we

00:00:32.613 --> 00:00:37.384
take this history from this table, combine it in some

00:00:37.384 --> 00:00:40.882
way, usually using an XOR with a bits of

00:00:40.882 --> 00:00:44.415
the PC. And use that to index into what we

00:00:44.415 --> 00:00:47.980
still will call the Branch History Table. This Branch

00:00:47.980 --> 00:00:51.450
History Table has entries. Each of these entries is just

00:00:51.450 --> 00:00:54.890
a single 2-bit counter. So each entry's very small.

00:00:54.890 --> 00:00:57.070
And that entry will tell us whether we should be

00:00:57.070 --> 00:01:00.710
predicting taken or not taken. When the branch outcome

00:01:00.710 --> 00:01:03.966
is known, we use the same history and PC combination

00:01:03.966 --> 00:01:07.370
to index back into this 2-bit counter, increment or

00:01:07.370 --> 00:01:10.996
decrement it, based on the current decision on a branch,

00:01:10.996 --> 00:01:13.586
and then we shift in that pattern also into

00:01:13.586 --> 00:01:16.546
the PHT entry, so that this history is ready for

00:01:16.546 --> 00:01:19.978
the next prediction on this particular branch. So

00:01:19.978 --> 00:01:22.279
the idea is that the program counter here tells

00:01:22.279 --> 00:01:25.020
us which branch we're talking about. We hope that

00:01:25.020 --> 00:01:28.408
the Pattern History Table has one history per branch

00:01:28.408 --> 00:01:32.270
that we have. Different histories and different pieces

00:01:32.270 --> 00:01:35.770
will result in different 2-bit counters being used, and

00:01:35.770 --> 00:01:38.360
thus, the decisions will be made for kind of

00:01:38.360 --> 00:01:42.030
like the combination of the history and the PC.

00:01:42.030 --> 00:01:44.886
Note that it is possible for another PC to

00:01:44.886 --> 00:01:49.002
map somewhere here, but that history, when XOR with that

00:01:49.002 --> 00:01:52.660
PC gives us, maybe, the same 2-bit counter. So

00:01:52.660 --> 00:01:55.938
it is possible to have some overlap here. But the

00:01:55.938 --> 00:01:58.274
idea is that this way, for each PC, we

00:01:58.274 --> 00:02:01.705
have a single history of all the possible histories that

00:02:01.705 --> 00:02:04.264
is, that is two to the Nth of them. We

00:02:04.264 --> 00:02:07.212
are really using only a very small number of counters

00:02:07.212 --> 00:02:10.428
because very few histories are actually happening, and

00:02:10.428 --> 00:02:12.974
that means that if you have a relatively large

00:02:12.974 --> 00:02:16.190
array of 2-bit counters the possibility of conflict is

00:02:16.190 --> 00:02:19.490
very low. But this allows us to have a

00:02:19.490 --> 00:02:25.790
lot of bits of history. For example, if we take 11-bits of PC, and we index into

00:02:25.790 --> 00:02:28.250
the PHT with them, we will need 2 to

00:02:28.250 --> 00:02:33.400
the 11th histories times, let's say 11-bits of history.

00:02:33.400 --> 00:02:38.430
We excerpt those 11-bits with these 11-bits. So we have 2 to

00:02:38.430 --> 00:02:43.778
the 11th 2-bit counters. So the overall cost of this

00:02:43.778 --> 00:02:48.926
predictor will be 2 to the 11th times 11 for the histories

00:02:48.926 --> 00:02:53.777
plus 2 to the 11th times 2 for the counters, which ends

00:02:53.777 --> 00:02:58.600
up costing us 26 kilobits. This is much less than what the

00:02:58.600 --> 00:03:00.706
cost would be if we had an array of

00:03:00.706 --> 00:03:04.450
2-bit counters for each possible history in each entry

00:03:04.450 --> 00:03:08.652
over here. Pretty much, these 2 to the 11

00:03:08.652 --> 00:03:11.654
times 2, will need to be in each entry here,

00:03:11.654 --> 00:03:15.272
if we didn't do the XOR like this. Note

00:03:15.272 --> 00:03:17.788
also that we don't have to have this numbers

00:03:17.788 --> 00:03:20.576
here and here equal, we can, for example, take

00:03:20.576 --> 00:03:23.704
something like 10-bits of the PC, to index into the

00:03:23.704 --> 00:03:25.608
PHT, which gives us only 2 to the

00:03:25.608 --> 00:03:28.804
10th histories and have a 16-bit history, so that

00:03:28.804 --> 00:03:33.990
we can have 2 to the 16th entries here and so on. It still will keep the overall

00:03:33.990 --> 00:03:36.726
cost in the, you know, tens of kilobits,

00:03:36.726 --> 00:03:39.538
not megabits or gigabits that we would get if

00:03:39.538 --> 00:03:43.110
we tried to put together long histories with dedicating

00:03:43.110 --> 00:03:46.910
2-bit counters for each possible history in each entry.

