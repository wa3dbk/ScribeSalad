WEBVTT
Kind: captions
Language: en

00:00:00.790 --> 00:00:02.740
In the previous lecture, we got done

00:00:02.740 --> 00:00:06.310
with discussing the model of a parallel machine.

00:00:07.530 --> 00:00:09.450
And in this lesson, what we're going to start

00:00:09.450 --> 00:00:13.950
doing is talking about synchronization algorithms that goes

00:00:13.950 --> 00:00:16.290
into the guts of any parallel operating

00:00:16.290 --> 00:00:19.970
systems that is supporting multi-threaded applications. And as

00:00:19.970 --> 00:00:23.350
we discuss the synchronization algorithms watch out for

00:00:23.350 --> 00:00:26.200
attacker's quote that I mentioned in the previous

00:00:26.200 --> 00:00:30.350
lesson on sharing, in shared memory multiprocessors

00:00:30.350 --> 00:00:32.159
that is going to be very, very key

00:00:32.159 --> 00:00:34.010
in terms of understanding the scalability of

00:00:34.010 --> 00:00:39.400
the synchronization algorithms. Synchronization primitives are a

00:00:39.400 --> 00:00:42.310
key for parallel programming. In your first

00:00:42.310 --> 00:00:45.590
project, you implemented a threads library, which

00:00:45.590 --> 00:00:48.970
provides the mutual exclusion lock. Let's talk

00:00:48.970 --> 00:00:51.816
about locks. What exactly is a lock?

00:00:51.816 --> 00:00:55.600
Well, you know, in the metaphor that you

00:00:55.600 --> 00:00:58.671
know about in real life. Lock is something that

00:00:58.671 --> 00:01:01.263
protects something that is precious. And in the

00:01:01.263 --> 00:01:05.033
context of parallel programming, if you have multiple threads

00:01:05.033 --> 00:01:08.023
executing and they share some data structure, it

00:01:08.023 --> 00:01:10.948
is important that the threads don't mess up each

00:01:10.948 --> 00:01:14.439
other's work. And a lock is something that allows

00:01:14.439 --> 00:01:16.904
a thread to make sure that when it is

00:01:16.904 --> 00:01:20.644
accessing some particular piece of shared data It is

00:01:20.644 --> 00:01:24.469
not inter being, being interfered with by some other

00:01:24.469 --> 00:01:27.560
thread. That's the purpose of a lock. So the

00:01:27.560 --> 00:01:30.540
idea would be that, a thread would acquire a

00:01:30.540 --> 00:01:33.220
lock, and once it acquires a lock, it knows

00:01:33.220 --> 00:01:37.180
that It can access this data that it shares

00:01:37.180 --> 00:01:39.490
with potentially other threads. I'm showing only two threads

00:01:39.490 --> 00:01:41.970
here, but potentially in a multi-threaded program you can

00:01:41.970 --> 00:01:44.488
have a lot more threads that are sharing a data structure.

00:01:44.488 --> 00:01:47.650
And once T1 knows that it has access to this data

00:01:47.650 --> 00:01:51.410
structure, then it can do whatever it wants with it. And

00:01:51.410 --> 00:01:54.070
then once it is done with whatever it wants to do

00:01:54.070 --> 00:01:57.030
with this data it can release the lock. So that's sort

00:01:57.030 --> 00:02:00.680
of the idea behind a lock. And locks come in two

00:02:00.680 --> 00:02:03.980
flavors, one is what we'll call an exclusive lock, or a

00:02:03.980 --> 00:02:07.200
mutual exclusion lock. And this is exactly the one that you

00:02:07.200 --> 00:02:11.008
implemented in your first project. And the idea

00:02:11.008 --> 00:02:14.450
is, as the name suggests, a mutually exclusive lock

00:02:14.450 --> 00:02:20.335
means that it can be used by a thread, one thread at a time. That's the idea.

00:02:20.335 --> 00:02:24.500
And here's a silly example of two children

00:02:24.500 --> 00:02:28.040
playing, and you know, they have to take turns

00:02:28.040 --> 00:02:30.740
in order to hit this ball and obviously,

00:02:30.740 --> 00:02:32.240
you don't want both of them hitting the ball

00:02:32.240 --> 00:02:36.910
at the same time. Not good for the game and not good for the safety of the

00:02:36.910 --> 00:02:39.540
children either. That same, same thing that applies

00:02:39.540 --> 00:02:43.760
to the mutual exclusion lock that we use in

00:02:43.760 --> 00:02:47.810
parallel programming. The idea is that a thread

00:02:47.810 --> 00:02:51.970
that wants to modify data It has to make

00:02:51.970 --> 00:02:54.570
sure that when it is modifying the data, nobody

00:02:54.570 --> 00:02:57.940
else is going to be accessing that particular data structure.

00:02:57.940 --> 00:02:59.790
And therefore it is going to get a mutual exclusion

00:02:59.790 --> 00:03:03.900
lock, it knows that nobody else is going to be messing

00:03:03.900 --> 00:03:06.250
with it. Then it can modify the data and then

00:03:06.250 --> 00:03:08.850
release the lock. And similarly if another thread wants to

00:03:08.850 --> 00:03:12.690
read that data and wants the assurance that nobody is

00:03:12.690 --> 00:03:15.410
going to be modifying this data while it is reading it,

00:03:15.410 --> 00:03:18.980
it can get a, an exclusive lock, access the data,

00:03:18.980 --> 00:03:22.942
read it and then release it. That's the idea behind mutually

00:03:22.942 --> 00:03:26.460
exclusive lock. You can also have a shared lock.

00:03:26.460 --> 00:03:29.430
Now, what that means is that this lock is something

00:03:29.430 --> 00:03:32.860
that allows multiple threats to access the data at the

00:03:32.860 --> 00:03:36.810
same time. Well, under what conditions would that me meaningful?

00:03:36.810 --> 00:03:40.720
Well, here is a, an analogy again. If there

00:03:40.720 --> 00:03:43.280
is a newspaper, and multiple people want to read the newspaper

00:03:43.280 --> 00:03:45.620
at the same time, perfectly fine to do that, right?

00:03:45.620 --> 00:03:48.392
That's the same sort of thing that happens often in

00:03:48.392 --> 00:03:51.810
parallel programming. That you have a database, and, and there

00:03:51.810 --> 00:03:54.240
are records in the database that multiple threads want to

00:03:54.240 --> 00:03:57.190
inspect. But they want to make sure that while they're inspecting

00:03:57.190 --> 00:04:00.490
it the, the data itself is not going to be changed so

00:04:00.490 --> 00:04:03.780
a shared lock is something that allows multiple readers to

00:04:03.780 --> 00:04:07.372
access some data with the assurance that nobody else is

00:04:07.372 --> 00:04:10.440
going to be modifying the data. So these are two different

00:04:10.440 --> 00:04:14.030
types of locks that you might have that might be useful

00:04:14.030 --> 00:04:16.680
in developing multi-threaded shared memory programs.

