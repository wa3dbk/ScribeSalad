WEBVTT
Kind: captions
Language: en

00:00:00.450 --> 00:00:05.970
Historically probably the first architectural style that became pervasive

00:00:05.970 --> 00:00:10.330
was called the Master Control. That issued right at top level routine that was

00:00:10.330 --> 00:00:15.420
responsible for organizing the use of the lower level routines.

00:00:15.420 --> 00:00:19.880
Some of the other ones listed on this particular list listed here.

00:00:19.880 --> 00:00:26.630
Are more recent message bus is an analogy with the bus, the hardware bus

00:00:26.630 --> 00:00:32.540
that organizes computations on a chip message bus often means asynchronous

00:00:32.540 --> 00:00:37.940
message passing over some common data channel. With your smartphone or

00:00:37.940 --> 00:00:43.324
other mobile devices there are a set of constraints that you have to deal with.

00:00:43.324 --> 00:00:47.140
That you wouldn't have to deal with in other kinds of applications. So

00:00:48.260 --> 00:00:52.648
architectural style in support of mobile code. Where there might be

00:00:52.648 --> 00:00:57.310
remote remote evaluation and you have agents of various places on a network

00:00:58.890 --> 00:01:02.788
is an example of mobile code architecture and style.

00:01:02.788 --> 00:01:08.414
The term object-oriented architectural style is a little bit different, than,

00:01:08.414 --> 00:01:12.240
object-oriented programming or object-oriented programming language. But

00:01:12.240 --> 00:01:17.550
with the object-oriented architectural style, we still have objects, but

00:01:17.550 --> 00:01:20.240
each of those objects have an independent existence that is

00:01:20.240 --> 00:01:22.950
they're running all the time, they have their own thread of control, and

00:01:22.950 --> 00:01:27.650
they're sending message to each, messages to each other. Assynchronous messages.

00:01:27.650 --> 00:01:31.860
This will allows them to cooperatively address a,

00:01:31.860 --> 00:01:35.970
address the problem being solved. Peer to peer network, you may have heard of.

00:01:35.970 --> 00:01:39.720
Here there are equal parties sharing responsibility for

00:01:39.720 --> 00:01:45.190
providing whatever services. Plug in architecture. If you are familiar with some

00:01:45.190 --> 00:01:49.770
interactive development environments like Eclipse, you know that there's a whole

00:01:49.770 --> 00:01:55.430
registry of available additional functionality that you can plug into Eclipse.

00:01:55.430 --> 00:02:00.960
And the mechanism for doing that is a very powerful way of adding extensibility

00:02:00.960 --> 00:02:05.920
to systems. Pipe and filter you've seen before with a quick a quick exercise.

00:02:05.920 --> 00:02:09.740
One you haven't seen probably, is process control. Think here,

00:02:09.740 --> 00:02:13.690
nuclear reactor. Think here, your speed control on your car.

00:02:13.690 --> 00:02:18.580
The situation is you have some ongoing hardware process and

00:02:18.580 --> 00:02:24.340
you'd like a corresponding software. Application to control that process.

00:02:24.340 --> 00:02:28.090
If the process is going too fast, you want to slow it down. If it's going too

00:02:28.090 --> 00:02:31.970
slow, you want to speed it up. This is called process control, and its key

00:02:31.970 --> 00:02:35.890
element is some kind of feedback loop. From the artificial intelligence world,

00:02:35.890 --> 00:02:40.830
there's production systems. These are essentially a collection of rules, and

00:02:40.830 --> 00:02:44.490
the conditions under which the rules fire. It enables the modeling of

00:02:44.490 --> 00:02:49.990
systems where we don't have a clear idea of what the control flow needed to

00:02:49.990 --> 00:02:54.380
implement the system. A very popular one these days is, is Rest.

00:02:54.380 --> 00:02:58.060
Rest stands for representational state transfer and

00:02:58.060 --> 00:03:01.970
you could think here it's those internet applications that are using HTTP.

00:03:03.160 --> 00:03:08.620
that, often have a client server type relationship, and that are stateless,

00:03:08.620 --> 00:03:15.350
that is each of the, user requests are handled independently,

00:03:15.350 --> 00:03:20.430
and some potentially some caching going on to improve performance.

00:03:20.430 --> 00:03:25.550
Service oriented architecture or SOA, is where we have carved up

00:03:25.550 --> 00:03:29.360
the functionality of the system into separate services. That is,

00:03:29.360 --> 00:03:34.410
from the users point of view, a service is a unit, a self contained unit of, of,

00:03:34.410 --> 00:03:39.960
of functionality and that means that we have to imagine the architecture

00:03:39.960 --> 00:03:44.690
of the system as being able to support a set of, a set of services.

00:03:44.690 --> 00:03:49.902
These are typically done in support of enterprise type applications, and

00:03:49.902 --> 00:03:56.048
often with internet connectivity between the user requests through some browser,

00:03:56.048 --> 00:04:00.610
and the ultimate service being provided by some server. Shared nothing is

00:04:00.610 --> 00:04:05.520
a term for a distributed database with no sharing across across the nodes.

00:04:05.520 --> 00:04:09.860
I don't have, personally have, a lot of experience with that one.

00:04:09.860 --> 00:04:13.150
Stay transition systems, on the other hand, are very common,

00:04:13.150 --> 00:04:17.635
particularly if yo have a situation where the system is driven by events,

00:04:17.635 --> 00:04:21.910
assynchronise events, and has to react to those events. A typical example is,

00:04:21.910 --> 00:04:25.110
if you've got a GUI and the user is providing the events. But

00:04:25.110 --> 00:04:28.380
it could also be some kind of real time system where the events are coming from

00:04:28.380 --> 00:04:34.080
the outside world. Shared memory, we saw from the, from the quick exercise and

00:04:34.080 --> 00:04:39.060
finally we have table-driven interpreter. For certain kinds of applications

00:04:39.060 --> 00:04:44.970
where the requests take the form of simple expressions in some kind of

00:04:44.970 --> 00:04:50.650
language we can deal with those requests by having a, an interpreter.

00:04:50.650 --> 00:04:55.360
The interpreter is essentially taking the request parsing it, and then invoking

00:04:55.360 --> 00:04:59.540
the, whatever procedure is required to deal with that sp, specific request.

