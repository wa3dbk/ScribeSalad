WEBVTT
Kind: captions
Language: en

00:00:00.240 --> 00:00:04.865
So, just like loop on rolling, which had similar benefits, function call

00:00:04.865 --> 00:00:10.575
inlining has a similar downside, and that downside is the code bloat.

00:00:10.575 --> 00:00:14.030
Suppose we have the original program, and it calls a function, and

00:00:14.030 --> 00:00:18.050
then it continues and calls the same function from another place and

00:00:18.050 --> 00:00:21.160
so on. Let's say that the function is ten instructions and

00:00:21.160 --> 00:00:24.900
then a return. So, now when we do our inlining, what we will do is,

00:00:24.900 --> 00:00:30.740
we will effectively put the ten instructions here and replace the call,

00:00:30.740 --> 00:00:35.170
and also take the same instructions, put them here, and replace the call. So,

00:00:35.170 --> 00:00:40.760
what used to be ten instructions, plus one for the return, plus two for

00:00:40.760 --> 00:00:45.673
calling, altogether 13 instructions, now becomes ten instructions here and

00:00:45.673 --> 00:00:51.180
ten instructions here, and although we eliminated the overhead,

00:00:51.180 --> 00:00:55.240
so there are no longer function calls and returns, and possibly some small

00:00:55.240 --> 00:01:00.260
amount of argument copying and so on. Still we have replicated the body of

00:01:00.260 --> 00:01:04.629
the function as many times as there are places in the code that call it.

00:01:04.629 --> 00:01:10.080
Some functions are called from hundreds of places, which means that the body

00:01:10.080 --> 00:01:15.020
of the function will now be replicated many, many times. This means that we

00:01:15.020 --> 00:01:19.460
really need to be judicious about, when do we do function called inlining.

00:01:19.460 --> 00:01:23.760
We cannot inline all of the functions that we want. We want to

00:01:23.760 --> 00:01:28.760
inline functions that are small, because the fewer instructions we have here,

00:01:29.960 --> 00:01:35.820
the more we are likely to offset the additional instructions we put in here,

00:01:35.820 --> 00:01:41.420
by the removal of some of the overheads. But as the function goes big,

00:01:41.420 --> 00:01:46.570
the replication results in a lot more code than the original calling and

00:01:46.570 --> 00:01:47.460
returning code did

