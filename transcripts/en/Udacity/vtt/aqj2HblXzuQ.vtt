WEBVTT
Kind: captions
Language: en

00:00:01.090 --> 00:00:03.858
This gives a visualization of
what is happening in learning

00:00:03.858 --> 00:00:05.665
by recording cases.

00:00:05.665 --> 00:00:10.480
There's a new problem a shown by the
color here, and memory contains a large

00:00:10.480 --> 00:00:14.330
number of cases, again represented
by the different colors here.

00:00:14.330 --> 00:00:18.635
So we retrieve the case b that is
most similar to the new problem a.

00:00:18.635 --> 00:00:21.133
In this particular case,
we're deciding by color.

00:00:21.133 --> 00:00:25.292
And whatever was the solution to b,
we apply to the situation a.

00:00:25.292 --> 00:00:28.473
While this visualization is useful,
it's still very abstract.

00:00:28.473 --> 00:00:32.189
Let's think in terms of some practical,
everyday examples.

00:00:32.189 --> 00:00:34.500
So you get up in the morning and
you want to go for a run.

00:00:34.500 --> 00:00:37.150
You put on your sneakers,
you have to tie your shoelaces.

00:00:37.150 --> 00:00:39.470
Well, how do you tie your shoelaces?

00:00:39.470 --> 00:00:40.080
That's a new problem.

00:00:41.120 --> 00:00:44.880
But of course, you have tied
shoelaces many, many times earlier.

00:00:44.880 --> 00:00:49.510
So you have a memory of tying
shoelaces to different kind of shoes.

00:00:49.510 --> 00:00:52.090
That's all's to it is
cases in your memory.

00:00:52.090 --> 00:00:55.408
So as you start tying the shoelaces for
the shoe today,

00:00:55.408 --> 00:00:59.100
you simply retrieve the closest
matching case and apply it.

00:01:00.220 --> 00:01:03.470
None of us really thinks very hard
in the morning about how exactly to

00:01:03.470 --> 00:01:04.120
tie shoelaces.

00:01:04.120 --> 00:01:06.800
If you were to do it,
it would take us a very long time.

00:01:06.800 --> 00:01:08.490
So in learning by recording cases,

00:01:08.490 --> 00:01:11.290
memory guardedly supplies
us with the answer.

00:01:11.290 --> 00:01:12.540
We don't have to think about it.

00:01:13.580 --> 00:01:16.805
&gt;&gt; So another example of this that
comes to mind is in programming.

00:01:16.805 --> 00:01:19.890
Oftentimes in programming, we deal
with the same type of problem over and

00:01:19.890 --> 00:01:21.240
over again.

00:01:21.240 --> 00:01:23.360
So I might imagine I'm
starting out a new program and

00:01:23.360 --> 00:01:24.958
I'm writing a program in Java.

00:01:24.958 --> 00:01:27.650
So I'm given a new problem of
creating a new program in Java.

00:01:28.660 --> 00:01:31.098
All I'm going to do is look
back in my memory of cases and

00:01:31.098 --> 00:01:33.657
retrieve another case of
starting a new program in Java.

00:01:33.657 --> 00:01:37.825
And I'm going to apply the solution
to that program directly to this one.

00:01:37.825 --> 00:01:41.160
In this case, it's going to be something
like, when I'm starting a new program

00:01:41.160 --> 00:01:43.725
in Java, last time,
I started with public static void main.

00:01:43.725 --> 00:01:46.230
I'm going to apply that solution
directly to my new problem,

00:01:46.230 --> 00:01:46.813
and it works.

00:01:46.813 --> 00:01:50.511
The solution can just be transferred
directly to the new problem without any

00:01:50.511 --> 00:01:51.685
kind of modification.

00:01:51.685 --> 00:01:54.595
Then later in developing that same
program, I might hit, for example,

00:01:54.595 --> 00:01:56.180
a null pointer error.

00:01:56.180 --> 00:01:58.730
I'm going to use that null pointer
error as a new problem and

00:01:58.730 --> 00:02:00.680
use it as a probe into my memory.

00:02:00.680 --> 00:02:03.420
I'm then going to retrieve a case of
when I encountered a null pointer error

00:02:03.420 --> 00:02:06.380
in the most similar program I've worked
on, and then that's going to give me

00:02:06.380 --> 00:02:09.979
a solution that I potentially can
apply directly to my current problem.

00:02:09.979 --> 00:02:13.070
So for example, the solution to the last
time I encountered that same error

00:02:13.070 --> 00:02:15.980
might be to run the program in debug
mode and allow it to tell me exactly

00:02:15.980 --> 00:02:19.090
what variable is null at
the time of execution.

00:02:19.090 --> 00:02:20.690
&gt;&gt; That's a good example, David.

00:02:20.690 --> 00:02:23.440
And we could even try to generalize
it to medical diagnosis.

00:02:23.440 --> 00:02:26.880
Imagine that you went to a medical
doctor with a set of signs and symptoms.

00:02:26.880 --> 00:02:29.030
So the doctor is faced
with a new problem.

00:02:29.030 --> 00:02:31.870
What is a diagnosis for
your signs and symptoms?

00:02:31.870 --> 00:02:36.130
The doctor may even have a number
of cases recorded in her memory.

00:02:36.130 --> 00:02:39.494
These are the cases she has
encountered during her experience.

00:02:39.494 --> 00:02:42.015
So the doctor must select
the most similar case,

00:02:42.015 --> 00:02:45.583
the most closely resembling case,
which in this case might be b, and

00:02:45.583 --> 00:02:49.290
say that I will apply to a exactly
the same diagnosis that I applied to b.

00:02:50.320 --> 00:02:54.183
So a case then is an encapsulation
of a past experience.

00:02:54.183 --> 00:02:57.970
And learning by recording cases
is a very powerful method

00:02:57.970 --> 00:03:00.920
that works in a very large number
of situations ranging from

00:03:00.920 --> 00:03:03.150
tying your shoelaces
to medical diagnosis.

