WEBVTT
Kind: captions
Language: en

00:00:00.170 --> 00:00:02.330
Alright, Michael, I got a quiz for you, okay?

00:00:02.330 --> 00:00:03.160
&gt;&gt; Sure.

00:00:03.160 --> 00:00:07.689
&gt;&gt; So, in the last example we had noise free data.

00:00:07.689 --> 00:00:09.840
So I want to think a little bit about what happens if we

00:00:09.840 --> 00:00:11.940
have some noisy data. And so I'm going to come up with

00:00:11.940 --> 00:00:16.360
a really weird, noisy model. But hopefully it illustrates the point. Okay.

00:00:16.360 --> 00:00:16.912
&gt;&gt; Sure.

00:00:16.912 --> 00:00:19.580
&gt;&gt; Okay so i got a bunch of training data, its x of i d

00:00:19.580 --> 00:00:25.310
of i and here's how the true underline process sort of works. So give us some

00:00:25.310 --> 00:00:28.330
particular x of i, you get a label which is

00:00:28.330 --> 00:00:31.950
d of i which is equal to k times x of

00:00:31.950 --> 00:00:34.000
i where k is some number So one of the

00:00:34.000 --> 00:00:38.220
counting numbers, one, two, three, four, five, six, seven, eight, and

00:00:38.220 --> 00:00:41.070
so on and so forth. And the probability that you

00:00:41.070 --> 00:00:45.000
actually get anyone of those multiples of x of i is

00:00:45.000 --> 00:00:47.850
equal to one over two to the k. Now why did

00:00:47.850 --> 00:00:50.360
I choose one over two to the k? Because it turns

00:00:50.360 --> 00:00:54.110
out that the sum of all those two to the k's from one

00:00:54.110 --> 00:00:55.550
through infinity happens to equal to

00:00:55.550 --> 00:00:57.650
one. So it's a true probability distribution.

00:00:57.650 --> 00:00:58.410
&gt;&gt; Hmm, okay.

00:00:58.410 --> 00:01:00.510
&gt;&gt; So it's just a neat little geometric

00:01:00.510 --> 00:01:03.630
distribution. So, you under understand the setup so far?

00:01:03.630 --> 00:01:07.300
&gt;&gt; I think so, so before hypothesis were producing

00:01:07.300 --> 00:01:09.790
answers then we looked for them to be exactly

00:01:09.790 --> 00:01:12.240
in the data. Now we're saying that the hypothesis

00:01:12.240 --> 00:01:15.590
produces an answer, and it gets kind of smooshed around

00:01:15.590 --> 00:01:18.300
a little bit before it reappears in the table, thats the noisy part.

00:01:18.300 --> 00:01:21.660
&gt;&gt; Right, so you, you're not going to be in a case now, that if

00:01:21.660 --> 00:01:27.620
the hypothesis disagrees with the label it sees. That in fact that means no it

00:01:27.620 --> 00:01:29.920
can't possibly be the right hypothesis because

00:01:29.920 --> 00:01:33.330
there's some stochastic process going on that might

00:01:33.330 --> 00:01:36.110
corrupt your output label, if you want to think

00:01:36.110 --> 00:01:38.350
of it as corruption, since it's noisy. Okay?

00:01:38.350 --> 00:01:39.050
&gt;&gt; Okay, yeah sure.

00:01:39.050 --> 00:01:39.330
&gt;&gt; Alright?

00:01:39.330 --> 00:01:40.650
&gt;&gt; Okay, so here's

00:01:40.650 --> 00:01:44.180
a set of data that you got. Here's a bunch of x's that, that make

00:01:44.180 --> 00:01:46.540
up our training data one, three, 11, 12,

00:01:46.540 --> 00:01:49.460
and 20. For some reason they're in ascending

00:01:49.460 --> 00:01:55.220
order. And the labels that go along with them are five, six, 11, 36, and 100. So

00:01:55.220 --> 00:02:01.580
you'll notice that they're all multiples of some sort of the input x. Okay?

00:02:01.580 --> 00:02:02.800
&gt;&gt; Alright.

00:02:02.800 --> 00:02:04.690
&gt;&gt; Now I have a candidate hypothesis.

00:02:05.704 --> 00:02:08.758
H of x which just returns x. That's kind of neat.

00:02:08.758 --> 00:02:11.750
So it's the identity function. So, what I want you to do

00:02:11.750 --> 00:02:16.360
is to compute the probability of seeing this particular data set in

00:02:16.360 --> 00:02:19.750
a world where that hypothesis, the identity function, is in fact true.

00:02:19.750 --> 00:02:22.790
&gt;&gt; The identity function plus this noise process.

00:02:22.790 --> 00:02:24.220
&gt;&gt; Yes.

00:02:24.220 --> 00:02:27.410
&gt;&gt; And one other question quickly this, this noise

00:02:27.410 --> 00:02:31.300
process is supplied independently to each of these inputs,

00:02:31.300 --> 00:02:32.270
outputs, pairs?

00:02:32.270 --> 00:02:32.960
&gt;&gt; Yes, absolutely.

00:02:32.960 --> 00:02:34.810
&gt;&gt; Okay, then, yeah, I think I can do that. Uh-huh.

00:02:34.810 --> 00:02:36.740
&gt;&gt; Okay, go.

