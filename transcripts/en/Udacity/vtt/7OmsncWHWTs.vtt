WEBVTT
Kind: captions
Language: en

00:00:01.359 --> 00:00:04.500
I mentioned earlier it's a multiple writer protocol,

00:00:04.500 --> 00:00:07.240
which means that this action that's going on

00:00:07.240 --> 00:00:10.030
can be happening simultaneously for the same page

00:00:10.030 --> 00:00:13.840
X on different nodes of the cluster. That's

00:00:13.840 --> 00:00:15.780
perfectly fine so far as the protocol is

00:00:15.780 --> 00:00:19.600
concerned, because the assumption is that the user

00:00:19.600 --> 00:00:22.940
has an association between locks. And the data

00:00:22.940 --> 00:00:26.440
structures governed by the lock. So, even if

00:00:26.440 --> 00:00:29.460
the same page is being modified, hopefully

00:00:29.460 --> 00:00:31.560
different portions of the same page has

00:00:31.560 --> 00:00:34.630
been modified because concurrently if a page

00:00:34.630 --> 00:00:38.680
is being modified, that means that different locks

00:00:38.680 --> 00:00:42.530
are protecting the portions of the page

00:00:42.530 --> 00:00:45.300
that are being modified by the different processes.

00:00:45.300 --> 00:00:51.186
Now if writes are happening to the same portion of a page under different locks,

00:00:51.186 --> 00:00:54.309
that's a user's problem. That's a data race. That's

00:00:54.309 --> 00:00:57.490
not the problem of the DSM software. It's an

00:00:57.490 --> 00:01:00.870
application problem because it represents a data race that

00:01:00.870 --> 00:01:03.100
should not have been there if the application is

00:01:03.100 --> 00:01:07.447
constructed correctly. But if the application is constructed correctly

00:01:07.447 --> 00:01:10.261
and the multiple data structures are hosted in the

00:01:10.261 --> 00:01:13.075
same page and the data structures are all governed

00:01:13.075 --> 00:01:16.665
by different locks. DSM software has a way of ensuring

00:01:16.665 --> 00:01:19.743
that changes made to a critical section under

00:01:19.743 --> 00:01:23.226
a particular lock is propagated from one processor

00:01:23.226 --> 00:01:26.466
to the next processor where the first processor

00:01:26.466 --> 00:01:29.220
is the current owner of the lock, and the

00:01:29.220 --> 00:01:31.731
next processor is the next user of the

00:01:31.731 --> 00:01:35.785
lock. So this implementation that I've detailed here

00:01:35.785 --> 00:01:38.190
is an example of the cooperation between the

00:01:38.190 --> 00:01:41.700
distributed shared memory software and the operating system to

00:01:41.700 --> 00:01:44.332
make it all happen. And in particular,

00:01:44.332 --> 00:01:48.871
TreadMarks implemented this LRC multiple writer coherence

00:01:48.871 --> 00:01:52.120
protocol on a Unix system. And in

00:01:52.120 --> 00:01:55.400
the Unix system, the operating system generates

00:01:55.400 --> 00:02:00.510
an exception called SIGSEGV in the operating system layer when a shared page is

00:02:00.510 --> 00:02:03.720
accessed by a thread. This exception is

00:02:03.720 --> 00:02:06.620
caught by the thread block's runtime handler.

00:02:06.620 --> 00:02:08.840
And at that point the DSM software get

00:02:08.840 --> 00:02:12.650
into gear, contacts the owner of the page, checks

00:02:12.650 --> 00:02:19.730
the status of the page. And if the page is invalid then it gets the page and

00:02:19.730 --> 00:02:26.300
the difts for that page and once it brings in the contents of the page and the

00:02:26.300 --> 00:02:29.170
difts it creates a current version of the page.

00:02:29.170 --> 00:02:31.760
And if the process that is trying to access

00:02:31.760 --> 00:02:34.870
the page is making a read access, then there is

00:02:34.870 --> 00:02:38.990
no problem. But if the process that wants to use

00:02:38.990 --> 00:02:41.510
that page wants to write to it, at that point

00:02:41.510 --> 00:02:43.710
it creates a twin and does all the things that

00:02:43.710 --> 00:02:46.220
I just mentioned. So one thing that you will notice

00:02:46.220 --> 00:02:51.030
is that there is space overhead for the creation of

00:02:51.030 --> 00:02:53.740
the twin and the point of the write. You have

00:02:53.740 --> 00:02:57.280
to create a twin. And then at the point of release,

00:02:57.280 --> 00:03:01.170
you have to create, of course you can get rid of the twin, but you're creating

00:03:01.170 --> 00:03:04.580
a dift data structure. So, the twin and

00:03:04.580 --> 00:03:08.200
the difts are all data structures. Of the implementation

00:03:08.200 --> 00:03:11.090
of distriuted shared memory. And as time goes

00:03:11.090 --> 00:03:14.470
by, there could be a lot of these difts

00:03:14.470 --> 00:03:18.040
that are lying around in different nodes. Imagine

00:03:18.040 --> 00:03:22.630
that a page was touched by ten different processors.

00:03:22.630 --> 00:03:24.280
In that case, there are going to be difts lying

00:03:24.280 --> 00:03:27.850
around in ten different processors and if eleven processor wants

00:03:27.850 --> 00:03:30.850
to access the same page the DSM software has

00:03:30.850 --> 00:03:34.130
to go and bring the dift's from this ten prior

00:03:34.130 --> 00:03:37.160
users of the page. Get the original page from

00:03:37.160 --> 00:03:41.380
the owner. Apply the difts to create the new page.

00:03:41.380 --> 00:03:44.920
A lot of latency in, is involved before the

00:03:44.920 --> 00:03:47.710
guy who needs the page now can start using it.

00:03:47.710 --> 00:03:51.930
And also there is a lot of space over here in the fact that all these discs are

00:03:51.930 --> 00:03:54.880
lying around. So one of the things that happens

00:03:54.880 --> 00:03:58.760
in, in the DSM software Is garbage collection. And that

00:03:58.760 --> 00:04:02.540
is, you keep a watermark of what is the

00:04:02.540 --> 00:04:04.560
amount of difts that have been created in the

00:04:04.560 --> 00:04:08.440
entire system. If it exceeds a threshold then you

00:04:08.440 --> 00:04:12.820
start applying these dift's to the original copy of the

00:04:12.820 --> 00:04:16.260
page, at the owner, so that you can then get

00:04:16.260 --> 00:04:19.440
rid of the dift's completely. Why do you need that,

00:04:19.440 --> 00:04:21.880
well the difts that going to be lying it on till

00:04:21.880 --> 00:04:24.500
a long time till the next time the pages access

00:04:24.500 --> 00:04:27.000
by someone, you don't want that. So, what you're trying

00:04:27.000 --> 00:04:30.340
to do is, you're reducing the space overhead in the

00:04:30.340 --> 00:04:35.040
DSM implementation by periodically doing this garbage collection. And applying

00:04:35.040 --> 00:04:37.850
the difts to the original copy of the page so

00:04:37.850 --> 00:04:40.070
that he can get rid of it from the system. You don't

00:04:40.070 --> 00:04:43.510
want to do it too eagerly, but you don't want to wait

00:04:43.510 --> 00:04:47.100
too long also because if a page hasn't been accessed for a

00:04:47.100 --> 00:04:49.610
long time, difts are going to be lying around for a long

00:04:49.610 --> 00:04:53.090
time. So there will be a demon process in every node that

00:04:53.090 --> 00:04:57.210
every once in a while wakes up and sees how much difts

00:04:57.210 --> 00:05:00.640
have been created in my known. If it exceeds the threshold then

00:05:00.640 --> 00:05:03.630
it says okay time to get to work. Let me go and

00:05:03.630 --> 00:05:05.480
apply this difts to the original copy of the

00:05:05.480 --> 00:05:07.260
page so that I can get rid of the difts.

