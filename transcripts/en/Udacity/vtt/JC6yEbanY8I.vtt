WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.000
Let's go back to now using this idea to count the number of steps in Russian as a function of a.

00:00:05.000 --> 00:00:09.000
The thing that you should be noticing here is we now know the number of times

00:00:09.000 --> 00:00:11.000
this loop is going to be executed.

00:00:11.000 --> 00:00:14.000
This is the floor log base 2 of a plus 1.

00:00:14.000 --> 00:00:17.000
For each of those times, how many statements get executed?

00:00:17.000 --> 00:00:21.000
Well, there are these two statements that get executed unconditionally.

00:00:21.000 --> 00:00:26.000
Then there is plus this conditional statement--this evaluation here get executed.

00:00:26.000 --> 00:00:30.000
These three things get executed, and this additional for statement only gets executed

00:00:30.000 --> 00:00:33.000
when x is odd.

00:00:33.000 --> 00:00:37.000
As we talked about before, that happens however many times as there are 1 bits

00:00:37.000 --> 00:00:40.000
in the binary representation of a.

00:00:40.000 --> 00:00:42.000
That actually is enough to get us our answers.

00:00:42.000 --> 00:00:44.000
Let me write it down.

00:00:44.000 --> 00:00:46.000
How many steps is it going to take to execute russian(a, b)?

00:00:46.000 --> 00:00:51.000
Well, as I said, the floor log base 2 of a rounded down plus 1

00:00:51.000 --> 00:00:53.000
is the number of times the while loop is executed.

00:00:53.000 --> 00:00:56.000
There are three statements that are going to executed inside

00:00:56.000 --> 00:00:58.000
plus the additional three statements that are executed outside

00:00:58.000 --> 00:01:03.000
plus there is going to be one statement executed for each of the bits of a that it's on

00:01:03.000 --> 00:01:05.000
and particularly the summation. That's kind of a mess.

00:01:05.000 --> 00:01:10.000
We can make it slightly less of a mess if we notice that this is upper bounded by

00:01:10.000 --> 00:01:14.000
4 times the rounded down logarithm of a plus 7.

00:01:14.000 --> 00:01:18.000
The reason for that being that the most number of on bits you can have in a number

00:01:18.000 --> 00:01:24.000
is if all the bits are on and how many bits can you have in a number.

00:01:24.000 --> 00:01:27.000
Well, if you have a number like this--a binary number like that,

00:01:27.000 --> 00:01:30.000
each time you halve it, you're chopping off one of the bits.

00:01:30.000 --> 00:01:36.000
The rounded down log base 2 of the number plus 1 is actually a count of the maximum

00:01:36.000 --> 00:01:38.000
number of bits that you can have on.

00:01:38.000 --> 00:01:43.000
Now, one thing that I'd like to point out here is that this quantity is much,

00:01:43.000 --> 00:01:49.000
much, much, much, much less in general than some linear function in a

00:01:49.000 --> 00:01:51.000
like what we get for naive.

00:01:51.000 --> 00:01:56.000
Naive grows a lot faster--in fact, exponentially faster--literally exponentially faster

00:01:56.000 --> 00:01:59.000
than the bound on the running time is for Russian.

00:01:59.000 --> 09:59:59.000
Naive--very, very bad. Russian--actually quite good and happy.

