WEBVTT
Kind: captions
Language: en

00:00:00.170 --> 00:00:02.660
The second design alternative I'm going to talk about

00:00:02.660 --> 00:00:06.360
mitigates exactly the problem that I had mentioned earlier.

00:00:06.360 --> 00:00:10.140
And that is, you want parallelism for accessing the

00:00:10.140 --> 00:00:14.810
database because, this is probably one of the slowest link

00:00:14.810 --> 00:00:17.790
in the whole processing of request because pulling in

00:00:17.790 --> 00:00:20.010
data from the database is going to take a lot

00:00:20.010 --> 00:00:22.880
of time. Both in terms of I/O that has

00:00:22.880 --> 00:00:25.270
to be done through discs as well as the network

00:00:25.270 --> 00:00:28.240
communication to pull in the data into

00:00:28.240 --> 00:00:30.790
the container where the processing needs to happen.

00:00:30.790 --> 00:00:32.960
And for that purpose the structure that we

00:00:32.960 --> 00:00:37.450
have here is to push the business logic

00:00:37.450 --> 00:00:41.580
as part of this container in which the

00:00:41.580 --> 00:00:44.450
servelet and the presentation logic was there we

00:00:44.450 --> 00:00:47.030
add the business logic also and make it

00:00:47.030 --> 00:00:50.900
a three tier software structure here. Servelet presentation

00:00:50.900 --> 00:00:57.300
logic and business logic, and all of the data access is going to be done

00:00:57.300 --> 00:01:02.700
through what are called entity beans. As I mentioned earlier, entity beans have

00:01:02.700 --> 00:01:07.830
persistence characteristics, and in this particular example

00:01:07.830 --> 00:01:10.060
i can think of the entity bean

00:01:10.060 --> 00:01:13.660
as representing one row of the database.

00:01:13.660 --> 00:01:16.620
So the data access object are implemented

00:01:16.620 --> 00:01:20.060
using a whole bunch of entity beans and you

00:01:20.060 --> 00:01:23.140
can decide as the designer whether an entity bean

00:01:23.140 --> 00:01:26.460
is responsible for one row of the database or

00:01:26.460 --> 00:01:28.840
maybe for a set of rows of the database.

00:01:28.840 --> 00:01:31.500
But in any event what we've done is, we've

00:01:31.500 --> 00:01:34.510
taken the parallelism that is available in terms of

00:01:34.510 --> 00:01:38.490
data access to the database and encoded it through

00:01:38.490 --> 00:01:42.140
the entity bean so that they can be parallel access

00:01:42.140 --> 00:01:44.890
to the unit of granularity that we have

00:01:44.890 --> 00:01:47.910
in terms data base access. So the EJB container

00:01:47.910 --> 00:01:52.250
now contains these entity beans. So now if a

00:01:52.250 --> 00:01:56.220
servelet that is serving a particular client needs to

00:01:56.220 --> 00:01:58.790
access some portion of the database, it can

00:01:58.790 --> 00:02:02.100
form more parallel requests to these entity beans, to

00:02:02.100 --> 00:02:04.730
as many entity beans as it wants. And all

00:02:04.730 --> 00:02:07.340
of those entity beans can work in parallel on

00:02:07.340 --> 00:02:11.690
behalf of a single client. And pull in the data that is needed and serve it

00:02:11.690 --> 00:02:16.960
up to the business logic so that the business logic can then do its thing. So we

00:02:16.960 --> 00:02:20.050
are reducing the time for data access by

00:02:20.050 --> 00:02:24.910
having this parallel structure and exploiting the available concurrency

00:02:24.910 --> 00:02:27.130
that may be there in terms of I/O

00:02:27.130 --> 00:02:32.170
performance, and also even if there are parallel requests,

00:02:32.170 --> 00:02:35.300
those parallel requests may want access to the

00:02:35.300 --> 00:02:37.200
same portion of the database. If you think

00:02:37.200 --> 00:02:39.290
about the example I gave you of two

00:02:39.290 --> 00:02:43.090
difference individuals wanting to make airline reservation for

00:02:43.090 --> 00:02:45.830
exactly the same dates and the same set

00:02:45.830 --> 00:02:49.300
of constraints. Then there may be an opportunity

00:02:49.300 --> 00:02:52.170
for this entity bean to cluster the request

00:02:52.170 --> 00:02:57.280
coming from several different end clients and amortize the

00:02:57.280 --> 00:03:01.270
access to the database server. Across several

00:03:01.270 --> 00:03:04.190
different clients that are temporally happening at

00:03:04.190 --> 00:03:06.660
the same time. And i mentioned entity

00:03:06.660 --> 00:03:10.900
beams usually are dealing with persistent state,

00:03:10.900 --> 00:03:17.350
which means that the persistence has to be provided at some level to these

00:03:17.350 --> 00:03:22.890
entity beans. So that persistence has to be provided to the data accessed object

00:03:22.890 --> 00:03:25.210
at some level, which are using these entity

00:03:25.210 --> 00:03:27.930
beans. It could be done at the level of

00:03:27.930 --> 00:03:30.910
individual entity beans. Which is called the bean

00:03:30.910 --> 00:03:34.660
managed persistence. If the bean is managing the persistence

00:03:34.660 --> 00:03:37.720
needs of the data access object, then that

00:03:37.720 --> 00:03:40.910
is called bean managed persistence. Or it could be

00:03:40.910 --> 00:03:44.730
that the container is providing that facility, in

00:03:44.730 --> 00:03:48.330
which case the persistence needs of the data access

00:03:48.330 --> 00:03:51.760
object is provided by the container and,

00:03:51.760 --> 00:03:54.180
and that is called container managed persistence. So

00:03:54.180 --> 00:03:56.830
these are two different design choices we

00:03:56.830 --> 00:03:59.880
can make in this structure. The structure is

00:03:59.880 --> 00:04:06.000
the same for the design alternate of two. That is, we're using entity beings to

00:04:06.000 --> 00:04:09.870
implement data access objects, and we're deciding the

00:04:09.870 --> 00:04:13.500
granularity of the data access object, based on

00:04:13.500 --> 00:04:15.710
the level of concurrency that you want

00:04:15.710 --> 00:04:19.269
in constructing this application service. But within

00:04:19.269 --> 00:04:21.959
that choice there are two possibilities again

00:04:21.959 --> 00:04:25.220
in terms of how we provide persistence for

00:04:25.220 --> 00:04:28.760
the data access object, either by providing

00:04:28.760 --> 00:04:32.100
it in the entity bean itself, or using

00:04:32.100 --> 00:04:34.250
the container service to provide that. So

00:04:34.250 --> 00:04:38.850
this, once again, points to opportunities for reuse

00:04:38.850 --> 00:04:41.220
of facilities that may be available. The

00:04:41.220 --> 00:04:45.830
same container-managed persistence may be usable for

00:04:45.830 --> 00:04:48.710
different types of applications. One application may

00:04:48.710 --> 00:04:50.990
be an airline application, another application may

00:04:50.990 --> 00:04:56.950
be a portal for hotel booking. All of those different applications may be able

00:04:56.950 --> 00:05:01.220
to reuse container-managed persistence that's available in

00:05:01.220 --> 00:05:04.050
the structure. So the pros of this

00:05:04.050 --> 00:05:06.970
structure is first of all, the concurrency

00:05:06.970 --> 00:05:10.700
that you can actually exploit concurrency for

00:05:10.700 --> 00:05:17.125
data access for the same client in parallel or even across different clients by

00:05:17.125 --> 00:05:20.210
amortizing the data access. That may be

00:05:20.210 --> 00:05:23.970
needed concurrently for similar services that are

00:05:23.970 --> 00:05:27.120
overlapping in terms of data usage. That's

00:05:27.120 --> 00:05:29.140
the good news. There's one con to this

00:05:29.140 --> 00:05:32.030
approach, and that is, because we moved

00:05:32.030 --> 00:05:34.850
the business logic into the web container from

00:05:34.850 --> 00:05:38.720
the EJB container, it exposes the business logic

00:05:38.720 --> 00:05:41.100
to the outside network. We are not confined

00:05:41.100 --> 00:05:43.920
to the corporate network but the business logic

00:05:43.920 --> 00:05:47.520
is exposed outside the corporate network in this

00:05:47.520 --> 00:05:51.860
design alternative. So, all the data access code

00:05:51.860 --> 00:05:54.230
that you used to be in the session

00:05:54.230 --> 00:05:57.190
beam in the previous structure that I talked about.

00:05:57.190 --> 00:05:59.740
All the data access code is now moved into

00:05:59.740 --> 00:06:03.860
this entity beam. That's how we get the parallelism

00:06:03.860 --> 00:06:06.440
in the fact that there are multiple entity beams

00:06:06.440 --> 00:06:09.200
that are carrying the same data access code and

00:06:09.200 --> 00:06:11.590
they could be accessing different portions of the database

00:06:11.590 --> 00:06:15.930
concurrently resulting in exploitation of parallelism and reusing the

00:06:15.930 --> 00:06:19.300
latency for the business logic to get all the

00:06:19.300 --> 00:06:22.110
data it needs from the data base in order to do its work.

