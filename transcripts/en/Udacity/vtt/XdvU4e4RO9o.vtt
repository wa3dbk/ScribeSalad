WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:04.110
To understand the constraints or
potential weaknesses of hash functions,

00:00:04.110 --> 00:00:06.350
there are two concepts
we need to discuss.

00:00:06.350 --> 00:00:11.900
The first is the pigeonhole principle
and the second is the birthday paradox.

00:00:11.900 --> 00:00:14.800
First, let's take a look at
the pigeonhole principle.

00:00:14.800 --> 00:00:16.920
Imagine we have nine pigeonholes,

00:00:16.920 --> 00:00:21.120
if we have nine pigeons then one
pigeon can be placed in each hole.

00:00:21.120 --> 00:00:25.820
That is suppose we have n number
of pigeons and m number of holes.

00:00:25.820 --> 00:00:30.200
If n equaled m that means there's
exactly one pigeon per hole.

00:00:30.200 --> 00:00:35.330
Now if we add another pigeon then there
will be one hole with two pigeons.

00:00:35.330 --> 00:00:40.350
That is if n, the number of pigeons
is greater than m the number of holes

00:00:40.350 --> 00:00:44.870
then there's at least one hole that
must have more than one pigeon.

00:00:44.870 --> 00:00:48.290
Now let's apply the pigeon hole
principle to another problem.

00:00:48.290 --> 00:00:50.750
How many people do we
need to have in a room

00:00:50.750 --> 00:00:55.440
such that there's a good chance that two
of them will have the same birthday.

00:00:55.440 --> 00:01:01.080
There are 365 birthdays and we can think
of these birthdays as the pigeon holes.

00:01:01.080 --> 00:01:05.140
How do we calculate the probability
that two people in the room

00:01:05.140 --> 00:01:06.570
have the same birthday.

00:01:06.570 --> 00:01:09.200
Obviously, if you want
the probability to be 100%,

00:01:09.200 --> 00:01:14.720
we need 366 people and
that's the pigeonhole principle.

00:01:14.720 --> 00:01:20.970
Because we have 365 birthdays or
365 pigeonholes.

00:01:20.970 --> 00:01:23.820
So we need 366 pigeons, or

00:01:23.820 --> 00:01:28.750
people, in order to make sure that two
of them will have the same birthday.

00:01:28.750 --> 00:01:31.280
Now suppose, we only need a good chance,

00:01:31.280 --> 00:01:36.980
say only 50% chance, that two people in
the room would have the same birthday.

00:01:36.980 --> 00:01:40.350
How do we calculate how many
people do we need in a room?

00:01:40.350 --> 00:01:43.660
We can solve this problem
using the following procedure.

00:01:43.660 --> 00:01:46.720
We can model this problem
of having n people

00:01:46.720 --> 00:01:49.940
choosing from k days as their birthdays.

00:01:49.940 --> 00:01:52.919
Of course k is 365.

00:01:52.919 --> 00:01:56.918
If we allow everybody to
choose any of the k days then

00:01:56.918 --> 00:02:00.090
there are k to the n
that many scenarios.

00:02:00.090 --> 00:02:05.100
Because for each of the n people,
they can choose any of the k days.

00:02:05.100 --> 00:02:08.880
So there are k to the n,
that many possible scenarios.

00:02:08.880 --> 00:02:10.050
On the other hand,

00:02:10.050 --> 00:02:13.930
if we insist that no two people
should have the same birthday,

00:02:13.930 --> 00:02:19.820
then the number of scenarios is choosing
n out of k without replacement.

00:02:19.820 --> 00:02:26.418
And that is k(k-1) times k- 2, so
on and so forth, and (k- n +1).

00:02:26.418 --> 00:02:31.470
Because for the first person,
he can choose any of the k days.

00:02:31.470 --> 00:02:36.285
And once he makes his choice, then the
next person can only have k- 1 choices.

00:02:36.285 --> 00:02:41.225
Because we don't want the second person
to have the same birthday as the first

00:02:41.225 --> 00:02:41.834
person.

00:02:41.834 --> 00:02:45.223
And once the first two people
have chosen their birthdays,

00:02:45.223 --> 00:02:48.030
then a third person can
only have k-2 choices.

00:02:48.030 --> 00:02:49.260
And so and so forth.

00:02:49.260 --> 00:02:53.140
So this is the number of possible
scenarios when we insist that

00:02:53.140 --> 00:02:55.830
no two people should
have the same birthday.

00:02:55.830 --> 00:03:00.020
Then we can use this formula
to compute a probability where

00:03:00.020 --> 00:03:03.920
there's a scenario where two
people share the same birthday.

00:03:03.920 --> 00:03:09.580
And this can be
approximated to n(n-1)/2k.

00:03:09.580 --> 00:03:14.028
Therefore if you want this
probability to be 0.5 meaning that

00:03:14.028 --> 00:03:19.070
there's 50% chance that two people
would share the same birthday

00:03:19.070 --> 00:03:22.470
then n should be the square root of k.

00:03:22.470 --> 00:03:25.650
Again this is just an approximation.

00:03:25.650 --> 00:03:29.737
If k=365 then its square root of k=19.

00:03:29.737 --> 00:03:34.190
That means as an approximation
if we have 19 people in a room,

00:03:34.190 --> 00:03:39.010
there is a good chance that two
of them share the same birthday.

00:03:39.010 --> 00:03:43.410
I've tried this in my class every year
with the students in my classroom.

00:03:43.410 --> 00:03:46.540
And it always works out
as the math tells us.

00:03:46.540 --> 00:03:49.580
Once we understand
the pigeonhole principle and

00:03:49.580 --> 00:03:54.580
birthday paradox, we may realize that
some of the properties of hash function

00:03:54.580 --> 00:03:56.650
seem to contradict each other.

00:03:56.650 --> 00:04:02.070
In particular, a hash function can
take as input data of any size and

00:04:02.070 --> 00:04:05.070
the output is always a fixed size.

00:04:05.070 --> 00:04:07.700
Since the size of hash value is fixed,

00:04:07.700 --> 00:04:11.960
that means that there are fixed
number of possible hash values.

00:04:11.960 --> 00:04:14.940
On the other hand since
the input to hash functions

00:04:14.940 --> 00:04:17.360
can be of any size that would mean that

00:04:17.360 --> 00:04:22.280
there are many many more possible inputs
to the number of possible outputs.

00:04:22.280 --> 00:04:26.470
In other words, there are many
more pigeons than the pigeonholes.

00:04:26.470 --> 00:04:28.560
Then applying the pigeonhole principle,

00:04:28.560 --> 00:04:32.120
many inputs were mapped to
the same output hash value.

00:04:32.120 --> 00:04:37.600
In other words, many different input
messages will have the same hash value,

00:04:37.600 --> 00:04:41.630
but this violates the property
of collision resistance.

00:04:41.630 --> 00:04:46.760
However, if we take a closer look at
hash function properties, in particular,

00:04:46.760 --> 00:04:48.740
the collision system properties.

00:04:48.740 --> 00:04:52.790
They only say that it should
be compositionally in feasible

00:04:52.790 --> 00:04:56.140
to find two different messages
that have the same hash value.

00:04:56.140 --> 00:05:00.115
It did not say that it should
be mathematically impossible

00:05:00.115 --> 00:05:01.695
to find such collision.

00:05:01.695 --> 00:05:05.375
In other words,
although it is mathematically possible

00:05:05.375 --> 00:05:08.205
to find the collision,
the hash function property says that

00:05:08.205 --> 00:05:12.485
we want to make it invisible, or
impractical, to find such collision.

00:05:12.485 --> 00:05:14.245
So how do we accomplish this?

00:05:14.245 --> 00:05:18.295
Obviously, the larger the number
of possible output hash values,

00:05:18.295 --> 00:05:20.680
the harder it is to find the collision.

00:05:20.680 --> 00:05:25.810
In other words, the longer the length
of the output hash value, the better.

00:05:25.810 --> 00:05:30.060
In short, to avoid collision,
we should use longer hash values

