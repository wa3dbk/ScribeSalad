WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.160
Let's walk through this code--so, first we set n is equal to the length

00:00:03.160 --> 00:00:06.890
of the n by an adjacency matrix that we took as input

00:00:06.890 --> 00:00:11.060
and we set assignment to be n(none), so a list of n(none)

00:00:11.060 --> 00:00:16.290
and we initialize the cover to be the empty list since we haven't actually set a cover yet,

00:00:16.290 --> 00:00:20.750
and we set valid off as false so that we can start this wild loop going

00:00:20.750 --> 00:00:24.990
While valid is false, we first check to find the vertex with the most uncovered edges

00:00:24.990 --> 00:00:29.450
So, we start with the first vertex and set candidate index to zero

00:00:29.450 --> 00:00:33.890
and the number of uncovered neighbors that it has to zero.

00:00:33.890 --> 00:00:37.360
Now, for every vertex in the graph, we check if it has already been assigned.

00:00:37.360 --> 00:00:39.790
And if so, then already covers all adjacent edges.

00:00:39.790 --> 00:00:45.880
If not, then we first set the sum of uncovered edges to be zero

00:00:45.880 --> 00:00:50.200
and then again for every vertex in the graph, we check if there is an edge between the two vertices

00:00:50.200 --> 00:00:55.750
represented by I and J and if J has been assigned.

00:00:55.750 --> 00:00:58.990
If it hasn't been assigned, then we increment the sum of the uncovered edges

00:00:58.990 --> 00:01:02.370
since there is now an edge that is not covered by either I or J,

00:01:02.370 --> 00:01:07.270
and we loop through all of the other vertices to check if there is an edge between I and J.

00:01:07.270 --> 00:01:09.810
Now, if the sum of the uncovered edges that we just counted up

00:01:09.810 --> 00:01:13.320
is greater than the maximum uncovered neighbors

00:01:13.320 --> 00:01:18.660
then we have a new candidate index for which vertex we should next add to the cover

00:01:18.660 --> 00:01:23.050
and then we set the max uncovered neighbors to be sum uncovered, which we just calculated

00:01:23.050 --> 00:01:28.590
and then we keep looping through this for every vertex until we find the max uncovered

00:01:28.590 --> 00:01:32.050
So, we figured out which vertex we should next add to the cover.

00:01:32.050 --> 00:01:36.800
Now, if we didn't find any uncovered neighbors, if max uncovered neighbors is zero

00:01:36.800 --> 00:01:39.799
then we see that this is valid vertex cover.

00:01:39.799 --> 00:01:43.610
We set valid to true and that means we'll fall out of this wild loop and continue on,

00:01:43.610 --> 00:01:47.770
otherwise, we append this index to the current cover

00:01:47.770 --> 00:01:51.870
and we set the assignment of this vertex to be one

00:01:51.870 --> 00:01:58.700
and then we continue on finding the vertex with the next smallest number of uncovered adjacent edges.

00:01:58.700 --> 00:02:02.500
Once, we eventually fall through that is once we eventually hit valid equal true here

00:02:02.500 --> 00:02:07.630
and fall out of this wild loop, we go down here and calculate the size of the cover and return

00:02:07.630 --> 00:02:11.900
So, size equal zero and then for every vertex in the graph,

00:02:11.900 --> 00:02:14.590
we check if it is currently in the assignment.

00:02:14.590 --> 99:59:59.000
And if so, we increment size and then we return size uncover.

