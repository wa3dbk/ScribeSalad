WEBVTT
Kind: captions
Language: en

00:00:00.360 --> 00:00:04.000
So far we've learned to declare
optionals using question marks, and

00:00:04.000 --> 00:00:07.550
we focused on safe ways to unwrap
optionals using question marks and

00:00:07.550 --> 00:00:08.920
if let statements.

00:00:08.920 --> 00:00:10.790
Now it's time to get
a little reckless and

00:00:10.790 --> 00:00:13.000
start working with exclamation points.

00:00:13.000 --> 00:00:15.740
Unwrapping optionals with exclamation
points requires a lot more

00:00:15.740 --> 00:00:17.280
confidence in your code.

00:00:17.280 --> 00:00:22.309
If you try to unwrap a nil value
with an exclamation point, yikes.

00:00:23.530 --> 00:00:26.140
To unwrap an optional in
this carefree manner,

00:00:26.140 --> 00:00:28.600
place an exclamation
point after the variable.

00:00:28.600 --> 00:00:31.165
But if the value inside is nil,
it explodes.

00:00:31.165 --> 00:00:35.670
[LAUGH] Okay, nothing explodes,
but it does throw a fatal error.

00:00:35.670 --> 00:00:39.290
There is no safe way to unwrap
with an exclamation point.

00:00:39.290 --> 00:00:41.790
When you choose to unwrap
with an exclamation point,

00:00:41.790 --> 00:00:45.960
you're saying that you want the program
to crash if the value inside is nil.

00:00:45.960 --> 00:00:49.480
It communicates to your code readers
that you're confident there will not be

00:00:49.480 --> 00:00:51.480
a nil value in the optional.

00:00:51.480 --> 00:00:54.810
We can also declare optionals
with an exclamation point,

00:00:54.810 --> 00:00:57.050
much the way we did with question marks.

00:00:57.050 --> 00:00:59.000
But this optional is different.

00:00:59.000 --> 00:01:01.070
It's implicitly unwrapped.

00:01:01.070 --> 00:01:03.720
That means that when this optional
is used in an expression,

00:01:03.720 --> 00:01:06.150
it will automatically unwrap.

00:01:06.150 --> 00:01:10.840
It is an optional, so it can store a
value or nil, but it's as if it's a very

00:01:10.840 --> 00:01:14.940
fragile wrapped package that immediately
falls open when it's picked up.

00:01:14.940 --> 00:01:16.730
Because we don't unwrap it carefully,

00:01:16.730 --> 00:01:20.020
if there's a nil value inside,
bad things can happen.

00:01:20.020 --> 00:01:21.770
A fatal error could be thrown.

00:01:21.770 --> 00:01:25.450
So in what scenarios would it
be appropriate to use such

00:01:25.450 --> 00:01:27.380
a volatile optional?

00:01:27.380 --> 00:01:29.490
Let's look at a couple examples.

00:01:29.490 --> 00:01:33.140
Let's say we're using our old friend
the Int initializer method and

00:01:33.140 --> 00:01:37.140
invoking it on a variable that we're
confident can be converted to an int.

00:01:37.140 --> 00:01:41.310
We know this method is going
to return the int 123, so

00:01:41.310 --> 00:01:45.410
in this case, unwrapping with
an exclamation point is appropriate.

00:01:45.410 --> 00:01:48.450
We know there's little risk
of an error being thrown, so

00:01:48.450 --> 00:01:53.150
we can place the exclamation
point after w like this, or

00:01:53.150 --> 00:01:56.670
we could unwrap the return
value directly, like this.

00:01:56.670 --> 00:02:00.950
In the second case, the value assigned
to w will be a plain old int.

00:02:00.950 --> 00:02:04.100
What about declaring implicitly
unwrapped optionals?

00:02:04.100 --> 00:02:07.010
When is an appropriate time to be so
bold?

00:02:07.010 --> 00:02:10.449
Well, remember the button
property in our view controller?

00:02:10.449 --> 00:02:13.640
We know that this button property will
be nil when the view controller's

00:02:13.640 --> 00:02:17.420
created, so we know it needs
to have an optional type.

00:02:17.420 --> 00:02:20.150
We can also be confident that
this button property will be set

00:02:20.150 --> 00:02:21.360
by storyboard.

00:02:21.360 --> 00:02:24.663
In that case, it should be okay to
unwrap this property automatically and

00:02:24.663 --> 00:02:26.438
declare it with an exclamation point.

00:02:29.096 --> 00:02:31.530
It is possible for this to backfire.

00:02:32.580 --> 00:02:36.630
Here's what it looks like in an x code
project if we try to use the button but

00:02:36.630 --> 00:02:38.700
it hasn't been initialized.

00:02:38.700 --> 00:02:43.180
Again, the problem here is that we're
accessing the button in order to get

00:02:43.180 --> 00:02:47.190
the title for state but
the button doesn't exist yet.

00:02:47.190 --> 00:02:48.480
You can get a fatal error.

00:02:49.740 --> 00:02:53.700
This is why one has to be careful and
only try to access an implicitly

00:02:53.700 --> 00:02:57.670
unwrapped optional in a case like this
when you know the button will be there.

