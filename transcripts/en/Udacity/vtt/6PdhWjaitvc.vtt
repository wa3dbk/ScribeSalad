WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:04.130
Instead of the generator generating all the successive states and then

00:00:04.130 --> 00:00:08.980
a tester finding out that this state, this state and this state are identical to

00:00:08.980 --> 00:00:13.830
the initial state. One could make the generator itself smarter and

00:00:13.830 --> 00:00:17.140
say that a generator will not even generate these three states, but

00:00:17.140 --> 00:00:20.560
it will know that it should not generate states that are already up here.

00:00:20.560 --> 00:00:24.150
This means that we can either provide the generator with

00:00:24.150 --> 00:00:27.850
some additional abilities or the tester with some additional abilities or

00:00:27.850 --> 00:00:32.780
both. If the generator was smarter, then it would not even generate these three

00:00:32.780 --> 00:00:37.790
states because they are nonproductive. I would exclude maybe the tester,

00:00:37.790 --> 00:00:41.780
the determinant of this state is illegal and therefore dismisses it.

00:00:41.780 --> 00:00:45.690
We could even go one step further and make the generator even smarter, so

00:00:45.690 --> 00:00:48.570
the generator will not generate this particular state. And thus,

00:00:48.570 --> 00:00:53.120
the balance within the generator and the tester can shift depending on where we

00:00:53.120 --> 00:00:57.690
try to put knowledge. For this problem, for this relatively simple and

00:00:57.690 --> 00:01:01.510
small problem, the balance will responsibility between the generator and

00:01:01.510 --> 00:01:06.550
test might look like a tree relationship. But imagine a problem in

00:01:06.550 --> 00:01:11.000
if there are a million such states. Then whether we have generated very smart or

00:01:11.000 --> 00:01:16.090
the tests are very smart or both can become a important issue. Despite that,

00:01:16.090 --> 00:01:20.360
genetic testing factors are a very popular method used in some schools of AI.

00:01:20.360 --> 00:01:24.740
Genetic algorithms, for instance, can be viewed as genetic [INAUDIBLE].

00:01:24.740 --> 00:01:29.040
Given a number of states, they try to find out all the potential successive

00:01:29.040 --> 00:01:33.600
states that are possible, given some simple rules of recombination. And

00:01:33.600 --> 00:01:37.810
then of a fitness function that acts as a tester. Genetic algorithms, therefore,

00:01:37.810 --> 00:01:41.060
are an effective method for a very large number of problems.

00:01:41.060 --> 00:01:45.030
They're also a very inefficient method because neither the generator nor

00:01:45.030 --> 00:01:48.100
the testing generator algorithms are especially smart.

