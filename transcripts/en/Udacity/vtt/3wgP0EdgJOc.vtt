WEBVTT
Kind: captions
Language: en

00:00:00.390 --> 00:00:04.820
If RPC has to be a viable mechanism for
structuring operating

00:00:04.820 --> 00:00:09.310
systems services above the kernel,
using the client server paradigm.

00:00:09.310 --> 00:00:12.410
Then it is important to
reduce this overhead.

00:00:12.410 --> 00:00:15.510
Now let's see how we can
reduce the overheads.

00:00:15.510 --> 00:00:18.170
And make RPC cheap enough that

00:00:18.170 --> 00:00:21.590
you want to use it in building
client service systems.

00:00:21.590 --> 00:00:23.940
How do we remove these overheads?

00:00:23.940 --> 00:00:26.590
The trick is to optimize
the common keys.

00:00:26.590 --> 00:00:27.590
Now what are the common keys?

00:00:27.590 --> 00:00:31.350
Well, the common keys is the actual
calls that are being made by the client

00:00:31.350 --> 00:00:32.119
to the server.

00:00:32.119 --> 00:00:35.590
We expect that those calls
are going to be made several times

00:00:35.590 --> 00:00:38.560
during the lifetime of the server and
the client.

00:00:38.560 --> 00:00:39.979
And so that's the key thing.

00:00:39.979 --> 00:00:43.634
That you want to make sure
that during the actual calls,

00:00:43.634 --> 00:00:46.502
the copying overhead
that I talked about.

00:00:46.502 --> 00:00:51.405
And the locality of the arguments and
the results, in terms of stuff being in

00:00:51.405 --> 00:00:56.670
the caches that are accessible to the
client and the server, that's the key.

00:00:56.670 --> 00:00:57.700
That's the common key.

00:00:57.700 --> 00:01:01.500
That's what we want to make
as efficient as possible.

00:01:01.500 --> 00:01:06.110
Now, setting up the relationship between
the client and the server itself,

00:01:06.110 --> 00:01:11.190
on the very first call by the client,
that needs to be done exactly once.

00:01:11.190 --> 00:01:13.720
And that process is
what is called binding.

00:01:13.720 --> 00:01:15.740
Binding the client and server.

00:01:15.740 --> 00:01:19.740
That is done once, the first call
is when the binding happens, and

00:01:19.740 --> 00:01:20.420
that's done once.

00:01:21.470 --> 00:01:26.890
Now, since the setup for the binding is
done only once, it's a one-time cost.

00:01:26.890 --> 00:01:30.280
It's okay if it is more
expensive than the actual costs.

00:01:30.280 --> 00:01:35.640
So, the binding, we can afford
to make it more time consuming,

00:01:35.640 --> 00:01:36.540
it's okay to do that.

00:01:36.540 --> 00:01:41.356
And these ideas should sound very
familiar to you from exokernal,

00:01:41.356 --> 00:01:46.516
that we've discussed before,
that we want to make the one time costs,

00:01:46.516 --> 00:01:49.708
not focus on the one
time cost of setting up.

00:01:49.708 --> 00:01:53.180
Which is a one time cost, but
focus on it is a recurring cost,

00:01:53.180 --> 00:01:56.340
which is the actual calls
that are being made.

00:01:56.340 --> 00:02:00.510
So now, let's discuss in more
detail how this binding works.

00:02:00.510 --> 00:02:03.150
The server has an entry
point procedure called

00:02:03.150 --> 00:02:06.540
foo that it wants to make it
available for clients to call.

00:02:06.540 --> 00:02:08.490
And in order to make it available for
everybody,

00:02:08.490 --> 00:02:11.970
it publishes this entry point
procedure in a name server.

00:02:11.970 --> 00:02:15.580
And let's the kernel know that there's
an entry point procedure called

00:02:15.580 --> 00:02:16.670
foo that's available for it.

00:02:16.670 --> 00:02:21.960
And the name server is a vehicle by
which anyone in the system can find on.

00:02:21.960 --> 00:02:23.820
It's sort of like the yellow pages,
right?

00:02:23.820 --> 00:02:26.450
So, you want to look
up somebody's name or

00:02:26.450 --> 00:02:29.160
phone number,
you look it up in the yellow pages.

00:02:29.160 --> 00:02:31.960
Similarly, this name server
serves the same purpose

00:02:31.960 --> 00:02:35.540
that if I want to know what
services are offered as a client.

00:02:35.540 --> 00:02:39.016
If I want to know what services
are offered by a particular server,

00:02:39.016 --> 00:02:42.048
I can find out from the nameserver
what are the entry point

00:02:42.048 --> 00:02:43.583
services available from S.

00:02:43.583 --> 00:02:47.413
So foo is an entry point service
that's available in the server,

00:02:47.413 --> 00:02:49.293
registers the name server, and

00:02:49.293 --> 00:02:53.067
let's the kernel know that it
has this particular entry point.

00:02:53.067 --> 00:02:56.386
And at this point the server
is basically waiting for

00:02:56.386 --> 00:02:59.370
bind requests to come from the colonel.

00:02:59.370 --> 00:03:02.660
Now the client looks
up the name server and

00:03:02.660 --> 00:03:05.465
finds that S is an entry
point called foo.

00:03:05.465 --> 00:03:07.855
So this is an entry point
that's available for

00:03:07.855 --> 00:03:10.105
this client to make
a call on the server.

00:03:10.105 --> 00:03:13.335
So the client issues this call s.foo,

00:03:13.335 --> 00:03:18.105
meaning that it wants to execute
this procedure foo onto server S.

00:03:18.105 --> 00:03:22.840
And so that's RPC call,
the first time, C is making.

00:03:22.840 --> 00:03:25.980
And this of course results
in a trap into the kernel.

00:03:25.980 --> 00:03:29.794
The kernel doesn't know whether
the server is willing to

00:03:29.794 --> 00:03:32.262
accept calls from the client or not.

00:03:32.262 --> 00:03:34.248
And therefore what it has to do is,

00:03:34.248 --> 00:03:38.840
it has to check with the server whether
there's a legitimate bona-fide client

00:03:38.840 --> 00:03:42.370
that can make calls on those
entry point procedure foo.

00:03:42.370 --> 00:03:47.580
And so the kernel basically makes an
up-call into the server saying that hey,

00:03:47.580 --> 00:03:48.260
you know what?

00:03:48.260 --> 00:03:51.690
There is this client that wants to
make something with this identity.

00:03:51.690 --> 00:03:56.640
Wants to make a call on your
entry point procedure foo.

00:03:56.640 --> 00:03:59.320
And that's the up call
that goes into the server.

00:03:59.320 --> 00:04:03.960
The server, if it recognizes
that this client is a bonafide

00:04:03.960 --> 00:04:08.460
client that can make this call,
it grants permission via the kernel that

00:04:08.460 --> 00:04:13.780
this client can make this call on
its entry point procedure foo.

00:04:13.780 --> 00:04:18.209
So once this validation has been done,
what the kernel does

00:04:18.209 --> 00:04:22.160
is to set up a descriptor called
the procedure descriptor.

00:04:22.160 --> 00:04:25.730
And the procedure descriptor is a data
structure that is in the kernel.

00:04:25.730 --> 00:04:30.300
And it is for this particular
entry point procedure foo.

00:04:30.300 --> 00:04:34.230
And it's part of granting
access to the client

00:04:34.230 --> 00:04:37.890
to make this call into its
entry point procedure, foo.

00:04:37.890 --> 00:04:40.820
What the server is going to
do is tell the kernel

00:04:40.820 --> 00:04:44.820
that these are the characteristics of
this particular entry point procedure.

00:04:44.820 --> 00:04:46.340
In particular, it's going to say,

00:04:46.340 --> 00:04:52.060
this is the entry point address where
you have to call me if there is call.

00:04:52.060 --> 00:04:56.810
This is the address of the entry
point procedure in my address space

00:04:56.810 --> 00:05:00.950
where code exists for
this particular procedure foo.

00:05:00.950 --> 00:05:04.584
And this is indicating the size
of an argument stack, and

00:05:04.584 --> 00:05:08.689
I'm going to talk to you a little
bit more about this in a minute.

00:05:08.689 --> 00:05:13.229
And this argument stack is going to
be the communication area between

00:05:13.229 --> 00:05:18.004
the client and the server, and this
entry in the procedure descriptor is

00:05:18.004 --> 00:05:22.390
just seeing, what are the sizes
of this argument stack?

00:05:22.390 --> 00:05:25.825
So this communication vehicle
that is going to be established

00:05:25.825 --> 00:05:28.995
between the client and
the server is going to be dependent at

00:05:28.995 --> 00:05:32.974
the formal parameters that are being
passed the client and the server.

00:05:32.974 --> 00:05:35.780
And the results that are being passed
from the server back to the client.

00:05:35.780 --> 00:05:39.980
Based on that, the server is going
to indicate to the kernel that

00:05:39.980 --> 00:05:42.950
communication area that
I want is this size.

00:05:42.950 --> 00:05:45.590
So, that's the size of this A-stack.

00:05:45.590 --> 00:05:47.890
I'm going to talk more
about that in a minute.

00:05:47.890 --> 00:05:52.390
And it is also going to say
how many simultaneous calls

00:05:52.390 --> 00:05:57.160
S is willing to accept for
this particular procedure foo.

00:05:57.160 --> 00:06:01.065
And the purpose of this is,
if this is a multi-processor and

00:06:01.065 --> 00:06:04.690
there are multiple cores and
multiple processes available.

00:06:04.690 --> 00:06:06.460
Then it may be possible for

00:06:06.460 --> 00:06:10.680
S to farm out multiple threads to
execute simultaneous calls that

00:06:10.680 --> 00:06:14.550
are coming in from multiple
clients distributed in the system.

00:06:14.550 --> 00:06:17.700
And so
they're saying how many concurrent calls

00:06:17.700 --> 00:06:22.230
the server is willing to accept on
behalf of this particular procedure.

00:06:22.230 --> 00:06:25.540
So, this procedure
descriptor is specific.

00:06:25.540 --> 00:06:28.880
Do this procedure foo, and it is saying,

00:06:28.880 --> 00:06:33.130
where is the entry point in the server's
domain for this particular procedure?

00:06:33.130 --> 00:06:37.840
What are the size of the communication
buffer that is needed to be established

00:06:37.840 --> 00:06:41.620
by the kernel for communication
between the client and the server?

00:06:41.620 --> 00:06:44.580
And the third thing is,
how many simultaneous calls

00:06:44.580 --> 00:06:47.780
the server is willing to accept for
this particular procedure, foo.

