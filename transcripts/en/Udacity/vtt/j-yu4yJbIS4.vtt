WEBVTT
Kind: captions
Language: en

00:00:00.540 --> 00:00:05.290
I will create a new views.py file
with a route called rate/limited.

00:00:05.290 --> 00:00:07.180
Later, I will create
a limiting decorator

00:00:07.180 --> 00:00:09.150
to restrict the number of requests.

00:00:09.150 --> 00:00:10.030
I should point out that for

00:00:10.030 --> 00:00:14.075
this example, I'm using the IP address
as the identifier of the client.

00:00:14.075 --> 00:00:17.555
This way rate limiting works even for
non-logged in users.

00:00:17.555 --> 00:00:20.165
But you can change this for
your implementation of future projects.

00:00:21.605 --> 00:00:24.805
Redis is an open source
in-memory data structure

00:00:24.805 --> 00:00:27.680
that can be used as a database,
cache and message broker.

00:00:29.000 --> 00:00:32.070
Redis provides us with a fast way to
keep track of end point requests,

00:00:32.070 --> 00:00:33.120
that is also scalable.

00:00:34.400 --> 00:00:37.320
Your vagrant machine already
has Redis installed.

00:00:37.320 --> 00:00:39.950
Just run Redis server from
inside your vagrant machine

00:00:39.950 --> 00:00:41.249
to fire up this Redis instance.

00:00:42.610 --> 00:00:45.900
You can now point to your Redis
instance with the code here.

00:00:45.900 --> 00:00:48.650
Now, I will make a class
called RateLimit that takes in

00:00:48.650 --> 00:00:50.950
the new object model
introduced in Python 2.2.

00:00:50.950 --> 00:00:55.360
I will make a variable called
expiration_window that will give my

00:00:55.360 --> 00:00:59.540
key an extra ten seconds to expire in
redis, so that badly synchronized clocks

00:00:59.540 --> 00:01:02.160
between workers and the redis
server do not cause any problems.

00:01:03.270 --> 00:01:06.510
I will now create an init method for
the RateLimit class.

00:01:06.510 --> 00:01:11.294
Taking init self the variables
key_prefix, limit, per and

00:01:11.294 --> 00:01:12.950
send_x_headers.

00:01:13.990 --> 00:01:17.220
Key is going to represent a string that
I will use to keep track of the rate

00:01:17.220 --> 00:01:18.480
limits for each of the requests.

00:01:19.490 --> 00:01:22.450
Limit and per define the number
of requests we want to allow over

00:01:22.450 --> 00:01:24.210
a certain time period.

00:01:24.210 --> 00:01:27.820
And send_x_headers is a Boolean option
that will allow us to inject into

00:01:27.820 --> 00:01:31.230
each response header the number of
remaining requests a client can make

00:01:31.230 --> 00:01:32.070
before they hit the limit.

00:01:33.100 --> 00:01:35.670
I would define reset here
to make a timestamp to

00:01:35.670 --> 00:01:38.890
indicate when a request
limit can reset itself.

00:01:38.890 --> 00:01:40.200
Then I will append this to my key.

00:01:41.410 --> 00:01:44.820
We use a pipeline to make sure that
we never increment a key without also

00:01:44.820 --> 00:01:48.250
setting the key expiration in case an
exception happens between those lines.

00:01:49.880 --> 00:01:51.390
For instance, if a process is killed.

00:01:52.510 --> 00:01:54.760
I will now increment
the value of my pipeline and

00:01:54.760 --> 00:01:58.080
set it to expire based on my reset
value and expiration window.

00:01:59.190 --> 00:02:02.350
I'll add two lambda functions to
calculate how many remaining requests I

00:02:02.350 --> 00:02:06.750
have left and another one that returns
true if I've hit my rate limit.

00:02:06.750 --> 00:02:10.541
I'll define the get_view_rate_limit
function which will retrieve

00:02:10.541 --> 00:02:13.350
the view_rate_limit from
the g-object in flask.

00:02:13.350 --> 00:02:15.450
I will use this function later
on inside of my decorator.

00:02:17.050 --> 00:02:19.870
I'll also make a function called
on_over_limit that returns

00:02:19.870 --> 00:02:22.840
the message that a client has
reached their limit of requests

00:02:22.840 --> 00:02:25.700
along with a 429 error which
means too many requests.

00:02:27.570 --> 00:02:31.420
Now I will create a rate limit method
that will wrap around my decorator

00:02:31.420 --> 00:02:33.140
taking in the following
values as arguments.

00:02:34.560 --> 00:02:37.470
The key is constructed by default
from the remote address and

00:02:37.470 --> 00:02:39.280
the current endpoint.

00:02:39.280 --> 00:02:42.300
Before the function is executed,
it increments the rate limit,

00:02:42.300 --> 00:02:44.660
with the help of
the rate limit class and

00:02:44.660 --> 00:02:49.470
stores an instance on the g object,
as g._view_rate_limit.

00:02:49.470 --> 00:02:51.720
If the view function is
indeed over the limit,

00:02:51.720 --> 00:02:54.750
we automatically call
a different function instead.

00:02:54.750 --> 00:02:58.270
Now, I will append the number of
remaining requests, the limit for

00:02:58.270 --> 00:03:01.420
that end point, and
the time until the limit resets itself,

00:03:01.420 --> 00:03:05.180
inside the header of each response,
that hits the rate limited request.

00:03:05.180 --> 00:03:08.730
This feature can be turned off if
send_x_headers is set to false.

00:03:08.730 --> 00:03:11.360
Whenever the rate limit
decorator is called and

00:03:11.360 --> 00:03:15.840
speaking of ratelimit decorator I can
now add the rate limit to my route.

00:03:15.840 --> 00:03:19.200
Here it is currently set to allow
300 requests per 30 seconds.

00:03:20.350 --> 00:03:23.785
So if everything worked well I can
fire up my flask web app and run this

00:03:23.785 --> 00:03:28.470
hungryclient.py file I made in order
to see how well my rate limiter works.

00:03:28.470 --> 00:03:31.820
I will tell hungryclient to send
off 2000 requests per minute or

00:03:31.820 --> 00:03:33.390
as fast as it can.

00:03:33.390 --> 00:03:34.155
As you can see,

00:03:34.155 --> 00:03:38.930
hungryclient is successfully reaching
the end point until it hits the limit.

00:03:38.930 --> 00:03:40.810
Then it waits five seconds and
tries again.

00:03:42.050 --> 00:03:43.590
Once the time limit is reached and

00:03:43.590 --> 00:03:46.892
reset, more requests can be
made until we reach 2,000.

00:03:46.892 --> 00:03:49.630
Code for this activity is
available in the instructor notes.

