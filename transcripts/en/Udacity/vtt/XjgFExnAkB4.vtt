WEBVTT
Kind: captions
Language: en

00:00:00.360 --> 00:00:03.190
I've been working through how you'd
write super simplistic read it write

00:00:03.190 --> 00:00:05.150
rules using true and false.

00:00:05.150 --> 00:00:08.769
But that's kind of useless in the
shopping list plus plus world where we

00:00:08.769 --> 00:00:11.496
want to read it write based
off of who's logged in.

00:00:11.496 --> 00:00:14.649
&gt;&gt; Yes, connecting your authorization
to your authentication.

00:00:14.649 --> 00:00:17.650
That should be very easy your
developer just needs to know a bit

00:00:17.650 --> 00:00:21.000
about a few extra variables here,
let me show you.

00:00:21.000 --> 00:00:24.770
&gt;&gt; As you know Firebase provides helpful
variables that you can use in your

00:00:24.770 --> 00:00:25.830
rules.

00:00:25.830 --> 00:00:28.350
You've already learned about
two of these, data and

00:00:28.350 --> 00:00:34.430
newData, which are essentially variables
that you can use in your JSON Rules for

00:00:34.430 --> 00:00:37.010
the previous state of the data and
the new state of the data.

00:00:38.670 --> 00:00:42.845
In addition, you have access to root,
now and auth.

00:00:42.845 --> 00:00:46.940
Root is a variable that represents
a rules data snapshot, much like data or

00:00:46.940 --> 00:00:51.660
new data, but
it's of the root Node for your data.

00:00:51.660 --> 00:00:52.820
Now is a variable,

00:00:52.820 --> 00:00:56.960
that stores the timestamp, representing
the exact time on the server.

00:00:56.960 --> 00:00:58.920
You can use it to write
rules to check for

00:00:58.920 --> 00:01:03.380
things like whether the timestamp is
before or after the current time.

00:01:03.380 --> 00:01:07.182
For example, the following rule could be
used to check that somebody isn't trying

00:01:07.182 --> 00:01:09.150
to write a timestamp
that is in the future.

00:01:10.330 --> 00:01:14.129
And one of the most important
variables is the auth variable,

00:01:14.129 --> 00:01:17.770
this variable has two
pieces of information.

00:01:17.770 --> 00:01:20.750
The provider and the uid of the user,
if they're logged in,

00:01:22.990 --> 00:01:27.650
if the user is not logged in,
the auth variable is equal to no.

00:01:27.650 --> 00:01:32.340
This variable allows you to check
whether someone is logged in and

00:01:32.340 --> 00:01:33.750
is a specific user.

00:01:33.750 --> 00:01:36.270
A lot of the permissions
to edit lists and

00:01:36.270 --> 00:01:40.770
shopping list items, dealt with
who the logged in user was for

00:01:40.770 --> 00:01:45.890
any rules related to who the user is
you'll need to use the auth variable.

00:01:45.890 --> 00:01:50.210
Beyond representing dynamic keys,
wildcard variables are also available to

00:01:50.210 --> 00:01:54.310
you in the rules themselves, they take
on the value of the key that they match.

00:01:54.310 --> 00:01:58.570
So if you had a messaging app that
had lists of messages a user posted,

00:01:58.570 --> 00:02:01.760
this would allow you to write rules
that compare the dynamic key of

00:02:01.760 --> 00:02:04.690
an object with the value
of one of its children.

00:02:04.690 --> 00:02:07.960
Here we're checking that the user
ID property of a message matches

00:02:07.960 --> 00:02:09.500
the user ID that it's listed under.

00:02:11.420 --> 00:02:13.620
If you learn to use
these simple variables,

00:02:13.620 --> 00:02:15.910
writing your read-write
rules will be easy as pie.

