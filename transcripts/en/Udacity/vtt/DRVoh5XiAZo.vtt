WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.000
So far, we may have encountered assertions in tests, in particular, in unit tests.

00:00:06.000 --> 00:00:12.000
Here, assertions are being used to check the results of a single run, mainly the test run.

00:00:12.000 --> 00:00:18.000
What we're going to look into is assertions that are integrated into the program code itself.

00:00:18.000 --> 00:00:21.000
Where the check all runs at once.

00:00:21.000 --> 00:00:25.000
A classic example for the use of assertions is a square root program.

00:00:25.000 --> 00:00:29.000
In the beginning, when invoking square root, we want to make sure

00:00:29.000 --> 00:00:32.000
that x, the parameter, is non-negative.

00:00:32.000 --> 00:00:37.000
I'll skip the actual computation of square roots here because this is the subject of another class,

00:00:37.000 --> 00:00:42.000
but before we return to the actual square root, we want to make sure

00:00:42.000 --> 00:00:44.000
that the square root actually is a square root.

00:00:44.000 --> 00:00:47.000
How do we do that--well, we square the square root

00:00:47.000 --> 00:00:51.000
and check whether it's identical to the original argument x.

00:00:51.000 --> 00:00:56.000
These two kinds of assertions form a pair and both of them have very specific objectives.

00:00:56.000 --> 00:01:00.000
An assertion that's being called at the beginning of a function

00:01:00.000 --> 00:01:04.000
and which checks the properties of the arguments is called precondition.

00:01:04.000 --> 00:01:08.000
An assertion which checks the result of a computation

00:01:08.000 --> 00:01:11.000
before it's actually being returned is called a postcondition.

00:01:11.000 --> 00:01:14.000
If you have such explicit checks in your code,

00:01:14.000 --> 00:01:18.000
this greatly increases your chances of quickly finding the bug,

00:01:18.000 --> 00:01:23.000
because these checks would re-invoke every single time that the function is executed

00:01:23.000 --> 00:01:26.000
and if they don't fail, you know that the computation

00:01:26.000 --> 00:01:29.000
is actually correct, which is a good thing.

00:01:29.000 --> 00:01:33.000
If you remember, our cause-effect chain has a succession of program states,

00:01:33.000 --> 00:01:38.000
where a defect introduces an infection which is then propagate to become the failure,

00:01:38.000 --> 00:01:42.000
imagine what happens if you actually do have assertions in your code

00:01:42.000 --> 00:01:45.000
that check large parts of your state.

00:01:45.000 --> 00:01:48.000
Now imagine what happens if you do have assertions in your code

00:01:48.000 --> 00:01:53.000
that check large parts of your state for whether they're valid or not.

00:01:53.000 --> 00:01:58.000
Suppose you have an assertion that checks all of these area every time a function is invoked,

00:01:58.000 --> 00:02:02.000
then you wouldn't see the failure only at the last moment but you would see the failure

00:02:02.000 --> 00:02:05.000
as soon as the infection spreads towards.

00:02:05.000 --> 00:02:09.000
If you have another assertion that covers this part of the state,

00:02:09.000 --> 00:02:12.000
then you would see the failure at the very moment it is introduced.

00:02:12.000 --> 00:02:16.000
which of course also means that you can immediately identify

00:02:16.000 --> 00:02:20.000
the defect that causes the infection.

00:02:20.000 --> 00:02:24.000
The earlier you see an infection--for instance, because an assertion fails,

00:02:24.000 --> 00:02:27.000
the shorter the cause-effect chain, we need to investigate.

00:02:27.000 --> 00:02:32.000
Also, if you do have parts of the state that are covered by assertion

00:02:32.000 --> 00:02:38.000
and these assertions don't fail, then we know that the state in here is actually not infected

00:02:38.000 --> 00:02:43.000
and so in your search, you can narrow down your search towards those parts of the state,

00:02:43.000 --> 00:02:48.000
which are not covered by passing assertions and all of this happens automatically

00:02:48.000 --> 00:02:52.000
with every single run, every single test run, and if you want so, even every single production run.

