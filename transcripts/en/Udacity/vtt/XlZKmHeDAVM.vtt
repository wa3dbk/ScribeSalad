WEBVTT
Kind: captions
Language: en

00:00:01.010 --> 00:00:03.410
And so, if we're going to
talk about all the elements,

00:00:03.410 --> 00:00:05.970
we'd better have a handle on
how many elements there are.

00:00:05.970 --> 00:00:08.620
So, how would you deal with that?

00:00:08.620 --> 00:00:12.053
&gt;&gt; We could use some variable, I guess,

00:00:12.053 --> 00:00:17.854
to represent the number of
elements in the vector, say N.

00:00:17.854 --> 00:00:18.912
That would work.
&gt;&gt; Okay, and

00:00:18.912 --> 00:00:22.834
are there any limits on the value, then?

00:00:24.937 --> 00:00:26.282
&gt;&gt; No, I don't think so.

00:00:26.282 --> 00:00:29.198
&gt;&gt; Well,
it better be non-negative, right?

00:00:29.198 --> 00:00:29.731
&gt;&gt; Right, right, yes.

00:00:29.731 --> 00:00:33.180
&gt;&gt; It wouldn't make sense to have
a vector of negative length.

00:00:33.180 --> 00:00:37.310
So, we're going to,
when we talk about all the elements, and

00:00:37.310 --> 00:00:41.850
the typical element is going
to be in the ith position.

00:00:41.850 --> 00:00:47.530
The value of i is going to
go up to this value of n.

00:00:47.530 --> 00:00:50.381
And, of course, with programming
languages, you have to worry about

00:00:50.381 --> 00:00:53.340
whether they start counting from zero,
or they start counting from one.

00:00:53.340 --> 00:00:55.852
And here, we'll say that
we start counting from one.

00:00:55.852 --> 00:00:59.920
That is the first element of
the vector using position one.

00:00:59.920 --> 00:01:00.613
And then,

00:01:00.613 --> 00:01:05.181
the subsequent elements go up to
the last one then being in position n.

00:01:05.181 --> 00:01:11.470
So, if there are n elements in the
vector, and we are talking about all but

00:01:11.470 --> 00:01:17.825
the last, that says we're talking
about from position one to n minus 1.

00:01:17.825 --> 00:01:18.433
&gt;&gt; Right.

00:01:18.433 --> 00:01:19.284
&gt;&gt; Okay?
&gt;&gt; And

00:01:19.284 --> 00:01:22.420
we want to have some property
that's true about that.

00:01:22.420 --> 00:01:26.380
And you said that the property was that,
if we look at that position and

00:01:26.380 --> 00:01:29.600
get the value in that vector,
it's less than or

00:01:29.600 --> 00:01:31.270
equal to the value in the next position.

00:01:32.270 --> 00:01:32.880
&gt;&gt; Correct.
&gt;&gt; Okay.

00:01:32.880 --> 00:01:36.220
So if we're going from one to n minus 1,
and

00:01:36.220 --> 00:01:41.385
n is initially 0, isn't that asking
us to look in the position minus 1?

00:01:43.010 --> 00:01:48.270
&gt;&gt; I guess n can't be negative,
but couldn't

00:01:49.510 --> 00:01:55.220
we write it in such a way that we say,
i, and then i plus 1?

00:01:55.220 --> 00:01:58.060
So, we could start at zero,
and then go to one?

00:01:58.060 --> 00:01:59.952
&gt;&gt; Well,
I think we have the same problem there.

00:01:59.952 --> 00:02:03.353
&gt;&gt; Okay.
&gt;&gt; But, what we're trying to do is make

00:02:03.353 --> 00:02:08.240
some statement for all i,
i being from one to n minus 1.

00:02:08.240 --> 00:02:11.982
If n is zero,
then we're saying from all i,

00:02:11.982 --> 00:02:16.447
from one to minus 1, and
there aren't any i there.

00:02:16.447 --> 00:02:18.270
So vacuously, it's true.

00:02:19.310 --> 00:02:19.900
Okay?

00:02:19.900 --> 00:02:24.376
So, even though we run into this
seemingly nonsensical situation,

00:02:24.376 --> 00:02:28.399
it doesn't actually effect
the truth of the post condition.

00:02:28.399 --> 00:02:29.107
Okay?

00:02:29.107 --> 00:02:31.700
So, think about that a little bit.

00:02:31.700 --> 00:02:37.020
And given that, we're then allowed to
make this quantified statement for

00:02:37.020 --> 00:02:40.400
all i, from one to n minus 1.

00:02:40.400 --> 00:02:47.710
And what must be true of each
of those i possibilities?

00:02:47.710 --> 00:02:48.744
You're talking about the output.

00:02:48.744 --> 00:02:50.182
&gt;&gt; This doesn't get any easier.

00:02:50.182 --> 00:02:51.925
[LAUGH].

00:02:51.925 --> 00:02:53.074
But we have [INAUDIBLE].

00:02:53.074 --> 00:02:58.300
Okay, so y of i is less than or
equal to, or no.

00:02:58.300 --> 00:03:01.320
We're going to do an i minus 1.

00:03:01.320 --> 00:03:08.060
So it's going to be greater than or
equal to y of minus 1.

00:03:08.060 --> 00:03:08.920
&gt;&gt; Nope.

00:03:08.920 --> 00:03:10.322
I think you had it right the first time.

00:03:10.322 --> 00:03:10.961
&gt;&gt; Oh.

00:03:10.961 --> 00:03:13.136
&gt;&gt; If i is starting at one, okay,

00:03:13.136 --> 00:03:17.923
then we're going to be talking about and
we're going to n minus 1.

00:03:17.923 --> 00:03:21.696
We're going to be going
to y sub i plus 1.

00:03:21.696 --> 00:03:22.775
&gt;&gt; Okay.

00:03:22.775 --> 00:03:26.590
&gt;&gt; Okay, so you might want
to change your slide there.

00:03:26.590 --> 00:03:28.910
Okay.
So what it means to be ordered is,

00:03:28.910 --> 00:03:33.500
if we look at the first n minus 1
elements, any one of those, and compare

00:03:33.500 --> 00:03:38.940
it to the one next to it on the right,
it's got to be less than or equal to it.

00:03:38.940 --> 00:03:42.170
And if we have that property,
then we say that the output is ordered.

00:03:42.170 --> 00:03:46.340
Notice, that we didn't say anything
in this part of the post condition

00:03:46.340 --> 00:03:50.370
about what those y's are and
how they relate to the input.

00:03:50.370 --> 00:03:53.200
That's what the second part
of the specification is.

00:03:53.200 --> 00:03:56.970
&gt;&gt; Before we move forward, is it okay
to start trying to express things?

00:03:56.970 --> 00:04:01.429
This is kind of like predicate
calculus kind of notation.

00:04:01.429 --> 00:04:07.270
Is that what we'll be leaning towards
once we start expressing things in OCL?

00:04:08.290 --> 00:04:14.250
&gt;&gt; So, in this part of the lesson,
we're going to use first order logic.

00:04:14.250 --> 00:04:19.325
It turns out that OCL is just another
syntax on top of first order logic.

00:04:19.325 --> 00:04:22.442
Okay?
We're going to stick with first order

00:04:22.442 --> 00:04:23.480
logic here.

00:04:23.480 --> 00:04:26.440
Eventually, I'll show
you a little bit of OCL.

00:04:26.440 --> 00:04:31.037
And then, in later lessons, we'll get
into the whole OCL as a language,

00:04:31.037 --> 00:04:35.785
which in addition to first order logic
has some other things that help it deal

00:04:35.785 --> 00:04:36.470
with UML.

