WEBVTT
Kind: captions
Language: en

00:00:00.170 --> 00:00:04.710
Now let's see the ROB is fixing our exception handling problems. And

00:00:04.710 --> 00:00:08.250
remember there are two of those problems. One of the problems occurs

00:00:08.250 --> 00:00:13.170
because this divide can be delayed, and realise that R2 is 0 much,

00:00:13.170 --> 00:00:17.310
much later. While the add for example can be quick and be done.

00:00:17.310 --> 00:00:20.990
So if you remember with [UNKNOWN] algorithm, the add would deposit the result to

00:00:20.990 --> 00:00:25.348
the destination register of the add long before the divide had the chance that

00:00:25.348 --> 00:00:29.450
R2 was 0 and that really we should have jumped to the exception handler here and

00:00:29.450 --> 00:00:32.530
never executed the add. So how does the rob help?

00:00:32.530 --> 00:00:37.160
So what we do is we treat the exception just like any other result.

00:00:37.160 --> 00:00:41.746
So basically when we determine that R2 is 0 instead of producing a result for

00:00:41.746 --> 00:00:46.930
R0, we mark R0 in the rob as, I mean, the result in the rob is now going to

00:00:46.930 --> 00:00:52.040
be exception instead of a value. When the divide reaches the commit point,

00:00:52.040 --> 00:00:55.690
at that point the add still hasn't committed, and everything before divide did.

00:00:55.690 --> 00:00:58.730
So at that point we can just do the, kind of wait for drain, you know,

00:00:58.730 --> 00:01:02.560
kind of flush everything, including the divide at this point, and

00:01:02.560 --> 00:01:06.720
jump to exit, exception handler. And now we have a stable state for the handler,

00:01:06.720 --> 00:01:10.740
which is here. Basically everything before the divide finished. The divide and

00:01:10.740 --> 00:01:13.600
everything after it didn't finish which is exactly the state that

00:01:13.600 --> 00:01:18.040
the divide by 0 exception handler should be seeing. Similarly for

00:01:18.040 --> 00:01:23.000
a load that would here have a page fault we would have the same situation of,

00:01:23.000 --> 00:01:27.170
when the page fault reaches the commit, we have committed everything

00:01:27.170 --> 00:01:30.750
before the page fault, and we haven't committed the page fault itself or

00:01:30.750 --> 00:01:34.170
anything after it. So there is a very nice resume point for

00:01:34.170 --> 00:01:37.470
the page fault exception handler. When we go back there and

00:01:37.470 --> 00:01:40.950
load a page from the disk we can jump back to the load of the store and

00:01:40.950 --> 00:01:44.540
then start executing from here, and because nothing here has already executed,

00:01:44.540 --> 00:01:48.580
everything is fine. The second problem with exceptions that we had were those

00:01:48.580 --> 00:01:53.610
phantom exceptions. Basically if we predicted that the branch here is not taken,

00:01:53.610 --> 00:01:58.400
we would execute this divide and maybe get the exception, like divide by 0. And

00:01:58.400 --> 00:02:01.560
at the time when we get this exception, maybe the branch is still not resolved.

00:02:01.560 --> 00:02:05.790
So when we finally resolve the branch it is too late because the divide by 0

00:02:05.790 --> 00:02:10.229
has already been triggered, so how does an R-O-B handle this?

00:02:10.229 --> 00:02:13.630
Well, the result of this instruction is now going to be marked as

00:02:13.630 --> 00:02:18.760
an exception in it's R-O-B. As the comment reaches the branch at the point or

00:02:18.760 --> 00:02:22.850
before it, depending on what kind of branch misprediction strategy we have,

00:02:22.850 --> 00:02:25.840
we will figure out that the branch has been mispredicted and

00:02:25.840 --> 00:02:29.994
that we really wanted to jump to this label here. At that point the divide and

00:02:29.994 --> 00:02:32.960
anything over here is not committed. Basically we haven't committed

00:02:32.960 --> 00:02:37.100
anything after the branch. So we can just cancel this instructions.

00:02:37.100 --> 00:02:41.640
They never reach commit and thus the exception here is never triggered. So

00:02:41.640 --> 00:02:46.020
the idea with exception handling is simply, treat the exception just as

00:02:46.020 --> 00:02:50.450
any other result. And delay the actual handling of exceptions until

00:02:50.450 --> 00:02:54.370
the instruction that is triggering the exception commits. At that point,

00:02:54.370 --> 00:02:57.880
we know exactly what the resume point is for the exception handler. And

00:02:57.880 --> 00:03:01.770
we know that we won't have any phantom exceptions because we would never

00:03:01.770 --> 00:03:06.790
reach the commit of this divide unless this divide was on the correct part for

00:03:06.790 --> 00:03:08.920
all the branches. Basically, if there was a misprediction,

00:03:08.920 --> 00:03:12.230
we would have canceled this divide long before it reaches the commit point.

