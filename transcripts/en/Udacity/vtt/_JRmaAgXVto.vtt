WEBVTT
Kind: captions
Language: en

00:00:01.440 --> 00:00:06.210
So I can see that you have
some mechanism here and

00:00:06.210 --> 00:00:12.040
in the specification file and
the generators for generating variance.

00:00:12.040 --> 00:00:14.620
Can you give me an idea of kind of
variance that might apply in this

00:00:14.620 --> 00:00:15.560
forecasting situation?

00:00:16.840 --> 00:00:17.380
&gt;&gt; Sure.

00:00:17.380 --> 00:00:21.820
So we already showed an example of the
most common case, which is what we call

00:00:21.820 --> 00:00:26.490
a batch forecaster, one that generates
forecast for all the locations and

00:00:26.490 --> 00:00:28.340
products that pertain
to a given retailer.

00:00:29.640 --> 00:00:36.160
Some other variants on that are we might
want to generate forecasts not in batch,

00:00:36.160 --> 00:00:40.190
right, not down in the database,
where they're materialized and kept.

00:00:40.190 --> 00:00:41.565
We might want to
generate them on demand.

00:00:41.565 --> 00:00:44.119
That is, we may just want to say,
all right,

00:00:44.119 --> 00:00:48.359
well rather than having to wait for
the weekly or the nightly reforecast for

00:00:48.359 --> 00:00:51.927
everything, I might want to
quickly regenerate a forecast for

00:00:51.927 --> 00:00:55.590
some particular product, or
some particular set of products.

00:00:56.980 --> 00:00:59.620
And I don't want to store
that result in the database,

00:00:59.620 --> 00:01:01.500
I just want to get an answer.

00:01:01.500 --> 00:01:03.530
We call that on demand forecasting.

00:01:03.530 --> 00:01:06.290
&gt;&gt; Is this something that somebody,

00:01:06.290 --> 00:01:09.630
at one of your clients
might formulate as a query?

00:01:09.630 --> 00:01:10.380
&gt;&gt; Yes, yes.

00:01:10.380 --> 00:01:14.124
In fact, in several of our clients
who use this service, they

00:01:14.124 --> 00:01:18.961
have existing systems where they need to
be able to get an on-demand forecast.

00:01:18.961 --> 00:01:22.006
Because they had traditionally
integrated with other systems that did

00:01:22.006 --> 00:01:23.410
on-demand forecasting.

00:01:23.410 --> 00:01:27.107
So we have to package up a service for
just that, and that service has to

00:01:27.107 --> 00:01:30.931
involve all of the same algorithms that
we use to do a batch forecast, but

00:01:30.931 --> 00:01:33.087
it's deployed slightly differently.

00:01:33.087 --> 00:01:36.210
So that's an example,
batch versus on-demand.

00:01:36.210 --> 00:01:41.086
Another example is, as I may have
alluded to previously, users,

00:01:41.086 --> 00:01:46.483
forecasters, that is, the actual
employees at one of the retail clients

00:01:46.483 --> 00:01:52.055
will often want to make adjustments or
do some what-if analysis by tweaking

00:01:52.055 --> 00:01:57.016
the inputs to our forecasting algorithms
to try to see if they can get

00:01:57.016 --> 00:02:02.353
forecasts that look more in line
with what they've seen historically.

00:02:02.353 --> 00:02:07.189
That's not used a lot, but
it is something that is needed, so

00:02:07.189 --> 00:02:12.397
the ability to do variance that
will allow for user adjustments and

00:02:12.397 --> 00:02:17.720
for tweaking of inputs is
another common class of variant.

00:02:17.720 --> 00:02:22.540
I think in this particular, I should
say, in the first application we built,

00:02:22.540 --> 00:02:25.169
the first forecast manager application,

00:02:25.169 --> 00:02:29.054
we built at least eight different
variants of the forecaster.

00:02:29.054 --> 00:02:31.005
And I may be missing a few.

00:02:31.005 --> 00:02:34.421
We may have made even some different
ones that we've used in order to test

00:02:34.421 --> 00:02:37.340
that capability and
do the accuracy assessment.

00:02:37.340 --> 00:02:39.276
So clearly you get a lot
of different variance.

00:02:39.276 --> 00:02:40.543
I mean eight's a lot.

00:02:40.543 --> 00:02:42.855
Right?
You wouldn't want to implement eight

00:02:42.855 --> 00:02:44.020
of these from scratch.

00:02:44.020 --> 00:02:45.780
You'd need to do something
to manage that variation.

00:02:46.830 --> 00:02:49.360
&gt;&gt; And
can you show us an assembly spec for

00:02:49.360 --> 00:02:51.100
one of these variance might look like?

00:02:51.100 --> 00:02:55.500
So if you look at the slide that
is being depicted now, this is

00:02:55.500 --> 00:02:58.390
the Hello World assembly spec that we
were looking at just a moment ago.

00:02:58.390 --> 00:03:02.135
And this is a new one, a variant
that I'm calling Guten Tag Welt.

00:03:02.135 --> 00:03:06.090
It's a variant of Hello World that
allows for forecast adjustment.

00:03:06.090 --> 00:03:08.799
And if you look at this assembly spec,
you'll notice a couple of things.

00:03:08.799 --> 00:03:11.318
So first, it's not exactly
the same as Hello World.

00:03:11.318 --> 00:03:16.980
It's got some new components,
a new interface, and a new refinement.

00:03:16.980 --> 00:03:20.020
In particular,
there's the mods component that

00:03:20.020 --> 00:03:23.570
implements a new interface
called overrides that represent

00:03:23.570 --> 00:03:27.740
some of the adjustment overrides that a
user of the system might want to make if

00:03:27.740 --> 00:03:32.340
they're tweaking the inputs to the
forecast in order to see the effects.

00:03:32.340 --> 00:03:35.210
There's also a new
refinement called dampener,

00:03:35.210 --> 00:03:40.100
which allows multipliers to be
dampened by these overrides.

00:03:40.100 --> 00:03:44.940
So typically in these applications, one
common adjustment scenario is to go in

00:03:44.940 --> 00:03:49.820
and allow the users to change,
by some percentage,

00:03:49.820 --> 00:03:54.810
the multipliers that our forecaster
calculated to compute uplift so

00:03:54.810 --> 00:03:57.950
that they can see its impact
on the final forecasts.

00:03:57.950 --> 00:04:02.200
And so what that dampener refinement
there is doing is it's applying

00:04:02.200 --> 00:04:05.840
those overrides by virtue of
being parameterized by that

00:04:05.840 --> 00:04:09.340
mods component to multipliers to
give us another implementation,

00:04:09.340 --> 00:04:12.330
another component that implements
the multipliers interface.

00:04:12.330 --> 00:04:16.500
And we can then use that in the same two
refinements that we saw previously in

00:04:16.500 --> 00:04:18.370
Hello World increment forecast.

00:04:18.370 --> 00:04:20.325
&gt;&gt; And the output of this
thing is the last line.

00:04:20.325 --> 00:04:21.579
&gt;&gt; That's right.

00:04:21.579 --> 00:04:23.770
&gt;&gt; You have a batch, but
it's an adjusted batch.

00:04:23.770 --> 00:04:24.290
&gt;&gt; That's right.

00:04:25.310 --> 00:04:26.440
&gt;&gt; Application that you built.

00:04:26.440 --> 00:04:27.298
&gt;&gt; Exactly.
Exactly.

00:04:27.298 --> 00:04:31.030
And it's a different component, so we
could actually put both of these in the,

00:04:31.030 --> 00:04:34.540
install both of these in our database
if we wanted to, and then we would have

00:04:34.540 --> 00:04:37.690
a batch forecaster and batch
adjusted forecaster if we so desire.

