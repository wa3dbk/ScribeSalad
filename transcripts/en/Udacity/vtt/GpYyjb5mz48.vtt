WEBVTT
Kind: captions
Language: en

00:00:00.410 --> 00:00:03.371
Measuring frames per second is a common way to talk about an application as a

00:00:03.371 --> 00:00:07.222
whole. If an application runs at 10 frames per second on one system and 20

00:00:07.222 --> 00:00:10.667
frames per second on another, we can truthfully say the second system is about

00:00:10.667 --> 00:00:15.887
twice as fast in this instance. However, graphics programmers themselves have

00:00:15.887 --> 00:00:19.609
been moving towards using the inverse of frames per second. Miliseconds the

00:00:19.609 --> 00:00:23.368
seconds per frame. There are number of good reasons for this. The most

00:00:23.368 --> 00:00:26.052
appealing one to me is that milliseconds give you a solid number for use in

00:00:26.052 --> 00:00:30.476
comparison of different algorithms. If you talk about an algorithm's

00:00:30.476 --> 00:00:33.452
implementation in terms of milliseconds per frame, you can then treat the

00:00:33.452 --> 00:00:38.194
effect on speed as a single number. This user interface is costing us five

00:00:38.194 --> 00:00:42.701
milliseconds per frame is a useful fact in its own right. This user interface

00:00:42.701 --> 00:00:46.148
slows us down by 10 frames per second. It's not all that helpful, since we

00:00:46.148 --> 00:00:49.686
don't know what the frame rate was before. Reading individual parts of the

00:00:49.686 --> 00:00:53.184
rendering process by frames per second, doesn't make a lot of sense, since it's

00:00:53.184 --> 00:00:58.760
the sum of the cost that's important. You can add millisecond costs together to

00:00:58.760 --> 00:01:02.841
see how much a frame will typically take. Games for example will often have a

00:01:02.841 --> 00:01:07.840
budget of say 33.3 milliseconds per frame, which means 30 frames per second. If

00:01:07.840 --> 00:01:10.480
different effects cost various amounts of time, it's easier to add these up and

00:01:10.480 --> 00:01:14.865
see if we're over budget. If an application aims for 60 frames per second, the

00:01:14.865 --> 00:01:19.010
budget is halved. Another reason to avoid frames per second is that they're

00:01:19.010 --> 00:01:22.508
difficult to work with mathematically. So, of course, that's what I'm going to

00:01:22.508 --> 00:01:26.182
ask you to do, to get a feel for this sort of problem. You measure your

00:01:26.182 --> 00:01:29.362
application. Say it's a walk through of a building. Here are the rates you

00:01:29.362 --> 00:01:34.751
find. 25 frames per second for 100 frames. 50 frames per second for the next

00:01:34.751 --> 00:01:39.198
100 frames. 25 frames per second for the next 100 frames. And then 10 frames

00:01:39.198 --> 00:01:44.304
per second for the last 100 frames of your benchmark. What is the average speed

00:01:44.304 --> 00:01:48.092
of the application in frames per second? I'll give you a hint, simply averaging

00:01:48.092 --> 00:01:52.159
the frames per second values is not going to work. Think about how many frames

00:01:52.159 --> 00:01:56.470
are rendered and how many seconds passed during the entire benchmark. You might

00:01:56.470 --> 00:01:59.090
want to translate this problem to thinking about miles per hour.

