WEBVTT
Kind: captions
Language: en

00:00:00.230 --> 00:00:03.770
Remember the video about pseudo-classical classing, where I pointed out

00:00:03.770 --> 00:00:07.630
that there were two different categories of code going on in the Car class.

00:00:07.630 --> 00:00:11.920
This is the exact moment where that distinction becomes extremely interesting.

00:00:11.920 --> 00:00:14.820
So far, we've made it so that the differentiation code in

00:00:14.820 --> 00:00:20.050
the subclass will call out the differentiation code available in the superclass.

00:00:20.050 --> 00:00:23.940
But due to the fact we're using prototype chains to implement an inheritance,

00:00:23.940 --> 00:00:28.370
we also need to wire up the subclass prototype to the superclass prototype,

00:00:28.370 --> 00:00:31.680
to allow the similarity code to be inherited as well.

00:00:31.680 --> 00:00:34.460
Amy does delegate Van.prototype, but

00:00:34.460 --> 00:00:39.310
neither amy nor Van.prototype have any relationship with Car.prototype yet.

00:00:39.310 --> 00:00:42.500
In order to set up that relationship, we want to make it so

00:00:42.500 --> 00:00:45.820
that Van.prototype delegates to Car.prototype.

00:00:45.820 --> 00:00:50.432
This is how we are going to make the shared methods available from Car onto Van.

00:00:50.432 --> 00:00:55.712
If we succeed, then a lookup to amy.move will fall through the amy object,

00:00:55.712 --> 00:00:58.943
and up to the van prototype, which will fail.

00:00:58.943 --> 00:01:02.100
And finally, fall all the way through to the Car prototype.

00:01:02.100 --> 00:01:05.670
Ideally, we would be able to update Van.prototype such that it

00:01:05.670 --> 00:01:09.040
would delegate it's field lookups to Car.prototype.

00:01:09.040 --> 00:01:11.709
In memory, we would expect it to work rather like this.

00:01:11.709 --> 00:01:16.019
The Van.prototype object should be made to delegate all the way up to

00:01:16.019 --> 00:01:17.887
the Car.prototype object.

00:01:17.887 --> 00:01:21.180
In this way, it would be very similar to car instances,

00:01:21.180 --> 00:01:25.970
because both would delegate field lookups to the Car prototype property.

00:01:25.970 --> 00:01:28.788
But this actually isn't allowed in the official version of the language.

00:01:28.788 --> 00:01:31.820
Instead, we're going to have to overwrite the originally provided prototype

00:01:31.820 --> 00:01:34.270
object with the brand new object that we create.

00:01:34.270 --> 00:01:37.480
So what object exactly do we want to be assigning in place of

00:01:37.480 --> 00:01:39.321
the old Van.prototype object?

00:01:39.321 --> 00:01:43.174
It might surprise you that pseudo-classical subclasses will work just fine

00:01:43.174 --> 00:01:44.841
after a reassignment like this.

00:01:44.841 --> 00:01:48.014
And that's because the instance delegation is set up

00:01:48.014 --> 00:01:50.910
only when the constructor actually runs.

00:01:50.910 --> 00:01:55.190
This prototype replacement happens right alongside the constructor definition

00:01:55.190 --> 00:01:59.240
and so that's plenty of time before we actually instantiate any objects.

00:01:59.240 --> 00:02:03.313
People often propose that Van.prototype could simply be made to

00:02:03.313 --> 00:02:04.875
equal Car.prototype.

00:02:04.875 --> 00:02:09.567
But remember, JavaScript doesn't do any copying when you assign one variable or

00:02:09.567 --> 00:02:12.100
property to be equal to another one.

00:02:12.100 --> 00:02:15.600
If that was the case, then it would be impossible to add any methods to

00:02:15.600 --> 00:02:20.300
the Car prototype that weren't also on the Van prototype and vice versa.

00:02:20.300 --> 00:02:24.170
So adding a Van.prototype.grab would have the effect of

00:02:24.170 --> 00:02:27.870
modifying Car.prototype to also have a .grab method.

00:02:27.870 --> 00:02:31.229
In short, we definitely don't want our Van.prototype to be

00:02:31.229 --> 00:02:34.890
the exact same object in memory as the Car.prototype object.

00:02:34.890 --> 00:02:40.600
So instead of making Van.prototype equal the same exact object as Car.prototype,

00:02:40.600 --> 00:02:43.770
how can we make sure that the Van prototype will delegate its

00:02:43.770 --> 00:02:46.050
field lookups to Car.prototype?

00:02:46.050 --> 00:02:47.040
Fill in the code for yourself.

