WEBVTT
Kind: captions
Language: en

00:00:00.380 --> 00:00:02.140
Alright, let's take some time now and talk about the

00:00:02.140 --> 00:00:06.240
unwind aggregation operator. In a lot of situations we're going

00:00:06.240 --> 00:00:09.680
to want to count or do some other sort of

00:00:09.680 --> 00:00:12.870
operation based on the values in an array field. We

00:00:12.870 --> 00:00:16.079
need to use array field values in some way. So,

00:00:16.079 --> 00:00:18.920
with this data We might want to answer a question like

00:00:18.920 --> 00:00:22.760
the following: In our collection, who included the most user

00:00:22.760 --> 00:00:25.430
mentions in their tweets? Now the reason why this is

00:00:25.430 --> 00:00:28.220
relevant to the unwind operator is because user

00:00:28.220 --> 00:00:31.540
mentions are included in our tweets inside an array

00:00:31.540 --> 00:00:34.310
field. Now in this data, if you remember,

00:00:34.310 --> 00:00:38.000
user mentions are found within the entity's sub-document, in

00:00:38.000 --> 00:00:41.530
particular, in the user mentions field. User mentions

00:00:41.530 --> 00:00:45.240
is an array that contains documents that represent each

00:00:45.240 --> 00:00:46.980
individual user mention. So, what I'm going to do

00:00:46.980 --> 00:00:50.490
here is pull up some examples using this query.

00:00:50.490 --> 00:00:52.580
Now, here I'm using an operator that we haven't seen

00:00:52.580 --> 00:00:56.170
before. All this says is give me back documents where

00:00:56.170 --> 00:00:59.940
the user mentions field of the entities sub-document are of

00:00:59.940 --> 00:01:04.959
length three. So, I'll pretty print this. Then, if we scroll

00:01:04.959 --> 00:01:07.530
up, we can see that this example here does in

00:01:07.530 --> 00:01:10.300
fact have three user mentions in it. And, just so

00:01:10.300 --> 00:01:13.220
you have the full picture, entities, is a top level

00:01:13.220 --> 00:01:16.520
field here. It has a sub document as a value and

00:01:16.520 --> 00:01:18.790
user mentions is one of the fields of that

00:01:18.790 --> 00:01:22.290
entities sub document. User mentions is an array value

00:01:22.290 --> 00:01:26.160
field. And, we can see that it holds documents

00:01:26.160 --> 00:01:29.770
that are shaped liked this Now, what we're interested in

00:01:29.770 --> 00:01:32.110
are these screen names here, because these are the

00:01:32.110 --> 00:01:36.720
names of users that are mentioned in this particular tweet.

00:01:36.720 --> 00:01:38.770
And for any tweet that mentions a user, you're

00:01:38.770 --> 00:01:41.710
going to have an array with documents like this inside

00:01:41.710 --> 00:01:45.400
of it, naming the users mentioned. Now, what we want

00:01:45.400 --> 00:01:48.680
to find out is a count of all the user mentions

00:01:48.680 --> 00:01:51.720
made by an individual Twitter user. So what we're going to

00:01:51.720 --> 00:01:55.240
have to do is look through all of the tweets. There'll

00:01:55.240 --> 00:01:57.460
be some grouping involved, of course, because we want to

00:01:57.460 --> 00:02:00.030
group together tweets by the same user. But we also want

00:02:00.030 --> 00:02:03.630
to count the number of user mentions. Unwind is a convenient

00:02:03.630 --> 00:02:06.770
tool for doing that to answer this particular question. Let's take

00:02:06.770 --> 00:02:11.900
a look. Okay, so here's our aggregation pipeline.

00:02:11.900 --> 00:02:15.720
Our first stage uses the unwind operator and it's

00:02:15.720 --> 00:02:18.420
being run against that user mentions field. Now

00:02:18.420 --> 00:02:21.310
remember that what unwind does, is creates a copy

00:02:21.310 --> 00:02:24.000
of the containing document for any array field.

00:02:24.000 --> 00:02:26.710
It duplicates all fields except for the items in

00:02:26.710 --> 00:02:29.620
the array. And it will create one copy for

00:02:29.620 --> 00:02:32.040
each element in the array. And the only difference

00:02:32.040 --> 00:02:35.280
between all of the copies will be that this field

00:02:35.280 --> 00:02:37.770
Will take on each of the different values in the array,

00:02:37.770 --> 00:02:39.770
in the documents that are produced. So let me, let

00:02:39.770 --> 00:02:41.730
me make this a little bit more concrete. If we take

00:02:41.730 --> 00:02:44.810
a look at this again, for this particular tweet, the

00:02:44.810 --> 00:02:50.460
unwind stage will produce three documents as output for this one

00:02:50.460 --> 00:02:53.170
tweet document here. All of the other fields that we

00:02:53.170 --> 00:02:57.210
see here, all of these, And everything else here in this

00:02:57.210 --> 00:03:02.160
tweet document will be exactly the same. The one difference will be

00:03:02.160 --> 00:03:06.710
that the user mentions field will have a single document as its

00:03:06.710 --> 00:03:10.970
value in each of those three copies of this tweet. In the

00:03:10.970 --> 00:03:16.560
first copy, it will have this as its value In the second copy,

00:03:21.540 --> 00:03:22.774
it will have this and finally the third copy, it

00:03:22.774 --> 00:03:25.560
will have this. So, in the documents that get passed along

00:03:25.560 --> 00:03:29.620
to the next stage, in this case a group stage,

00:03:29.620 --> 00:03:32.930
the documents will have a different value for the user mentions

00:03:32.930 --> 00:03:36.310
field. Now, it turns out that in our case. What

00:03:36.310 --> 00:03:39.990
we really care about is this splitting effect. Not so much

00:03:39.990 --> 00:03:43.030
with the value of user mentions is each time through.

00:03:43.030 --> 00:03:46.930
Because, what we're interested in doing in the next stage is

00:03:46.930 --> 00:03:50.060
essentially counting all of the documents that

00:03:50.060 --> 00:03:53.280
pass through to this group stage with the

00:03:53.280 --> 00:03:57.310
same screen name for the user who created

00:03:57.310 --> 00:04:00.380
the tweet. Because, again, remember. The question we're

00:04:00.380 --> 00:04:05.900
after here is, who included the most user mentions in their tweets? So by the

00:04:05.900 --> 00:04:08.300
time we get to this stage unwind will

00:04:08.300 --> 00:04:12.000
have produced an individual document for every user

00:04:12.000 --> 00:04:16.149
mention in the collection. And group then will

00:04:16.149 --> 00:04:19.269
aggregate them together based on the screen name

00:04:19.269 --> 00:04:22.240
of the user who created the tweet, will

00:04:22.240 --> 00:04:25.870
then simple produce a count field here as

00:04:25.870 --> 00:04:28.970
part of our group operation. And again remember

00:04:28.970 --> 00:04:32.810
that sum imply increments this counter each time

00:04:32.810 --> 00:04:34.850
you see the document that's aggregated together with

00:04:34.850 --> 00:04:37.320
the screen name or a document that has

00:04:37.320 --> 00:04:39.650
the same screen name. Then we do our sort

00:04:39.650 --> 00:04:43.089
and limit states. So one question I'll put to you

00:04:43.089 --> 00:04:46.620
here is does this count the number of unique

00:04:46.620 --> 00:04:49.790
user mentions? That is to say if a twitter user

00:04:49.790 --> 00:04:53.570
mentions the same user more than once does this

00:04:53.570 --> 00:04:56.300
count each one of those mentions or does it count

00:04:56.300 --> 00:05:00.350
all mentions of the same user as one mentions? If

00:05:00.350 --> 00:05:02.970
its not unique mentions that are not being counted here

00:05:02.970 --> 00:05:05.280
question I'll leave you with is what type of

00:05:05.280 --> 00:05:07.670
aggregation pipeline would we need to put together in order

00:05:07.670 --> 00:05:11.170
to count unique mentions. Of users. Okay, so let's

00:05:11.170 --> 00:05:14.860
run this. And because we limited this to one, we

00:05:14.860 --> 00:05:17.700
get one document in our result array with a

00:05:17.700 --> 00:05:21.860
count of 21 for user mentions for this user. Now

00:05:21.860 --> 00:05:23.500
in case it's not clear to you by this

00:05:23.500 --> 00:05:28.530
point, the advantage of the aggregation framework in MongoDB is

00:05:28.530 --> 00:05:31.140
that all of this work is being performed

00:05:31.140 --> 00:05:35.800
server side. That means that for this particular query

00:05:35.800 --> 00:05:37.670
all that comes across the network to our

00:05:37.670 --> 00:05:40.450
client is just that one result we just looked

00:05:40.450 --> 00:05:43.830
at. The aggregation framework is powerful, not just

00:05:43.830 --> 00:05:46.340
because of the functionality it provides, but because of

00:05:46.340 --> 00:05:49.370
the speed with which it can execute these queries

00:05:49.370 --> 00:05:52.290
because this functionality is fundamental to the server itself.

