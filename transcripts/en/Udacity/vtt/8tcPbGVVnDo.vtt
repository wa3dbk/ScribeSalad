WEBVTT
Kind: captions
Language: en

00:00:00.250 --> 00:00:04.430
An alternative, is to perform address lookups, using a

00:00:04.430 --> 00:00:07.610
data structure called a try. In a try, prefixes

00:00:07.610 --> 00:00:10.180
are spelled out by following a path from the

00:00:10.180 --> 00:00:13.140
root. And to find the best prefix, we simply spell

00:00:13.140 --> 00:00:16.760
out the address in the try. For example, let's

00:00:16.760 --> 00:00:19.270
suppose we had the following table. Such a lookup

00:00:19.270 --> 00:00:23.070
table has entries of varying lengths. Let's see how

00:00:23.070 --> 00:00:25.810
this might be encoded in a try. In a try,

00:00:25.810 --> 00:00:29.690
spelling out the bit one always takes us to the right, and spelling out the bit

00:00:29.690 --> 00:00:35.740
zero always takes us to the left. So to insert one one one star, we'd basically

00:00:35.740 --> 00:00:39.350
start here. One. One. One. And then we

00:00:39.350 --> 00:00:42.680
insert P1, and then we repeat this process.

00:00:42.680 --> 00:00:47.200
One, zero, star results in P2. One, zero,

00:00:47.200 --> 00:00:50.650
one, zero, results in P3. And one, zero,

00:00:50.650 --> 00:00:53.774
one, zero, one results in P4. If we

00:00:53.774 --> 00:00:56.827
want to insert one, one, one, zero, insertion is

00:00:56.827 --> 00:01:00.620
easy. We can simply insert P5 as such.

00:01:00.620 --> 00:01:03.659
Look ups are easy, so for example let's suppose

00:01:03.659 --> 00:01:09.030
we want to look up 10111. Well all we have to do, is spell this out in the try.

00:01:09.030 --> 00:01:15.460
So we can follow 1-0-1 and now, we see that there's no entry for 1011.

00:01:15.460 --> 00:01:22.830
So, we use the entry of the last node in the tree that we traverse, that has

00:01:22.830 --> 00:01:25.053
an entry in this case P2. Now this

00:01:25.053 --> 00:01:28.720
structure here is what's called a single bit try.

00:01:28.720 --> 00:01:31.350
Single bit trys are very efficient. Not that

00:01:31.350 --> 00:01:34.370
every note in this try exists due to one

00:01:34.370 --> 00:01:37.270
of the five folding table entries that we've

00:01:37.270 --> 00:01:40.670
inserted in the try. So, a single bit try

00:01:40.670 --> 00:01:43.410
is a very efficient use of memory. Updates are

00:01:43.410 --> 00:01:46.090
also very simple. We saw how easy it was,

00:01:46.090 --> 00:01:49.960
to insert the entry for P5. And fortunately, the

00:01:49.960 --> 00:01:53.860
main problem is the number of memory accesses that

00:01:53.860 --> 00:01:56.470
are required to perform a lookup. For 32 bit

00:01:56.470 --> 00:01:59.970
address, we can see, that looking up the address

00:01:59.970 --> 00:02:03.260
in a single bit trie, might require 32 look

00:02:03.260 --> 00:02:06.130
ups, in the worst case. One for each bit.

00:02:06.130 --> 00:02:10.880
So it's each bit in the address requires, one traversal in the trie, or one

00:02:10.880 --> 00:02:15.320
memory look up. So this could be very bad. At worst, 32 accesses in the

00:02:15.320 --> 00:02:17.790
worst case. To put this in perspective,

00:02:17.790 --> 00:02:23.180
an OC48 requires a 160 nanosecond lookup, or

00:02:23.180 --> 00:02:27.550
simply 4 memory accesses. So 32 accesses, is

00:02:27.550 --> 00:02:30.140
far too many, especially for high speed links.

