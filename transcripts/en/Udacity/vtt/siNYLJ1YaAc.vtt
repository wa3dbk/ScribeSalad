WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Manuel had a question.

00:00:03.000 --> 00:00:09.000
"I always though recursive calls were more efficient that iterative functions.

00:00:09.000 --> 00:00:15.000
Professor Evans said that recursive definition isn't very efficient in Python.

00:00:15.000 --> 00:00:20.000
So I want to ask if other programming languages like C or Java

00:00:20.000 --> 00:00:26.000
improve the recursive calls in order to always be more efficient that the iterative method."

00:00:26.000 --> 00:00:29.000
Thanks for the question, Manuel.

00:00:29.000 --> 00:00:34.000
The problem with recursion in terms of performance is that when you execute

00:00:34.000 --> 00:00:39.000
a procedure that does a recursive call you've got to keep track of the state of that call.

00:00:39.000 --> 00:00:43.000
That's called a stack frame. You're keeping track of the function you called.

00:00:43.000 --> 00:00:45.000
You're keeping track of where to return when you're done,

00:00:45.000 --> 00:00:50.000
and you're making a new space to store the parameters that you passed in to that procedure.

00:00:50.000 --> 00:00:53.000
If you have a recursive call, each time you're doing the recursive call

00:00:53.000 --> 00:00:56.000
you need a new stack frame to keep track of that.

00:00:56.000 --> 00:00:59.000
When you finally get to the base case, then you're got a result,

00:00:59.000 --> 00:01:01.000
and you've got to unwind all that.

00:01:01.000 --> 00:01:04.000
You're going back through all those stack frames, passing back the results,

00:01:04.000 --> 00:01:07.000
reclaiming that space. That take a lot of space.

00:01:07.000 --> 00:01:11.000
If there are a lot of recursive calls like some of the examples you've seen in 101,

00:01:11.000 --> 00:01:15.000
you're going to run out of space when you do that on a high input.

00:01:15.000 --> 00:01:20.000
For some languages there's an optimization that the interpreter or the compiler does

00:01:20.000 --> 00:01:24.000
to know that if the only thing that you do with the results of the recursive call

00:01:24.000 --> 00:01:29.000
is pass it back to the next level, you don't really need to keep track of all those stacks.

00:01:29.000 --> 00:01:32.000
You can keep reusing the one you had, just replacing the parameters,

00:01:32.000 --> 00:01:35.000
and know that when you're done that's the actual result.

00:01:35.000 --> 00:01:38.000
Or maybe you do a more complex optimization where there's something you need

00:01:38.000 --> 00:01:42.000
to do on the result, but you don't need to keep track of all those stack frames.

00:01:42.000 --> 00:01:48.000
This is what most languages that are designed to use recursion frequently do.

00:01:48.000 --> 00:01:51.000
Languages like Lisp and Scheme are designed this way--

00:01:51.000 --> 00:01:53.000
to make it very efficient to do recursive calls.

00:01:53.000 --> 00:01:57.000
It's still more expensive than iteration, because you still need to do the call.

00:01:57.000 --> 00:02:02.000
You need to do the mechanics of calling a procedure and getting a result,

00:02:02.000 --> 00:02:04.000
but with this tail recursion optimization,

00:02:04.000 --> 00:02:07.000
you don't need to keep track of all those stack frames.

00:02:07.000 --> 00:02:09.000
It's much more efficient than it is in Python.

00:02:09.000 --> 00:02:13.000
There have been a lot of questions about why am I covering recursive procedures

00:02:13.000 --> 00:02:15.000
if they're so inefficient in Python.

00:02:15.000 --> 00:02:18.000
The reason for doing that is really it's a very useful way of thinking,

00:02:18.000 --> 00:02:23.000
even if you need to eventually turn the procedure into an iterative version of it.

00:02:23.000 --> 00:02:27.000
By writing the recursive version and understanding how they recursive definition works

00:02:27.000 --> 00:02:31.000
and understanding things that way, you're thinking in a new and powerful way.

00:02:31.000 --> 00:02:36.000
Recursive procedures are often easier to reason about than iterative ones.

00:02:36.000 --> 00:02:39.000
And if you use a language that does provide tail recursion elimination,

00:02:39.000 --> 00:02:43.000
then the recursive definition is often the one that you want to use.

00:02:43.000 --> 00:02:45.000
In Python that's usually not the case.

00:02:45.000 --> 00:02:47.000
It's better to write a procedure not to have a recursive call,

00:02:47.000 --> 00:02:50.000
because you're going to run out of stack space if you ever call it on a large input.

