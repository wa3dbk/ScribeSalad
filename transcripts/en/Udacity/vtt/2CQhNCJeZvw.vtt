WEBVTT
Kind: captions
Language: en

00:00:00.490 --> 00:00:07.520
Having given you the abstractions and PTS, and the simplicity of the programming

00:00:07.520 --> 00:00:13.600
model. I will now introduce you to the heavy lifting that needs to happen

00:00:13.600 --> 00:00:15.950
under the covers in order to support

00:00:15.950 --> 00:00:18.980
this simple programming model from the point

00:00:18.980 --> 00:00:21.970
of view of the domain expert developing

00:00:21.970 --> 00:00:26.820
a situation awareness application. All the computations

00:00:26.820 --> 00:00:30.310
in the application can be considered as

00:00:30.310 --> 00:00:33.400
either producers or consumers of data. Producers

00:00:33.400 --> 00:00:36.210
of data, are putting things into the

00:00:36.210 --> 00:00:39.660
system and consumers of data are getting stuff

00:00:39.660 --> 00:00:45.910
from the system. And under the covers there are worker threads in the run-time

00:00:45.910 --> 00:00:49.400
system of PTS that react to these

00:00:49.400 --> 00:00:52.890
get calls coming from the producers and consumers.

00:00:52.890 --> 00:00:58.580
For instance, whenever, a producer puts an item, that results in

00:00:58.580 --> 00:01:04.180
new item triggers. That are going to be generated by the worker threads to the

00:01:04.180 --> 00:01:07.630
rest of the implementation. Implementation of

00:01:07.630 --> 00:01:10.740
the channel architecture is a three

00:01:10.740 --> 00:01:19.290
layer architecture. The top layer is the live channel layer of the architecture.

00:01:19.290 --> 00:01:22.700
And this is the layer that reacts to

00:01:22.700 --> 00:01:25.960
the new item triggers coming from these worker

00:01:25.960 --> 00:01:31.450
threads, working on behalf of a put call that is coming from a producer. So the

00:01:31.450 --> 00:01:35.280
channel abstractions result in these new item triggers

00:01:35.280 --> 00:01:38.220
to be sent to the live channel layer.

00:01:38.220 --> 00:01:41.040
Of the channel architecture. And the live channel

00:01:41.040 --> 00:01:44.960
layer, is the one that is holding a snapshot

00:01:44.960 --> 00:01:47.930
of items that have been generated on

00:01:47.930 --> 00:01:51.800
a particular channel. Starting from the oldest item

00:01:51.800 --> 00:01:56.120
in the channel to the newest item that just came in because of this new item

00:01:56.120 --> 00:02:03.140
trigger At the time of creation of a channel, the creator of a channel could

00:02:03.140 --> 00:02:07.270
specify what the semantics of the data that

00:02:07.270 --> 00:02:11.100
are kept in this channel are. In particular,

00:02:11.100 --> 00:02:16.510
a creator of a channel could say that, what I want the channel to contain are

00:02:16.510 --> 00:02:21.570
live data corresponding to a certain snapshot of

00:02:21.570 --> 00:02:24.820
real time. From oldest to new. For instance,

00:02:24.820 --> 00:02:31.220
I could say keep only the last 30 seconds of data in the channel. Rest of

00:02:31.220 --> 00:02:36.230
it, you can throw it away. So there is a garbage collection trigger that is part

00:02:36.230 --> 00:02:38.400
of the run time system, that is looking

00:02:38.400 --> 00:02:42.320
at information that is in the channel, that says.

00:02:42.320 --> 00:02:45.720
What items in the channel have become old

00:02:45.720 --> 00:02:48.110
and therefore can be thrown away. Those are the

00:02:48.110 --> 00:02:51.540
Gc triggers. And the Gc triggers will move

00:02:51.540 --> 00:02:54.440
data that have become ancient, so far as this

00:02:54.440 --> 00:02:56.930
channel is concerned, and move it into this

00:02:56.930 --> 00:03:01.320
garbage list. Meaning that these items are no longer

00:03:01.320 --> 00:03:03.100
relevant from the point of view of this

00:03:03.100 --> 00:03:07.100
application. And therefore they can be garbage collected.

00:03:07.100 --> 00:03:10.170
So they're put into this garbage list. And

00:03:10.170 --> 00:03:14.000
there is another garbage collection thread that is responsible

00:03:14.000 --> 00:03:17.080
for periodically cleaning up all the garbage that

00:03:17.080 --> 00:03:19.700
has been created and throwing away stuff that

00:03:19.700 --> 00:03:23.160
is no longer relevant. For this computation. So

00:03:23.160 --> 00:03:26.120
this is all the channel book keeping that's happening,

00:03:26.120 --> 00:03:31.820
under the covers in support of an application that is using the PTS library.

00:03:31.820 --> 00:03:39.380
But there's a lot more to it than just dealing with live data and data that

00:03:39.380 --> 00:03:43.646
is no longer relevant that has to be garbage collected or thrown away. As I

00:03:43.646 --> 00:03:47.480
mentioned one of the features of the

00:03:47.480 --> 00:03:51.430
PTS architecture is the fact that an application

00:03:51.430 --> 00:03:56.410
can choose to keep data for as long as they wants, and that is the

00:03:56.410 --> 00:04:01.140
persistence property supported by PTS run time system.

00:04:01.140 --> 00:04:04.810
So once again properties of the channel An

00:04:04.810 --> 00:04:09.090
application programmer could specify that, I don't

00:04:09.090 --> 00:04:12.540
want to throw away stuff that becomes old

00:04:12.540 --> 00:04:17.089
to keep in the channel, but I want to archive them, I want to persist them.

00:04:17.089 --> 00:04:19.230
And if those properties have been associated

00:04:19.230 --> 00:04:23.280
with the channel, then when items go past

00:04:23.280 --> 00:04:25.440
the window that has to be stored in

00:04:25.440 --> 00:04:28.060
the Live Channel Layer. The Live Channel Layer

00:04:28.060 --> 00:04:31.090
results in generating what are called persistent

00:04:31.090 --> 00:04:34.950
triggers to indicate that some items have become

00:04:34.950 --> 00:04:37.250
old in this channel, and they have to

00:04:37.250 --> 00:04:42.610
be persisted. The second main functional layer in

00:04:42.610 --> 00:04:45.490
the channel architecture is the Persistence layer.

00:04:45.490 --> 00:04:48.230
The Interaction layer is just a go between

00:04:48.230 --> 00:04:50.650
the Live Channel layer and the Persistence

00:04:50.650 --> 00:04:53.350
layer of the channel architecture. And what the

00:04:53.350 --> 00:04:57.850
Persistence layer does is, based on the

00:04:57.850 --> 00:05:00.260
persistence triggers that it gets from the live

00:05:00.260 --> 00:05:04.450
channel layer. It is going to take items from

00:05:04.450 --> 00:05:08.270
the channel and decide how to persist them.

00:05:08.270 --> 00:05:13.890
Now, here again, the application can have a say in how items need to

00:05:13.890 --> 00:05:17.040
be persisted. And they do that by

00:05:17.040 --> 00:05:21.300
having a Pickling Handler. That is, the application

00:05:21.300 --> 00:05:27.580
can specify Here is a function that I want you to use every time you decide

00:05:27.580 --> 00:05:33.940
to persist some item from the channel. For example, an application may specify

00:05:33.940 --> 00:05:40.200
that don't store all the images as is on archive or storage,

00:05:40.200 --> 00:05:45.360
but Condense them in such and so fashion. And that is a function that it can

00:05:45.360 --> 00:05:48.420
supply. And the runtime system, when it

00:05:48.420 --> 00:05:52.525
works on persistence, will automatically apply the

00:05:52.525 --> 00:05:57.030
application-specified function on the items that need

00:05:57.030 --> 00:05:59.860
to be persisted to create a digest.

00:05:59.860 --> 00:06:04.560
Which will then be persistent. Items that need to be persistent necessarily have

00:06:04.560 --> 00:06:08.470
to go to non-volatile storage devices, and

00:06:08.470 --> 00:06:12.250
here again, the PTS architecture supports several

00:06:12.250 --> 00:06:16.330
different configured Backends to store items that

00:06:16.330 --> 00:06:18.623
need to be persistent. And the Backend

00:06:18.623 --> 00:06:20.398
layer is the third layer in the

00:06:20.398 --> 00:06:25.205
channel architecture. And PTS supports several different

00:06:25.205 --> 00:06:29.080
Backends to support the persistence activities and

00:06:29.080 --> 00:06:31.130
it is an application choice as to

00:06:31.130 --> 00:06:36.860
which back end layer it wants to use for its specific application. The Backend

00:06:36.860 --> 00:06:43.130
layers supported by PTS include mySQL, it can use Unix file system as a

00:06:43.130 --> 00:06:50.440
persistence layer, or it can use a file system from IBM called GPFS. So mySQL,

00:06:50.440 --> 00:06:56.520
Unix file system, and GPFS are the three different Backends that are available.

00:06:56.520 --> 00:07:02.130
For the persistence layer to store channel data that needs to be archived for

00:07:02.130 --> 00:07:08.130
later retrieval. The nice property is that all of the persistence activities

00:07:08.130 --> 00:07:15.780
happen unbeknownst to the user. All that the user has done is in the creation of

00:07:15.780 --> 00:07:19.850
a channel. Specified certain properties to associate

00:07:19.850 --> 00:07:23.300
with that channel. For example, the property that

00:07:23.300 --> 00:07:29.590
may have been associated with a channel is that any items beyond the last 30

00:07:29.590 --> 00:07:32.410
seconds persistent on the storage, and when

00:07:32.410 --> 00:07:35.450
you persist them on the storage, apply this

00:07:35.450 --> 00:07:38.640
function. Those are the things being specified

00:07:38.640 --> 00:07:41.670
by the user creation time of the channel,

00:07:41.670 --> 00:07:47.070
once that is done the heavy lifting that needs to be done during down time,

00:07:47.070 --> 00:07:49.950
is all handled under the covers, by

00:07:49.950 --> 00:07:53.280
the run time system. Of the channel architecture

00:07:53.280 --> 00:07:57.020
that takes items from the channel, pickles

00:07:57.020 --> 00:08:00.310
them using the function that has been specified,

00:08:00.310 --> 00:08:03.920
and uses one of the configured Backends to

00:08:03.920 --> 00:08:07.950
push those pickled items onto the persistent storage.

00:08:07.950 --> 00:08:15.210
On the other side, when. An application wants to get an item. That item range

00:08:15.210 --> 00:08:21.120
may span from something that is there in the live channel part of the three

00:08:21.120 --> 00:08:27.700
layer architecture, or it could be on the archival storage. Now it is up to the

00:08:27.700 --> 00:08:33.150
run time system to retrieve all the items between the lower bond. And the upper

00:08:33.150 --> 00:08:39.909
bound specified by get primitive. So get primitive that spans both live and

00:08:39.909 --> 00:08:43.558
archived items results in get triggers being

00:08:43.558 --> 00:08:45.930
passed from the light channel through the

00:08:45.930 --> 00:08:51.680
interaction layer to the Backend so that corresponding to the get interval that

00:08:51.680 --> 00:08:58.330
is specified. The Backend layer can pull the data from the archive storage and

00:08:58.330 --> 00:09:00.650
pass it up so that it finally gets

00:09:00.650 --> 00:09:03.800
to the application. What I wanted to illustrate through

00:09:03.800 --> 00:09:06.800
this picture is there is a lot of heavy

00:09:06.800 --> 00:09:10.120
lifting that needs to happen in order to support

00:09:10.120 --> 00:09:12.770
a simple programming model. The programming model is very

00:09:12.770 --> 00:09:17.480
simple But, in order to support the simplicity, all

00:09:17.480 --> 00:09:19.980
of the heavy lifting has to be absorbed under

00:09:19.980 --> 00:09:23.760
the covers in the run time system of the

00:09:23.760 --> 00:09:25.410
PTS programing model.

