WEBVTT
Kind: captions
Language: en

00:00:00.270 --> 00:00:04.324
The traveling salesman problem falls
into a special class of problems called

00:00:04.325 --> 00:00:05.514
NP-Hard.

00:00:05.514 --> 00:00:09.870
NP-Hard problems don't have a known
algorithm that can solve them

00:00:09.870 --> 00:00:11.753
in polynomial time.

00:00:11.753 --> 00:00:16.520
As I mentioned during the discussion of
the Knapsack Problem, polynomial time

00:00:16.520 --> 00:00:22.450
algorithms have a run time where n has
a constant exponent like n squared and

00:00:22.450 --> 00:00:26.570
we want algorithms that can solve
problems in polynomial time or

00:00:26.570 --> 00:00:29.250
they're often too slow to be useful.

00:00:29.250 --> 00:00:32.506
The Knapsack problem is actually
also an NP-Hard problem.

00:00:33.580 --> 00:00:37.769
The solution we looked at was
in Pseudo-Polynomial time and

00:00:37.770 --> 00:00:40.600
no true polynomial
time solution is known.

00:00:41.360 --> 00:00:42.700
Since the problem is so

00:00:42.700 --> 00:00:46.369
difficult, there are two classes of
algorithms considered solutions.

00:00:47.430 --> 00:00:52.500
The first are exact algorithms, which
don't happen in polynomial time but

00:00:52.500 --> 00:00:53.370
will get us the correct answer.

00:00:54.648 --> 00:00:59.440
The second are Approximation Algorithms,
which don't always find the exact

00:00:59.440 --> 00:01:04.709
optimal solution but
generally find a near optimal solution.

00:01:04.709 --> 00:01:07.420
They tend to run in a more
reasonable amount of time, and

00:01:07.420 --> 00:01:09.300
several are even polynomial time.

00:01:10.400 --> 00:01:15.690
The Brute Force solution to TSP has the
same philosophy as the one for Knapsack.

00:01:16.800 --> 00:01:21.490
Find every possible combination and
pick the best one, but

00:01:21.490 --> 00:01:23.929
it takes significantly longer.

00:01:23.930 --> 00:01:29.480
It's in factorial time, so n multiplied
by every integer between it and one.

00:01:30.830 --> 00:01:33.850
There are also dynamic
programming solutions for TSP.

00:01:35.120 --> 00:01:38.660
The most famous one is
the Held-Karp Algorithm.

00:01:38.660 --> 00:01:42.300
However, even the dynamic
programming solutions are slow.

00:01:42.300 --> 00:01:45.800
The runtime for this particular
solution is an exponential time.

00:01:47.180 --> 00:01:52.300
Even though the approximation algorithms
don't find the exact optimal path,

00:01:52.300 --> 00:01:54.720
there is a lot of active
research into them for TSP.

00:01:55.810 --> 00:02:00.740
One of the most famous, called
Christofides algorithm, works by turning

00:02:00.740 --> 00:02:05.770
a graph into a tree, where the starting
note is the root creating and

00:02:05.770 --> 00:02:09.448
traversing through it in
a particularly intelligent way.

00:02:09.449 --> 00:02:12.530
The algorithm guarantees
that the path it produces

00:02:12.530 --> 00:02:15.809
will be at most 50% longer
than the shortest route.

00:02:17.400 --> 00:02:22.600
There have been some slight improvements
on this first specific cases of TSP but

00:02:22.600 --> 00:02:24.530
generally it's considered
to be the best there is.

00:02:25.530 --> 00:02:30.380
TSP is an interesting case study for
this type of difficult problem,

00:02:30.380 --> 00:02:34.725
particularly, since it has so many
applications and is so widely studied.

00:02:34.725 --> 00:02:39.200
While you likely won't get asked
about it directly in an interview,

00:02:39.200 --> 00:02:42.700
it's good to know that
problems like this exist and

00:02:42.700 --> 00:02:45.880
that it is possible to get an interview
problem with no efficient solution.

00:02:47.600 --> 00:02:51.700
You don't need to worry too much
about the exact meaning of NP-Hard or

00:02:51.700 --> 00:02:54.400
similar classes, but
it's good to remember that

00:02:54.400 --> 00:02:57.900
even the brightest minds can't
solve every problem efficiently.

