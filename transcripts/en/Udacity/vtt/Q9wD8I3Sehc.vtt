WEBVTT
Kind: captions
Language: en

00:00:00.120 --> 00:00:04.210
So what do we have to have in our cache
in order to support a miss-under-miss

00:00:04.210 --> 00:00:05.100
operation?

00:00:05.100 --> 00:00:08.180
Before the cache would simply
block when it has a miss and

00:00:08.180 --> 00:00:10.600
not do anything until the miss comes.

00:00:10.600 --> 00:00:12.970
So it doesn't really need
much support for that.

00:00:12.970 --> 00:00:17.750
With miss-under-miss we have a miss but
accesses keep coming to the cache.

00:00:17.750 --> 00:00:21.520
If there hits, we handle them normally
by just finding those blocks and

00:00:21.520 --> 00:00:23.090
returning to the processor.

00:00:23.090 --> 00:00:26.120
If there are misses, we have to do more.

00:00:26.120 --> 00:00:31.810
Now we need to have the so called
Miss Status Handling Registers or MSHRs.

00:00:31.810 --> 00:00:35.730
What they do is they remember
what we requested from memory.

00:00:35.730 --> 00:00:38.910
So they keep information about
the misses that we currently have in

00:00:38.910 --> 00:00:39.770
progress.

00:00:39.770 --> 00:00:45.390
When we have a miss, we have to check
the MSHRs to see if there is any match.

00:00:45.390 --> 00:00:49.000
Basically if we have a miss, we want to
know whether it's a new miss or

00:00:49.000 --> 00:00:52.120
something that we didn't find in
the cache but it has already been

00:00:52.120 --> 00:00:56.170
ordered from memory because of
a previous access that was a miss.

00:00:56.170 --> 00:01:00.170
So if it's not a match, that means
it's a miss to a different block.

00:01:00.170 --> 00:01:03.840
In that case, we allocate a new MSHR.

00:01:03.840 --> 00:01:08.020
In the MSHR, we remember which
instruction in the processor to wake up

00:01:08.020 --> 00:01:09.800
when the data comes back.

00:01:09.800 --> 00:01:11.030
And that's it.

00:01:11.030 --> 00:01:16.760
If there is a match, that means that
we try to find data from a block and

00:01:16.760 --> 00:01:20.830
that block had a previous miss that
was already sent to memory but

00:01:20.830 --> 00:01:22.110
didn't come back yet.

00:01:22.110 --> 00:01:25.390
So really, if we did things one at
a time this would not be a miss.

00:01:25.390 --> 00:01:31.130
So we call this a miss and this is
sometimes called half-miss, because

00:01:31.130 --> 00:01:35.820
this is a true miss, that we would have,
even if we did blocking caches.

00:01:35.820 --> 00:01:40.700
This is a miss that would be a hit if
we did blocking, but because we allowed

00:01:40.700 --> 00:01:45.250
the processor to check the cache,
before the previous misses came back,

00:01:45.250 --> 00:01:49.990
some of the new accesses are now not
finding the data in the cache but

00:01:49.990 --> 00:01:53.790
the data is already on the way
back to the processor.

00:01:53.790 --> 00:01:56.390
Now because the request for

00:01:56.390 --> 00:02:00.340
this block has already been sent to
memory, we shouldn't send it again.

00:02:00.340 --> 00:02:06.480
Instead, we simply add that
instruction to the MSHR and that's it.

00:02:06.480 --> 00:02:09.360
When the data finally
comes back from memory,

00:02:09.360 --> 00:02:12.950
we find the MSHR that
corresponds to that request, and

00:02:12.950 --> 00:02:16.770
we wake up all the instructions
that were added to this MSHR.

00:02:17.860 --> 00:02:22.640
The first one, and all of the subsequent
ones that also wanted the data.

00:02:22.640 --> 00:02:24.430
Keep in mind that the miss and

00:02:24.430 --> 00:02:28.690
the half-miss to the same block, need
not necessarily be to the same word.

00:02:28.690 --> 00:02:32.960
Actually it's quite common that, for
example, you access the first word and

00:02:32.960 --> 00:02:35.760
then very soon you access
the second word in a block.

00:02:35.760 --> 00:02:39.600
The first word had a miss,
the second word will have a half-miss.

00:02:39.600 --> 00:02:44.340
And after waking up the instructions,
we release the MSHR so

00:02:44.340 --> 00:02:46.440
it can be used by another miss.

00:02:46.440 --> 00:02:50.450
So how many MSHRs do we want to have?

00:02:50.450 --> 00:02:53.620
It turns out there is a huge
benefit even if you only have two,

00:02:53.620 --> 00:02:58.535
so it can handle two different
blocks in progress at the same time.

00:02:58.535 --> 00:03:00.740
Four is even better, and

00:03:00.740 --> 00:03:05.240
there are benefits to be gained even
if you have 16 or even 32 MSHRs.

00:03:06.290 --> 00:03:09.740
So we want to have a few
tens of MSHRs if we can.

00:03:10.740 --> 00:03:14.420
This is because memory
latencies are relatively long.

00:03:14.420 --> 00:03:18.310
So if we can keep sending requests
to memory during that time,

00:03:18.310 --> 00:03:22.700
we can be achieving the memory
level parallelism of 16 or even 32.

00:03:22.700 --> 00:03:25.290
Cutting down dramatically

00:03:25.290 --> 00:03:28.990
on what the overall performance
penalty of cache misses ends up being.

