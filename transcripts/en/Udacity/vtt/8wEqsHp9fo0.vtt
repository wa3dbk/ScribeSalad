WEBVTT
Kind: captions
Language: en

00:00:00.360 --> 00:00:02.870
Now let's see what is involved in making the

00:00:02.870 --> 00:00:06.190
actual calls between the client and the server. And you

00:00:06.190 --> 00:00:09.440
will see that all the kernel copying overheads are

00:00:09.440 --> 00:00:13.510
eliminated in the actual calls. What the client stub does

00:00:13.510 --> 00:00:15.510
on the client side is when the client makes

00:00:15.510 --> 00:00:18.260
the call is that through, the clients tab is going to

00:00:18.260 --> 00:00:21.810
take the arguments and put those arguments into the a

00:00:21.810 --> 00:00:25.420
stack, ignore this result for a minute, so that the

00:00:25.420 --> 00:00:27.580
stub is going to, the client stub is going to prepare the

00:00:27.580 --> 00:00:31.420
a stack, with the arguments of the call, and then in

00:00:31.420 --> 00:00:35.710
the a stack, you can only pass arguments by value,

00:00:35.710 --> 00:00:39.350
not by reference. And the reason is that this A stack,

00:00:39.350 --> 00:00:42.520
I mentioned to you is mapped into the client address

00:00:42.520 --> 00:00:45.160
space and shortly, it's going to be mapped into the, it is,

00:00:45.160 --> 00:00:47.040
it is mapped into the server address space as well

00:00:47.040 --> 00:00:50.740
by the, by the kernel and since only the A stack

00:00:50.740 --> 00:00:52.700
is mapped into the address space of both the

00:00:52.700 --> 00:00:56.520
client and the server. If this has pointers pointing to

00:00:56.520 --> 00:00:59.710
the other parts of the client address space, so it

00:00:59.710 --> 00:01:01.860
is not going to be a, able to access that. So,

00:01:01.860 --> 00:01:05.200
it is important that the arguments are passed by value

00:01:05.200 --> 00:01:08.970
and not by by reference. And the work done by

00:01:08.970 --> 00:01:12.540
the stub in, in preparing the array stack is much

00:01:12.540 --> 00:01:16.040
simpler than what I told you earlier about. The general

00:01:16.040 --> 00:01:19.610
RPC mechanism of creating an RPC packet. Where

00:01:19.610 --> 00:01:22.350
it has to serialize the data structures that

00:01:22.350 --> 00:01:24.700
are being passed as arguments. In this case,

00:01:24.700 --> 00:01:29.190
it is simply copying the arguments from the

00:01:29.190 --> 00:01:35.070
stack of the client thread into this A stack. That's what is being done by this

00:01:35.070 --> 00:01:38.780
stub. Then the client traps into the kernel,

00:01:38.780 --> 00:01:41.060
making a procedure called s.foo that is also

00:01:41.060 --> 00:01:46.330
in the trap. And, at this point, the the client's stop is presenting through the

00:01:46.330 --> 00:01:50.320
kernel the binding object associated with s.foo.

00:01:50.320 --> 00:01:52.300
So the binding object, I told you, is

00:01:52.300 --> 00:01:55.780
the capability that this client is authorized

00:01:55.780 --> 00:01:59.710
to make calls on s.foo. So once the

00:01:59.710 --> 00:02:02.380
BO is validated by the kernel, it

00:02:02.380 --> 00:02:06.640
can then see what the procedure descriptor associated

00:02:06.640 --> 00:02:09.530
with the BO is. And this procedure descriptor

00:02:09.530 --> 00:02:11.750
is, as I told you, the information that

00:02:11.750 --> 00:02:14.590
is needed by the kernel in order to

00:02:14.590 --> 00:02:17.500
pass the control to the server, to start executing

00:02:17.500 --> 00:02:22.120
the server procedure corresponding to this particular RPC

00:02:22.120 --> 00:02:25.520
call being made by the client. Now recall that

00:02:25.520 --> 00:02:27.970
the semantics of RPC is that the client,

00:02:27.970 --> 00:02:31.500
once it makes this RPC call, it's basically blocked.

00:02:31.500 --> 00:02:33.970
It's waiting for the call to be complete

00:02:33.970 --> 00:02:37.200
before it gets started resuming its execution. Therefore the

00:02:37.200 --> 00:02:41.490
optimization, what the kernel could do is. Borrow

00:02:41.490 --> 00:02:43.620
because all of this is happening on the same

00:02:43.620 --> 00:02:47.950
machine the kernel can borrow the client thread

00:02:47.950 --> 00:02:51.700
and doctor the client thread to run on the

00:02:51.700 --> 00:02:53.580
server address place. Now what do I mean

00:02:53.580 --> 00:02:56.920
by doctoring the client thread? What I mean is.

00:02:56.920 --> 00:02:59.460
Basically what you want to do is you want

00:02:59.460 --> 00:03:02.940
to make sure that the client's thread starts executing

00:03:02.940 --> 00:03:05.950
in the address space of the server, and the

00:03:05.950 --> 00:03:09.370
PC that the client thread is going to start executing

00:03:09.370 --> 00:03:12.580
in is the entry point procedure that is pointed

00:03:12.580 --> 00:03:15.410
to by the procedure descriptor. So you have the fix

00:03:15.410 --> 00:03:18.760
of the PC. The address space descriptor, and the

00:03:18.760 --> 00:03:21.990
stack that is being used by the server in order

00:03:21.990 --> 00:03:25.870
to execute this entry-point procedure. And for this purpose, what

00:03:25.870 --> 00:03:29.180
the kernel does is it allocates a special stack, which

00:03:29.180 --> 00:03:31.490
is called the execution stack, I'm not showing you this

00:03:31.490 --> 00:03:34.990
picture. An execution stack, or E-Stack, and that is a

00:03:34.990 --> 00:03:38.634
stack that the server procedure is going to use. In

00:03:38.634 --> 00:03:41.548
order to do its own thing, because server procedure may

00:03:41.548 --> 00:03:44.090
be making it's own procedure calls and so on, so

00:03:44.090 --> 00:03:46.947
it's going to do all of that action on the E-stack.

00:03:46.947 --> 00:03:51.570
So the A-stack is only for the purpose of passing the arguments, and the E-stack

00:03:51.570 --> 00:03:55.650
is what the server is going to use in order to make, do its own work.

