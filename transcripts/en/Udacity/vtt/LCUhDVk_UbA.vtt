WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.000
So the answer is we need 63 bits to ensure this probability is less than one-half.

00:00:06.000 --> 00:00:10.000
And the way to think about this is assuming the uniform distribution

00:00:10.000 --> 00:00:16.000
of our ideal hash function, every time the probability that one guess maps to H

00:00:16.000 --> 00:00:21.000
is 1 over the number of bits, or 2 to the negative b.

00:00:21.000 --> 00:00:24.000
We'll use b to represent the number of bits.

00:00:24.000 --> 00:00:27.000
So with our random oracle model, for any given guess the probability

00:00:27.000 --> 00:00:31.000
that it hashes to a particular value is 2 to the negative b.

00:00:31.000 --> 00:00:36.000
The probability a guess is bad is 1 minus that.

00:00:36.000 --> 00:00:39.000
And now over a series of guess, the probability that they're all bad

00:00:39.000 --> 00:00:43.000
is that raised to the number of guesses power.

00:00:43.000 --> 00:00:48.000
And we've said that k is equal to the number of guesses here,

00:00:48.000 --> 00:00:55.000
which we said was 2 to the 62, and we can solve 1 minus 2 to the negative 62

00:00:55.000 --> 00:00:58.000
to the 2 to the 62.

00:00:58.000 --> 00:01:02.000
That's equal to approximately 0.63.

00:01:02.000 --> 00:01:04.000
There are lots of ways to solve this.

00:01:04.000 --> 00:01:06.000
You could try computing this in Python.

00:01:06.000 --> 00:01:08.000
These numbers get pretty big.

00:01:08.000 --> 00:01:10.000
The easiest way to solve this is to just plug this into Wolfram-Alpha.

00:01:10.000 --> 00:01:12.000
There are also, certainly, mathematical things you could do

00:01:12.000 --> 00:01:15.000
to get this equation in a simpler form,

00:01:15.000 --> 00:01:18.000
but since we just want the answer, it's easier to just try plugging in some numbers.

00:01:18.000 --> 00:01:21.000
If we increase the number of bits by 1,

00:01:21.000 --> 00:01:25.000
that means the probability for each guess being bad increases to 1 minus 2 to the negative 63,

00:01:25.000 --> 00:01:28.000
and that turns out to be 0.39.

00:01:28.000 --> 00:01:32.000
That means 63 is the fewest number of bits to provide

00:01:32.000 --> 00:01:36.000
the attacker with less than a 50% chance of finding a pre-image

00:01:36.000 --> 00:01:38.000
that maps to the same hash value

00:01:38.000 --> 99:59:59.000
in 2 to the 62 guesses.

