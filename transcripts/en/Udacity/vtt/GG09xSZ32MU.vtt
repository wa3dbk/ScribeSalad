WEBVTT
Kind: captions
Language: en

00:00:00.620 --> 00:00:04.080
We said we need to ROB in order to have precise exceptions, and

00:00:04.080 --> 00:00:07.570
also to be able to easily recover from Branch mispredictions. So

00:00:07.570 --> 00:00:13.300
let's see how that happens. Suppose we have a program that reaches a branch, and

00:00:13.300 --> 00:00:16.670
suppose that our prediction was that the program will continue here and

00:00:16.670 --> 00:00:21.580
fetch these three instructions. Although in fact the program branches. So,

00:00:21.580 --> 00:00:25.940
this three instructions will be executed in our branch misprediction.

00:00:25.940 --> 00:00:29.825
Let's say what happens in this program, you know [UNKNOWN] and

00:00:29.825 --> 00:00:35.450
the registers. First, we will issue the LO here, It's output is the R1,

00:00:35.450 --> 00:00:40.070
so at the beginning of all of these the ROB is empty. The issue and

00:00:40.070 --> 00:00:44.080
commit point are the same, and. That, let's say that there are no instruction.

00:00:45.210 --> 00:00:47.910
At the beginning of all of this, let's say that there are no instructions, so

00:00:47.910 --> 00:00:50.330
the RAT is just pointing to the registers, and the issue and

00:00:50.330 --> 00:00:53.820
commit point in the ROB are the same. Meaning that the ROB is empty,

00:00:53.820 --> 00:00:58.330
all of the entries are free. Now let's see what happens when we issue the load.

00:00:58.330 --> 00:01:02.310
We move the issue point to here. The load produces R1.

00:01:04.170 --> 00:01:07.910
An R1 here in the RAT is made to point to the ROB 1 entry. When

00:01:09.290 --> 00:01:15.440
we issue the branch, it produces no output,

00:01:15.440 --> 00:01:21.060
and thus we don't need to rename anything and the issue pointer moves here.

00:01:21.060 --> 00:01:25.648
Next what happens, we will issue instructions. That, shouldn't have been issued.

00:01:25.648 --> 00:01:30.170
But the [UNKNOWN] doesn't know that yet, so it's just going to do it anyway. So

00:01:30.170 --> 00:01:36.550
this add here writes to R2. And it gets the next ROB entry here.

00:01:36.550 --> 00:01:41.520
So the R2 entry is going to point to ROB3. And then this multiply here.

00:01:42.980 --> 00:01:48.870
Is going to write R3. And that R3 is going to ROB4. And then

00:01:48.870 --> 00:01:54.110
the divide is going to again write to R2. And that means that the answer for R2,

00:01:54.110 --> 00:01:59.570
in the RAT will be changed from pointing to the add to pointing to the divide.

00:01:59.570 --> 00:02:03.020
Which is ROB5, and of course after all of this issuing is done,

00:02:03.020 --> 00:02:07.390
our issue point is now here. And we have five instructions in our prompt.

00:02:07.390 --> 00:02:12.130
Now suppose that this LO takes a long time to produce a value for

00:02:12.130 --> 00:02:16.701
example because it's a cash miss. This branch depends on the loads, we've cannot

00:02:16.701 --> 00:02:20.492
complete until the load is done, and this add also co-depends on the load and it

00:02:20.492 --> 00:02:25.518
cannot complete until the load is done. But this multiply here can begin because

00:02:25.518 --> 00:02:30.260
R3 and R4 are not produced by any of these instructions. So this multiply,

00:02:31.520 --> 00:02:36.680
might produce a value for example 15 and originally it would

00:02:36.680 --> 00:02:42.040
write it to the registers, and at that point after the branch misprediction, but

00:02:42.040 --> 00:02:47.590
this multiply can compute its value because R3 and R4 might be ready,

00:02:47.590 --> 00:02:52.840
they're not produced many of the previous instructions. So, the value of 15 when

00:02:52.840 --> 00:02:58.520
the multiply finishes, would have been written to the registers, and

00:02:58.520 --> 00:03:02.530
then, we don't know how to undo the multiplication once we discover that

00:03:02.530 --> 00:03:07.303
the branch have been mispredicted. In our [INAUDIBLE] base processor,

00:03:07.303 --> 00:03:12.870
the result of the multiplication goes into its. ROB entry,

00:03:12.870 --> 00:03:16.470
and it's marked as done. Once this multiply produces a value,

00:03:16.470 --> 00:03:22.000
the divide can begin. And let's say that the divide is producing a value of 2,

00:03:22.000 --> 00:03:26.220
and it might also be done before the load returns. So now we

00:03:26.220 --> 00:03:31.040
have a situation where these two instructions would have updated registers, and

00:03:31.040 --> 00:03:33.920
done permanent damage. But in a raw based processor,

00:03:33.920 --> 00:03:39.410
all they did was update the raw [INAUDIBLE]. The registers are still unmodified

