WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.650
Now that we have learned how to analyze algorithms

00:00:03.650 --> 00:00:08.770
let's look back to the algorithm that Alice was using to solve her problem

00:00:08.770 --> 00:00:13.660
which was the whole point of us learning about algorithm analysis in the first place.

00:00:13.660 --> 00:00:17.920
Here again is the algorithm that Alice was using. It's those five lines here.

00:00:17.920 --> 00:00:22.900
And although we already notice that it's a running time that grows exponentially

00:00:22.900 --> 00:00:27.220
we don't really yet have the precise running time stated in O notation.

00:00:27.220 --> 00:00:33.580
In order to do this, let's look at the individual lines and see how often they are executed.

00:00:33.580 --> 00:00:38.130
And then as a little quiz, I will ask you to figure out the running time

00:00:38.130 --> 00:00:40.870
of Alice algorithm using O notation.

00:00:40.870 --> 00:00:46.720
Let's start with line 1, and line 1 is just an assignment of a value.

00:00:46.720 --> 00:00:52.250
That's actually it takes zero times steps but we can also just say that

00:00:52.250 --> 00:00:57.640
it takes O(1), which just means that it's some constant although in this case

00:00:57.640 --> 00:01:02.700
the constant is zero but O(1) is a general notation to keep in mind.

00:01:02.700 --> 00:01:07.450
Anytime you want to state that an algorithm runs in constant time you can just write O(1).

00:01:07.450 --> 00:01:12.580
Now, line #2. When we have n communication centers.

00:01:12.580 --> 00:01:15.350
So N is going to be the size of the input in this case.

00:01:15.350 --> 00:01:23.150
Then we already figured out at the beginning that this line here is going to executed O(2^n)

00:01:23.150 --> 00:01:26.550
and I'm going to use this notation here, which you might not be familiar with

00:01:26.550 --> 00:01:29.680
to say that n here is the exponent.

00:01:29.680 --> 00:01:32.220
So what about line 3?

00:01:32.220 --> 00:01:37.530
So line 3 is going to be called each time that this loop here executes.

00:01:37.530 --> 00:01:44.070
So each time the loop of lines 2, 3, 4, and 5 executes we're going to call this function here.

00:01:44.070 --> 00:01:51.690
Now the question is how long does it take as to check if an assignment of 0 and 1 values is valid.

00:01:51.690 --> 00:01:59.470
So if you have a network that has n communication centers then in theory each communication center

00:01:59.470 --> 00:02:02.830
can be connected to any other communication center.

00:02:02.830 --> 00:02:06.920
So you have n communication centers and the question is how many connections

00:02:06.920 --> 00:02:08.680
can they have between each other?

00:02:08.680 --> 00:02:15.120
So this one could be connected to this one, this one here, this one here, and so on.

00:02:15.120 --> 00:02:20.960
And basically checking if an assignment of 0 and 1 values is valid means checking for each cable

00:02:20.960 --> 00:02:25.820
between two communication centers whether at least one of the communications centers

00:02:25.820 --> 00:02:27.830
is assigned a 1.

00:02:27.830 --> 00:02:33.230
The running time of checking if the whole assignment of 0 and 1 values is valid

00:02:33.230 --> 00:02:35.550
depends on the total number of cables.

00:02:35.550 --> 00:02:39.570
The question here is what is the maximum number of cables that we can have.

00:02:39.570 --> 00:02:44.020
And that is actually very similar to the running time of the algorithm that you analyzed

00:02:44.020 --> 00:02:49.750
in the quiz a few minutes ago because the first communication center can be connected

00:02:49.750 --> 00:02:56.770
to n-1 other communication centers and the second one is it can also be connected

00:02:56.770 --> 00:03:01.690
to n-1 other centers but of course we don't want to double count

00:03:01.690 --> 00:03:05.850
or actually it doesn't really matter if we double count or not because we're using O notation.

00:03:05.850 --> 00:03:11.390
But if we don't double count, then it's just n-2 cables here and this goes on and on and on.

00:03:11.390 --> 00:03:15.370
And from the algorithm that you analyzed before when we were discussing O notation,

00:03:15.370 --> 00:03:22.680
you already know that if you do the sum of n-1, n-2, n-3, and so on until you get down to 1

00:03:22.680 --> 00:03:25.130
then that is O(n²).

00:03:25.130 --> 00:03:31.550
The worst case running time for checking if a given assignment is valid means going through

00:03:31.550 --> 00:03:36.360
O(n²) different cables and then for each of those cables checking if one of the

00:03:36.360 --> 00:03:40.230
communication centers that it is attached to has been assigned a 1.

00:03:40.230 --> 00:03:47.690
Now to figure out the running time of this line here, of course we first know it's O(n²) cables

00:03:47.690 --> 00:03:51.090
and then the question is how much time do we need to check an individual cable

00:03:51.090 --> 00:03:55.110
but for now I think without further discussion we can assume that it's constant time

00:03:55.110 --> 00:03:57.610
because it's just connected to two communication centers.

00:03:57.610 --> 00:04:00.860
There's probably an efficient way that we can implement this.

00:04:00.860 --> 00:04:03.870
If you were to prove the actual running time of course you would have to have

00:04:03.870 --> 00:04:04.960
a more detailed discussion here.

00:04:04.960 --> 00:04:09.830
But for now we'll just say each time this line here is executed it takes O(2^n) time.

00:04:09.830 --> 00:04:11.370
Now, what about line 4?

00:04:11.370 --> 00:04:17.300
Each time this line is executed, we have to do the sum of all the 1s in the assignment.

00:04:17.300 --> 00:04:19.940
And now the assignment concerns the communication centers.

00:04:19.940 --> 00:04:24.690
So we have to go through n communication centers and count how many 1s we find.

00:04:24.690 --> 00:04:28.990
So each time this line is executed, it will take O(n^2) time, which is linear time.

00:04:28.990 --> 00:04:35.820
And finally, line 5 is taking the minimum of the best possible solution we have found so far

00:04:35.820 --> 00:04:39.060
and the number of devices we have in the current solution to figure out

00:04:39.060 --> 00:04:42.360
if the current solution is a better solution than the one that we already have.

00:04:42.360 --> 00:04:47.480
But this of course takes only constant time because it does not depend on the size of the input.

00:04:47.480 --> 00:04:49.820
It always takes two values and produces a minimum.

00:04:49.820 --> 00:04:55.460
So as announced as our next quiz, I would like you to take this information and figure out

00:04:55.460 --> 00:05:00.050
what the overall running time of Alice's algorithm will be

00:05:00.050 --> 00:05:03.270
given a network of n communication centers.

00:05:03.270 --> 99:59:59.000
So which of these six possibilities is the correct running time of Alice's algorithm above?

