WEBVTT
Kind: captions
Language: en

00:00:00.230 --> 00:00:05.700
From the previous quiz the problem is that the variable i that's used in this

00:00:05.700 --> 00:00:11.470
thread creation operation is a globally visible variable that's defined in main.

00:00:11.470 --> 00:00:14.120
When its value changes in one thread,

00:00:14.120 --> 00:00:17.190
every one of the other threads will see the new value.

00:00:17.190 --> 00:00:20.335
In this particular case the second thread that was created in

00:00:20.335 --> 00:00:24.790
pthread_create was created with i equal 1.

00:00:24.790 --> 00:00:32.310
In the thread function, p will become equivalent to the address of i and myNum

00:00:32.310 --> 00:00:37.180
will then become equivalent to the actual value of i, so that's presumably 1.

00:00:37.180 --> 00:00:41.050
However, it is possible that before this thread had a chance to

00:00:41.050 --> 00:00:47.200
execute these operations and set the value of myNum to be 1,

00:00:47.200 --> 00:00:52.270
the main thread went into the next iteration of this for loop.

00:00:52.270 --> 00:00:54.390
And there it incremented i.

00:00:54.390 --> 00:00:56.260
So i is now 2.

00:00:56.260 --> 00:00:58.750
Since we passes an argument the address of i,

00:00:59.800 --> 00:01:02.700
p will also correspond to the address of i.

00:01:02.700 --> 00:01:07.590
So it will point to the same i and then myNum will actually take as

00:01:07.590 --> 00:01:12.160
a value the new value of i so it will take as a value 2.

00:01:12.160 --> 00:01:16.170
So it's not like we lost the print out from that second thread that we were

00:01:16.170 --> 00:01:20.980
expecting with print out thread number 1, it's just that both the second and

00:01:20.980 --> 00:01:25.860
the third thread ended up seeing that the value of i is 2 and

00:01:25.860 --> 00:01:29.010
that's why then printing out thread number 2.

00:01:29.010 --> 00:01:32.340
We call this situation a data race, or a race condition.

00:01:32.340 --> 00:01:35.680
It occurs when one thread tries to read a variable that

00:01:35.680 --> 00:01:37.800
another thread is modifying.

00:01:37.800 --> 00:01:41.900
In this example the second thread that we created was trying to

00:01:41.900 --> 00:01:47.510
read the variable i, and we were expecting it that it would read i equal 1,

00:01:47.510 --> 00:01:50.830
however at the same time the main thread was modifying i,

00:01:50.830 --> 00:01:53.940
was incrementing it, and it became 2.

00:01:53.940 --> 00:01:57.840
To correct the problem let's look at a slightly modified code here.

00:01:57.840 --> 00:01:59.160
We see that in the for

00:01:59.160 --> 00:02:04.330
looping main the value of i is first copied into an array.

00:02:04.330 --> 00:02:06.145
Into an element of an array tNum.

00:02:06.145 --> 00:02:10.038
The array has s many elements as there are threads and

00:02:10.038 --> 00:02:14.790
when we are creating a thread we pass as an argument the address of

00:02:14.790 --> 00:02:19.980
the particular element of the array that corresponds to that thread number.

00:02:19.980 --> 00:02:24.300
By creating this array then, it's like as if we created local storage, or

00:02:24.300 --> 00:02:25.940
private storage, for

00:02:25.940 --> 00:02:29.420
the arguments of every single one of the threads that we create.

00:02:29.420 --> 00:02:32.240
Now we don't have to worry about the ordering of

00:02:32.240 --> 00:02:37.240
how the new threads will execute the operations, because every one of

00:02:37.240 --> 00:02:42.100
them will have their own private copy of the input arguments that won't change.

