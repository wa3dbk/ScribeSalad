WEBVTT
Kind: captions
Language: en

00:00:00.100 --> 00:00:03.310
Okay, so
let's revisit this idea of isolation.

00:00:03.310 --> 00:00:05.190
When it comes to protection and

00:00:05.190 --> 00:00:08.220
security, isolation is
actually your best friend.

00:00:08.220 --> 00:00:11.470
Okay, that means that I'm
isolated from somebody else and

00:00:11.470 --> 00:00:13.160
they can't do anything bad to me.

00:00:13.160 --> 00:00:18.570
Untrusted user code has to be
isolated from the system code, okay.

00:00:18.570 --> 00:00:24.372
We talked about trusted system code
tamper-proofness that we're talking.

00:00:24.372 --> 00:00:26.090
You shouldn't be able to alter it and

00:00:26.090 --> 00:00:29.620
the only way you can go in to operating
system is through system calls

00:00:29.620 --> 00:00:32.590
that are defined by
the operating system and so on.

00:00:32.590 --> 00:00:36.650
So how are we going to achieve
this isolation of user code?

00:00:36.650 --> 00:00:40.220
The reason I wanted to think about
this is what does a processor do?

00:00:40.220 --> 00:00:42.280
It says fetch the next instruction.

00:00:42.280 --> 00:00:46.300
To execute it you need some operands
that are somewhere in memory.

00:00:46.300 --> 00:00:48.320
You fetch those you execute
the instruction and

00:00:48.320 --> 00:00:49.920
you keep doing that forever.

00:00:49.920 --> 00:00:53.360
But I'm using let's say running
executing some user code.

00:00:53.360 --> 00:00:57.110
Why can't I say the next
instruction I want to switch to

00:00:57.110 --> 00:01:01.190
somewhere in the operating system or
the next data item I want to bring

00:01:01.190 --> 00:01:03.680
is a data structure that resided
in the operating system?

00:01:03.680 --> 00:01:06.280
If you tried to do that we said
you wouldn't be able to do it.

00:01:06.280 --> 00:01:09.180
Because we have this execution
mode we're talking about,

00:01:09.180 --> 00:01:10.390
and things like that.

00:01:10.390 --> 00:01:13.480
So, we're going to use that
hardware support to achieve or

00:01:13.480 --> 00:01:17.230
accomplish this isolation,
separating, or separation,

00:01:17.230 --> 00:01:20.120
of user code from
the operating system code.

00:01:20.120 --> 00:01:23.430
So let's see how we actually
going to be able to do that.

00:01:23.430 --> 00:01:26.110
Well the way to do that is again I said.

00:01:26.110 --> 00:01:30.090
It's going to rely on
the hardware to protect memory.

00:01:30.090 --> 00:01:33.950
So remember isolation I said the way.

00:01:33.950 --> 00:01:38.850
Executing in user mode or
executing user code and at

00:01:38.850 --> 00:01:43.370
that point if the hardware can protect
memory where the operating system is.

00:01:43.370 --> 00:01:45.250
What does memory protection mean.

00:01:45.250 --> 00:01:49.400
We said the process in which read
write request or load store request or

00:01:49.400 --> 00:01:53.060
execute those instructions to
fetch the next instruction or

00:01:53.060 --> 00:01:55.470
fetch the data that it's
going to operate on.

00:01:55.470 --> 00:01:59.350
It's going to generate an address
where it wants to do a read or write.

00:01:59.350 --> 00:02:00.870
Well, the hardware says,

00:02:00.870 --> 00:02:04.210
you're not allowed to access
that part of the memory.

00:02:04.210 --> 00:02:05.870
Okay, hardware support is saying,

00:02:05.870 --> 00:02:08.669
it is part of memory that
belongs to the operating system.

00:02:08.669 --> 00:02:10.900
Okay, that's what the operating
system code and data is.

00:02:10.900 --> 00:02:15.360
If you're running in user mode, you are
not allowed to generate an address and

00:02:15.360 --> 00:02:18.020
complete a read write in
a memory location that

00:02:18.020 --> 00:02:19.460
belongs to the operating system.

00:02:19.460 --> 00:02:22.480
So hardware support memory
protection essentially says,

00:02:22.480 --> 00:02:26.500
if the process happens to generate an
address that is in the operating system,

00:02:26.500 --> 00:02:27.810
the hardware support we have for

00:02:27.810 --> 00:02:32.270
memory protection is going to stop
that memory access from completing.

00:02:32.270 --> 00:02:34.070
Although it's generating an address, and

00:02:34.070 --> 00:02:37.750
it's a memory location, the hardware
that potentially can do a read or

00:02:37.750 --> 00:02:40.660
write there but
it currently knows that it's user code.

00:02:40.660 --> 00:02:43.310
And user code directly can't access

00:02:43.310 --> 00:02:47.280
the information that we have
in the operating system part.

00:02:47.280 --> 00:02:52.020
So the hardware is going to essentially
stop that access from proceeding.

00:02:52.020 --> 00:02:56.790
So hardware is going to sort of
keep you contained in your space.

00:02:56.790 --> 00:03:00.050
And we get to that,
it's not just OS user, but

00:03:00.050 --> 00:03:02.840
it's also across different
user processes, but

00:03:02.840 --> 00:03:07.490
it's going to contain you within
the area of memory that belongs to you.

00:03:07.490 --> 00:03:09.620
And if you try to touch something else.

00:03:09.620 --> 00:03:10.560
Which you can.

00:03:10.560 --> 00:03:12.410
It's going to stop you from doing that.

00:03:12.410 --> 00:03:13.770
And the hardware is going to do that.

00:03:13.770 --> 00:03:15.100
All this hardware support we have for

00:03:15.100 --> 00:03:17.470
memory protection is
actually going to do that.

