WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
Welcome to the first office hours.

00:00:02.000 --> 00:00:05.000
Peter and I are going to be answering your questions.

00:00:05.000 --> 00:00:09.000
Well, Peter will be answering the question. I'll be asking the questions every week.

00:00:09.000 --> 00:00:12.000
We're going to take the questions that you ask in the forums.

00:00:12.000 --> 00:00:16.000
So far we've seen a lot of really good stuff, so I hope in the weeks to come

00:00:16.000 --> 00:00:19.000
you guys keep coming to the forums and keep asking such great questions.

00:00:19.000 --> 00:00:22.000
The first question comes from Prajeet, and he's a high school student

00:00:22.000 --> 00:00:25.000
who actually lives in the Silicon Valley area.

00:00:25.000 --> 00:00:28.000
He wants to know when you're about to tackle a new problem

00:00:28.000 --> 00:00:30.000
how much research do you do?

00:00:30.000 --> 00:00:32.000
Do you look for methods that have already been written

00:00:32.000 --> 00:00:34.000
or do you generally just write these tools yourself?

00:00:34.000 --> 00:00:39.000
And how do you balance that trade off of research time versus time spent writing?

00:00:39.000 --> 00:00:41.000
That's a great question Prajeet.

00:00:41.000 --> 00:00:45.000
An important part of being a programmer is knowing what you should do yourself

00:00:45.000 --> 00:00:49.000
and what you should take advantage of what other people have already done.

00:00:49.000 --> 00:00:52.000
I like to think of at two levels.

00:00:52.000 --> 00:00:59.000
One is the low level tools--the built-in functions and data types like strings and sets

00:00:59.000 --> 00:01:03.000
and dictionaries that are part of Python.

00:01:03.000 --> 00:01:09.000
There you've just got to learn what's available and keep on learning and reminding yourself

00:01:09.000 --> 00:01:13.000
of exactly what all the functionality is.

00:01:13.000 --> 00:01:19.000
The core functionality, how you access the nth element of a list,

00:01:19.000 --> 00:01:22.000
that you're going to know by heart pretty soon.

00:01:22.000 --> 00:01:24.000
But there's lots of individual methods,

00:01:24.000 --> 00:01:27.000
like how you count up how many items are in a list and so on.

00:01:27.000 --> 00:01:31.000
You may not remember all those, so you'll be looking at the documentation constantly,

00:01:31.000 --> 00:01:36.000
looking things up, and saying what methods are available on this type.

00:01:36.000 --> 00:01:41.000
And then the second part is for much larger pieces of code.

00:01:41.000 --> 00:01:48.000
Say you want a web server or you want to be able to parse and respond to email.

00:01:48.000 --> 00:01:52.000
Those are the types of things where you expect, hey, somebody else has done that before.

00:01:52.000 --> 00:01:55.000
That's a big job. I probably don't have to do it.

00:01:55.000 --> 00:01:59.000
Then you start research, and you find the right module that implements what you need.

00:01:59.000 --> 00:02:03.000
Programming is always this combination of what you have to do yourself

00:02:03.000 --> 00:02:07.000
and what do you find that people have already done that you can incorporate into your solution.

00:02:07.000 --> 00:02:10.000
Mark Sanders asks the next question.

00:02:10.000 --> 00:02:13.000
He had some concerns with the difficulty level of the class,

00:02:13.000 --> 00:02:16.000
particularly in the solution videos.

00:02:16.000 --> 00:02:19.000
Often he'll write some code that maybe solved it one way

00:02:19.000 --> 00:02:23.000
and he finds that your solution maybe involves functions that he's never seen before.

00:02:23.000 --> 00:02:26.000
What do you have to say to students who are experiencing this kind of thing.

00:02:26.000 --> 00:02:30.000
Mark, thanks for that question, and I know other people in the forums had

00:02:30.000 --> 00:02:34.000
similar types of questions and what I want to say to you is

00:02:34.000 --> 00:02:37.000
everyone chill out. You've all got this.

00:02:37.000 --> 00:02:42.000
If you've made it through CS101, you know everything you need to know

00:02:42.000 --> 00:02:45.000
to answer all the problems in this class.

00:02:45.000 --> 00:02:49.000
Now, I think that there's this misperception that--

00:02:49.000 --> 00:02:53.000
and maybe this is sort of the way school has traditionally been done--

00:02:53.000 --> 00:02:57.000
that students think that there is one correct answer,

00:02:57.000 --> 00:03:01.000
and you're measured by how close you come to the teacher's answer.

00:03:01.000 --> 00:03:04.000
In this class, that's not the way things work at all.

00:03:04.000 --> 00:03:10.000
In this class, what I'm trying to get you to do is to grapple with a problem,

00:03:10.000 --> 00:03:18.000
come up with a solution and then analyze alternatives for how it might be done differently.

00:03:18.000 --> 00:03:22.000
If you have the problem and you come up with a solution and it solves the problem,

00:03:22.000 --> 00:03:27.000
then you've got it. That's 100% correct. Pat yourself on the back.

00:03:27.000 --> 00:03:30.000
Don't worry about how anybody else solved it.

00:03:30.000 --> 00:03:33.000
You did the job, and I know you can do it.

00:03:33.000 --> 00:03:37.000
You've got all the background you need--full stop.

00:03:37.000 --> 00:03:41.000
Now, after you've done, now it's time to introspect a little.

00:03:41.000 --> 00:03:47.000
I'll talk about the way I did it, and my way of doing it might be different than yours.

00:03:47.000 --> 00:03:53.000
If you think my way is interesting or has something novel to show that you didn't think of before,

00:03:53.000 --> 00:03:56.000
then you could say, hah, maybe next time I'll do it that way.

00:03:56.000 --> 00:03:58.000
But that doesn't take away from your solution.

00:03:58.000 --> 00:04:01.000
Your solution is still fine,

00:04:01.000 --> 00:04:07.000
but now you've learned a new trick, a new tool to add to your arsenal

00:04:07.000 --> 00:04:09.000
that maybe next time you can use.

00:04:09.000 --> 00:04:11.000
I'll let you in on a secret.

00:04:11.000 --> 00:04:14.000
Every advanced feature that's in a programming language

00:04:14.000 --> 00:04:18.000
is there because somebody suffered in the past.

00:04:18.000 --> 00:04:22.000
Somebody tried to write it out the long way, and it took a really long time,

00:04:22.000 --> 00:04:27.000
and they said, gee, there's got to be a better way, and then we put the better way into the language.

00:04:27.000 --> 00:04:30.000
You've got to understand why this is in the language.

00:04:30.000 --> 00:04:32.000
Now, if I just told you ahead of time,

00:04:32.000 --> 00:04:35.000
"Here's a new feature. This is part of the language,"

00:04:35.000 --> 00:04:41.000
you wouldn't get it to the degree you would if you see why it's there because you suffered without it.

00:04:41.000 --> 00:04:44.000
That's the way this course works, and I know it might be different

00:04:44.000 --> 00:04:49.000
from what you were used to before where you're spoon fed

00:04:49.000 --> 00:04:51.000
everything you need to know ahead of time.

00:04:51.000 --> 00:04:56.000
Maybe that's how school works in some cases, but it's not how the real world works.

00:04:56.000 --> 00:05:00.000
So don't get frustrated. That's the way the class is supposed to work.

00:05:00.000 --> 00:05:04.000
If you have a solution that works, no matter how you did it, then that's fine.

00:05:04.000 --> 00:05:07.000
That's perfect. That's 100% correct solution.

00:05:07.000 --> 00:05:13.000
Then after that you can start learning about alternative ways to do it.

00:05:13.000 --> 00:05:18.000
Thanks. Serge had a question about how to value, I guess,

00:05:18.000 --> 00:05:22.000
the clarity of a certain solution or the beauty of a certain solution.

00:05:22.000 --> 00:05:26.000
How do you, when you're presented with two choices for code,

00:05:26.000 --> 00:05:28.000
both equally correct and even equally efficient,

00:05:28.000 --> 00:05:31.000
how do you evaluate which one is better than the other?

00:05:31.000 --> 00:05:34.000
Great question, Serge. You're right.

00:05:34.000 --> 00:05:38.000
The first thing you want to think about is have I solved the problem?

00:05:38.000 --> 00:05:40.000
Do I have it correct?

00:05:40.000 --> 00:05:43.000
Once you do, then efficiency is another issue.

00:05:43.000 --> 00:05:45.000
Sometimes efficiency is important.

00:05:45.000 --> 00:05:49.000
For a lot of the types of problems that we're dealing with efficiency is not important,

00:05:49.000 --> 00:05:52.000
because all the solutions will be fast enough,

00:05:52.000 --> 00:05:55.000
but I think that's a minor part of the conversation.

00:05:55.000 --> 00:05:59.000
The more important part of the conversation is the one you're having with programmers.

00:05:59.000 --> 00:06:03.000
That's other programmers who are reading your code and with yourself

00:06:03.000 --> 00:06:09.000
as you start developing and working with your code over time.

00:06:09.000 --> 00:06:11.000
You want to hold up your end of the conversation.

00:06:11.000 --> 00:06:16.000
You want to have it be clear, express exactly what you mean to say,

00:06:16.000 --> 00:06:18.000
and have that all work out.

00:06:18.000 --> 00:06:24.000
One of the the rules I use is we're all good and communicating in English,

00:06:24.000 --> 00:06:27.000
or in our native language whatever it is,

00:06:27.000 --> 00:06:32.000
so if the code can look like that then we know we're going to be successful in our communication.

00:06:32.000 --> 00:06:35.000
We talk about what's the best poker hand.

00:06:35.000 --> 00:06:40.000
Well, the best poker hand is the one that's the maximum according to the hand rank.

00:06:40.000 --> 00:06:46.000
To the extent in which I can write my code to sound exactly like that English sentence,

00:06:46.000 --> 00:06:48.000
then I think that that code is clear.

00:06:48.000 --> 00:06:53.000
There's a one-to-one mapping between the English description and the code description.

00:06:53.000 --> 00:06:56.000
Now, Serge, you mentioned length.

00:06:56.000 --> 00:07:03.000
The length of a conversation can help clarity of communication or it can hurt it.

00:07:03.000 --> 00:07:08.000
If I go on and talk and talk and talk and talk, and you start to get bored,

00:07:08.000 --> 00:07:11.000
then I failed in my communication.

00:07:11.000 --> 00:07:14.000
Having a program that's too long can be a problem.

00:07:14.000 --> 00:07:17.000
Similarly, if you ask me a complicated question, and I give you a two-word answer,

00:07:17.000 --> 00:07:20.000
I may have failed to communicate then.

00:07:20.000 --> 00:07:24.000
I may not have given you enough context so that you understand my answer,

00:07:24.000 --> 00:07:27.000
even if my answer was technically correct.

00:07:27.000 --> 00:07:30.000
A program can fail to communicate because it's too short as well.

00:07:30.000 --> 00:07:35.000
You've got to learn to have good taste, to say, yes, for my audience

00:07:35.000 --> 00:07:39.000
this is the right length, this speaks to them and tells them all they need to know

00:07:39.000 --> 00:07:42.000
with just the right amount of context to get it right.

00:07:46.000 --> 00:07:49.000
Clair Dunn had a question, and she is interested in this top-down

00:07:49.000 --> 00:07:52.000
problem solving approach that we used in unit one.

00:07:52.000 --> 00:07:58.000
What I mean by that is we're often defining functions, even pretending to use, functions that don't exist.

00:07:58.000 --> 00:08:02.000
When you defined the poker function, you referenced the hand-rank function,

00:08:02.000 --> 00:08:05.000
even though we haven't written that yet.

00:08:05.000 --> 00:08:08.000
What can you say about the advantages of this approach to problem-solving

00:08:08.000 --> 00:08:13.000
versus the bottom-up approach where we would first build up all the pieces

00:08:13.000 --> 00:08:16.000
and then use those pieces in the poker function.

00:08:16.000 --> 00:08:20.000
We know when we're finished with our program we've got a complete structure.

00:08:20.000 --> 00:08:23.000
It's got a top and a bottom.

00:08:23.000 --> 00:08:26.000
There's a top level function that you call, and then that's going to call subroutines.

00:08:26.000 --> 00:08:31.000
That's why they're called subroutines, because they're below.

00:08:31.000 --> 00:08:35.000
They've all got to work in order for your program to work.

00:08:35.000 --> 00:08:39.000
Now the question is in what order do you address them?

00:08:39.000 --> 00:08:41.000
I think a lot of that depends on the domain

00:08:41.000 --> 00:08:48.000
and depends on where you're clear and where you're uncertainty is.

00:08:48.000 --> 00:08:52.000
If we have a description of the domain that we understand,

00:08:52.000 --> 00:08:55.000
then it makes a lot of sense to start from the top.

00:08:55.000 --> 00:08:59.000
I gave the example of saying what's the best poker hand.

00:08:59.000 --> 00:09:06.000
It's the one that has the maximum hand rank, and that's a high level statement.

00:09:06.000 --> 00:09:09.000
It assumes that we know how to rank a hand.

00:09:09.000 --> 00:09:12.000
I think that's quite a reasonable assumption.

00:09:12.000 --> 00:09:15.000
If you don't understand what's going on, then sometimes it makes more sense

00:09:15.000 --> 00:09:18.000
just to start down at the bottom and build your way up,

00:09:18.000 --> 00:09:22.000
to say what are the pieces of the domain and how do they fit together?

00:09:22.000 --> 00:09:27.000
Let me play with them a little bit, and then I'll think of a good way to put them together.

00:09:27.000 --> 00:09:30.000
You can go in both directions, top down and bottom up.

00:09:30.000 --> 00:09:35.000
It depends on your current state of understanding, but I think the key here--

00:09:35.000 --> 00:09:42.000
maybe that Clair wasn't used to--is never be afraid to engage in wishful thinking,

00:09:42.000 --> 00:09:46.000
to say if only I had a function that did the right thing.

00:09:46.000 --> 00:09:51.000
Then I could proceed. You should always be willing to proceed that way.

00:09:51.000 --> 00:09:58.000
One last question. You were once a student of computer science yourself.

00:09:58.000 --> 00:10:02.000
I'm sure there were methods that were helpful for you in learning how to code.

00:10:02.000 --> 00:10:07.000
What kind of advice can you give to current students of computer science?

00:10:07.000 --> 00:10:10.000
I should I think you guys are doing great,

00:10:10.000 --> 00:10:18.000
and it's so much easier for you than it was for me when I was learning.

00:10:18.000 --> 00:10:21.000
Part of the reason for is that so much is more accessible now.

00:10:21.000 --> 00:10:28.000
I started before there was an internet, so you couldn't just do a Google search and find results.

00:10:28.000 --> 00:10:30.000
Secondly, I didn't own a computer.

00:10:30.000 --> 00:10:34.000
Those were big, expensive things that individuals didn't own.

00:10:34.000 --> 00:10:39.000
So you had to go to the computer center and use the machines that were there.

00:10:39.000 --> 00:10:42.000
It was just inconvenient and hard to do that.

00:10:42.000 --> 00:10:47.000
Now, one of the good advantages of doing that was that meant I was in the same room with other people.

00:10:47.000 --> 00:10:53.000
You got a chance to talk with your colleagues and friends and learn from them.

00:10:53.000 --> 00:10:57.000
I would encourage you to keep doing that, to keep finding other people

00:10:57.000 --> 00:11:01.000
to bounce ideas off of and learning from them.

00:11:01.000 --> 00:11:05.000
But then you're in such a great position now to learn so much more quickly.

00:11:05.000 --> 00:11:08.000
&gt;From what I've seen from briefly observing 101

00:11:08.000 --> 00:11:13.000
and from what I've seen in this class, you guys are off to a great start.

00:11:13.000 --> 00:11:19.000
It took me years to get to the level where you guys are just starting out. Keep it up.

00:11:19.000 --> 00:11:24.000
Thanks for the answer, and thank you all for the great questions. We'll see you again next week.

