WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
The next kind of strong oracle that I'd like to talk about

00:00:02.000 --> 00:00:04.000
is what I would call a function inverse pair.

00:00:04.000 --> 00:00:07.000
We have available to us some sort of function and also its inverse,

00:00:07.000 --> 00:00:11.000
and we can use these as a pair to do strong checking

00:00:11.000 --> 00:00:13.000
of correct behavior of the software under test.

00:00:13.000 --> 00:00:15.000
If we remember, a couple of units ago

00:00:15.000 --> 00:00:17.000
I gave the example of where you could test an assembler

00:00:17.000 --> 00:00:20.000
by pairing it with a disassembler and also an exhaustive enumerator

00:00:20.000 --> 00:00:22.000
for instruction encodings.

00:00:22.000 --> 00:00:25.000
And then what we would do is take all valid instruction encodings,

00:00:25.000 --> 00:00:27.000
disassemble them into assembly language,

00:00:27.000 --> 00:00:29.000
reassemble the assembly language into machine code,

00:00:29.000 --> 00:00:31.000
and do a comparison on the output.

00:00:31.000 --> 00:00:35.000
So that's what I'm talking about when I mention function inverse pairs.

00:00:35.000 --> 00:00:38.000
If we think about it, we can find these function inverse pairs a lot of places.

00:00:38.000 --> 00:00:43.000
Another example is encryption and decryption, compression and decompression,

00:00:43.000 --> 00:00:46.000
saving and loading of files, and this isn't as trivial as it sounds.

00:00:46.000 --> 00:00:50.000
I'm not talking about an example where we take some sort of a bitwise representation

00:00:50.000 --> 00:00:54.000
in memory and dump it literally to disk and then load it again. That's unlikely to go wrong.

00:00:54.000 --> 00:00:57.000
On the other hand, many times when a program saves its state to disk

00:00:57.000 --> 00:00:59.000
this is a pretty non-trivial operation.

00:00:59.000 --> 00:01:01.000
We might, for example, be replacing machine pointers

00:01:01.000 --> 00:01:03.000
with some sort of an on-disk representation,

00:01:03.000 --> 00:01:05.000
and then the load operation is going to contain the inverse,

00:01:05.000 --> 00:01:07.000
but it's pretty easy to get that wrong.

00:01:07.000 --> 00:01:09.000
Or maybe perhaps we forgot to save part of the program state

00:01:09.000 --> 00:01:11.000
and then when we load it we'll end up in a different state,

00:01:11.000 --> 00:01:14.000
but we'll be able to catch that by treating save and load as a function inverse pair.

00:01:14.000 --> 00:01:16.000
Transmit and receive across some sort of a loop back interface--

00:01:16.000 --> 00:01:19.000
that is to say, a network interface that connects a machine to itself--

00:01:19.000 --> 00:01:21.000
can serve as a useful oracle because in some cases

00:01:21.000 --> 00:01:24.000
there are non-trivial transformations of data representation

00:01:24.000 --> 00:01:27.000
that happen as part of the transmit and receive operation.

00:01:27.000 --> 00:01:30.000
And finally, encoding and decoding of, for example, media formats

00:01:30.000 --> 00:01:32.000
serves as a final example of a function inverse pair.

00:01:32.000 --> 00:01:34.000
I know there must be a bunch of these that I'm missing,

00:01:34.000 --> 00:01:37.000
but these are the ones that I could come up with

00:01:37.000 --> 00:01:39.000
just sort of sitting down and brainstorming for a couple of minutes.

00:01:39.000 --> 00:01:41.000
If you have a function inverse pair, use them together

00:01:41.000 --> 00:01:43.000
and try to see if you arrived at the original data.

00:01:43.000 --> 00:01:45.000
And of course, this may not always be as easy as it seems.

00:01:45.000 --> 00:01:47.000
For example, when we save pointers to disk

00:01:47.000 --> 00:01:50.000
and we swizzle them into some sort of on-disk representation,

00:01:50.000 --> 00:01:52.000
when we load them, the pointer values may have changed,

00:01:52.000 --> 00:01:54.000
but the shape of the data shouldn't.

00:01:54.000 --> 00:01:57.000
So some sort of abstraction is going to be required

00:01:57.000 --> 00:01:59.000
to compare the saved and loaded version.

00:01:59.000 --> 00:02:02.000
Similarly, the encode and decode of media files

00:02:02.000 --> 00:02:04.000
often involves a lossy encoding step.

00:02:04.000 --> 00:02:07.000
So if we encode something as a JPEG and decode it,

00:02:07.000 --> 00:02:10.000
then of course the bits that we get back are not going to be the bits we started with.

00:02:10.000 --> 00:02:12.000
But on the other hand, they shouldn't be too different.

00:02:12.000 --> 00:02:14.000
If we can somehow quantify how different they are,

00:02:14.000 --> 00:02:17.000
then we might be able to use even a lossy encode/decode pair

00:02:17.000 --> 00:02:21.000
as a test oracle for something like a JPEG encoder and decoder.

