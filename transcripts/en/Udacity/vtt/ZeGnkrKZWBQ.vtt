WEBVTT
Kind: captions
Language: en

00:00:00.360 --> 00:00:03.400
I need to reiterate that
those were just the basics.

00:00:03.400 --> 00:00:06.859
There are a lot of complications
that we're going to address now.

00:00:06.860 --> 00:00:10.879
First of all, in the previous example,
we should think about the for loop.

00:00:10.880 --> 00:00:13.820
Does the for
the Itself count for something?

00:00:13.820 --> 00:00:16.100
In order for the loop to work,

00:00:16.100 --> 00:00:20.000
you need to do a computation each time
to get the next letter in the string.

00:00:21.140 --> 00:00:26.250
Since this needs to happen one time for
every input letter, we can just add

00:00:26.250 --> 00:00:31.720
1 to the value before n, and
now we end up with 3n + 2.

00:00:31.720 --> 00:00:35.700
It turns out that it's actually really
hard to predict how many computations

00:00:35.700 --> 00:00:38.770
this pseudocode is going to take.

00:00:38.770 --> 00:00:41.940
For example,
a lower level language like C would

00:00:41.940 --> 00:00:45.949
break down the process a lot more and it
would take a lot more lines of code, but

00:00:45.950 --> 00:00:48.660
they would be doing less
work in the background.

00:00:48.660 --> 00:00:53.169
The Python version of this might
be about these many lines of code.

00:00:53.170 --> 00:00:56.710
But it would be doing a lot more in the
background because it's a higher level

00:00:56.710 --> 00:00:57.960
language.

00:00:57.960 --> 00:01:00.815
For example, let's look at this line.

00:01:00.815 --> 00:01:03.515
This line could take a different
number of computations

00:01:03.515 --> 00:01:06.605
based on the data structure
the cipher is using.

00:01:07.875 --> 00:01:09.855
Maybe we store data in a list, and

00:01:09.855 --> 00:01:13.612
we need to check each letter against
our current letter to solve the code.

00:01:14.662 --> 00:01:18.992
That could be as many as 26 checks for
each letter in our input string.

00:01:20.202 --> 00:01:26.202
So ultimately our efficiency calculation
might look a little more like this.

00:01:26.202 --> 00:01:30.262
Let's go back to those example input
strings we talked about before.

00:01:30.262 --> 00:01:33.232
Now if we start out with
a 10 letter input string,

00:01:33.232 --> 00:01:37.230
we end up with 292 computations.

00:01:37.230 --> 00:01:40.210
If we start out with 1 million
letters in our input string,

00:01:40.210 --> 00:01:44.500
we end up with 29 million
steps to go through.

00:01:44.500 --> 00:01:47.450
Because of our choice of data structure,
we're doing a lot

00:01:47.450 --> 00:01:51.840
more computations than we might if
we chose it a little bit smarter.

00:01:51.840 --> 00:01:54.880
Later, we'll talk a little bit more
about the efficiency of different

00:01:54.880 --> 00:01:56.690
types of data structures.

00:01:56.690 --> 00:02:00.420
But for now hopefully you realize the
importance of thinking about efficiency

00:02:00.420 --> 00:02:01.300
before writing code.

