WEBVTT
Kind: captions
Language: en

00:00:00.370 --> 00:00:02.210
Here is an algorithm for error defined.

00:00:02.210 --> 00:00:05.180
What elements in an agent's
classification knowledge

00:00:05.180 --> 00:00:08.670
may be potentially responsible for
his failure?

00:00:08.670 --> 00:00:12.410
Let us look at the problem where we
define the false success elements.

00:00:12.410 --> 00:00:13.630
I just said earlier.

00:00:13.630 --> 00:00:17.910
Potentially, the agent may deceive
a set of positive experiences, and

00:00:17.910 --> 00:00:22.200
a set of negative experiences,
not just one positive or one negative.

00:00:22.200 --> 00:00:25.730
First the intersection of all of
the features that are responsible for

00:00:25.730 --> 00:00:27.290
all the false successes.

00:00:27.290 --> 00:00:30.740
A false success again is, something
that we already fine a success.

00:00:30.740 --> 00:00:32.580
What was not a success like the pill,

00:00:32.580 --> 00:00:35.530
we identified it as a cup,
it was not a cup.

00:00:35.530 --> 00:00:39.460
First take the intersection of
all the features present for

00:00:39.460 --> 00:00:40.580
all the false successes.

00:00:40.580 --> 00:00:44.810
False-success is an object where
the agent identified as a success, but

00:00:44.810 --> 00:00:45.910
in fact was false.

00:00:45.910 --> 00:00:46.700
Like the pale.

00:00:46.700 --> 00:00:49.490
The agent identified that it was a cup,
but it wasn't.

00:00:49.490 --> 00:00:52.930
Then take the union of the features
present for all the true successes.

00:00:54.130 --> 00:00:58.210
A true success is something that
the agent classified as a success, and

00:00:58.210 --> 00:00:59.030
indeed was a success.

00:01:00.090 --> 00:01:03.500
Now remove all the assertions of
the union of the true successes,

00:01:03.500 --> 00:01:05.760
from the intersection
of the false successes,

00:01:05.760 --> 00:01:11.400
to identify those elements that
are present in the false successes only.

00:01:11.400 --> 00:01:12.630
So, to put that differently,

00:01:12.630 --> 00:01:16.350
start off by gathering together anything
that's ever present in a false success.

00:01:16.350 --> 00:01:20.510
Then, gather together everything that's
true for every single true success.

00:01:20.510 --> 00:01:22.070
Remove the things that are true for

00:01:22.070 --> 00:01:26.590
every true success, from the things that
are ever true for any false success.

00:01:26.590 --> 00:01:29.210
That way we get a list of only
the things that are true for

00:01:29.210 --> 00:01:31.220
some false successes.

00:01:31.220 --> 00:01:34.840
So we're defining suspicious true
success relationships, except that here,

00:01:34.840 --> 00:01:36.890
the operations are in reverse.

00:01:36.890 --> 00:01:37.630
&gt;&gt; So similarly,

00:01:37.630 --> 00:01:40.990
here we gather together everything
that's ever true about any true success,

00:01:40.990 --> 00:01:44.780
and then gather together things that
are true for every single false success.

00:01:44.780 --> 00:01:47.930
So every single false example
has these things in common.

00:01:47.930 --> 00:01:51.320
Then we remove the things that every
single fault example has in common,

00:01:51.320 --> 00:01:53.810
from the things that are true for
any true example.

00:01:53.810 --> 00:01:55.420
&gt;&gt; As you can see,
we are taking unions and

00:01:55.420 --> 00:01:58.680
intersections of features
characterizing different examples.

00:01:58.680 --> 00:02:02.040
The number of examples,
both positive and negative, needed for

00:02:02.040 --> 00:02:06.420
this algorithm to work well, depends
on the complexity of the concept.

00:02:06.420 --> 00:02:09.490
In general, the more features you
have the description of the object,

00:02:09.490 --> 00:02:11.680
more will be the number
of examples we'll need,

00:02:11.680 --> 00:02:14.320
to identify the features that
were responsible for our failure.

