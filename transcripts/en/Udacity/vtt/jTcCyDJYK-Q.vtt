WEBVTT
Kind: captions
Language: en

00:00:00.240 --> 00:00:04.227
We're going to make all this little hand
wavy stuff that I did, which I like,

00:00:04.227 --> 00:00:05.366
a bit more concrete,

00:00:05.366 --> 00:00:09.562
which you should appreciate because
I'm making abstraction more concrete.

00:00:10.642 --> 00:00:12.221
&gt;&gt; Thank you, thank you very much,
I'm here all week.

00:00:12.221 --> 00:00:13.505
In order to do that,

00:00:13.505 --> 00:00:18.130
we're going to actually introduce
a real formalism called options.

00:00:18.130 --> 00:00:22.570
And options are just a way of writing
down explicitly what we mean by this

00:00:22.570 --> 00:00:26.540
temporal abstraction new actions idea.

00:00:26.540 --> 00:00:31.530
&gt;&gt; Okay, and is this related to concepts
like the financial version of options?

00:00:31.530 --> 00:00:32.860
Like stock options?

00:00:32.860 --> 00:00:36.950
&gt;&gt; I'm going to say no because I've
never really understood those things.

00:00:36.950 --> 00:00:38.560
&gt;&gt; So maybe they are related.

00:00:38.560 --> 00:00:42.420
&gt;&gt; Probably not though, I'm going to say
that options are just a fancy way of

00:00:42.420 --> 00:00:44.940
saying choices is a fancy
way of saying actions.

00:00:44.940 --> 00:00:46.380
Here's what an option actually is.

00:00:46.380 --> 00:00:50.080
So an option is a tuple because
everything in life is a tuple and

00:00:50.080 --> 00:00:51.860
it has three parts to it.

00:00:51.860 --> 00:00:56.591
So in fact it's a triple,
it has I which is the initiation set,

00:00:56.591 --> 00:01:00.608
it has pi which is almost
always the case a policy, and

00:01:00.608 --> 00:01:03.940
then it has beta which
is a termination set.

00:01:03.940 --> 00:01:06.123
So let me explain what
I mean by those things.

00:01:06.123 --> 00:01:12.737
So the initiation set I is just the set
of states where the particular option or

00:01:12.737 --> 00:01:20.150
super action, like go to doorway in the
south, is actually legal to be executed.

00:01:20.150 --> 00:01:22.560
So this is where it may start or
initiate.

00:01:22.560 --> 00:01:25.720
So there's a set of states where
an action actually makes sense.

00:01:25.720 --> 00:01:30.200
So let's take your action, which was
go to the the door to the south, right?

00:01:30.200 --> 00:01:35.130
So that's clearly legal
inside the northeast corner,

00:01:35.130 --> 00:01:38.070
but I think the way you meant it anyway,

00:01:38.070 --> 00:01:42.920
it's not really something that you would
execute from, say, the southwest corner.

00:01:42.920 --> 00:01:44.220
That seem reasonable?

00:01:44.220 --> 00:01:47.120
&gt;&gt; Yeah, I feel like it sort of violates
the spirit a little bit if it's the case

00:01:47.120 --> 00:01:51.770
that you can navigate to that
south doorway from anywhere.

00:01:51.770 --> 00:01:54.800
Then why not just navigate to
the goal from anywhere, right.

00:01:54.800 --> 00:01:57.670
We're not really breaking it
down into simpler subproblems.

00:01:57.670 --> 00:01:58.330
Right exactly, so

00:01:58.330 --> 00:02:01.300
in fact we should just have one
action which is solve the problem.

00:02:01.300 --> 00:02:03.310
&gt;&gt; Right.
&gt;&gt; And you should just execute that.

00:02:03.310 --> 00:02:05.750
That's going to be at least as hard
to learn as the original problem and

00:02:05.750 --> 00:02:07.050
probably as hard to execute.

00:02:07.050 --> 00:02:09.196
If you already had that then there
was nothing to do in the first place.

00:02:09.196 --> 00:02:10.717
&gt;&gt; Is the aesthetic here sort of like,

00:02:10.717 --> 00:02:13.106
I don't know,
algorithm design in computer science?

00:02:13.106 --> 00:02:16.993
The sort of idea that you want to break
a problem up into subproblems but

00:02:16.993 --> 00:02:20.745
somehow have solved a little bit of
the main problem along the way in

00:02:20.745 --> 00:02:24.701
thinking of things like Quicksort and
Mergesort and so forth where you

00:02:24.701 --> 00:02:28.680
recursively solve the same kind of
problem, but it's not cyclical.

00:02:28.680 --> 00:02:31.640
It's not like you make no progress
because at each time you break down

00:02:31.640 --> 00:02:33.450
the problem it actually makes
it a little bit easier.

00:02:34.620 --> 00:02:39.320
&gt;&gt; Right, so in fact I think the word
abstraction here is quite important,

00:02:39.320 --> 00:02:42.520
we do abstraction when we code,
right, we create functions.

00:02:42.520 --> 00:02:45.910
And then we use those functions to
think about the problem at a more

00:02:45.910 --> 00:02:48.590
abstract level and it allows us
to solve the problem more easily.

00:02:48.590 --> 00:02:50.580
So it's yes,
I think that's a pretty good analogy,

00:02:50.580 --> 00:02:54.650
it's not a perfect analogy, there's not
really an input and an output here.

00:02:54.650 --> 00:02:58.885
But it's trying to solve
the same idea of modularity and

00:02:58.885 --> 00:03:00.059
re-usability for that matter.

00:03:01.320 --> 00:03:04.960
&gt;&gt; And it allows us to make
the problem easier to think about and

00:03:04.960 --> 00:03:05.930
easier to solve.

00:03:05.930 --> 00:03:07.920
&gt;&gt; Cool.
I like how computer science comes up

00:03:07.920 --> 00:03:09.445
even inside of computer science.

00:03:09.445 --> 00:03:11.570
&gt;&gt; Yes, computing is everywhere
it is computing all the way down.

