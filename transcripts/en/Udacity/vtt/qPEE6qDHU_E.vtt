WEBVTT
Kind: captions
Language: en

00:00:00.680 --> 00:00:02.420
So here's an example to explain why maybe

00:00:02.420 --> 00:00:04.630
the situation's not so bad after all. So let's

00:00:04.630 --> 00:00:06.480
look at a particular example. We've got our

00:00:06.480 --> 00:00:10.360
input space consisting of say, the first 10 integers.

00:00:10.360 --> 00:00:13.180
And our hypothesis space is, you take an

00:00:13.180 --> 00:00:15.850
input, and then you just return whether it's greater

00:00:15.850 --> 00:00:18.330
than or equal to some theta. So that's a

00:00:18.330 --> 00:00:21.760
parameter. And now, how big is the hypothesis space?

00:00:21.760 --> 00:00:23.450
&gt;&gt; What type is data?

00:00:23.450 --> 00:00:24.520
&gt;&gt; Let's say theta's a real number.

00:00:24.520 --> 00:00:26.660
&gt;&gt; Oh, so it's infinite. Infinite!

00:00:26.660 --> 00:00:29.910
&gt;&gt; Indeed it is. Now, on the other hand, what

00:00:29.910 --> 00:00:32.020
would you do to try to learn this? Can you use

00:00:32.020 --> 00:00:36.430
the algorithm that we talked about before to learn in this

00:00:36.430 --> 00:00:39.540
particular space? So, I guess what I'm asking is, is there

00:00:39.540 --> 00:00:42.310
a way you can sort of sneakily apply the ideas

00:00:42.310 --> 00:00:44.710
from before, now the ideas from before were that you actually

00:00:44.710 --> 00:00:47.680
keep track of all the hypotheses. And to keep the version

00:00:47.680 --> 00:00:51.340
space, and once you've seen enough examples that are randomly drawn,

00:00:51.340 --> 00:00:56.200
you would be able to know that you've epsilon-exhausted the version

00:00:56.200 --> 00:00:58.930
space, and then, ultimately, any hypothesis that's left is going to

00:00:58.930 --> 00:01:01.770
be okay. So, what could we possibly do to track all

00:01:01.770 --> 00:01:03.700
of these hypotheses? It's problematic, because

00:01:03.700 --> 00:01:05.410
there's an infinite number of them.

00:01:05.410 --> 00:01:07.490
&gt;&gt; Okay. I see where you're going with this. So when I

00:01:07.490 --> 00:01:09.050
asked you what type it was, you said it was a real

00:01:09.050 --> 00:01:13.260
number, but it would have been easier if it, theta weren't a

00:01:13.260 --> 00:01:16.390
real number, but were in fact, you know, a positive integer say,

00:01:16.390 --> 00:01:17.420
or a non-negative integer.

00:01:17.420 --> 00:01:20.060
&gt;&gt; That's true, though there's still an infinite number of those.

00:01:20.060 --> 00:01:22.590
&gt;&gt; True, but it doesn't matter because the size of

00:01:22.590 --> 00:01:25.361
X is, it's so finite. So any value of theta

00:01:25.361 --> 00:01:29.060
greater than ten for example It doesn't matter. It doesn't

00:01:29.060 --> 00:01:30.620
matter because it will always give you the same answer.

00:01:30.620 --> 00:01:33.175
&gt;&gt; Alright. So if we, what if we only track the

00:01:33.175 --> 00:01:39.300
non-negative integers 10 or below. This would be, what, it's finite.

00:01:41.150 --> 00:01:46.280
And it gives us the same answer, as if we had actually tracked the, the infinite

00:01:46.280 --> 00:01:49.330
hypothesis space. So there's kind of, well, I

00:01:49.330 --> 00:01:50.330
dunno, you had a, you had a good way

00:01:50.330 --> 00:01:51.550
of saying it before, do you want to say

00:01:51.550 --> 00:01:53.270
it again? What, what is the difference between

00:01:53.270 --> 00:01:55.300
kind of this hypothesis space that we're working

00:01:55.300 --> 00:01:58.440
with, and the hypothesis space as we defined it.

00:01:58.440 --> 00:02:02.740
&gt;&gt; So there's a there's a notion of syntactic hypothesis space which is

00:02:02.740 --> 00:02:03.950
all the things you could possibly

00:02:03.950 --> 00:02:06.490
write, and then there's the semantic hypothesis

00:02:06.490 --> 00:02:08.479
space which are the actual different

00:02:08.479 --> 00:02:10.680
functions that you are practically represented.

00:02:10.680 --> 00:02:11.820
&gt;&gt; Yeah, I like that, that, that you

00:02:11.820 --> 00:02:15.620
can make a distinction between semantically, say, finite

00:02:15.620 --> 00:02:18.940
hypothesis base and actually spec-, it specified syntactically

00:02:18.940 --> 00:02:21.620
infinitely. And you also have the example of

00:02:21.620 --> 00:02:24.930
of a decision tree. With discrete inputs as

00:02:24.930 --> 00:02:26.510
also being kind of like this. That we,

00:02:26.510 --> 00:02:28.140
you know, we, we generally think about only

00:02:28.140 --> 00:02:31.530
ones that split on a attribute once, but syntactically

00:02:31.530 --> 00:02:33.230
you could keep splitting on it. It just doesn't

00:02:33.230 --> 00:02:35.960
give you a semantically different tree. So, this is

00:02:35.960 --> 00:02:37.530
kind of at the heart of what we're going to

00:02:37.530 --> 00:02:40.300
be able to do to talk about how we can

00:02:40.300 --> 00:02:43.200
learn and if in an hypothesis space, more complicated

00:02:43.200 --> 00:02:45.870
ones than this example here. But at the same time,

00:02:45.870 --> 00:02:48.190
without having to track an infinite number of hypothesis,

00:02:48.190 --> 00:02:50.730
because there's just not that many, that are meaningfully different.

00:02:50.730 --> 00:02:51.430
&gt;&gt; I like that.

