WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
[Evans] The answer is all except for the third are true.

00:00:03.000 --> 00:00:07.000
The third is not true because encryption is generally faster than hashing.

00:00:07.000 --> 00:00:09.000
These 3 are really big problems with this scheme.

00:00:09.000 --> 00:00:11.000
Let's talk about the fourth one first.

00:00:11.000 --> 00:00:13.000
We need this key to decrypt.

00:00:13.000 --> 00:00:15.000
The program that's running on the server that needs to check passwords

00:00:15.000 --> 00:00:17.000
will need this key all the time,

00:00:17.000 --> 00:00:21.000
so chances are if the password file is compromised, the key is also compromised

00:00:21.000 --> 00:00:24.000
because it's available in memory, it's stored in this program,

00:00:24.000 --> 00:00:28.000
or it's readily accessible because we need it every time we check a password.

00:00:28.000 --> 00:00:31.000
The solution to this is that we don't actually need to invert the password

00:00:31.000 --> 00:00:33.000
to check it's correct.

00:00:33.000 --> 00:00:36.000
All we need to do is recompute from the entered password

00:00:36.000 --> 00:00:39.000
some function and check that with what's stored.

00:00:39.000 --> 00:00:42.000
So there's no reason to have a key here.

00:00:42.000 --> 00:00:46.000
The first reason is also true--that because we're encrypting the password,

00:00:46.000 --> 00:00:49.000
the output that's the stored password will reveal the length.

00:00:49.000 --> 00:00:53.000
The reason that's a bad idea, well, it reveals information about the password.

00:00:53.000 --> 00:00:57.000
It also helps an attacker out--tells them which passwords are short,

00:00:57.000 --> 00:01:00.000
and that helps the attacker know which ones to try and break.

00:01:00.000 --> 00:01:03.000
The easier way to fix this is to use a hash function as well.

00:01:03.000 --> 00:01:08.000
If we use a hash function, the size of output doesn't depend on the size of the input.

00:01:08.000 --> 00:01:12.000
So no matter how long the password is, we'll have the same number of output bits

00:01:12.000 --> 00:01:14.000
based on our hash function.

00:01:14.000 --> 00:01:16.000
The second one is a little more subtle.

00:01:16.000 --> 00:01:18.000
If we just use the hash function in a straightforward way,

00:01:18.000 --> 00:01:20.000
we won't save this problem.

00:01:20.000 --> 00:01:22.000
This problem is pretty important.

00:01:22.000 --> 00:01:26.000
If you look at typical passwords, many are the same.

00:01:26.000 --> 00:01:32.000
The most popular password, at least according to an analysis of leaked passwords,

00:01:32.000 --> 00:01:35.000
is 123456--

00:01:35.000 --> 00:01:37.000
if that's your password, you should probably change it--

00:01:37.000 --> 00:01:41.000
out of the 32 million passwords that were leaked.

00:01:41.000 --> 00:01:46.000
So an analysis of the 32 million passwords that were leaked by RockYou.com--

00:01:46.000 --> 00:01:49.000
and they do not store passwords in an encrypted format,

00:01:49.000 --> 00:01:52.000
so all the actual passwords were easily revealed--

00:01:52.000 --> 00:01:55.000
the most popular password was 123456.

00:01:55.000 --> 00:02:00.000
Over 290,000 people used that for their password.

00:02:00.000 --> 00:02:03.000
That's almost a 10th of a percent.

00:02:03.000 --> 00:02:05.000
So if this is your password, you should probably change it.

00:02:05.000 --> 00:02:09.000
Once you start looking at a set of a few thousand popular passwords,

00:02:09.000 --> 00:02:12.000
you're covering a large percentage of users.

00:02:12.000 --> 99:59:59.000
So this first approach fails on many accounts.

