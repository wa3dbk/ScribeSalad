WEBVTT
Kind: captions
Language: en

00:00:00.780 --> 00:00:03.770
As we discussed, one way to see
the subtlety of the difference between

00:00:03.770 --> 00:00:07.410
problems in P and
those that are in NP-complete,

00:00:07.410 --> 00:00:11.580
is to compare what it takes to solve
seemingly similar real world problems.

00:00:11.580 --> 00:00:13.510
Consider the shortest path problem.

00:00:13.510 --> 00:00:15.180
You're given two locations, and

00:00:15.180 --> 00:00:17.900
you want to find the shortest
valid route between them.

00:00:17.900 --> 00:00:20.560
Your phone does this in a matter of
milliseconds, when you ask it for

00:00:20.560 --> 00:00:21.540
directions.

00:00:21.540 --> 00:00:24.190
And it gives you an exact answer,
according to whatever model for

00:00:24.190 --> 00:00:25.870
distance it is using.

00:00:25.870 --> 00:00:28.130
This is computationally tractable.

00:00:28.130 --> 00:00:30.670
On the other hand consider
this warehouse scenario

00:00:30.670 --> 00:00:33.890
where a customer places an order for
several different items.

00:00:33.890 --> 00:00:36.500
And a person or
a robot has to go around and

00:00:36.500 --> 00:00:40.540
collect them before going to
the shipping area for them to be packed.

00:00:40.540 --> 00:00:43.220
Of course, we want to do
this as quickly as possible.

00:00:43.220 --> 00:00:45.400
This is called the traveling
salesman problem.

00:00:45.400 --> 00:00:47.340
And it is NP-complete.

00:00:47.340 --> 00:00:50.640
This problem also comes up in
the unofficial guide to Disney World

00:00:50.640 --> 00:00:53.920
which tries to tell you how to get to
all the rides as quickly as possible.

00:00:53.920 --> 00:00:56.770
This explains why your phone
can give you directions, but

00:00:56.770 --> 00:00:58.380
supply chain logistics,

00:00:58.380 --> 00:01:02.310
just figuring out how things should be
routed is a billion dollar industry.

00:01:02.310 --> 00:01:05.209
Actually however we don't even need
to change the shortest path so

00:01:05.209 --> 00:01:07.900
much to get a NP-complete problem.

00:01:07.900 --> 00:01:11.750
Instead of asking for the shortest path,
we can ask for the longest simple path.

00:01:11.750 --> 00:01:16.190
We have to say simple so we don't
just run around in cycles forever.

00:01:16.190 --> 00:01:19.090
That also would give us
an NP-complete problem.

00:01:19.090 --> 00:01:21.718
This isn't the only possible
pairing of similar P and

00:01:21.718 --> 00:01:23.720
NP-complete problems either.

00:01:23.720 --> 00:01:24.980
I'm going to list some more.

00:01:24.980 --> 00:01:27.060
If you aren't familiar with
these problems yet, don't worry,

00:01:27.060 --> 00:01:29.970
you will learn about them
by the end of the course.

00:01:29.970 --> 00:01:33.170
Vertex cover in bipartite
graphs is polynomial, but

00:01:33.170 --> 00:01:36.660
vertex cover in general
graphs is NP-complete.

00:01:36.660 --> 00:01:41.530
A class of optimization problems called
linear programming is NP, but if we

00:01:41.530 --> 00:01:46.230
restrict the solutions to integers,
then we get and NP-complete problem.

00:01:46.230 --> 00:01:48.380
Finding an Eulerian cycle in the graph,

00:01:48.380 --> 00:01:50.480
where you touch each
edge once is polynomial.

00:01:51.500 --> 00:01:52.450
On the other hand,

00:01:52.450 --> 00:01:57.440
finding a Hamiltonian cycle that touches
each vertex once is NP-complete.

00:01:57.440 --> 00:02:00.060
And lastly figuring out
whether a boolean formula

00:02:00.060 --> 00:02:03.030
with two literals per
clause is polynomial, but

00:02:03.030 --> 00:02:07.410
if there are three literals per clause,
then the problem is NP-complete.

00:02:07.410 --> 00:02:08.220
So you see,

00:02:08.220 --> 00:02:11.590
problems in P aren't always easy to
tell from those that are NP-complete.

00:02:11.590 --> 00:02:14.870
Yet in the real world,
when you encounter a problem,

00:02:14.870 --> 00:02:17.200
it's very important to know
which sort you are dealing with.

00:02:18.200 --> 00:02:20.810
If your problem is like
one of the problems in P,

00:02:20.810 --> 00:02:23.420
then you know that there should
be an efficient solution.

00:02:23.420 --> 00:02:26.900
And, you can avail yourself of
the wisdom of many other scientists

00:02:26.900 --> 00:02:29.590
who have thought hard about how to
efficiently solve these problems.

00:02:30.840 --> 00:02:35.020
On the other hand, if your problem is as
hard as one of the NP-complete problems,

00:02:35.020 --> 00:02:36.780
then some caution is in order.

00:02:36.780 --> 00:02:41.590
You can expect to be able to find exact
solutions for small enough instances.

00:02:41.590 --> 00:02:44.070
And you may be able to find
a polynomial algorithm that

00:02:44.070 --> 00:02:47.460
will give you an approximate
solution that is good enough, but

00:02:47.460 --> 00:02:50.800
you should not expect to find an exact
solution that will scale well.

00:02:52.050 --> 00:02:55.380
Being able to know which situation you
are in is one of the many practical

00:02:55.380 --> 00:02:56.970
benefits of studying complexity.

