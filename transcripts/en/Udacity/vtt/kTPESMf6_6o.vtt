WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.009
Now we are almost there.

00:00:02.009 --> 00:00:05.380
What I would like you to do now is think about

00:00:05.380 --> 00:00:08.380
when you analyze an algorithm using pen and paper,

00:00:08.380 --> 00:00:10.030
how would you go about that?

00:00:10.030 --> 00:00:13.120
What you basically say is every program here and your variables here,

00:00:13.120 --> 00:00:15.400
so how do you get from here to here?

00:00:15.400 --> 00:00:18.430
So basically, it's a number of rules that look like this.

00:00:18.430 --> 00:00:22.100
If we are at a certain line of the code,

00:00:22.100 --> 00:00:25.270
so say we are here, and usually that line of code will

00:00:25.270 --> 00:00:27.810
also use some variables, but it doesn't have to,

00:00:27.810 --> 00:00:29.510
but usually it will of course,

00:00:29.510 --> 00:00:32.500
so certain variables are set to a given value.

00:00:32.500 --> 00:00:35.030
Then we know what the program is going to do next.

00:00:35.030 --> 00:00:37.620
For example, it's going to jump to the next line of code,

00:00:37.620 --> 00:00:40.150
and it's going to modify this variable here.

00:00:40.150 --> 00:00:42.160
So how many of these rules are there?

00:00:42.160 --> 00:00:43.690
Well, for a single line of code,

00:00:43.690 --> 00:00:45.830
it depends on the variables here,

00:00:45.830 --> 00:00:49.370
and let's assume that one line of code uses a maximum of 3 variables.

00:00:49.370 --> 00:00:52.310
If you were to count how many of the rules there are,

00:00:52.310 --> 00:00:56.390
it's the number of different values that one variable can take

00:00:56.390 --> 00:00:59.710
times the number of different values that the second variable can take

00:00:59.710 --> 00:01:02.810
times the number of values that the third variable can take.

00:01:02.810 --> 00:01:04.750
So for one line of code,

00:01:04.750 --> 00:01:08.420
that's actually just O of 1 as the constant.

00:01:08.420 --> 00:01:09.410
Why is that?

00:01:09.410 --> 00:01:13.340
Well, because we set that on the RAM variables can not get arbitrarily large,

00:01:13.340 --> 00:01:16.100
so there's only a constant number

00:01:16.100 --> 00:01:18.350
of different values that a variable can take,

00:01:18.350 --> 00:01:21.450
so even if we have 3 different variables

00:01:21.450 --> 00:01:23.440
and consider all of the combinations,

00:01:23.440 --> 00:01:25.410
it will be a huge number usually,

00:01:25.410 --> 00:01:27.310
but it will be a constant number

00:01:27.310 --> 00:01:28.750
for one line of code.

00:01:28.750 --> 00:01:30.440
Now if we're not looking at one line of code

00:01:30.440 --> 00:01:32.510
but all lines of code,

00:01:32.510 --> 00:01:34.510
then this actually doesn't change,

00:01:34.510 --> 00:01:38.940
because we have a constant number of possibilities for each line in the code

00:01:38.940 --> 00:01:42.380
and the program has constant size just as before.

00:01:42.380 --> 00:01:46.080
So there's a constant number of rules

00:01:46.080 --> 00:01:48.560
that will tell us exactly what the machine is going to do

00:01:48.560 --> 00:01:50.130
in the deterministic case.

00:01:50.130 --> 00:01:53.060
We're going to go to the non deterministic case in a minute,

00:01:53.060 --> 99:59:59.000
because there of course, as we just found out, the if-then rules don't work.

