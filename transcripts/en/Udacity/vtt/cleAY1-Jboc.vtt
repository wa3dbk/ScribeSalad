WEBVTT
Kind: captions
Language: en

00:00:00.290 --> 00:00:03.690
Okay now I'd like to talk about group in a little more detail. By now you should

00:00:03.690 --> 00:00:06.950
understand that group's role is really to aggregate it's

00:00:06.950 --> 00:00:10.000
input in some way based on the operators specified.

00:00:11.080 --> 00:00:12.720
Here are a list of operators that we

00:00:12.720 --> 00:00:15.685
can use in grouping documents together in the aggregation

00:00:15.685 --> 00:00:20.240
framework. We've seen some several times. First simply selects

00:00:20.240 --> 00:00:25.250
the first documented group. Last, the last documented group.

00:00:25.250 --> 00:00:26.930
Max, min, and average, all do what you might

00:00:26.930 --> 00:00:30.750
expect, based on a numeric value we're calculating as part

00:00:30.750 --> 00:00:33.110
of a group. As one example, let's take a

00:00:33.110 --> 00:00:37.470
look at average. So, here we have an aggregation pipeline.

00:00:37.470 --> 00:00:40.510
And the idea here is to calculate the average

00:00:40.510 --> 00:00:44.710
number of re-tweets for any tweets using a particular hashtag.

00:00:44.710 --> 00:00:46.620
So we do an unwind on the hashtags array of

00:00:46.620 --> 00:00:50.370
the entities field. Then we're going to group, based on the

00:00:50.370 --> 00:00:53.100
text of the hashtag. So, this'll give us one

00:00:53.100 --> 00:00:56.560
document for every hashtag used in a given tweet.

00:00:56.560 --> 00:00:58.780
So then in the group stage here, we're going

00:00:58.780 --> 00:01:01.880
to aggregate based on the text, so based on

00:01:01.880 --> 00:01:04.989
the hashtag itself. And then I'm going to calculate

00:01:04.989 --> 00:01:08.700
an average based on the field retweet_count, which is

00:01:08.700 --> 00:01:12.070
a top-level field for tweets. Finally, we're going to

00:01:12.070 --> 00:01:15.420
sort, based on the retweet_avg. Okay, so this gives us

00:01:15.420 --> 00:01:18.890
an idea of where we might use average and what

00:01:18.890 --> 00:01:21.480
it looks like. The syntax is very similar to what

00:01:21.480 --> 00:01:24.180
we've seen with sum. Now what I'd like to do

00:01:24.180 --> 00:01:26.950
is nudge this discussion of operators along just a little

00:01:26.950 --> 00:01:29.510
bit, and I'd like to introduce a couple of additional

00:01:29.510 --> 00:01:33.850
operators. One is push, and the other is addToSet. These

00:01:33.850 --> 00:01:37.100
are extremely useful operators in a variety of different situations

00:01:37.100 --> 00:01:41.570
because these are operators that actually deal with arrays. Okay?

00:01:41.570 --> 00:01:43.410
So let's take a look at an example of where

00:01:43.410 --> 00:01:46.050
we might use something like this. We're going to look

00:01:46.050 --> 00:01:50.232
at an example involving addToSet. Essentially what addToSet does is,

00:01:50.232 --> 00:01:54.192
as it's accumulation function for a grouping, it adds values to

00:01:54.192 --> 00:01:56.928
an array, but does so by treating the array as

00:01:56.928 --> 00:01:59.736
a set, that is it won't add the same value more

00:01:59.736 --> 00:02:03.830
than once to the array we're accumulating in. Okay. So

00:02:03.830 --> 00:02:07.030
here's an example. Now in this example, what I'm doing is

00:02:07.030 --> 00:02:10.680
aggregating together all of the unique hashtags and grouping

00:02:10.680 --> 00:02:12.955
by the user screen name. So this is essentially

00:02:12.955 --> 00:02:15.400
all of the hashtags that an individual user has

00:02:15.400 --> 00:02:19.180
used in their tweets, but we're ignoring hashtags that a

00:02:19.180 --> 00:02:22.600
user has used in multiple tweets. So, here we're

00:02:22.600 --> 00:02:25.460
going to use addToSet to do that. And the way that

00:02:25.460 --> 00:02:28.980
this works is we're going to group, again we're going to

00:02:28.980 --> 00:02:32.160
specify as our id to define the grouping based on

00:02:32.160 --> 00:02:33.990
the screen name of the user creating the

00:02:33.990 --> 00:02:37.650
tweets. Okay? Note that we're unwinding, based on

00:02:37.650 --> 00:02:45.120
the hashtags array. So what we are going to do then is use addToSet, and for

00:02:45.120 --> 00:02:47.553
each hashtag the actual text of the hashtag,

00:02:47.553 --> 00:02:50.865
we're going to add that to this array,

00:02:50.865 --> 00:02:54.165
unique_hashtags, that's part of the group document for

00:02:54.165 --> 00:02:57.300
an individual user. Using addToSet ensures that no

00:02:57.300 --> 00:03:00.670
matter how many times a given hashtag occurs, that is no matter how many times

00:03:00.670 --> 00:03:04.950
a user used it in a given tweet. So, no matter how many times the group

00:03:04.950 --> 00:03:08.400
stage sees that text, it will be added

00:03:08.400 --> 00:03:11.658
one and only one time to this unique_hashtags

00:03:11.658 --> 00:03:16.010
array. And then I'm simply going to do a sort based on ID. So let's run this.

00:03:18.310 --> 00:03:21.210
Okay? And so, all we're getting out is a list of

00:03:21.210 --> 00:03:24.530
pairings for a screen name, and a list of all the

00:03:24.530 --> 00:03:27.170
unique hashtags they've used. Okay? So we can see that, for

00:03:27.170 --> 00:03:32.260
this particular user....1, 2, 3, 4, 5, 6 different hashtags, used,

00:03:32.260 --> 00:03:34.480
we don't know in how many different tweets, or how many

00:03:34.480 --> 00:03:38.460
times. This is essentially the vocabulary of hashtags for this particular

00:03:38.460 --> 00:03:40.570
user. And if we scroll through here we'll see, we'll see

00:03:40.570 --> 00:03:44.080
the vocabulary of hastags for all of the users in this collection.

00:03:44.080 --> 00:03:47.040
Now, what might be more satisfying here, is

00:03:47.040 --> 00:03:49.190
if we were to use something like sort based

00:03:49.190 --> 00:03:52.760
on the number of unique hashtags that individual

00:03:52.760 --> 00:03:56.030
users have written as part of their tweets. But

00:03:56.030 --> 00:03:58.270
that's when you require us to do something

00:03:58.270 --> 00:03:59.840
we haven't talked about yet, which is using the

00:03:59.840 --> 00:04:01.810
same operator in more than one group stage

00:04:01.810 --> 00:04:04.500
in an aggregation pipeline. We'll look at that next.

