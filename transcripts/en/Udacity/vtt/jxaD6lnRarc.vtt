WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:03.790
So, here's the empty shell of our program. We'll need a scanner to read the

00:00:03.790 --> 00:00:08.402
user input, but right now the code won't compile. It doesn't know what a

00:00:08.402 --> 00:00:13.378
scanner is. We need to import java.util.Scanner to tell the program where to

00:00:13.378 --> 00:00:20.075
find the code for the scanner. That's better. Now, we want to print the prompt.

00:00:20.075 --> 00:00:25.446
And I remember my colon and space at the end. So that there would be space for

00:00:25.446 --> 00:00:30.286
the user input and I now read in the word. I'm going to use the next line, I'll

00:00:30.286 --> 00:00:34.748
explain that in another minute. I'll make my book so that I can use it to do

00:00:34.748 --> 00:00:39.211
the calculations. And now, I can calculate the number of occurrences and print

00:00:39.211 --> 00:00:43.616
the result in a nice format. I'm safe I made any syntax errors with all that

00:00:43.616 --> 00:00:49.560
typing. Sure enough, misspelled occurrences. Thank goodness for the compiler.

00:00:49.560 --> 00:00:53.404
You saw this run before, so I won't run it again. There is that one question

00:00:53.404 --> 00:00:58.701
left over though. The next versus nextline. Let's look at the documentation. If

00:00:58.701 --> 00:01:05.087
I search for scanner and Java 7, go to the official documentation, and then

00:01:05.087 --> 00:01:12.427
search for the methods. Here they are, there are a lot of them, but here are

00:01:12.427 --> 00:01:22.029
the ones that start to be nextFloat. And next, nextBigDecimal. All right. The

00:01:22.029 --> 00:01:27.702
ones that return strings are next, next with a pattern, next with another

00:01:27.702 --> 00:01:36.279
pattern. Next line, all right. And these look like something else. nextLine has

00:01:36.279 --> 00:01:41.785
slightly awkward language. Advances this scanner past the current line and

00:01:41.785 --> 00:01:46.320
returns the input that was skipped. But what this means for us is that the

00:01:46.320 --> 00:01:50.950
scanner will give us a line of input. So, everything the user types before they

00:01:50.950 --> 00:01:56.435
hit Enter will get loaded in with next. If I find the documentation for next

00:01:56.435 --> 00:02:01.594
without the line. Here's next. It says finds and returns the next complete

00:02:01.594 --> 00:02:06.889
token from this scanner. Wants a complete token. Maybe there's more

00:02:06.889 --> 00:02:11.290
information. It says, a complete token is preceded and followed by input that

00:02:11.290 --> 00:02:16.196
matches the delimiter pattern. And then, talks about blocking while waiting for

00:02:16.196 --> 00:02:20.200
input to scan. You don't need to worry about that part too much. Basically,

00:02:20.200 --> 00:02:23.794
it's saying it'll wait until the user actually enters something. But this

00:02:23.794 --> 00:02:28.830
delimiter thing, maybe somewhere on this page it says what the delimiter is.

00:02:28.830 --> 00:02:33.141
Let's look for it using Ctrl+F. Delimiter. This looks like it's in the summary

00:02:33.141 --> 00:02:37.384
near the top of the page. A scanner breaks its input into tokens using a

00:02:37.384 --> 00:02:42.282
delimiter pattern, which by default, matches whitespace. We saw whitespace

00:02:42.282 --> 00:02:47.470
before, that was things like spaces and tabs that you can't see. I guess that

00:02:47.470 --> 00:02:50.898
makes sense. So, it gives you a chunk that is separated from other things by

00:02:50.898 --> 00:02:55.785
something like spaces. So, it seems like next would work fine by default if the

00:02:55.785 --> 00:03:01.933
user just wanted to search for one word, like Alice. But if they wanted to

00:03:01.933 --> 00:03:06.991
search for two words, like Mad Hatter, you would want to use nextLine.

