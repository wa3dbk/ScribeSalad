WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Hi, and welcome to the third office hours.

00:00:03.000 --> 00:00:05.000
We've got, again, more good questions.

00:00:05.000 --> 00:00:07.000
Let's get right at them. &amp;gt;&amp;gt;All right.

00:00:07.000 --> 00:00:13.000
The first one comes from Voythos, and Voythos is taking CS262 as well with Wes Weimer.

00:00:13.000 --> 00:00:17.000
In that class they talked about finding state machines as a representation

00:00:17.000 --> 00:00:20.000
of the underlying engine for regular expressions.

00:00:20.000 --> 00:00:25.000
In our implementation, is that actually what we did or did we do something different?

00:00:25.000 --> 00:00:27.000
That's a great question.

00:00:27.000 --> 00:00:33.000
We didn't explicitly show that, but there is a one-to-one correspondence between

00:00:33.000 --> 00:00:37.000
a regular expression and a finite state machine.

00:00:37.000 --> 00:00:42.000
And we can post some references, some supplementary material for that.

00:00:42.000 --> 00:00:47.000
But you can make up a little table of here is a regular expression--

00:00:47.000 --> 00:00:54.000
say the alt regular expression, a or b--and then here's a finite state machine.

00:00:54.000 --> 00:00:57.000
I guess one way to implement that would be you'd have a start state,

00:00:57.000 --> 00:01:01.000
you'd have two epsilon transitions to the a or b,

00:01:01.000 --> 00:01:04.000
and then two epsilon transitions coming back.

00:01:04.000 --> 00:01:07.000
So any regular expression corresponds one-to-one

00:01:07.000 --> 00:01:11.000
to a little collection of nodes in the finite state machine.

00:01:11.000 --> 00:01:14.000
That means you can go in either direction.

00:01:14.000 --> 00:01:16.000
Does that mean that we've actually implemented that?

00:01:16.000 --> 00:01:18.000
Well, it kind of depends on how you look at it.

00:01:18.000 --> 00:01:23.000
Yes, you could say that we've implemented it, because you can show what they look like,

00:01:23.000 --> 00:01:29.000
but we aren't really creating objects that correspond to these individual states.

00:01:29.000 --> 00:01:33.000
They're sort of existing ephemerally when we execute the program

00:01:33.000 --> 00:01:36.000
rather than being defined exactly ahead of time.

00:01:36.000 --> 00:01:38.000
In that sense, no.

00:01:38.000 --> 00:01:44.000
I guess, maybe in the more important sense, the types of manipulations we can do

00:01:44.000 --> 00:01:47.000
with what we implemented are slightly different than what you would do

00:01:47.000 --> 00:01:50.000
if you explicitly created these finite state machines--

00:01:50.000 --> 00:01:58.000
particularly this transition between deterministic and nondeterministic machines.

00:01:58.000 --> 00:02:03.000
That's a little hard to do exactly in the representation that we had,

00:02:03.000 --> 00:02:07.000
although you could do something very much like it by starting to memoize your functions and so on.

00:02:07.000 --> 00:02:14.000
You could arrive at the same place as you would by doing that transition with machines.

00:02:14.000 --> 00:02:18.000
Great. If you want an in depth discussion on finite state machines,

00:02:18.000 --> 00:02:21.000
you can check out the link below this video to Wes's course.

