WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
Hey, welcome back.

00:00:02.000 --> 00:00:05.000
I'm very happy to be here today with Sally Goldman.

00:00:05.000 --> 00:00:10.000
Sally is a professor at Washington University and is also a researcher at Google.

00:00:10.000 --> 00:00:17.000
We'd like to talk mostly about the process of choosing the right algorithm and data structure

00:00:17.000 --> 00:00:20.000
and how your programs are so much tied to that choice.

00:00:20.000 --> 00:00:23.000
[Sally Goldman, Professor, Washington Univ.]The big picture, I think, in terms of what we focused in the book

00:00:23.000 --> 00:00:28.000
is if I'm looking at a data structure for a problem, there are broad classes of data structures.

00:00:28.000 --> 00:00:33.000
Some data structures are very good just searching something with a unique ID.

00:00:33.000 --> 00:00:37.000
Other things may be good at finding--like I want to find if the word CAT, that substring,

00:00:37.000 --> 00:00:43.000
is part of a word, and so there's this broad class of data structures.

00:00:43.000 --> 00:00:49.000
Really, the encapsulation is as important as to understand these abstract data types or ADTs

00:00:49.000 --> 00:00:52.000
and understand which one of those fits your problem,

00:00:52.000 --> 00:00:55.000
because that is a fundamental decision, and there is fewer of them so it's easier.

00:00:55.000 --> 00:01:01.000
First of all, an invariant is something typically about your data that holds all the time.

00:01:01.000 --> 00:01:06.000
If I have something called search_tree, I may say that if I'm at a certain node

00:01:06.000 --> 00:01:10.000
everything on the left half is smaller and everything on the right half is bigger.

00:01:10.000 --> 00:01:16.000
Again, I think it helps just in understand and designing the data structure

00:01:16.000 --> 00:01:20.000
to remember the this is an important thing and I need to make sure that all the methods

00:01:20.000 --> 00:01:23.000
and all the operations I do preserve this.

00:01:23.000 --> 00:01:26.000
In that particular case, it allows me to search quickly.

00:01:26.000 --> 00:01:31.000
Without that invariant, I'd lose it, but at the same time it let's you formally prove correctness.

00:01:31.000 --> 00:01:33.000
It's a pretty good dual.

00:01:33.000 --> 00:01:37.000
I think it helps you reason about it informally and let's you formally, in fact, prove

00:01:37.000 --> 00:01:39.000
that you haven't forgotten any cases.

00:01:39.000 --> 00:01:41.000
How do you know you have the right answer?

00:01:41.000 --> 00:01:44.000
Certainly it's good to prove you're always going to have the right answer,

00:01:44.000 --> 00:01:49.000
but that proof is about the technique that you created.

00:01:49.000 --> 00:01:51.000
It doesn't say that your code is right.

00:01:51.000 --> 00:01:56.000
I think you actually want to prove rather informally at least that you're going

00:01:56.000 --> 00:01:59.000
to always have the right answer, but you need tests.

00:01:59.000 --> 00:02:03.000
Without unit tests bug will creep in.

00:02:03.000 --> 00:02:06.000
The book we wrote we have a couple thousand unit tests,

00:02:06.000 --> 00:02:09.000
and I'll tell you there are times in the end I'm like, oh, I can make this a little simpler.

00:02:09.000 --> 00:02:13.000
I didn't need this case, and all the unit tests start going red.

00:02:13.000 --> 00:02:16.000
Then I'd put a sentence about why you needed it.

00:02:16.000 --> 00:02:19.000
I think you actually need testing in the code to make sure the code actually

00:02:19.000 --> 00:02:24.000
really implemented what you intended and testing at the algorithmic level.

00:02:24.000 --> 00:02:27.000
Looking at the difference in dealing with algorithmic complexity,

00:02:27.000 --> 00:02:30.000
making sure you actually cover all the cases of the input,

00:02:30.000 --> 00:02:35.000
and dealing with the complexity of the code and different operating systems, different windows.

00:02:35.000 --> 00:02:39.000
Yeah, it's tricky and also everyone wants to try out different things,

00:02:39.000 --> 00:02:43.000
and so you have these different variations and the code gets a lot of cruft built into it

00:02:43.000 --> 00:02:46.000
that kind of can get it out of hand.

00:02:46.000 --> 00:02:50.000
I think that industry code is also important to keep that in check.

00:02:50.000 --> 00:02:52.000
What makes for good code?

00:02:52.000 --> 00:02:56.000
Clean--it should be fairly modular. You don't want the two-page method.

00:02:56.000 --> 00:03:00.000
You definitely want to make sure that commonly used blocks are reused

00:03:00.000 --> 00:03:06.000
and have some documentation on the methods whether in a separate file

00:03:06.000 --> 00:03:09.000
like if it's a C++ with an H file or something where it's all together.

00:03:09.000 --> 00:03:12.000
You definitely want to really say what the method is doing.

00:03:12.000 --> 00:03:18.000
In the end good code is code that other people can come and change and adapt.

