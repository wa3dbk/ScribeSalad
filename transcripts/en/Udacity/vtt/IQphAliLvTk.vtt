WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.000
The answer turns out to be none of these, but if you though ring, that was true for a little while.

00:00:05.000 --> 00:00:08.000
If you thought hypercube, that we true pretty for the same amount of time,

00:00:08.000 --> 00:00:12.000
and I actually thought the answer was hypercube until I drew out a picture

00:00:12.000 --> 00:00:15.000
and discovered that it wasn't. Here's why.

00:00:15.000 --> 00:00:17.000
Again, in the case for n = 1, it's just a single node.

00:00:17.000 --> 00:00:20.000
In the case of n = 2, it's one single node that's half the graph

00:00:20.000 --> 00:00:22.000
and one single node that's the other half of the graph,

00:00:22.000 --> 00:00:25.000
and individual subgraphs have their nodes randomly ordered,

00:00:25.000 --> 00:00:27.000
but there's just one of them so there's only one order.

00:00:27.000 --> 00:00:31.000
Then we connect the corresponding nodes, but there's just one of them, so it's just that.

00:00:31.000 --> 00:00:35.000
In the n = 4 case, we have two n = 2 graphs,

00:00:35.000 --> 00:00:40.000
and then the algorithms arbitrarily orders the two nodes and the two subgraphs,

00:00:40.000 --> 00:00:42.000
but it looks the same either way. If we flip this around, it still looks the same.

00:00:42.000 --> 00:00:46.000
Let's pretend I flip this one around, and then we connect up the corresponding nodes.

00:00:46.000 --> 00:00:49.000
Now we get something that is a ring. It's also a hypercube.

00:00:49.000 --> 00:00:51.000
Actually, all these have been hypercubes so far.

00:00:51.000 --> 00:00:53.000
Let's move up to n = 8.

00:00:53.000 --> 00:00:56.000
In the n = 8 case we first generate two n =4 graphs,

00:00:56.000 --> 00:00:58.000
which we know what they look like from before.

00:00:58.000 --> 00:01:02.000
Then we arbitrarily order these nodes and the two different graphs

00:01:02.000 --> 00:01:04.000
and connect up the corresponding nodes.

00:01:04.000 --> 00:01:06.000
This is where it gets sort of weird.

00:01:06.000 --> 00:01:10.000
In a normal hypercube, we would connect this corner, this corner, this corner.

00:01:10.000 --> 00:01:12.000
Let's start off that way.

00:01:12.000 --> 00:01:15.000
Because the nodes are randomly ordered, we could actually get something like this

00:01:15.000 --> 00:01:17.000
where the top is nice and parallel and the bottom is crossing.

00:01:17.000 --> 00:01:20.000
This is not a hypercube, but it's sort of hypercube-ish.

00:01:20.000 --> 00:01:24.000
As we grow this to larger and larger n, we get tanglier and tanglier structures.

00:01:24.000 --> 00:01:27.000
So, the nice thing about these structures is they do kind of have an essence

00:01:27.000 --> 00:01:32.000
of looking like real social network graphs. They have some complexity to them.

00:01:32.000 --> 00:01:36.000
This is still not quite what we're looking for, but let's do an analysis of this graph then call it a day.

00:01:36.000 --> 00:01:39.000
We can express the number of edges in the tangled hypercube again

00:01:39.000 --> 00:01:43.000
using a recurrence relation. Now the recurrence relation has this form..

00:01:43.000 --> 00:01:46.000
For an n-node graph we generate 2 n/2-nodes graphs, connect up

00:01:46.000 --> 00:01:50.000
the parallel nodes and that introduces n new edges.

00:01:50.000 --> 00:01:53.000
Once again, we can think about this as happening in a kind of recursion tree.

00:01:53.000 --> 00:01:56.000
We first consider generating a graph with n nodes.

00:01:56.000 --> 00:01:59.000
We do that by generating two graphs of n/2.

00:01:59.000 --> 00:02:03.000
Each of those actually requires two graphs of size n/4.

00:02:03.000 --> 00:02:06.000
Each of these levels we're going to be generating n new edges at this top level,

00:02:06.000 --> 00:02:10.000
n/2 for this subgraph, and n/2 for this subgraph, which adds up to n,

00:02:10.000 --> 00:02:16.000
n/4 for this one, n/4 for this one, n/4 for this one, n/4 for this one, which adds up to n.

00:02:16.000 --> 00:02:21.000
And I don't know if you can see what's going to happen here, but we get n

00:02:21.000 --> 00:02:23.000
edge contributions at each of these levels,

00:02:23.000 --> 00:02:26.000
and you may recall that there are log n levels to this tree.

00:02:26.000 --> 00:02:32.000
At the end of the day, the total number of edges that are created is n log n.

00:02:32.000 --> 00:02:35.000
This basic structure comes up a lot on algorithm analysis,

00:02:35.000 --> 00:02:37.000
which is one of the reasons that I was generating the graph this way.

00:02:37.000 --> 00:02:43.000
What we're going to get into next time is actually running some algorithms on graphs

00:02:43.000 --> 00:02:48.000
of various sorts, and trying to analyse the algorithms to see how long they actually take to run.

