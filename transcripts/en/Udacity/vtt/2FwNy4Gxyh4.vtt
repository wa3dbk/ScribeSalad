WEBVTT
Kind: captions
Language: en

00:00:00.290 --> 00:00:03.220
In the previous video, I introduced
a lot of new concepts that may or

00:00:03.220 --> 00:00:04.806
may not be familiar to you.

00:00:04.806 --> 00:00:06.270
To see all of these concepts in action,

00:00:06.270 --> 00:00:10.530
in this section we're going to build our
own web server in Python that not only

00:00:10.530 --> 00:00:14.480
renders web pages in a browser, but by
processing data submitted by the user,

00:00:14.480 --> 00:00:17.990
can create a unique web page each
time a user modifies the input.

00:00:17.990 --> 00:00:22.000
To get started let's create a new
Python file called webserver.py and

00:00:22.000 --> 00:00:25.000
save it in the same directory
as your restaurantmenu.db.

00:00:25.000 --> 00:00:29.520
And databasesetup.py files so we can
access it from our vagrant machine.

00:00:29.520 --> 00:00:32.990
Follow along with me using Sublime or
your favorite text editor.

00:00:32.990 --> 00:00:35.760
One of the cool things about Python is
that it comes with a large collection of

00:00:35.760 --> 00:00:38.035
libraries we can use
right out of the box.

00:00:38.035 --> 00:00:41.065
We will be using the HTTP base
server library extensively to

00:00:41.065 --> 00:00:42.305
create this project.

00:00:42.305 --> 00:00:45.775
Take a minute to skim over the HTTP
base server documentation on

00:00:45.775 --> 00:00:47.705
the official Python
documentation website.

00:00:47.705 --> 00:00:53.865
I will add from BaseHTTPServer
import BaseHTTPRequestHandler and

00:00:53.865 --> 00:00:57.835
HTTPServer to the first line of my
webserver.py file to be able to

00:00:57.835 --> 00:01:01.050
take advantage of this
BaseHTTPServer functionality.

00:01:01.050 --> 00:01:04.530
Our web server code will have two
main sections, the main method and

00:01:04.530 --> 00:01:05.800
the handler class.

00:01:05.800 --> 00:01:09.790
In main we instantiate our server and
specify what port it will listen on.

00:01:09.790 --> 00:01:13.450
Our handler code indicates what code
to execute based on the type of

00:01:13.450 --> 00:01:15.230
HTTP request that is sent to the server.

00:01:15.230 --> 00:01:19.040
I will start by coding a main method
as the entry point of my code.

00:01:19.040 --> 00:01:21.810
I'll add this block of code at
the end of my file to immediately run

00:01:21.810 --> 00:01:25.500
the main method when the Python
interpreter executes my script.

00:01:25.500 --> 00:01:28.170
Inside this main method,
I will add a try except block.

00:01:28.170 --> 00:01:31.650
The Python interpreter will try to
attempt the code inside the try block.

00:01:31.650 --> 00:01:35.650
And if a defined event occurs, we can
exit out of the code with an exception.

00:01:35.650 --> 00:01:38.050
The exception I want to
handle is KeyboardInterrupt.

00:01:38.050 --> 00:01:40.900
This is a built-in exception in
Python that can be triggered when

00:01:40.900 --> 00:01:43.430
the user holds Ctrl+C on the keyboard.

00:01:43.430 --> 00:01:45.090
Going back inside my try block,

00:01:45.090 --> 00:01:48.200
I will create an instance
of an HTTP server class.

00:01:48.200 --> 00:01:49.525
Looking at the documentation for

00:01:49.525 --> 00:01:53.280
HTTPServer, I see that I can
create a web server like so.

00:01:53.280 --> 00:01:57.690
In the documentation we also see that
HTTPServer is built off of a TCPServer

00:01:57.690 --> 00:02:01.380
class, indicating the transmission
protocol that this server will use.

00:02:01.380 --> 00:02:05.760
Server address is a tuple that contains
the host and port number for our server.

00:02:05.760 --> 00:02:09.370
I will leave host as an empty string and
specify our port number with an integer.

00:02:09.370 --> 00:02:11.860
I will define port in
a separate variable, and

00:02:11.860 --> 00:02:13.670
create my server instance as so.

00:02:13.670 --> 00:02:16.630
Notice that I just made up a name,
webserverHandler, for

00:02:16.630 --> 00:02:17.910
the request handler class.

00:02:17.910 --> 00:02:21.160
I will define my webserverHandler
in the next section of code.

00:02:21.160 --> 00:02:24.260
But first, let me add some
finishing code to the main method.

00:02:24.260 --> 00:02:27.140
After I create the server I'll add
a print statement to know that my

00:02:27.140 --> 00:02:28.450
server is running.

00:02:28.450 --> 00:02:32.860
Then I will use this serve_forever
function built into my HTTPServer to

00:02:32.860 --> 00:02:37.320
keep it constantly listening until I
call Ctrl+C or exit the application.

00:02:37.320 --> 00:02:40.579
Inside my KeyboardInterrupt exception
I will shut down the server by

00:02:40.579 --> 00:02:42.750
calling server.socket.close.

00:02:42.750 --> 00:02:44.010
And I have another print statement,

00:02:44.010 --> 00:02:46.700
just letting me know that
the server was properly stopped.

00:02:46.700 --> 00:02:47.770
Above my main method,

00:02:47.770 --> 00:02:52.690
I will now define the webserverHandler
class that I called in my HTTPServer,

00:02:52.690 --> 00:02:56.340
and have it extend from a class
called BaseHTTPRequestHandler.

00:02:56.340 --> 00:02:59.800
The do_GET function handles all get
requests our web server receives.

00:02:59.800 --> 00:03:02.770
In order to figure out which resource
we are trying to access, we will use

00:03:02.770 --> 00:03:06.960
a simple pattern matching plan that only
looks for the ending of our URL path.

00:03:06.960 --> 00:03:10.062
Let's create another try except
block for our do_GET method.

00:03:10.062 --> 00:03:13.980
The BaseHTTPRequestHandler
provides us a variable called path

00:03:13.980 --> 00:03:17.110
that contains the URL sent by
the client to the server as a string.

00:03:17.110 --> 00:03:21.700
I will make an if statement that looks
for the URL that ends with /hello.

00:03:21.700 --> 00:03:24.590
I will tell my web server
to send a response code of

00:03:24.590 --> 00:03:26.810
200 indicating a successful get request.

00:03:26.810 --> 00:03:30.420
I will use the send_header function to
indicate that I'm replying with text in

00:03:30.420 --> 00:03:34.430
the form of HTML to my client along
with this end_headers command which just

00:03:34.430 --> 00:03:38.028
sends a blank line indicating the end
of our HTTP headers in the response.

00:03:38.028 --> 00:03:41.430
Now that I've created the response
I can include some content to

00:03:41.430 --> 00:03:42.740
send back to the client.

00:03:42.740 --> 00:03:45.340
I'll create an empty string for
now and name it output.

00:03:45.340 --> 00:03:47.810
In the next line I will add
a message with some HTML and

00:03:47.810 --> 00:03:49.900
body tags to my output stream.

00:03:49.900 --> 00:03:54.460
I can use the self.wfile.write function
to send a message back to the client.

00:03:54.460 --> 00:03:56.970
So I'll go ahead and
put my output string there.

00:03:56.970 --> 00:03:58.190
I'm going to add a print statement for

00:03:58.190 --> 00:04:00.810
now, just so I can see my
output string in the terminal.

00:04:00.810 --> 00:04:02.540
This might come in handy for debugging.

00:04:02.540 --> 00:04:05.860
Then I can exit my if statement
with the return command.

00:04:05.860 --> 00:04:08.200
I will also write an exception for
IOErrors, and

00:04:08.200 --> 00:04:12.620
use the following line of code to notify
me of a 404 or file not found error.

00:04:12.620 --> 00:04:13.990
Now, I think I'm ready to test and

00:04:13.990 --> 00:04:15.690
see what I've written
thus far in the browser.

