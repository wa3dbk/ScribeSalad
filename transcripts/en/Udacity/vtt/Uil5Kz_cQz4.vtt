WEBVTT
Kind: captions
Language: en

00:00:00.120 --> 00:00:04.440
Let's discuss the solution for our branch prediction performance quiz.

00:00:04.440 --> 00:00:07.760
The first thing we want to do is figure out how many cycles are we

00:00:07.760 --> 00:00:11.290
spending per iteration of this loop in the case where we

00:00:11.290 --> 00:00:16.340
are fetching nothing until we are sure what to fetch. There is a trick to this.

00:00:16.340 --> 00:00:21.550
Which is when we fetch the ADDI here we don't know if it is a branch.

00:00:21.550 --> 00:00:26.420
So we are not sure what to fetch in the next cycle. When the ADDI moves to

00:00:26.420 --> 00:00:32.720
the decode stage at the end of that cycle we know that it's not a branch. So

00:00:32.720 --> 00:00:38.010
actually the ADDI's costs us two cycles. One to fetch it and

00:00:38.010 --> 00:00:43.600
then there is a pipeline bubble untill we can decode it. Similarly, the add

00:00:43.600 --> 00:00:48.530
costs us two cycles. One to fetch it, one to be sure that it's not a branch.

00:00:48.530 --> 00:00:53.640
For a branch, we fetch it in once cycle, we decode it in the next cycle,

00:00:53.640 --> 00:00:57.020
we're still not sure what to fetch, because now that we know it's a branch,

00:00:57.020 --> 00:01:02.370
we need to know whether it's taken or not. So the branch costs us three cycles.

00:01:02.370 --> 00:01:05.780
When the branch is in the earlier stage we have two pipeline bubbles

00:01:05.780 --> 00:01:09.910
already because we wouldn't fetch anything yet. And only after that,

00:01:09.910 --> 00:01:14.310
we know what to fetch. So there are three cycles worth of branch and

00:01:14.310 --> 00:01:17.390
doing nothing before we can fetch the next instruction. So

00:01:17.390 --> 00:01:23.340
overall, we're spending seven cycles per iteration of this loop.

00:01:23.340 --> 00:01:26.990
Now let's see what happens with a perfect predictor.

00:01:26.990 --> 00:01:30.780
With a perfect predictor, when we are fetching the ADD,

00:01:30.780 --> 00:01:36.650
we can perfectly predict that the next instruction to fetch is this second ADD.

00:01:36.650 --> 00:01:42.080
So we spend one cycle here, one cycle here, and with a perfect predictor once we

00:01:42.080 --> 00:01:46.250
have fetched this branch we magically know that we should be fetching this ADDI.

00:01:46.250 --> 00:01:50.945
So we spend one cycle here for a total of three cycles. So the speed up of

00:01:50.945 --> 00:01:56.810
having a perfect predictor, in this case, is 7 over three, which is 2.33.

00:01:56.810 --> 00:02:01.950
So with a perfect predictor, we would have more than twice the performance than

00:02:01.950 --> 00:02:06.050
we're having when fetching nothing until we are sure what to fetch.

