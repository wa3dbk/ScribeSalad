WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
The answer is the attacker can learn both the length of m and which blocks

00:00:03.000 --> 00:00:08.000
in the message are equal. The attacker learns the length because the length

00:00:08.000 --> 00:00:12.000
of this ciphertext is actually equal to the lenght of m.

00:00:12.000 --> 00:00:15.000
The output for encryption functions is the same length as its input

00:00:15.000 --> 00:00:19.000
so we know that these lengths are equal. It's assumed that

00:00:19.000 --> 00:00:23.000
file contents m were an even number of blocks, since we're dividing m into

00:00:23.000 --> 00:00:26.000
If it's not, we'll have to do something about that.

00:00:26.000 --> 00:00:30.000
And we'll get to that soon, but the solution to that is to add padding.

00:00:30.000 --> 00:00:33.000
The other issue, which is a more serious one in this case

00:00:33.000 --> 00:00:36.000
is the attacker learns which blocks in m are equal.

00:00:36.000 --> 00:00:39.000
This may not sound like such a big problem, if we're thinking of

00:00:39.000 --> 00:00:44.000
the blocks as 128 random bits, maybe the probability that two blocks are equal

00:00:44.000 --> 00:00:49.000
is actually very low. We'll see later--this class is not quite as low as you might guess

00:00:49.000 --> 00:00:52.000
but the message is not random bits. The message, or the file,

00:00:52.000 --> 00:00:57.000
if we're thinking of these as 8-bit characters, well,

00:00:57.000 --> 00:01:02.000
128 bits is only 16 characters. If they're Unicode characters, well then we have

00:01:02.000 --> 00:01:05.000
more than one byte per character. This could get down to

00:01:05.000 --> 00:01:07.000
a pretty small number of characters. There are certainly lots of sequences

00:01:07.000 --> 00:01:10.000
in many files that would be 16 characters long.

00:01:10.000 --> 00:01:14.000
that could be repeated. So this is a pretty large amount of information to leak.

00:01:14.000 --> 00:01:18.000
We want to find a way to encrypt our file that doesn't do that.

00:01:18.000 --> 00:01:22.000
Ways of using ciphers like this are called Modes of Operation.

00:01:22.000 --> 00:01:27.000
The one that I just described is known as Electronic Codebook Mode.

00:01:27.000 --> 00:01:31.000
And the reason for that is that you can think of having a book

00:01:31.000 --> 00:01:39.000
that for each input message, 128 bits of input, there are (2^128) - 1 inputs

00:01:39.000 --> 00:01:42.000
You would be able to look up the value of encrypting that message.

00:01:42.000 --> 00:01:47.000
So you can have a codebook that gives you for each input the 128-bit

00:01:47.000 --> 00:01:49.000
output that corresponds to that input.

00:01:49.000 --> 00:01:55.000
And this would be a really big book if we assume we could get about 10,000

00:01:55.000 --> 00:01:58.000
entries on a page, and each page weighs five grams,

00:01:58.000 --> 00:02:04.000
well, this would be about 1.7 * 10^32 kg to carry around.

00:02:04.000 --> 00:02:08.000
Adn that's just for one key. So it's really not practical to think of this as

00:02:08.000 --> 00:02:12.000
being a physical codebook today, but this is really the same thing

00:02:12.000 --> 00:02:15.000
that early codebooks did. They just provided one-to-one mapping

00:02:15.000 --> 00:02:19.000
between inputs and keys. And that's exactly how we're using AES here

00:02:19.000 --> 00:02:22.000
is to provide that mapping, and we're using the same mapping every time

00:02:22.000 --> 00:02:25.000
we need to encrypt the same value, we're getting the same output.

00:02:25.000 --> 00:02:28.000
This is the problem that we mentioned earlier,

00:02:28.000 --> 00:02:32.000
that it doesn't hide repetition in the message.

00:02:32.000 --> 00:02:36.000
Another problem it has is that someone could scramble--

00:02:36.000 --> 00:02:39.000
an attacker could move blocks around--could replace blocks--could change things--

00:02:39.000 --> 00:02:42.000
and it would still decrypt to a perfectly valid message,

00:02:42.000 --> 00:02:43.000
just with the blocks in a different order.

00:02:43.000 --> 00:02:47.000
So those are problems with the Electronic Codebook Mode

00:02:47.000 --> 00:02:50.000
We're going to look at some alternatives that avoid some of those problems.

