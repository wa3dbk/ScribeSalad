WEBVTT
Kind: captions
Language: en

00:00:00.980 --> 00:00:02.110
So one of the things we can do with

00:00:02.110 --> 00:00:04.600
strings that we can't do with numbers, is we can

00:00:04.600 --> 00:00:09.010
extract subsequences from the strings. So remember what a string

00:00:09.010 --> 00:00:11.380
is, is a sequence of characters. If we have a

00:00:11.380 --> 00:00:15.660
string, we can use the square brackets to extract

00:00:15.660 --> 00:00:18.050
parts of that string. So if we have the string

00:00:18.050 --> 00:00:22.395
udacity, and we use the square bracket, with the value

00:00:22.395 --> 00:00:26.570
0, that would select the zeroth character from the string.

00:00:26.570 --> 00:00:28.630
The characters of the string are indexed starting

00:00:28.630 --> 00:00:33.040
from 0, so the result of index 0,

00:00:33.040 --> 00:00:34.800
is the string with just the letter u.

00:00:35.900 --> 00:00:38.070
The expression inside the square brackets can be

00:00:38.070 --> 00:00:44.160
anything that evaluates to a number. So we could have, 1 plus 1 in here. 1

00:00:44.160 --> 00:00:51.480
plus 1 evaluates to the number 2. And at position 2, we find the letter a,

00:00:51.480 --> 00:00:53.960
so the value of this would be the string containing

00:00:53.960 --> 00:00:56.750
the single letter a. This looks a little strange and

00:00:56.750 --> 00:00:59.620
we wouldn't normally use indexing with the string literal like

00:00:59.620 --> 00:01:02.680
this, but it does work. It looks a lot more normal

00:01:02.680 --> 00:01:04.989
when we're doing it with a variable. We've initialized the

00:01:04.989 --> 00:01:09.720
variable name to the string Dave. Then when we do name

00:01:09.720 --> 00:01:12.370
index 0, whatever the variable name is, that will give

00:01:12.370 --> 00:01:16.490
us the first letter of that string, in this case it's

00:01:16.490 --> 00:01:21.510
the uppercase D. Let's try that in the Python interpreter. So here, I've defined

00:01:21.510 --> 00:01:26.325
the variable name, with the value, the string Dave. And I'm printing name index

00:01:26.325 --> 00:01:30.920
0. I get the first letter. If I try instead, to

00:01:30.920 --> 00:01:35.410
print name index 3, that will give us the fourth letter, the e.

00:01:36.680 --> 00:01:41.710
Suppose I tried to do name index 4. Well, there's no character

00:01:41.710 --> 00:01:44.490
at position 4, remember that the indexes start at 0,

00:01:44.490 --> 00:01:48.370
so this is 0, 1, 2, 3. When I run this,

00:01:49.410 --> 00:01:51.070
what I get is an error. I get an error

00:01:51.070 --> 00:01:54.700
because I've asked for position 4 of the string; that's out

00:01:54.700 --> 00:01:56.850
of range, so the error I get says that that

00:01:56.850 --> 00:02:00.860
string index is out of range. What I can do is

00:02:00.860 --> 00:02:04.360
use negative numbers. When I use negative numbers in my index

00:02:04.360 --> 00:02:06.990
it starts counting from the back of the string. So name

00:02:06.990 --> 00:02:12.400
index negative 1 will go as the last character in the string. If I do name index

00:02:12.400 --> 00:02:19.760
negative 2, that will give us the next to last character which is the v.

