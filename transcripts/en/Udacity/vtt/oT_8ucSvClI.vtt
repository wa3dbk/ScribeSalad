WEBVTT
Kind: captions
Language: en

00:00:00.560 --> 00:00:03.960
Okay. So here's some practical matters, Michael. I mentioned

00:00:03.960 --> 00:00:06.560
one of them before, and that is that mimic

00:00:06.560 --> 00:00:10.670
does well with structure. When the optimal values that

00:00:10.670 --> 00:00:13.570
you care about depend only on the structure, as

00:00:13.570 --> 00:00:16.020
opposed to specific values, mimic tends to do pretty

00:00:16.020 --> 00:00:20.140
well. By contrast Randomize hill climbing, genetic algorithms. These

00:00:20.140 --> 00:00:22.540
other things that we've looked at before can sometimes

00:00:22.540 --> 00:00:26.630
get confused by two different values that are both optima

00:00:26.630 --> 00:00:29.370
but look very different from one another. Where it's the

00:00:29.370 --> 00:00:32.980
structure that matters and not the actual values. So, the chain

00:00:32.980 --> 00:00:35.570
example before where you had alternating values as one of those

00:00:35.570 --> 00:00:39.810
cases where it's easy for randomized algorithms that only look for

00:00:39.810 --> 00:00:42.480
point values to get confused. 'because their basically being drawn

00:00:42.480 --> 00:00:46.220
in multiple directions at once. The quiz also brought up another

00:00:46.220 --> 00:00:48.630
point which is worth mentioning here was that mimic and with

00:00:48.630 --> 00:00:52.485
anything that tries to do this kind of search through probability

00:00:52.485 --> 00:00:55.770
[UNKNOWN] is that it's an issue of representing everything.

00:00:55.770 --> 00:00:57.380
That is it's not enough just to be able to

00:00:57.380 --> 00:01:00.900
represent a probability distribution of the [UNKNOWN]. You really

00:01:00.900 --> 00:01:03.430
want to be able to represent everything in between as

00:01:03.430 --> 00:01:07.890
you move through probability space toward your answer. This

00:01:07.890 --> 00:01:11.990
is the universal symbol for moving through probability space. You

00:01:11.990 --> 00:01:15.480
don't just want to represent here at the end and

00:01:15.480 --> 00:01:17.620
here at the beginning which is pretty easy because uniform

00:01:17.620 --> 00:01:22.440
distribution, but can you represent this point? Can you represent this point?

00:01:22.440 --> 00:01:25.860
And if you can't are you going to end up getting stuck. And

00:01:25.860 --> 00:01:29.950
actually turns out that mimic can get stuck in local optimal though

00:01:29.950 --> 00:01:34.014
it typically does not optima because you get randomize your search for optima.

00:01:34.014 --> 00:01:34.460
&gt;&gt; Hm. I see.

00:01:34.460 --> 00:01:38.000
&gt;&gt; But the problem of local optima is still a problem of local

00:01:38.000 --> 00:01:42.640
optima. Now, when I say something like you get randomized restarts for free,

00:01:42.640 --> 00:01:45.450
I'm actually cheating a little bit and hiding something which is

00:01:45.450 --> 00:01:48.130
a little bit more important, which is what you really get

00:01:48.130 --> 00:01:52.230
for free is probability theory. So there's a hundred, literally, hundreds

00:01:52.230 --> 00:01:55.650
of years of work on how to think about representing probability distributions

00:01:55.650 --> 00:01:57.500
and what you can do with them and there are terms

00:01:57.500 --> 00:02:00.680
like important sampling and rejection sampling And all these kinds of

00:02:00.680 --> 00:02:04.090
tools that we have for representing probability distributions that you ca

00:02:04.090 --> 00:02:08.139
actually inherit with something like Mimic for dealing with these painful cases

00:02:08.139 --> 00:02:10.300
where you might not be able to represent distributions.

00:02:10.300 --> 00:02:14.800
&gt;&gt; But the single most important thing to me about Mimic or what to get out

00:02:14.800 --> 00:02:17.990
of here is that representing structure does matter.

00:02:17.990 --> 00:02:19.920
But you pay a price. And that price

00:02:19.920 --> 00:02:23.050
basically boils down to, time. So the question

00:02:23.050 --> 00:02:27.800
we might ask ourselves, is, what is the

00:02:27.800 --> 00:02:31.950
sort of practical time complexity of mimic? And,

00:02:31.950 --> 00:02:34.720
it really boils down to something very simple.

00:02:34.720 --> 00:02:38.240
Let me just share a fact with you Michael. Okay. I

00:02:38.240 --> 00:02:41.470
have run this algorithm on many, many, many examples and I've

00:02:41.470 --> 00:02:43.100
compared it to simulated [INAUDIBLE].

00:02:43.100 --> 00:02:45.030
I've compared it to [INAUDIBLE] algorithms.

00:02:45.030 --> 00:02:47.390
I've compared it to randomized hill climbing. And it works pretty

00:02:47.390 --> 00:02:49.360
well for the sorts of examples I've come up with. And

00:02:49.360 --> 00:02:52.100
here's a little fact that I just want to give you.

00:02:52.100 --> 00:02:56.400
Mimic tends to run orders of magnitude fewer iterations. And I'm

00:02:56.400 --> 00:02:59.750
not exaggerating here; I mean that if I run Simulated Annealing,

00:02:59.750 --> 00:03:03.510
it might take 100,000 iterations for something like

00:03:03.510 --> 00:03:08.420
Simulated Annealing, but for Mimic, it might take only

00:03:08.420 --> 00:03:11.640
a hundred. And this is consistently true, so

00:03:11.640 --> 00:03:14.110
it turns out that that's not good enough. It

00:03:14.110 --> 00:03:15.860
turns out that the fact that Mimic can

00:03:15.860 --> 00:03:18.850
do something in three, four, five, six, seven orders

00:03:18.850 --> 00:03:21.580
of magnitude fewer iterations Is it an argument

00:03:21.580 --> 00:03:23.230
for always using it? Can you imagine one now?

00:03:23.230 --> 00:03:25.220
&gt;&gt; because it might give a worse answer?

00:03:25.220 --> 00:03:27.360
&gt;&gt; Well, in practice it doesn't. So, these are

00:03:27.360 --> 00:03:31.260
cases where both simulated [UNKNOWN] and mimic, or randomized hill

00:03:31.260 --> 00:03:34.780
climbing or genetic algorithms actually eventually do find the answer.

00:03:34.780 --> 00:03:37.740
Mimic just finds it in orders of magnitude, fewer iterations.

00:03:38.770 --> 00:03:40.370
&gt;&gt; But you're counting iterations.

00:03:40.370 --> 00:03:40.563
&gt;&gt; Mm-hm.

00:03:40.563 --> 00:03:42.590
&gt;&gt; You didn't control for the fact that Different

00:03:42.590 --> 00:03:45.380
algorithms, can take different times for a single iteration.

00:03:45.380 --> 00:03:47.640
&gt;&gt; That's exactly right. So, what do you think?

00:03:47.640 --> 00:03:50.190
If I were to compare simulated annealing to mimic,

00:03:50.190 --> 00:03:53.380
which do you think take, the, takes more time for any given iteration?

00:03:53.380 --> 00:03:55.510
&gt;&gt; Well simulated annealing just does this little tiny

00:03:55.510 --> 00:03:57.660
step, right? It like, computes a bunch of neighbors

00:03:57.660 --> 00:04:00.240
and then does a probability comparrison, and then, takes

00:04:00.240 --> 00:04:03.800
a step. Mimic is drawing this sample, estimating a

00:04:03.800 --> 00:04:07.190
bunch of parameters, then yeah. I guess the other

00:04:07.190 --> 00:04:10.660
way around. It's drawing from a distribution. It's computing

00:04:10.660 --> 00:04:12.980
which things are say above the median performance, and

00:04:12.980 --> 00:04:15.380
then it's re-estimating a new distribution. And then that's

00:04:15.380 --> 00:04:17.390
the end of the iteration. Depending on how many samples

00:04:17.390 --> 00:04:19.420
it takes to do that, it's, it could take a

00:04:19.420 --> 00:04:23.330
very long time, and in particular, it's going to always be

00:04:23.330 --> 00:04:25.390
a lot more samples than what simulated annealing is doing.

00:04:25.390 --> 00:04:29.560
&gt;&gt; Almost certainly. So, when would you think that MIMIC would still be worth

00:04:29.560 --> 00:04:31.890
using in a case like that, where we know that we can get to the

00:04:31.890 --> 00:04:34.290
answer, but simulated annealing will take orders

00:04:34.290 --> 00:04:37.250
of magnitude more iterations, MIMIC will take

00:04:37.250 --> 00:04:40.440
fewer iterations? So when would it still be worth it to take the one with

00:04:40.440 --> 00:04:43.070
fewer iterations even though east, each iteration is

00:04:43.070 --> 00:04:46.870
expensive? Prints algorithm, quadratic this that and the other.

00:04:46.870 --> 00:04:50.410
&gt;&gt; Oh yeah, grab at that part, hm.

