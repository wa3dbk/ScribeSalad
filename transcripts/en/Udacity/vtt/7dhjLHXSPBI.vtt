WEBVTT
Kind: captions
Language: en

00:00:00.260 --> 00:00:02.020
So one of the approaches for

00:00:02.020 --> 00:00:06.610
eliminating false dependencies is to duplicate register values.

00:00:06.610 --> 00:00:10.860
Let's see how that would work. We have an instruction here that adds R2 and

00:00:10.860 --> 00:00:17.220
R3 and puts the result in R1. Then we have R1 minus R5 goes into R4.

00:00:17.220 --> 00:00:23.480
Then we have R4 plus 1 goes into R3. Then we have R8 minus R9 goes into R4.

00:00:23.480 --> 00:00:28.900
And sometime later, we have an instruction that uses R4.

00:00:28.900 --> 00:00:32.150
Here we have what happens in some cycle. Let's call it Cycle 100.

00:00:32.150 --> 00:00:37.500
And in the next two cycles. And let's assume that Cycle 100 is when this

00:00:37.500 --> 00:00:44.220
instruction can execute. Now what happens is, after we execute this instruction,

00:00:44.220 --> 00:00:49.830
it can supply the register value R1 through forwarding to the next instruction,

00:00:49.830 --> 00:00:56.030
so we have that this instruction can execute here. And then R4 can be supplied

00:00:56.030 --> 00:01:02.250
to the next instruction, so it can execute here. However, this instruction,

00:01:02.250 --> 00:01:07.180
which is doing R 8 minus R 9 could actually execute here. So the problem with

00:01:07.180 --> 00:01:12.500
false dependencies, occurs in that R 4 is written by this and also this

00:01:12.500 --> 00:01:17.570
instruction, so let's see which final value of R 4 ends up in the register, so

00:01:17.570 --> 00:01:23.040
that it is used much later here. Well, if this is in execution stage, let's say

00:01:23.040 --> 00:01:28.510
that we have the memory stage next and the write register stage next. Meanwhile,

00:01:28.510 --> 00:01:33.260
this instruction goes through the MEM stage here and then write register here.

00:01:33.260 --> 00:01:38.530
So, as you can see, we first write this R4 and

00:01:38.530 --> 00:01:44.980
only then write this R4, which means that the final value of register R4.

00:01:44.980 --> 00:01:48.840
And that is the value that will be read by this instruction is actually going to

00:01:48.840 --> 00:01:54.940
come from this instruction and that should not be happening.

00:01:54.940 --> 00:02:00.490
So in order to fix this, one way is to again duplicate the registered values.

00:02:00.490 --> 00:02:04.610
So the idea is that when this instruction writes to the register of 4,

00:02:04.610 --> 00:02:08.020
it writes to a version of register of 4.

00:02:08.020 --> 00:02:12.050
And then another value is stored to another version of R4, but

00:02:12.050 --> 00:02:16.020
we remember both versions. So that's why it's called duplication, pretty much.

00:02:16.020 --> 00:02:21.240
We don't store only one value for R4. We store all the possible values that R4

00:02:21.240 --> 00:02:27.500
had. And then, an instruction that wants R4, will have to search

00:02:27.500 --> 00:02:33.100
among all the possible versions of R4, to find the one that is before it.

00:02:33.100 --> 00:02:37.480
But the latest one before it. So in this case, we will search for R4 and

00:02:37.480 --> 00:02:43.110
find this one, and this one, and this is the latest one that we should be using.

00:02:43.110 --> 00:02:48.160
That requires two version of R4 to exist. Meanwhile this instruction here.

00:02:48.160 --> 00:02:52.900
When it executes, we'll look for version of R4 and again find that

00:02:52.900 --> 00:02:58.540
there really are two versions that it big be using R4 here and R4 here.

00:02:58.540 --> 00:03:03.490
But because this one is coming after this instruction it should be ignored and

00:03:03.490 --> 00:03:07.780
thus we use this value. So everything will be correct but it requires us to

00:03:07.780 --> 00:03:12.240
keep multiple versions of each registers which is really complicated.

