WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
We're going to the test suite, we're going to go to the test removed.

00:00:03.000 --> 00:00:07.000
After we've removed everything from a tree, we're going to remove an element that we know

00:00:07.000 --> 00:00:10.000
is not on the tree and of course after we removed everything from the tree, anything we choose

00:00:10.000 --> 00:00:13.000
should not be on the tree so minus 999.

00:00:13.000 --> 00:00:15.000
We'll work this well as any, so we're going to go ahead

00:00:15.000 --> 00:00:18.000
and save that and run the coverage tool again. 

00:00:18.000 --> 00:00:20.000
So this time something interesting happens.   

00:00:20.000 --> 00:00:25.000
What happened is the removed method for this spaly tree on removal of minus 999 

00:00:25.000 --> 00:00:29.000
so on the line that we just added causes an exception re-thrown in this splay function   

00:00:29.000 --> 00:00:31.000
and so let's go back and look at those splay tree code.

00:00:31.000 --> 00:00:35.000
So when we removed an element from the tree but wasn't there, it's suppose to raise 

00:00:35.000 --> 00:00:37.000
the exception key not found in tree. 

00:00:37.000 --> 00:00:40.000
On the other hand, what its actually doing is failing quite a bit below here

00:00:40.000 --> 00:00:45.000
in the middle of the splay function when the code does a comparison against an element of type none  

00:00:45.000 --> 00:00:49.000
and so that's probably not what the developer intended by adding just a little bit to our test suite   

00:00:49.000 --> 00:00:53.000
we seem to have find a bug not anticipated by the developer of the splay tree   

00:00:53.000 --> 00:00:56.000
and I think this example is illustrative for a couple of reasons.   

00:00:56.000 --> 00:01:00.000
First of all the coverage tool, the very first time we run it told us something that we didn't know   

00:01:00.000 --> 00:01:03.000
and this my experience in general that this is what happens when you use a coverage tool.      

00:01:03.000 --> 00:01:08.000
Its basically a very similar to the first time you run a profiling tool on a piece of code where it turns

00:01:08.000 --> 00:01:11.000
out that usually this functions are using up CPU time are not the ones that you necessarily

00:01:11.000 --> 00:01:14.000
thought were using up CPU time--well, coverage tools are very similar.   

00:01:14.000 --> 00:01:19.000
It often turns out that the stuff that you thought was going to run might not be running only some of it  

00:01:19.000 --> 00:01:22.000
but often turns out that some of the stuff that you thought was going to run doesn't get run.  

00:01:22.000 --> 00:01:24.000
So it told us something interesting and that's nice.   

00:01:24.000 --> 00:01:27.000
Now on the other hand if the coverage tool haven't told us anything interesting that is to say 

00:01:27.000 --> 00:01:31.000
if it told us that everything that we hoped was executing when we run the unit test   

00:01:31.000 --> 00:01:34.000
was executing well then that's good too--we get to sleep a little easier.  

00:01:34.000 --> 00:01:39.000
The second thing you noticed is a much more settle point and this point is that we're out of the test case    

00:01:39.000 --> 00:01:42.000
to execute this one of code but it turned out that the bug wasn't right here.   

00:01:42.000 --> 00:01:45.000
The bug was somewhere completely different buried in the splay routine      

00:01:45.000 --> 00:01:48.000
and if you go back and look at the coverage information, it's going to turn out 

00:01:48.000 --> 00:01:53.000
that the splay routine is entirely covered--that is to say every line of the splay routine

00:01:53.000 --> 00:01:56.000
was executed during the execution of the unit test for the splay tree.

00:01:56.000 --> 00:01:59.000
This serves to make a couple of points--first of all just because some code was covered

00:01:59.000 --> 00:02:02.000
especially at the statement level  this does not mean anything about whether it contains bug in it.  

00:02:02.000 --> 00:02:04.000
It just means that it run at least once.  

00:02:04.000 --> 00:02:07.000
The other thing is that and the second thing is we have to ask the question,   

00:02:07.000 --> 00:02:10.000
"What do we want to really read into the fact that we failed to cover something?"   

00:02:10.000 --> 00:02:15.000
The thing to not read into it is a bit of failed piece of coverage is a mandate  

00:02:15.000 --> 00:02:17.000
to write a test that covers this test case.

00:02:17.000 --> 00:02:21.000
That's what we did, that's not a good general lesson rather the way we should think about this  

00:02:21.000 --> 00:02:24.000
is that the coverage tool is giving us a bit of evidence.   

00:02:24.000 --> 00:02:28.000
It has given an example suggesting that our test suite is poorly thought out. 

00:02:28.000 --> 00:02:32.000
That is to say that our test suite is failing to exercise functionality that is present in our code   

00:02:32.000 --> 00:02:34.000
and what that means is we haven't thought about this problem

00:02:34.000 --> 00:02:36.000
very well and we need to rethink the test suite.

00:02:36.000 --> 00:02:41.000
So to summarize that, when coverage fails its better to try to think about why we went wrong   

00:02:41.000 --> 00:02:45.000
rather than just blindly writing a test case and just exercise the code which wasn't covered.  

