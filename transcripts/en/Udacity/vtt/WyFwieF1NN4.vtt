WEBVTT
Kind: captions
Language: en

00:00:00.800 --> 00:00:04.700
The real beauty of the system is that
you can use it with string keys too.

00:00:04.700 --> 00:00:08.800
You just need to come up with some hash
function that converts letters into

00:00:08.800 --> 00:00:09.430
numbers.

00:00:09.430 --> 00:00:14.140
Individual letters can be pretty
easily converted into ASCII values and

00:00:14.140 --> 00:00:17.450
many languages already have
functions built in that do that.

00:00:18.570 --> 00:00:22.550
We can combine the ASCII values with
a formula to get a unique hash for

00:00:22.550 --> 00:00:23.990
each letter.

00:00:23.990 --> 00:00:26.900
So what should our hash
function look like?

00:00:26.900 --> 00:00:29.310
Again, there are some trade-offs here.

00:00:29.310 --> 00:00:31.610
Do we want every word
in it's own bucket?

00:00:31.610 --> 00:00:36.280
Are you okay with collisions but
want a relatively simple hash function?

00:00:36.280 --> 00:00:41.180
If you have 30 or less words, you can
probably just use the ASCII value for

00:00:41.180 --> 00:00:44.860
the first letter of
a string as a hash value.

00:00:44.860 --> 00:00:47.300
The standard hash code function for

00:00:47.300 --> 00:00:52.830
string keys in Java a large hash
table over having any collisions.

00:00:52.830 --> 00:00:55.410
The formula looks something like this.

00:00:55.410 --> 00:00:58.980
For example, let's say,
we're going to hash the word UDACITY and

00:00:58.980 --> 00:01:02.879
we're starting with the first
two letters of the string, UD.

00:01:02.880 --> 00:01:06.130
We can plug these ASCII
values into the equation to

00:01:06.130 --> 00:01:08.800
get a hash value that is
unique to our string.

00:01:10.900 --> 00:01:11.670
Why does this work?

00:01:11.670 --> 00:01:16.950
Well by multiplying the ASCII value for
each letter by a power of some number

00:01:16.950 --> 00:01:21.150
like 31, we can guarantee that
every number representation or

00:01:21.150 --> 00:01:24.370
hash value will be
unique to that string.

00:01:24.370 --> 00:01:26.490
A hash function like
that would be great for

00:01:26.490 --> 00:01:30.270
a dictionary where we need
unique buckets for each string.

00:01:30.270 --> 00:01:35.348
However strings with just three or four
letters already have huge hash values.

00:01:36.550 --> 00:01:39.200
The tradeoff is really important here.

00:01:39.200 --> 00:01:44.380
As long as you have the space for it, a
unique hash value can be really useful.

00:01:44.380 --> 00:01:48.110
Lastly, why is the number 31 used here?

00:01:48.110 --> 00:01:51.560
The earliest hash functions took
advantage of some properties of

00:01:51.560 --> 00:01:55.740
the number 31 and research showed
that it was a great choice for

00:01:55.740 --> 00:01:57.220
this kind of string hashing.

00:01:58.560 --> 00:02:02.840
However, now there are more complex hash
functions that have been discovered.

00:02:02.840 --> 00:02:08.150
So thirty one is more of a convention
than the best value for every situation.

00:02:08.150 --> 00:02:12.730
Remember that designing a solution for
your keys is the most important thing.

00:02:12.730 --> 00:02:15.450
Don't get too bogged down in
all of these conventions.

