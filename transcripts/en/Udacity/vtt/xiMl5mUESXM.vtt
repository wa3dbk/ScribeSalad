WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.250
So can a computer solve any problem that meets these 3 requirements?

00:00:05.250 --> 00:00:09.080
It seems, in a way, like a computer should be able to do that, doesn't it?

00:00:09.080 --> 00:00:12.750
I mean, the input is fit for a computer; the output is fit for a computer.

00:00:12.750 --> 00:00:17.280
We have even been very, very nitpicky with finite strings, constant number of symbols,

00:00:17.280 --> 00:00:20.490
and we want an objectively correct and definitive answer.

00:00:20.490 --> 00:00:23.710
No grading student's essays, no predicting the future,

00:00:23.710 --> 00:00:26.770
no looking at pictures and telling us if they're beautiful.

00:00:26.770 --> 00:00:30.070
I'm now going to show you a problem that meets these 3 criteria.

00:00:30.070 --> 00:00:33.370
I will also be able to show you that no computer can ever solve it.

00:00:33.370 --> 00:00:35.370
And this is actually a problem where it would be

00:00:35.370 --> 00:00:37.590
very useful to have a computer being able to solve it.

00:00:37.590 --> 00:00:42.030
So I guess you've all been in this situation here where on your computer,

00:00:42.030 --> 00:00:46.880
you're working, and you've just started a certain type of calculation or task on the computer.

00:00:46.880 --> 00:00:52.050
The computer tells you yes, I'm 10% done, and after a while this moves to 20%,

00:00:52.050 --> 00:00:57.760
after a while it moves to 30%, and, of course, pending on what system you're working on,

00:00:57.760 --> 00:01:03.300
your mouse turns into this hourglass here, and now the progress bar gets stuck.

00:01:03.300 --> 00:01:07.850
And it stays there. You go have lunch, you come back, and it stays there.

00:01:07.850 --> 00:01:12.280
So the question is, at some point in time--I mean, you want this task to get done--

00:01:12.280 --> 00:01:16.740
but maybe in the next minute the computer will go on.

00:01:16.740 --> 00:01:22.250
Maybe it's just thinking, it's just working, but it could also be that your program has crashed.

00:01:22.250 --> 00:01:26.520
If your computer stays that way for quite a time, well, you probably would assume

00:01:26.520 --> 00:01:28.630
that it has crashed, but you never know for sure.

00:01:28.630 --> 00:01:31.230
So what if we had an algorithm for that?

00:01:31.230 --> 00:01:36.020
What if we had an algorithm that took as input a computer program, P.

00:01:36.020 --> 00:01:38.290
It could be written in any language, basically.

00:01:38.290 --> 00:01:43.580
So Python, C++, Java, or whatnot. And, of course, we also wanted input for that program.

00:01:43.580 --> 00:01:47.210
And the input, of course, in accordance with rule number 1,

00:01:47.210 --> 00:01:49.810
will be a finite string using a constant number of symbols.

00:01:49.810 --> 00:01:52.640
And actually, the program, of course, will be as well.

00:01:52.640 --> 00:01:55.850
So it may be, for example, the source code of a program.

00:01:55.850 --> 00:02:00.000
We want this algorithm to tell us if we run the program on the input,

00:02:00.000 --> 00:02:03.480
does the computer ever finish, or does it go into an infinite loop?

00:02:03.480 --> 00:02:08.410
Very simple question. And, of course, this problem totally conforms with all 3 requirements here.

00:02:08.410 --> 00:02:12.330
So as I just said, the input is a finite string, constant number of symbols, perfect.

00:02:12.330 --> 00:02:16.050
Output, it's a decision problem so the output will either be yes or no.

00:02:16.050 --> 00:02:19.270
And, of course, the output is also objectively correct, because

00:02:19.270 --> 00:02:22.730
we're talking about deterministic machines here, so you can easily check

00:02:22.730 --> 00:02:25.310
if the program, indeed, will go into an infinite loop,

00:02:25.310 --> 00:02:27.350
if the computer tells you where the problem is.

00:02:27.350 --> 99:59:59.000
And this problem is known as the famous, and it's really famous, halting problem.

