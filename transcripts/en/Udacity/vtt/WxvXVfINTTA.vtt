WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
Writing assertions is not always easy.

00:00:03.000 --> 00:00:08.000
You need to be prepared for a number of iterations until your pre and postconditions are accurate.

00:00:08.000 --> 00:00:12.000
A typical chain of tools looks like this.

00:00:12.000 --> 00:00:17.000
Here, we do have test inputs either random generated or systematic generated

00:00:17.000 --> 00:00:20.000
or coming from users or coming from production.

00:00:20.000 --> 00:00:23.000
These test inputs have been checked by preconditions,

00:00:23.000 --> 00:00:27.000
and the results of the computation will be checked by postconditions.

00:00:27.000 --> 00:00:30.000
Now, as it comes to preconditions and postconditions,

00:00:30.000 --> 00:00:33.000
you can be either too permissive or you can be too strict.

00:00:33.000 --> 00:00:38.000
If you are too permissive with your preconditions, this means that inputs,

00:00:38.000 --> 00:00:43.000
which shouldn't go into the function, go into the function and then result in arbitrary behavior.

00:00:43.000 --> 00:00:46.000
If you are too strict with the preconditions,

00:00:46.000 --> 00:00:50.000
this means that valid inputs will result in failing preconditions.

00:00:50.000 --> 00:00:53.000
The same also applies for postconditions.

00:00:53.000 --> 00:00:59.000
If you are too permissive with your postconditions, this means that you will not catch a number of bugs.

00:00:59.000 --> 00:01:04.000
If you are too strict, however, then you will catch bugs where there are no bugs.

00:01:04.000 --> 00:01:08.000
The key is to come up with the right balance between these two.

00:01:08.000 --> 00:01:10.000
You don't want to be too permissive. You don't want to be too strict.

00:01:10.000 --> 00:01:13.000
In theory, you like to have preconditions and postconditions

00:01:13.000 --> 00:01:16.000
that capture exactly what the program is doing.

00:01:16.000 --> 00:01:21.000
However, in practice, you will find that while writing preconditions is typically easy,

00:01:21.000 --> 00:01:24.000
writing postconditions or regular functions can be very hard.

00:01:24.000 --> 00:01:29.000
And therefore, it's very common for postconditions only to check a part of the actual state

00:01:29.000 --> 00:01:34.000
that is, your postconditions that are simple but a bit too permissive that is they missed errors.

00:01:34.000 --> 00:01:40.000
Whereas for preconditions, it's frequently feasible to come up with the right level of precision.

00:01:40.000 --> 00:01:43.000
Why is that postconditions are so complex?

00:01:43.000 --> 00:01:49.000
To give you a simple example of why writing correct postconditions is not easy at all,

00:01:49.000 --> 00:01:54.000
let me give you a very simple example. Let assume we do have a sorting function.

00:01:54.000 --> 00:02:00.000
The precondition for a sorting function is simple: basically, we simply assume that x is a list.

00:02:00.000 --> 00:02:03.000
Well, we could put up an appropriate assertion here,

00:02:03.000 --> 00:02:06.000
but the precondition is to accept essentially anything.

00:02:06.000 --> 00:02:09.000
For the postcondition, we have to make sure two things.

00:02:09.000 --> 00:02:14.000
First, we assume that the list y that we will return actually is sorted,

00:02:14.000 --> 00:02:20.000
but we also need to make sure that the list we returned is a permutation of our input list.

00:02:20.000 --> 00:02:26.000
So let's go and check whether the list is sorted. We iterate over the elements of y

00:02:26.000 --> 00:02:32.000
and if one element is greater than its successor, we return false, otherwise we return true.

00:02:32.000 --> 00:02:37.000
So what you see here is that in order to check the postcondition,

00:02:37.000 --> 00:02:39.000
we needed to come up with another function,

00:02:39.000 --> 00:02:42.000
which actually now, should again be checked against what?

00:02:42.000 --> 00:02:47.000
The property that is-sorted checks here, is essentially already described in here,

00:02:47.000 --> 00:02:52.000
meaning that any assertion you could have here would be just the same as anything you have in here

00:02:52.000 --> 00:02:54.000
so you simply have to believe that this is true.

00:02:54.000 --> 00:03:01.000
Well, I didn't believe that I actually ran a number of tests, so I'm pretty confident that this works.

00:03:01.000 --> 00:03:04.000
Now, this is just is-sorted. You also have to come up with is-permutation,

00:03:04.000 --> 00:03:06.000
this is also something you have to define.

00:03:06.000 --> 00:03:13.000
Helper functions like is-sorted or is-permutation will probably be helpful later in the future

00:03:13.000 --> 00:03:16.000
because you may be able to reuse them for other purpose.

00:03:16.000 --> 00:03:19.000
They may even become part of a library.

