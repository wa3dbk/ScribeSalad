WEBVTT
Kind: captions
Language: en

00:00:00.090 --> 00:00:03.370
So the answer is, only the second and the third

00:00:03.370 --> 00:00:06.360
are equivalent. This is a little surprising. This was kind

00:00:06.360 --> 00:00:09.646
of a tricky question. So the reason the first one

00:00:09.646 --> 00:00:13.430
is not, if x is seven or greater, well, then seven

00:00:13.430 --> 00:00:16.750
mod seven has the value zero. That's not the same

00:00:16.750 --> 00:00:19.580
as the x that we started with. And that's the

00:00:19.580 --> 00:00:22.469
case also if we have eight. Eight module seven has

00:00:22.469 --> 00:00:25.300
the value one. Which is different from what we started with.

00:00:26.460 --> 00:00:29.190
When the modulo is greater than the possible value of

00:00:29.190 --> 00:00:31.840
x, and we said, x could be only between zero and

00:00:31.840 --> 00:00:34.300
10, well, then, the result is always the same as

00:00:34.300 --> 00:00:39.590
x. The third question, when we map x to its character

00:00:39.590 --> 00:00:41.810
value, and then we take the order of that, we'll

00:00:41.810 --> 00:00:46.020
char an order inverses, so that's equivalent. You would think that

00:00:46.020 --> 00:00:48.570
would in the other direction and the reason it doesn't is

00:00:48.570 --> 00:00:52.200
because the input to ord must be a one letter string.

00:00:52.200 --> 00:00:55.210
If the input's not a single character, then ord produces

00:00:55.210 --> 00:00:58.410
an error. So let's see that in the Python interpreter, if

00:00:58.410 --> 00:01:02.500
we print the result of ord where the input is a

00:01:02.500 --> 00:01:04.980
number and we said x was a number between zero and

00:01:04.980 --> 00:01:07.840
three. Well, that gives us an error. And it gives an

00:01:07.840 --> 00:01:10.280
error, because ord expects a string of length one, but the

00:01:10.280 --> 00:01:13.440
input was an integer. There is a function that allows us

00:01:13.440 --> 00:01:17.390
to turn numbers into strings. And that's the str function that

00:01:17.390 --> 00:01:21.260
takes a number and gives us a string corresponding

00:01:21.260 --> 00:01:24.460
to that number. So let's see what str of three

00:01:24.460 --> 00:01:26.820
gives us, that will give us the string three,

00:01:26.820 --> 00:01:28.720
we can't see in output here that it is actually

00:01:28.720 --> 00:01:31.230
a string, but it is a string, and we

00:01:31.230 --> 00:01:35.070
can actually use order on the result there. When we

00:01:35.070 --> 00:01:39.430
run this, what we get is 51, not the

00:01:39.430 --> 00:01:43.070
three that we passed in and that's because the ord

00:01:43.070 --> 00:01:46.945
of the character three is 51.

