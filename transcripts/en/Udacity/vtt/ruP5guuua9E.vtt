WEBVTT
Kind: captions
Language: en

00:00:00.510 --> 00:00:05.470
So now let's see Coral in action for putting

00:00:05.470 --> 00:00:10.480
and getting content, user-generated content, that can be distributed in

00:00:10.480 --> 00:00:15.430
a democratic fashion and the load for both serving as a metadata

00:00:15.430 --> 00:00:20.210
server as well as the content server can get naturally

00:00:20.210 --> 00:00:26.630
distributed. Because of the way the Coral system works in

00:00:26.630 --> 00:00:33.440
managing the sloppy DHT. Let's say, Naomi, who is at node number 30, has some

00:00:33.440 --> 00:00:35.860
interesting content, and she wants to share it

00:00:35.860 --> 00:00:39.140
with the world. So what she does, she

00:00:39.140 --> 00:00:42.460
creates a unique signature, a key, for this

00:00:42.460 --> 00:00:45.790
content by hashing it. And let's say that

00:00:45.790 --> 00:00:52.600
the key that she generated for this content is 100. So now, Naomi wants to put

00:00:52.600 --> 00:00:57.830
the key, 100, and the value, 30, indicating that this

00:00:57.830 --> 00:01:02.890
node has the content corresponding to this key, 100. She

00:01:02.890 --> 00:01:08.100
wants to put it out on the internet, and so she uses the Coral

00:01:08.100 --> 00:01:13.340
system. And she uses the Coral key-based routing. The

00:01:13.340 --> 00:01:18.920
node that she would like to store this key 100 is node

00:01:18.920 --> 00:01:22.250
100 corresponding to David's computer, okay? Because David's

00:01:22.250 --> 00:01:24.950
computer has node ID 100 so that's the

00:01:24.950 --> 00:01:27.810
place I would like to keep it, but

00:01:27.810 --> 00:01:31.416
we are following the Corals key-based routing algorithm. So

00:01:31.416 --> 00:01:37.143
Naomi, what she's going to do is going to make a series of RPC calls to put 100,

00:01:37.143 --> 00:01:44.000
30 key value pair. And she finds that none of the intermediate nodes are either

00:01:44.000 --> 00:01:47.590
full or loaded. And finally, she reaches David's

00:01:47.590 --> 00:01:50.810
computer. David also says my node is neither

00:01:50.810 --> 00:01:53.430
full nor loaded. How can it be, because

00:01:53.430 --> 00:01:57.130
she just created this content, 100. So this

00:01:57.130 --> 00:02:03.620
100, key 100, is not known to the world. So nobody is at this point serving as a

00:02:03.620 --> 00:02:09.180
metadata server for this particular key. So David is the right place to keep it,

00:02:09.180 --> 00:02:15.620
so David hosts this particular key value pair, 100, 30. Jacques finds out

00:02:15.620 --> 00:02:21.210
that there is this interesting video whose signature is 100, so he wants to get

00:02:21.210 --> 00:02:28.490
it. And he knows that the likely place where it is contained is

00:02:28.490 --> 00:02:34.140
node number 100, but once again, he is going to use the Coral key-based routing,

00:02:34.140 --> 00:02:39.130
and he is doing a get call, and the get call follows the same key-based routing

00:02:39.130 --> 00:02:42.995
algorithm of halving the distance to the destination.

00:02:42.995 --> 00:02:46.130
And so we make a whole bunch of RPC

00:02:46.130 --> 00:02:49.780
calls, finally get to the destination itself because

00:02:49.780 --> 00:02:52.910
none of the intermediate nodes have this key

00:02:52.910 --> 00:02:56.120
value pair. So we get to David's computer,

00:02:56.120 --> 00:02:59.280
and David says, yes, I do have the key

00:02:59.280 --> 00:03:03.100
value pair 100, 30, and here is the

00:03:03.100 --> 00:03:05.430
value that you are looking for associated with the

00:03:05.430 --> 00:03:07.150
key that you are asking about, and the

00:03:07.150 --> 00:03:10.520
value is 30 indicating that 30 is the node

00:03:10.520 --> 00:03:13.582
that has the content that corresponds to this

00:03:13.582 --> 00:03:16.600
key 100. That's what Jacques is going to get

00:03:16.600 --> 00:03:20.220
back. So then Jacques gets his response from,

00:03:20.220 --> 00:03:24.430
from David that the value is 30, that value

00:03:24.430 --> 00:03:27.910
indicates the node ID from which Jacques

00:03:27.910 --> 00:03:31.280
can download the content corresponding to the

00:03:31.280 --> 00:03:34.980
key 100. That's Naomi's computer. So, Jacques

00:03:34.980 --> 00:03:38.440
goes to Naomi's computer and gets the content

00:03:38.440 --> 00:03:44.380
corresponding to key 100. Naomi sends the content, so Jacques is now happy. He's

00:03:44.380 --> 00:03:49.540
got the content that corresponds to 100. But Jacques is a nice guy too. So he

00:03:49.540 --> 00:03:52.860
says well, I have the content. Since I have

00:03:52.860 --> 00:03:55.990
the content, I can also serve as a proxy

00:03:55.990 --> 00:03:58.650
for Naomi. And what I'm going to do, is

00:03:58.650 --> 00:04:02.820
I'm going to put the key value pair 100 corresponding

00:04:02.820 --> 00:04:06.450
to this content that is now mirrored over here.

00:04:06.450 --> 00:04:09.840
And say that the value is 60 indicating that I'm

00:04:09.840 --> 00:04:12.160
willing to serve as a proxy for the same

00:04:12.160 --> 00:04:15.490
content. So I'm going to do a pull operation, and

00:04:15.490 --> 00:04:18.070
this pull operation is going to go down, and

00:04:18.070 --> 00:04:20.422
this pull operation is going to use the same

00:04:20.422 --> 00:04:24.680
key-based routing algorithm. And when it gets to David,

00:04:24.680 --> 00:04:27.240
David might say look I am not interested in holding

00:04:27.240 --> 00:04:30.550
more than one value for this particular key. And

00:04:30.550 --> 00:04:32.840
so if he says that I don't want to do

00:04:32.840 --> 00:04:36.320
it then I have to retract my steps and

00:04:36.320 --> 00:04:40.370
pick an intermediate node which said that it is willing.

00:04:40.370 --> 00:04:45.210
Because it is neither loaded nor full for this particular key 100, so it's

00:04:45.210 --> 00:04:49.980
willing to serve as a metadata server. We already have one metadata server, but

00:04:49.980 --> 00:04:55.780
this guy is willing to do that for only one value, and therefore this guy

00:04:55.780 --> 00:05:00.842
becomes a new metadata server for the same key 100. So

00:05:00.842 --> 00:05:05.642
in this metadata server, new metadata server, we've got

00:05:05.642 --> 00:05:11.977
this entry 100, 60 also stored. So now there are two metadata servers

00:05:11.977 --> 00:05:18.562
that can potentially answer queries that concern this video 100. Now if a

00:05:18.562 --> 00:05:24.227
third guy, Kamal, comes to know about this cool video that is now

00:05:24.227 --> 00:05:30.610
propagating on the internet and he finds that the key for that is 100.

00:05:30.610 --> 00:05:33.514
He can once again query the Coral system

00:05:33.514 --> 00:05:36.594
for that video and he is following the same

00:05:36.594 --> 00:05:40.906
key-based routing algorithm of Coral, and trying to get

00:05:40.906 --> 00:05:45.116
towards David's node, which is node 100. So he's

00:05:45.116 --> 00:05:47.430
going to follow that, but when he does

00:05:47.430 --> 00:05:50.170
that he hits this intermediate node and this guy

00:05:50.170 --> 00:05:52.950
says, you know what, I've got the key that

00:05:52.950 --> 00:05:55.640
you're looking for and the value that is associated

00:05:55.640 --> 00:06:00.050
with this key is 60. So Kamal doesn't have to go all the

00:06:00.050 --> 00:06:05.280
way to this metadata server. He can get the answer for his query, get

00:06:05.280 --> 00:06:10.904
100, from this intermediate node itself which returns a different

00:06:10.904 --> 00:06:15.950
value. Different from Naomi's address.

00:06:15.950 --> 00:06:20.612
Namely node ID 60 that corresponds to the new good Samaritan, Jacques,

00:06:20.612 --> 00:06:26.070
who's also willing to serve as a proxy for the same video content. So 60 gets

00:06:26.070 --> 00:06:32.500
return to Kamal and Kamal can then go to Jacques and get the content from, from

00:06:32.500 --> 00:06:35.330
Jacques. And that way you see that the

00:06:35.330 --> 00:06:38.770
origin of this particular video, which started at

00:06:38.770 --> 00:06:42.070
Naomi, is now propagated to Jacques. So the

00:06:42.070 --> 00:06:45.720
origin server need not get overloaded and of

00:06:45.720 --> 00:06:51.510
course Kamal will turn around and become a good Samaritan himself and say that

00:06:51.510 --> 00:06:55.610
he is willing to serve as a proxy also. So his key value pair

00:06:55.610 --> 00:06:59.610
entry gets into another intermediate node. Now

00:06:59.610 --> 00:07:02.300
we've got three nodes that can serve

00:07:02.300 --> 00:07:05.270
as metadata server for this particular key

00:07:05.270 --> 00:07:10.610
100. Not just the original metadata server node,

00:07:10.610 --> 00:07:15.810
David's computer, but intermediate nodes that also have become

00:07:15.810 --> 00:07:21.830
part of the metadata server network for this particular key 100. And

00:07:21.830 --> 00:07:26.860
similarly, there is no origin server overload also. Because now

00:07:26.860 --> 00:07:31.540
the content itself has gotten distributed

00:07:31.540 --> 00:07:36.080
in several proxies. And all of these proxies

00:07:36.080 --> 00:07:41.760
have dynamically gotten the content, and have shared their willingness

00:07:41.760 --> 00:07:48.870
to serve as proxies. So if a new node wants to get the same video 100, when

00:07:48.870 --> 00:07:53.170
it makes its get operation, that get operation is going to traverse the

00:07:53.170 --> 00:07:57.130
network, and either hit David himself or

00:07:57.130 --> 00:08:01.080
hopefully one of the intermediate metadata servers.

00:08:01.080 --> 00:08:07.560
And that way the request for the actual content may go to different

00:08:07.560 --> 00:08:13.270
content providers dynamically as the system evolves. So as a result you can

00:08:13.270 --> 00:08:20.100
see that the metadata server load is distributed. And the origin server

00:08:20.100 --> 00:08:26.750
is also not stressed. That's the nice thing about the Coral sloppy DHT approach.

00:08:26.750 --> 00:08:34.880
So the key takeaway in the Coral approach, is that even though an individual

00:08:34.880 --> 00:08:40.950
request may have a little bit more latency because we're not trying to reach

00:08:40.950 --> 00:08:44.470
the desired destination directly, but going through

00:08:44.470 --> 00:08:47.456
some intermediate hops. In particular halving the

00:08:47.456 --> 00:08:50.062
distance to the desired destination. You're going

00:08:50.062 --> 00:08:52.000
to increase the latency a little bit,

00:08:52.000 --> 00:08:59.318
but we are doing that in the common good that in these kinds of environments,

00:08:59.318 --> 00:09:06.110
giant scale services, big data, large numbers of users, and content suddenly

00:09:06.110 --> 00:09:11.430
becoming popular, all of this dynamism has be dealt with in a

00:09:11.430 --> 00:09:17.580
system that is as vibrant as the internet. And Coral is a step towards that

00:09:17.580 --> 00:09:21.370
by reducing the stress on the origin server, as well

00:09:21.370 --> 00:09:26.580
as reducing the stress on the metaservers by naturally distributing it.

