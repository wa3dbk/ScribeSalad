WEBVTT
Kind: captions
Language: en

00:00:00.670 --> 00:00:05.070
Is partial order good enough for constructing deterministic

00:00:05.070 --> 00:00:08.100
distributed algorithms? It turns out, it may be

00:00:08.100 --> 00:00:12.440
sufficient for many situations. The airline reservation example

00:00:12.440 --> 00:00:14.640
I started with would work fine with a

00:00:14.640 --> 00:00:18.620
partial order of events dictated by Lamport's clock.

00:00:18.620 --> 00:00:21.150
But there are situations where there maybe a

00:00:21.150 --> 00:00:23.910
need for a total order of events in

00:00:23.910 --> 00:00:26.100
the distributed system. Let's look at an example.

00:00:27.260 --> 00:00:29.930
Here is an example to illustrate the need for

00:00:29.930 --> 00:00:33.230
a total order. I'm going to use my own, personal

00:00:33.230 --> 00:00:36.500
life example to illustrate the need for total order.

00:00:36.500 --> 00:00:39.780
I have, one car and my family consists of

00:00:39.780 --> 00:00:42.820
my wife, my son and my daughter, and we

00:00:42.820 --> 00:00:45.970
share this single car. And what we want to do

00:00:45.970 --> 00:00:49.100
is make sure that we can make local decision

00:00:49.100 --> 00:00:52.270
on who gets dibs on using the car at any

00:00:52.270 --> 00:00:54.810
point of time. And we're going to use Lamport's clock for this.

00:00:54.810 --> 00:00:57.760
So what we do is, whenever we want to get the

00:00:57.760 --> 00:01:01.620
car for our personal use, we're going to text everyone with a

00:01:01.620 --> 00:01:04.620
time stamp. I'm going to associate a time stamp, if I'm, if I'm

00:01:04.620 --> 00:01:08.170
requesting the car, I'm going to text every one, and associate a

00:01:08.170 --> 00:01:12.820
time stamp with that request. And it is a logical time-stamp

00:01:12.820 --> 00:01:15.230
and similarly my wife would do the same thing, son and

00:01:15.230 --> 00:01:17.430
daughter all of us do the same thing. And how do we

00:01:17.430 --> 00:01:20.345
pick the winner, well, locally we can look at the

00:01:20.345 --> 00:01:24.070
time-stamp of request that have come in from others and my

00:01:24.070 --> 00:01:28.448
own request. And whoever has the earliest time stamp wins. Pretty

00:01:28.448 --> 00:01:31.130
simple, right? So pretty simple, everybody is going to make a

00:01:31.130 --> 00:01:34.160
local decision, looking at the time stamps of request that

00:01:34.160 --> 00:01:36.570
have come in from others and say well, you know right

00:01:36.570 --> 00:01:40.535
now, it's my son's turn to use the car, or my

00:01:40.535 --> 00:01:42.820
daughter's turn to use the car and so on. But what

00:01:42.820 --> 00:01:46.610
if the time stamp, because these are locally generated by

00:01:46.610 --> 00:01:49.160
each one of us, happens to be the same. So, for

00:01:49.160 --> 00:01:52.420
instance, let's say my son makes a request. Takes, sends a

00:01:52.420 --> 00:01:55.790
text message. My son makes a request, sends a text message

00:01:55.790 --> 00:01:58.200
with a time stamp ten to all of us. So this

00:01:58.200 --> 00:02:01.130
is the blue arrow that's going everywhere, so that's indicating to

00:02:01.130 --> 00:02:04.560
all three of us that he wants the car, and timestamp

00:02:04.560 --> 00:02:08.080
ten is when he generated the request. So happens, my wife

00:02:08.080 --> 00:02:11.720
also makes a request for using the car, exactly

00:02:11.720 --> 00:02:14.160
with the same timestamp ten. And that's the purple

00:02:14.160 --> 00:02:21.070
arrow that you see. So, now we have a problem. And the problem is, all of us are

00:02:21.070 --> 00:02:24.040
looking at these text messages and trying to make

00:02:24.040 --> 00:02:26.530
a decision, who's got the dibs on using the

00:02:26.530 --> 00:02:30.480
car? How will my son and my wife know,

00:02:30.480 --> 00:02:33.570
given that both the time stamp is the same,

00:02:33.570 --> 00:02:36.010
which one is the winner for using this car?

00:02:36.010 --> 00:02:39.060
Now, what we do is, we're going to break the

00:02:39.060 --> 00:02:43.200
tie, and I'm going to stipulate that age wins. And

00:02:43.200 --> 00:02:46.110
therefore, in this case, if the time stamp happens to

00:02:46.110 --> 00:02:50.640
be exactly the same, then my wife, by seniority, is

00:02:50.640 --> 00:02:52.620
the winner. She gets the car. So, that's how we

00:02:52.620 --> 00:02:55.450
break the tie. You can see, through this example, that

00:02:55.450 --> 00:02:59.130
there is a need for total order in decision making

00:02:59.130 --> 00:03:01.860
when you have a distributed system. And you want

00:03:01.860 --> 00:03:06.020
to make local decisions without bothering anyone, based on

00:03:06.020 --> 00:03:08.300
information that you have, but you have to make

00:03:08.300 --> 00:03:12.440
that local decision unambiguously, because you cannot have both

00:03:12.440 --> 00:03:15.450
my son and wife thinking that they have the

00:03:15.450 --> 00:03:17.900
car at the same time. That'll be a problem.

00:03:17.900 --> 00:03:19.800
So, whenever there is a tie, we have to

00:03:19.800 --> 00:03:22.930
break that, and that's the need for the total order.

