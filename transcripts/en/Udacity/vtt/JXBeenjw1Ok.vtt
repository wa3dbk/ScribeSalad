WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.560
As you have seen, non-determinism is pretty powerful,

00:00:03.560 --> 00:00:09.780
so the question is, of course, could we actually build a non-deterministic RAM?

00:00:09.780 --> 00:00:12.970
And as I told you before, I have no idea how you would do that,

00:00:12.970 --> 00:00:16.850
so if somebody ask me to build a non-deterministic RAM, I would turn them down

00:00:16.850 --> 00:00:21.250
although if you could build one of these, you would certainly become quite rich and famous.

00:00:21.250 --> 00:00:27.830
The next best thing we can do to building a non-deterministic RAM though is simulating one.

00:00:27.830 --> 00:00:32.170
And of course you will be asking yourself, well, if he doesn't know

00:00:32.170 --> 00:00:36.750
how to build a non-deterministic RAM, how is he going to simulate one?

00:00:36.750 --> 00:00:43.190
Well, the answer is actually not that difficult but I'll have to warn you because the simulation

00:00:43.190 --> 00:00:48.300
will not be very satisfying or at least will have to pay quite a steep price for the simulation.

00:00:48.300 --> 00:00:52.830
So the first thing we should probably talk about when we want to simulate

00:00:52.830 --> 00:00:56.480
a non-deterministic RAM on a deterministic RAM is

00:00:56.480 --> 00:01:01.980
how would we simulate a deterministic RAM on a deterministic RAM?

00:01:01.980 --> 00:01:05.610
So basically, a picture like this, you have a deterministic RAM and of course,

00:01:05.610 --> 00:01:08.710
it's branded as a deterministic RAM and on that machine,

00:01:08.710 --> 00:01:14.130
you do a simulation of another deterministic RAM and this might look

00:01:14.130 --> 00:01:16.410
a little bit more complicated than it actually is.

00:01:16.410 --> 00:01:22.060
So, all it means is that if you have a program code that you run on a deterministic RAM,

00:01:22.060 --> 00:01:27.280
instead of running this code directly, you have another program

00:01:27.280 --> 00:01:32.460
and this program is basically going through your code and simulating what your code is doing.

00:01:32.460 --> 00:01:35.420
And this program here which would be the simulator

00:01:35.420 --> 00:01:42.270
is basically looking at the code and simulating what this code would actually do.

00:01:42.270 --> 00:01:47.750
Without running it directly on the machine, so it's running indirectly on this machine here.

00:01:47.750 --> 00:01:50.610
Another way you can look at the simulation is this diagram here,

00:01:50.610 --> 00:01:53.450
so you start out with a certain program that you want to simulate

00:01:53.450 --> 00:01:57.760
and of course you also start out not only with the program but also with a memory of that RAM

00:01:57.760 --> 00:02:02.410
and if you remember in the last unit, we said that the RAM had actually different kinds of memory,

00:02:02.410 --> 00:02:05.610
some memory for the input, some for the output, and so on

00:02:05.610 --> 00:02:08.039
but we'll just draw this as a single memory here.

00:02:08.039 --> 00:02:13.700
So, we start out at the first line of code and then because it's a deterministic RAM,

00:02:13.700 --> 00:02:16.870
that line of code specifies exactly what's going to happen next,

00:02:16.870 --> 00:02:19.980
so it specifies certain modifications that we make to the memory,

00:02:19.980 --> 00:02:24.830
so we might change this variable here or even change two variables

00:02:24.830 --> 00:02:28.000
although this is not often going to happen in one single line of code,

00:02:28.000 --> 00:02:31.890
but we make some modifications to the memory and we're still in the first line of code here,

00:02:31.890 --> 00:02:36.460
then, we're going to check if that line here actually is a statement that tells us that we are done.

00:02:36.460 --> 00:02:41.950
If that is the case, then the simulation would also be done, but let's say that this is not the case.

00:02:41.950 --> 00:02:44.690
We can then go to the next line of code in our simulation

00:02:44.690 --> 00:02:48.810
and again that line will also specify some other things that we are to do,

00:02:48.810 --> 00:02:53.240
so most of the time it's going to be again changing variables, maybe it's reading the variable,

00:02:53.240 --> 00:02:59.220
but let's say it's also changing additional variables, so we check again if we're done,

00:02:59.220 --> 00:03:02.070
we go to the next line of code and so on, until we're done.

00:03:02.070 --> 00:03:07.690
And the reason why this simulation works and it actually works rather efficiently I would say,

00:03:07.690 --> 00:03:13.960
is a determinism means that each line of code specifies exactly what's going to happen next.

00:03:13.960 --> 00:03:16.530
Now for our next quiz, I would like you to think a little bit

00:03:16.530 --> 00:03:21.800
about the cost of this simulation or the properties of this simulation,

00:03:21.800 --> 00:03:26.530
so I would like you to tell me if instead of executing a program directly

00:03:26.530 --> 00:03:30.400
or running it directly on a machine, we do a simulation of that code.

00:03:30.400 --> 00:03:32.520
What are the properties of that simulation?

00:03:32.520 --> 00:03:36.430
In other words, what does it caused us to do such a simulation?

00:03:36.430 --> 00:03:39.220
Obviously, it will take longer because we are wrapping

00:03:39.220 --> 00:03:43.790
some other code around the original program, but how much longer does it take?

00:03:43.790 --> 00:03:47.910
Does it take longer by a polynomial time factor and by a polynomial time factor,

00:03:47.910 --> 00:03:53.030
I mean, if for example, the original algorithm would run in O(n²) time,

00:03:53.030 --> 00:03:58.340
or O(n⁴) time, something like that.

00:03:58.340 --> 00:04:04.740
Does it take longer exponentially, maybe, so if the original run in O(n²) time,

00:04:04.740 --> 00:04:11.430
we would now run and say (2^n) time or (2^n) times and square time,

00:04:11.430 --> 00:04:17.060
and finally, if this sort of simulation robust, so will it always give us the same result

00:04:17.060 --> 00:04:19.070
that the original program would have given us,

00:04:19.070 --> 99:59:59.000
or is there a possibility that such a simulation can make a mistake?

