WEBVTT
Kind: captions
Language: en

00:00:00.240 --> 00:00:03.710
Recall the basic idea of
how a two-way merge works.

00:00:03.710 --> 00:00:07.770
You're initially given a bunch of input
runs, each of, let's say, the same size,

00:00:07.770 --> 00:00:10.160
and each one sorted in ascending order.

00:00:10.160 --> 00:00:12.800
Your goal is to produce
a single sorted output.

00:00:12.800 --> 00:00:17.150
A natural scheme, based on the classical
merge sort idea is to take pairs of runs

00:00:17.150 --> 00:00:19.810
and combine them in a tree-like fashion.

00:00:19.810 --> 00:00:23.750
One problem with two way merging is that
it doesn't really use fast memory to its

00:00:23.750 --> 00:00:25.160
fullest potential.

00:00:25.160 --> 00:00:27.640
Remember how merging and
fast memory works?

00:00:27.640 --> 00:00:32.369
At any point in time it uses very little
of the available fast memory space.

00:00:32.369 --> 00:00:35.680
In fact it uses just
three L-sized blocks.

00:00:35.680 --> 00:00:39.700
There's one block for each of A and
B, and one block for the output C.

00:00:39.700 --> 00:00:41.240
So can you do better?

00:00:41.240 --> 00:00:43.990
A natural idea is to merge
not two runs at a time, but

00:00:43.990 --> 00:00:47.010
a bunch of runs, let's say K.

00:00:47.010 --> 00:00:50.610
In fact, let's start by considering
one of these K way merges.

00:00:50.610 --> 00:00:53.720
You're given a set of K input runs,
each of size S.

00:00:53.720 --> 00:00:57.520
Let's say they start in slow memory and
they're sorted in ascending order.

00:00:57.520 --> 00:01:00.600
Let's also suppose that you've
chosen this value of K so

00:01:00.600 --> 00:01:05.129
that at least K plus one blocks
of L will fit in fast memory.

00:01:05.129 --> 00:01:08.060
Your choice of K is not arbitrary.

00:01:08.060 --> 00:01:09.210
Let's say you've chosen it so

00:01:09.210 --> 00:01:13.690
that K plus one L-sized blocks
will fit in fast memory.

00:01:13.690 --> 00:01:15.590
This way you can reserve one block for

00:01:15.590 --> 00:01:19.500
each of the inputs, as well as
an additional block for the output.

00:01:19.500 --> 00:01:23.710
Initially, you would fill the inputs
with blocks of the input runs.

00:01:23.710 --> 00:01:25.800
Now at each step of the local merge,

00:01:25.800 --> 00:01:30.010
you need to know which of the K input
blocks has the next smallest item.

00:01:30.010 --> 00:01:33.390
Let's say that these shaded items
are the next ones to consider from

00:01:33.390 --> 00:01:35.260
each of the K input blocks.

00:01:35.260 --> 00:01:38.060
Of these,
you need to somehow find the smallest.

00:01:38.060 --> 00:01:39.680
Let's say that's this item.

00:01:39.680 --> 00:01:42.560
We'll come back to precisely how
to find it in just a moment.

00:01:42.560 --> 00:01:45.410
You can move this smallest
item to the output buffer.

00:01:45.410 --> 00:01:48.520
The next item from the source
buffer now becomes active.

00:01:48.520 --> 00:01:50.370
You then repeat this process.

00:01:50.370 --> 00:01:54.110
For instance, maybe this first
block has the next smallest item.

00:01:54.110 --> 00:01:57.420
So move it and
make the item that follows it active.

00:01:57.420 --> 00:02:01.320
As with two way merge, you will at
some point fill the output block.

00:02:01.320 --> 00:02:03.770
When that happens you
just need to flush it.

00:02:03.770 --> 00:02:07.555
Similarly, you will at some point
exhaust one of the input buffers.

00:02:07.555 --> 00:02:10.155
Again, if there are any unread
blocks of the input that remain,

00:02:10.155 --> 00:02:11.995
you just refill it.

00:02:11.995 --> 00:02:14.695
Now let's return to the question
how should you pick the next

00:02:14.695 --> 00:02:17.445
smallest item from the input frontier?

00:02:17.445 --> 00:02:19.975
You have several natural options.

00:02:19.975 --> 00:02:22.825
For instance,
one simple way is to do a linear scan.

00:02:22.825 --> 00:02:25.015
This is fine if K is small.

00:02:25.015 --> 00:02:28.285
Otherwise, you might consider some
type of priority queue data structure,

00:02:28.285 --> 00:02:30.230
like say a min-heap.

00:02:30.230 --> 00:02:31.295
Let's say we go with a min-heap.

00:02:31.295 --> 00:02:34.480
You would then have
the following operational costs.

00:02:34.480 --> 00:02:37.480
After loading the first K blocks,
you'd have to build the heap,

00:02:37.480 --> 00:02:40.190
which would cost you O of K operations.

00:02:40.190 --> 00:02:42.690
Then anytime you wanted to
find the next item to merge,

00:02:42.690 --> 00:02:46.930
you'd call an extract Min,
which would cost you log K operations.

00:02:46.930 --> 00:02:48.310
And after you extract an item,

00:02:48.310 --> 00:02:52.020
you might need to replace it, which
would also have a logarithmic cost.

00:02:52.020 --> 00:02:55.310
Now remember,
these are all fast memory operations, so

00:02:55.310 --> 00:02:58.530
when we consider these costs,
we'll just count them as comparisons.

00:02:58.530 --> 00:03:00.755
Now, assuming a heap-based
implementation,

00:03:00.755 --> 00:03:03.725
what's the cost of a single K way merge?

00:03:03.725 --> 00:03:06.315
Let's start with slow-fast
memory transfers.

00:03:06.315 --> 00:03:09.165
You only ever read distinct
input blocks once, and

00:03:09.165 --> 00:03:12.175
you only ever write distinct
output blocks once.

00:03:12.175 --> 00:03:15.605
So that's 2Ks over L block reads and
writes.

00:03:15.605 --> 00:03:17.155
What about comparisons?

00:03:17.155 --> 00:03:19.800
First, there's the initial
cost to build the heap,

00:03:19.800 --> 00:03:25.150
Then every one of the K times s items is
eventually either inserted or extracted.

00:03:25.150 --> 00:03:28.790
Since each insert or extract
costs you O of log K comparisons,

00:03:28.790 --> 00:03:33.470
then that's an additional asymptotic
cost of about Ks log K comparisons.

00:03:33.470 --> 00:03:36.100
Remember, that's for
a single k-way merge.

00:03:36.100 --> 00:03:39.488
Now's a good time to pause before
seeing what happens in the full K-way

00:03:39.488 --> 00:03:40.430
merge tree.

