WEBVTT
Kind: captions
Language: en

00:00:00.540 --> 00:00:04.430
I realize the two-level model may seem
like a bit of a cartoon compared to

00:00:04.430 --> 00:00:07.420
real memory hierarchies that you
know from either other courses or

00:00:07.420 --> 00:00:08.270
maybe even real life.

00:00:09.490 --> 00:00:10.598
So why bother?

00:00:10.598 --> 00:00:15.070
Well, the two-level model really
does capture the most important

00:00:15.070 --> 00:00:20.176
performance effects of real memories,
namely capacity and transfer size.

00:00:20.176 --> 00:00:23.511
Now, there's been a lot of research on
locality-sensitive algorithms based on

00:00:23.511 --> 00:00:24.270
this model.

00:00:24.270 --> 00:00:27.960
So, it's helpful to know it in order to
come up with sensible ways to extend it.

00:00:29.300 --> 00:00:32.400
To exploit a memory hierarchy
algorithmically, what can you do?

00:00:33.440 --> 00:00:36.780
The main technique you thought about
in this lesson is to organize your data

00:00:36.780 --> 00:00:39.980
access to increase data use.

00:00:39.980 --> 00:00:42.610
The other important pair of concepts
in this lesson were those of

00:00:42.610 --> 00:00:44.980
computational intensity and
machine balance.

00:00:46.110 --> 00:00:48.600
Here's a general rule of thumb
based on those two concepts.

00:00:49.680 --> 00:00:53.580
If you want your algorithm to scale
well to future memory hierarchies,

00:00:53.580 --> 00:00:57.010
then you want the intensity of your
algorithm to at least match, but

00:00:57.010 --> 00:01:00.400
preferably exceed the balance
point of the machine.

00:01:00.400 --> 00:01:03.410
You'll take this idea much further
in some of the other lessons.

