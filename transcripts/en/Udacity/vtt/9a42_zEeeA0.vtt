WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
This is our first programming assignment.

00:00:04.000 --> 00:00:09.000
In class, we localized the robot in a 1D world

00:00:09.000 --> 00:00:15.000
with a number of grid cells where each grid cell could have a different color,

00:00:15.000 --> 00:00:19.000
and the measurement vector was a sequence of observations.

00:00:19.000 --> 00:00:25.000
Our world was cyclic--if you fell off one end you would continue at the other end.

00:00:25.000 --> 00:00:33.000
In this assignment, I want you to do the same for 2D roles of arbitrary dimension.

00:00:33.000 --> 00:00:41.000
Just as before, begin with a uniform distribution as you always do in global localization.

00:00:41.000 --> 00:00:46.000
Then we have a number of motion commands--[0, 0] is no move,

00:00:46.000 --> 00:00:52.000
[0, 1] means you move to the right, [0, -1] means move left,

00:00:52.000 --> 00:01:00.000
[1, 0] makes you move down, not up, and [-1, 0] makes you move up.

00:01:00.000 --> 00:01:02.000
Again, the world shall be cyclic.

00:01:02.000 --> 00:01:09.000
If you fall off one end, like over here, we continue at the other end, like the one over here.

00:01:09.000 --> 00:01:15.000
Here is a simple example of the type code I give to you as a specification of the problem,

00:01:15.000 --> 00:01:20.000
and then you have to compute what my code computes but that it can't see right now.

00:01:20.000 --> 00:01:27.000
The world in this specific instance is a 3 x 3 matrix--3 row and 3 columns.

00:01:27.000 --> 00:01:30.000
It has only 2 possible colors, green or red,

00:01:30.000 --> 00:01:35.000
and this specific world has only a single red at the center location over here.

00:01:35.000 --> 00:01:38.000
We have a motion vector and a measurement vector.

00:01:38.000 --> 00:01:40.000
We start with a motion.

00:01:40.000 --> 00:01:45.000
This one says stay in place, and this was says we're going to observe red.

00:01:45.000 --> 00:01:50.000
Additionally, I give you two more variables called "sensor_right" and "p_move."

00:01:50.000 --> 00:01:54.000
Sensor_right is the probability that the sensor measurement is correct.

00:01:54.000 --> 00:01:59.000
In this specific instance, I set it to zero, which means the sensor value is always correct.

00:01:59.000 --> 00:02:05.000
P-move tells you at what probability the motion is executed correctly.

00:02:05.000 --> 00:02:08.000
Right now it's 1.0. It's always correct.

00:02:08.000 --> 00:02:11.000
If it's a smaller value, then the motion might fail,

00:02:11.000 --> 00:02:14.000
and when it fails, our robot won't move at all.

00:02:14.000 --> 00:02:17.000
Let's execute this.

00:02:17.000 --> 00:02:22.000
Here we didn't move, we observed red, and we had a noise-free sensor.

00:02:22.000 --> 00:02:26.000
As a result, we get a matrix that says zero everywhere

00:02:26.000 --> 00:02:32.000
except it's a 1 at the center location that has a red color.

00:02:32.000 --> 00:02:34.000
Let's modify the world.

00:02:34.000 --> 00:02:40.000
Let's make this grid cell red over here as well.

00:02:40.000 --> 00:02:43.000
Then now let's just rerun the code.

00:02:43.000 --> 00:02:47.000
What we get is a matrix just like the previous one,

00:02:47.000 --> 00:02:52.000
but now we have winning grid cells, both of which have a 0.5 probability

00:02:52.000 --> 00:02:55.000
so that all the probabilities add up to 1.

00:02:55.000 --> 00:02:59.000
Let's now model a noisy sensor

00:02:59.000 --> 00:03:03.000
and set sensor_right to 0.8.

00:03:03.000 --> 00:03:05.000
Your code should now computer the following:

00:03:05.000 --> 00:03:10.000
a 0.06 for almost all grid cells except the two winning ones,

00:03:10.000 --> 00:03:14.000
which come in at 0.26 and 0.26 each.

00:03:14.000 --> 00:03:16.000
Check that your code does this.

00:03:16.000 --> 00:03:19.000
Let's now bring in some motion.

00:03:19.000 --> 00:03:23.000
After not moving at all, I assume we're going to move 1 to the right,

00:03:23.000 --> 00:03:26.000
and we always have to have as many measurements as motions.

00:03:26.000 --> 00:03:29.000
So let me add a second measurement.

00:03:29.000 --> 00:03:31.000
Let's say we sense red again.

00:03:31.000 --> 00:03:34.000
Intuitively, this lands us in the square over here. Why?

00:03:34.000 --> 00:03:38.000
Well, we didn't move in the beginning, we saw red--

00:03:38.000 --> 00:03:42.000
there's two possibilities--but now we move again to the right side.

00:03:42.000 --> 00:03:45.000
We see red again. That makes this cell over here the most likely.

00:03:45.000 --> 00:03:53.000
Let's just check, and as predicted, almost all cells have a probability of 0.03.

00:03:53.000 --> 00:04:00.000
Some have 0.13, but the one over here has a probability of 0.533.

00:04:00.000 --> 00:04:05.000
If we set our sensor probability to 1.0, that is no sensor noise,

00:04:05.000 --> 00:04:12.000
we get back this array over here, which assigns all probability to the rightmost cell.

00:04:12.000 --> 00:04:17.000
Finally, I want to show you what happens if you modify the move variable.

00:04:17.000 --> 00:04:21.000
Say our motion succeeds only with 0.5 probability

00:04:21.000 --> 00:04:25.000
and with the remaining 0.5 we remained at the same location.

00:04:25.000 --> 00:04:28.000
This doesn't affect the first motion command,

00:04:28.000 --> 00:04:31.000
because success and failure is the same thing here. We don't move.

00:04:31.000 --> 00:04:34.000
But with this one over here there is a 50% chance of moving

00:04:34.000 --> 00:04:37.000
and a 50% chance of staying at the same location.

00:04:37.000 --> 00:04:41.000
Let's run the code. Here is our posterior probability.1

00:04:41.000 --> 00:04:47.000
The cell on the right still wins, but now with a smaller total probability of just 0.46.

00:04:47.000 --> 00:04:54.000
If we now assume perfect sensors, by setting sensor_right to 1.0

00:04:54.000 --> 00:04:56.000
we get this thing over here.

00:04:56.000 --> 00:05:00.000
We have 0.66 chance associated with the right cell over here

00:05:00.000 --> 00:05:05.000
and a 0.33 with the possibility that we moved this specific red here twice

00:05:05.000 --> 00:05:07.000
by just not moving in between.

00:05:07.000 --> 00:05:13.000
Check your code to make sure it gives you the exact same operative result.

00:05:13.000 --> 00:05:17.000
Finally, I want your code to execute input as complex as this one.

00:05:17.000 --> 00:05:23.000
This is a 4 x 5 world--4 rows and 5 columns, all with reds or greens.

00:05:23.000 --> 00:05:25.000
There's only two colors.

00:05:25.000 --> 00:05:30.000
There's a sequence of measurements of 5 elements and, correspondingly,

00:05:30.000 --> 00:05:32.000
a sequence of motions of 5 elements.

00:05:32.000 --> 00:05:34.000
All the measurements are green.

00:05:34.000 --> 00:05:40.000
The motions don't move at all, move right, move down, move down, and move right again.

00:05:40.000 --> 00:05:46.000
Then there are certain sensor probability and motion probabilities that I set at will.

00:05:46.000 --> 00:05:49.000
I set it to 0.7 and 0.8 over here.

00:05:49.000 --> 00:05:52.000
Now, if we look at the sequence, green, green, green, green, green,

00:05:52.000 --> 00:05:57.000
we first don't move at all, then move right, down, down, and right,

00:05:57.000 --> 00:06:04.000
you find that the most likely match in this world is we first sense this green over here.

00:06:04.000 --> 00:06:07.000
We then moved right to this green.

00:06:07.000 --> 00:06:12.000
We moved then down to this green, further down to this green, and right to this green.

00:06:12.000 --> 00:06:16.000
This would be the cell with the largest posterior probability.

00:06:16.000 --> 00:06:20.000
It is the 3rd row and the 4th column.

00:06:20.000 --> 00:06:23.000
Let's run it.

00:06:23.000 --> 00:06:25.000
And here is the result.

00:06:25.000 --> 00:06:30.000
It's somewhat illegible, and I apologize for the poor formatting of my Python routine.

00:06:30.000 --> 00:06:36.000
But if you look at these probabilities--0.011, 0.024, and so on--

00:06:36.000 --> 00:06:42.000
you'll find that indeed the largest element is the one over here--0.3535.

00:06:42.000 --> 00:06:49.000
And it's our 3rd row and our 4th column gives me this large probability.

00:06:49.000 --> 00:06:53.000
I want your code to produce numbers just like those,

00:06:53.000 --> 00:06:57.000
and we'll check that you got the code correctly.

00:06:57.000 --> 00:07:03.000
In summary, read your colors, build a probability distribution of the same dimensions--

00:07:03.000 --> 00:07:06.000
in this case 4 x 5--

00:07:06.000 --> 00:07:12.000
Initialize distribution, execute a motion first, then measurement, motion, measurement,

00:07:12.000 --> 00:07:14.000
motion, measurement, motion, measurement, and so on.

00:07:14.000 --> 00:07:19.000
You can safely assume that the measurement vector is of the same length as the motion vector,

00:07:19.000 --> 00:07:24.000
using the measurement correctness probability and motion success probability,

00:07:24.000 --> 00:07:28.000
and then compute an output of just the final distribution.

00:07:28.000 --> 00:07:31.000
If you've done this, you'll succeed.

