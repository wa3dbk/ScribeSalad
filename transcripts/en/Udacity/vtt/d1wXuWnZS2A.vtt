WEBVTT
Kind: captions
Language: en

00:00:00.340 --> 00:00:04.000
So far we have talked about
stack buffer overflows.

00:00:04.000 --> 00:00:08.670
Remember we started with the idea of
both overflows and then I quickly

00:00:08.670 --> 00:00:13.430
narrowed onto stack buffer overflows or
overflows on the stack.

00:00:13.430 --> 00:00:18.490
There are other variations of buffer
overflows and the number of reasons for

00:00:18.490 --> 00:00:19.650
those.

00:00:19.650 --> 00:00:23.010
We want to talk about
these different types or

00:00:23.010 --> 00:00:27.220
variations of buffer overflows before
we actually start talking works and

00:00:27.220 --> 00:00:32.360
defenses against these kinds of
attacks that exploit buffer overflow.

00:00:32.360 --> 00:00:35.200
So the first variation
we're going to talk about

00:00:35.200 --> 00:00:37.700
is what is called return-to-libc.

00:00:37.700 --> 00:00:44.250
Libc is the library, C library,
of a program's use library functions.

00:00:44.250 --> 00:00:48.850
So, remember when I was talking
about buffer overflow shell code,

00:00:48.850 --> 00:00:50.470
modifying return address.

00:00:50.470 --> 00:00:52.770
Our assumption was that we're
going to return address,

00:00:52.770 --> 00:00:55.700
it's going to be modified to
point to point to some place

00:00:55.700 --> 00:00:58.080
where we are able to
place the shell code.

00:00:58.080 --> 00:01:00.585
And that could be on the stack itself.

00:01:00.585 --> 00:01:05.825
In that case you were transfer control
to the shell code and execute it

00:01:05.825 --> 00:01:09.715
off the stack because that's where the
code is told, the shell code is told.

00:01:09.715 --> 00:01:12.625
We're going to talk about some
defenses where systems don't

00:01:12.625 --> 00:01:13.940
allow you to do that.

00:01:13.940 --> 00:01:18.610
So it's not easy to find room for
your shell code on the stack and

00:01:18.610 --> 00:01:19.910
get it executed.

00:01:19.910 --> 00:01:23.480
So the variations of
where you should return,

00:01:23.480 --> 00:01:28.300
you don't have to return to code that
is explicitly write as shell code, but

00:01:28.300 --> 00:01:31.100
you can return to
a function in the library.

00:01:31.100 --> 00:01:33.440
So the return address is
going to be modified.

00:01:33.440 --> 00:01:36.040
The return address that
we had on the stack,

00:01:36.040 --> 00:01:40.250
it's going to be modified to point
to a standard library function.

00:01:40.250 --> 00:01:43.130
So the assumption here is that
you'll be able to figure out

00:01:43.130 --> 00:01:45.020
the address of the library function.

00:01:45.020 --> 00:01:49.100
And once you have that,
that's what is going to overwrite.

00:01:49.100 --> 00:01:53.410
So when you do the stack buffer overflow
you make sure that library function

00:01:53.410 --> 00:01:58.460
address is what gets returned into the
return address field on the stack frame.

00:01:58.460 --> 00:02:00.000
So why do we want to do that?

00:02:00.000 --> 00:02:02.680
Why do you want to return
to a library function?

00:02:02.680 --> 00:02:06.270
Well if you return to the right
kind of library function.

00:02:06.270 --> 00:02:09.110
And you're able to setup
the arguments for it.

00:02:09.110 --> 00:02:12.820
Or the parameters before
the call happens on the stack.

00:02:12.820 --> 00:02:16.450
Then you can execute a library
function with arguments or

00:02:16.450 --> 00:02:22.150
parameters of your choice so think about
the library function called system.

00:02:22.150 --> 00:02:25.220
The system call,
if you look at it carefully,

00:02:25.220 --> 00:02:29.890
you can ask it to execute bin csh or
some csh or something like that.

00:02:29.890 --> 00:02:33.340
And as a result of executing this
function call you would launch

00:02:33.340 --> 00:02:34.950
a command shell.

00:02:34.950 --> 00:02:37.690
That's what our shell
code was doing before.

00:02:37.690 --> 00:02:41.680
Now we can get the same result
by executing a library function.

00:02:41.680 --> 00:02:43.410
And the reason it will do that for

00:02:43.410 --> 00:02:47.040
us is that before we make
the call to it we go to it by

00:02:47.040 --> 00:02:50.630
returning from this function where
we were able to overflow the buffer.

00:02:50.630 --> 00:02:54.620
We're going to set the stack in such
a way that the arguments actually

00:02:54.620 --> 00:02:56.350
are going to be such.

00:02:56.350 --> 00:02:59.160
So for example I said the system
calls should execute bin something.

00:02:59.160 --> 00:03:04.330
It's going to be such that when hit the
system library function or the library

00:03:04.330 --> 00:03:08.490
function's system, it's actually
going to do what you want it do.

00:03:08.490 --> 00:03:10.510
In particular give you a shell command.

00:03:10.510 --> 00:03:11.570
A command shell.

00:03:11.570 --> 00:03:16.560
So when that happens,
you actually then going to execute code

00:03:16.560 --> 00:03:19.470
that you didn't have to craft and
place on the stack.

00:03:19.470 --> 00:03:21.790
You're just executing
a library function.

00:03:21.790 --> 00:03:25.900
And you're manipulating its input
by properly crafting that input

00:03:25.900 --> 00:03:26.740
on the stack.

00:03:26.740 --> 00:03:28.980
And before you make this
library function call.

00:03:28.980 --> 00:03:31.870
And then it's going to do your
bidding if you are that hacker.

00:03:31.870 --> 00:03:36.960
So in libc, the thing to remember is
that the return address is modified

00:03:36.960 --> 00:03:42.480
to point to a chosen library function
and the setup is input in such a way

00:03:42.480 --> 00:03:46.680
that the execution library function,
with that input, allows the attacker

00:03:46.680 --> 00:03:50.600
to sort of gain control the same way we
were able to do before with shell code.

