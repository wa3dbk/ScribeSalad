WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.000
Okay, so this is what a random test is going to look like,

00:00:02.000 --> 00:00:04.000
and now let's look at the implementation in Python.

00:00:04.000 --> 00:00:07.000
And we're going to see is that since all I have is the reference implementation,

00:00:07.000 --> 00:00:10.000
not actually going to be testing two implementations against each other,

00:00:10.000 --> 00:00:14.000
rather all I'm going to be doing is making up two random 64-bit integers

00:00:14.000 --> 00:00:17.000
and just running the high common bits and low common bits function on them.

00:00:17.000 --> 00:00:19.000
We're going to do is we're going to be able to see code coverage, but I'm not actually checking

00:00:19.000 --> 00:00:22.000
the output for correctness, and I'm running a 100,000 test cases,

00:00:22.000 --> 00:00:25.000
so let's run this under the coverage harness.

00:00:25.000 --> 00:00:27.000
As you can see, I'm asking here for branch coverage.

00:00:27.000 --> 00:00:30.000
So, that's a lot of output, and the coverage should have been computed,

00:00:30.000 --> 00:00:33.000
and we see here is out of 25 statements around 23 of them

00:00:33.000 --> 00:00:37.000
a couple of statements were missing, and we had couple of partial branch coverage results.

00:00:37.000 --> 00:00:39.000
What you can see here is we've executed the body of the loops,

00:00:39.000 --> 00:00:44.000
and we've returned out of this path, but we failed to take the exit branch from the loop,

00:00:44.000 --> 00:00:46.000
and we failed to execute the return statement.

00:00:46.000 --> 00:00:48.000
The same thing is happened over here.

00:00:48.000 --> 00:00:51.000
So, let's asked ourselves why completely random testing with valid inputs

00:00:51.000 --> 00:00:54.000
a hundred thousand times did not manage to cover this.

00:00:54.000 --> 00:00:57.000
Well, of course, this is pretty easily to see, so we're generating two totally independent

00:00:57.000 --> 00:01:01.000
random 64-bit numbers, and the only way we can reach this case is fairly the same.

00:01:01.000 --> 00:01:05.000
So what are the odds of two randomly generating 64-bit integers being the same?

00:01:05.000 --> 00:01:07.000
They're extremely low compared to a number of test cases running.

00:01:07.000 --> 00:01:09.000
We're never going to test this case, so for testing optimized

00:01:09.000 --> 00:01:12.000
implementations of these functions in such matters quite a bit more.

00:01:12.000 --> 00:01:16.000
When we do optimize implementations of these functions, we're going to use specialized instructions

00:01:16.000 --> 00:01:19.000
that modern architecture support with providing bit counts.

00:01:19.000 --> 00:01:23.000
This is going to boil down to at least before using GCC as compiler

00:01:23.000 --> 00:01:27.000
functions like this builtin clz and builtin ctz, which as you can see,

00:01:27.000 --> 00:01:31.000
clz returned a number of leading 0-bits in x starting at the most significant bit position,

00:01:31.000 --> 00:01:37.000
and we can use this to implement one of our bit functions by XORing to the other the two operands

00:01:37.000 --> 00:01:43.000
to turn common bits into leading 0 bits, and so, we can do is using XOR operation to turn

00:01:43.000 --> 00:01:49.000
high order common bits in our arguments into leading 0 bits then we can use this builtin clz

00:01:49.000 --> 00:01:52.000
to implement an extremely fast version of the high common bits function

00:01:52.000 --> 00:01:57.000
and similarly, this builtin ctz can be used to build an extremely fast low common bits.

00:01:57.000 --> 00:02:02.000
If you see here, if x is 0, that is to say, if the two inputs are equal, the result is undefined.

00:02:02.000 --> 00:02:05.000
The implementation here has allowed to do something really weird

00:02:05.000 --> 00:02:08.000
in the case where we passed in two operands that are the same, but as we saw

00:02:08.000 --> 00:02:11.000
a little random testing here has only a negligible chance

00:02:11.000 --> 00:02:13.000
of actually generating two arguments that are actually the same.

00:02:13.000 --> 00:02:16.000
It's really a bad random test for this case. Let's go back and try to do better.

