WEBVTT
Kind: captions
Language: en

00:00:00.025 --> 00:00:03.615
[SOUND]
&gt;&gt; What's on your mind?

00:00:03.615 --> 00:00:06.253
&gt;&gt; Well, so I've been chatting
a lot with the developer about

00:00:06.253 --> 00:00:09.040
the order of certain events
which got me thinking.

00:00:09.040 --> 00:00:10.445
Let's say you have a user.

00:00:10.445 --> 00:00:11.910
&gt;&gt; Hm-hm.

00:00:11.910 --> 00:00:13.890
&gt;&gt; And the user does a couple of edits.

00:00:13.890 --> 00:00:17.440
If there any way you can know how
Firebase sends these edits to the server

00:00:17.440 --> 00:00:19.570
or what order they're processed in, or

00:00:19.570 --> 00:00:22.490
what order they'll trigger
event listeners in?

00:00:22.490 --> 00:00:25.270
&gt;&gt; I was just working through some
of these scenarios earlier today.

00:00:25.270 --> 00:00:28.360
It turns out that Firebase does have
what they call Event Guarantees.

00:00:28.360 --> 00:00:31.430
Which are guarantees about how
Firebase will handle your data.

00:00:31.430 --> 00:00:31.970
Let's take a look.

00:00:33.810 --> 00:00:37.910
&gt;&gt; Firebase provides several related
guarantees for database events.

00:00:37.910 --> 00:00:40.880
All Firebase operations
performed locally by your app

00:00:40.880 --> 00:00:42.990
will immediately fire events.

00:00:42.990 --> 00:00:46.330
Events are notifications such
as a child node was added or

00:00:46.330 --> 00:00:48.310
a child node was changed.

00:00:48.310 --> 00:00:50.300
This is helpful when there
is network latency or

00:00:50.300 --> 00:00:52.260
loss in internet connectivity.

00:00:52.260 --> 00:00:55.400
In these situations,
when connectivity is reestablished,

00:00:55.400 --> 00:00:58.260
the app will receive
the appropriate set of events and

00:00:58.260 --> 00:01:01.170
all the clients will catch up
with the current server state.

00:01:02.610 --> 00:01:06.110
Another guarantee is that
of Eventual Consistency.

00:01:06.110 --> 00:01:10.040
This means that events will eventually
reflect the correct state of the data

00:01:10.040 --> 00:01:12.660
even when temporary events such
as separate clients writing

00:01:12.660 --> 00:01:15.920
similar changes to the database
at approximately the same time,

00:01:15.920 --> 00:01:18.820
prevents an immediate
update to the database.

00:01:18.820 --> 00:01:20.470
After some time passes,

00:01:20.470 --> 00:01:24.130
the database will become
consistent with all the changes.

00:01:24.130 --> 00:01:26.270
A third guarantee is Event Order.

00:01:26.270 --> 00:01:29.300
Rights from a single client will
always be written in to the server and

00:01:29.300 --> 00:01:32.540
broadcast out to other users in order.

00:01:32.540 --> 00:01:36.400
If a single client performs right
operations to three locations in its

00:01:36.400 --> 00:01:37.610
Firebase database,

00:01:38.880 --> 00:01:43.540
those three operations will be delivered
to all currently connected clients

00:01:43.540 --> 00:01:47.180
in the same order that
the originating client sent them in.

00:01:47.180 --> 00:01:50.950
Finally, Firebase guarantees that
whenever something is read from

00:01:50.950 --> 00:01:54.350
the database with a value
event type object.

00:01:54.350 --> 00:01:58.310
For example, add value event listener or
add listener for

00:01:58.310 --> 00:02:00.740
single value event,
it is triggered last.

00:02:00.740 --> 00:02:05.270
This is in the case where you have
both child event listeners and

00:02:05.270 --> 00:02:08.235
value event listeners
on the same location.

00:02:08.235 --> 00:02:10.824
The child event listeners
will be triggered first.

00:02:10.824 --> 00:02:15.045
So when data is stored or when it
changes the order is, data is written or

00:02:15.045 --> 00:02:18.815
updated, the data is then
synchronized to a data snapshot,

00:02:18.815 --> 00:02:22.285
child events are triggered, and
then the value events are triggered.

