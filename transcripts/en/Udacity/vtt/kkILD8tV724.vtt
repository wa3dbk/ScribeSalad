WEBVTT
Kind: captions
Language: en

00:00:00.222 --> 00:00:04.555
Before we dive into the session material, 
let's talk a bit about storing

00:00:04.596 --> 00:00:06.921
or persisting data in Android.

00:00:07.444 --> 00:00:11.139
First of all, why do we bother 
to persist things at all?

00:00:11.139 --> 00:00:16.044
This is the era of the connected cloud.
Why don't we always fetch from there?

00:00:16.044 --> 00:00:20.096
It's really nice to not start the app
and see, Loading, or, even worse,

00:00:20.096 --> 00:00:22.004
like this, a blank screen.

00:00:22.088 --> 00:00:25.767
The faster people can use an app,
the more it will be used.

00:00:25.767 --> 00:00:30.090
Obviously, if one has to select Refresh
to get it to display anything,

00:00:30.090 --> 00:00:32.112
that would be particularly bad.

00:00:32.112 --> 00:00:36.648
Another reason to persist our data,
is that using any radio is detrimental

00:00:36.648 --> 00:00:40.795
to the battery life of the device,
especially the cellular radio.

00:00:40.795 --> 00:00:44.459
Many users aren't on meter data plans
or may be roaming

00:00:44.459 --> 00:00:46.229
when they want to use your app.

00:00:46.229 --> 00:00:49.688
All those unnecessary 
data fetches can add up.

00:00:49.723 --> 00:00:51.871
There are still lots of places
that don't have

00:00:51.871 --> 00:00:53.941
a network connection available.

00:00:53.945 --> 00:00:56.914
One of the prime advantages 
of having a mobile app is

00:00:56.914 --> 00:01:00.610
being resistant to bad
or non-existent network conditions.

00:01:00.610 --> 00:01:06.045
After all, you never know where the user
will want to use your app.

00:01:06.998 --> 00:01:12.106
As you might expect, Android stores
your persistent data in the file system.

00:01:12.677 --> 00:01:15.373
These files can be stored 
in internal storage

00:01:15.373 --> 00:01:17.244
that is private to your app.

00:01:17.244 --> 00:01:20.942
They can also be stored in shared 
or external storage.

00:01:21.021 --> 00:01:23.711
On older Android devices, 
this shared storage

00:01:23.711 --> 00:01:26.584
was actually on an external memory card.

00:01:26.584 --> 00:01:29.988
Today, most Android devices 
only emulate this card

00:01:29.988 --> 00:01:34.639
so that there is the shared external 
storage apps need available on the device.

00:01:34.702 --> 00:01:37.796
Some Android devices 
have emulated shared storage

00:01:37.796 --> 00:01:40.782
and secondary external storage.

00:01:40.782 --> 00:01:45.334
Android 4.4 Kit Kat added an API 
to allow developers to access

00:01:45.334 --> 00:01:47.801
this secondary external storage.

00:01:47.801 --> 00:01:51.093
We're going to focus 
on internal storage in this class.

00:01:51.165 --> 00:01:55.649
Check the Instructor Notes to learn more
about Android storage locations.

00:01:56.084 --> 00:01:57.781
As I mentioned before,

00:01:57.781 --> 00:02:00.605
Android persists data 
into the file system.

00:02:00.690 --> 00:02:04.930
It does provide two functional layers
on top of the file system in the form

00:02:04.930 --> 00:02:07.378
of shared preferences and SQLite.

00:02:07.645 --> 00:02:10.871
The Shared Preferences class 
provides a general framework

00:02:10.871 --> 00:02:14.244
that allows you to save 
and retrieve persistent key value pairs

00:02:14.244 --> 00:02:19.816
of primitive data types, such as booleans,
floats, ints, longs and strings.

00:02:20.282 --> 00:02:23.377
Shared Preferences is used 
by the Android preference activity

00:02:23.377 --> 00:02:26.296
to store our settings data 
such as the location.

00:02:26.296 --> 00:02:29.605
Why store things in a SQLite database?

00:02:29.605 --> 00:02:34.723
After all, Android supports 
both RAW files and Shared Preferences.

00:02:35.349 --> 00:02:39.835
For the same reason that it's inefficient
to find things if you throw your clothes

00:02:39.835 --> 00:02:41.145
in a pile on the floor.

00:02:41.651 --> 00:02:46.554
Storing things in an SQLite database 
helps you organize and find data easily,

00:02:46.554 --> 00:02:48.963
thanks to the power 
of indexing in tables.

00:02:49.632 --> 00:02:54.505
An SQLite database looks something like
this fragment from our weather database.

00:02:54.505 --> 00:02:57.362
Note that not all fields are represented.

00:02:57.362 --> 00:03:00.831
We can perform queries using SQL 
against this database,

00:03:00.831 --> 00:03:03.237
such as the SELECT statement here,

00:03:03.237 --> 00:03:06.192
which returns the weather
on the specified date,

00:03:06.192 --> 00:03:08.776
similar to what we'll want to do
for the DetailView.

00:03:09.044 --> 00:03:13.295
We can use a slightly more complex query
to return a range of dates

00:03:13.575 --> 00:03:16.893
which is similar to what we do 
on the main forecast ListView.

