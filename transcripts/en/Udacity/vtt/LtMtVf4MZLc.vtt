WEBVTT
Kind: captions
Language: en

00:00:00.140 --> 00:00:03.240
You've been working a lot with and and or now, and the expressions got kind of

00:00:03.240 --> 00:00:08.263
complicated. In fact, so complicated that they've attracted the interest of

00:00:08.263 --> 00:00:13.900
mathematicians, such as this stern looking fellow. His name is George Boole.

00:00:13.900 --> 00:00:17.612
And he figured out the rules for working with conditions that could be true or

00:00:17.612 --> 00:00:23.480
false. And ever since, that's been called Boolean logic. Now, why do we care?

00:00:23.480 --> 00:00:27.478
We want our programs to be simpler to read. And so, when we have a long and

00:00:27.478 --> 00:00:30.598
complex condition, such as this one, we might want to put it in a separate

00:00:30.598 --> 00:00:35.877
method. Let's think about what this test here was. This was the test for the s

00:00:35.877 --> 00:00:41.659
flag, where you had a blue square in the middle. And this test you checked, is

00:00:41.659 --> 00:00:46.080
our pixel, in the middle. Alright, so if we had a method that could test that,

00:00:46.080 --> 00:00:51.470
we could say, if x and y is in the middle, then we want blue, otherwise white.

00:00:51.470 --> 00:00:55.930
Much easier to read. let's go and write this method. Here it is, isInMiddle,

00:00:55.930 --> 00:01:00.132
takes and x and a y, coordinate. And here, you have the exact same condition

00:01:00.132 --> 00:01:04.500
that we've had before. And we simply compute, and return that. There's just one

00:01:04.500 --> 00:01:09.184
catch. We have to specify a return type for this method. And what is this thing

00:01:09.184 --> 00:01:13.315
that's being returned? Well it's either true or false. In Java, the type, that

00:01:13.315 --> 00:01:17.965
has two values, true and false, is called, Boolean, in honor, of our friend

00:01:17.965 --> 00:01:23.470
George. Here it is. So when you have a method, that can return a condition,

00:01:23.470 --> 00:01:28.843
that's true or false, you declare it as a Boolean method. Then you can use that

00:01:28.843 --> 00:01:32.914
method inside an if statement just as much as you can use the relational

00:01:32.914 --> 00:01:38.224
operator. You would want to do that whenever a condition has become so

00:01:38.224 --> 00:01:43.040
complicated, that you want to put it inside its own method. You can also

00:01:43.040 --> 00:01:55.490
declare variables of Boolean type. Let me give you a quick example. [SOUND].

00:01:55.490 --> 00:02:00.050
I've reimplemented the isInMiddle method to use two Boolean variables. Let's

00:02:00.050 --> 00:02:04.230
check it out. The first variable, x in middle, checks where the x is between 1

00:02:04.230 --> 00:02:09.530
3rd and 2 3rds of the weight. It's said to true if this condition is fulfilled.

00:02:09.530 --> 00:02:14.709
Or to false if it's not. And similarly. This variable over here, yInMiddle, is

00:02:14.709 --> 00:02:19.796
set to true when this condition is fulfilled, and to false if it's not. Why

00:02:19.796 --> 00:02:24.561
might I want to do this? Because each of those conditions is complicated enough

00:02:24.561 --> 00:02:30.240
that by saving it in a variable, it makes the code easier to read. Now over

00:02:30.240 --> 00:02:34.650
here, I say if both of these conditions are fulfilled then the point is in the

00:02:34.650 --> 00:02:40.558
middle, so I return the and of these two. Generally, you use a Boolean variable

00:02:40.558 --> 00:02:43.798
if you want to remember a value that's true of false, so that you can use it

00:02:43.798 --> 00:02:50.839
later. Sarah has an example of that for you, in a different context.

