WEBVTT
Kind: captions
Language: en

00:00:00.250 --> 00:00:03.410
What we have discussed so
far are the so-called flat page tables,

00:00:03.410 --> 00:00:06.770
where for every page number,
there is an entry in the table.

00:00:06.770 --> 00:00:10.280
Let's talk about the size
of such a flat page table.

00:00:10.280 --> 00:00:14.985
It has one entry per page in
the entire virtual address space.

00:00:14.985 --> 00:00:19.185
Even for pages in the address space that
the program never actually accesses,

00:00:19.185 --> 00:00:23.565
such as those pages that sit
between the heap and the stack.

00:00:23.565 --> 00:00:27.815
The entry in such a page table
contains the frame number,

00:00:27.815 --> 00:00:31.435
plus a few bits that tell us
if the page is accessible.

00:00:31.435 --> 00:00:33.595
For example, the protection bits or

00:00:33.595 --> 00:00:37.380
a bit that tells us that the page is
not really in physical memory at all.

00:00:37.380 --> 00:00:40.630
So the entry in the page table
is typically similar in size to

00:00:40.630 --> 00:00:42.370
the actual physical address.

00:00:42.370 --> 00:00:45.880
The entry needs to
contain the frame number,

00:00:45.880 --> 00:00:48.310
which is most of the bits
in the physical address.

00:00:48.310 --> 00:00:52.130
It doesn't need to contain the page
offset that the physical address has,

00:00:52.130 --> 00:00:54.130
but it needs to contain some extra bits.

00:00:54.130 --> 00:00:56.560
So overall,
if we have a 32 bit physical address,

00:00:56.560 --> 00:00:59.770
probably the entry size in
the page table will be 32 bits.

00:00:59.770 --> 00:01:04.160
If we have a 64 bit physical address,
probably the entry size will be 64 bits.

00:01:04.160 --> 00:01:08.760
So the overall size of a page
table is the overall size of

00:01:08.760 --> 00:01:13.890
the virtual memory of a process
divided by the page size.

00:01:13.890 --> 00:01:17.550
This is how many entries
we have in the page table,

00:01:17.550 --> 00:01:20.330
times the size of a page table entry.

00:01:20.330 --> 00:01:25.100
Let's look at an example where the
virtual memory size is 4 gigabytes for

00:01:25.100 --> 00:01:31.670
a process, the page size is 4 kilobytes,
and the size of an entry is 4 bytes.

00:01:31.670 --> 00:01:37.540
In that case, we get a 4
megabyte page table per process.

00:01:37.540 --> 00:01:42.570
Now note, that a process might actually
be using less than four megabytes of

00:01:42.570 --> 00:01:47.200
actual virtual memory, because most of
the pages are unused in such a process.

00:01:47.200 --> 00:01:50.680
Yet, the page table still
needs to be four megabytes.

00:01:50.680 --> 00:01:53.160
So one problem with
the flat page tables,

00:01:53.160 --> 00:01:57.220
is that the page table
is reasonably large,

00:01:57.220 --> 00:02:01.930
even if the process uses very little
of its available virtual memory.

00:02:01.930 --> 00:02:07.120
The other problem with the flat page
table is that if the virtual memory

00:02:07.120 --> 00:02:13.010
is a 64 bit address space, so if the
virtual memory's 2 to the 64th bytes,

00:02:13.010 --> 00:02:18.210
then we are talking about a page table
that is four billion times this,

00:02:18.210 --> 00:02:20.750
which is much larger than
the memory we actually have.

00:02:20.750 --> 00:02:25.920
So the page table like this simply
cannot fit in memory if we have a large

00:02:25.920 --> 00:02:31.500
virtual address space, and today's
processors have such a large space.

00:02:31.500 --> 00:02:34.100
So we need to reorganize
the page table so

00:02:34.100 --> 00:02:35.820
that it doesn't occupy this much space.

