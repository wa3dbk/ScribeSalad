WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:02.370
Now what if we're writing JSON? Well the function for writing

00:00:02.370 --> 00:00:07.740
JSON is called dumps. And just like we had, loads, this stands

00:00:07.740 --> 00:00:11.300
for dump string. If we just use dump in Python that

00:00:11.300 --> 00:00:13.750
would expect a, a file argument so we're writing it directly to

00:00:13.750 --> 00:00:16.750
a file. But we'll be just be using dumps. And you

00:00:16.750 --> 00:00:19.760
can pass into dumps a Python object, in this case let's just

00:00:19.760 --> 00:00:22.820
say one, two, three, a list. And dumps will convert that to

00:00:22.820 --> 00:00:25.320
JSON for us. Let's go ahead and see that in the terminal.

00:00:25.320 --> 00:00:27.030
You can see I didn't put quotes around this, because this is

00:00:27.030 --> 00:00:30.790
the actual list object we've converting to JSON. It outputs a string,

00:00:30.790 --> 00:00:33.870
that's what these quotes are, of the JSON representation, which looks almost

00:00:33.870 --> 00:00:37.570
identical. That's pretty cool, huh? And if we were to make this object

00:00:37.570 --> 00:00:41.120
a little bit more complicated, map the string "one" to the number

00:00:41.120 --> 00:00:43.660
1 and "two" to the number 2, we get our JSON. Now, the

00:00:43.660 --> 00:00:47.220
order changed, because order is not defined in dictionaries, but we get

00:00:47.220 --> 00:00:50.380
our JSON. Now, let's see where escaping comes into play. If I were

00:00:50.380 --> 00:00:53.090
to, instead, print the string two, we ought to make

00:00:53.090 --> 00:00:57.910
this string the man said cool. What would dumps do? So

00:00:57.910 --> 00:00:59.740
what I did is I changed the value for the,

00:00:59.740 --> 00:01:03.465
the, the two key to a string. Remember, these single quotes

00:01:03.465 --> 00:01:05.860
are delineating the string. And then, the string has an

00:01:05.860 --> 00:01:09.410
internal section with double quotes in it. Our JSON library will

00:01:09.410 --> 00:01:11.750
escape that for us. And you can see here that

00:01:11.750 --> 00:01:15.490
it is printing out a Python string that is valid JSON.

00:01:15.490 --> 00:01:17.820
And the Python version of the string has double quotes in it.

00:01:17.820 --> 00:01:21.390
I mean, double slashes in it. You need to be careful because this

00:01:21.390 --> 00:01:26.780
is not, in itself, valid JSON. This is valid Python representing valid

00:01:26.780 --> 00:01:28.720
JSON. That's why you have these double slashes. So you need to be

00:01:28.720 --> 00:01:33.090
careful when you are copying and pasting code, you know, or copying

00:01:33.090 --> 00:01:35.270
and pasting JSON, and it's in and out of Python that you get

00:01:35.270 --> 00:01:37.740
the escaping right. If I were to take this and instead print

00:01:37.740 --> 00:01:40.760
it so you can see the actual value, we'd just have the single

00:01:40.760 --> 00:01:44.140
backslashes which is the actual valid JSON, so. Time for a

00:01:44.140 --> 00:01:47.740
quick little quiz. Okay. What is the valid JSON representation for

00:01:47.740 --> 00:01:51.800
this Python data structure? So this is Python code. We'll include

00:01:51.800 --> 00:01:53.880
text version of this so you can copy and paste it into

00:01:53.880 --> 00:01:56.100
your editor. And I'd like you to put in this text

00:01:56.100 --> 00:02:00.200
box what the valid JSON version of this is. Basically, I'm

00:02:00.200 --> 00:02:02.870
testing the, your ability to use the JSON module, and have

00:02:02.870 --> 00:02:06.200
it escape properly. Now remember, I don't want to see the Python

00:02:06.200 --> 00:02:08.090
version of the JSON string. I want to see

00:02:08.090 --> 00:02:10.360
the actual JSON string, that if you were sending

00:02:10.360 --> 00:02:12.260
this over the wire to somebody that would

00:02:12.260 --> 00:02:15.020
be interpreted properly by the JSON reader. Good luck.

