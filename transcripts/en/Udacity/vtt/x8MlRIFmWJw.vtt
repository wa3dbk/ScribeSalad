WEBVTT
Kind: captions
Language: en

00:00:00.240 --> 00:00:04.150
So far, we've built up a healthy
collection of NP-complete problems.

00:00:04.150 --> 00:00:07.050
But given that there are thousands
of known NP-complete problems,

00:00:07.050 --> 00:00:09.060
we've only scratched the surface.

00:00:09.060 --> 00:00:12.850
In fact, we haven't even come close
to Karp's mark of 21 problems from

00:00:12.850 --> 00:00:14.630
his 1972 paper.

00:00:14.630 --> 00:00:17.735
If you want to go on and extend the set
of problems that you can prove to be

00:00:17.735 --> 00:00:22.375
NP-complete, you might consider reducing
subset sum to the knapsack problem.

00:00:22.375 --> 00:00:25.700
Where one has a fixed capacity for
carrying stuff, and

00:00:25.700 --> 00:00:29.470
wants to pack the largest value
of subset items that will fit.

00:00:29.470 --> 00:00:32.820
Another classic problem is that
of the traveling salesman.

00:00:32.820 --> 00:00:36.660
He has a list of cities that he wants to
visit, and he wants to know the order

00:00:36.660 --> 00:00:38.930
that will minimize the distance
that he has to travel.

00:00:40.170 --> 00:00:42.720
One can prove that this
problem is NP-complete

00:00:42.720 --> 00:00:47.690
by first reducing vertex cover to the
Hamiltonian Cycle problem, which asks if

00:00:47.690 --> 00:00:51.760
there's a cycle in the graph that
visits each vertex exactly once.

00:00:51.760 --> 00:00:54.610
And then Hamiltonian Cycle
to traveling salesman.

00:00:54.610 --> 00:00:56.640
Another classic problem is 3D matching.

00:00:57.710 --> 00:01:00.140
2D matching can be
thought of as the problem

00:01:00.140 --> 00:01:03.630
of making as many compatible couples
as possible from a set of people.

00:01:04.790 --> 00:01:07.410
3D matching extends
this problem further.

00:01:07.410 --> 00:01:11.360
By matching them with a home that they
would enjoy living in together, and

00:01:11.360 --> 00:01:13.070
of course, there are many others.

00:01:13.070 --> 00:01:16.180
The point of this lesson, however, is
not so that you can produce the needed

00:01:16.180 --> 00:01:20.020
chain of reductions for
every problem known to be NP-complete.

00:01:20.020 --> 00:01:23.470
Rather it is to give you a sense for
what these arguments look like, and

00:01:23.470 --> 00:01:25.580
how you might go about
making such an argument for

00:01:25.580 --> 00:01:28.290
a problem that is of
particular interest to you.

00:01:28.290 --> 00:01:31.090
The reductions we've given as
examples are a fine start.

00:01:31.090 --> 00:01:33.890
But if you want to go further in
understanding how to use complexity to

00:01:33.890 --> 00:01:37.650
understand real-world problems, take
a look at the classic text by Garey and

00:01:37.650 --> 00:01:39.830
Johnson on Computers and Intractability.

00:01:40.860 --> 00:01:44.320
Even though it's from the same decade
as the original Cook-Levin result, and

00:01:44.320 --> 00:01:48.950
Karp's list of 21 NP-complete problems,
it's still one of the best.

00:01:48.950 --> 00:01:52.770
As Lance says, a good computer scientist
shouldn't leave home without it.

00:01:52.770 --> 00:01:54.920
Now that you have a better
understanding of the nature and

00:01:54.920 --> 00:01:59.350
scope of the P versus NP question, we'll
return to high-level in the next lesson.

00:01:59.350 --> 00:02:03.168
The next question's like,
what would happen if P were equal to NP?

00:02:03.168 --> 00:02:05.520
What good might we be able to do?

00:02:05.520 --> 00:02:09.502
And in a world where P is not equal to
NP, what are the hopes for coping with

00:02:09.502 --> 00:02:12.330
the NP-completeness of problems
that we would really like to solve?

