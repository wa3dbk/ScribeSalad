WEBVTT
Kind: captions
Language: en

00:00:00.330 --> 00:00:03.660
I strongly advise you to look through the

00:00:03.660 --> 00:00:07.810
paper and understand both the link list version

00:00:07.810 --> 00:00:11.280
as well as the previous Anderson's array based

00:00:11.280 --> 00:00:13.950
lock version of the queuing locks. Because there

00:00:13.950 --> 00:00:16.640
are lots of subtleties in implementing these kinds

00:00:16.640 --> 00:00:20.020
of algorithms in the kernel and in the

00:00:20.020 --> 00:00:22.460
parallel operating system kernel. And therefore, it is

00:00:22.460 --> 00:00:25.470
important that you understand the subtleties by looking at

00:00:25.470 --> 00:00:28.900
the code. I've given you, of course, a description

00:00:28.900 --> 00:00:31.140
at a semantic level of what happens, but looking

00:00:31.140 --> 00:00:33.560
at the code will actually make it very clear

00:00:33.560 --> 00:00:37.770
what is going on in terms of writing a synchronization

00:00:37.770 --> 00:00:40.750
algorithm on a multiprocessor. And one of the things

00:00:40.750 --> 00:00:44.270
that I mentioned is that both the the link list

00:00:44.270 --> 00:00:46.230
based queuing lock as well as the earlier array

00:00:46.230 --> 00:00:50.620
based queuing lock required fancier re-modified write instruction. So for

00:00:50.620 --> 00:00:54.985
instance, in this case, we need a fetch and store, and in this case and also a

00:00:54.985 --> 00:00:59.540
compare and swap to fancier re-modified write instruct, instructions.

00:00:59.540 --> 00:01:02.250
And similarly the array based queuing log required a

00:01:02.250 --> 00:01:04.769
fetch and increment. Now it is possible that the

00:01:04.769 --> 00:01:07.080
architecture doesn't have that. If that is the case

00:01:07.080 --> 00:01:11.170
then you have to simulate these fancier read, modify,

00:01:11.170 --> 00:01:14.540
write instructions using a simpler test and sentence structure.

