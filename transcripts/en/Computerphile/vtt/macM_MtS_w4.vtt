WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.500
Today we are going to be talking about a problem in logic

00:00:03.500 --> 00:00:05.880
and how in solving that problem,

00:00:05.910 --> 00:00:10.250
Alan Turing almost inadvertently
invented the modern digital computer.

00:00:12.929 --> 00:00:16.890
So we start back at the beginning of the
20th century, where mathematicians had

00:00:16.890 --> 00:00:21.960
posed this problem - in logic we're
interested in finding "Do these premises

00:00:21.960 --> 00:00:27.660
entail this conclusion?" So premises are
the bits you start off with in an argument

00:00:27.660 --> 00:00:31.230
they are your -- the bits you know at the
beginning or your assumptions and the

00:00:31.230 --> 00:00:34.690
conclusion is the bit you want to
establish the bit that you reason to

00:00:34.710 --> 00:00:39.899
with your argument and we want to know
is there a test that will tell us

00:00:39.899 --> 00:00:43.140
yes for sure these premises do or don't

00:00:43.140 --> 00:00:47.219
entail this conclusion. Is there an
automatic way of finding out whether

00:00:47.219 --> 00:00:49.530
they do or whether they don't?

00:00:49.530 --> 00:00:53.430
So that's the problem, it's called the
decision problem.

00:00:53.430 --> 00:00:58.649
The mathematicians wanted to find out "Is
there an answer to the decision problem

00:00:58.649 --> 00:01:00.510
for first order logic?"

00:01:00.510 --> 00:01:04.500
that's the kind of logic you learn in
philosophy or mathematics at university

00:01:04.500 --> 00:01:09.810
so lots of mathematicians were trying to
work out is first order logic decidable

00:01:09.810 --> 00:01:13.680
that is can we automatically test
whether the premises entail the

00:01:13.680 --> 00:01:14.640
conclusion

00:01:14.640 --> 00:01:19.409
Alan Turing was one of the first to
discover that first order logic isn't

00:01:19.409 --> 00:01:23.640
decidable. To prove this

00:01:23.640 --> 00:01:28.320
it's really difficult conceptually
because you have to be able to show no

00:01:28.320 --> 00:01:35.159
possible program can give you the answer
but how do you do that how do you show

00:01:35.159 --> 00:01:38.250
something about every possible program

00:01:38.250 --> 00:01:41.340
you can't run through every program one
by one

00:01:41.340 --> 00:01:44.670
but Turing came up with a brilliant
solution

00:01:44.670 --> 00:01:47.909
his idea goes something like this

00:01:47.909 --> 00:01:52.829
suppose we have a program and let's just
draw it as a black box

00:01:53.610 --> 00:01:58.799
it's going to take some inputs and it's
going to give us some outputs

00:01:58.799 --> 00:02:04.799
our program is going to solve some
problem a problem like "Do the premises

00:02:04.800 --> 00:02:08.910
entail the conclusion" we ask it a
question and it will give us an answer

00:02:08.910 --> 00:02:12.030
yes or no

00:02:12.030 --> 00:02:17.190
now here's another question we can ask
let's look at all of those possible

00:02:17.190 --> 00:02:21.450
programs and we're just thinking of them
as black boxes at the moment we might

00:02:21.450 --> 00:02:26.819
want to know is this program given a
certain input going to give us an answer

00:02:26.819 --> 00:02:33.030
or is it going to trundle on forever and
never give us an answer that is is it

00:02:33.030 --> 00:02:35.400
going to halt or is it not going to halt

00:02:35.400 --> 00:02:39.569
eventually so think about your computer
running you want it to give you an

00:02:39.569 --> 00:02:42.989
answer of whether it's a good answer or
a bad answer

00:02:42.989 --> 00:02:47.760
it's better than no answer. No answer
would mean the computer trundles around

00:02:47.760 --> 00:02:51.510
forever and ever in a loop and you would
just never know whether it's going to

00:02:51.510 --> 00:02:54.000
finish today tomorrow or never

00:02:54.000 --> 00:03:00.390
so halting is good so there's another
question we can ask given some program

00:03:00.390 --> 00:03:01.800
and some input

00:03:01.800 --> 00:03:07.680
will it ever halt? Now it turns out that
our logical problem

00:03:08.280 --> 00:03:15.150
"Do these premises entail this conclusion?"
is very similar to this halting problem

00:03:15.720 --> 00:03:20.880
in fact if we can solve the logical
problem then we can solve the halting

00:03:20.880 --> 00:03:21.959
problem

00:03:21.959 --> 00:03:27.900
will this program halt on this input so
the clever part of Turing's proof is

00:03:27.900 --> 00:03:33.720
to show that it's impossible for any
machine however clever it is to solve

00:03:33.720 --> 00:03:38.880
the halting problem that is to tell us
whether a given machine with a given

00:03:38.880 --> 00:03:42.840
input will halt or not - and here's how
he did it

00:03:42.840 --> 00:03:47.970
let's suppose we've got a machine or a
program that solves the problem for us

00:03:48.480 --> 00:03:52.680
it solves the halting problem don't
worry about how it works let's just

00:03:52.680 --> 00:03:56.730
think of it as a black box taking the
description of a machine and an input

00:03:56.730 --> 00:03:58.829
and giving us an answer

00:03:58.829 --> 00:04:02.760
yes it will halt or no it won't halt
just suppose that's possible

00:04:03.480 --> 00:04:07.980
call that machine "h" for the halting
problem - if you give me that machine

00:04:07.980 --> 00:04:10.980
I can transform it into a different
machine like this

00:04:11.549 --> 00:04:16.049
I stick some extra bits on it so that if
it gives me a yes answer

00:04:16.709 --> 00:04:19.919
I make it loop forever without ever
stopping

00:04:20.549 --> 00:04:22.980
if it gives me a no answer on the other
hand

00:04:22.980 --> 00:04:27.390
and it's going to halt straight away
let's call that big machine

00:04:28.050 --> 00:04:35.130
the whole thing "h+" now here's another
question we can ask what happens if I

00:04:35.130 --> 00:04:43.350
feed the whole machine into itself so
i'm going to put h+ in here and h+

00:04:43.350 --> 00:04:44.520
in here

00:04:44.520 --> 00:04:51.870
so the question I'm now asking is I'm
feeding h+ into itself so i'm asking the

00:04:51.870 --> 00:04:58.410
question "Does h+ halt given input h+?"
and here's where it all goes wrong

00:04:58.410 --> 00:05:02.610
because if h plus does halt

00:05:02.610 --> 00:05:06.390
we get a yes answer but then it loops
forever

00:05:06.390 --> 00:05:10.980
so it doesn't halt on the other hand if
it doesn't halt

00:05:11.550 --> 00:05:16.620
we get a no answer but then it halts so
if it does halt then it doesn't halt

00:05:17.190 --> 00:05:22.350
but if it doesn't halt then it does
halt. Either way we get a contradiction

00:05:22.350 --> 00:05:27.420
it's a paradox but what that shows is we
started off assuming that we can solve

00:05:27.420 --> 00:05:28.530
the problem

00:05:28.530 --> 00:05:32.520
we've ended up with a paradox so our
assumption was bad

00:05:32.520 --> 00:05:36.120
it turns out there's no possible machine

00:05:36.120 --> 00:05:39.120
no possible program that solves the
halting problem

00:05:39.660 --> 00:05:44.070
the really clever bit about Turing's
idea is it doesn't matter what kind of

00:05:44.070 --> 00:05:49.200
program our machine is. It doesn't matter
whether it's an abstract algorithm

00:05:49.200 --> 00:05:52.770
whether it's a real computer, a physical
computer

00:05:52.770 --> 00:05:57.120
it doesn't matter what it is we've prove
that no such program as possible

00:06:00.249 --> 00:06:06.339
Turing as part of his argument had to
say a little bit about what's going on

00:06:06.340 --> 00:06:11.349
in these black boxes //DFB: and the idea is
that every card represents an instruction

00:06:11.349 --> 00:06:13.149
in the Turing machine

