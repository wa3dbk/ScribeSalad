WEBVTT
Kind: captions
Language: en

00:00:00.269 --> 00:00:04.480
UTF-8 is perhaps the best hack,

00:00:04.480 --> 00:00:08.040
the best single thing that's used

00:00:08.040 --> 00:00:10.180
that can be written down on the back of a napkin,

00:00:10.180 --> 00:00:11.580
and that's how was it was put together.

00:00:11.590 --> 00:00:16.050
The first draft of UTF-8 was written on the back of a napkin in a diner

00:00:16.050 --> 00:00:18.410
and it's just such an elegant hack

00:00:18.410 --> 00:00:21.260
that solved so many problems and I
absolutely love it.

00:00:23.600 --> 00:00:24.720
Back in the 1960s,

00:00:24.730 --> 00:00:28.230
we had teleprinters, we had simple
devices where you type a key

00:00:28.230 --> 00:00:31.500
and it sends some numbers and the same letter comes out on the other side,

00:00:31.500 --> 00:00:34.649
but there needs to be a standard so in
the mid-1960s

00:00:34.649 --> 00:00:40.229
America, at least, settled on ASCII, which is the American Standard Code for Information Interchange,

00:00:40.230 --> 00:00:42.410
and it's a 7-bit binary system,

00:00:42.410 --> 00:00:43.940
so each letter you type in

00:00:43.940 --> 00:00:48.280
gets converted into 7 binary numbers and sent over the wire.

00:00:48.280 --> 00:00:52.760
Now that means you can have numbers from 0 to 127.

00:00:52.760 --> 00:00:58.340
They sort of moved the first 32 for control codes and less important stuff for writing,

00:00:58.340 --> 00:01:01.280
things like like "go down a line" or backspace.

00:01:01.860 --> 00:01:05.920
And then they made the rest characters. They added some numbers, some punctuation marks.

00:01:05.920 --> 00:01:12.460
They did a really clever thing, which is that they made 'A' 65 which, in binary—

00:01:12.460 --> 00:01:18.000
find 1, 2, 4, 8, 16, 32, 64—

00:01:18.000 --> 00:01:25.220
in binary, 65 is 1000001,

00:01:25.220 --> 00:01:31.340
which means that 'B' is 66, which means you've got 2 in binary just here.

00:01:31.340 --> 00:01:34.800
C, 67, 3 in binary.

00:01:34.800 --> 00:01:39.900
So you can look at a 7-bit binary character and just knock off the first two digits

00:01:39.900 --> 00:01:41.760
and know what its position in the alphabet is.

00:01:41.760 --> 00:01:45.800
Even cleverer than that, they started lowercase 32 later,

00:01:45.800 --> 00:01:51.980
which means that lowercase 'a' is 97—1100001.

00:01:51.980 --> 00:01:56.560
Anything that doesn't fit into that is probably a space, which conveniently will be all zeroes,

00:01:56.560 --> 00:01:58.600
or some kind of punctuation mark.

00:01:58.600 --> 00:02:01.900
Brilliant, clever, wonderful, great way of doing things,

00:02:01.900 --> 00:02:05.600
and that became the standard, at least in the English-speaking world.

00:02:05.600 --> 00:02:09.840
As for the rest of the world, a few of them did versions of that,

00:02:09.840 --> 00:02:14.780
but you start getting into other alphabets, into languages that don't really use alphabets at all.

00:02:14.780 --> 00:02:18.700
They all came up with their own encoding, which is fine.

00:02:18.700 --> 00:02:22.620
And then along come computers, and, over time, things change.

00:02:22.620 --> 00:02:28.660
We move to 8-bit computers, so we now have a whole extra number at the start just to confuse matters,

00:02:28.660 --> 00:02:32.800
which means we can go to 256! We can have twice as many characters!

00:02:32.800 --> 00:02:38.200
And, of course, everyone settled on the same standard for this, because that would make perfect s—

00:02:38.200 --> 00:02:39.060
No. None of them did.

00:02:39.060 --> 00:02:43.080
All the Nordic countries start putting Norwegian characters and Finnish characters in there.

00:02:43.080 --> 00:02:46.680
Japan just doesn't use ASCII at all.

00:02:46.680 --> 00:02:51.900
Japan goes and creates its own multibyte encoding with more letters and more characters

00:02:51.900 --> 00:02:54.440
and more binary numbers going to each individual character.

00:02:54.440 --> 00:02:57.640
All of these things are massively incompatible.

00:02:57.640 --> 00:03:04.680
Japan actually has three or four different encodings, all of which are completely incompatible with each other.

00:03:04.680 --> 00:03:08.700
So you send a document from one old-school Japanese computer to another,

00:03:08.700 --> 00:03:14.100
it will come out so garbled that there is even a word in Japanese for "garbled characters,"

00:03:14.100 --> 00:03:17.600
which is—I'm probably mispronouncing this—but it's "mojibake."

00:03:17.600 --> 00:03:19.380
It's a bit of a nightmare, but it's not bad,

00:03:19.380 --> 00:03:23.340
because how often does someone in London have to send a document

00:03:23.340 --> 00:03:27.660
to a completely incompatible and unknown computer at another company in Japan?

00:03:27.660 --> 00:03:30.960
In those days, it's rare. You printed it off and you faxed it.

00:03:30.960 --> 00:03:36.300
And then the World Wide Web hit, and we have a problem,

00:03:36.300 --> 00:03:41.140
because suddenly documents are being sent from all around the world all the time.

00:03:41.140 --> 00:03:44.280
So a thing is set up called the Unicode Consortium.

00:03:44.280 --> 00:03:53.240
In what I can only describe as a miracle, over the last couple of decades, they have hammered out a standard.

00:03:53.240 --> 00:03:58.660
Unicode now have a list of more than a hundred thousand characters

00:03:58.660 --> 00:04:02.460
that covers everything you could possibly want to write in any language—

00:04:02.460 --> 00:04:10.180
English alphabet, Cyrillic alphabet, Arabic alphabet, Japanese, Chinese, and Korean characters.

00:04:10.180 --> 00:04:17.800
What you have at the end is the Unicode Consortium assigning 100,000+ characters to 100,000 numbers.

00:04:17.800 --> 00:04:22.340
They have not chosen binary digits. They have not chosen what they should be represented as.

00:04:22.340 --> 00:04:28.700
All they have said is that THAT Arabic character there, that is number 5,700-something,

00:04:28.700 --> 00:04:32.840
and this linguistic symbol here, that's 10,000-something.

00:04:32.840 --> 00:04:35.460
I have to simplify massively here because there are about,

00:04:35.460 --> 00:04:38.820
of course, five or six incompatible ways to do this,

00:04:38.820 --> 00:04:43.360
but what the web has more or less settled on is something called "UTF-8."

00:04:43.360 --> 00:04:47.600
There are a couple of problems with doing the obvious thing, which is saying,

00:04:47.600 --> 00:04:50.080
"OK. We're going to 100,000.

00:04:50.080 --> 00:04:56.380
That's gonna need, what... to be safe, that's gonna need 32 binary digits to encode it."

00:04:56.380 --> 00:05:03.520
They encoded the English alphabet in exactly the same way as ASCII did. 'A' is still 65.

00:05:03.520 --> 00:05:09.740
So if you have just a string of English text, and you're encoding it at 32 bits per character,

00:05:09.740 --> 00:05:15.200
you're gonna have about 20-something... 26? Yeah.

00:05:15.200 --> 00:05:20.680
26, 27 zeroes and then a few ones for every single character.

00:05:20.680 --> 00:05:22.280
That is incredibly wasteful.

00:05:22.280 --> 00:05:27.300
Suddenly every English language text file takes four times the space on disk.

00:05:27.300 --> 00:05:30.560
So problem 1: you have to get rid of all the zeroes in the English text.

00:05:30.560 --> 00:05:37.260
Problem 2: there are lots of old computer systems that interpret 8 zeroes in a row,

00:05:37.260 --> 00:05:40.620
a NULL, as "this is the end of the string of characters."

00:05:40.620 --> 00:05:45.240
so if you ever send 8 zeroes in a row, they just stop listening.

00:05:45.240 --> 00:05:48.020
They assume the string has ended there, and it gets cut off,

00:05:48.020 --> 00:05:51.720
so you can't have 8 zeroes in a row anywhere.

00:05:51.720 --> 00:05:56.440
'K. Problem number 3: it has to be backwards-compatible.

00:05:56.440 --> 00:06:03.800
You have to be able to take this Unicode text and chuck it into something that only understands basic ASCII,

00:06:03.800 --> 00:06:06.660
and have it more or less work for English text.

00:06:06.660 --> 00:06:12.100
UTF-8 solves all of these problems and it's just a wonderful hack.

00:06:12.100 --> 00:06:14.960
It starts by just taking ASCII.

00:06:14.960 --> 00:06:20.800
If you have something under 128, that can just be expressed as 7 digits,

00:06:20.800 --> 00:06:25.460
you put down a zero, and then you put the same numbers that you would otherwise,

00:06:25.460 --> 00:06:29.820
so let's have that 'A' again—there we go!

00:06:29.820 --> 00:06:35.380
That's still 'A.' That's still 65. That's still UTF-8-valid, and that's still ASCII-valid. Brilliant.

00:06:35.380 --> 00:06:38.100
OK. Now let's say we're going above that.

00:06:38.100 --> 00:06:43.280
Now you need something that's gonna work more or less for ASCII, or at least not break things,

00:06:43.280 --> 00:06:44.580
but still be understood.

00:06:44.580 --> 00:06:49.180
So what you do is you start by writing down "110."

00:06:49.180 --> 00:06:54.560
This means this is the start of a new character, and this character is going to be 2 bytes long.

00:06:54.560 --> 00:06:57.360
Two ones, two bytes, a byte being 8 characters.

00:06:57.360 --> 00:07:01.380
And you say on this one, we're gonna start it with "10," which means this is a continuation,

00:07:01.380 --> 00:07:05.520
and at all these blank spaces, of which you have 5 here and 6 here,

00:07:05.520 --> 00:07:07.920
you fill in the other numbers,

00:07:07.920 --> 00:07:11.060
and then when you calculate it, you just take off those headers,

00:07:11.060 --> 00:07:15.280
and it understands just  as being whatever number that turns out to be.

00:07:15.280 --> 00:07:17.880
That's probably somewhere in the hundreds.

00:07:17.880 --> 00:07:22.220
That'll do you for the first 4,096. What about above that?

00:07:22.220 --> 00:07:28.640
Well, above that you go "1110," meaning there are three bytes in this—three ones, three bytes—

00:07:28.640 --> 00:07:30.500
with two continuation bytes.

00:07:30.500 --> 00:07:35.240
So now you have 1, 2, 3, 4, 10, 16 spaces.

00:07:35.240 --> 00:07:36.560
You want to go above that? You can.

00:07:36.560 --> 00:07:46.020
This specification goes all the way to "1111110x" with this many continuation bytes after it.

00:07:46.020 --> 00:07:50.000
It's a neat hack that you can explain on the back of a napkin or a bit of paper.

00:07:50.000 --> 00:07:57.420
It's backwards-compatible. It avoids waste. At no point will it ever, ever, ever send 8 zeroes in a row,

00:07:57.420 --> 00:08:01.960
and, really, really crucially, the one that made it win over every other system

00:08:01.960 --> 00:08:05.520
is that you can move backwards and forwards really easily.

00:08:05.520 --> 00:08:08.180
You do not have to have an index of where the character starts.

00:08:08.180 --> 00:08:12.520
If you are halfway through a string and you wanna go back one character,

00:08:12.520 --> 00:08:14.940
you just look for the previous header.

00:08:14.940 --> 00:08:16.060
And that's it, and that works,

00:08:16.060 --> 00:08:22.420
and, as of a few years ago, UTF-8 beat out ASCII and everything else as, for the first time,

00:08:22.420 --> 00:08:25.140
the dominant character encoding on the web.

00:08:25.140 --> 00:08:28.900
We don't have that mojibake that Japanese has.

00:08:28.900 --> 00:08:35.000
We have something that nearly works, and that is why it's the most beautiful hack that I can think of

00:08:35.000 --> 00:08:38.000
that is used around the world every second of every day.

00:08:40.840 --> 00:08:45.180
(BRADY HARAN)
-We'd like to think Audible.com for their support of this Computerphile video,

00:08:45.180 --> 00:08:49.880
and, if you register with Audible and go to audible.com/computerphile,

00:08:49.880 --> 00:08:52.640
you can download a free audiobook.

00:08:52.640 --> 00:08:58.200
They've got a huge range of books at Audible. I'd like to recommend "The Last Man On the Moon,"

00:08:58.200 --> 00:09:04.740
which is by Eugene Cernan who is the eleventh of twelve men to step onto the Moon.

00:09:04.740 --> 00:09:07.000
but he was the last man to step off the Moon,

00:09:07.000 --> 00:09:10.560
so I'm not sure whether or not he is "the last man on the Moon" or not.

00:09:10.560 --> 00:09:12.500
Sort of depends how you define it.

00:09:12.500 --> 00:09:17.660
But his book is really good, and what I really like about it is it's read by Cernan himself,

00:09:17.660 --> 00:09:18.760
which I think is pretty cool

00:09:18.760 --> 00:09:23.720
Again, thanks to Audible. Go to audible.com/computerphile

00:09:23.720 --> 00:09:25.100
and get a free audiobook.

00:09:25.100 --> 00:09:29.760
(TOM SCOTT)
-"... an old system that hasn't been programmed well will take those nice curly quotes

00:09:29.760 --> 00:09:33.560
that Microsoft Word has put into Unicode, and it will look at that and say,

00:09:33.560 --> 00:09:36.640
'That is three separate characters...' "

