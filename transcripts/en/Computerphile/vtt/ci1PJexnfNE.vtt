WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.609
There are very good reasons for C
occupying a special place in the

00:00:05.609 --> 00:00:10.830
firmament of languages, although I think
one thing to say at the outset is [that] really

00:00:10.830 --> 00:00:19.020
it finds its maximum power - it's maximum
raison d'etre for even existing at all - if you

00:00:19.020 --> 00:00:27.180
think of it as being the classical
system implementation language. Again, for

00:00:27.180 --> 00:00:31.560
younger viewers, it's going to be hard to
understand and comprehend this. But if

00:00:31.560 --> 00:00:37.680
you go back to the early mainframe era
you're getting really, really, powerful

00:00:37.680 --> 00:00:42.840
computers - well by those days' standards -
coming along, from the early 60s

00:00:42.840 --> 00:00:49.620
onwards. They were so expensive they had
to be time-shared between lots of users

00:00:49.620 --> 00:00:55.100
and that in turn means you've got to
have system software that can multitask

00:00:55.100 --> 00:00:59.850
between different people, different
people's programs loaded in the

00:00:59.850 --> 00:01:04.049
machine at the same time, all being time-
sliced with a little bit of time. But at

00:01:04.049 --> 00:01:10.320
the same time, increasingly, computer
systems had to evolve into not just

00:01:10.320 --> 00:01:13.560
being able to print out your output and
your answers but to store it in a

00:01:13.560 --> 00:01:20.360
file; they had to run file systems. And
by the early 1970s you are in this

00:01:20.360 --> 00:01:26.790
incredible situation that one of the
biggest challenges in programming - a

00:01:26.790 --> 00:01:31.979
real-time challenge where you had to
keep people happy - was nothing more or

00:01:31.979 --> 00:01:37.170
less than the operating system in your
computer. One of the hardest challenges

00:01:37.170 --> 00:01:43.110
going. And, yeah, the wisdom was: "You will
only ever be able to do this in

00:01:43.110 --> 00:01:48.149
assembler". Some of the low-level tricks
you need to do in operating systems - you

00:01:48.149 --> 00:01:54.450
know the `real man' attitude: "Real Men use
assembler!" And I think a lot of people

00:01:54.450 --> 00:01:59.610
said: "No, there's some truth in that but
on the other hand just a little bit of

00:01:59.610 --> 00:02:05.610
higher-level operations - if only it could
be done without slowing the language

00:02:05.610 --> 00:02:09.569
down too much would help us stay sane. 
I think a lot of

00:02:09.569 --> 00:02:16.349
people, gradually, were, if you like,
embellishing assemblers to become macro-

00:02:16.349 --> 00:02:21.900
assemblers to try and give the kind of
higher-level approach to things that you

00:02:21.900 --> 00:02:26.250
got in high level languages. But on the
other side the opposing armies were always

00:02:26.250 --> 00:02:30.750
saying: "High-level languages -  they're so
inefficient! You need assembler for

00:02:30.750 --> 00:02:36.150
everything, ideally". Moore's Law put paid to
that, y'know. Yes, we can afford to use

00:02:36.150 --> 00:02:40.410
high-level languages for a lot more
things in the early 70s. Then there

00:02:40.410 --> 00:02:47.190
were a lot of experiments in trying, 
usually, to adapt existing languages for

00:02:47.190 --> 00:02:51.299
system implementation use. And
particularly ones that had started to

00:02:51.299 --> 00:02:56.280
build in some low-level operations for
bit twiddling. It was getting important

00:02:56.280 --> 00:03:01.590
to be able to dig down to the byte level and
get out characters. Looming up, just on

00:03:01.590 --> 00:03:07.590
the horizon, shock! horror! as if 16 bits
wasn't a toy computer - 8 bits [was] coming.

00:03:07.590 --> 00:03:13.230
So you needed a language to evolve that
could cope with different widths of

00:03:13.230 --> 00:03:20.160
objects. Of course as it becomes ... you go
through a sort of - like a minimum - in the

00:03:20.160 --> 00:03:24.540
curve. You know - we have to chop things
down in size because otherwise we can't

00:03:24.540 --> 00:03:28.639
make it at a price that people will buy.
But then, as hardware becomes cheaper,

00:03:28.639 --> 00:03:33.239
generally you then turn the corner. And
you could see it even in DEC and

00:03:33.239 --> 00:03:40.049
their PDP-11 minicomputers. Soon enough
they come along with a 32-bit computer

00:03:40.049 --> 00:03:44.720
[the VAX] which they can afford to make at long
last. And, of course, that was the era when

00:03:44.720 --> 00:03:51.150
discrete transistors and components, on
printed circuit boards, gave way to chip

00:03:51.150 --> 00:03:57.930
technology. So you have, like, LSI-11s.
It's large-scale integration, it's not

00:03:57.930 --> 00:04:01.470
separate components any more. And
gradually the curve turns the other way

00:04:01.470 --> 00:04:06.680
&gt;&gt; Sean: How did this change in architecture
feed back into the language choices then?

00:04:06.680 --> 00:04:16.010
&gt;&gt; DFB: Well, I think that it's two things. First
of all, can you get a system implementation

00:04:16.010 --> 00:04:22.070
language that helps you do low-level
things at a higher level? And I still

00:04:22.070 --> 00:04:28.160
think that, probably, you could say
that the most successful of all time - and on

00:04:28.160 --> 00:04:32.540
that front - was C. It's not that there weren't
others. There were things like Bliss, there

00:04:32.540 --> 00:04:39.470
were things like, even, Algol 68. And other
high-level languages, BCPL, were tried out.

00:04:39.470 --> 00:04:46.910
But C had the great advantage that you
could see how you might port it. Ah! yeah!

00:04:46.910 --> 00:04:50.660
Dennis, Ken all that. They're doing it on
the PDP-11; they'll be doing it on the

00:04:50.660 --> 00:04:56.150
VAX but up come the SUNs, all of a
sudden. The SUN servers. Hey! can we port

00:04:56.150 --> 00:05:00.020
UNIX to this? We're porting UNIX - we got to
get the C compiler working! Can you get

00:05:00.020 --> 00:05:04.730
the C compiler working - yes of
course you can. And it really stood the

00:05:04.730 --> 00:05:09.800
test of time. I mean when you look now, in
the `gcc' compiler, at the architectures

00:05:09.800 --> 00:05:15.380
that are supported, it just writes its
own brochure saying: "Just look at this, we

00:05:15.380 --> 00:05:20.090
can cope with anything!" However, the other
side of that, was then the

00:05:20.090 --> 00:05:24.590
differentiation to, if you like,
higher-level languages - even imperative

00:05:24.590 --> 00:05:31.400
ones - just became more marked. And I think
it was very interesting that - I think it

00:05:31.400 --> 00:05:37.010
was in the mid to late 80s - James Gosling
of Sun effectively ... it's people who

00:05:37.010 --> 00:05:40.730
run programmers and see how many
mistakes they make when they're using

00:05:40.730 --> 00:05:48.320
pointers. And, as far as I recall it, one
of the design requirements of Java was:

00:05:48.320 --> 00:05:52.430
"We're gonna ban pointers at user level".
When we start looking at why

00:05:52.430 --> 00:05:56.900
programs go wrong it's people who've
made mistakes with pointers. So therefore

00:05:56.900 --> 00:06:03.290
we're gonna ban them. I'm actually not
against that. If you really don't need to

00:06:03.290 --> 00:06:07.640
do low-level manipulations of pointers
then let the language do it for you.

00:06:07.640 --> 00:06:12.440
Or if it's like C++ where you could do
them and you say I don't want to do all

00:06:12.440 --> 00:06:17.090
my clever stuff under the hood - I'm not
writing an operating system. Yeah! get

00:06:17.090 --> 00:06:22.040
hold of a library full of functions and
trust them because they'll have been

00:06:22.040 --> 00:06:24.500
tested. They'll be efficient and all this kind

00:06:24.500 --> 00:06:29.510
of thing.  So, yes, things like functional

00:06:29.510 --> 00:06:35.680
languages, which of course always used to -
still do! -  get flak for being so slow,

00:06:35.680 --> 00:06:42.140
They became more and more possible to do
I suppose Brian [Kernighan] might say they got

00:06:42.140 --> 00:06:47.770
`less and less inefficient' y'know. But
no, it was a liberation to have that much

00:06:47.770 --> 00:06:52.160
compute power around that you didn't
have to think too much. I'm glad that

00:06:52.160 --> 00:06:56.420
many sensible souls on the comment
streams of recent videos have said this.

00:06:56.420 --> 00:07:00.620
It's no good getting theological about:
"You're not a real programmer if you don't

00:07:00.620 --> 00:07:05.200
program in C" or anything silly like
that. You've got to have an attitude of

00:07:05.200 --> 00:07:10.610
`horses for courses': the right programming
language for the right task. If it's

00:07:10.610 --> 00:07:15.200
yelling out to use Python, use Python. If
it's yelling out to use AWK - as I've

00:07:15.200 --> 00:07:21.080
been known to do ... Yeah! I tried out, as you
know, my Reed-Muller `messages from Mars'

00:07:21.080 --> 00:07:25.730
I got it ... hacked it together in AWK.
Well, why not? You can always take the

00:07:25.730 --> 00:07:29.630
view that if it's not efficient
enough we can drive down to a lower

00:07:29.630 --> 00:07:33.770
level, more efficient, language. But the
ability to try things out, without them

00:07:33.770 --> 00:07:38.060
taking hours and hours - because of really
fast hardware - is probably about the

00:07:38.060 --> 00:07:42.740
biggest liberation I can think of in
terms of my professional career as a

00:07:42.740 --> 00:07:46.280
computer scientist. 
&gt;&gt; Sean: You know I'm not a programmer. 
I mean, one day it might make a

00:07:46.280 --> 00:07:55.910
video - my bad exploration of BASIC in my
youth. But, as a non programmer I suppose

00:07:55.910 --> 00:08:01.820
I come at this and think, well, why can't
there be one thing that fits all and my

00:08:01.820 --> 00:08:06.680
kind of taking examples from
other parts of life. Presumably certain

00:08:06.680 --> 00:08:09.830
things are good for certain things like you say&gt;
&gt;&gt; DFB:  I think that's right. I think that

00:08:09.830 --> 00:08:15.650
you see it in all sorts of other realms
in life. It's that you know the true

00:08:15.650 --> 00:08:20.690
professional tool for doing something - it
was probably very different from a user-level

00:08:20.690 --> 00:08:27.740
tool.  Y' know, I mean, if you go to a
hardware store and buy yourself a drill

00:08:27.740 --> 00:08:32.450
with a hammer action, you know that's a
very different object from what they

00:08:32.450 --> 00:08:37.220
would use industrially to hack into
buildings. It's in principle the same but

00:08:37.220 --> 00:08:42.139
the whole spec. and construction of it
is very different. And that's what we

00:08:42.139 --> 00:08:49.820
now have the ability to do, is to fit the 
language to the task.

00:08:49.820 --> 00:08:58.040
Of course, it still leaves a big problem
that lots and lots of software ideally

00:08:58.040 --> 00:09:02.509
should have been rewritten years ago.
Because the moment you get something

00:09:02.509 --> 00:09:07.509
that's good for its time, and works, the
temptation is just to leave it in place

00:09:07.509 --> 00:09:12.709
because it works and we daren't change it 
because so many things are dependent on it.

00:09:12.709 --> 00:09:18.529
So, this is why there are still 8-bit Z80
programs doing heaven knows what in the

00:09:18.529 --> 00:09:21.440
Armed Forces. There are probably still companies out

00:09:21.440 --> 00:09:27.459
there, in the wild, still using COBOL on
mainframes. You know [the] cost of a mainframe

00:09:27.459 --> 00:09:33.350
simulation these days? Peanuts! That
program [will] cost us a fortune to rewrite it.

00:09:33.350 --> 00:09:40.899
And it's bound to go wrong, And it's known
and reliable so that thing about having

00:09:40.899 --> 00:09:48.440
legacy software and hardware and it's so
difficult to trust to replacing it. It's

00:09:48.440 --> 00:09:52.839
still is going to be a problem eternally I think, that. 
&gt;&gt; Sean: well there is a

00:09:52.839 --> 00:09:59.810
well-known phrase: "If it ain't broken, don't fix it!" 
&gt;&gt; DFB: What's helped the `ain't broken'

00:09:59.810 --> 00:10:05.690
bit, you see, that's the thing, is that if
there's something rather exotic on the

00:10:05.690 --> 00:10:12.380
hardware front, from the 1960s, you no
longer have to literally build one of

00:10:12.380 --> 00:10:17.000
those. You can simulate its action. So as
long as you put a lot of effort into

00:10:17.000 --> 00:10:21.589
getting a good simulator going, then you
can carry on with the code you've had

00:10:21.589 --> 00:10:28.470
for 30-40 years in some cases.

