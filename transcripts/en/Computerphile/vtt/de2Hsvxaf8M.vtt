WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:12.050
There's a book just over your shoulder that's carefully been placed there, can you pick the book up and tell me about it? Right! Great book, you should
buy the newer version of this.

00:00:12.050 --> 00:00:18.289
Brief commercial announcement yeah sure I think I mentioned at some point in our

00:00:18.289 --> 00:00:22.340
conversation the fact that the people
working on MULTICS, well MULTICS was sort of the

00:00:22.340 --> 00:00:26.900
second version of timesharing that was
done at MIT with collaboration of Bell

00:00:26.900 --> 00:00:30.130
Labs and General Electric very big

00:00:30.130 --> 00:00:36.050
system for providing in effect a computing
utility for programmers.

00:00:36.050 --> 00:00:40.379
Multex was actually being written in high-level languages ah they started with PL1

00:00:40.379 --> 00:00:44.489
which was not a good choice and then
they moved to BCPL

00:00:44.489 --> 00:00:51.629
language which developed in fact by
Martin Richards of Cambridge.

00:00:51.629 --> 00:00:55.190
The people doing that who are at Bell Labs in
particular Ken Thompson and Dennis

00:00:55.190 --> 00:00:59.039
Ritchie had gotten used to the idea that
you could write really interesting

00:00:59.039 --> 00:01:03.660
operating system kind of software and
tools that supported it in high-level

00:01:03.660 --> 00:01:08.600
languages so you weren't writing
assembly language and so when they

00:01:08.600 --> 00:01:13.610
started working on UNIX this very small
stripped-down version that was done at

00:01:13.610 --> 00:01:18.840
Bell Labs they were at the same time
exploring the use of high-level

00:01:18.840 --> 00:01:24.110
languages and there were a variety of
these there was a language called B

00:01:24.110 --> 00:01:29.979
which was the first attempt it was done
by Ken Thompson a very simple language

00:01:29.979 --> 00:01:34.869
and I suppose you could say it was sort
of like a stripped down version of BCPL

00:01:34.869 --> 00:01:42.450
A weak naming convention there and
so you could do interesting things with

00:01:42.450 --> 00:01:47.520
B but it wasn't quite powerful enough
and in particular it was an interpreter

00:01:47.520 --> 00:01:52.770
not a compiler and that meant it didn't
generate machine code for the particular

00:01:52.770 --> 00:01:55.110
machine was running on it was just a
program that

00:01:55.110 --> 00:02:00.210
interpreted what it was trying to say
so it meant it ran relatively slowly.

00:02:00.210 --> 00:02:05.100
The other thing is that the language did not support the architecture of newer

00:02:05.100 --> 00:02:09.710
machines that were showing up in
particular that PDP 11 newer machines

00:02:09.710 --> 00:02:15.540
instead of having everything in the
machine be a single size of in effect integer

00:02:15.540 --> 00:02:20.120
let's say 16 bits or something like that they had different sizes that were, the

00:02:20.120 --> 00:02:24.600
machine would efficiently and naturally
manipulate 8bit, 16bit maybe thirty

00:02:24.600 --> 00:02:30.760
two-bit &amp; the language B didn't reflect
that and so Dennis Ritchie undertook

00:02:30.760 --> 00:02:36.910
to design what amounted to a version of
B that was richer and had mechanisms

00:02:36.910 --> 00:02:41.550
in the language to say this is an 8-bit
quantity this is a 16 bit quantity

00:02:41.550 --> 00:02:46.890
basically the char and int types that you see in the early versions of C and so he

00:02:46.890 --> 00:02:47.410
wrote

00:02:47.410 --> 00:02:53.220
a compiler for that and then with the
compiler in hand they started to rewrite

00:02:53.220 --> 00:02:58.320
the operating system itself in C
and this took a while but something in the

00:02:58.320 --> 00:03:04.110
order of six months to get that working
and at that point then you've got the

00:03:04.110 --> 00:03:08.890
operating system of course all kinds of
other critical core software written in

00:03:08.890 --> 00:03:13.540
a high-level language rather than in
assembly language and that's important

00:03:13.540 --> 00:03:18.120
for all kinds of reasons one is means
that it's just a lot easier for lots of

00:03:18.120 --> 00:03:22.170
people to see what the code does you
need so much expertise because it's a

00:03:22.170 --> 00:03:28.160
high-level language and the other thing
is that it's portable in the sense that

00:03:28.160 --> 00:03:32.260
if somebody makes a C compiler for a
different kind of machine different

00:03:32.260 --> 00:03:37.560
architecture then you can recompile
whatever your program is for that new

00:03:37.560 --> 00:03:38.700
architecture in

00:03:38.700 --> 00:03:42.920
that way you can move your program to a
different machine of this always been

00:03:42.920 --> 00:03:45.950
the advantage of high-level languages
but now you could do it for the operating

00:03:45.950 --> 00:03:51.230
system and that meant that UNIX, the
operating system no longer was only PDP

00:03:51.230 --> 00:03:58.950
11 but could run on a variety of other
machines as well

00:03:58.960 --> 00:04:07.450
I think the concept of having a high-level language Iget right, you compile it down to hexes, machine code that tells the processors to do stuff. and if you have a different compiler for a different machine

00:04:07.470 --> 00:04:11.069
it just changes what those Hexes are -right that's exactly right

00:04:11.069 --> 00:04:24.050
so so it should be really simple to understand how you write an OS in a high level language, but is it a bit like, making a sharp tool and using that sharp tool to make a sharper tool?

00:04:24.050 --> 00:04:29.950
Yeah, right, I think in fact, the complication is in building in writing
of operating system and high-level

00:04:29.950 --> 00:04:35.190
language in translating it into let's
say multiple different architectures is

00:04:35.190 --> 00:04:39.590
there's a lot of detail to get right
there in there are some things which the

00:04:39.590 --> 00:04:43.190
high-level language just doesn't support
So you need a little tiny bit of assembly

00:04:43.190 --> 00:04:47.910
language assist for any given operating
system the one that's more like that the

00:04:47.910 --> 00:04:51.610
conceptual problem that you were
explaining well is how does the compiler

00:04:51.610 --> 00:04:56.710
itself get started because of course the
C compiler is written in C so there is the

00:04:56.710 --> 00:05:01.700
how do you get it started and your idea
of the sharper tool making yet a sharper

00:05:01.700 --> 00:05:02.470
tool and so on

00:05:02.470 --> 00:05:07.720
is metaphorically the right idea because
what you do is you say I wrote some code

00:05:07.720 --> 00:05:15.110
in C on paper let me mechanically
translate that into something that will

00:05:15.110 --> 00:05:21.820
process a bit more of C code and
bootstrap myself up from that so it's a

00:05:21.820 --> 00:05:27.789
bootstrapping process and I've never
done it so take me with a grain of salt

00:05:27.789 --> 00:05:34.780
on that but that's the basic idea so. - OK, so tell me about this book, how did this come about?

00:05:34.780 --> 00:05:42.170
that's the first edition (is it autographed?) this one isn't actually no dear oh dear this however is

00:05:42.170 --> 00:05:55.740
the 24th printing so. (I'll just point out that Prof Brailsford brought in a pen for the autograph there.) OK I will autograph it...

00:05:55.740 --> 00:06:01.320
somewhere early on in this process of
people building interesting languages I

00:06:01.320 --> 00:06:04.919
got intrigued by the idea of how do you
explain those languages to other people

00:06:04.919 --> 00:06:10.669
and so I wrote tutorial documents I wrote a tutorial document on B so that

00:06:10.669 --> 00:06:15.540
people could learn B because Ken Thompson
and to a lesser degree Dennis didn't

00:06:15.540 --> 00:06:19.360
write tremendous amount of documentation
let's say it was a spare and there was

00:06:19.360 --> 00:06:22.940
not much tutorial stuff so I wrote a
tutorial document on B that was useful

00:06:22.940 --> 00:06:28.900
when C came along then I wrote a
tutorial document on C and at some point

00:06:28.900 --> 00:06:33.530
I had already written I guess couple
books at that point and it seemed like

00:06:33.530 --> 00:06:39.729
the market, the market!? That there might
be a market for a C book and so I

00:06:39.729 --> 00:06:44.280
twisted Dennis Ritchies arm into
writing the book with me and that is the

00:06:44.280 --> 00:06:51.400
smartest thing I ever did in my whole
life no ambiguity so we took my tutorial

00:06:51.400 --> 00:06:54.560
document as kind of a piece of it, we
took his reference manual which is a

00:06:54.560 --> 00:06:58.050
excellent reference manual as a big
piece of it took that verbatim and then

00:06:58.050 --> 00:07:04.960
we filled in material in the middle to explain the various parts of the language at length, and we

00:07:04.960 --> 00:07:09.370
published that, we wrote it in 1977
published at the beginning of 78 and of

00:07:09.370 --> 00:07:13.070
course it was done with all of the
document preparation tools that we had

00:07:13.070 --> 00:07:15.910
been working on over the years and so it
had

00:07:15.910 --> 00:07:19.960
mathematical expressions in it using EQN
it had tables of things like

00:07:19.960 --> 00:07:23.370
operators using Mike Lesk's TBL program
it

00:07:23.370 --> 00:07:28.490
the first edition predates pic the
picture drawing language the second

00:07:28.490 --> 00:07:34.250
edition has pic pictures so on so is
this incestuous or is this building on

00:07:34.250 --> 00:07:39.370
what people have done I don't know but
that's how it came about and I remember

00:07:39.370 --> 00:07:45.000
talking to the editor this is published
by Prentice Hall with Karl Karlstrom the

00:07:45.000 --> 00:07:50.010
editor there and I remember discussion
with him about how many copies do you

00:07:50.010 --> 00:07:54.050
think this will sell no idea well maybe
five thousand

00:07:54.050 --> 00:08:03.160
done better than that which is just as well

00:08:03.160 --> 00:08:10.160
there never an A because B was based on? There was a language Steve
Johnson who was all part of this the

00:08:10.160 --> 00:08:16.140
creator of Yacc, Steve Johnson spent a sabbatical
at University of Waterloo in Ontario and

00:08:16.140 --> 00:08:19.660
he came back with a link I don't
somebody else had done that the language

00:08:19.660 --> 00:08:24.540
they're called "A" but it was spelled "EH"
- Bit of Canadian humor I guess...

