WEBVTT
Kind: captions
Language: en

00:00:00.701 --> 00:00:02.000
Galpin: Hello, and welcome

00:00:02.000 --> 00:00:04.801
to Bringing C and C++ Games
to Android.

00:00:04.801 --> 00:00:07.000
I'm Dan Galpin.
I'm a developer advocate

00:00:07.000 --> 00:00:10.000
on the Android team
working with game developers.

00:00:10.000 --> 00:00:12.000
So about this talk--

00:00:12.000 --> 00:00:14.000
um, we're gonna expect

00:00:14.000 --> 00:00:16.501
that you guys
are C and C++ developers.

00:00:16.501 --> 00:00:19.501
If you don't know C and C++,
you probably shouldn't be here.

00:00:19.501 --> 00:00:23.133
Hopefully, you've gotten
some Android background,

00:00:23.133 --> 00:00:25.133
because we're not gonna cover
all the basics here.

00:00:25.133 --> 00:00:26.968
This is considered
a higher-level talk.

00:00:26.968 --> 00:00:28.801
Um, game development--
the development experience

00:00:28.801 --> 00:00:30.300
is awesome.

00:00:30.300 --> 00:00:32.133
We are not gonna teach you

00:00:32.133 --> 00:00:34.133
how to become a game developer
here, either.

00:00:34.133 --> 00:00:36.133
And, however,
we are going to expect

00:00:36.133 --> 00:00:39.133
that you may or may not have
ever touched the NDK

00:00:39.133 --> 00:00:40.634
or, in that case, JNI.

00:00:40.634 --> 00:00:44.300
So our agenda for today is going
to be programming Android

00:00:44.300 --> 00:00:46.300
and C and C++,

00:00:46.300 --> 00:00:50.300
using the NDK,
bringing your game to Android,

00:00:50.300 --> 00:00:53.300
troubleshooting tips and tricks,
and tongue twisters

00:00:53.300 --> 00:00:57.200
and best practices.

00:00:57.200 --> 00:00:59.200
So to start off,

00:00:59.200 --> 00:01:02.267
um, Programming Android
in C and C++.

00:01:02.267 --> 00:01:04.767
Um, and I'm gonna be joined,
by the way,

00:01:04.767 --> 00:01:07.267
by Ian Ni-Lewis, who's also
a developer advocate here

00:01:07.267 --> 00:01:10.167
on the Android team
doing game development--

00:01:10.167 --> 00:01:12.934
uh, helping game--
helping out game developers.

00:01:12.934 --> 00:01:16.434
So to start off with,

00:01:16.434 --> 00:01:18.934
the NDK provides support

00:01:18.934 --> 00:01:21.467
for C and C++ development.

00:01:21.467 --> 00:01:23.467
NDK is
the Native Development Kit,

00:01:23.467 --> 00:01:27.033
and the idea is
people write code

00:01:27.033 --> 00:01:30.734
in other languages than Java.

00:01:30.734 --> 00:01:32.734
[inhales sharply] I know.
It's kind of shocking.

00:01:32.734 --> 00:01:34.734
And sometimes--
sometimes this code works,

00:01:34.734 --> 00:01:36.734
and they want to reuse it,

00:01:36.734 --> 00:01:39.701
so we--so we've made
the NDK partially because

00:01:39.701 --> 00:01:42.200
there's tons and tons
of great code out there,

00:01:42.200 --> 00:01:44.200
whether it be open-source code,

00:01:44.200 --> 00:01:46.200
whether it be code
that you've developed,

00:01:46.200 --> 00:01:48.200
that you're gonna want to reuse.

00:01:48.200 --> 00:01:50.200
Also, as it turns out,

00:01:50.200 --> 00:01:52.701
Java is not the best language
for everything.

00:01:52.701 --> 00:01:54.200
There are times

00:01:54.200 --> 00:01:56.868
when you're doing things
that are really math-sensitive.

00:01:56.868 --> 00:01:59.200
There are times
in which you are doing things

00:01:59.200 --> 00:02:01.267
that are seriously hard-core

00:02:01.267 --> 00:02:03.801
where you're gonna want
to accelerate things,

00:02:03.801 --> 00:02:06.801
and you're gonna want to take
advantage of things like VFP.

00:02:06.801 --> 00:02:09.801
You're gonna want to take
advantage of things like NEON,

00:02:09.801 --> 00:02:11.801
okay, for--for supercool stuff.

00:02:11.801 --> 00:02:14.801
And of course, I have heard
that there are other platforms

00:02:14.801 --> 00:02:17.801
that people write games for
other than Android.

00:02:17.801 --> 00:02:20.734
And--I know. It's shocking.
[laughter]

00:02:20.734 --> 00:02:24.234
Galpin: Um, but you might want
to port those entire games over,

00:02:24.234 --> 00:02:26.234
and you want to--a method
of doing that

00:02:26.234 --> 00:02:28.234
that allows you
to get high performance

00:02:28.234 --> 00:02:29.734
and consistent quality.

00:02:29.734 --> 00:02:32.234
So let--let me let Ian
take it away from here,

00:02:32.234 --> 00:02:34.567
and he's gonna talk about
what's in the box.

00:02:34.567 --> 00:02:36.567
Ni-Lewis: I haven't been
this embarrassed

00:02:36.567 --> 00:02:39.067
since I, uh, started teaching
class at DigiPen

00:02:39.067 --> 00:02:41.567
and thought that it started
a week after it actually did.

00:02:41.567 --> 00:02:44.067
I found out that all my students
wanted to kill me.

00:02:44.067 --> 00:02:46.067
Uh, I apologize for being late,
but yes,

00:02:46.067 --> 00:02:49.434
um, as Dan was saying,
the, uh, the NDK

00:02:49.434 --> 00:02:52.033
is a way to program C and C++
in Android.

00:02:52.033 --> 00:02:54.033
How many of you have used
the NDK?

00:02:54.033 --> 00:02:56.534
Okay, awesome.

00:02:56.534 --> 00:02:59.334
The rest of you, you know,
bless your lucky stars.

00:02:59.334 --> 00:03:01.000
Um...
Galpin: [laughs]

00:03:01.000 --> 00:03:03.100
Ni-Lewis: The NDK was actually
kind of difficult to use

00:03:03.100 --> 00:03:04.634
in the past.

00:03:04.634 --> 00:03:06.267
It's gotten a lot better
this year,

00:03:06.267 --> 00:03:07.767
and we're actually
pretty excited

00:03:07.767 --> 00:03:09.767
about the changes
that we've made.

00:03:09.767 --> 00:03:11.267
Here's what the NDK is.

00:03:11.267 --> 00:03:13.267
It starts out with a toolchain,

00:03:13.267 --> 00:03:15.434
and if you're familiar
with, uh, Linux programming

00:03:15.434 --> 00:03:17.434
or Mac programming,
this sort of toolchain

00:03:17.434 --> 00:03:19.434
is not gonna seem
at all out of place.

00:03:19.434 --> 00:03:21.434
It's basically GCC
and--and Make and Build

00:03:21.434 --> 00:03:23.434
and all these nice things
that you're used to.

00:03:23.434 --> 00:03:25.434
It also has a build system.

00:03:25.434 --> 00:03:27.934
Uh, you're not
actually required to use this

00:03:27.934 --> 00:03:30.200
as a--as an NDKr5.

00:03:30.200 --> 00:03:32.868
And, at first glance, it seems
a little overengineered,

00:03:32.868 --> 00:03:35.701
but it's based on
the same platform build system

00:03:35.701 --> 00:03:37.734
that we use for Android.

00:03:37.734 --> 00:03:40.701
And it makes it
really, really easy

00:03:40.701 --> 00:03:42.701
to write modular code

00:03:42.701 --> 00:03:46.234
and--and build up an application
of multiple shared libraries

00:03:46.234 --> 00:03:47.734
in C++.

00:03:47.734 --> 00:03:49.234
And I'm told that,

00:03:49.234 --> 00:03:52.901
if you try and do the whole
toolchain from scratch yourself,

00:03:52.901 --> 00:03:54.901
it's considerably
more difficult.

00:03:54.901 --> 00:03:57.901
So you might want to at least
start with the made files

00:03:57.901 --> 00:03:59.901
that we've got for you.

00:03:59.901 --> 00:04:02.968
Um, and there's also a set
of headers and libraries,

00:04:02.968 --> 00:04:05.968
so libraries that interface
with the underlying system.

00:04:05.968 --> 00:04:07.968
Now this is
a really important point.

00:04:07.968 --> 00:04:10.968
In fact, it's actually the most
important piece of the NDK,

00:04:10.968 --> 00:04:12.968
and you might be asking
yourself, "Why?"

00:04:12.968 --> 00:04:14.968
In fact, if you're like me,
you're probably saying,

00:04:14.968 --> 00:04:16.968
"Well, wait a second,
I heard Android's Linux,

00:04:16.968 --> 00:04:18.968
"and Linux has always been C++,

00:04:18.968 --> 00:04:20.968
so why do I even need
this stuff," right?

00:04:20.968 --> 00:04:23.801
Well, it turns out that,

00:04:23.801 --> 00:04:26.968
although Android
is based on Linux,

00:04:26.968 --> 00:04:28.968
Android processes

00:04:28.968 --> 00:04:33.400
have a very important
difference,

00:04:33.400 --> 00:04:36.400
um, and that's the--you know,
we've always had the Dalvik VM,

00:04:36.400 --> 00:04:40.467
and every Android process
loads the Dalvik VM.

00:04:40.467 --> 00:04:43.334
Application code is expected
to run in the VM,

00:04:43.334 --> 00:04:46.000
over the top of this set
of frameworks,

00:04:46.000 --> 00:04:51.167
um, that is the Android SDK,
in Java.

00:04:51.167 --> 00:04:54.234
Now what the NDK is trying to do

00:04:54.234 --> 00:04:56.567
is let you get some code
down here

00:04:56.567 --> 00:04:58.567
under--underneath that layer,

00:04:58.567 --> 00:05:01.601
uh, where only C and C++ code

00:05:01.601 --> 00:05:05.334
have--have been written before.

00:05:05.334 --> 00:05:07.234
And the problem with this

00:05:07.234 --> 00:05:10.234
is that, for a long time,
the Android operating system

00:05:10.234 --> 00:05:13.234
has been on, uh, able to rely
on this framework layer

00:05:13.234 --> 00:05:15.234
for backwards
and forward compatibility.

00:05:15.234 --> 00:05:18.234
So the problem with just
sticking some code down there,

00:05:18.234 --> 00:05:20.234
which you know,
you know, you can do--

00:05:20.234 --> 00:05:21.734
you're not dumb,

00:05:21.734 --> 00:05:23.734
you can--you can
compile C code on Linux--

00:05:23.734 --> 00:05:25.734
but if you do it
without the NDK,

00:05:25.734 --> 00:05:27.734
you're gonna have
a real problem here,

00:05:27.734 --> 00:05:30.734
because the set of system
libraries that we talk to,

00:05:30.734 --> 00:05:33.734
uh, that--that implement
the Android system

00:05:33.734 --> 00:05:36.567
in C and C++
have never been stabilized.

00:05:36.567 --> 00:05:39.567
There's never been a reason
for them to be stable.

00:05:39.567 --> 00:05:42.567
We change them every time
we revise the operating system.

00:05:42.567 --> 00:05:44.067
We're continually
making them better

00:05:44.067 --> 00:05:45.567
and switching things around

00:05:45.567 --> 00:05:47.801
based on the needs
of the underlying OS.

00:05:47.801 --> 00:05:51.801
So what we needed with the NDK
more than anything else,

00:05:51.801 --> 00:05:54.133
uh, was to create

00:05:54.133 --> 00:05:57.100
a stable ABI,

00:05:57.100 --> 00:05:59.100
and with that stable ABI,

00:05:59.100 --> 00:06:01.667
then we could finally get
the framework classes

00:06:01.667 --> 00:06:04.167
out of the way
and let your application code

00:06:04.167 --> 00:06:08.000
live in both Java land
or Dalvik land

00:06:08.000 --> 00:06:11.601
and C and C++ land.

00:06:11.601 --> 00:06:13.601
With first revision of the NDK,

00:06:13.601 --> 00:06:15.601
we--we launched
some basic libraries.

00:06:15.601 --> 00:06:17.100
Basically, the things

00:06:17.100 --> 00:06:19.601
that we thought were gonna
be most interesting

00:06:19.601 --> 00:06:21.601
to high-performance,
uh, programmers--

00:06:21.601 --> 00:06:23.601
you know, obviously,
the basic stuff

00:06:23.601 --> 00:06:27.634
like--like libcs,
math libraries, uh, and OpenGL.

00:06:27.634 --> 00:06:31.067
Now with Froyo,
we also introduced a library

00:06:31.067 --> 00:06:32.767
called libjnigraphics

00:06:32.767 --> 00:06:36.601
which let you talk directly
to the 2-D rendering layers,

00:06:36.601 --> 00:06:40.100
uh, in a bitmap layer,
as well as the 3-D OpenGL stuff,

00:06:40.100 --> 00:06:43.434
and with Gingerbread,

00:06:43.434 --> 00:06:45.434
we actually made
a concerted effort

00:06:45.434 --> 00:06:47.434
to make the NDK,

00:06:47.434 --> 00:06:49.934
and--and the Android system
in general,

00:06:49.934 --> 00:06:51.934
more attractive
to game programmers,

00:06:51.934 --> 00:06:54.934
so we introduced
some new input models.

00:06:54.934 --> 00:06:57.934
Um, we used libEGL,

00:06:57.934 --> 00:07:01.000
which is a--the standard way

00:07:01.000 --> 00:07:03.000
of getting OpenGL contacts.

00:07:03.000 --> 00:07:05.000
Um, we introduced OpenSL,

00:07:05.000 --> 00:07:08.000
so finally, you didn't have
to go back to Java

00:07:08.000 --> 00:07:09.501
just to do sound.

00:07:09.501 --> 00:07:11.501
And we introduced a library
called libandroid,

00:07:11.501 --> 00:07:14.767
which allows you to access
some of the SDK framework

00:07:14.767 --> 00:07:16.267
from C++.

00:07:16.267 --> 00:07:19.267
Uh, most notably, it's now
possible, in Gingerbread,

00:07:19.267 --> 00:07:22.267
to write, uh, an activity

00:07:22.267 --> 00:07:24.634
completely in C++,

00:07:24.634 --> 00:07:27.968
and it's, uh,
it's also possible,

00:07:27.968 --> 00:07:29.467
in Gingerbread

00:07:29.467 --> 00:07:31.501
to access the AssetManager
from C++,

00:07:31.501 --> 00:07:33.968
which, if you ever tried
to access the AssetManager

00:07:33.968 --> 00:07:36.968
from--from C in previous
versions of the NDK,

00:07:36.968 --> 00:07:38.968
it was incredibly difficult.

00:07:38.968 --> 00:07:42.534
So we're excited
to see those changes.

00:07:42.534 --> 00:07:45.701
Well, now that we've talked
a little about what the NDK is,

00:07:45.701 --> 00:07:49.601
we should probably make it
really clear what it's not.

00:07:49.601 --> 00:07:51.734
This is not the end of Dalvik.

00:07:51.734 --> 00:07:55.400
Dalvik is still a great way
to program Android,

00:07:55.400 --> 00:07:57.734
and it will always
be the--the premier way

00:07:57.734 --> 00:07:59.234
of programming Android.

00:07:59.234 --> 00:08:02.868
You always have, uh, SDKs
written in Dalvik first.

00:08:02.868 --> 00:08:04.901
But...

00:08:04.901 --> 00:08:07.634
it does give you a way
to--to write C--

00:08:07.634 --> 00:08:11.968
C and C++ code if you've got
an, uh, an investment in that.

00:08:11.968 --> 00:08:13.968
It's not always gonna
be higher performance.

00:08:13.968 --> 00:08:15.968
Dalvik is a fast
virtual machine,

00:08:15.968 --> 00:08:18.467
and not everything is gonna
benefit from NEON instructions

00:08:18.467 --> 00:08:20.133
or from hand-tuned
assembly code.

00:08:20.133 --> 00:08:23.634
So it's not always gonna be
the right choice for every game.

00:08:23.634 --> 00:08:26.133
Is it the right choice
for your game?

00:08:26.133 --> 00:08:28.133
That's gonna depend
on a lot of things.

00:08:28.133 --> 00:08:30.133
Keep this in mind--

00:08:30.133 --> 00:08:33.133
Dalvik is the premier
development environment

00:08:33.133 --> 00:08:34.634
for Android.

00:08:34.634 --> 00:08:37.133
It's a productive
development environment.

00:08:37.133 --> 00:08:41.133
It has garbage collection
and lots of nice libraries.

00:08:41.133 --> 00:08:44.567
But on the C and C++ side,

00:08:44.567 --> 00:08:47.067
uh, lots of programmers
know C and C++

00:08:47.067 --> 00:08:49.067
that don't know
a Dalvik language.

00:08:49.067 --> 00:08:52.067
Uh, it can be faster,

00:08:52.067 --> 00:08:54.734
and it can leverage
existing libraries

00:08:54.734 --> 00:08:57.734
like open-source libraries that
have been written in C and C++

00:08:57.734 --> 00:08:59.734
and are available for free.

00:08:59.734 --> 00:09:03.300
So it may or may not be
the right choice for you.

00:09:03.300 --> 00:09:06.234
Fortunately,
you don't have to make

00:09:06.234 --> 00:09:08.234
an all-or-nothing choice.

00:09:08.234 --> 00:09:11.267
And we'll talk a little bit
about how Java and C and C++

00:09:11.267 --> 00:09:12.734
can coexist.

00:09:12.734 --> 00:09:14.734
By the way, I do apologize
for my voice.

00:09:14.734 --> 00:09:16.734
I was way too enthusiastic
yesterday.

00:09:16.734 --> 00:09:18.734
Whoo! Google I/O!

00:09:18.734 --> 00:09:20.734
Um...

00:09:20.734 --> 00:09:23.734
Let's talk about
how to use the NDK.

00:09:23.734 --> 00:09:26.234
All right, first off,
you're gonna have to install it.

00:09:26.234 --> 00:09:28.734
This is a really simple step
unless you're on Windows,

00:09:28.734 --> 00:09:30.734
in which case,
you're kind of screwed.

00:09:30.734 --> 00:09:33.234
[laughs]
No, I--so on any system,

00:09:33.234 --> 00:09:35.234
you're--you're gonna
want to make sure

00:09:35.234 --> 00:09:37.234
you've got Java
and Ant up to date.

00:09:37.234 --> 00:09:39.234
I don't know,
on my MacBook Pro,

00:09:39.234 --> 00:09:42.234
I had to do, like, a-a MacPort
to get for these things.

00:09:42.234 --> 00:09:43.734
Um, but on Windows,

00:09:43.734 --> 00:09:46.267
you're almost certainly
gonna want to download Cygwin.

00:09:46.267 --> 00:09:48.734
Um, that's not--
that's not a restriction

00:09:48.734 --> 00:09:50.734
we put on regular
Android programming,

00:09:50.734 --> 00:09:53.234
but, you know, the build scripts
for the--for the NDK

00:09:53.234 --> 00:09:55.234
just have never been ported
for Bash.

00:09:55.234 --> 00:09:57.734
Um, it is actually possible

00:09:57.734 --> 00:09:59.734
to build without Cygwin.

00:09:59.734 --> 00:10:01.734
Um, I'll mention
a couple of ways

00:10:01.734 --> 00:10:03.734
in a bit
on how to do that,

00:10:03.734 --> 00:10:06.367
but it's highly recommended.

00:10:07.934 --> 00:10:10.801
So then there's a sort of
a nice flow that we go through.

00:10:10.801 --> 00:10:12.434
You set up a project.

00:10:12.434 --> 00:10:14.934
Um, you write some makefiles.

00:10:14.934 --> 00:10:16.934
You're gonna write
some interface classes

00:10:16.934 --> 00:10:19.567
and glue them up
with some JNI magic.

00:10:19.567 --> 00:10:21.901
Um, and then you're gonna go

00:10:21.901 --> 00:10:25.234
into sort of your build,
deploy, and debug cycle

00:10:25.234 --> 00:10:27.801
that--that characterizes
any software project.

00:10:27.801 --> 00:10:29.801
Let's drill down on these
a little bit.

00:10:29.801 --> 00:10:32.133
All right,
to create the project,

00:10:32.133 --> 00:10:34.634
there's actually several ways
you can do this.

00:10:34.634 --> 00:10:37.167
The one on the slide
is the out-of-the-box way.

00:10:37.167 --> 00:10:39.167
You run
Android create project,

00:10:39.167 --> 00:10:41.667
and that gets you,
as I'm sure you're aware,

00:10:41.667 --> 00:10:43.334
an Android project.

00:10:43.334 --> 00:10:45.801
There's also a couple
of third-party projects

00:10:45.801 --> 00:10:48.801
that I want to mention
just because they're so cool.

00:10:48.801 --> 00:10:50.801
There's a product
called vs-android

00:10:50.801 --> 00:10:53.801
on Google code that, uh, will
create an Android project

00:10:53.801 --> 00:10:56.300
in MSBuild,
so a lot of game developers

00:10:56.300 --> 00:10:57.801
use Visual Studio.

00:10:57.801 --> 00:11:00.801
If you like that sort of thing,
um, that's a possibility.

00:11:00.801 --> 00:11:02.868
There's also a project
called Sequoyah

00:11:02.868 --> 00:11:04.868
that's part
of the Eclipse project.

00:11:04.868 --> 00:11:07.367
If you load that
as an Eclipse extension,

00:11:07.367 --> 00:11:11.467
it will actually help you
create, uh, an NDK project

00:11:11.467 --> 00:11:14.801
using the confer
to C++ project wizard

00:11:14.801 --> 00:11:16.467
in, uh, in Eclipse.

00:11:16.467 --> 00:11:18.968
Can you tell I'm a V--
a Visual Studio guy,

00:11:18.968 --> 00:11:20.467
'cause I just said "wizard"?

00:11:20.467 --> 00:11:23.467
Do they even call it that
in Eclipse? I don't even know.

00:11:23.467 --> 00:11:25.501
Um, but it's gonna create the--
either way,

00:11:25.501 --> 00:11:27.467
you're gonna--you're gonna get
a few different files created.

00:11:27.467 --> 00:11:29.467
There's--there's an XML file
that Ant uses.

00:11:29.467 --> 00:11:31.467
There's a couple
of properties files

00:11:31.467 --> 00:11:33.968
that you usually don't need
to care about.

00:11:33.968 --> 00:11:36.968
Um, and you are also actually
gonna have to create

00:11:36.968 --> 00:11:39.434
a couple of files yourself,
unless you use

00:11:39.434 --> 00:11:41.901
that Sequoyah, uh, project
that I talked about earlier.

00:11:41.901 --> 00:11:43.901
Um, it's two makefiles.

00:11:43.901 --> 00:11:46.567
These are actually
fairly standard makefiles

00:11:46.567 --> 00:11:49.067
in--in the sense that they used
new make syntax,

00:11:49.067 --> 00:11:51.567
but they fit
into that fancy build system

00:11:51.567 --> 00:11:53.734
that I mentioned earlier.

00:11:53.734 --> 00:11:57.334
So they don't require nearly as
much work as a normal makefile.

00:11:57.334 --> 00:11:59.834
The first makefile
is called Android.mk.

00:11:59.834 --> 00:12:01.400
It's mandatory.

00:12:01.400 --> 00:12:03.400
The build system
expects to find this,

00:12:03.400 --> 00:12:05.400
and if it doesn't,
it will complain.

00:12:05.400 --> 00:12:07.400
And it just contains the names

00:12:07.400 --> 00:12:09.400
of the files
that you're compiling

00:12:09.400 --> 00:12:11.400
and any flag overrides
that you want to do,

00:12:11.400 --> 00:12:14.400
so, you know, you want
to set C flags for your project,

00:12:14.400 --> 00:12:16.400
fine, you can do it here.

00:12:16.400 --> 00:12:19.400
There's also a somewhat optional
makefile called application.mk.

00:12:19.400 --> 00:12:22.400
Um, the idea is you might have
several modules

00:12:22.400 --> 00:12:25.400
in your application, you know,
several different libraries.

00:12:25.400 --> 00:12:27.634
Each one
gets its own Android.mk,

00:12:27.634 --> 00:12:29.901
and then the application.mk
pulls it all together.

00:12:29.901 --> 00:12:31.934
But the application makefile

00:12:31.934 --> 00:12:34.567
also does some--
some other important things.

00:12:34.567 --> 00:12:37.634
It's a--it's a place to set your
global debug flag settings,

00:12:37.634 --> 00:12:40.667
um, and more--more importantly
than anything else,

00:12:40.667 --> 00:12:42.667
it's a place to set up your STL.

00:12:42.667 --> 00:12:44.667
And one of
the great new features

00:12:44.667 --> 00:12:48.067
that we've finally been able
to add in NDKr5

00:12:48.067 --> 00:12:50.067
is real STL support,

00:12:50.067 --> 00:12:52.067
including exceptions,

00:12:52.067 --> 00:12:55.067
uh, that you get with just
this one line of code

00:12:55.067 --> 00:12:59.267
in your makefile.

00:12:59.267 --> 00:13:01.267
Now you need to write
an interface,

00:13:01.267 --> 00:13:04.334
because remember that, unless
you happen to be targeting

00:13:04.334 --> 00:13:07.334
the 4% of devices
that run Gingerbread right now,

00:13:07.334 --> 00:13:10.868
you're probably gonna
want to start out in Java

00:13:10.868 --> 00:13:13.400
and then call in to C++.

00:13:13.400 --> 00:13:15.400
So you write a Java interface

00:13:15.400 --> 00:13:18.400
that's gonna wrap your C++ in
something that looks like Java,

00:13:18.400 --> 00:13:20.901
and to do that,
you use the native keyword.

00:13:20.901 --> 00:13:22.400
This is actually really easy.

00:13:22.400 --> 00:13:25.901
You just decide which functions
are gonna be, uh,

00:13:25.901 --> 00:13:27.901
implemented in C++,

00:13:27.901 --> 00:13:29.901
and then you use
the native keyword

00:13:29.901 --> 00:13:32.868
to do--um,
to define those functions

00:13:32.868 --> 00:13:37.033
inside your Java file.

00:13:37.033 --> 00:13:40.033
After that, you just need
to generate stubs

00:13:40.033 --> 00:13:42.033
in your C and C++ code

00:13:42.033 --> 00:13:44.534
which you can do
with a variety of tools.

00:13:44.534 --> 00:13:46.534
Eclipse has a tool for this.

00:13:46.534 --> 00:13:49.534
There's also a command line tool
in the JDK called javah,

00:13:49.534 --> 00:13:53.033
and it just generates a file
that looks a little like this.

00:13:53.033 --> 00:13:56.534
Remember that--oh, darn,
these little slides.

00:13:56.534 --> 00:13:59.534
Uh, remember we had
two public native void--

00:13:59.534 --> 00:14:03.100
or public data functions
in our sample code.

00:14:03.100 --> 00:14:07.100
If we passed the class
with these functions in them

00:14:07.100 --> 00:14:10.100
to javah, it's gonna generate
code that looks like this.

00:14:10.100 --> 00:14:13.767
Basically, you have a couple
of JNI export functions

00:14:13.767 --> 00:14:17.868
and... the, um,

00:14:17.868 --> 00:14:20.868
the names of the functions
are a concatenation

00:14:20.868 --> 00:14:23.868
of the class path
and the class name

00:14:23.868 --> 00:14:26.868
and the function name,
all separated by underscores.

00:14:26.868 --> 00:14:30.567
And the parameters
to those functions

00:14:30.567 --> 00:14:34.167
are transformed
into JNI types

00:14:34.167 --> 00:14:35.667
that--that are in C--

00:14:35.667 --> 00:14:39.334
you know, jint, for instance.

00:14:39.334 --> 00:14:41.834
Uh, and then there's a couple
of extra parameters.

00:14:41.834 --> 00:14:43.834
One's a pointer
to a JNI environment,

00:14:43.834 --> 00:14:45.868
which is sort of the object

00:14:45.868 --> 00:14:48.834
that you use to talk
to the Java system from C++,

00:14:48.834 --> 00:14:51.834
and there's also gonna be
a handle to your object.

00:14:51.834 --> 00:14:54.934
Or, if the function is static
in Java,

00:14:54.934 --> 00:14:57.934
there's gonna be a handle
to your class.

00:14:57.934 --> 00:15:00.934
We'll show you how to use that
in just a second.

00:15:03.534 --> 00:15:05.534
Now you might
be thinking to yourself,

00:15:05.534 --> 00:15:07.534
that looks really easy,
and it is.

00:15:07.534 --> 00:15:10.033
Just by giving the function
the proper name,

00:15:10.033 --> 00:15:12.734
the Java compiler
and the--and the Runtime

00:15:12.734 --> 00:15:16.734
know exactly how to find it
in your c--C and C++ code.

00:15:16.734 --> 00:15:18.767
And they find it
with a name lookup

00:15:18.767 --> 00:15:21.734
in--on a vtable that's sort of
automatically generated for you.

00:15:21.734 --> 00:15:24.400
But... there are times

00:15:24.400 --> 00:15:26.901
that you might
want to do this manually.

00:15:26.901 --> 00:15:29.901
For instance, let's say
that you've got some functions

00:15:29.901 --> 00:15:32.901
that you know you want
to implement in C,

00:15:32.901 --> 00:15:34.400
but you don't know exactly

00:15:34.400 --> 00:15:36.400
what the implementation is
until Runtime.

00:15:36.400 --> 00:15:39.234
A good example of this would be

00:15:39.234 --> 00:15:42.033
if you've got some
really heavy-duty math library,

00:15:42.033 --> 00:15:44.534
and you've got an implementation
that uses NEON

00:15:44.534 --> 00:15:46.868
and then another implementation
that doesn't.

00:15:46.868 --> 00:15:49.567
Well, not all CPUs have NEON,

00:15:49.567 --> 00:15:53.367
so you might want to delay
the binding of that function

00:15:53.367 --> 00:15:56.367
until you know what your
instruction set is going to be.

00:15:56.367 --> 00:15:58.367
If you wanted to do
something like that,

00:15:58.367 --> 00:16:00.367
it's also actually fairly easy.

00:16:00.367 --> 00:16:04.267
You just make your own
function table.

00:16:04.267 --> 00:16:06.267
Um, it's just an array
of structures

00:16:06.267 --> 00:16:08.767
that has the name
of the function.

00:16:08.767 --> 00:16:10.767
It has this cryptic
little string.

00:16:10.767 --> 00:16:13.267
That's just telling you
what the function signature is.

00:16:13.267 --> 00:16:16.267
In this case, uh, two integers,
uh, or the function

00:16:16.267 --> 00:16:18.267
takes two integers
and returns void.

00:16:18.267 --> 00:16:20.267
If you don't want to memorize

00:16:20.267 --> 00:16:22.267
this particular bit
of gobbledygook,

00:16:22.267 --> 00:16:25.634
you can use a, uh, tool
called javap

00:16:25.634 --> 00:16:27.601
to generate that,
or, once again,

00:16:27.601 --> 00:16:30.601
Eclipse has a menu item
that does this for you.

00:16:30.601 --> 00:16:33.634
Um...

00:16:33.634 --> 00:16:36.634
and then finally, the last thing
in that structure

00:16:36.634 --> 00:16:38.634
is just the point
of the function.

00:16:38.634 --> 00:16:41.133
Once you've created that table,

00:16:41.133 --> 00:16:44.634
when you're ready to register
up your--your interface,

00:16:44.634 --> 00:16:48.634
you just call a function
called register natives,

00:16:48.634 --> 00:16:52.534
and you pass in a pointer
of that table that you created.

00:16:52.534 --> 00:16:54.534
And that way,
you could actually have

00:16:54.534 --> 00:16:56.534
multiple
different implementations

00:16:56.534 --> 00:16:58.901
of the same functions
inside the same library

00:16:58.901 --> 00:17:02.434
being hooked up at Runtime
to your Java code.

00:17:02.434 --> 00:17:06.434
Of course, it's cool that you
can call C++ code from Java.

00:17:06.434 --> 00:17:09.434
It's also kind of nice
to be able to go the other way.

00:17:09.434 --> 00:17:11.434
That's not super--I'm not gonna
tell you that's easy,

00:17:11.434 --> 00:17:13.434
because it's not one line
of code,

00:17:13.434 --> 00:17:15.434
but it is
pretty straightforward.

00:17:15.434 --> 00:17:18.434
And this is where we use that
class or, uh, object handle

00:17:18.434 --> 00:17:20.434
that we talked about earlier.

00:17:20.434 --> 00:17:22.767
Um...
using object handle,

00:17:22.767 --> 00:17:25.434
you can get a handle
to its class.

00:17:25.434 --> 00:17:27.434
Using class handle,

00:17:27.434 --> 00:17:29.934
you can get a handle
to a method,

00:17:29.934 --> 00:17:32.467
and once you've got a handle
to a method,

00:17:32.467 --> 00:17:35.801
you can use a function
on that JNI environment,

00:17:35.801 --> 00:17:38.801
uh, one of the call method

00:17:38.801 --> 00:17:40.467
family of functions

00:17:40.467 --> 00:17:42.467
that differ by return type.

00:17:42.467 --> 00:17:45.467
And--and that allows you
to actually make a call

00:17:45.467 --> 00:17:47.467
from C and C++
back into Java.

00:17:47.467 --> 00:17:49.534
Excuse me. Mm.

00:17:52.701 --> 00:17:54.534
So that's all the coding.

00:17:54.534 --> 00:17:56.801
Now we get to build,
and that's pretty normal.

00:17:56.801 --> 00:17:59.400
If you've done any Java
or--excuse me--

00:17:59.400 --> 00:18:01.601
any, uh, Android
programming before,

00:18:01.601 --> 00:18:03.601
you probably know
the second two steps.

00:18:03.601 --> 00:18:05.634
It's the first step
that's a little different.

00:18:05.634 --> 00:18:08.100
You run ndk-build,
which is a shell script

00:18:08.100 --> 00:18:10.100
that just launches
all those makefiles,

00:18:10.100 --> 00:18:12.100
stitches everything together,

00:18:12.100 --> 00:18:14.100
copies everything
to the right directories,

00:18:14.100 --> 00:18:15.601
and makes sure

00:18:15.601 --> 00:18:18.100
that all of the C and C++ code
that you've compiled

00:18:18.100 --> 00:18:20.701
is where the packager
expects to find it.

00:18:20.701 --> 00:18:24.267
Then run Ant to package it,
run Ant deploy or--

00:18:24.267 --> 00:18:27.501
I'm sorry--Ant install
to deploy it,

00:18:27.501 --> 00:18:30.467
and we're ready to debug.

00:18:30.467 --> 00:18:33.300
Now this is actually
the most important, cool thing

00:18:33.300 --> 00:18:36.133
that we've done in the past year
with Androids.

00:18:36.133 --> 00:18:40.100
We actually made it possible
to run a real instance of GDB

00:18:40.100 --> 00:18:42.100
and do multi-threaded debugging

00:18:42.100 --> 00:18:43.934
on Android devices.

00:18:43.934 --> 00:18:46.367
The NDK GDB script
is a shell script

00:18:46.367 --> 00:18:48.701
that does a whole lot
of heavy lifting.

00:18:48.701 --> 00:18:52.334
It starts by sanity checking
your setup and making sure

00:18:52.334 --> 00:18:55.334
that you can actually debug
the code that you think you can,

00:18:55.334 --> 00:18:57.834
um, and then it's gonna
start your application

00:18:57.834 --> 00:19:00.334
in an instance of GDB server.

00:19:00.334 --> 00:19:02.400
The GDB server
is this tiny little thing

00:19:02.400 --> 00:19:03.901
that just communicates

00:19:03.901 --> 00:19:08.534
with a real GDB across,
in this case, a named pipe.

00:19:08.534 --> 00:19:11.334
Why is it a named pipe
instead of a socket?

00:19:11.334 --> 00:19:14.334
So we don't have to ask for
internet privileges to debug.

00:19:14.334 --> 00:19:17.334
So GDB connects to this,
uh, named pipe on your host.

00:19:17.334 --> 00:19:19.334
It thinks there's a socket
on the host,

00:19:19.334 --> 00:19:23.234
because it's been, um, aliased.

00:19:23.234 --> 00:19:26.734
And once GDB is running,
you can attach to that

00:19:26.734 --> 00:19:28.734
with any tool
that supports GDB--

00:19:28.734 --> 00:19:30.734
I know of at least three.

00:19:30.734 --> 00:19:32.734
Eclipse supports GDB.

00:19:32.734 --> 00:19:34.734
Um, Visual Studio supports GDB

00:19:34.734 --> 00:19:36.734
if you buy an add-on
called WinGDB.

00:19:36.734 --> 00:19:39.234
Xcode, which I've never used,
but I hear it's cool,

00:19:39.234 --> 00:19:41.234
also, uh, it supports GDB.

00:19:41.234 --> 00:19:43.234
So you can use these IDEs

00:19:43.234 --> 00:19:46.234
or you can use
the, uh, command line interface

00:19:46.234 --> 00:19:48.801
to GDB, as well.

00:19:48.801 --> 00:19:51.300
Now I'm just about to turn it
back over to Dan,

00:19:51.300 --> 00:19:53.300
and we're gonna talk
about some tips and tricks,

00:19:53.300 --> 00:19:55.300
and it's really actually
the most interesting part

00:19:55.300 --> 00:19:57.300
of the talk,
but before we do,

00:19:57.300 --> 00:19:59.801
I want to leave you
with one tip of my own,

00:19:59.801 --> 00:20:01.801
just from experience debugging.

00:20:01.801 --> 00:20:04.801
Make sure that, when you
start debugging the NDK,

00:20:04.801 --> 00:20:06.801
you have a Gingerbread device.

00:20:06.801 --> 00:20:08.801
No matter
what you're targeting,

00:20:08.801 --> 00:20:11.300
the debug support
pre-Gingerbread

00:20:11.300 --> 00:20:13.200
was not phenomenal.

00:20:13.200 --> 00:20:15.400
Gingerbread changes all that,
and it allows you

00:20:15.400 --> 00:20:17.868
to actually debug
multithreaded applications

00:20:17.868 --> 00:20:19.868
and have a hope
of actually figuring out

00:20:19.868 --> 00:20:21.868
what's wrong with your code.

00:20:21.868 --> 00:20:23.868
So remember to do that,

00:20:23.868 --> 00:20:26.367
and then I'm gonna turn this
over to Dan

00:20:26.367 --> 00:20:29.367
for some ideas on how you can
bring your games to Android.

00:20:29.367 --> 00:20:32.901
Galpin: Thanks, Ian.
[applause]

00:20:32.901 --> 00:20:34.901
Galpin: Um, so this part
of the talk

00:20:34.901 --> 00:20:36.901
is subtitled
"Saving Ian's Voice."

00:20:36.901 --> 00:20:39.901
And, uh, but, uh,
it's really good--

00:20:39.901 --> 00:20:41.901
it's really great
to have him here to talk about,

00:20:41.901 --> 00:20:44.901
uh, a lot of the stuff
that's going on in--in the NDK.

00:20:44.901 --> 00:20:47.400
So this part of the talk,
we're gonna be talking about

00:20:47.400 --> 00:20:49.067
actually bringing your game
to Android

00:20:49.067 --> 00:20:51.067
and what that actually involves.

00:20:51.067 --> 00:20:53.067
So let's first talk
about what devices

00:20:53.067 --> 00:20:55.567
have been accessing
Android market.

00:20:55.567 --> 00:20:57.567
This is basically
the freshest data.

00:20:57.567 --> 00:21:00.901
It's a 2-week period.
We published it just this week.

00:21:00.901 --> 00:21:02.968
And as you can see,
it's really exciting.

00:21:02.968 --> 00:21:05.834
We've had great uptake
for Android 2.2.

00:21:05.834 --> 00:21:08.834
65.9% of devices
checking into market

00:21:08.834 --> 00:21:10.834
are now running Froyo,

00:21:10.834 --> 00:21:13.167
and 94.7%

00:21:13.167 --> 00:21:16.067
are running Android 2.1
or higher.

00:21:16.067 --> 00:21:17.801
So this is fantastic,

00:21:17.801 --> 00:21:19.801
because it means
that you can take advantage

00:21:19.801 --> 00:21:21.734
of many of the latest features
of Android

00:21:21.734 --> 00:21:25.634
without having to eliminate
much of the market at all.

00:21:25.634 --> 00:21:27.734
But NativeActivity
is just starting.

00:21:27.734 --> 00:21:30.901
Right now, we're at 4.3%,

00:21:30.901 --> 00:21:33.434
so for
non-tablet-specific titles,

00:21:33.434 --> 00:21:35.934
things that are not going
to require Honeycomb,

00:21:35.934 --> 00:21:38.934
we want to be able to take
advantage of NativeActivity

00:21:38.934 --> 00:21:41.434
when it's useful,
and I'll give you an example.

00:21:41.434 --> 00:21:44.601
Um, how many people here have
heard about the Xperia PLAY?

00:21:44.601 --> 00:21:47.267
Okay. Cool device.

00:21:47.267 --> 00:21:50.767
Um, it has a touch pad on it,
and that touch pad

00:21:50.767 --> 00:21:54.367
is only accessible right now
through NativeActivity.

00:21:54.367 --> 00:21:56.367
So a lot of people
are in a position

00:21:56.367 --> 00:21:58.400
where they want to write
an application that's compatible

00:21:58.400 --> 00:22:00.367
that can take advantage
of those touch pads,

00:22:00.367 --> 00:22:02.934
but they still want to hit
the rest of the market.

00:22:02.934 --> 00:22:04.934
So let's talk about
how to do that.

00:22:04.934 --> 00:22:07.434
So we can do something

00:22:07.434 --> 00:22:10.100
called
platform-specific resources,

00:22:10.100 --> 00:22:12.100
and we can define
boolean values there.

00:22:12.100 --> 00:22:14.100
And this is how that works.

00:22:14.100 --> 00:22:16.100
We create resources
in a values--

00:22:16.100 --> 00:22:19.267
in a values-v9 directory.

00:22:19.267 --> 00:22:21.267
Inside of there,
we create two values,

00:22:21.267 --> 00:22:24.267
one called, in this case,
"atleastGingerbread"

00:22:24.267 --> 00:22:26.267
and the other called
"notGingerbread."

00:22:26.267 --> 00:22:29.267
From there, we can just go into
the manifest.

00:22:29.267 --> 00:22:32.300
Now we enable one activity,

00:22:32.300 --> 00:22:34.267
if atleastGingerbread is true,

00:22:34.267 --> 00:22:36.901
and one activity
if notGingerbread is true.

00:22:36.901 --> 00:22:38.901
Voilï¿½,
We have an application

00:22:38.901 --> 00:22:41.901
that now can run NativeActivity
on Gingerbread

00:22:41.901 --> 00:22:45.400
and will run whatever standard
activity on everything else.

00:22:45.400 --> 00:22:48.734
Now there are some things you'll
want to do in your native code

00:22:48.734 --> 00:22:50.234
to take advantage of this.

00:22:50.234 --> 00:22:52.067
Oh, let me actually show you--

00:22:52.067 --> 00:22:54.067
there's what
I was gonna show you there.

00:22:54.067 --> 00:22:56.067
Um, there's some things
you're gonna want to do

00:22:56.067 --> 00:22:57.567
to take advantage of this.

00:22:57.567 --> 00:22:59.567
One is you're gonna want
to create stub interfaces

00:22:59.567 --> 00:23:01.067
to your game engine.

00:23:01.067 --> 00:23:03.901
Obviously, you do not want
to HardCode the dependencies

00:23:03.901 --> 00:23:05.934
to NativeActivity
in your game engine

00:23:05.934 --> 00:23:07.901
and include
the whole thing twice.

00:23:07.901 --> 00:23:09.901
It's gonna make the download
a lot larger.

00:23:09.901 --> 00:23:11.901
It also means maintenance
can potentially be larger.

00:23:11.901 --> 00:23:13.901
So what we're going to do

00:23:13.901 --> 00:23:15.901
is we're going to create
some stub libraries.

00:23:15.901 --> 00:23:17.901
We'll talk about that
really fancy build system

00:23:17.901 --> 00:23:19.400
we had before.

00:23:19.400 --> 00:23:21.400
This is what the Android.make
looks like now.

00:23:21.400 --> 00:23:23.400
As you see,
it just contains a pointer

00:23:23.400 --> 00:23:25.400
to three other libraries
we want to build.

00:23:25.400 --> 00:23:27.067
There's
the application.makefile.

00:23:27.067 --> 00:23:31.000
It actually lists
each one of those libraries.

00:23:31.000 --> 00:23:33.400
Inside of
the individual directories,

00:23:33.400 --> 00:23:36.400
We also contain
and have other makefiles.

00:23:36.400 --> 00:23:38.968
In the Android.make,
we have this one,

00:23:38.968 --> 00:23:41.767
and in the Native Android.make,
we have this one.

00:23:41.767 --> 00:23:45.200
This one, of course, only refers
to libraries that are in Froyo,

00:23:45.200 --> 00:23:48.200
and this one refers to libraries
that are actually available

00:23:48.200 --> 00:23:51.601
in Gingerbread and beyond.

00:23:51.601 --> 00:23:53.100
And what's important

00:23:53.100 --> 00:23:56.834
is both of them use
the same local shared library,

00:23:56.834 --> 00:23:58.834
and that's where
the primary amount of our code

00:23:58.834 --> 00:24:01.567
will actually sit.

00:24:01.567 --> 00:24:03.567
So we do have one problem,

00:24:03.567 --> 00:24:06.067
and that is Android
does not support

00:24:06.067 --> 00:24:09.667
dynamically loaded libraries
that are automatically linked.

00:24:09.667 --> 00:24:11.667
We don't do dependency checking.

00:24:11.667 --> 00:24:15.501
So we have to have a way
of loading that other library

00:24:15.501 --> 00:24:17.501
before NativeActivity kicks off.

00:24:17.501 --> 00:24:19.000
The good news

00:24:19.000 --> 00:24:22.000
is that we actually provide
a method for doing that.

00:24:22.000 --> 00:24:24.000
We can extend NativeActivity.

00:24:24.000 --> 00:24:26.501
So all we're doing in our--
in NativeActivity

00:24:26.501 --> 00:24:28.501
is creating a static member

00:24:28.501 --> 00:24:31.801
that loads
our primary dynamic library.

00:24:31.801 --> 00:24:34.801
Now in our standard
JNI-based version,

00:24:34.801 --> 00:24:36.801
we simply load them in order.

00:24:36.801 --> 00:24:38.801
And that's it.

00:24:38.801 --> 00:24:42.300
With this, you can actually have
two--two different activities

00:24:42.300 --> 00:24:45.234
that share
the same native code path

00:24:45.234 --> 00:24:47.200
but target different devices.

00:24:47.200 --> 00:24:49.701
Now let's talk about
what you need to do

00:24:49.701 --> 00:24:51.701
in order to write a game.

00:24:51.701 --> 00:24:53.868
Well, you need to deal
with the Android Lifecycle.

00:24:53.868 --> 00:24:56.033
You're gonna deal with--
you're gonna have to have--

00:24:56.033 --> 00:24:58.200
deal with Input, Graphics,
Sound, and, of course, Assets.

00:24:58.200 --> 00:25:00.934
And the reason I want to bring
up the activity lifecycle

00:25:00.934 --> 00:25:02.934
is it is so important.

00:25:02.934 --> 00:25:05.934
The framework does a lot to help
you with the activity lifecycle,

00:25:05.934 --> 00:25:08.934
and I'm sure many of you have
seen a diagram like this.

00:25:08.934 --> 00:25:10.934
Someone comes in front
of your activity.

00:25:10.934 --> 00:25:13.434
It's visible. It get shut down.
It comes to the foreground.

00:25:13.434 --> 00:25:14.934
It gets restarted.

00:25:14.934 --> 00:25:16.767
You know,
all this stuff happens,

00:25:16.767 --> 00:25:18.767
and there's always one line
that has been missing

00:25:18.767 --> 00:25:20.767
from this diagram,
and that's this one.

00:25:20.767 --> 00:25:23.701
Okay, and that happens
when something in your process

00:25:23.701 --> 00:25:25.701
actually changes
the configuration.

00:25:25.701 --> 00:25:28.701
So you're at--so look
at all the different ways

00:25:28.701 --> 00:25:30.701
your application
can go through this chart.

00:25:30.701 --> 00:25:32.701
But here's what's interesting--

00:25:32.701 --> 00:25:35.701
There's only one in which your
process actually gets killed.

00:25:35.701 --> 00:25:37.200
Most of the time,

00:25:37.200 --> 00:25:39.701
your native process
is never going to get killed.

00:25:39.701 --> 00:25:42.200
Your library is not going
to get reloaded,

00:25:42.200 --> 00:25:45.133
and this means that you actually
have to be a little bit smart,

00:25:45.133 --> 00:25:48.701
because Android tries to keep
your process around

00:25:48.701 --> 00:25:52.534
for as long as possible, so even
if you finish your activity,

00:25:52.534 --> 00:25:54.834
your native process
is going to continue running.

00:25:54.834 --> 00:25:57.534
It's gonna continue
to get a bunch of CPU cycles.

00:25:57.534 --> 00:25:59.033
What does this mean?

00:25:59.033 --> 00:26:01.100
It means if you actually
continue that running,

00:26:01.100 --> 00:26:03.100
it's gonna be bad.

00:26:03.100 --> 00:26:06.200
Now visible activities
are given high priority,

00:26:06.200 --> 00:26:08.200
so it's not the end
of the world,

00:26:08.200 --> 00:26:11.200
but it is something
that is very important to note.

00:26:11.200 --> 00:26:13.200
So what does this mean?

00:26:13.200 --> 00:26:16.133
Be careful
with static initializers.

00:26:16.133 --> 00:26:18.133
Your library
will not be unloaded

00:26:18.133 --> 00:26:21.267
as long as your process
is active.

00:26:21.267 --> 00:26:23.934
So this means that
when your activity restarts,

00:26:23.934 --> 00:26:27.200
you need to be able to manually
reinitialize anything

00:26:27.200 --> 00:26:29.634
that you might be relying
on static initializers to do.

00:26:29.634 --> 00:26:31.634
So in general, don't use them.

00:26:31.634 --> 00:26:34.400
Uh, also,
be careful with threads,

00:26:34.400 --> 00:26:36.400
because threads are tied
to your process.

00:26:36.400 --> 00:26:38.901
They'll continue to run even
if your activity has ended.

00:26:38.901 --> 00:26:41.400
And what that means is that
people will be using the device,

00:26:41.400 --> 00:26:43.400
and they'll find that
it's slow and terrible,

00:26:43.400 --> 00:26:45.067
and they'll look
in the battery life meter,

00:26:45.067 --> 00:26:47.067
and they'll realize that
your application is the one

00:26:47.067 --> 00:26:48.801
that's sucking up
all the battery life

00:26:48.801 --> 00:26:50.801
and then they'll go
on Android Market

00:26:50.801 --> 00:26:53.501
and they'll give you a one-star
review and say that you suck.

00:26:53.501 --> 00:26:55.501
I mean, they might
do that anyways,

00:26:55.501 --> 00:26:58.501
but at least let's not give them
a reason to do it.

00:26:58.501 --> 00:27:00.067
Um, other things to note

00:27:00.067 --> 00:27:02.133
is that Gameplay should stop
during onPause,

00:27:02.133 --> 00:27:04.501
but your application
might still be visible,

00:27:04.501 --> 00:27:06.667
and I'll tell you, the most
standard way that can happen

00:27:06.667 --> 00:27:08.667
is if you're using
In-app Billing,

00:27:08.667 --> 00:27:11.033
you'll bring up--it'll--it'll
actually bring up an intent

00:27:11.033 --> 00:27:14.033
that'll cause an activity
to show up not full screen.

00:27:14.033 --> 00:27:16.267
Well, your application
is technically paused,

00:27:16.267 --> 00:27:17.968
but still visible,

00:27:17.968 --> 00:27:20.968
so it might make sense to do
some more stuff in onStop

00:27:20.968 --> 00:27:22.968
than you were doing in onPause.

00:27:22.968 --> 00:27:24.467
Still save all your state,

00:27:24.467 --> 00:27:26.467
but maybe you don't want
to trash

00:27:26.467 --> 00:27:28.968
all of your GL variables
in onPause in that case.

00:27:28.968 --> 00:27:30.467
Finally, in onDestroy,

00:27:30.467 --> 00:27:32.767
you want to make sure all
your native code is cleaned up.

00:27:32.767 --> 00:27:34.434
And a lot of people
are like,

00:27:34.434 --> 00:27:36.434
"Well, onDestroy never gets
called, right?"

00:27:36.434 --> 00:27:38.000
I mean--but it does.

00:27:38.000 --> 00:27:40.000
There are definite ways
in which it can get called,

00:27:40.000 --> 00:27:42.000
especially if you're not
handling orientation changes

00:27:42.000 --> 00:27:44.501
or changes in--in, uh,
in devices,

00:27:44.501 --> 00:27:46.501
like, when a keyboard is
attached or something like that,

00:27:46.501 --> 00:27:48.334
and it tries to restart
your activity.

00:27:48.334 --> 00:27:50.334
So you've got two choices--
you can either handle

00:27:50.334 --> 00:27:52.000
all those--all those
configuration changes,

00:27:52.000 --> 00:27:54.334
or you can be really,
really vigilant about this--

00:27:54.334 --> 00:27:56.000
one of the two.

00:27:56.000 --> 00:27:57.934
So let's talk a bit--
just go quickly

00:27:57.934 --> 00:27:59.934
about all the things
you've got to handle.

00:27:59.934 --> 00:28:01.501
You've got to handle input,
okay?

00:28:01.501 --> 00:28:03.067
Key handling is important.

00:28:03.067 --> 00:28:05.000
A lot of devices
have capacitive buttons,

00:28:05.000 --> 00:28:07.033
and what this means is that
we actually madea change

00:28:07.033 --> 00:28:09.701
in Android 2 that said, instead
of just relying on onKeyDown,

00:28:09.701 --> 00:28:11.701
we actually went,
and you have to get a cycle

00:28:11.701 --> 00:28:13.200
of onKeyDown and onKeyUp.

00:28:13.200 --> 00:28:14.701
This prevents you

00:28:14.701 --> 00:28:16.534
from accidentally swiping
into a button

00:28:16.534 --> 00:28:19.200
and clicking it when you don't
mean to a lot of the time.

00:28:19.200 --> 00:28:21.200
It doesn't mean that it doesn't
happen, but it helps.

00:28:21.200 --> 00:28:23.200
Another thing to do is,
if you're gonna do things

00:28:23.200 --> 00:28:25.033
like handle key repeats,
use the actual functions

00:28:25.033 --> 00:28:26.868
that are built
into the framework

00:28:26.868 --> 00:28:28.868
so you--so you get the same
key repeat counts

00:28:28.868 --> 00:28:30.701
and the same behavior
you would expect

00:28:30.701 --> 00:28:32.200
from an Android application.

00:28:32.200 --> 00:28:34.033
Touch and Multitouch handling
is similar.

00:28:34.033 --> 00:28:36.033
We have things
like GestureDetector.

00:28:36.033 --> 00:28:38.534
Use those so that
your application behaves

00:28:38.534 --> 00:28:41.601
like a non-native application
whenever possible,

00:28:41.601 --> 00:28:43.100
when it makes sense.

00:28:43.100 --> 00:28:45.100
And then finally
and probably most importantly--

00:28:45.100 --> 00:28:46.767
dealing with Multitouch.

00:28:46.767 --> 00:28:49.100
Now most devices
now support Multitouch,

00:28:49.100 --> 00:28:51.601
and most devices can actually
track distinct points,

00:28:51.601 --> 00:28:55.601
but you can query to find out
whether or not that's true

00:28:55.601 --> 00:28:57.601
by checking this variable--

00:28:57.601 --> 00:28:59.601
"FEATURE_TOUCHSCREEN_
MULTITOUCH_ DISTINCT."

00:28:59.601 --> 00:29:01.667
You can also use it as a filter
in Android Market.

00:29:01.667 --> 00:29:03.667
If you want to make sure
your device

00:29:03.667 --> 00:29:05.667
supports true
2-finger multitouch, you can.

00:29:05.667 --> 00:29:08.000
We also add a feature in
Gingerbread called Jazz Hands,

00:29:08.000 --> 00:29:10.000
which allows you to see

00:29:10.000 --> 00:29:12.934
if you application supports
5-finger multitouch.

00:29:12.934 --> 00:29:15.434
So these are all--all things
that you can do

00:29:15.434 --> 00:29:17.968
to help configure your why
to make sense for your user.

00:29:17.968 --> 00:29:20.200
Now even if you don't support
distinct multitouch,

00:29:20.200 --> 00:29:22.534
you can do things,
like have virtual D-pads.

00:29:22.534 --> 00:29:25.534
You just want to put them in
opposite corners of the screen

00:29:25.534 --> 00:29:27.467
so that they
will never intersect.

00:29:30.501 --> 00:29:32.501
It is cool to handle things
like trackballs.

00:29:32.501 --> 00:29:35.167
For the devices that have them,
I love it when it's an option.

00:29:35.167 --> 00:29:37.167
And, of course, um, everyone's
gonna want to use things

00:29:37.167 --> 00:29:38.667
like sensors, you know.

00:29:38.667 --> 00:29:40.667
When people are gonna want
to take advantage

00:29:40.667 --> 00:29:42.667
of the Xceleron or the Gyro.
You just want to make sure

00:29:42.667 --> 00:29:44.334
that it's disabled
when you're not using it.

00:29:44.334 --> 00:29:46.534
You're also gonna want to make
sure to "Androidify" your game,

00:29:46.534 --> 00:29:48.801
and what I mean is don't break
the hard buttons.

00:29:48.801 --> 00:29:50.801
So, you know,
"Back" should do something.

00:29:50.801 --> 00:29:52.801
There's nothing worse than when
you're on the title screen

00:29:52.801 --> 00:29:54.801
of a game, you hit the "Back"
button and nothing happens,

00:29:54.801 --> 00:29:56.467
and just, you know,
the Pease Electric goes off

00:29:56.467 --> 00:29:58.067
to let you know that
you're hitting the button,

00:29:58.067 --> 00:30:00.067
but the game is not responding
or doing something.

00:30:00.067 --> 00:30:01.567
Make sure it does something.

00:30:01.567 --> 00:30:03.567
Uh, you know, Menu could--
should probably do something,

00:30:03.567 --> 00:30:05.567
and if someone accidentally
swipes the Home key,

00:30:05.567 --> 00:30:07.567
there's nothing worse
than when the game goes away.

00:30:07.567 --> 00:30:09.567
So the result--and volume
buttons are very similar.

00:30:09.567 --> 00:30:11.100
We don't want to eat
those messages.

00:30:11.100 --> 00:30:13.100
You--you actually have to return
them to the framework,

00:30:13.100 --> 00:30:15.100
and you want to set
the volume control stream.

00:30:15.100 --> 00:30:16.601
And then again,

00:30:16.601 --> 00:30:18.601
don't let the hard buttons
bake--break your game.

00:30:18.601 --> 00:30:21.100
You want to save your state.
It's very, very important.

00:30:21.100 --> 00:30:25.334
You know, these buttons
do things that are relevant.

00:30:25.334 --> 00:30:27.667
OpenGL--Let's talk
very, very quickly about this.

00:30:27.667 --> 00:30:30.267
The coolest thing about OpenGL
and Android

00:30:30.267 --> 00:30:33.267
is that you can actually create
your surface inside of Dalvik

00:30:33.267 --> 00:30:36.267
and take advantage of it
directly from within the NDK,

00:30:36.267 --> 00:30:38.267
and that's awesome,
because, actually,

00:30:38.267 --> 00:30:40.601
it's a lot of work

00:30:40.601 --> 00:30:42.968
to create OpenGL stuff--

00:30:42.968 --> 00:30:45.901
OpenGL context compatibly
across Android.

00:30:45.901 --> 00:30:48.934
And GLSurfaceView--if you ever
look at the source code,

00:30:48.934 --> 00:30:51.434
and, of course,
what's awesome is that you can,

00:30:51.434 --> 00:30:54.801
um, actually contains
a whole bunch of stuff

00:30:54.801 --> 00:30:56.801
that you don't want
to have to rewrite

00:30:56.801 --> 00:30:58.801
that works around
a lot of issues

00:30:58.801 --> 00:31:00.801
that can possibly happen
in the GL driver.

00:31:00.801 --> 00:31:02.868
So I definitely recommend
using it.

00:31:02.868 --> 00:31:05.667
Now it's not the most efficient
way to multitask,

00:31:05.667 --> 00:31:07.667
because it's going
to automatically release

00:31:07.667 --> 00:31:09.167
your context during onPause

00:31:09.167 --> 00:31:13.000
if you call its onPause state
during the onPause.

00:31:13.000 --> 00:31:15.000
That's when it does the work
for you.

00:31:15.000 --> 00:31:17.000
You might want to call it
during onStop

00:31:17.000 --> 00:31:19.501
if you know you're gonna
be using a In-app Billing--

00:31:19.501 --> 00:31:21.000
one thing to think about.

00:31:21.000 --> 00:31:24.000
But also with, um, Honeycomb,

00:31:24.000 --> 00:31:25.501
you can actually say,

00:31:25.501 --> 00:31:28.000
"I want it to preserve
my state," and it will.

00:31:28.000 --> 00:31:31.000
So we added that as a feature
in Android 3.0.

00:31:31.000 --> 00:31:32.834
And when your context is lost,

00:31:32.834 --> 00:31:34.834
you're gonna have to do
a lot of work.

00:31:34.834 --> 00:31:36.667
You're gonna have to reload
your resources--

00:31:36.667 --> 00:31:38.501
things like textures,
buffer optics, and shaders,

00:31:38.501 --> 00:31:40.334
and your names
don't even persist.

00:31:40.334 --> 00:31:42.667
So these are all things
that are important to remember

00:31:42.667 --> 00:31:44.334
when you're using OpenGL.

00:31:44.334 --> 00:31:46.334
The marketing way
of describing this

00:31:46.334 --> 00:31:49.501
is that Android encourages
innovation in hardware.

00:31:49.501 --> 00:31:51.501
[laughter]
Galpin: [laughs]

00:31:51.501 --> 00:31:54.534
What this means is that you have
a problem as a developer.

00:31:54.534 --> 00:31:57.267
You've got to deal
with potentially different kinds

00:31:57.267 --> 00:31:59.634
of proprietary texture
compression formats,

00:31:59.634 --> 00:32:03.133
and if you want
the best quality, you will,

00:32:03.133 --> 00:32:05.133
because your--
your other solutions

00:32:05.133 --> 00:32:06.801
are not all that great.

00:32:06.801 --> 00:32:08.467
You can use
uncompressed textures,

00:32:08.467 --> 00:32:09.968
but what that means

00:32:09.968 --> 00:32:12.300
is that you are going
to get a lower frame rate,

00:32:12.300 --> 00:32:14.300
because you're gonna be using
more memory bandwidth.

00:32:14.300 --> 00:32:16.300
You can use ETC1,

00:32:16.300 --> 00:32:19.968
but ETC1 doesn't compress
all data very well.

00:32:19.968 --> 00:32:21.968
It's mostly good for data

00:32:21.968 --> 00:32:23.968
that does not have
sharp color transitions

00:32:23.968 --> 00:32:25.968
and it does not support Alpha.

00:32:25.968 --> 00:32:27.968
You can use Multi-APK,

00:32:27.968 --> 00:32:30.501
which, as we announced earlier,
will be available soon,

00:32:30.501 --> 00:32:33.367
or you can put textures
on an asset server,

00:32:33.367 --> 00:32:35.000
detect support at Runtime,

00:32:35.000 --> 00:32:37.000
and downtoad--
download to each device.

00:32:37.000 --> 00:32:38.934
In the previous session
before this one,

00:32:38.934 --> 00:32:42.200
we talked about how to secure--
securely deliver assets

00:32:42.200 --> 00:32:45.501
from an asset server in order to
avoid people leeching bandwidth.

00:32:45.501 --> 00:32:47.501
So if you want
to know about that,

00:32:47.501 --> 00:32:50.033
there's some information
on that.

00:32:50.033 --> 00:32:53.634
So some--some small tips
about drawing for performance.

00:32:53.634 --> 00:32:56.133
Draw order is important,
especially if you're not on a--

00:32:56.133 --> 00:32:58.133
on a tile-based renderer,

00:32:58.133 --> 00:33:00.234
or a-a specific type

00:33:00.234 --> 00:33:02.300
of tile-based renderer
in this case.

00:33:02.300 --> 00:33:04.300
So definitely draw
front to back.

00:33:04.300 --> 00:33:06.334
It really helps.

00:33:06.334 --> 00:33:08.734
VBOs are critical
for performance.

00:33:08.734 --> 00:33:11.067
You want to avoid
unnecessary state changes.

00:33:11.067 --> 00:33:14.934
And finally, you need to use
power of 2 sized textures,

00:33:14.934 --> 00:33:17.100
because if you don't,

00:33:17.100 --> 00:33:19.100
it can either be very slow,

00:33:19.100 --> 00:33:21.834
or it's just going to take
an enormous amount of memory,

00:33:21.834 --> 00:33:23.834
because it's just going
to scale your texture up

00:33:23.834 --> 00:33:25.834
to the next power
of 2 sized textures

00:33:25.834 --> 00:33:27.834
automatically inside the driver.

00:33:27.834 --> 00:33:30.000
Or it's just not gonna work.

00:33:30.000 --> 00:33:33.701
Um, and then, of course,
writing compatible shaders,

00:33:33.701 --> 00:33:37.200
and this--this slide is actually
contributed by my friend Kim

00:33:37.200 --> 00:33:40.200
over at Sony Ericsson, because
he--they've done a lot of work

00:33:40.200 --> 00:33:42.701
on this, but, uh,
it's very, very important

00:33:42.701 --> 00:33:46.234
to query for the number
of attributes, and the varying,

00:33:46.234 --> 00:33:48.234
and the uniforms
that are supported

00:33:48.234 --> 00:33:50.234
when you're writing
your shaders.

00:33:50.234 --> 00:33:52.234
And just because they're there

00:33:52.234 --> 00:33:54.567
doesn't mean they're actually
going to perform well,

00:33:54.567 --> 00:33:56.067
but if it's not there

00:33:56.067 --> 00:33:58.067
and you try to write a shader
that does that,

00:33:58.067 --> 00:34:00.934
it's going to crash your
application, and that's not fun.

00:34:00.934 --> 00:34:03.501
Uh, and of course, you want
to avoid things like conditions

00:34:03.501 --> 00:34:05.501
and discard as much as possible,

00:34:05.501 --> 00:34:07.501
'cause it's really going to slow
down the performance

00:34:07.501 --> 00:34:09.200
of your shaders.

00:34:09.200 --> 00:34:11.634
Mobile shaders are just in the
beginning on their lifecycle,

00:34:11.634 --> 00:34:14.167
and they are going to do
very, very cool things,

00:34:14.167 --> 00:34:16.667
but right now, we have to be
a little cautious

00:34:16.667 --> 00:34:19.767
when we write them.

00:34:19.767 --> 00:34:21.267
Quickly into sound--

00:34:21.267 --> 00:34:23.267
Android includes a bunch
of options for sound.

00:34:23.267 --> 00:34:25.267
It can be a little confusing,

00:34:25.267 --> 00:34:27.267
so let's go through them
super quickly.

00:34:27.267 --> 00:34:28.767
We have MediaPlayer,

00:34:28.767 --> 00:34:30.767
which is really
a full-track media solution.

00:34:30.767 --> 00:34:33.767
We have SoundPool, which allows
you to play sounds from memory,

00:34:33.767 --> 00:34:36.100
and it's actually the only way

00:34:36.100 --> 00:34:38.434
to play compressed audio
from memory.

00:34:38.434 --> 00:34:42.334
That is not yet supported
in native OpenSL.

00:34:42.334 --> 00:34:44.334
We also have,
of course, AudioTrack,

00:34:44.334 --> 00:34:47.334
which is something we introduced
in--in...

00:34:47.334 --> 00:34:49.701
Android 1.5...
[inhales sharply] I think,

00:34:49.701 --> 00:34:51.701
and, uh, it, uh, allows you

00:34:51.701 --> 00:34:55.801
to play PCM audio only
with minimal latency,

00:34:55.801 --> 00:34:57.801
and it's really meant
for applications

00:34:57.801 --> 00:34:59.801
that are generating
their own audio.

00:34:59.801 --> 00:35:02.033
And finally,
we have OpenSL, yes,

00:35:02.033 --> 00:35:04.367
which does require
Android 2.3 or higher,

00:35:04.367 --> 00:35:06.901
but it combines the capabilities
of MediaPlayer and AudioTrack,

00:35:06.901 --> 00:35:09.901
and it allows you to do all
of your audio from native code.

00:35:09.901 --> 00:35:12.901
And it--and the interface
is actually a little nicer

00:35:12.901 --> 00:35:14.901
in terms of generating audio,

00:35:14.901 --> 00:35:17.400
because it actually calls you
back when it needs a buffer.

00:35:17.400 --> 00:35:19.400
So it's a very,
very straightforward interface

00:35:19.400 --> 00:35:20.901
to use.

00:35:20.901 --> 00:35:22.901
And I'm sure, going forward,
it's gonna become

00:35:22.901 --> 00:35:24.901
even more and more powerful
and important.

00:35:24.901 --> 00:35:26.901
So let's talk quickly
about assets.

00:35:26.901 --> 00:35:29.901
One of the things that people
want to be able to do

00:35:29.901 --> 00:35:32.901
is pull resources and assets
out of their APK file.

00:35:32.901 --> 00:35:35.901
And I went to the Android team,
and I said, "All right,

00:35:35.901 --> 00:35:38.400
"there are many ways
we can do this.

00:35:38.400 --> 00:35:39.901
"What is the way

00:35:39.901 --> 00:35:42.901
that is most likely to still
be compatible in the future?"

00:35:42.901 --> 00:35:45.667
And they suggested
this method.

00:35:45.667 --> 00:35:48.667
So what we're going to do
is get our APK file name,

00:35:48.667 --> 00:35:51.567
uh, using this SourceDir.

00:35:51.567 --> 00:35:53.601
Then we're going to use
the AssetManager code.

00:35:53.601 --> 00:35:56.934
And that AssetManager code
allows us to get something

00:35:56.934 --> 00:35:58.934
called an AssetFileDescriptor.

00:35:58.934 --> 00:36:00.934
All an AssetFileDescriptor is

00:36:00.934 --> 00:36:02.934
is a standard
native file descriptor

00:36:02.934 --> 00:36:05.934
that includes extra parameters
for offsetting length.

00:36:05.934 --> 00:36:08.934
We can read them, open
the APK file from that offset,

00:36:08.934 --> 00:36:11.133
and there we are.

00:36:11.133 --> 00:36:14.067
We're reading our--our resources
right out of native code

00:36:14.067 --> 00:36:16.067
without any additional overhead,

00:36:16.067 --> 00:36:18.067
which--and the overhead
we're trying to avoid,

00:36:18.067 --> 00:36:20.067
of course,
is having to buffer things

00:36:20.067 --> 00:36:22.067
between Dalvik and native code.

00:36:22.067 --> 00:36:24.567
You can, of course,
use a native Zip Utility

00:36:24.567 --> 00:36:26.100
in a very similar way.

00:36:26.100 --> 00:36:28.400
It's a little--it's a little
less future-proof,

00:36:28.400 --> 00:36:30.400
but it's probably going to work
as well.

00:36:30.400 --> 00:36:32.400
Um, and it's probably
gonna be faster,

00:36:32.400 --> 00:36:35.400
as long as you do things
like cache the Zip directory.

00:36:35.400 --> 00:36:38.400
And then finally, of course,
you can use native AssetManager

00:36:38.400 --> 00:36:41.601
on Gingerbread and beyond.

00:36:41.601 --> 00:36:43.601
All right,
my tongue twister slide--

00:36:43.601 --> 00:36:45.601
"Troubleshooting, Tips,
and Tricks:

00:36:45.601 --> 00:36:48.367
Targeting tricky, trying tasks."

00:36:48.367 --> 00:36:50.367
So Threading, Dalvik,
and the NDK--

00:36:50.367 --> 00:36:52.701
all context are per-thread.

00:36:52.701 --> 00:36:54.701
You've got to be careful
to check your threading.

00:36:54.701 --> 00:36:56.701
If you take that same context

00:36:56.701 --> 00:36:58.701
and reuse it
across multiple threads,

00:36:58.701 --> 00:37:00.701
bad things will happen,
because the JNI context

00:37:00.701 --> 00:37:02.767
tries to do smart stuff
for you,

00:37:02.767 --> 00:37:05.267
like clean up objects
that you're not using anymore.

00:37:05.267 --> 00:37:08.167
So you want to use one
JNI context per thread,

00:37:08.167 --> 00:37:10.167
or you want to take advantage
of a game loop

00:37:10.167 --> 00:37:11.667
that actually takes
your messages,

00:37:11.667 --> 00:37:13.167
threads them
into another thread.

00:37:13.167 --> 00:37:15.334
It's also useful
if you're calling the framework,

00:37:15.334 --> 00:37:18.334
'cause many of the framework
classes don't like to be called

00:37:18.334 --> 00:37:20.667
from anything other
than the UI thread.

00:37:20.667 --> 00:37:23.501
As far as performance, you can
check for older hardware,

00:37:23.501 --> 00:37:25.501
and there's multiple ways
of doing that--

00:37:25.501 --> 00:37:28.501
checking for ARM7, checking
for support for OpenGL 2.

00:37:28.501 --> 00:37:30.501
And then you can use Fallbacks.

00:37:30.501 --> 00:37:32.501
You can use things
like 16-bit textures.

00:37:32.501 --> 00:37:34.501
Um, you can actually
convert them on the fly

00:37:34.501 --> 00:37:36.000
using BitmapFactory.

00:37:36.000 --> 00:37:38.000
You can also use
a smaller render target

00:37:38.000 --> 00:37:40.000
using
SurfaceHolder.setFixedSize.

00:37:40.000 --> 00:37:43.000
Of course, there are other ways
of doing that within OpenGL,

00:37:43.000 --> 00:37:45.000
but this actually does it
at the optimal place,

00:37:45.000 --> 00:37:46.667
which is at the compositor.

00:37:46.667 --> 00:37:48.334
Pixels are very, very expensive,

00:37:48.334 --> 00:37:50.667
especially on tablets,
so this really will help,

00:37:50.667 --> 00:37:53.167
but if all else fails,
we do have market filters,

00:37:53.167 --> 00:37:55.501
such as Device Availability,
which was announced today,

00:37:55.501 --> 00:37:58.434
platform release, GL version,
and instruction set.

00:37:58.434 --> 00:38:01.000
And you can--you can filter
on instruction set

00:38:01.000 --> 00:38:03.000
by only building a library

00:38:03.000 --> 00:38:05.667
for ARM5 or ARM7.

00:38:05.667 --> 00:38:07.667
And here are just general tips.

00:38:07.667 --> 00:38:10.734
Start small. Don't make me
download a big file.

00:38:10.734 --> 00:38:12.734
Use the backup/restore service,

00:38:12.734 --> 00:38:14.734
can support
multiple control schemes,

00:38:14.734 --> 00:38:16.734
install to SD--
I'm not gonna go through these,

00:38:16.734 --> 00:38:18.734
but you should all consider
these, things like profiling.

00:38:18.734 --> 00:38:21.367
You know, make the game
render up and do better stuff,

00:38:21.367 --> 00:38:23.868
if I--if it detects that
it's running on a cool system.

00:38:23.868 --> 00:38:26.200
Hooking into social networks
is, of course, really important

00:38:26.200 --> 00:38:28.701
for viral spreading
of your application.

00:38:28.701 --> 00:38:30.868
Building a live wallpaper
is so cool

00:38:30.868 --> 00:38:33.367
and so few applications do it.

00:38:33.367 --> 00:38:35.367
But, like, like,
isn't that awesome?

00:38:35.367 --> 00:38:37.367
You get to own
the user's home screen.

00:38:37.367 --> 00:38:39.701
I mean, what other platform
allows you to do that?

00:38:39.701 --> 00:38:41.200
That's so awesome.

00:38:41.200 --> 00:38:44.200
Um, analytics--definitely find
out where your customers are.

00:38:44.200 --> 00:38:47.167
Find out how
they're using your title.

00:38:47.167 --> 00:38:49.834
Like, this is awesome,
awesome information.

00:38:49.834 --> 00:38:52.667
Find out where--use--use it
to do things like finding out

00:38:52.667 --> 00:38:55.501
even where someone is dying
in the middle of your game.

00:38:55.501 --> 00:38:57.000
Like, you're like, "Hey,

00:38:57.000 --> 00:38:59.334
"that level's way harder
than I thought it should be.

00:38:59.334 --> 00:39:00.834
What's going on?"

00:39:00.834 --> 00:39:02.901
Or, "Only on this device people
are having problems."

00:39:02.901 --> 00:39:04.901
All that kind of stuff
you can find out.

00:39:04.901 --> 00:39:06.901
And, of course, In-app payments,
we went through that

00:39:06.901 --> 00:39:08.901
in the last presentation
I just did.

00:39:08.901 --> 00:39:10.901
We are now seeing amazing
traction in app payments.

00:39:10.901 --> 00:39:12.734
If you look, we just added

00:39:12.734 --> 00:39:14.734
a new category in Market
for top-grossing applications

00:39:14.734 --> 00:39:16.734
and three out of the top five

00:39:16.734 --> 00:39:19.234
are top-grossing
only through In-app payments.

00:39:19.234 --> 00:39:23.133
So some tools--I'm gonna throw
these up here very quickly

00:39:23.133 --> 00:39:26.133
so that when this slide--
when this is played back

00:39:26.133 --> 00:39:29.133
and put on--on, uh, on the web,
you'll be able to get these,

00:39:29.133 --> 00:39:32.133
but this is some of the stuff
we've talked about,

00:39:32.133 --> 00:39:34.634
and, of course, we have
some performance tools.

00:39:34.634 --> 00:39:36.634
Each one of the chips
at manufacturers

00:39:36.634 --> 00:39:38.634
has now come out
with performance tools,

00:39:38.634 --> 00:39:40.133
and they can be very useful.

00:39:40.133 --> 00:39:41.934
Some of them require
a routed device.

00:39:41.934 --> 00:39:45.634
Now we've got a very short
period of time for Q&amp;A.

00:39:45.634 --> 00:39:48.000
So, uh, I went through those
a little fast at the end,

00:39:48.000 --> 00:39:50.501
so if you have a question, this
is the time to stop me on it.

00:39:50.501 --> 00:39:52.501
And, uh, thank you very much.

00:39:52.501 --> 00:39:55.434
[applause]

00:39:57.934 --> 00:39:59.934
Galpin:
And I recommend everyone

00:39:59.934 --> 00:40:01.601
stay around in the room
after this,

00:40:01.601 --> 00:40:04.601
because, um, there's gonna
be something special

00:40:04.601 --> 00:40:09.400
for all of you, so...
[chuckles]

00:40:09.400 --> 00:40:11.367
Free cake?
That sounds good to me.

00:40:11.367 --> 00:40:13.367
All right, next.

00:40:13.367 --> 00:40:16.367
man: Hi, uh, I work on
the open source port of Freeciv,

00:40:16.367 --> 00:40:18.501
if I can just give
a quick shout-out.

00:40:18.501 --> 00:40:20.534
Galpin: Awesome.
man: So it's--it's open source.

00:40:20.534 --> 00:40:23.501
It's, I think, one
of the largest NDK applications

00:40:23.501 --> 00:40:25.501
you can--you can freely
get the source to.

00:40:25.501 --> 00:40:28.501
Um, there's a lot
of terrible ideas in there,

00:40:28.501 --> 00:40:31.067
but hopefully, there's one
or two, uh, good ones.

00:40:31.067 --> 00:40:33.467
Galpin: Cool.
man: Uh, I had a quick question.

00:40:33.467 --> 00:40:36.033
It was something I'd seen
when--when loading a resource.

00:40:36.033 --> 00:40:38.367
One--one of the goals
of that project was to be able

00:40:38.367 --> 00:40:41.367
to drop my app, even let it
be killed and have it, like,

00:40:41.367 --> 00:40:44.000
spring back as quickly as
possible to where you left off.

00:40:44.000 --> 00:40:45.567
Galpin: Right.
man: And so I spent

00:40:45.567 --> 00:40:47.567
a lot of time optimizing
how I loaded my art assets.

00:40:47.567 --> 00:40:49.067
Galpin: Mm-hmm.

00:40:49.067 --> 00:40:51.067
man: I found something
really counterintuitive.

00:40:51.067 --> 00:40:54.067
It seems JPEGs load about
three times faster than PNGs.

00:40:54.067 --> 00:40:57.067
Is that, um... sensible?
Galpin: Is that--

00:40:57.067 --> 00:40:59.067
Is that based on the file size?
'Cause--

00:40:59.067 --> 00:41:02.067
man: Uh, it--what I found
was when benchmarking this

00:41:02.067 --> 00:41:04.200
on a Samsung tab...
Galpin: Mm-hmm.

00:41:04.200 --> 00:41:07.634
man: was only about
1 millisecond per--per file

00:41:07.634 --> 00:41:10.300
was taken up in file I/O.
Galpin: Mm-hmm. Mm-hmm.

00:41:10.300 --> 00:41:12.300
man: And that was effectively
the same

00:41:12.300 --> 00:41:14.300
whether PNG or JPEG.

00:41:14.300 --> 00:41:16.300
Definitely the PNGs were larger.
Galpin: Hmm.

00:41:16.300 --> 00:41:18.300
man: The JPEGs were smaller.

00:41:18.300 --> 00:41:20.300
It was the actual--apparently,
it was the actual time

00:41:20.300 --> 00:41:22.868
spent, like, converting
from the compressed stream

00:41:22.868 --> 00:41:24.701
into a bitmap.

00:41:24.701 --> 00:41:26.701
Galpin: Hmm. Interesting.
I-I haven't experienced that.

00:41:26.701 --> 00:41:28.200
But, you know, I-I--

00:41:28.200 --> 00:41:30.200
Ni-Lewis: PNGs aren't on
the no-compress list, are they?

00:41:30.200 --> 00:41:32.033
Galpin: No. Yeah, they're--
they're both--they're both

00:41:32.033 --> 00:41:34.033
on the no-compress list, yeah.
Ni-Lewis: Okay, I thought so.

00:41:34.033 --> 00:41:35.701
Galpin: So that's--
the only thing

00:41:35.701 --> 00:41:37.701
that would cause that normally
is that--is that, you know,

00:41:37.701 --> 00:41:39.534
in the zip file, uh, you know,
things,resources

00:41:39.534 --> 00:41:41.033
can be compressed,
but both of those files

00:41:41.033 --> 00:41:42.601
are automatically
not compressed.

00:41:42.601 --> 00:41:44.601
I'm--I'm obviously pretty
surprised you're seeing that.

00:41:44.601 --> 00:41:46.601
But I-I--you know, I don't
actually know the answer.

00:41:46.601 --> 00:41:48.601
That's a cool thing to note.
man: Yeah, and--

00:41:48.601 --> 00:41:50.601
Shift--even shifting
that around, it didn't, like,

00:41:50.601 --> 00:41:52.267
if--if I was on the SD card,
the only thing

00:41:52.267 --> 00:41:54.267
is if it was on the SD card,
it would seem to take

00:41:54.267 --> 00:41:56.100
about twice as long
as if it was on flash memory.

00:41:56.100 --> 00:41:58.100
Galpin: Yeah, see, that--that
would--that would really make me

00:41:58.100 --> 00:42:00.133
think that it actually
was, on some level, file I/O.

00:42:00.133 --> 00:42:02.167
man: Yeah.
Galpin: It might be even, uh,

00:42:02.167 --> 00:42:04.167
just--just because,
uh, uh, that would be my first--

00:42:04.167 --> 00:42:06.501
my first guess is it's entirely
I/O bound, but, um--

00:42:06.501 --> 00:42:08.934
man: Right. But, uh, three
times, and I mean, you know,

00:42:08.934 --> 00:42:10.934
these weren't very large files.
Galpin: Yeah.

00:42:10.934 --> 00:42:13.334
man: I mean, it was--it--
I don't know.

00:42:13.334 --> 00:42:16.000
And it could also be--I know
that it's the OMAP platform

00:42:16.000 --> 00:42:18.000
and they have
optimized JPEG decoder,

00:42:18.000 --> 00:42:20.601
so maybe out floating
some of that to a DSP.

00:42:20.601 --> 00:42:22.601
Galpin: I don't think so,
but that's, uh, that's it.

00:42:22.601 --> 00:42:24.601
I think--I think it's--
Ni-Lewis: And it could be,

00:42:24.601 --> 00:42:26.601
you know, loading it through
and optimizing code paths.

00:42:26.601 --> 00:42:28.601
There are two different
code paths for it, but I-I--

00:42:28.601 --> 00:42:30.934
Galpin: It could be loading it
through--yeah.

00:42:30.934 --> 00:42:33.100
man: Oh. Yeah, I did actually
try compiling the libJPEG

00:42:33.100 --> 00:42:37.067
and using, like, instead
of loading it from, um, Java,

00:42:37.067 --> 00:42:39.067
pushing it into a texture,
and then pulling it up

00:42:39.067 --> 00:42:40.734
through there.
Galpin: Yeah.

00:42:40.734 --> 00:42:42.434
man: I-I tried
the libJPEG thing

00:42:42.434 --> 00:42:44.334
and--and it even seemed
like using just

00:42:44.334 --> 00:42:48.100
a bog standard compiled libJPEG
performed better than PNG,

00:42:48.100 --> 00:42:51.100
but performed worse than--than
pulling it up through Java.

00:42:51.100 --> 00:42:53.100
Galpin: Oh, interesting. Cool.
man: All right, well, thank you.

00:42:53.100 --> 00:42:55.100
Galpin: No, that's interesting.
That's good to know.

00:42:55.100 --> 00:42:57.100
Ni-Lewis: It's a mystery.
Galpin: It is.

00:42:57.100 --> 00:42:59.167
man: Um, so question--

00:42:59.167 --> 00:43:02.567
Uh, I have downloaded NDK
using the JNI,

00:43:02.567 --> 00:43:05.567
but I find out that debugging
is extremely difficult.

00:43:05.567 --> 00:43:08.901
So I saw that we can do
the complete,

00:43:08.901 --> 00:43:13.434
uh, Android application
in C and C++ only,

00:43:13.434 --> 00:43:15.434
without using Java.

00:43:15.434 --> 00:43:18.434
Uh, so that makes the debugging
much easier.

00:43:18.434 --> 00:43:21.434
Can you show me, uh,
some way in the future

00:43:21.434 --> 00:43:25.033
we can support only C and C++
for entry application?

00:43:25.033 --> 00:43:27.200
Ni-Lewis: Ging--
with Gingerbread,

00:43:27.200 --> 00:43:28.701
you can support that,

00:43:28.701 --> 00:43:32.033
but let me sort of lay things
on the line for you.

00:43:32.033 --> 00:43:35.167
The, um, the debugger
for C and C++

00:43:35.167 --> 00:43:38.167
is, uh, honestly,
a little flaky.

00:43:38.167 --> 00:43:41.601
Um, every single version
gets so much better,

00:43:41.601 --> 00:43:43.934
it's just amazing.
man: Mm-hmm.

00:43:43.934 --> 00:43:45.934
Ni-Lewis: Um, but it
also depends a lot

00:43:45.934 --> 00:43:47.934
on what you're using with it.

00:43:47.934 --> 00:43:51.601
Um, so for instance, were--
were you using, like, stock GDB,

00:43:51.601 --> 00:43:54.601
or were you using Eclipse or...

00:43:54.601 --> 00:43:57.701
man: Uh, many use,
uh, Eclipse, yes.

00:43:57.701 --> 00:44:00.200
Ni-Lewis: Okay, so right now,

00:44:00.200 --> 00:44:03.067
um, if you--if you use Eclipse,

00:44:03.067 --> 00:44:05.567
and you either--there's--
there's instructions

00:44:05.567 --> 00:44:08.567
on the internet for how to get
it to work with--with any GDB,

00:44:08.567 --> 00:44:11.901
or you can also, um, use
NVIDIA's plug-in for Eclipse.

00:44:11.901 --> 00:44:13.934
It sets up the debugger for you.

00:44:13.934 --> 00:44:15.901
The--the--the only disadvantage
to that

00:44:15.901 --> 00:44:18.234
is your device has to be rooted,
uh, right now.

00:44:18.234 --> 00:44:20.601
Um, hopefully, they'll fix that.

00:44:20.601 --> 00:44:23.667
Um, then actually, it's--
it's fairly easy to debug.

00:44:23.667 --> 00:44:27.667
You can bounce back and forth
between Java and, uh, JNI,

00:44:27.667 --> 00:44:29.834
right--oh, and your--
and your C++.

00:44:29.834 --> 00:44:31.834
Galpin: Yeah, there's--there's
no--well, I was gonna say

00:44:31.834 --> 00:44:33.834
the main answer is that
there's really no reason

00:44:33.834 --> 00:44:35.334
why--why you can't debug
native code

00:44:35.334 --> 00:44:37.000
that's being called
from--from JNI.

00:44:37.000 --> 00:44:39.000
It actually works--it works,
as far as I can tell,

00:44:39.000 --> 00:44:40.801
just as well as--
as fully native code.

00:44:40.801 --> 00:44:42.801
Ni-Lewis: Yeah,
and--and the bad news is

00:44:42.801 --> 00:44:44.934
going to full-on C++
would not help anything,

00:44:44.934 --> 00:44:47.534
because it's not the--it's not
bouncing back and forth

00:44:47.534 --> 00:44:49.667
between Java and C
that's the problem.

00:44:49.667 --> 00:44:53.300
It's just the debug layer,
and C is--is a little flaky

00:44:53.300 --> 00:44:55.300
with Eclipse.

00:44:55.300 --> 00:44:57.300
man: Okay, thank you.
Galpin: Mm-hmm?

00:44:57.300 --> 00:44:59.634
man: Uh, I have a question
regarding Google TV

00:44:59.634 --> 00:45:01.367
in the NDK.
Galpin: Mm-hmm.

00:45:01.367 --> 00:45:04.434
man: And that, uh, after talking
to the Google TV guys,

00:45:04.434 --> 00:45:06.801
the NDK is not supported for,
uh, Google TV.

00:45:06.801 --> 00:45:08.434
Galpin: Mm-hmm.
man: Is that ever going

00:45:08.434 --> 00:45:10.434
to change and...
Galpin: I think that's kind of--

00:45:10.434 --> 00:45:12.434
I think that's kind of up
to the Google TV team.

00:45:12.434 --> 00:45:14.067
Um, as--
as a C and C++ developer,

00:45:14.067 --> 00:45:16.067
I would love it to change,
but, uh, but that's--

00:45:16.067 --> 00:45:17.934
that's--that's up to them.

00:45:17.934 --> 00:45:20.100
Ni-Lewis: Yeah, actually,
you're not the first person

00:45:20.100 --> 00:45:21.934
to answer--to ask this question.

00:45:21.934 --> 00:45:24.934
Um, and I've worked closely
with the--the Google TV team.

00:45:24.934 --> 00:45:27.434
They--basically, they're not
making any announcements.

00:45:27.434 --> 00:45:29.801
Um, they haven't ruled it out
one way or the other.

00:45:29.801 --> 00:45:33.167
Um, but they--they have said
on many occasions

00:45:33.167 --> 00:45:34.667
that they understand

00:45:34.667 --> 00:45:37.000
that it's a-a desire
that a lot of people have.

00:45:37.000 --> 00:45:39.000
man: Yeah,
especially with regard

00:45:39.000 --> 00:45:41.000
to, uh, some sort of, like,

00:45:41.000 --> 00:45:44.033
Xbox live arcade style gameplay.

00:45:44.033 --> 00:45:47.033
Galpin: Absolutely. No, it's
totally--I'm there with you.

00:45:47.033 --> 00:45:49.033
Ni-Lewis: We--we think
that would be cool, too.

00:45:49.033 --> 00:45:50.901
man: So--so with each version,

00:45:50.901 --> 00:45:52.901
indicates you guys
are really progressing...

00:45:52.901 --> 00:45:56.334
[speaking indistinctly]

00:45:56.334 --> 00:45:59.033
so good direction.

00:45:59.033 --> 00:46:02.100
But the question is about
accessing the MediaPlayer,

00:46:02.100 --> 00:46:04.501
the video player back, actually,
from native code, so...

00:46:04.501 --> 00:46:06.501
Galpin: Yeah, so--so right now,

00:46:06.501 --> 00:46:08.834
there's--there's no way
to do it, uh, directly.

00:46:08.834 --> 00:46:10.501
Um, I'd love to see that change,

00:46:10.501 --> 00:46:12.501
but, uh, that's still the way
things are,

00:46:12.501 --> 00:46:14.067
so you still have to go back

00:46:14.067 --> 00:46:17.734
and bounce back into,
uh, into Dalvik to do that.

00:46:17.734 --> 00:46:19.934
man: But that's on
your road map, right?

00:46:19.934 --> 00:46:21.501
Galpin: [laughs]
man: [laughs]

00:46:21.501 --> 00:46:23.501
Galpin: I would really like it
to happen.

00:46:23.501 --> 00:46:25.901
man: [chuckles]

00:46:25.901 --> 00:46:27.934
man: Uh, first of all,
let me say thank you

00:46:27.934 --> 00:46:29.734
for multithreaded GDB
and Gingerbread.

00:46:29.734 --> 00:46:31.734
Uh, other--before,
it was just a pain

00:46:31.734 --> 00:46:33.534
having to call things
on the main thread.

00:46:33.534 --> 00:46:35.534
Galpin: Yeah.
man: Um, I actually, um--

00:46:35.534 --> 00:46:37.200
Galpin: Thank David--
thank David Turner

00:46:37.200 --> 00:46:38.801
and the--and the--and the Dalvik

00:46:38.801 --> 00:46:40.801
and the--and the Android,
uh, Kernel team, actually.

00:46:40.801 --> 00:46:42.801
They made that happen.
They're both awesome.

00:46:42.801 --> 00:46:44.801
man: I actually don't
work on games, but I imported

00:46:44.801 --> 00:46:46.801
an extremely large
engineering app from C++,

00:46:46.801 --> 00:46:50.501
um, and we needed, um, we were
using the CrystaX before,

00:46:50.501 --> 00:46:52.501
because we needed wide string.
Galpin: Yeah.

00:46:52.501 --> 00:46:54.067
man: And we needed,
like, a full SDL,

00:46:54.067 --> 00:46:56.067
but for Gingerbread,
we've actually switched now

00:46:56.067 --> 00:46:58.067
to using new--the SDL,
but the problem is,

00:46:58.067 --> 00:47:02.567
the, um, the one that's part
of the NDK5

00:47:02.567 --> 00:47:05.434
doesn't export any of
the actually wstring functions.

00:47:05.434 --> 00:47:08.767
Um, if you--it builds,
but it doesn't link to wstring.

00:47:08.767 --> 00:47:11.901
Uh, and I tried
really, really hard,

00:47:11.901 --> 00:47:14.400
and I looked around,
and eventually, what I had to do

00:47:14.400 --> 00:47:16.400
was I had to download
the NDK source code

00:47:16.400 --> 00:47:18.901
and change the build scripts
to get wstring to export,

00:47:18.901 --> 00:47:20.901
and it's like
a meg and a half bigger,

00:47:20.901 --> 00:47:23.400
and it's fine, um, but actually,
my question is this...

00:47:23.400 --> 00:47:25.400
Galpin: Yeah.
man: Um, so I changed that.

00:47:25.400 --> 00:47:27.901
Do I have maybe--I may need
to ask a lawyer this,

00:47:27.901 --> 00:47:29.901
but do I have, like,
an affirmative GPL obligation?

00:47:29.901 --> 00:47:31.901
'Cause I only changed
the build scripts.

00:47:31.901 --> 00:47:34.901
I didn't change GCC, but I'm
using my own version, I guess,

00:47:34.901 --> 00:47:37.901
now of the NDK, not the source--
not the one that was...

00:47:37.901 --> 00:47:40.901
Galpin: Well, all of, I mean,
I'm--I'm not an attorney.

00:47:40.901 --> 00:47:42.901
man: Yeah.
Galpin: But my understanding

00:47:42.901 --> 00:47:44.901
is all of Android is licensed
under a, uh, license

00:47:44.901 --> 00:47:46.901
that doesn't force you
to contribute your changes

00:47:46.901 --> 00:47:48.901
to all of--all of--
man: Well, 'cause I didn't know

00:47:48.901 --> 00:47:50.901
if GCC--yeah.
Galpin: Yeah, if you're using

00:47:50.901 --> 00:47:52.901
a GCC stuff, you know,
it's interesting.

00:47:52.901 --> 00:47:54.901
I don't actually know
what the answer is--on that.

00:47:54.901 --> 00:47:56.901
But I'm surprised the wide
string stuff isn't working.

00:47:56.901 --> 00:47:58.901
You should file that as a bug,
because I just spoke to it.

00:47:58.901 --> 00:48:00.467
man: Okay.
Galpin: So that was one--

00:48:00.467 --> 00:48:02.133
that was one
of the desired changes.

00:48:02.133 --> 00:48:04.133
Ni-Lewis: That--yeah, well, we--
I talked to David about that.

00:48:04.133 --> 00:48:05.734
Galpin: Yeah.
Ni-Lewis: Yeah, I think--

00:48:05.734 --> 00:48:08.801
now he said that he actually
couldn't get the command line,

00:48:08.801 --> 00:48:11.801
that there were like two
mutually exclusive options

00:48:11.801 --> 00:48:13.400
where wide string didn't work.
Galpin: Yeah.

00:48:13.400 --> 00:48:15.067
man: Uh-huh, there are,
and I actually had

00:48:15.067 --> 00:48:17.067
to HardCode one of them.
They're like boolean opposites.

00:48:17.067 --> 00:48:18.567
Galpin: Yeah.
Ni-Lewis: Okay.

00:48:18.567 --> 00:48:20.567
man: And I went into one
of the makefiles, and I figured,

00:48:20.567 --> 00:48:22.567
yeah, and I basically
had to manually override it.

00:48:22.567 --> 00:48:24.067
Galpin: Right.
Ni-Lewis: And this

00:48:24.067 --> 00:48:25.934
is really good--
this is one of the things

00:48:25.934 --> 00:48:27.934
that you should speak up, uh, on
the forums or e-mail us about.

00:48:27.934 --> 00:48:29.434
man: Okay.
Galpin: Yeah.

00:48:29.434 --> 00:48:31.067
Ni-Lewis: Because--because
as you can see--

00:48:31.067 --> 00:48:33.801
so really difficult build,
uh, solution that ends up

00:48:33.801 --> 00:48:35.801
making your code
a mega and a half bigger.

00:48:35.801 --> 00:48:37.267
Galpin: Yeah.
man: Mm-hmm.

00:48:37.267 --> 00:48:39.267
Ni-Lewis: And maybe isn't all
that desirable by most people.

00:48:39.267 --> 00:48:40.968
man: Yeah.
Ni-Lewis: You know, you can

00:48:40.968 --> 00:48:42.434
probably see why that choice
was made.

00:48:42.434 --> 00:48:44.434
man: Yeah, absolutely.
Ni-Lewis: But if we've got more

00:48:44.434 --> 00:48:46.000
feedback about that,
more data points, you know,

00:48:46.000 --> 00:48:48.000
that might be something we want
to do--support in the future.

00:48:48.000 --> 00:48:49.667
Galpin: Yeah, absolutely.
man: Thanks.

00:48:49.667 --> 00:48:51.267
man: Okay, quick one.
Galpin: Mm-hmm.

00:48:51.267 --> 00:48:53.267
man: Uh, any plans to access
the camera API through the--

00:48:53.267 --> 00:48:55.267
through native code?
Galpin: [sighs] Yeah,

00:48:55.267 --> 00:48:57.267
it would be--it's another--
it's another "nice to have."

00:48:57.267 --> 00:48:59.000
I think, you know,
I think ultimately, here's--

00:48:59.000 --> 00:49:00.501
here's the issue.

00:49:00.501 --> 00:49:02.567
I mean, the--the general--
the general thought

00:49:02.567 --> 00:49:05.567
is if there isn't a
strong performance reason,

00:49:05.567 --> 00:49:09.200
for the most part, um, you know,
the--the goal is to make it

00:49:09.200 --> 00:49:12.200
something that you have to get
through, uh, through Dalvik,

00:49:12.200 --> 00:49:14.200
because that is the primary--

00:49:14.200 --> 00:49:16.200
the primary platform
for development for Android.

00:49:16.200 --> 00:49:18.200
That being said,
there's a lot of people

00:49:18.200 --> 00:49:20.534
who want to do really cool stuff
with the camera that,

00:49:20.534 --> 00:49:23.200
if you had a native interface,
you could do it a lot better.

00:49:23.200 --> 00:49:25.200
So I-I think that's--I think
that's an important one

00:49:25.200 --> 00:49:27.200
to--to bring up, and--and again,
keep requesting it.

00:49:27.200 --> 00:49:29.200
Keep complaining about it.
Hopefully, it will happen.

00:49:29.200 --> 00:49:33.067
man: Thank you.

00:49:33.067 --> 00:49:35.067
Galpin: All right,
so that being said,

00:49:35.067 --> 00:49:37.567
uh, I'd like to, uh,
to mention,

00:49:37.567 --> 00:49:40.501
uh, that, uh,
how many of you guys here

00:49:40.501 --> 00:49:44.033
are game developers
or want to be game developers?

00:49:44.033 --> 00:49:46.033
Okay, well...

00:49:46.033 --> 00:49:48.067
Ni-Lewis: Everybody wants
to be a game developer.

00:49:48.067 --> 00:49:50.033
Galpin: Uh, well, yeah. Well,
you know, it's--it's--it's--

00:49:50.033 --> 00:49:51.534
it's a tough job.

00:49:51.534 --> 00:49:53.534
Um, so we have something
very special for you.

00:49:53.534 --> 00:49:56.000
We've, uh,
Sony Ericsson has come today,

00:49:56.000 --> 00:49:59.234
and, uh, they are here

00:49:59.234 --> 00:50:02.200
to make sure
that every one of you

00:50:02.200 --> 00:50:05.701
has the ability to develop
really, really great games.

00:50:05.701 --> 00:50:10.501
And so they want you to have
a device

00:50:10.501 --> 00:50:13.801
that has support
for a modern GPU,

00:50:13.801 --> 00:50:15.801
has the support
for a lot of different controls.

00:50:15.801 --> 00:50:18.000
They want to see what you can do
with it.

00:50:18.000 --> 00:50:20.033
So, without further ado,
on your way out,

00:50:20.033 --> 00:50:22.133
you will be getting a card,

00:50:22.133 --> 00:50:24.133
and you will be able
to exchange that card

00:50:24.133 --> 00:50:26.133
for your own--very own
Xperia PLAY.

00:50:26.133 --> 00:50:29.067
[cheers and applause]

00:50:34.000 --> 00:50:36.467
Galpin: So...

00:50:36.467 --> 00:50:38.467
our--our only ask,

00:50:38.467 --> 00:50:40.467
and it's that
we want to make sure

00:50:40.467 --> 00:50:42.467
you guys do really,
really cool stuff with it.

00:50:42.467 --> 00:50:44.000
If you do,

00:50:44.000 --> 00:50:46.000
uh, and you're gonna want to go
a couple things--

00:50:46.000 --> 00:50:48.067
one is you're gonna want to go
to sonyericsson.com/developer,

00:50:48.067 --> 00:50:50.067
and--and they've written
a lot of articles about

00:50:50.067 --> 00:50:52.400
how to get to the special
features of that device.

00:50:52.400 --> 00:50:54.434
The second thing
you're gonna want to do is,

00:50:54.434 --> 00:50:57.501
if you do something cool,
go to standout.sonyericsson.com,

00:50:57.501 --> 00:50:59.801
and let them know
that you've done something cool,

00:50:59.801 --> 00:51:01.534
because they're always looking
for people

00:51:01.534 --> 00:51:04.234
who are doing cool stuff
with the Xperia PLAY.

00:51:04.234 --> 00:51:06.234
So, uh, with that,
I hope you all enjoy it,

00:51:06.234 --> 00:51:07.734
and I'm very excited

00:51:07.734 --> 00:51:09.567
and a little jealous
for you all.

00:51:09.567 --> 00:51:12.901
And, uh,
and there we have it.

00:51:12.901 --> 00:51:14.901
Ni-Lewis: Thank you.
[cheers and applause]

00:51:14.901 --> 00:51:16.834
Galpin: Thank you.

