WEBVTT
Kind: captions
Language: en

00:00:01.934 --> 00:00:03.234
Ager: So my name
is Mads Ager.

00:00:03.234 --> 00:00:05.167
I'm a software engineer
at Google.

00:00:05.167 --> 00:00:08.033
And I work
on the V8 JavaScript engine.

00:00:08.033 --> 00:00:12.434
And this talk is going
to be about the internals of V8.

00:00:12.434 --> 00:00:16.167
So what did we do,
uh, to make V8 fast

00:00:16.167 --> 00:00:20.601
and what were our design,
uh, decisions when making V8?

00:00:20.601 --> 00:00:22.267
So here's the agenda
of the talk.

00:00:22.267 --> 00:00:26.934
So the main part of the talk
will be about the design goals

00:00:26.934 --> 00:00:30.534
and the overall goals
that we had for V8.

00:00:30.534 --> 00:00:32.834
And, um, the internals.

00:00:32.834 --> 00:00:34.467
So what did we actually do?

00:00:34.467 --> 00:00:38.901
Uh, what are the techniques
that we used to make V8 fast?

00:00:40.534 --> 00:00:44.234
Um, and that involves
things like hidden classes,

00:00:44.234 --> 00:00:48.367
uh, native code generation
using inline caching,

00:00:48.367 --> 00:00:50.968
and precise generational
garbage collection.

00:00:50.968 --> 00:00:52.868
So that'll be the main part
of the talk

00:00:52.868 --> 00:00:55.133
where I explain
these--these things.

00:00:55.133 --> 00:00:57.767
So, um, after that,
I'll tell you something

00:00:57.767 --> 00:01:00.367
about a couple of recent
developments in V8.

00:01:00.367 --> 00:01:02.033
So the first one
is that we implemented

00:01:02.033 --> 00:01:04.234
a new JavaScript regular
expression engine

00:01:04.234 --> 00:01:05.834
completely from scratch.

00:01:05.834 --> 00:01:07.300
And the other one
is that we've built

00:01:07.300 --> 00:01:08.601
a new compile
infrastructure.

00:01:08.601 --> 00:01:10.067
I'm just going
to briefly mention those

00:01:10.067 --> 00:01:11.801
and tell you a bit
about them.

00:01:11.801 --> 00:01:13.467
Um, and then I'll go
into something

00:01:13.467 --> 00:01:16.534
that, um, I think
is really important.

00:01:16.534 --> 00:01:19.567
Uh, and I've called it
object heap scalability here.

00:01:19.567 --> 00:01:21.367
Or JavaScript scalability.

00:01:21.367 --> 00:01:24.501
And that's all about how well
your JavaScript engine deals

00:01:24.501 --> 00:01:27.067
with running really,
really big web applications

00:01:27.067 --> 00:01:29.067
where you have
a lot of objects.

00:01:29.067 --> 00:01:31.601
Uh, and therefore,
extra pressure

00:01:31.601 --> 00:01:33.701
on your memory management
system.

00:01:33.701 --> 00:01:35.300
Um, and I think that
this is really important.

00:01:35.300 --> 00:01:38.934
And I think that it has been
underemphasized so far.

00:01:38.934 --> 00:01:41.434
Um, so I'm going to spend
a bit of time

00:01:41.434 --> 00:01:42.801
talking about that.

00:01:42.801 --> 00:01:44.300
And then at the end,
I'm going to just,

00:01:44.300 --> 00:01:48.000
uh, tell you a bit about some
of the performance bottlenecks

00:01:48.000 --> 00:01:51.167
that we have in V8 right now,
uh, which will give you

00:01:51.167 --> 00:01:53.567
sort of an indication
of the kind of things

00:01:53.567 --> 00:01:56.100
that we like to, uh,
to work on in V8

00:01:56.100 --> 00:02:00.133
to make it even faster.

00:02:00.133 --> 00:02:01.801
Okay, so for this talk,

00:02:01.801 --> 00:02:04.868
the first question is really
why did Google want

00:02:04.868 --> 00:02:08.067
to build a new JavaScript
engine?

00:02:08.067 --> 00:02:10.067
And the answer
is pretty simple.

00:02:10.067 --> 00:02:12.534
So we believe that

00:02:12.534 --> 00:02:15.000
in order
to build, uh, the next wave

00:02:15.000 --> 00:02:18.000
of big,
uh, web applications,

00:02:18.000 --> 00:02:21.000
you need better JavaScript
performance.

00:02:21.000 --> 00:02:24.834
Um, and at the time
when the V8 project started,

00:02:24.834 --> 00:02:26.634
the existing
JavaScript engines

00:02:26.634 --> 00:02:28.901
were not very fast.

00:02:28.901 --> 00:02:31.400
So basically
they were all interpreters

00:02:31.400 --> 00:02:34.968
working on abstract syntax trees
or on bytecodes.

00:02:34.968 --> 00:02:38.567
And they had, uh, poor memory
management systems,

00:02:38.567 --> 00:02:41.000
which led
to big pause times,

00:02:41.000 --> 00:02:44.467
um, and maybe even,
uh, memory leaks.

00:02:44.467 --> 00:02:47.801
Um, so we wanted
to try to change this picture.

00:02:47.801 --> 00:02:52.000
We wanted to try to push,
uh, JavaScript performance.

00:02:52.000 --> 00:02:53.934
Uh, and we thought that
the best way to do that

00:02:53.934 --> 00:02:55.968
was to build a completely
new JavaScript engine

00:02:55.968 --> 00:02:58.801
from scratch so that we could do
our own designs

00:02:58.801 --> 00:03:01.868
and start completely
from scratch.

00:03:01.868 --> 00:03:05.100
Um, so the overall goal
for V8

00:03:05.100 --> 00:03:07.567
is to push the performance bar
for JavaScript.

00:03:07.567 --> 00:03:10.434
Not only for Google Chrome
and for V8,

00:03:10.434 --> 00:03:13.033
but we wanted to kind of try
to push the industry

00:03:13.033 --> 00:03:16.334
and see if we can get, uh,
better JavaScript performance

00:03:16.334 --> 00:03:17.834
in browsers in general,

00:03:17.834 --> 00:03:19.334
which will benefit
all of us.

00:03:19.334 --> 00:03:21.133
It'll benefit Google
because we can do better

00:03:21.133 --> 00:03:22.467
web applications.

00:03:22.467 --> 00:03:23.968
And it'll benefit
the users as well

00:03:23.968 --> 00:03:27.834
because, well, users like
web applications as well.

00:03:30.501 --> 00:03:34.634
So we wanted to build
a really fast JavaScript engine.

00:03:34.634 --> 00:03:37.501
So why is that a challenge?

00:03:37.501 --> 00:03:41.701
Well, JavaScript is a very,
very dynamic language.

00:03:41.701 --> 00:03:44.734
So objects are basically
just HashMaps.

00:03:44.734 --> 00:03:47.901
So you can add and remove
properties,

00:03:47.901 --> 00:03:51.400
um, to and from objects
on the fly

00:03:51.400 --> 00:03:52.901
in any order you like.

00:03:52.901 --> 00:03:55.000
And you have,
uh, no type structure.

00:03:55.000 --> 00:03:58.067
So if you want to do,
uh, a property lookup

00:03:58.067 --> 00:04:00.200
on an object in JavaScript,

00:04:00.200 --> 00:04:03.167
you don't know anything
statically about the object.

00:04:03.167 --> 00:04:04.400
So if you have an object,

00:04:04.400 --> 00:04:06.267
you want to search
for the X-property,

00:04:06.267 --> 00:04:07.267
you have to do exactly that.

00:04:07.267 --> 00:04:08.601
You have to search.

00:04:08.601 --> 00:04:10.100
So you have to look
in your HashMap.

00:04:10.100 --> 00:04:11.400
If it's not there,

00:04:11.400 --> 00:04:13.634
you need to traverse
the prototype chain

00:04:13.634 --> 00:04:14.667
and look for it there.

00:04:14.667 --> 00:04:16.033
And that's, like,
really slow.

00:04:16.033 --> 00:04:17.934
So if you compare that
to static,

00:04:17.934 --> 00:04:19.868
object-oriented languages

00:04:19.868 --> 00:04:23.467
where you have a notion of type,
where you have classes,

00:04:23.467 --> 00:04:25.667
if you do a property load
in a language

00:04:25.667 --> 00:04:28.100
where you have a notion
of class,

00:04:28.100 --> 00:04:31.667
well, then the class tells you
the layout of your object.

00:04:31.667 --> 00:04:34.067
So if you want to access
an X-property

00:04:34.067 --> 00:04:36.067
on an object
that has a certain class,

00:04:36.067 --> 00:04:38.334
then the class tells you
the index

00:04:38.334 --> 00:04:40.934
in your object
for that property.

00:04:40.934 --> 00:04:42.968
So you can generate
just a few assembly line--

00:04:42.968 --> 00:04:47.133
assembly instructions
that will load your property.

00:04:47.133 --> 00:04:51.734
In JavaScript, if you just
do it, uh, like naively--

00:04:51.734 --> 00:04:54.334
implement JavaScript--
then you'll have a full search

00:04:54.334 --> 00:04:57.467
of--of a number
of HashMaps in a chain.

00:04:57.467 --> 00:04:59.534
And that's really slow.

00:04:59.534 --> 00:05:03.934
Um, right, so JavaScript
is highly dynamic.

00:05:03.934 --> 00:05:06.033
You can add properties
to objects.

00:05:06.033 --> 00:05:08.300
You can remove properties
from objects.

00:05:08.300 --> 00:05:11.934
Um, and, uh,
you can actually change

00:05:11.934 --> 00:05:15.634
prototype chains
as well dynamically.

00:05:15.634 --> 00:05:17.267
So you can change basically
everything,

00:05:17.267 --> 00:05:19.467
uh, in your program
on the fly.

00:05:19.467 --> 00:05:22.801
Also, JavaScript has a couple
of language features,

00:05:22.801 --> 00:05:27.834
um, that--that could
give you trouble as well.

00:05:27.834 --> 00:05:29.567
So one of them is eval.

00:05:29.567 --> 00:05:33.467
So eval is a function
that you can call with a string

00:05:33.467 --> 00:05:37.067
to evaluate that string
as JavaScript code.

00:05:37.067 --> 00:05:38.801
And that's actually
not so bad.

00:05:38.801 --> 00:05:41.100
The problem with it is that
it can also change

00:05:41.100 --> 00:05:43.067
the calling context.

00:05:43.067 --> 00:05:46.334
And that means that,
um, if you're trying

00:05:46.334 --> 00:05:48.601
to implement JavaScript,

00:05:48.601 --> 00:05:50.667
you really want to have
some scope information.

00:05:50.667 --> 00:05:52.167
So if you look for--

00:05:52.167 --> 00:05:54.834
if you access
a property X somewhere,

00:05:54.834 --> 00:05:57.667
you want to be able to--to see
basically in your scopes

00:05:57.667 --> 00:05:59.167
where is X declared?

00:05:59.167 --> 00:06:01.701
But if you have a call to eval,
basically, you don't know

00:06:01.701 --> 00:06:04.300
because eval can introduce
new bindings dynamically.

00:06:04.300 --> 00:06:06.501
So you could introduce
a new X variable

00:06:06.501 --> 00:06:09.434
in, uh, the context
where you're calling eval.

00:06:09.434 --> 00:06:11.000
So basically, you just have
to give up

00:06:11.000 --> 00:06:13.667
and say, statically,
I don't know.

00:06:13.667 --> 00:06:17.234
Um, and there's similar issues
with, uh, "with" statements

00:06:17.234 --> 00:06:18.634
in JavaScript.

00:06:18.634 --> 00:06:21.067
So "with" statements are used
to introduce a new object

00:06:21.067 --> 00:06:22.801
in your scope chain.

00:06:22.801 --> 00:06:25.434
So if you want easy access
to all the properties

00:06:25.434 --> 00:06:26.868
on the document object,

00:06:26.868 --> 00:06:30.300
you can say with document
and then have a blog of code,

00:06:30.300 --> 00:06:34.133
where if you just write a name
like "write"

00:06:34.133 --> 00:06:37.000
that will be looked up
in the document object

00:06:37.000 --> 00:06:40.534
so that will actually be
document.write.

00:06:40.534 --> 00:06:41.834
And that's all fine.

00:06:41.834 --> 00:06:46.167
But if you want to, uh,
have scope information again,

00:06:46.167 --> 00:06:48.267
you have to give up
inside of a "with" statement

00:06:48.267 --> 00:06:50.133
because you don't know.

00:06:50.133 --> 00:06:52.367
Because it might look
like a variable is declared

00:06:52.367 --> 00:06:53.968
and out of scope,

00:06:53.968 --> 00:06:56.567
but, uh, dynamically,
you might introduce an object

00:06:56.567 --> 00:06:58.501
with your "with" statement

00:06:58.501 --> 00:07:00.000
that has that property name
as well.

00:07:00.000 --> 00:07:01.701
And that's the one
that you need to get.

00:07:01.701 --> 00:07:04.767
So overall,
JavaScript is very dynamic.

00:07:04.767 --> 00:07:07.234
Um, and that makes it a bit
of a challenge

00:07:07.234 --> 00:07:10.968
to implement it efficiently.

00:07:10.968 --> 00:07:13.334
So let's talk
about what we did for V8

00:07:13.334 --> 00:07:16.667
and which design decisions
we took.

00:07:16.667 --> 00:07:21.467
So the goal for V8 was to create
a JavaScript engine

00:07:21.467 --> 00:07:26.200
that would make, um, large
object-oriented applications

00:07:26.200 --> 00:07:27.901
perform well.

00:07:27.901 --> 00:07:29.801
So if you have large
object-oriented applications,

00:07:29.801 --> 00:07:31.400
you're going to use
abstractions.

00:07:31.400 --> 00:07:33.067
And if you use abstractions,

00:07:33.067 --> 00:07:34.834
you're going to have a lot
of property accesses

00:07:34.834 --> 00:07:37.567
and you're going to have
a lot of--of function calls.

00:07:37.567 --> 00:07:40.534
And you're going to have
a lot of objects.

00:07:40.534 --> 00:07:42.334
So that means
that in order to make

00:07:42.334 --> 00:07:44.100
these kind of applications
run fast,

00:07:44.100 --> 00:07:45.300
you need fast property
access,

00:07:45.300 --> 00:07:47.234
you need fast property
calls,

00:07:47.234 --> 00:07:50.300
and you need fast and scalable
memory management.

00:07:50.300 --> 00:07:53.968
So you want to be able to handle
a large number of objects,

00:07:53.968 --> 00:07:58.100
um, efficiently.

00:07:58.100 --> 00:08:02.701
So these goals led
to three key components of V8.

00:08:02.701 --> 00:08:04.234
So the first component

00:08:04.234 --> 00:08:06.200
is something called
hidden classes

00:08:06.200 --> 00:08:08.601
and hidden class
transitions.

00:08:08.601 --> 00:08:09.901
Um, so hidden classes

00:08:09.901 --> 00:08:13.367
is basically our notion
of types.

00:08:13.367 --> 00:08:16.033
Um, so JavaScript does not have
any types.

00:08:16.033 --> 00:08:17.701
And we're not adding types
to JavaScript

00:08:17.701 --> 00:08:18.901
or anything like that.

00:08:18.901 --> 00:08:20.634
But internally
in the JavaScript engine,

00:08:20.634 --> 00:08:23.300
we have a notion of type
and that's our hidden class.

00:08:23.300 --> 00:08:25.534
And I'll--I'll tell you more
about that.

00:08:25.534 --> 00:08:28.667
So once we have that, we--
we, uh, we can use a technique

00:08:28.667 --> 00:08:30.467
called inline caching.

00:08:30.467 --> 00:08:33.567
Um, so we generate native code
for all of our JavaScript.

00:08:33.567 --> 00:08:35.667
And we also generate code
on the fly

00:08:35.667 --> 00:08:38.667
and use a technique
called inline caching.

00:08:38.667 --> 00:08:40.834
So these two things together,
hidden classes

00:08:40.834 --> 00:08:43.501
and native code generation
with inline caching,

00:08:43.501 --> 00:08:46.667
gives us fast property access
and fast function calls.

00:08:46.667 --> 00:08:48.868
So those are the two
first items.

00:08:48.868 --> 00:08:50.901
Um, so the second thing
that we wanted

00:08:50.901 --> 00:08:54.033
was, uh, a fast memory
management system.

00:08:54.033 --> 00:08:55.501
Um, so we use,

00:08:55.501 --> 00:08:57.467
uh, a generational garbage
collector.

00:08:57.467 --> 00:09:00.467
And it's pretty much standard,
but it works really well.

00:09:00.467 --> 00:09:02.133
Um, and that means that,

00:09:02.133 --> 00:09:06.300
uh, having a generational
garbage collector,

00:09:06.300 --> 00:09:09.501
we scale well to dealing
with a lot of objects.

00:09:09.501 --> 00:09:13.000
And I'll tell you some more
about that as well.

00:09:13.000 --> 00:09:17.000
Okay, so let's, uh,
let's dig in.

00:09:17.000 --> 00:09:18.601
So to set the scene,
let me start

00:09:18.601 --> 00:09:22.000
by telling you a bit
about V8's memory model.

00:09:22.000 --> 00:09:26.734
Um, so in V8, we use,
uh, 32-bit tagged pointers.

00:09:26.734 --> 00:09:29.467
Um, all of our objects
in our heap

00:09:29.467 --> 00:09:32.300
are, uh, 4-byte aligned.

00:09:32.300 --> 00:09:34.000
And that means
that if you have a pointer

00:09:34.000 --> 00:09:37.100
to a JavaScript object, uh,
the two least significant bits

00:09:37.100 --> 00:09:39.067
are going to be zero.

00:09:39.067 --> 00:09:41.767
So we can use that knowledge
to actually,

00:09:41.767 --> 00:09:43.634
um, do pointer tagging.

00:09:43.634 --> 00:09:45.801
Since we know that all pointers
should have

00:09:45.801 --> 00:09:47.868
the two least significant bits,
zero,

00:09:47.868 --> 00:09:50.501
we can actually put in
ones there,

00:09:50.501 --> 00:09:53.200
uh, to--to give
some extra information

00:09:53.200 --> 00:09:54.367
to our pointers.

00:09:54.367 --> 00:09:55.734
And then we just make sure
to strip them

00:09:55.734 --> 00:09:58.067
if we actually need
the actual pointer.

00:09:58.067 --> 00:10:01.534
Um, so what we use that for
is allowing 32--

00:10:01.534 --> 00:10:04.133
sor--sorry--
31-bit signed integers

00:10:04.133 --> 00:10:05.968
to be immediate values.

00:10:05.968 --> 00:10:09.000
And they're distinguished
from real pointers by tagging.

00:10:09.000 --> 00:10:11.868
So if you'll, uh, load a pointer
to a JavaScript object

00:10:11.868 --> 00:10:15.934
from a heap and the address
is even--

00:10:15.934 --> 00:10:17.133
it's actually not a pointer.

00:10:17.133 --> 00:10:18.734
It's an immediate
integer value.

00:10:18.734 --> 00:10:21.634
And you get the integer value
by just shifting,

00:10:21.634 --> 00:10:23.501
uh, one bit right.

00:10:23.501 --> 00:10:25.367
So basically shifting
the zero away.

00:10:25.367 --> 00:10:28.434
And that's going to be
you're, uh, integer value.

00:10:28.434 --> 00:10:30.133
So that means
that we can have efficient,

00:10:30.133 --> 00:10:33.000
um, we can deal with integers
efficiently,

00:10:33.000 --> 00:10:34.634
uh, because they're just
immediate values

00:10:34.634 --> 00:10:36.167
and we don't have
to do any heap allocation

00:10:36.167 --> 00:10:37.767
to handle integers.

00:10:37.767 --> 00:10:39.701
Um, so on the other hand,

00:10:39.701 --> 00:10:43.667
if you load, um, a pointer
to an object from our heap

00:10:43.667 --> 00:10:44.834
and it's odd,

00:10:44.834 --> 00:10:46.934
so it has the least significant
bit of one,

00:10:46.934 --> 00:10:48.934
then it is an actual pointer.

00:10:48.934 --> 00:10:52.300
And the pointer to the object
is this value

00:10:52.300 --> 00:10:53.501
where you subtract one.

00:10:53.501 --> 00:10:56.901
So where you clear the tag.

00:10:56.901 --> 00:11:00.901
Okay, so, um,

00:11:00.901 --> 00:11:05.634
our base JavaScript objects
consist of three words.

00:11:05.634 --> 00:11:09.267
The first word
is a hidden class pointer.

00:11:09.267 --> 00:11:12.334
Um, so this is our notion
of type as I told you before.

00:11:12.334 --> 00:11:16.067
And I'll--I'll get into details
on that in a second.

00:11:16.067 --> 00:11:18.734
Uh, and the two other pointers
are used

00:11:18.734 --> 00:11:20.734
to point to where
we actually hold

00:11:20.734 --> 00:11:22.601
the values of properties.

00:11:22.601 --> 00:11:25.467
So we split the property's
backing storage

00:11:25.467 --> 00:11:26.968
into two parts,

00:11:26.968 --> 00:11:31.868
one is for properties
that are named by strings.

00:11:31.868 --> 00:11:34.133
So like X, Y, and Z.

00:11:34.133 --> 00:11:36.334
And the other one
is for what we call "elements,"

00:11:36.334 --> 00:11:39.234
which are basically properties
which have integer names.

00:11:39.234 --> 00:11:42.033
So 012 and so on.

00:11:42.033 --> 00:11:44.701
Um, so all
of our JavaScript objects

00:11:44.701 --> 00:11:47.267
are these three-word
thingies.

00:11:47.267 --> 00:11:50.100
Okay, and the backing storage
for properties and for elements

00:11:50.100 --> 00:11:52.400
can be in two
different states,

00:11:52.400 --> 00:11:54.367
namely a fast case
and a slow case.

00:11:54.367 --> 00:11:56.067
So in the fast case,

00:11:56.067 --> 00:11:59.434
uh, a property's backing storage
or an element's backing storage

00:11:59.434 --> 00:12:00.767
is just an array,

00:12:00.767 --> 00:12:02.634
where we can do
direct indexing.

00:12:02.634 --> 00:12:05.033
And in the slow case,
it's going to be a dictionary

00:12:05.033 --> 00:12:08.901
or a HashMap.

00:12:08.901 --> 00:12:14.434
Okay, so now we're ready
to talk about hidden classes.

00:12:14.434 --> 00:12:16.033
So, uh, as I told you,

00:12:16.033 --> 00:12:18.501
in static, object-oriented,
uh, languages

00:12:18.501 --> 00:12:20.701
where you have classes,

00:12:20.701 --> 00:12:24.400
uh, you can do really fast
property access

00:12:24.400 --> 00:12:26.634
because the class describes
your object

00:12:26.634 --> 00:12:29.434
and you know exactly
where to find the properties

00:12:29.434 --> 00:12:30.767
of your object.

00:12:30.767 --> 00:12:33.300
So we wanted to have the same
ability for JavaScript.

00:12:33.300 --> 00:12:35.534
We wanted to be able to do,
like, a few,

00:12:35.534 --> 00:12:38.334
uh, assembly instructions
to load a property.

00:12:38.334 --> 00:12:41.534
Um, so to use these
normal optimization techniques,

00:12:41.534 --> 00:12:44.534
we needed to introduce
a notion of type.

00:12:44.534 --> 00:12:46.834
And for that, we use
hidden classes.

00:12:46.834 --> 00:12:51.601
So hidden classes,
uh, are classes,

00:12:51.601 --> 00:12:53.200
but they're only internal

00:12:53.200 --> 00:12:54.667
to the--
to the JavaScript engine.

00:12:54.667 --> 00:12:56.234
So it's something
that we keep track of

00:12:56.234 --> 00:12:58.000
and users don't know about.

00:12:58.000 --> 00:13:01.234
Um, and hidden classes
group objects

00:13:01.234 --> 00:13:03.734
that have the exact same
structure.

00:13:06.133 --> 00:13:09.701
Okay, so talking
about hidden classes,

00:13:09.701 --> 00:13:13.667
it's easiest to just,
uh, have an example.

00:13:13.667 --> 00:13:17.434
So, um, in JavaScript,
all objects are created

00:13:17.434 --> 00:13:20.567
from--from, uh,
from functions.

00:13:20.567 --> 00:13:22.634
Um, and here's
a point function,

00:13:22.634 --> 00:13:23.901
which is a constructive
function

00:13:23.901 --> 00:13:25.801
that we can use
to construct points.

00:13:25.801 --> 00:13:27.868
And it just takes two arguments
and assigns them

00:13:27.868 --> 00:13:32.834
to the, uh, X and Y properties
of the resulting object.

00:13:32.834 --> 00:13:36.133
Okay, so the goal here
is that any point

00:13:36.133 --> 00:13:39.467
that we construct
should end up having,

00:13:39.467 --> 00:13:41.701
uh, the point map, basically,

00:13:41.701 --> 00:13:43.534
the point hidden class.

00:13:43.534 --> 00:13:46.300
So JavaScript objects created
in the same way

00:13:46.300 --> 00:13:48.534
should end up having
the same hidden class

00:13:48.534 --> 00:13:53.200
because they'll have
the same internal structure.

00:13:53.200 --> 00:13:54.834
Okay.

00:13:54.834 --> 00:13:57.133
Um, so in this example,
I'm going to create two points.

00:13:57.133 --> 00:13:58.434
I'm going to show you
how they end up

00:13:58.434 --> 00:14:01.300
having the same
hidden class.

00:14:01.300 --> 00:14:05.701
So since all JavaScript objects
are created from functions,

00:14:05.701 --> 00:14:09.968
we create an initial class
for each function.

00:14:09.968 --> 00:14:11.200
So the point function here

00:14:11.200 --> 00:14:13.100
is going to have
an initial class,

00:14:13.100 --> 00:14:14.334
which is called class zero,

00:14:14.334 --> 00:14:15.734
which I've put up there.

00:14:15.734 --> 00:14:18.000
And this is the class--
the hidden class--

00:14:18.000 --> 00:14:21.868
that we're going to give,
uh, to all new objects created

00:14:21.868 --> 00:14:23.801
from the point function.

00:14:23.801 --> 00:14:28.167
So when we, uh, create
our first point here, p1,

00:14:28.167 --> 00:14:30.767
that's this three-word thing

00:14:30.767 --> 00:14:33.734
that has a pointer
to hidden class.

00:14:33.734 --> 00:14:35.534
And since this object
was created

00:14:35.534 --> 00:14:37.467
using the point function,

00:14:37.467 --> 00:14:40.000
it's initial class is going
to be the initial class

00:14:40.000 --> 00:14:42.734
of the point function,
class zero.

00:14:42.734 --> 00:14:44.734
And then it has properties
and elements as well.

00:14:44.734 --> 00:14:46.534
And in the beginning,
we're going to allocate

00:14:46.534 --> 00:14:48.734
a small piece of--
of backing storage

00:14:48.734 --> 00:14:51.067
both for properties
and for elements.

00:14:51.067 --> 00:14:53.033
Um, so that's--
that's the initial thing

00:14:53.033 --> 00:14:55.467
that you get
when you say a new point.

00:14:55.467 --> 00:14:57.367
And then we're going
to start executing the body

00:14:57.367 --> 00:15:01.033
of the point function
with this newly allocated object

00:15:01.033 --> 00:15:05.434
as the--this pointer.

00:15:05.434 --> 00:15:07.067
Okay, so the first thing
that we're going to do

00:15:07.067 --> 00:15:09.267
is add an X-property
to this object.

00:15:09.267 --> 00:15:11.501
So adding a property
to an object

00:15:11.501 --> 00:15:13.934
changes the structure
of the object,

00:15:13.934 --> 00:15:15.934
which means that we need
to change the hidden class

00:15:15.934 --> 00:15:17.868
of the object.

00:15:17.868 --> 00:15:21.501
So when we assign X
to this property,

00:15:21.501 --> 00:15:23.200
we need to create
a new class.

00:15:23.200 --> 00:15:26.334
And we do that by copying
the original class,

00:15:26.334 --> 00:15:27.701
which is class zero,

00:15:27.701 --> 00:15:29.868
and then adding the knowledge
to that class

00:15:29.868 --> 00:15:31.734
that we have an X-property.

00:15:31.734 --> 00:15:34.033
and that--that property
is at offset zero

00:15:34.033 --> 00:15:35.467
in our backing storage.

00:15:35.467 --> 00:15:37.701
And then we're going
to put the value

00:15:37.701 --> 00:15:40.667
into the backing storage
at offset zero.

00:15:40.667 --> 00:15:42.701
And importantly,
we're going to remember

00:15:42.701 --> 00:15:45.834
in class zero

00:15:45.834 --> 00:15:48.701
that if you have an object
that has class zero

00:15:48.701 --> 00:15:51.334
and you add a property
with the name X,

00:15:51.334 --> 00:15:53.868
then you need to transition
to class one.

00:15:53.868 --> 00:15:57.934
So that's what we call
a hidden class transition.

00:15:57.934 --> 00:16:01.000
Another similar thing happens
when we add the Y-property.

00:16:01.000 --> 00:16:03.067
So adding a new property
to an object

00:16:03.067 --> 00:16:04.601
changes its structure.

00:16:04.601 --> 00:16:08.033
And therefore it needs
to change its hidden class.

00:16:08.033 --> 00:16:10.534
So we create
a new hidden class

00:16:10.534 --> 00:16:12.667
by copying class one.

00:16:12.667 --> 00:16:15.501
We add the knowledge
that we have a Y-property

00:16:15.501 --> 00:16:17.167
and that the value
of the Y-property

00:16:17.167 --> 00:16:19.434
is at offset one
in our backing storage.

00:16:19.434 --> 00:16:21.133
We fill in value.

00:16:21.133 --> 00:16:23.534
And we, uh, update
the hidden class pointer

00:16:23.534 --> 00:16:25.667
to point
to this new class.

00:16:25.667 --> 00:16:27.667
And again, we remember
in class one

00:16:27.667 --> 00:16:30.400
that if you have an object
that has class one

00:16:30.400 --> 00:16:32.200
and you add a Y-property
to it,

00:16:32.200 --> 00:16:35.968
then you need to transition
to class two.

00:16:35.968 --> 00:16:38.300
Okay, so that finishes
the construction

00:16:38.300 --> 00:16:39.968
of our first point.

00:16:39.968 --> 00:16:42.133
So you see this is actually
a pretty heavy weight

00:16:42.133 --> 00:16:45.801
to construct the first object
from a constructive function

00:16:45.801 --> 00:16:48.601
because we need to create
all of these new classes

00:16:48.601 --> 00:16:52.501
by copying existing ones
and adding a bit of information.

00:16:52.501 --> 00:16:55.367
Um, but that only costs
on the first construction.

00:16:55.367 --> 00:16:57.234
So on the next construction,

00:16:57.234 --> 00:16:59.567
um, we're basically going
to do the same thing,

00:16:59.567 --> 00:17:02.234
but we're going
to reuse our classes.

00:17:02.234 --> 00:17:06.834
So if we go to the construction
of, uh, of p2,

00:17:06.834 --> 00:17:08.901
that will create
a new object,

00:17:08.901 --> 00:17:10.868
which is this
three-way thing.

00:17:10.868 --> 00:17:13.133
The initial class
is going to be the class

00:17:13.133 --> 00:17:15.200
associated
with the point function,

00:17:15.200 --> 00:17:17.934
which is going to be c0.

00:17:17.934 --> 00:17:19.133
Class zero.

00:17:19.133 --> 00:17:20.634
And then we're going
to execute the body

00:17:20.634 --> 00:17:22.300
of the point function.

00:17:22.300 --> 00:17:23.667
So the first thing
we're going to do

00:17:23.667 --> 00:17:28.667
is assign, um, is to add
an X-property to our object.

00:17:28.667 --> 00:17:32.300
So now this point
has class zero.

00:17:32.300 --> 00:17:34.501
And in class zero,
there's information

00:17:34.501 --> 00:17:37.334
that if you have an object
that has class zero,

00:17:37.334 --> 00:17:39.334
and you add a property
called X,

00:17:39.334 --> 00:17:41.834
well, then you need
to transition to class one.

00:17:41.834 --> 00:17:43.634
So that's what we're going
to do.

00:17:43.634 --> 00:17:46.167
So for the assignment to X,

00:17:46.167 --> 00:17:48.434
we're just going to update
the hidden class pointer

00:17:48.434 --> 00:17:50.801
and put the value
in the backing storage.

00:17:50.801 --> 00:17:52.400
And similarly for Y,

00:17:52.400 --> 00:17:54.467
we now have an object
of class one.

00:17:54.467 --> 00:17:57.067
In class one, we know
that if you add a Y property,

00:17:57.067 --> 00:17:59.234
you need to transition
to class two.

00:17:59.234 --> 00:18:00.634
So that's all we're going
to do.

00:18:00.634 --> 00:18:02.934
We're just going to update
the hidden class pointer

00:18:02.934 --> 00:18:07.934
and, uh, add the value
to the backing storage.

00:18:07.934 --> 00:18:10.534
So now we've created
two point objects.

00:18:10.534 --> 00:18:13.033
They've been created
in exactly the same way.

00:18:13.033 --> 00:18:17.934
And they end up sharing
the hidden class, class two.

00:18:17.934 --> 00:18:20.200
And the important thing here
is that in class two,

00:18:20.200 --> 00:18:23.234
we have a complete description
of our objects.

00:18:23.234 --> 00:18:26.267
We know that all objects
that have class two

00:18:26.267 --> 00:18:28.934
will have X at offset zero
in the backing storage

00:18:28.934 --> 00:18:31.167
and Y at offset one.

00:18:31.167 --> 00:18:35.100
And we can use that
to optimize property accesses.

00:18:37.534 --> 00:18:39.434
So let me revisit
my previous statement.

00:18:39.434 --> 00:18:41.968
So I said that JavaScript
is really challenging

00:18:41.968 --> 00:18:45.467
to implement because
it's really, really dynamic.

00:18:45.467 --> 00:18:46.667
And that's true.

00:18:46.667 --> 00:18:48.934
So in JavaScript,
you have a lot of features

00:18:48.934 --> 00:18:52.834
that allow you to write
really, really dynamic code.

00:18:52.834 --> 00:18:55.567
But it turns out
that if you write,

00:18:55.567 --> 00:18:59.300
uh, nice,
well-factored code,

00:18:59.300 --> 00:19:01.901
in most cases, you'll have,
like, parts of your code

00:19:01.901 --> 00:19:04.701
that deal with objects
that have a certain structure.

00:19:04.701 --> 00:19:06.934
So now that we have
hidden classes,

00:19:06.934 --> 00:19:08.667
we can instrument
our JavaScript engine

00:19:08.667 --> 00:19:12.234
to actually collect information
about the hidden classes

00:19:12.234 --> 00:19:13.901
that hit certain access sites.

00:19:13.901 --> 00:19:15.968
And it turns out that 90%
of the cases

00:19:15.968 --> 00:19:19.067
or maybe even more,
uh, only objects

00:19:19.067 --> 00:19:23.367
having the same hidden class
are ever seen.

00:19:23.367 --> 00:19:26.100
So that means that,
basically, you know something

00:19:26.100 --> 00:19:28.033
about the structure
of your objects

00:19:28.033 --> 00:19:31.567
when you've seen an object once
at an access site.

00:19:31.567 --> 00:19:33.501
And that's what we're, uh,
and that's what we're going

00:19:33.501 --> 00:19:36.234
to do to, uh, to--
to optimize.

00:19:36.234 --> 00:19:39.400
Um, so basically,
at runtime,

00:19:39.400 --> 00:19:41.634
JavaScript is not that
dynamic.

00:19:41.634 --> 00:19:44.167
You basically see things
that have the same structure

00:19:44.167 --> 00:19:46.667
again and again and again
and again.

00:19:46.667 --> 00:19:48.167
So we can use that.

00:19:48.167 --> 00:19:52.100
Um, so the only problem here

00:19:52.100 --> 00:19:55.501
is that when we generate
the JavaScript code--

00:19:55.501 --> 00:19:59.534
sorry, the native code
for our JavaScript code,

00:19:59.534 --> 00:20:02.067
um, we don't know
the hidden class

00:20:02.067 --> 00:20:04.534
of an object
at an access site,

00:20:04.534 --> 00:20:06.000
uh, because we have
no type information

00:20:06.000 --> 00:20:07.300
in the language.

00:20:07.300 --> 00:20:09.934
Um, so that means
that we only know something

00:20:09.934 --> 00:20:11.868
about our objects
when we see the first object

00:20:11.868 --> 00:20:13.834
at an access site.

00:20:13.834 --> 00:20:16.234
Um, so in order
to handle this,

00:20:16.234 --> 00:20:18.367
we use runtime
code generation.

00:20:18.367 --> 00:20:23.601
And we use a technique called
inline caching.

00:20:23.601 --> 00:20:25.100
So here's
a very simple picture

00:20:25.100 --> 00:20:26.834
of what inline caching
is like.

00:20:26.834 --> 00:20:28.100
So in the beginning,

00:20:28.100 --> 00:20:30.467
we just generate native code
for our JavaScript code.

00:20:30.467 --> 00:20:33.400
And at all access sites,
we have absolutely no knowledge.

00:20:33.400 --> 00:20:36.200
So if we want to load
an X-property,

00:20:36.200 --> 00:20:37.901
we're just going to call
a piece of code

00:20:37.901 --> 00:20:39.701
that's going to do
a completely generic

00:20:39.701 --> 00:20:42.534
full lookup, uh, through
our objects

00:20:42.534 --> 00:20:43.634
to see if they can find--

00:20:43.634 --> 00:20:46.767
uh, if it can find
the property.

00:20:46.767 --> 00:20:48.701
But once
we've done that once,

00:20:48.701 --> 00:20:50.200
we have some extra
information.

00:20:50.200 --> 00:20:52.167
We know the hidden class
of the object

00:20:52.167 --> 00:20:53.734
that we've just looked at.

00:20:53.734 --> 00:20:56.634
And we know, um,

00:20:56.634 --> 00:20:59.634
where we found the property
in this object.

00:20:59.634 --> 00:21:03.167
And based on that knowledge,
we can generate a small snippet

00:21:03.167 --> 00:21:07.000
of new code that's going to be
really fast.

00:21:07.000 --> 00:21:10.334
Um, and it's going to assume
that the next time we get here,

00:21:10.334 --> 00:21:14.067
we're going to see
the same hidden class again.

00:21:14.067 --> 00:21:15.901
So then we're going
to rewrite the code.

00:21:15.901 --> 00:21:17.234
So that at this access site,

00:21:17.234 --> 00:21:19.701
we're not going to go
to the fully generic code.

00:21:19.701 --> 00:21:23.634
But we're actually going
to hit the fast lookup code.

00:21:23.634 --> 00:21:25.801
And the only thing
the fast lookup code has to do

00:21:25.801 --> 00:21:27.634
is validate our assumptions.

00:21:27.634 --> 00:21:31.334
So it needs to check that
the next object that gets here

00:21:31.334 --> 00:21:32.634
actually has the same
hidden class

00:21:32.634 --> 00:21:33.667
as the first one.

00:21:33.667 --> 00:21:34.734
And if it does,

00:21:34.734 --> 00:21:36.334
then it knows exactly
where to load

00:21:36.334 --> 00:21:39.267
the--the property value.

00:21:39.267 --> 00:21:41.767
Okay, and if the assumptions
are broken--

00:21:41.767 --> 00:21:44.767
so if we get here
with another type of object--

00:21:44.767 --> 00:21:46.400
well, then we bail out
and then we go

00:21:46.400 --> 00:21:48.734
to the fully generic
lookup again.

00:21:48.734 --> 00:21:50.501
And again, that's the same
for all access sites.

00:21:50.501 --> 00:21:54.701
When we've seen the first,
uh, object at an access site,

00:21:54.701 --> 00:21:56.167
we generate a new piece
of code

00:21:56.167 --> 00:21:58.667
to do a fast lookup
the next time.

00:21:58.667 --> 00:22:00.267
Um, and that's
with the assumption

00:22:00.267 --> 00:22:03.000
that we get the same
hidden class again.

00:22:03.000 --> 00:22:05.033
If we don't,
then we bail out

00:22:05.033 --> 00:22:08.734
and do a full generate lookup.

00:22:08.734 --> 00:22:11.801
Okay, so what does
the fast case look like?

00:22:11.801 --> 00:22:13.467
So it looks like this.

00:22:13.467 --> 00:22:14.934
Um, and I've actually
given you

00:22:14.934 --> 00:22:17.400
all of the information
that you need to--

00:22:17.400 --> 00:22:18.901
to completely understand
what's going on here.

00:22:18.901 --> 00:22:20.901
So let me try to step--
step through it.

00:22:20.901 --> 00:22:23.767
So this is the--
the small snippet of code

00:22:23.767 --> 00:22:27.667
that we generate to access
a property on an object.

00:22:27.667 --> 00:22:29.968
So the first couple
of lines here,

00:22:29.968 --> 00:22:32.868
the first line
just loads the receiver

00:22:32.868 --> 00:22:37.968
from the stack
into register eax, okay?

00:22:37.968 --> 00:22:43.701
So as I told you,
we use tag pointers.

00:22:43.701 --> 00:22:46.000
So either--so now
we've loaded something.

00:22:46.000 --> 00:22:49.667
Okay. So now we need to check
if it's an object

00:22:49.667 --> 00:22:52.133
or if it's
an immediate value.

00:22:52.133 --> 00:22:54.801
Uh, maybe a small integer.

00:22:54.801 --> 00:22:56.801
So that's what the second line
here is doing.

00:22:56.801 --> 00:22:59.801
It--it, uh, tests
if the least significant bit

00:22:59.801 --> 00:23:01.334
of eax is one.

00:23:01.334 --> 00:23:03.367
If it is,
this is an object pointer.

00:23:03.367 --> 00:23:06.667
If it's not, it's an immediate
integer value

00:23:06.667 --> 00:23:09.167
for which this snippet
doesn't really do anything.

00:23:09.167 --> 00:23:12.033
So we're going to jump out
and go do the generic case

00:23:12.033 --> 00:23:13.868
if that's the--
if--if that's happening.

00:23:13.868 --> 00:23:16.734
So if we see an integer here,
we're just bailing out.

00:23:16.734 --> 00:23:19.234
So the--the first lines here
are just loading the receiver,

00:23:19.234 --> 00:23:22.200
checking that it's an object.

00:23:22.200 --> 00:23:23.968
So the next couple
of lines here

00:23:23.968 --> 00:23:25.901
are validating
our assumptions.

00:23:25.901 --> 00:23:27.901
And our assumption is
that we're going to see

00:23:27.901 --> 00:23:29.534
the same hidden class again.

00:23:29.534 --> 00:23:32.367
So this piece of code
was generated with the knowledge

00:23:32.367 --> 00:23:34.701
that the first,
uh, that the hidden class

00:23:34.701 --> 00:23:36.634
of the first object
that got here

00:23:36.634 --> 00:23:38.300
was at address
whatever's there.

00:23:38.300 --> 00:23:41.367
0xf78 and so on.

00:23:41.367 --> 00:23:44.734
Okay. So now we need to check
that the hidden class

00:23:44.734 --> 00:23:48.334
of a current object
is the same one.

00:23:48.334 --> 00:23:52.267
So we're going to load
from eax minus one.

00:23:52.267 --> 00:23:55.534
So that's removing the tagging
from the pointer

00:23:55.534 --> 00:23:57.834
and loading a pointer
from there,

00:23:57.834 --> 00:23:59.234
which is the map pointer,

00:23:59.234 --> 00:24:01.968
and we're just comparing that
to what we saw before.

00:24:01.968 --> 00:24:04.434
If it's the same,
we're happy

00:24:04.434 --> 00:24:06.767
and we load
the properties array

00:24:06.767 --> 00:24:08.367
from our object.

00:24:08.367 --> 00:24:09.901
And from the properties array,

00:24:09.901 --> 00:24:13.334
we load the property value
directly.

00:24:13.334 --> 00:24:14.534
And then we return.

00:24:14.534 --> 00:24:15.734
So in the fast case,

00:24:15.734 --> 00:24:17.200
all we need to do
is check our assumptions.

00:24:17.200 --> 00:24:19.133
We load the receiver.
Check that it's an object.

00:24:19.133 --> 00:24:21.234
Check that it has the correct
hidden class.

00:24:21.234 --> 00:24:22.968
And then directly load
the property.

00:24:22.968 --> 00:24:25.200
So that's a few assembly line
instructions.

00:24:25.200 --> 00:24:26.868
And that's really,
really fast.

00:24:26.868 --> 00:24:28.601
And if any of
our assumptions break,

00:24:28.601 --> 00:24:33.400
if we either get an integer
or if the class does not match,

00:24:33.400 --> 00:24:36.934
then we bail out and go
to a fully generic lookup.

00:24:39.834 --> 00:24:41.734
Okay, so basically,

00:24:41.734 --> 00:24:43.868
I've told you now
about two states

00:24:43.868 --> 00:24:45.601
that our inline caches
can be in.

00:24:45.601 --> 00:24:47.567
There's actually a third
as well.

00:24:47.567 --> 00:24:49.901
So the three inline cache states
that we have

00:24:49.901 --> 00:24:51.234
are uninitialized,

00:24:51.234 --> 00:24:52.667
which is where
everything begins.

00:24:52.667 --> 00:24:53.767
We don't know anything yet.

00:24:53.767 --> 00:24:56.100
We haven't seen
any objects here.

00:24:56.100 --> 00:24:58.067
So once we see
the first object,

00:24:58.067 --> 00:25:01.000
we transition
to monomorphic,

00:25:01.000 --> 00:25:03.133
which means that we've
only seen one hidden class

00:25:03.133 --> 00:25:05.133
at this access site.

00:25:05.133 --> 00:25:07.868
If we see more hidden classes
at the same access site,

00:25:07.868 --> 00:25:10.901
we go into what's called
a megamorphic state.

00:25:10.901 --> 00:25:13.801
And that just means
we've seen more types here.

00:25:13.801 --> 00:25:16.801
Um, and in that case,
we actually use a cache

00:25:16.801 --> 00:25:19.701
of generated
fast-case stubs.

00:25:19.701 --> 00:25:21.868
So if we've already generated
a stub

00:25:21.868 --> 00:25:24.834
for the, uh, this hidden class
that we're seeing

00:25:24.834 --> 00:25:26.434
and this property,
we use that.

00:25:26.434 --> 00:25:28.367
And otherwise, we go
to the full generic lookup.

00:25:28.367 --> 00:25:31.300
So even if we see,
uh, multiple different classes

00:25:31.300 --> 00:25:32.501
at the same access site,

00:25:32.501 --> 00:25:33.767
we're actually trying
to--to use

00:25:33.767 --> 00:25:37.367
some of our optimized stubs.

00:25:37.367 --> 00:25:39.567
Another thing worth,
uh, knowing

00:25:39.567 --> 00:25:41.434
about inline caches in V8

00:25:41.434 --> 00:25:44.834
is that we clear them
on full garbage collections.

00:25:44.834 --> 00:25:46.467
And that might sound odd.

00:25:46.467 --> 00:25:49.868
So we've just spent time
generating code on the fly.

00:25:49.868 --> 00:25:52.868
Uh, and now we just
throw it all away.

00:25:52.868 --> 00:25:55.334
So the reason for that is that,
first of all,

00:25:55.334 --> 00:25:58.601
it allows us to get rid
of unused code stubs.

00:25:58.601 --> 00:26:00.400
So all of the code
that we generate

00:26:00.400 --> 00:26:02.667
is allocated
in the JavaScript heap

00:26:02.667 --> 00:26:04.267
like any other JavaScript
object.

00:26:04.267 --> 00:26:06.400
And it flows freely around.

00:26:06.400 --> 00:26:10.100
Um, so in order to be able
to, uh, to throw it away,

00:26:10.100 --> 00:26:12.067
uh, we need to clear
inline caches

00:26:12.067 --> 00:26:16.100
so there are no pointers,
uh, to these stubs.

00:26:16.100 --> 00:26:19.367
Um, so if you have
an application

00:26:19.367 --> 00:26:22.334
where you have, like,
a couple of stages--

00:26:22.334 --> 00:26:24.934
so in the first stage,
you set up a lot of stuff.

00:26:24.934 --> 00:26:28.434
And you do a lot of things
with one piece of code.

00:26:28.434 --> 00:26:30.634
And then basically
you transition to some other--

00:26:30.634 --> 00:26:32.601
to--to, like, another phase
where you use, basically,

00:26:32.601 --> 00:26:34.234
another piece of code.

00:26:34.234 --> 00:26:36.567
We don't want to keep
all the code objects alive

00:26:36.567 --> 00:26:38.067
from the first piece of code

00:26:38.067 --> 00:26:39.767
because if they're not going
to be used anymore,

00:26:39.767 --> 00:26:41.200
that's a waste.

00:26:41.200 --> 00:26:44.367
Um, so clearing inline caches
at full garbage collections

00:26:44.367 --> 00:26:47.300
allows us to get rid
of unused code stubs.

00:26:47.300 --> 00:26:50.901
The other thing that clearing,
um, inline caches

00:26:50.901 --> 00:26:52.734
at full garbage collection
gives us

00:26:52.734 --> 00:26:55.267
is the ability
to actually go back

00:26:55.267 --> 00:26:58.033
to the fast case
if we hit the slow case

00:26:58.033 --> 00:27:00.400
where we've seen multiple
different hidden classes

00:27:00.400 --> 00:27:02.200
at an access site.

00:27:02.200 --> 00:27:04.167
But basically,
we've transitioned

00:27:04.167 --> 00:27:06.701
to another, like, phase
of the program

00:27:06.701 --> 00:27:09.100
where we're only seeing objects
with the same,

00:27:09.100 --> 00:27:11.467
uh, with the same
hidden class.

00:27:11.467 --> 00:27:13.400
Uh, then we basically
don't want to get stuck

00:27:13.400 --> 00:27:15.534
in the situation
where we think that we've seen

00:27:15.534 --> 00:27:17.367
multiple, uh, things.

00:27:17.367 --> 00:27:20.801
So clearing inline caches
on--on full garbage collection

00:27:20.801 --> 00:27:22.367
gives our inline caches
the ability

00:27:22.367 --> 00:27:25.801
to go back to the fast
monomorphic case again.

00:27:28.868 --> 00:27:34.267
Okay, so, um,

00:27:34.267 --> 00:27:36.501
that was,
uh, an introduction

00:27:36.501 --> 00:27:38.567
to how we make
property accesses fast.

00:27:38.567 --> 00:27:39.834
So there are
two things here.

00:27:39.834 --> 00:27:42.734
There are the hidden classes
and--and the transition

00:27:42.734 --> 00:27:44.367
between hidden classes.

00:27:44.367 --> 00:27:47.501
And there's native code
generation with inline caching.

00:27:47.501 --> 00:27:50.667
So the next thing I'd like
to--to tell you about

00:27:50.667 --> 00:27:53.767
is, uh,
our memory management.

00:27:53.767 --> 00:27:57.334
So we use a precise generational
garbage collector.

00:27:57.334 --> 00:28:00.634
And what we really want here
is, uh,

00:28:00.634 --> 00:28:02.767
to get in a situation
where the JavaScript engine

00:28:02.767 --> 00:28:04.367
scales well.

00:28:04.367 --> 00:28:06.434
So if you have a lot
of objects,

00:28:06.434 --> 00:28:09.701
uh, and a lot of, like,
big data structures

00:28:09.701 --> 00:28:11.467
when you run your program,

00:28:11.467 --> 00:28:14.033
we don't want
the garbage collector

00:28:14.033 --> 00:28:16.000
to have to look
at all of these objects

00:28:16.000 --> 00:28:20.534
every time it has to, uh,
uh, reclaim, uh, some memory

00:28:20.534 --> 00:28:23.667
because that's going to lead
to big pause times

00:28:23.667 --> 00:28:26.133
and it's going to degrade
your performance.

00:28:26.133 --> 00:28:28.868
Because every time you need
to get some free memory,

00:28:28.868 --> 00:28:30.033
it has to look at everything.

00:28:30.033 --> 00:28:31.300
So we don't want that.

00:28:31.300 --> 00:28:34.234
So instead, we use generational
garbage collection.

00:28:34.234 --> 00:28:38.234
Um, so we have
two generations.

00:28:38.234 --> 00:28:40.000
We have a young generation,

00:28:40.000 --> 00:28:42.634
which is one, small,
contiguous space,

00:28:42.634 --> 00:28:44.701
which would
garbage collect often,

00:28:44.701 --> 00:28:46.501
and then we have
an old generation,

00:28:46.501 --> 00:28:49.400
uh, which is divided
into a number of spaces.

00:28:49.400 --> 00:28:53.300
Um, and--and we only
occasionally garbage collect

00:28:53.300 --> 00:28:54.767
the old generation.

00:28:54.767 --> 00:28:57.534
So the reasoning here
is that, um,

00:28:57.534 --> 00:28:59.701
in object-oriented programs,

00:28:59.701 --> 00:29:03.033
most objects that you allocate
are going to be dead,

00:29:03.033 --> 00:29:04.234
like, really soon.

00:29:04.234 --> 00:29:06.868
You'll have a lot
of temporary objects.

00:29:06.868 --> 00:29:10.534
Um, and the ones
that do not die immediately

00:29:10.534 --> 00:29:12.767
are often long-lived.

00:29:12.767 --> 00:29:15.067
So we allocate
all of our objects

00:29:15.067 --> 00:29:17.133
in the young generation.

00:29:17.133 --> 00:29:18.567
When--when we run
out of space

00:29:18.567 --> 00:29:19.701
in the young generation,

00:29:19.701 --> 00:29:22.033
we need to do
a garbage collection.

00:29:22.033 --> 00:29:24.100
But we only garbage collect
the young generation.

00:29:24.100 --> 00:29:25.868
And since most objects
that are allocated

00:29:25.868 --> 00:29:27.434
die really young,

00:29:27.434 --> 00:29:29.634
there'll be a lot
of dead objects

00:29:29.634 --> 00:29:30.801
in our young generation.

00:29:30.801 --> 00:29:32.501
So we can get rid
of most of them.

00:29:32.501 --> 00:29:34.200
And then we'll be ready
to allocate again.

00:29:34.200 --> 00:29:36.767
So there's no reason for us
to look at the old generation

00:29:36.767 --> 00:29:38.467
if we can free enough,
uh, memory

00:29:38.467 --> 00:29:41.467
from the--from the young
generation.

00:29:41.467 --> 00:29:47.234
Um, so objects that survive
in the young generation

00:29:47.234 --> 00:29:50.434
will be promoted
to the old generation

00:29:50.434 --> 00:29:53.100
and then will continue.

00:29:53.100 --> 00:29:55.834
Okay, so, um, the old
generation, as I said,

00:29:55.834 --> 00:29:58.300
is divided up into a number
of spaces.

00:29:58.300 --> 00:30:00.400
And I'm not going to go
into a lot of details with that.

00:30:00.400 --> 00:30:03.601
But, so--so the reasons
for having multiple spaces

00:30:03.601 --> 00:30:05.133
is basically to be able

00:30:05.133 --> 00:30:09.234
to, uh, um, manage the--
the bookkeeping

00:30:09.234 --> 00:30:11.601
in our memory management
system.

00:30:11.601 --> 00:30:14.834
So for instance,
uh, we need--we have pages

00:30:14.834 --> 00:30:18.000
that are 8, uh, 8K big.

00:30:18.000 --> 00:30:19.934
So if we have objects
that are larger than that,

00:30:19.934 --> 00:30:21.601
then we're not going
to allocate them

00:30:21.601 --> 00:30:22.801
in the normal way.

00:30:22.801 --> 00:30:25.767
So we have a special space
for large objects.

00:30:25.767 --> 00:30:28.567
Uh, and also,
uh, as I said,

00:30:28.567 --> 00:30:31.701
we're dynamically generating
native code on the fly.

00:30:31.701 --> 00:30:35.434
Um, so we need one space
that's executable,

00:30:35.434 --> 00:30:37.734
uh, where we generate
our native code

00:30:37.734 --> 00:30:39.100
and run it from there.

00:30:39.100 --> 00:30:40.834
Um, so that's
the code space.

00:30:40.834 --> 00:30:43.834
And then there are a number
of other spaces.

00:30:43.834 --> 00:30:45.100
Good.

00:30:45.100 --> 00:30:48.868
So which types of garbage
collection do we use?

00:30:48.868 --> 00:30:50.968
Um, I'm sorry about that.

00:30:50.968 --> 00:30:53.501
My slides
are a bit messed up here.

00:30:53.501 --> 00:30:56.467
Uh, I think we'll be fine.

00:30:56.467 --> 00:31:00.133
So, um, we have three types
of garbage collection.

00:31:00.133 --> 00:31:02.234
So the first one
is a scavenge collect.

00:31:02.234 --> 00:31:03.834
A scavenge.

00:31:03.834 --> 00:31:05.734
And on a scavenge collection,

00:31:05.734 --> 00:31:08.067
uh, we only look
at the young generation.

00:31:08.067 --> 00:31:09.667
So this is what we do
all the time.

00:31:09.667 --> 00:31:12.934
Uh, and that's,
uh, copying collection.

00:31:12.934 --> 00:31:15.234
Um, which means
that it's leaning on the size

00:31:15.234 --> 00:31:16.868
of the live data.

00:31:16.868 --> 00:31:18.667
And as I told you,
a lot of data dies--

00:31:18.667 --> 00:31:21.267
a lot of objects die
really young.

00:31:21.267 --> 00:31:24.300
So that means
that most of your data

00:31:24.300 --> 00:31:26.501
in the young generation
is going to be dead.

00:31:26.501 --> 00:31:28.467
And since this, uh, garbage
collection technique

00:31:28.467 --> 00:31:30.133
is leaning on the size
of live objects,

00:31:30.133 --> 00:31:31.467
it's going to be really fast

00:31:31.467 --> 00:31:33.667
because there's not going
to be much live data.

00:31:33.667 --> 00:31:36.167
So typical pause times
for a scavenge

00:31:36.167 --> 00:31:37.834
is one to two milliseconds.

00:31:37.834 --> 00:31:41.734
Um, and we do that
all the time.

00:31:41.734 --> 00:31:43.167
Okay, so once in awhile,

00:31:43.167 --> 00:31:47.601
we've actually, uh, promoted
enough objects

00:31:47.601 --> 00:31:50.467
that we should, um, try
to clear up

00:31:50.467 --> 00:31:52.701
the old generation as well.

00:31:52.701 --> 00:31:56.100
Um, so once in awhile,
we do full garbage collections.

00:31:56.100 --> 00:31:57.934
And we have two flavors
of those.

00:31:57.934 --> 00:32:01.334
So the first one
is a non-compacting collection.

00:32:01.334 --> 00:32:03.334
So that's a mark-sweep
collection

00:32:03.334 --> 00:32:07.167
of both young and old
generation.

00:32:07.167 --> 00:32:10.000
And in the non-compacting
version,

00:32:10.000 --> 00:32:12.534
all free memory
gets added to free lists

00:32:12.534 --> 00:32:14.367
and we allocate from there.

00:32:14.367 --> 00:32:17.634
Um, and this might cause
fragmentation.

00:32:17.634 --> 00:32:21.234
So, um, so fragmentation's
not good.

00:32:21.234 --> 00:32:23.300
So that's why we have
a--another way

00:32:23.300 --> 00:32:25.467
of garbage collection.

00:32:25.467 --> 00:32:27.634
Um, okay, so a typical
pause time

00:32:27.634 --> 00:32:29.501
for, like, really big
applications

00:32:29.501 --> 00:32:32.767
for a full,
uh, non-compacting collection

00:32:32.767 --> 00:32:35.667
is up to 50 milliseconds.

00:32:35.667 --> 00:32:37.701
Often, you'll see
a lot smaller.

00:32:37.701 --> 00:32:40.467
But if you're building
really big applications,

00:32:40.467 --> 00:32:44.200
you can see pause times
up to 50 milliseconds.

00:32:44.200 --> 00:32:46.567
So the last type of garbage
collection that we have

00:32:46.567 --> 00:32:48.567
is a full compacting
collection.

00:32:48.567 --> 00:32:51.367
Uh, and that's
a mark-sweep-compact collection

00:32:51.367 --> 00:32:53.133
of both generations.

00:32:53.133 --> 00:32:55.133
And instead
of adding free memory

00:32:55.133 --> 00:32:56.634
to free lists,

00:32:56.634 --> 00:32:58.033
we compact everything.

00:32:58.033 --> 00:33:01.767
So we move all of the objects
to the beginning of pages

00:33:01.767 --> 00:33:04.300
um, to get rid
of the fragmentation.

00:33:04.300 --> 00:33:07.000
So basically, inside of V8,
we have a notion of--

00:33:07.000 --> 00:33:08.367
we have an idea
of how much fragmentation

00:33:08.367 --> 00:33:10.000
we've created.

00:33:10.000 --> 00:33:13.300
And when we reach
a certain threshold,

00:33:13.300 --> 00:33:15.634
we're going to do a non--
sorry, a compacting collection

00:33:15.634 --> 00:33:18.434
to get rid
of the fragmentation.

00:33:18.434 --> 00:33:19.934
Okay, so getting rid
of fragmentation

00:33:19.934 --> 00:33:22.501
means that we need
to copy a lot of objects.

00:33:22.501 --> 00:33:24.834
So if you're building
a really large application,

00:33:24.834 --> 00:33:29.767
uh, you might get pause times
of up to 100 milliseconds here.

00:33:29.767 --> 00:33:30.968
Yeah.

00:33:35.901 --> 00:33:38.400
Oh, so the question is
"how big is the, uh, is the--

00:33:38.400 --> 00:33:40.000
is the young generation?"

00:33:40.000 --> 00:33:42.667
Um, it's not very big.

00:33:42.667 --> 00:33:45.534
It's, like, wow,

00:33:45.534 --> 00:33:46.901
honestly,
I don't even remember.

00:33:46.901 --> 00:33:49.234
I think it's--it's--
it's a megabyte or two.

00:33:49.234 --> 00:33:51.033
Something like that.

00:34:04.667 --> 00:34:06.701
So the--so--I'm not sure
I understand the question.

00:34:06.701 --> 00:34:08.601
So you're saying
that if I have an application

00:34:08.601 --> 00:34:11.834
that allocates
a lot of small objects--

00:34:11.834 --> 00:34:14.267
a lot of small objects,
uh, and then you're saying

00:34:14.267 --> 00:34:15.567
that then
the young generation's

00:34:15.567 --> 00:34:18.000
going to be scanned
frequently?

00:34:18.000 --> 00:34:19.367
Well, no, not really.

00:34:19.367 --> 00:34:21.734
So--so the--so, um,
so if you allocate

00:34:21.734 --> 00:34:23.334
a lot of small objects,

00:34:23.334 --> 00:34:24.667
yes, they're going
to be allocated

00:34:24.667 --> 00:34:27.033
in the--
in the young generation.

00:34:27.033 --> 00:34:29.534
Um, so if--if when you--

00:34:29.534 --> 00:34:31.133
so when you fill out
the young generation

00:34:31.133 --> 00:34:32.367
and you don't have
any more room,

00:34:32.367 --> 00:34:34.100
you need to garbage collect.

00:34:34.100 --> 00:34:36.834
So at that point,
you look at all the live data

00:34:36.834 --> 00:34:38.567
and then it's true
that if all of your objects

00:34:38.567 --> 00:34:40.033
are still live,

00:34:40.033 --> 00:34:42.234
then you're going to look
through all of them, basically.

00:34:42.234 --> 00:34:44.467
But if they survive,
then you're going to move them

00:34:44.467 --> 00:34:45.701
to the old generation

00:34:45.701 --> 00:34:48.501
and you're not going to look
at them again.

00:34:48.501 --> 00:34:50.501
Yeah. But, yeah,
you're right.

00:34:50.501 --> 00:34:52.334
I mean, as long as you just
allocate,

00:34:52.334 --> 00:34:54.968
uh, and--and keep
everything alive,

00:34:54.968 --> 00:34:56.968
it's going to be allocated
in the young generation,

00:34:56.968 --> 00:34:58.200
and you're going
to scan all of them

00:34:58.200 --> 00:34:59.734
and basically move them
to the old generation

00:34:59.734 --> 00:35:03.033
so you don't have to look
at them the next time.

00:35:03.033 --> 00:35:06.968
Yeah.

00:35:06.968 --> 00:35:08.467
Oh, the timing of these?

00:35:08.467 --> 00:35:13.200
Uh, these are on, uh,
all desktop--desktop machines.

00:35:13.200 --> 00:35:17.400
Uh, and--and, uh, so basically
running inside of Chrome

00:35:17.400 --> 00:35:21.534
on, like, a modern machine--
desktop machine.

00:35:25.200 --> 00:35:27.767
Okay.

00:35:27.767 --> 00:35:32.834
So that covers the part
of how we made V8

00:35:32.834 --> 00:35:36.601
handle, um, property accesses,
function calls,

00:35:36.601 --> 00:35:41.534
and, um, uh, write really well
and be fast at that.

00:35:41.534 --> 00:35:43.400
And how we made V8 scale,

00:35:43.400 --> 00:35:46.000
uh, by using generational
garbage collection.

00:35:46.000 --> 00:35:48.000
So now let me talk
a bit about,

00:35:48.000 --> 00:35:50.100
uh, some recent developments.

00:35:52.400 --> 00:35:54.367
So recently, we've, uh,
we've implemented

00:35:54.367 --> 00:35:57.167
a new regular expression engine
for V8.

00:35:57.167 --> 00:35:59.133
It's called Irregexp.

00:35:59.133 --> 00:36:02.267
Um, so initially, V8,

00:36:02.267 --> 00:36:04.667
um, actually
in the beginning,

00:36:04.667 --> 00:36:06.167
like, completely
from the beginning

00:36:06.167 --> 00:36:08.334
to get V8 up and running,
we use PCRE,

00:36:08.334 --> 00:36:11.601
which is a standard library
for regular expression matching.

00:36:11.601 --> 00:36:14.100
Um, the problem with PCRE

00:36:14.100 --> 00:36:15.801
is that it does not match

00:36:15.801 --> 00:36:18.234
JavaScript regular expression
semantics.

00:36:18.234 --> 00:36:19.467
So you need something else.

00:36:19.467 --> 00:36:22.300
Either you need
to modify PCRE

00:36:22.300 --> 00:36:24.267
or you need to have,
like, a compatibility layer

00:36:24.267 --> 00:36:27.334
that basically translates
PCRE regular expressions--

00:36:27.334 --> 00:36:28.767
sorry, JavaScript regular
expressions

00:36:28.767 --> 00:36:30.767
to their equivalent
PCRE regular expression

00:36:30.767 --> 00:36:32.934
and then use PCRE.

00:36:32.934 --> 00:36:35.801
Um, so luckily,
at WebKit,

00:36:35.801 --> 00:36:39.200
they, uh, they had this problem
as well.

00:36:39.200 --> 00:36:42.334
And they created a library
called JSCRE,

00:36:42.334 --> 00:36:45.033
uh, which matched,
uh, JavaScript semantics.

00:36:45.033 --> 00:36:46.334
So we switched to that.

00:36:46.334 --> 00:36:50.100
So the initial version of V8
used a library,

00:36:50.100 --> 00:36:53.067
uh, from WebKit
called JSCRE.

00:36:53.067 --> 00:36:57.634
Um, so JSCRE did not fit V8
that well

00:36:57.634 --> 00:36:59.801
so it didn't really
perform well.

00:36:59.801 --> 00:37:03.667
And the reason for this
is that, uh, JSCRE,

00:37:03.667 --> 00:37:05.934
uh, expected a different string
representation

00:37:05.934 --> 00:37:08.167
than most strings in V8.

00:37:08.167 --> 00:37:11.634
So in order to actually
hand off a string to JSCRE,

00:37:11.634 --> 00:37:13.968
we would most of the time
have to do a string conversion.

00:37:13.968 --> 00:37:15.734
And that's really costly.

00:37:15.734 --> 00:37:18.901
Um, so this really didn't
perform very well.

00:37:18.901 --> 00:37:22.100
So, uh, and we thought
that we could do--do better.

00:37:22.100 --> 00:37:23.767
And we also thought
that we could do better

00:37:23.767 --> 00:37:25.334
when it comes to algorithms,

00:37:25.334 --> 00:37:27.834
uh, for regular expression
matching.

00:37:27.834 --> 00:37:30.834
Uh, so we implemented our own
regular expression matching,

00:37:30.834 --> 00:37:34.901
which has given us a 10x speedup
on regular expression matching

00:37:34.901 --> 00:37:36.601
on our benchmarks.

00:37:36.601 --> 00:37:39.367
Um, and our new library
implements

00:37:39.367 --> 00:37:41.968
all of, uh, JavaScript
regular expressions.

00:37:41.968 --> 00:37:44.567
So there's no fallback
to any other engines.

00:37:44.567 --> 00:37:48.067
It's a full JavaScript regular
expression implementation.

00:37:50.100 --> 00:37:51.167
So what's in there?

00:37:51.167 --> 00:37:53.300
Um, well, first of all,

00:37:53.300 --> 00:37:56.033
um, the new
regular expression engine

00:37:56.033 --> 00:37:58.467
is based on an automata
approach.

00:37:58.467 --> 00:38:01.200
So from an input regular
expression,

00:38:01.200 --> 00:38:03.200
we build an automaton.

00:38:03.200 --> 00:38:04.567
And then we perform
analysis

00:38:04.567 --> 00:38:07.501
and optimization
on that automaton.

00:38:07.501 --> 00:38:10.300
And then from the resulting
rewritten automaton,

00:38:10.300 --> 00:38:12.167
we generate native code.

00:38:12.167 --> 00:38:13.968
So all of your regular
expressions

00:38:13.968 --> 00:38:18.734
are now executed,
uh, using native code.

00:38:18.734 --> 00:38:23.033
And, um, in our analysis
and optimization phase,

00:38:23.033 --> 00:38:26.734
we use a number of tricks
to, uh, to make,

00:38:26.734 --> 00:38:29.133
um, regular expression matching
cheaper.

00:38:29.133 --> 00:38:31.167
So we try
to avoid backtracking

00:38:31.167 --> 00:38:32.934
and we try
to reorder operations

00:38:32.934 --> 00:38:34.334
so that we perform
the least--

00:38:34.334 --> 00:38:37.167
the least expensive
operations first.

00:38:37.167 --> 00:38:39.400
So when you do regular
expression matching,

00:38:39.400 --> 00:38:42.334
um, most of the time,
you do find a match

00:38:42.334 --> 00:38:44.868
because you actually know
that it's going to be there--

00:38:44.868 --> 00:38:48.934
at--at--that it's going
to be there somewhere.

00:38:48.934 --> 00:38:50.467
But you start
from the beginning, right?

00:38:50.467 --> 00:38:53.567
And maybe you have to scan,
uh, through a lot.

00:38:53.567 --> 00:38:56.400
So basically, the common case
for regular expression matching

00:38:56.400 --> 00:38:57.868
is that you don't have
a match.

00:38:57.868 --> 00:38:59.033
For the first position,

00:38:59.033 --> 00:39:00.567
you're probably not going
to have a match.

00:39:00.567 --> 00:39:01.634
And so on.

00:39:01.634 --> 00:39:03.267
Um, so reordering
operations

00:39:03.267 --> 00:39:05.901
to perform the least expensive
operations first

00:39:05.901 --> 00:39:08.200
gives us an opportunity
to--to fail

00:39:08.200 --> 00:39:09.400
as quickly as possible,

00:39:09.400 --> 00:39:10.934
which is actually
pretty important

00:39:10.934 --> 00:39:14.834
when you do regular expression
matching.

00:39:14.834 --> 00:39:16.667
Okay, so let me, uh,
let me give you

00:39:16.667 --> 00:39:18.934
a couple of examples here.

00:39:18.934 --> 00:39:21.267
Um, so one of the things
that we do,

00:39:21.267 --> 00:39:23.567
uh, which is to avoid
backtracking,

00:39:23.567 --> 00:39:27.801
is to search for common parts
of--in--in alternatives first.

00:39:27.801 --> 00:39:30.601
So if you want to look
for either "Sun" or "Mon,"

00:39:30.601 --> 00:39:33.701
then the common part
of this regular expression

00:39:33.701 --> 00:39:37.267
is that the character
at index two

00:39:37.267 --> 00:39:39.000
is going to be "n."

00:39:39.000 --> 00:39:40.000
Okay.

00:39:40.000 --> 00:39:42.901
So if, uh,
so if you search

00:39:42.901 --> 00:39:45.133
and at the current position,

00:39:45.133 --> 00:39:47.667
the thing that's at index two
is not an "n,"

00:39:47.667 --> 00:39:48.868
then you're done.

00:39:48.868 --> 00:39:50.234
Then you don't have to do
anything more

00:39:50.234 --> 00:39:51.834
because then you know
that it can't match here.

00:39:51.834 --> 00:39:53.367
So you need to move on.

00:39:53.367 --> 00:39:55.400
Okay, so the more traditional
approach here

00:39:55.400 --> 00:39:58.467
would be to start out
by the first alternative.

00:39:58.467 --> 00:40:00.467
So you try to look
for "Sun."

00:40:00.467 --> 00:40:02.834
So you might find S.
You might find u.

00:40:02.834 --> 00:40:05.234
And then
you might not find n.

00:40:05.234 --> 00:40:06.734
Then at that point,
all you know

00:40:06.734 --> 00:40:08.601
is that you didn't match
"Sun."

00:40:08.601 --> 00:40:11.234
So you have to try
the other alternative.

00:40:11.234 --> 00:40:14.033
Uh, and that'll fail,
uh, by looking at the M.

00:40:14.033 --> 00:40:15.367
All right.

00:40:15.367 --> 00:40:18.434
But by, uh, looking
for common parts first,

00:40:18.434 --> 00:40:19.767
we just have to do
one comparison

00:40:19.767 --> 00:40:21.400
and we know that it's not
going to be here

00:40:21.400 --> 00:40:23.234
for any of the alternatives.

00:40:23.234 --> 00:40:26.100
So that avoids
a lot of backtracking.

00:40:26.100 --> 00:40:29.467
Um, another nice thing

00:40:29.467 --> 00:40:31.968
about the--our new regular
expression engine

00:40:31.968 --> 00:40:34.968
is that, uh, in V8, we have
an ASCII representation

00:40:34.968 --> 00:40:36.501
for most strings.

00:40:36.501 --> 00:40:38.734
Uh, because a lot of strings
that are actually used

00:40:38.734 --> 00:40:41.334
in JavaScript programs
are still ASCII strings.

00:40:41.334 --> 00:40:42.334
Uh, and that means

00:40:42.334 --> 00:40:44.000
that in a single compare
instruction,

00:40:44.000 --> 00:40:46.467
you can actually, uh,

00:40:46.467 --> 00:40:48.667
match up to four characters
at a time.

00:40:48.667 --> 00:40:51.000
So in order to search
for "foobar,"

00:40:51.000 --> 00:40:54.033
you'll just, um,
in an ASCII string,

00:40:54.033 --> 00:40:58.367
you'll just load four bytes
into Word

00:40:58.367 --> 00:40:59.767
and then you'll do a compare

00:40:59.767 --> 00:41:02.534
against the bit parent
that's "foob."

00:41:02.534 --> 00:41:05.767
Um, and then you're going
to load the next two characters,

00:41:05.767 --> 00:41:07.267
which is two bytes,

00:41:07.267 --> 00:41:10.534
and then you're going to do
a two-byte compare for those.

00:41:10.534 --> 00:41:13.868
Um, so that's really nice
to have the ability

00:41:13.868 --> 00:41:15.868
to actually match
four characters at a time.

00:41:15.868 --> 00:41:18.400
That's really fast.

00:41:18.400 --> 00:41:20.634
Okay, so here's an example
that shows you something

00:41:20.634 --> 00:41:21.934
about reordering.

00:41:21.934 --> 00:41:23.667
Um, so here's
a regular expression

00:41:23.667 --> 00:41:25.133
that looks for "foobar"

00:41:25.133 --> 00:41:27.267
that can be spelled
either with a normal F

00:41:27.267 --> 00:41:28.334
or a capital F

00:41:28.334 --> 00:41:30.534
and a normal B
or a capital B.

00:41:30.534 --> 00:41:33.634
And then it's going to capture
whatever was matched.

00:41:33.634 --> 00:41:36.968
Okay, so we want to perform
the cheap operations first.

00:41:36.968 --> 00:41:39.968
So we're going to try
to begin by matching "oo"

00:41:39.968 --> 00:41:42.067
and "ar"
at position one and four

00:41:42.067 --> 00:41:43.234
because those are just,
like,

00:41:43.234 --> 00:41:45.067
simple character
comparisons.

00:41:45.067 --> 00:41:46.367
And those are really quick.

00:41:46.367 --> 00:41:47.434
And if one of them fail,

00:41:47.434 --> 00:41:49.567
well, then we can skip
all the rest.

00:41:49.567 --> 00:41:51.000
Okay, so the next thing
we're going to do

00:41:51.000 --> 00:41:52.601
is look for either F
or a capital F

00:41:52.601 --> 00:41:53.834
at position zero.

00:41:53.834 --> 00:41:55.300
And we're going to look for a B
or a capital B

00:41:55.300 --> 00:41:56.667
at position three.

00:41:56.667 --> 00:41:58.501
And then finally,
we're going to--to perform

00:41:58.501 --> 00:42:00.367
the actual capture
operation.

00:42:00.367 --> 00:42:03.968
Um, so the reordering here
is really just to get

00:42:03.968 --> 00:42:06.567
the cheap operations first
because that allows us

00:42:06.567 --> 00:42:08.968
to fail early and quickly.

00:42:11.400 --> 00:42:12.934
Good.

00:42:12.934 --> 00:42:15.267
So that's, uh, that's our new
regular expression engine.

00:42:15.267 --> 00:42:17.200
So another thing
that we've done recently

00:42:17.200 --> 00:42:19.501
is to change our compiler.

00:42:19.501 --> 00:42:22.767
Uh, so the original compiler
was extremely simple.

00:42:22.767 --> 00:42:25.300
Uh, just build an abstract
syntax tree.

00:42:25.300 --> 00:42:27.801
It did no static analysis
of any kind.

00:42:27.801 --> 00:42:29.467
It did no
register allocation.

00:42:29.467 --> 00:42:31.767
So it just built an abstract
syntax tree.

00:42:31.767 --> 00:42:33.701
And one pass
over the abstract syntax tree,

00:42:33.701 --> 00:42:35.133
it--it would generate
a code.

00:42:35.133 --> 00:42:36.634
Period.

00:42:36.634 --> 00:42:39.467
Um, so we've now implemented
a new compile infrastructure,

00:42:39.467 --> 00:42:41.734
which performs register
allocation.

00:42:41.734 --> 00:42:43.300
It's still
a one-pass compiler.

00:42:43.300 --> 00:42:45.234
Um, so for JavaScript,

00:42:45.234 --> 00:42:48.601
since you get all of your code
over the network,

00:42:48.601 --> 00:42:50.067
you need
your JavaScript engine

00:42:50.067 --> 00:42:53.200
to--to be able
to run the code quickly.

00:42:53.200 --> 00:42:56.934
So you need to, uh,
to have a fast compiler.

00:42:56.934 --> 00:42:58.267
So it's still
a one-pass compiler.

00:42:58.267 --> 00:42:59.901
But now it actually
does its best

00:42:59.901 --> 00:43:02.367
to, uh, to do register
allocation as well.

00:43:02.367 --> 00:43:04.133
And--and we're pretty
excited about this.

00:43:04.133 --> 00:43:06.400
And we think that it'll--
that it'll form the basis

00:43:06.400 --> 00:43:10.300
for further native code
optimizations in--in V8.

00:43:13.133 --> 00:43:16.033
Okay, so that's what I wanted
to say about recent stuff.

00:43:16.033 --> 00:43:18.367
Um, so now I'm going to talk
to something

00:43:18.367 --> 00:43:19.934
that's quite different,

00:43:19.934 --> 00:43:22.167
uh, but that I think
is really, really important.

00:43:22.167 --> 00:43:26.767
Namely how well
your JavaScript engines scale

00:43:26.767 --> 00:43:29.734
to deal with very large
applications.

00:43:29.734 --> 00:43:34.267
Um, so why is that
important?

00:43:34.267 --> 00:43:37.701
Well, so web applications
are becoming bigger and bigger

00:43:37.701 --> 00:43:39.501
and more complex.

00:43:39.501 --> 00:43:41.634
And with
the increased complexity,

00:43:41.634 --> 00:43:43.267
you get more objects.

00:43:43.267 --> 00:43:46.534
And more objects
put extra, uh, stress

00:43:46.534 --> 00:43:48.701
on your memory management
system.

00:43:48.701 --> 00:43:52.400
So if you do not have
a system that scale

00:43:52.400 --> 00:43:53.601
to handle all of
these objects,

00:43:53.601 --> 00:43:55.701
your performance
will suffer.

00:43:55.701 --> 00:44:00.000
Um, so not only are applications
becoming bigger,

00:44:00.000 --> 00:44:01.801
which means that they get
more objects,

00:44:01.801 --> 00:44:04.968
but also, a lot of browsers
are still single process.

00:44:04.968 --> 00:44:06.968
And most single process
browsers,

00:44:06.968 --> 00:44:09.634
um, when you start up
multiple tabs

00:44:09.634 --> 00:44:11.334
with multiple applications,

00:44:11.334 --> 00:44:13.534
all of your JavaScript objects
are going to be allocated

00:44:13.534 --> 00:44:16.334
in the same JavaScript
object heap.

00:44:16.334 --> 00:44:19.467
Which means that you actually
get a lot of objects

00:44:19.467 --> 00:44:21.300
in your JavaScript heap.

00:44:21.300 --> 00:44:24.267
So if your memory management
system has to look

00:44:24.267 --> 00:44:27.701
at all objects
for every garbage collection,

00:44:27.701 --> 00:44:29.901
that's going to hurt you.

00:44:29.901 --> 00:44:31.934
Um, right.

00:44:31.934 --> 00:44:34.267
So it is actually
really important

00:44:34.267 --> 00:44:38.534
that your JavaScript execution
is--is good

00:44:38.534 --> 00:44:40.367
and is fast in these situations
as well.

00:44:40.367 --> 00:44:41.667
And it's important now.

00:44:41.667 --> 00:44:44.100
It's not--it's not only
for, like, the future.

00:44:44.100 --> 00:44:45.767
It's also important now.

00:44:45.767 --> 00:44:47.801
Um, right.

00:44:47.801 --> 00:44:50.267
So our approach
to scalability

00:44:50.267 --> 00:44:52.267
is to use generational
garbage collection,

00:44:52.267 --> 00:44:54.100
as I've just
told you about.

00:44:54.100 --> 00:44:57.434
Um, right.

00:44:57.434 --> 00:45:00.234
So I've done a little
experiment here.

00:45:00.234 --> 00:45:02.968
And I should say right now

00:45:02.968 --> 00:45:05.200
that this is really,
really artificial.

00:45:05.200 --> 00:45:08.100
So take all of this
with a grain of salt.

00:45:08.100 --> 00:45:10.701
But it does--it does
illustrate my point.

00:45:10.701 --> 00:45:13.434
Um, so my scalability
experiment,

00:45:13.434 --> 00:45:16.167
um, was to take
the raytrace benchmark

00:45:16.167 --> 00:45:19.067
from the V8 benchmark suite
and then run it

00:45:19.067 --> 00:45:20.701
a number of times.

00:45:20.701 --> 00:45:21.901
And on each iteration,

00:45:21.901 --> 00:45:24.033
I'm going to allocate
some extra memory

00:45:24.033 --> 00:45:25.868
in the JavaScript heap.

00:45:25.868 --> 00:45:28.667
Um, and with V8,
the data structure

00:45:28.667 --> 00:45:30.000
that I'm going to allocate,

00:45:30.000 --> 00:45:32.534
I'm going to add one megabyte
of extra live data

00:45:32.534 --> 00:45:33.934
per iteration.

00:45:33.934 --> 00:45:36.634
And then I'm just going
to map out the performance--

00:45:36.634 --> 00:45:39.734
so the benchmark score--
over these iterations

00:45:39.734 --> 00:45:43.767
with an increased amount
of objects in your heap.

00:45:43.767 --> 00:45:47.701
And the result looks like this
for, uh, for three browsers.

00:45:47.701 --> 00:45:50.501
Um, so as you can see,

00:45:50.501 --> 00:45:52.200
the performance
characteristics here

00:45:52.200 --> 00:45:53.834
are quite different.

00:45:53.834 --> 00:45:56.133
Um, so what we want
to get to here

00:45:56.133 --> 00:45:59.400
is basically having
a straight line.

00:45:59.400 --> 00:46:00.667
So as you can see,

00:46:00.667 --> 00:46:04.634
uh, Chromium running V8
is not getting a straight line.

00:46:04.634 --> 00:46:07.868
But it's also not, like,
dropping completely.

00:46:07.868 --> 00:46:10.601
Um, and that's--that's pretty
much what you get

00:46:10.601 --> 00:46:13.267
when you use a generational
garbage collection like we do.

00:46:13.267 --> 00:46:16.100
So it does cost
to have larger heaps,

00:46:16.100 --> 00:46:19.033
but your performance
does not completely degrade.

00:46:19.033 --> 00:46:21.033
Um, so another
interesting thing

00:46:21.033 --> 00:46:22.200
that you can see
from this graph

00:46:22.200 --> 00:46:24.767
is that you have, like,
down spikes.

00:46:24.767 --> 00:46:27.267
Um, so those down spikes
are when you get

00:46:27.267 --> 00:46:29.400
to the full compacting
collections.

00:46:29.400 --> 00:46:30.701
So if you actually get
to a point

00:46:30.701 --> 00:46:33.067
where you need to do
a full compacting collection,

00:46:33.067 --> 00:46:37.200
that's going to be visible
on graphs like, uh, like these.

00:46:37.200 --> 00:46:38.300
So the interesting thing here

00:46:38.300 --> 00:46:42.234
is that, like, Firefox 3.5,
beta 4,

00:46:42.234 --> 00:46:43.400
uh, seems to be doing
very well

00:46:43.400 --> 00:46:45.968
when it comes to scalability.

00:46:45.968 --> 00:46:48.167
Uh, the benchmark score
is not that impressive

00:46:48.167 --> 00:46:49.434
on the other hand.

00:46:49.434 --> 00:46:52.901
Uh, Safari is doing really well
on the benchmark score.

00:46:52.901 --> 00:46:54.667
Uh, but it seems
that there's something

00:46:54.667 --> 00:46:57.934
like a full scan of the heap
on each garbage collection

00:46:57.934 --> 00:47:01.801
because if you add extra data
to the heap,

00:47:01.801 --> 00:47:04.567
then already at, like,
five megabytes,

00:47:04.567 --> 00:47:07.033
they're at a third
of the speed that they had

00:47:07.033 --> 00:47:11.267
with, uh, with a freshly,
uh, started browser.

00:47:11.267 --> 00:47:13.300
Um, so I think
this really matters

00:47:13.300 --> 00:47:16.133
because this is--I mean,
this is a benchmark, right?

00:47:16.133 --> 00:47:18.901
So this is a benchmark
that's in our benchmark suite.

00:47:18.901 --> 00:47:20.601
And this tells you something
about how valid

00:47:20.601 --> 00:47:23.734
those benchmark results are
in the real world.

00:47:23.734 --> 00:47:27.567
So if you have
a single process browser

00:47:27.567 --> 00:47:29.133
and you open multiple tabs,

00:47:29.133 --> 00:47:31.067
that's going to lead
to a lot of objects.

00:47:31.067 --> 00:47:33.801
And, uh, and then
your performance

00:47:33.801 --> 00:47:35.734
is going to be more like
what's on the right

00:47:35.734 --> 00:47:38.367
of this, uh,
of this graph.

00:47:38.367 --> 00:47:40.534
So I think that--that we need
to put some more emphasis

00:47:40.534 --> 00:47:41.734
on this.

00:47:41.734 --> 00:47:44.734
Uh, and I think
that it's really important,

00:47:44.734 --> 00:47:48.133
um, because it's--
it's really important for--

00:47:48.133 --> 00:47:50.234
for the real live
situations,

00:47:50.234 --> 00:47:53.567
having many tabs
or having big applications.

00:47:53.567 --> 00:47:56.100
Um, so in order
to put a bit of focus on this,

00:47:56.100 --> 00:48:00.133
uh, we've, um, we've published
a new benchmark

00:48:00.133 --> 00:48:01.934
in the V8 benchmark suite.

00:48:01.934 --> 00:48:04.334
Which is again completely
artificial.

00:48:04.334 --> 00:48:08.133
So it builds a splay tree,
uh, roughly the size

00:48:08.133 --> 00:48:10.601
of, like, 30 megabytes,
something like that.

00:48:10.601 --> 00:48:12.734
And then it just performs
operations on the splay tree.

00:48:12.734 --> 00:48:14.534
Which means that it allocates
new nodes,

00:48:14.534 --> 00:48:16.100
it modifies the splay tree,

00:48:16.100 --> 00:48:19.934
and it garbage collects, uh,
nodes that have been removed.

00:48:19.934 --> 00:48:21.300
Um, right,

00:48:21.300 --> 00:48:23.067
so we really want to try
to, like,

00:48:23.067 --> 00:48:24.801
put some emphasis on this.

00:48:24.801 --> 00:48:27.701
Uh, we want scalability.
We want browsers to be scalable.

00:48:27.701 --> 00:48:30.434
We want people to actually get
the JavaScript performance

00:48:30.434 --> 00:48:31.801
that they expect

00:48:31.801 --> 00:48:35.133
when they run the JavaScript
benchmarks out there.

00:48:35.133 --> 00:48:38.567
Uh, those should basically
reflect what you get in reality.

00:48:38.567 --> 00:48:41.267
So again, this experiment
is completely artificial.

00:48:41.267 --> 00:48:44.868
Uh, if you want to try this,
uh, take your browsers,

00:48:44.868 --> 00:48:47.901
load a number of tabs,
run benchmarks,

00:48:47.901 --> 00:48:49.234
um, or try something else.

00:48:49.234 --> 00:48:51.000
Try writing really big
web applications

00:48:51.000 --> 00:48:53.267
and see how well,
uh, JavaScript behaves

00:48:53.267 --> 00:48:56.934
under a bit of stress.

00:48:56.934 --> 00:49:00.567
Good. So that finishes
my scalability rant.

00:49:00.567 --> 00:49:02.300
Um, good.

00:49:02.300 --> 00:49:03.334
So let me tell you a bit

00:49:03.334 --> 00:49:04.801
about the performance
bottlenecks

00:49:04.801 --> 00:49:07.734
that I see for--
for V8 currently.

00:49:07.734 --> 00:49:13.701
Um, so one of the bottlenecks
that we have is that, um,

00:49:13.701 --> 00:49:17.667
we only generate
one, uh, fully general version

00:49:17.667 --> 00:49:19.801
of all code that we generate.

00:49:19.801 --> 00:49:21.667
That means that we are not
basically allowed

00:49:21.667 --> 00:49:24.267
to have that many assumptions
in our code.

00:49:24.267 --> 00:49:28.734
Because we need to handle
all the special cases

00:49:28.734 --> 00:49:31.667
in the code that we generate.

00:49:31.667 --> 00:49:33.334
So that means that we have
a lot of checking

00:49:33.334 --> 00:49:35.968
for basically exceptional
situations in our code,

00:49:35.968 --> 00:49:39.934
like situations that basically
do not happen in reality.

00:49:39.934 --> 00:49:43.634
Um, so one thing
that we should explore

00:49:43.634 --> 00:49:47.601
is generating multiple versions
of the same code.

00:49:47.601 --> 00:49:49.367
So generating--
uh, in the beginning,

00:49:49.367 --> 00:49:52.968
generating a really optimized
version of the code

00:49:52.968 --> 00:49:55.534
that avoids a lot
of the checking.

00:49:55.534 --> 00:49:57.767
And then if some
of our checks fail,

00:49:57.767 --> 00:50:00.701
then basically bail out
to a slower version of the code.

00:50:00.701 --> 00:50:03.200
So at that point, generate
another version of the code.

00:50:03.200 --> 00:50:06.901
So that should give us
a big performance gain.

00:50:06.901 --> 00:50:11.501
Um, another,
uh, bottleneck

00:50:11.501 --> 00:50:15.067
is that our use
of inline caching

00:50:15.067 --> 00:50:18.400
is based on calls to stubs.

00:50:18.400 --> 00:50:20.734
So we generate these stubs

00:50:20.734 --> 00:50:22.334
and then we use,
like, a call instruction

00:50:22.334 --> 00:50:24.234
to actually get
to that code.

00:50:24.234 --> 00:50:28.501
Um, and that's good
for a code size

00:50:28.501 --> 00:50:30.601
because we just have
a call instruction in there.

00:50:30.601 --> 00:50:32.934
But it's not necessarily
the best thing we can do

00:50:32.934 --> 00:50:34.133
for our performance.

00:50:34.133 --> 00:50:35.400
So in some situations,

00:50:35.400 --> 00:50:38.667
we might actually want
to inline the code instead

00:50:38.667 --> 00:50:40.501
directly in the code stream.

00:50:40.501 --> 00:50:42.434
So instead of having
the call,

00:50:42.434 --> 00:50:44.234
we can just have the code
directly there.

00:50:44.234 --> 00:50:46.434
Uh, and that
actually matters.

00:50:46.434 --> 00:50:51.234
Uh, and we have done that
for a couple of simple cases

00:50:51.234 --> 00:50:52.634
of loads.

00:50:52.634 --> 00:50:54.167
And it really does matter.

00:50:54.167 --> 00:50:56.067
So the downside to that
is code size.

00:50:56.067 --> 00:51:01.400
So your code becomes bigger
when you actually inline.

00:51:01.400 --> 00:51:02.734
Okay, so another issue,

00:51:02.734 --> 00:51:04.901
which is basically,
uh, related

00:51:04.901 --> 00:51:07.300
to doing more inlining

00:51:07.300 --> 00:51:08.968
is our write barrier.

00:51:08.968 --> 00:51:12.167
Um, so since we use
generational garbage collection,

00:51:12.167 --> 00:51:15.067
um, and we, uh,

00:51:15.067 --> 00:51:18.300
garbage collect
the young generation often,

00:51:18.300 --> 00:51:20.567
we need to know
about all pointers

00:51:20.567 --> 00:51:22.234
into the young generation.

00:51:22.234 --> 00:51:23.934
And that includes
all of the pointers

00:51:23.934 --> 00:51:25.667
from objects
in the old generation

00:51:25.667 --> 00:51:27.801
to pointers
in the new generation.

00:51:27.801 --> 00:51:30.133
And that means that whenever
we store a pointer

00:51:30.133 --> 00:51:31.968
in an old generation object,

00:51:31.968 --> 00:51:33.767
we might have
to record somewhere

00:51:33.767 --> 00:51:35.968
that this object
is actually referring

00:51:35.968 --> 00:51:37.534
to a new space object.

00:51:37.534 --> 00:51:39.801
And that's done by something
called a write barrier.

00:51:39.801 --> 00:51:41.467
And right now,

00:51:41.467 --> 00:51:42.868
our write barrier is a bit
complicated.

00:51:42.868 --> 00:51:46.901
It has a lot of instructions,
and it's a bit slow.

00:51:46.901 --> 00:51:48.968
So we should experiment
with--with new ways

00:51:48.968 --> 00:51:50.868
of implementing
our write barrier.

00:51:50.868 --> 00:51:53.334
Um, and the reason
why that's related

00:51:53.334 --> 00:51:55.667
to, uh, inlining more code

00:51:55.667 --> 00:51:58.334
is that since our write
barrier's pretty big,

00:51:58.334 --> 00:52:01.868
it's not really practical
to inline stores

00:52:01.868 --> 00:52:03.767
directly in the code
because all stores

00:52:03.767 --> 00:52:06.601
need to have the write barrier
inline as well.

00:52:06.601 --> 00:52:08.801
And that will lead
to a lot of, uh,

00:52:08.801 --> 00:52:12.801
of code size, uh, increase.

00:52:12.801 --> 00:52:14.133
Okay,
and the last thing here,

00:52:14.133 --> 00:52:15.901
I don't really want
to talk much about.

00:52:15.901 --> 00:52:18.100
But--but basically,
there are a lot of global loads

00:52:18.100 --> 00:52:19.567
in JavaScript code.

00:52:19.567 --> 00:52:22.801
And we handle global loads
the same way as any other loads.

00:52:22.801 --> 00:52:24.300
And basically,
we don't have to.

00:52:24.300 --> 00:52:26.767
So we could generate
better code for that.

00:52:26.767 --> 00:52:29.200
Um, so another thing
that I didn't put up here,

00:52:29.200 --> 00:52:31.033
but which is also
really important,

00:52:31.033 --> 00:52:32.801
is, uh, DOM performance.

00:52:32.801 --> 00:52:35.801
And basically, we haven't
done much, uh, in that area

00:52:35.801 --> 00:52:37.601
to really,
really optimize it.

00:52:37.601 --> 00:52:39.601
Um, so that's another thing
that we should do.

00:52:39.601 --> 00:52:42.300
Uh, we should look more
at DOM performance.

00:52:42.300 --> 00:52:45.767
So the interaction
between JavaScript

00:52:45.767 --> 00:52:48.300
and--and the DOM.

00:52:51.000 --> 00:52:52.000
Good.

00:52:52.000 --> 00:52:53.634
So to summarize,

00:52:53.634 --> 00:52:55.601
V8 was designed
both for speed

00:52:55.601 --> 00:52:57.934
and for scalability.

00:52:57.934 --> 00:53:00.367
Uh, the goal of V8 is
to raise the performance bar

00:53:00.367 --> 00:53:01.634
for JavaScript.

00:53:01.634 --> 00:53:03.634
So we want to continue
to push

00:53:03.634 --> 00:53:07.667
and see if we can make
JavaScript even faster.

00:53:07.667 --> 00:53:12.667
And, um, we don't want
to just push

00:53:12.667 --> 00:53:14.634
for Google
and for Google Chrome.

00:53:14.634 --> 00:53:17.934
We really want to--
to try to see if we can--

00:53:17.934 --> 00:53:22.667
if we can inspire other
JavaScript vendors as well.

00:53:22.667 --> 00:53:25.534
And therefore,
our full source code

00:53:25.534 --> 00:53:28.200
is available
under a BSD license.

00:53:28.200 --> 00:53:29.501
And, unfortunately,

00:53:29.501 --> 00:53:31.534
the URL scrolled out of
my slides here.

00:53:31.534 --> 00:53:35.167
But it's at
code.google.com/p/v8.

00:53:35.167 --> 00:53:37.167
Should be pretty easy
to find.

00:53:37.167 --> 00:53:39.467
So the graph
that I've put up here

00:53:39.467 --> 00:53:40.868
that I'd like to end with

00:53:40.868 --> 00:53:44.100
is the, um,
is what has happened to

00:53:44.100 --> 00:53:46.434
the V8 benchmark score
over time.

00:53:46.434 --> 00:53:49.701
So, um, the versions
that you see on the left

00:53:49.701 --> 00:53:51.367
are Google Chrome versions.

00:53:51.367 --> 00:53:54.667
So this basically started
in September of 2008

00:53:54.667 --> 00:53:56.901
with a 1.0 beta.

00:53:56.901 --> 00:53:59.100
And since then,
we've just continued to push.

00:53:59.100 --> 00:54:02.234
And we will continue
to do that.

00:54:02.234 --> 00:54:04.300
So that's all.
Thanks.

00:54:04.300 --> 00:54:08.234
[applause]

00:54:11.701 --> 00:54:13.934
Questions.

00:54:13.934 --> 00:54:16.467
Yes.

00:54:23.901 --> 00:54:25.167
Yeah, that's a good point.

00:54:25.167 --> 00:54:28.300
So the question is,
in my example of hidden classes

00:54:28.300 --> 00:54:31.834
and hidden class transitions,
I added first X and then Y.

00:54:31.834 --> 00:54:34.901
So what would happen
if I added Y first and then X?

00:54:34.901 --> 00:54:37.601
And the, uh, and the answer is
that that would be

00:54:37.601 --> 00:54:39.667
a different hidden class.

00:54:39.667 --> 00:54:43.234
Um, so, uh,
it's really common

00:54:43.234 --> 00:54:44.767
for objects to be allocat--

00:54:44.767 --> 00:54:47.467
to be generated
in exactly the same way.

00:54:47.467 --> 00:54:49.100
Um, so that's basically
what saves us.

00:54:49.100 --> 00:54:50.501
But you're right.

00:54:50.501 --> 00:54:52.434
They're objects that basically
have the same structure,

00:54:52.434 --> 00:54:54.167
namely a Y-property
and an X-property,

00:54:54.167 --> 00:54:57.167
um, they can actually
get completely different maps

00:54:57.167 --> 00:55:00.167
if you first add Y and then X
and then in another place

00:55:00.167 --> 00:55:01.400
add X and then Y.

00:55:01.400 --> 00:55:05.667
Those would be separate
hidden classes.

00:55:05.667 --> 00:55:10.601
Yeah.

00:55:10.601 --> 00:55:12.467
Okay. So what if you declare
an object

00:55:12.467 --> 00:55:14.767
through an object literal
and not through a function?

00:55:14.767 --> 00:55:16.434
Uh, that's not going
to be a problem

00:55:16.434 --> 00:55:18.767
because object literals
are also created

00:55:18.767 --> 00:55:21.400
based on a function--
namely the object function.

00:55:21.400 --> 00:55:24.567
And the object function
has an initial map.

00:55:24.567 --> 00:55:28.567
Um, so basically,
uh, the same thing works.

00:55:28.567 --> 00:55:30.901
Yeah.

00:55:35.968 --> 00:55:37.100
Yeah, that's a good question.

00:55:37.100 --> 00:55:38.434
So the question is

00:55:38.434 --> 00:55:42.133
do we only apply this
to user-defined objects

00:55:42.133 --> 00:55:45.267
or do we also use this
on, like, built-in stuff

00:55:45.267 --> 00:55:47.501
like date, math, number,
whatever?

00:55:47.501 --> 00:55:49.467
And the answer is that,
yes, we also do it

00:55:49.467 --> 00:55:50.801
on built-in stuff.

00:55:50.801 --> 00:55:54.033
Uh, and to go a bit deeper,

00:55:54.033 --> 00:55:56.901
our built-in stuff is actually
implemented in JavaScript.

00:55:56.901 --> 00:55:59.434
So we don't implement that
in C++.

00:55:59.434 --> 00:56:02.133
We actually have it implemented
in JavaScript--a lot of it.

00:56:02.133 --> 00:56:06.200
Um, so that means that basically
the same thing applies.

00:56:06.200 --> 00:56:08.767
So it's going to go through
exactly the same path.

00:56:08.767 --> 00:56:12.534
And the cool thing about that
is that if we improve

00:56:12.534 --> 00:56:14.834
our overall JavaScript
performance,

00:56:14.834 --> 00:56:18.334
we're also going to improve
the speed of our libraries.

00:56:18.334 --> 00:56:20.868
Um, so that's one cool thing
about having libraries

00:56:20.868 --> 00:56:22.367
written in JavaScript.

00:56:22.367 --> 00:56:25.167
Another cool thing
is that, um,

00:56:25.167 --> 00:56:29.801
uh, it's really easy and quick
to go change stuff.

00:56:29.801 --> 00:56:32.734
Um, so it also does lead to--

00:56:32.734 --> 00:56:34.868
to some extra complication

00:56:34.868 --> 00:56:37.334
in the sense that in order
to set up

00:56:37.334 --> 00:56:39.634
your math, number,
date objects,

00:56:39.634 --> 00:56:43.067
you actually have to look
at JavaScript code.

00:56:43.067 --> 00:56:44.968
You actually have to compile
JavaScript code.

00:56:44.968 --> 00:56:48.067
So to overcome that,
uh, we--we use something

00:56:48.067 --> 00:56:49.901
called snapshotting.

00:56:49.901 --> 00:56:53.033
So, um, yes,

00:56:53.033 --> 00:56:54.534
this is becoming
a longer explanation.

00:56:54.534 --> 00:56:56.100
Sorry about that.

00:56:56.100 --> 00:56:57.767
So--so basically,
in the beginning,

00:56:57.767 --> 00:56:59.868
the first time that we--
that we, uh--

00:56:59.868 --> 00:57:01.200
so when we build V8,

00:57:01.200 --> 00:57:04.467
we start up V8 once,
we load the basic libraries.

00:57:04.467 --> 00:57:07.667
That gives us a heap
that contains all of the code

00:57:07.667 --> 00:57:09.033
for our basic libraries.

00:57:09.033 --> 00:57:12.968
We dump that heap
as a binary image to a file.

00:57:12.968 --> 00:57:16.734
And then we integrate
that binary data

00:57:16.734 --> 00:57:19.167
into a new version of V8
that we built

00:57:19.167 --> 00:57:20.767
so that when you start V8,

00:57:20.767 --> 00:57:22.868
even though your libraries
are written in JavaScript,

00:57:22.868 --> 00:57:25.534
you don't have to--to pass
and compile any JavaScript code

00:57:25.534 --> 00:57:26.701
to get your native libraries.

00:57:26.701 --> 00:57:29.000
All you do is just slurp
in that binary data

00:57:29.000 --> 00:57:31.634
and you're up and running.

00:57:31.634 --> 00:57:33.267
Yeah.

00:57:40.067 --> 00:57:41.200
So the question is

00:57:41.200 --> 00:57:43.200
"if there are any JavaScript
design patterns

00:57:43.200 --> 00:57:46.100
that I know of that perform
better than others."

00:57:46.100 --> 00:57:49.801
Um, so my answer to that
would be no.

00:57:49.801 --> 00:57:52.033
But also, my answer to that
should be that,

00:57:52.033 --> 00:57:55.267
uh, that it shouldn't matter
that much.

00:57:55.267 --> 00:57:57.767
So basically, you shouldn't
worry about it.

00:57:57.767 --> 00:58:00.167
We should hopefully be able
to make it fast.

00:58:00.167 --> 00:58:02.834
Um, but as you've seen
with the techniques

00:58:02.834 --> 00:58:04.267
that we used here,

00:58:04.267 --> 00:58:08.167
we're kind of, uh, somehow
relying on user build to--

00:58:08.167 --> 00:58:10.400
to do something
that's, like, well structured,

00:58:10.400 --> 00:58:13.133
uses abstractions,
and does not,

00:58:13.133 --> 00:58:17.834
like, uh, try
to be overly general

00:58:17.834 --> 00:58:20.367
and try to have, like, code
that's, like, really using

00:58:20.367 --> 00:58:21.701
a million different--

00:58:21.701 --> 00:58:23.634
operating on a million
different types.

00:58:23.634 --> 00:58:27.367
But, um, but that shouldn't
really be an issue

00:58:27.367 --> 00:58:29.067
because in--

00:58:29.067 --> 00:58:30.434
in most application code
that you write,

00:58:30.434 --> 00:58:32.501
you might have parts
of the code that's like that

00:58:32.501 --> 00:58:33.801
that's really generic

00:58:33.801 --> 00:58:37.200
and then you have most
of your code, which is not.

00:58:37.200 --> 00:58:38.968
So basically, you shouldn't
have to worry about it.

00:58:38.968 --> 00:58:42.100
That should be, uh,
that should be us worrying.

00:58:53.767 --> 00:58:55.167
Oh.

00:58:59.167 --> 00:59:01.801
Okay, so, uh,
the question is if I can--

00:59:01.801 --> 00:59:03.067
can give some information

00:59:03.067 --> 00:59:06.367
about other browsers
that are starting to use--

00:59:06.367 --> 00:59:07.868
that are using
these techniques

00:59:07.868 --> 00:59:11.167
and, uh, also if it's being
fed back to WebKit.

00:59:11.167 --> 00:59:12.167
Yeah.

00:59:12.167 --> 00:59:15.467
So, um...

00:59:15.467 --> 00:59:19.167
so, uh,
Apple's JavaScript engine,

00:59:19.167 --> 00:59:21.634
I guess it's called Nitro
by now,

00:59:21.634 --> 00:59:25.000
uh, is using
these techniques as well,

00:59:25.000 --> 00:59:26.767
which is really cool.

00:59:26.767 --> 00:59:28.300
So I think that's--
that's great.

00:59:28.300 --> 00:59:30.133
And they're getting
great performance gains

00:59:30.133 --> 00:59:32.968
the same way that we did
by using these techniques.

00:59:32.968 --> 00:59:35.501
So they use, uh,
what we call hidden classes

00:59:35.501 --> 00:59:37.934
and inline caching as well.

00:59:37.934 --> 00:59:39.701
Uh, I think they call
their hidden classes

00:59:39.701 --> 00:59:41.267
structure IDs or something
like that.

00:59:41.267 --> 00:59:42.467
But they use
the same techniques,

00:59:42.467 --> 00:59:43.667
which is really cool.

00:59:43.667 --> 00:59:45.968
Um, feeding it back
to WebKit,

00:59:45.968 --> 00:59:48.701
yes, we are doing that
in the sense

00:59:48.701 --> 00:59:51.467
that the binding layer,
so the--

00:59:51.467 --> 00:59:55.000
the layer that binds V8
into the DOM

00:59:55.000 --> 00:59:57.367
is being upstreamed
to WebKit.

00:59:57.367 --> 00:59:59.367
So that actually lives
at WebKit now.

00:59:59.367 --> 01:00:03.567
Um, so hopefully it should be
fairly easy going forward

01:00:03.567 --> 01:00:08.434
to use V8 instead of Nitro
if you want to in WebKit.

01:00:08.434 --> 01:00:11.367
man: Any--over here.
Over here.

01:00:11.367 --> 01:00:12.667
Ager: Oh, yes.

01:00:12.667 --> 01:00:14.634
man:
Any performance boosts

01:00:14.634 --> 01:00:18.467
to the lambda
functional closures

01:00:18.467 --> 01:00:22.734
optimizing
the call stacks?

01:00:22.734 --> 01:00:24.400
Ager: I'm not sure
I understand the question.

01:00:24.400 --> 01:00:26.167
Could you repeat, please?

01:00:26.167 --> 01:00:27.467
man: Is there
a performance boost

01:00:27.467 --> 01:00:32.801
to the handling of the lambda
functions closures?

01:00:32.801 --> 01:00:34.667
Ager: Oh, if we have
any performance boosts

01:00:34.667 --> 01:00:36.467
on--on closures.

01:00:36.467 --> 01:00:39.667
Uh...

01:00:39.667 --> 01:00:41.501
so...

01:00:41.501 --> 01:00:43.767
well, basically,
I mean, that code is handled

01:00:43.767 --> 01:00:45.133
like--like all other code.

01:00:45.133 --> 01:00:46.934
So it gets, like,
the same kind of benefits

01:00:46.934 --> 01:00:48.534
that--that the rest
of the code does.

01:00:48.534 --> 01:00:50.067
So--so yes.

01:00:54.801 --> 01:00:56.767
So I think we're running
out of time.

01:00:56.767 --> 01:00:58.534
So--so I think
I should stop now.

01:00:58.534 --> 01:01:01.701
So you're all welcome
to come talk to me afterwards.

01:01:01.701 --> 01:01:05.033
So if you have other questions,
please come talk to me.

01:01:05.033 --> 01:01:07.901
[applause]

