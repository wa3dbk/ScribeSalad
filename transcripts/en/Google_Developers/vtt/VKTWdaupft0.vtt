WEBVTT
Kind: captions
Language: en

00:00:03.060 --> 00:00:05.141
Good morning.

00:00:05.141 --> 00:00:05.890
I'm Brian McQuade.

00:00:05.890 --> 00:00:07.306
I'm a software
engineer at Google.

00:00:07.306 --> 00:00:09.410
I work on making the mobile
web faster and better.

00:00:09.410 --> 00:00:11.160
And today I'm going
to talk about building

00:00:11.160 --> 00:00:13.090
an instant mobile web apps.

00:00:13.090 --> 00:00:16.100
So we'll take the next 30
minutes to cover two topics.

00:00:16.100 --> 00:00:17.810
The first will be,
I'll give an overview

00:00:17.810 --> 00:00:19.920
of the process my
team actually took

00:00:19.920 --> 00:00:22.106
to optimize one of
the apps I work on.

00:00:22.106 --> 00:00:23.480
And then in the
second half we'll

00:00:23.480 --> 00:00:26.470
take from that some learnings
or some generalizations and best

00:00:26.470 --> 00:00:28.750
practices that hopefully
you can take with you

00:00:28.750 --> 00:00:30.580
to make your mobile apps faster.

00:00:34.350 --> 00:00:37.190
OK, so our goal
specifically, more precisely,

00:00:37.190 --> 00:00:39.960
is to render app content
on the phone in a second.

00:00:39.960 --> 00:00:42.980
So from the time a user
clicks a link, to the time

00:00:42.980 --> 00:00:45.520
they actually start to
see content on your phone

00:00:45.520 --> 00:00:48.122
and you're able to interact with
it, should be about a second.

00:00:48.122 --> 00:00:49.580
And this one second
target actually

00:00:49.580 --> 00:00:51.570
comes from some work
linked here at the bottom

00:00:51.570 --> 00:00:53.070
by Jakob Nielsen--
hopefully you can

00:00:53.070 --> 00:00:55.900
see that-- that talks about
some different thresholds

00:00:55.900 --> 00:00:59.289
of human perception, where,
sort of, behavior changes.

00:00:59.289 --> 00:01:01.080
And that one second
boundary is interesting

00:01:01.080 --> 00:01:03.205
because that's the point
at which a user will start

00:01:03.205 --> 00:01:06.930
to disengage with the
activity they've initiated.

00:01:06.930 --> 00:01:09.110
They'll start to think
about doing something else.

00:01:09.110 --> 00:01:13.594
And so to keep the user
engaged, to keep them wanting

00:01:13.594 --> 00:01:16.010
to use your app, we want to
try to deliver that content as

00:01:16.010 --> 00:01:18.400
quickly as possible, ideally
within that roughly one

00:01:18.400 --> 00:01:21.070
second boundary.

00:01:21.070 --> 00:01:24.179
So a lot of what I'm going
to talk about focuses

00:01:24.179 --> 00:01:26.720
on this concept of the critical
rendering path, which you may

00:01:26.720 --> 00:01:29.225
have heard Ilya talk about
or others talk about.

00:01:29.225 --> 00:01:31.350
At a really high level,
the critical rendering path

00:01:31.350 --> 00:01:33.860
is sort of the
sequence of resources

00:01:33.860 --> 00:01:35.690
that need to be
loaded and parsed,

00:01:35.690 --> 00:01:40.620
usually JavaScript and
style sheet resources,

00:01:40.620 --> 00:01:43.050
that prevent content on
the page from actually

00:01:43.050 --> 00:01:44.270
rendering from the screen.

00:01:44.270 --> 00:01:47.624
So actually it's easiest
to explain, I think,

00:01:47.624 --> 00:01:48.290
with an example.

00:01:52.110 --> 00:01:54.510
So here along the top
we've got a timeline

00:01:54.510 --> 00:01:57.880
that shows how an example page
that I'm using for this example

00:01:57.880 --> 00:02:01.720
renders over time, out to 20
seconds on a mobile device.

00:02:01.720 --> 00:02:03.437
So we have a performance
problem here.

00:02:03.437 --> 00:02:05.520
And the question becomes,
well, why is it so slow?

00:02:05.520 --> 00:02:08.229
Why is it taking nine seconds to
render anything to the screen,

00:02:08.229 --> 00:02:11.450
and why does it take 20
seconds to finish rendering?

00:02:11.450 --> 00:02:15.010
And that's what the critical
rendering path tries to answer.

00:02:15.010 --> 00:02:17.280
So if we have an example
network waterfall here,

00:02:17.280 --> 00:02:18.780
we can walk through
and try to start

00:02:18.780 --> 00:02:21.780
to make sense of what this
critical rendering path is all

00:02:21.780 --> 00:02:22.280
about.

00:02:22.280 --> 00:02:26.350
So obviously, we start by
loading the HTML resource.

00:02:26.350 --> 00:02:27.840
That comes back
with some content.

00:02:27.840 --> 00:02:30.790
It might have a style sheet,
and a script resource.

00:02:30.790 --> 00:02:32.820
And so at this point
we have-- like I said,

00:02:32.820 --> 00:02:36.500
the critical path includes,
usually, script and styles.

00:02:36.500 --> 00:02:37.990
These resources
block the browser

00:02:37.990 --> 00:02:39.865
from actually painting
content to the screen.

00:02:39.865 --> 00:02:41.369
So while a style
sheet is pending,

00:02:41.369 --> 00:02:43.410
the browser is going to
wait for that style sheet

00:02:43.410 --> 00:02:44.600
to load before it
actually paints

00:02:44.600 --> 00:02:45.720
any content to the screen.

00:02:45.720 --> 00:02:48.945
So we can't paint anything until
these resources finish loading.

00:02:51.930 --> 00:02:54.610
Imagine that we sent out the
request for both of those.

00:02:54.610 --> 00:02:57.590
The response comes back to the
JavaScript in nine seconds,

00:02:57.590 --> 00:03:00.767
and at that point, we can
begin to paint something

00:03:00.767 --> 00:03:01.350
to the screen.

00:03:01.350 --> 00:03:03.160
It may not be the content
the user actually wants,

00:03:03.160 --> 00:03:03.760
unfortunately.

00:03:03.760 --> 00:03:05.070
That's sort of at the end.

00:03:05.070 --> 00:03:06.880
But we've sort of
started to paint.

00:03:06.880 --> 00:03:10.030
And then from there imagine the
JavaScript resource adds a CSS

00:03:10.030 --> 00:03:12.050
resource to the DOM, a
style sheet to the DOM,

00:03:12.050 --> 00:03:14.000
and so now that's
on the critical path

00:03:14.000 --> 00:03:15.790
for subsequent paints.

00:03:15.790 --> 00:03:20.160
Once that loads, we can paint
a little bit more content.

00:03:20.160 --> 00:03:23.670
The style sheet maybe had
some stylings for the footer.

00:03:23.670 --> 00:03:27.430
Additionally, we've loaded, say,
a second JavaScript resource

00:03:27.430 --> 00:03:29.470
from that first
JavaScript resource.

00:03:29.470 --> 00:03:31.270
And say that's used
to actually render

00:03:31.270 --> 00:03:32.920
the main content on the screen.

00:03:32.920 --> 00:03:34.490
And so that now
has to load, parse,

00:03:34.490 --> 00:03:35.610
and execute before
you can actually

00:03:35.610 --> 00:03:37.580
see any content on the
screen-- or, I'm sorry,

00:03:37.580 --> 00:03:38.940
see the final content.

00:03:38.940 --> 00:03:41.280
And then finally around
19 or 20 seconds,

00:03:41.280 --> 00:03:44.440
all of that finishes, that
whole process of these things

00:03:44.440 --> 00:03:46.180
loading in the browser
finishes, and we

00:03:46.180 --> 00:03:48.360
could paint these finished
content to the screen

00:03:48.360 --> 00:03:49.991
and show that the user.

00:03:49.991 --> 00:03:51.490
So the critical
rendering path tries

00:03:51.490 --> 00:03:54.350
to focus on the most
significant resources that

00:03:54.350 --> 00:03:58.070
cause render-blocking,
and explain

00:03:58.070 --> 00:03:59.500
why we see these delays.

00:03:59.500 --> 00:04:01.920
But this becomes especially
important on mobile, where

00:04:01.920 --> 00:04:04.020
we have these very high
network round-trip times,

00:04:04.020 --> 00:04:06.290
and loading extra
JavaScript and CSS resources

00:04:06.290 --> 00:04:09.810
ends up having a
significant cost.

00:04:09.810 --> 00:04:13.199
So now, we'll focus
more on thinking

00:04:13.199 --> 00:04:14.490
about optimizing critical path.

00:04:14.490 --> 00:04:17.769
We know, here, that we've got
this really long critical path

00:04:17.769 --> 00:04:18.570
of resources.

00:04:18.570 --> 00:04:20.630
This is just a toy example.

00:04:20.630 --> 00:04:22.780
So the question becomes,
how do we actually

00:04:22.780 --> 00:04:23.951
address and optimize that?

00:04:23.951 --> 00:04:25.950
I'm going to talk about
the process my team went

00:04:25.950 --> 00:04:29.280
through about a year ago to do
just that for one of the apps

00:04:29.280 --> 00:04:31.779
I work on, PageSpeed Insights.

00:04:31.779 --> 00:04:33.570
So PageSpeed Insights
is a tool you can use

00:04:33.570 --> 00:04:36.759
at
developers.google.com/pagespeed.

00:04:36.759 --> 00:04:39.300
This is a tool where you could
enter a URL into the box here.

00:04:39.300 --> 00:04:44.010
We go off and we render the
page in a headless browser.

00:04:44.010 --> 00:04:46.050
We analyze how it loads.

00:04:46.050 --> 00:04:48.080
And we come back and give
you a prioritized list

00:04:48.080 --> 00:04:50.720
of recommendations to
make the page load faster.

00:04:50.720 --> 00:04:52.470
And about a year ago,
we had this problem.

00:04:52.470 --> 00:04:54.000
Well, we started
to think about, OK,

00:04:54.000 --> 00:04:57.500
how do we make this page
really fast on mobile?

00:04:57.500 --> 00:05:00.350
We knew we weren't doing great,
but the first thing we did

00:05:00.350 --> 00:05:03.586
is we wanted to see exactly
how poorly we were doing.

00:05:03.586 --> 00:05:05.210
And so what we saw
really surprised us.

00:05:05.210 --> 00:05:07.870
It was worse than we expected.

00:05:07.870 --> 00:05:10.112
Now you can see where
the example comes from.

00:05:10.112 --> 00:05:12.070
It took nine seconds to
render anything at all,

00:05:12.070 --> 00:05:14.590
but it took about 19 or 20
seconds on a 3G connection

00:05:14.590 --> 00:05:16.740
or on an iPhone 4, in
this case, to render

00:05:16.740 --> 00:05:18.199
what the user
actually cared about,

00:05:18.199 --> 00:05:19.906
which was that initial
text box that they

00:05:19.906 --> 00:05:21.590
could use to interact
with the app.

00:05:21.590 --> 00:05:25.990
And so, 20 seconds.

00:05:25.990 --> 00:05:27.810
Our target is one second.

00:05:27.810 --> 00:05:30.140
We've got a really
significant problem here,

00:05:30.140 --> 00:05:32.450
and we knew we needed
to really rethink a lot,

00:05:32.450 --> 00:05:34.810
or try to figure out what
we had missed, right?

00:05:34.810 --> 00:05:36.870
This app was reasonably
fast on desktop,

00:05:36.870 --> 00:05:39.960
but on a high latency
mobile connection,

00:05:39.960 --> 00:05:41.530
it just took way
too long to load.

00:05:41.530 --> 00:05:44.217
So we started to
look at the markup.

00:05:44.217 --> 00:05:46.050
We saw we had some
render-blocking resources

00:05:46.050 --> 00:05:46.984
in the head.

00:05:46.984 --> 00:05:48.650
But this isn't all
that uncommon, right?

00:05:48.650 --> 00:05:49.860
You see this in lots of apps.

00:05:49.860 --> 00:05:51.734
So there's nothing that
really stood out here

00:05:51.734 --> 00:05:53.820
as being particularly costly.

00:05:53.820 --> 00:05:56.850
So we went back to our timeline.

00:05:56.850 --> 00:05:58.770
Then we looked at a
network waterfall.

00:05:58.770 --> 00:06:01.980
You can see we load
about 25 resources here.

00:06:01.980 --> 00:06:03.970
And the question came
up, OK, well we're

00:06:03.970 --> 00:06:06.720
loading all these resources,
but which of these resources

00:06:06.720 --> 00:06:09.530
are actually contributing
to making the page slower?

00:06:09.530 --> 00:06:12.710
Which of these are on the
critical rendering path?

00:06:12.710 --> 00:06:15.360
And so one of the things that
PageSpeed Insights actually

00:06:15.360 --> 00:06:18.992
does today is it can
tell you which resources

00:06:18.992 --> 00:06:20.450
are on the critical
rendering path.

00:06:20.450 --> 00:06:22.480
And so we can go here.

00:06:22.480 --> 00:06:25.460
We can click through.

00:06:25.460 --> 00:06:28.080
And we can see we've got these
JavaScript resources, these CSS

00:06:28.080 --> 00:06:30.204
resources that are on that
critical rendering path,

00:06:30.204 --> 00:06:32.780
that block rendering of
content on the screen,

00:06:32.780 --> 00:06:34.760
and then use that to go
back to our waterfall

00:06:34.760 --> 00:06:39.060
and start to focus on
which resources actually

00:06:39.060 --> 00:06:39.840
block rendering.

00:06:39.840 --> 00:06:44.040
So now we have about a
dozen resources to focus on.

00:06:44.040 --> 00:06:46.287
And we're able to focus
more precisely on,

00:06:46.287 --> 00:06:48.620
what are the render-blocking
effects of these resources?

00:06:48.620 --> 00:06:50.490
And then, how do
we address those?

00:06:50.490 --> 00:06:52.500
And so we can begin to
sort of match up here.

00:06:52.500 --> 00:06:57.610
We've got some content that
loads before the nine second

00:06:57.610 --> 00:06:58.130
first paint.

00:06:58.130 --> 00:07:00.850
We can start to notice
which of those resources

00:07:00.850 --> 00:07:01.850
are blocking that point.

00:07:01.850 --> 00:07:03.632
I'll get into that
in just a minute.

00:07:03.632 --> 00:07:05.590
But this was sort of the
starting point for us,

00:07:05.590 --> 00:07:08.440
was looking at this
and figuring out,

00:07:08.440 --> 00:07:11.230
how do we optimize the critical
rendering path for this page?

00:07:17.690 --> 00:07:20.420
At a high level we felt like
we had two problems here.

00:07:20.420 --> 00:07:24.410
One was that we had a bunch
of render-blocking JavaScript

00:07:24.410 --> 00:07:28.660
and CSS loaded in a way that
blocked any content at all

00:07:28.660 --> 00:07:31.420
from rendering the page--
rendering on the page.

00:07:31.420 --> 00:07:33.950
So this block of
JavaScript and CSS

00:07:33.950 --> 00:07:37.650
here, which declared in
the head of the HTML, all

00:07:37.650 --> 00:07:40.050
had to be downloaded,
parsed, and executed in order

00:07:40.050 --> 00:07:42.330
for anything at all
to render on screen.

00:07:42.330 --> 00:07:46.820
And as we know, mobile networks
have really high latency,

00:07:46.820 --> 00:07:49.950
so downloading
additional resources has

00:07:49.950 --> 00:07:52.220
a pretty significant,
pretty high cost,

00:07:52.220 --> 00:07:54.650
all the while your users are
looking at a blank screen,

00:07:54.650 --> 00:07:56.570
waiting and wondering
if your app is working,

00:07:56.570 --> 00:07:59.724
thinking about transitioning
away to do something else.

00:07:59.724 --> 00:08:01.890
So for us-- and I'll show
it in a little more detail

00:08:01.890 --> 00:08:04.150
in a minute-- what we
concluded we needed to do

00:08:04.150 --> 00:08:07.240
was basically eliminate
all of these resources

00:08:07.240 --> 00:08:08.597
from being render-blocking.

00:08:08.597 --> 00:08:10.680
And that amounted to doing
two things, which we'll

00:08:10.680 --> 00:08:14.004
dive into-- loading our
render-blocking JavaScript

00:08:14.004 --> 00:08:15.670
asynchronously, and
then really thinking

00:08:15.670 --> 00:08:17.330
about what is the
minimal amount of CSS

00:08:17.330 --> 00:08:19.110
we actually need
to render this out,

00:08:19.110 --> 00:08:21.422
and loading that in a
blocking way, but making sure

00:08:21.422 --> 00:08:22.880
we weren't loading
any more than we

00:08:22.880 --> 00:08:24.360
needed in a render-blocking way.

00:08:27.479 --> 00:08:29.020
And so recall, this
is the screenshot

00:08:29.020 --> 00:08:33.340
that was associated with
that point in the page load.

00:08:33.340 --> 00:08:35.489
The thing to note here is
that we haven't actually

00:08:35.489 --> 00:08:37.280
rendered the content
the user really cared,

00:08:37.280 --> 00:08:40.510
that text box to interact
with the app yet.

00:08:40.510 --> 00:08:43.110
So the second issue
was, we were actually

00:08:43.110 --> 00:08:45.680
rendering that sort
of critical content,

00:08:45.680 --> 00:08:49.290
the text box, that the user
could use to actually analyze

00:08:49.290 --> 00:08:51.650
a page, using a
JavaScript resource.

00:08:51.650 --> 00:08:54.341
We made it to download a
large chunk of JavaScript,

00:08:54.341 --> 00:08:56.590
download, parse, and execute
that JavaScript before we

00:08:56.590 --> 00:08:58.880
actually rendered
that, using JavaScript

00:08:58.880 --> 00:09:00.490
to construct the DOM.

00:09:00.490 --> 00:09:03.020
So this added another
roughly 10 seconds of latency

00:09:03.020 --> 00:09:05.100
here before we could
get to this point.

00:09:05.100 --> 00:09:11.610
So all in all, we had at a
high level these two problems.

00:09:11.610 --> 00:09:14.240
And so we sat down and we
tried to address these things.

00:09:14.240 --> 00:09:16.882
The thing we did for this was
we realized most of the content,

00:09:16.882 --> 00:09:18.340
we're rendering it
with JavaScript,

00:09:18.340 --> 00:09:20.780
and that's fine and great,
but it just wasn't performant.

00:09:20.780 --> 00:09:24.950
And so what we did is we
inlined that initial view.

00:09:24.950 --> 00:09:27.830
Or I should say, we put the
initial view's HTML markup

00:09:27.830 --> 00:09:31.070
directly in HTML, no longer
depending on JavaScript

00:09:31.070 --> 00:09:34.209
to actually render that, which
allowed us to present that

00:09:34.209 --> 00:09:36.000
to the user that much
faster without having

00:09:36.000 --> 00:09:40.490
to wait for that render-blocking
JavaScript to load.

00:09:40.490 --> 00:09:42.930
So I just wanted to show
a quick before and after.

00:09:42.930 --> 00:09:45.860
Here's that HTML markup
for the original page that

00:09:45.860 --> 00:09:48.220
took 19 seconds, at
least part of it.

00:09:48.220 --> 00:09:50.570
We've got our render-blocking
JavaScript in the head.

00:09:50.570 --> 00:09:56.380
We've got some markup
for the content,

00:09:56.380 --> 00:09:58.477
but we don't have, you'll
notice, the input box.

00:09:58.477 --> 00:10:00.560
That was rendered with
JavaScript, so some of that

00:10:00.560 --> 00:10:01.840
comes later.

00:10:01.840 --> 00:10:07.300
The after case-- here, we've
got a slightly different markup.

00:10:07.300 --> 00:10:10.530
First, we've got an inline style
block that contains the CSS.

00:10:10.530 --> 00:10:12.840
We need to style the
content in the initial view.

00:10:12.840 --> 00:10:14.410
So we don't have
to go to network

00:10:14.410 --> 00:10:16.300
to download additional
style sheets, which

00:10:16.300 --> 00:10:18.820
will incur additional mobile
network round trips, which

00:10:18.820 --> 00:10:21.790
are significantly slower,
or significantly slow

00:10:21.790 --> 00:10:24.030
down the page load.

00:10:24.030 --> 00:10:25.490
And then as I
mentioned, now we've

00:10:25.490 --> 00:10:27.880
made sure that all
the markup we need

00:10:27.880 --> 00:10:30.960
to render the above the fold
content is directly in HTML.

00:10:30.960 --> 00:10:34.090
We're not using JavaScript to
render any of this content.

00:10:34.090 --> 00:10:36.810
And then finally,
because we're including

00:10:36.810 --> 00:10:39.840
all the markup we need to
render the initial view directly

00:10:39.840 --> 00:10:43.432
in HTML, we can load our
JavaScript asynchronously

00:10:43.432 --> 00:10:44.890
because we don't
need it to render,

00:10:44.890 --> 00:10:46.473
so we don't want it
to block rendering

00:10:46.473 --> 00:10:50.240
of the initial presentation.

00:10:50.240 --> 00:10:52.667
So that high level was the
process we went through.

00:10:52.667 --> 00:10:54.250
And so the question
is, how did we do?

00:10:54.250 --> 00:10:56.690
Did we actually
speed the page up?

00:10:56.690 --> 00:11:00.270
So here's the waterfall
for the original page.

00:11:00.270 --> 00:11:04.660
We've got about 25
resources in total.

00:11:04.660 --> 00:11:07.420
And then here's the waterfall
for this rewrite that

00:11:07.420 --> 00:11:09.760
was focused on delivering
a really fast experience

00:11:09.760 --> 00:11:10.530
on mobile.

00:11:10.530 --> 00:11:12.730
And you can see we've got
about 20 resources now.

00:11:12.730 --> 00:11:16.836
So we had 25 before, 20 now.

00:11:16.836 --> 00:11:18.460
It's not really
significantly different

00:11:18.460 --> 00:11:19.876
if you look at the
total waterfall

00:11:19.876 --> 00:11:21.330
size, total number of requests.

00:11:21.330 --> 00:11:22.788
But I think what's
really important

00:11:22.788 --> 00:11:25.202
here is looking not at the
total number of requests,

00:11:25.202 --> 00:11:27.160
but the relative size of
the two critical paths

00:11:27.160 --> 00:11:30.490
between the critical rendering
paths, between the two pages.

00:11:30.490 --> 00:11:32.937
So in the old example, we had
a bunch of resources here.

00:11:32.937 --> 00:11:34.520
We've got everything
we need to render

00:11:34.520 --> 00:11:37.200
the initial view in
the HTML payload.

00:11:37.200 --> 00:11:39.750
So the critical path, the
critical rendering path,

00:11:39.750 --> 00:11:41.180
is this one HTML resource.

00:11:41.180 --> 00:11:43.750
And we can render
much more quickly

00:11:43.750 --> 00:11:46.370
than in the original case
where we had a dozen resources.

00:11:46.370 --> 00:11:49.280
So we often talk
about, well, reducing

00:11:49.280 --> 00:11:51.494
requests is a goal
with performance

00:11:51.494 --> 00:11:52.410
and with optimization.

00:11:52.410 --> 00:11:53.909
But I think what's
more important is

00:11:53.909 --> 00:11:55.830
to think about reducing
the number of requests

00:11:55.830 --> 00:11:57.400
on the critical rendering path.

00:11:57.400 --> 00:12:01.420
That's really where you
will see your big returns.

00:12:01.420 --> 00:12:02.300
So let's look.

00:12:02.300 --> 00:12:05.000
Let's do sort of a side
by side, before and after.

00:12:05.000 --> 00:12:07.840
So the optimized case,
we start to render in

00:12:07.840 --> 00:12:09.680
about a second a half,
and we're completely

00:12:09.680 --> 00:12:10.596
done at three seconds.

00:12:10.596 --> 00:12:12.530
All the images,
everything, have come back.

00:12:12.530 --> 00:12:13.910
And recall the original case.

00:12:13.910 --> 00:12:15.694
We're still waiting.

00:12:15.694 --> 00:12:17.860
We can't actually really
interact with the app, even

00:12:17.860 --> 00:12:20.670
at this point, because we
don't have the text box.

00:12:20.670 --> 00:12:28.850
So we were able to reduce
the render time down

00:12:28.850 --> 00:12:31.620
from about 20 seconds down
to one or one half seconds.

00:12:31.620 --> 00:12:34.240
So we more or less
accomplished our goal.

00:12:34.240 --> 00:12:36.480
So that's the process
we went through,

00:12:36.480 --> 00:12:39.170
and now I'm going to
spend little time talking

00:12:39.170 --> 00:12:42.080
about the process of
optimizing your app's content.

00:12:42.080 --> 00:12:43.180
So what did we learn?

00:12:43.180 --> 00:12:44.960
What are the general
best practices there?

00:12:44.960 --> 00:12:47.510
How can you deliver this instant
experience for your users

00:12:47.510 --> 00:12:49.072
on mobile?

00:12:49.072 --> 00:12:51.030
So the first thing we
learned-- the first thing

00:12:51.030 --> 00:12:54.010
we identified as an
important best practice--

00:12:54.010 --> 00:12:55.500
is to load script
asynchronously.

00:12:55.500 --> 00:12:59.670
So don't load scripts in a way
that blocks rendering, because

00:12:59.670 --> 00:13:03.460
on mobile networks, with the
high latency, high round trip

00:13:03.460 --> 00:13:05.160
times, each additional
resource you

00:13:05.160 --> 00:13:06.760
load in the critical
rendering path

00:13:06.760 --> 00:13:10.530
pushes out the time the user
has to wait to start interacting

00:13:10.530 --> 00:13:12.690
with your app pretty
significantly.

00:13:12.690 --> 00:13:16.810
So here we've got your
sort of standard page,

00:13:16.810 --> 00:13:19.810
group source equals all
that JS in the head.

00:13:19.810 --> 00:13:21.652
And we've got the
content right beneath it.

00:13:21.652 --> 00:13:23.860
The browser receives that
at the same time, probably,

00:13:23.860 --> 00:13:24.830
as the script.

00:13:24.830 --> 00:13:29.150
But it can't show it to the user
until the script has finished

00:13:29.150 --> 00:13:30.700
downloading, parsing,
and executing

00:13:30.700 --> 00:13:32.630
on the mobile device,
which introduces

00:13:32.630 --> 00:13:37.410
really significant additional
render latencies for the user.

00:13:37.410 --> 00:13:39.530
And so what do we do?

00:13:39.530 --> 00:13:41.970
In the best case, you
can take advantage

00:13:41.970 --> 00:13:45.430
of the HMTL5 async tag, which
tells the browser, yes, I

00:13:45.430 --> 00:13:48.360
need this script, I need
to load this script,

00:13:48.360 --> 00:13:51.786
but you don't need to execute
it inline at the point

00:13:51.786 --> 00:13:53.160
where it appears
in the document.

00:13:53.160 --> 00:13:55.674
Execute it sometime later
when it finishes downloading,

00:13:55.674 --> 00:13:57.090
and then go ahead
and just proceed

00:13:57.090 --> 00:13:59.374
parsing the rest
of the document,

00:13:59.374 --> 00:14:01.790
and render that content to the
user as quickly as you can.

00:14:01.790 --> 00:14:04.660
So this gets scripts out of
the critical rendering path,

00:14:04.660 --> 00:14:09.610
which is a really
important thing to do.

00:14:09.610 --> 00:14:12.860
So I'll say there are
some subtleties here.

00:14:12.860 --> 00:14:14.360
It's often not quite
as easy as just

00:14:14.360 --> 00:14:16.230
dropping the async tag in there.

00:14:16.230 --> 00:14:18.410
If you use document.write
in your JavaScript,

00:14:18.410 --> 00:14:20.900
this is a really
dangerous thing to do.

00:14:20.900 --> 00:14:23.280
And there are other
subtleties that I'd

00:14:23.280 --> 00:14:26.130
be happy to talk
about at the session.

00:14:26.130 --> 00:14:29.570
And I guess it'll be 45 minutes.

00:14:29.570 --> 00:14:32.750
So second, render the initial
view server-side as HTML.

00:14:32.750 --> 00:14:35.820
You'll recall we had
about six seconds

00:14:35.820 --> 00:14:37.440
of render-blocking
JavaScript and CSS,

00:14:37.440 --> 00:14:42.150
but then we had 10 seconds
to load that final JavaScript

00:14:42.150 --> 00:14:44.400
resource, download,
parse, and execute it

00:14:44.400 --> 00:14:46.150
before the app
finished rendering.

00:14:46.150 --> 00:14:48.630
And the problem was we were
loading this big JavaScript

00:14:48.630 --> 00:14:51.380
bundle, whose job it was to
actually construct the DOM.

00:14:51.380 --> 00:14:53.220
So we had to go to
network in order

00:14:53.220 --> 00:14:55.490
to create the DOM that
the user would see.

00:14:55.490 --> 00:14:58.010
And this is just, unfortunately,
an inherently slow process

00:14:58.010 --> 00:14:58.820
on mobile.

00:14:58.820 --> 00:15:01.974
Rendering client-side--
let's talk about-- so

00:15:01.974 --> 00:15:03.640
what do we mean by
server-side rendering

00:15:03.640 --> 00:15:04.990
versus client-side rendering?

00:15:04.990 --> 00:15:09.050
So client-side rendering,
you're using JavaScript

00:15:09.050 --> 00:15:11.420
to actually render the
content in the document.

00:15:11.420 --> 00:15:13.200
So here we load up that JS.

00:15:13.200 --> 00:15:17.000
The DOM itself doesn't
really contain any markup.

00:15:17.000 --> 00:15:20.940
It doesn't contain mark up
that you see on the screen.

00:15:20.940 --> 00:15:22.690
It's just to figure
out a placeholder div,

00:15:22.690 --> 00:15:25.175
and then when app.js
finishes loading,

00:15:25.175 --> 00:15:27.550
we might get something like
this that actually constructs

00:15:27.550 --> 00:15:30.470
the DOM once that
resource finishes loading.

00:15:30.470 --> 00:15:35.449
By contrast, server-side
rendering-- everything

00:15:35.449 --> 00:15:37.240
that we need to display
in the initial view

00:15:37.240 --> 00:15:40.050
is present right
in the HTML markup,

00:15:40.050 --> 00:15:41.810
and so no additional
resources are needed.

00:15:41.810 --> 00:15:43.330
As soon as that
HTML comes back, we

00:15:43.330 --> 00:15:45.080
can render that to the
screen and the user

00:15:45.080 --> 00:15:47.410
sees that as
quickly as possible.

00:15:47.410 --> 00:15:48.994
So this is just, on
mobile especially,

00:15:48.994 --> 00:15:50.826
this is just a much
more performant approach

00:15:50.826 --> 00:15:51.840
for the initial view.

00:15:51.840 --> 00:15:54.750
So certainly, once the
app has finished loading,

00:15:54.750 --> 00:15:57.040
and the user is
interacting with your app--

00:15:57.040 --> 00:15:59.715
they're changing the way
the content is presented,

00:15:59.715 --> 00:16:01.840
maybe they're navigating
through a menu-- certainly

00:16:01.840 --> 00:16:03.756
at that point it makes
sense to use JavaScript

00:16:03.756 --> 00:16:05.260
to construct your document.

00:16:05.260 --> 00:16:07.830
But for that initial
view, you should

00:16:07.830 --> 00:16:10.840
do as much server-side rendering
to HTML as you possibly can.

00:16:14.250 --> 00:16:15.750
So we found this to be true.

00:16:15.750 --> 00:16:17.370
But we weren't the only ones.

00:16:17.370 --> 00:16:21.510
Twitter also came to
the same conclusion.

00:16:21.510 --> 00:16:23.260
So they wrote a blog
post about a year ago

00:16:23.260 --> 00:16:24.620
where they talked about this.

00:16:24.620 --> 00:16:27.990
In 2010, they'd
released new Twitter,

00:16:27.990 --> 00:16:30.340
where all the rendering
happened on the client.

00:16:30.340 --> 00:16:32.116
And they talked about
how that allowed

00:16:32.116 --> 00:16:33.740
them to do some
interesting new things,

00:16:33.740 --> 00:16:37.620
but it came at the consequence
of significant regression

00:16:37.620 --> 00:16:39.839
in actual client-side
render time.

00:16:39.839 --> 00:16:41.380
So in 2012, they
wrote this blog post

00:16:41.380 --> 00:16:43.630
where they talk about taking
back control of front end

00:16:43.630 --> 00:16:47.310
performance by moving
rendering back to the server.

00:16:47.310 --> 00:16:54.870
And what they found is that
page load times dropped really

00:16:54.870 --> 00:16:55.540
significantly.

00:16:55.540 --> 00:16:57.450
So wasn't like
10% or 15%, it was

00:16:57.450 --> 00:16:59.230
1/5 of what they
were previously.

00:16:59.230 --> 00:17:01.480
So this was a really
big thing for them.

00:17:01.480 --> 00:17:04.440
And in order to deliver that
instant experience on mobile,

00:17:04.440 --> 00:17:07.010
it's pretty much a
requirement that you

00:17:07.010 --> 00:17:10.170
render that initial
view server-side.

00:17:10.170 --> 00:17:13.185
So Twitter wasn't
the only organization

00:17:13.185 --> 00:17:14.900
to come to this conclusion.

00:17:14.900 --> 00:17:17.230
Airbnb had a very similar
conclusion in a blog post

00:17:17.230 --> 00:17:18.640
earlier this year.

00:17:18.640 --> 00:17:20.254
And they said under
their old design,

00:17:20.254 --> 00:17:21.629
the external
JavaScript files had

00:17:21.629 --> 00:17:23.087
to download,
evaluate, and execute.

00:17:27.619 --> 00:17:28.994
Only then would
the app discover,

00:17:28.994 --> 00:17:31.160
oh, the user's intent was
to do x, who would call up

00:17:31.160 --> 00:17:33.220
the API, which was an
additional network request,

00:17:33.220 --> 00:17:36.182
that became part of that
critical rendering path.

00:17:36.182 --> 00:17:37.640
Here we are in a
mobile connection,

00:17:37.640 --> 00:17:40.560
which has really high latency.

00:17:40.560 --> 00:17:42.789
Which led to, for them, a
time to content-- the time

00:17:42.789 --> 00:17:45.080
until the user could get the
content that they wanted--

00:17:45.080 --> 00:17:48.591
of upwards of 10
seconds, in bad cases.

00:17:48.591 --> 00:17:50.590
So then they switched to
server-side rendering--

00:17:50.590 --> 00:17:53.090
which, by the way, they open
sourced the infrastructure they

00:17:53.090 --> 00:17:56.150
used for this, so it's worth
a look at this blog post.

00:17:56.150 --> 00:18:00.280
When they moved to serving the
initial view as HTML generated

00:18:00.280 --> 00:18:02.722
on the server, it felt
five times faster.

00:18:02.722 --> 00:18:03.930
So similar conclusion, right?

00:18:03.930 --> 00:18:05.440
Twitter-- 1/5.

00:18:05.440 --> 00:18:09.270
Here, Airbnb--
five times faster.

00:18:09.270 --> 00:18:11.270
So in my opinion, if you
want to deliver a truly

00:18:11.270 --> 00:18:13.145
instant experience--
and there's a trade off.

00:18:16.194 --> 00:18:18.360
So if you want to deliver
that experience on mobile,

00:18:18.360 --> 00:18:19.650
you really need
to be server-side

00:18:19.650 --> 00:18:20.816
rendering that initial view.

00:18:20.816 --> 00:18:23.307
Loading JavaScript to create
the initial presentation

00:18:23.307 --> 00:18:24.890
is just going to be
too slow on mobile

00:18:24.890 --> 00:18:26.930
for it to be an
instant experience.

00:18:26.930 --> 00:18:32.710
And we saw Twitter and Airbnb
both had really dramatic speed

00:18:32.710 --> 00:18:37.462
reductions as a result of
adopting this technique.

00:18:37.462 --> 00:18:39.670
So I would say, when choosing
a JavaScript framework,

00:18:39.670 --> 00:18:41.430
you want to look for a
framework ideally that

00:18:41.430 --> 00:18:42.721
supports server-side rendering.

00:18:45.905 --> 00:18:47.780
Airbnb talked about the
one they open source.

00:18:47.780 --> 00:18:48.960
Not all the JavaScript
frameworks out

00:18:48.960 --> 00:18:51.376
there today do support this,
but if you're using one today

00:18:51.376 --> 00:18:53.965
that you do like that doesn't
support server-side rendering,

00:18:53.965 --> 00:18:55.590
you should push on
the development team

00:18:55.590 --> 00:18:57.990
or pitch in and
help out to make it

00:18:57.990 --> 00:19:00.680
easy to do that as part
of using that framework.

00:19:00.680 --> 00:19:04.190
So you can take advantage
of this automatically.

00:19:04.190 --> 00:19:08.910
So the third area I
want to talk about

00:19:08.910 --> 00:19:10.890
is minimizing
render-blocking CSS.

00:19:10.890 --> 00:19:15.310
And I think this is the topic
we get the most questions on.

00:19:15.310 --> 00:19:18.015
So I'm going to go through a
couple common questions here.

00:19:18.015 --> 00:19:20.390
The first of which, people
say, well what do you mean CSS

00:19:20.390 --> 00:19:21.009
is blocking?

00:19:21.009 --> 00:19:23.300
Why is this part of this
blocking critical render path?

00:19:23.300 --> 00:19:27.050
JavaScript blocks, yes, but
what do you mean CSS blocks?

00:19:27.050 --> 00:19:31.030
And it's correct that JavaScript
blocks DOM tree construction.

00:19:31.030 --> 00:19:33.380
JavaScript blocks the parser.

00:19:33.380 --> 00:19:36.640
But style sheets block
render tree construction.

00:19:36.640 --> 00:19:39.320
So ultimately, in order
to lay out in paint,

00:19:39.320 --> 00:19:41.590
we need the style sheet
to have finished loading.

00:19:41.590 --> 00:19:43.850
And what your users
care about is content

00:19:43.850 --> 00:19:44.850
painted to the screen.

00:19:44.850 --> 00:19:47.880
So for them, JavaScript
is-- I'm sorry,

00:19:47.880 --> 00:19:49.340
style sheets are
render-blocking.

00:19:49.340 --> 00:19:51.816
So it's important to
keep this in mind.

00:19:51.816 --> 00:19:53.940
If you load a large style
sheet in the head, that's

00:19:53.940 --> 00:19:58.760
going to delay the time it takes
to paint content to the screen.

00:19:58.760 --> 00:20:04.510
So CSS is render-blocking.

00:20:04.510 --> 00:20:05.830
So what's critical CSS?

00:20:05.830 --> 00:20:06.669
What is this?

00:20:06.669 --> 00:20:08.460
We talk about this
concept of critical CSS.

00:20:08.460 --> 00:20:10.168
You may have heard,
it sort of goes along

00:20:10.168 --> 00:20:12.160
with the critical
rendering path.

00:20:12.160 --> 00:20:15.110
And how do I identify
my critical CSS?

00:20:15.110 --> 00:20:19.040
So critical CSS you can
think of as the minimal CSS

00:20:19.040 --> 00:20:21.550
you need to actually
position and style content

00:20:21.550 --> 00:20:23.620
in the initial view of your app.

00:20:23.620 --> 00:20:25.420
So everything you
need to present

00:20:25.420 --> 00:20:29.050
that flash of unstyled style
content for the content

00:20:29.050 --> 00:20:30.940
that you display
initially to the user.

00:20:30.940 --> 00:20:33.430
And the idea here
is that because we

00:20:33.430 --> 00:20:35.620
know CSS is
render-blocking, we want

00:20:35.620 --> 00:20:38.730
to minimize the amount of CSS
that we serve up to the user,

00:20:38.730 --> 00:20:41.180
in order to minimize the
size of the critical path

00:20:41.180 --> 00:20:44.184
and get the content to display
as quickly as possible.

00:20:44.184 --> 00:20:46.350
So identifying critical
CSS-- we'll talk about this.

00:20:48.867 --> 00:20:51.200
People often ask the question,
well I have all this CSS.

00:20:51.200 --> 00:20:52.270
I need all of it.

00:20:52.270 --> 00:20:54.210
What do you mean critical?

00:20:54.210 --> 00:20:56.770
How do I know what's
critical and what's not?

00:20:56.770 --> 00:20:59.870
So again, critical CSS is that
needed to position and style

00:20:59.870 --> 00:21:01.920
content in the initial view.

00:21:01.920 --> 00:21:04.990
So imagine we have
this alert CSS rule,

00:21:04.990 --> 00:21:07.740
and then we've got this markup
served up in the initial HTML.

00:21:07.740 --> 00:21:10.340
So it's going to be
visible in the initial view

00:21:10.340 --> 00:21:13.030
that references that rule.

00:21:13.030 --> 00:21:16.810
We expect it to look like
this on the page initially.

00:21:16.810 --> 00:21:19.290
We expect it to have
their proper stylings.

00:21:19.290 --> 00:21:21.870
A good way to ask yourself,
is this critical CSS or not,

00:21:21.870 --> 00:21:24.420
is to ask well, if I took
this rule out of the payload,

00:21:24.420 --> 00:21:27.050
would my initial view with the
content I serve to the user

00:21:27.050 --> 00:21:29.540
initially look correctly?

00:21:29.540 --> 00:21:32.910
And in this case obviously,
if we took that rule out,

00:21:32.910 --> 00:21:34.480
it would get the
default stylings

00:21:34.480 --> 00:21:35.800
and look totally wrong.

00:21:35.800 --> 00:21:40.990
So clearly, we need this
CSS to style content

00:21:40.990 --> 00:21:44.370
in the initial view, and
thus it is critical CSS.

00:21:44.370 --> 00:21:45.770
And we want to
serve it up early,

00:21:45.770 --> 00:21:47.080
and in a render-blocking way.

00:21:50.440 --> 00:21:53.030
So imagine we changed
our HTML markup there.

00:21:53.030 --> 00:21:56.330
So you can see before it
was .

00:21:56.330 --> 00:21:57.859
Now we decide, OK,
we don't really

00:21:57.859 --> 00:21:59.400
want to mark hello
world as an alert.

00:21:59.400 --> 00:22:01.910
It's just a normal
snippet of text.

00:22:01.910 --> 00:22:05.207
We want it to be styled as such.

00:22:05.207 --> 00:22:07.540
So imagine, though, that we
do use the alert class later

00:22:07.540 --> 00:22:08.040
in the app.

00:22:08.040 --> 00:22:12.110
Like imagine your user is
interacting with the app.

00:22:12.110 --> 00:22:13.440
They try to upload a video.

00:22:13.440 --> 00:22:14.080
It fails.

00:22:14.080 --> 00:22:15.705
You want to show an
alert at that time.

00:22:15.705 --> 00:22:17.990
So we do need it, but
we don't need this rule

00:22:17.990 --> 00:22:19.840
as part of the initial view.

00:22:19.840 --> 00:22:22.770
At that point, it's not
part of the initial view,

00:22:22.770 --> 00:22:24.870
and so it's no longer
critical and you

00:22:24.870 --> 00:22:27.960
may want to think about loading
that later in the app life

00:22:27.960 --> 00:22:32.794
cycle, in a way that doesn't
block the initial view.

00:22:32.794 --> 00:22:33.460
So one more bit.

00:22:33.460 --> 00:22:34.450
I think this is
actually, probably--

00:22:34.450 --> 00:22:36.783
this is somewhat subtle, but
probably the most important

00:22:36.783 --> 00:22:40.044
thing we talk
about critical CSS.

00:22:40.044 --> 00:22:42.710
The critical CSS is that the CSS
is needed to position and style

00:22:42.710 --> 00:22:44.850
the content in the initial view.

00:22:44.850 --> 00:22:49.360
So oftentimes, we inline
data URIs into our CSS,

00:22:49.360 --> 00:22:51.850
the goal being OK, let's
reduce the number of requests

00:22:51.850 --> 00:22:52.670
that my page makes.

00:22:52.670 --> 00:22:54.690
I can serve up the
image separately,

00:22:54.690 --> 00:22:57.360
or I can inline
right into my CSS.

00:22:57.360 --> 00:23:02.400
And interestingly, what we are
doing when we inline these data

00:23:02.400 --> 00:23:04.260
URIs for images,
is we're basically

00:23:04.260 --> 00:23:07.290
promoting the image from
being non-render-blocking,

00:23:07.290 --> 00:23:09.880
not part of the critical
render path, because images

00:23:09.880 --> 00:23:12.480
by default-- they obviously
need to download the image

00:23:12.480 --> 00:23:15.640
to render the image itself--
but images don't block rendering

00:23:15.640 --> 00:23:17.880
of other content on the screen.

00:23:17.880 --> 00:23:19.900
When we inline it
as a data URI here,

00:23:19.900 --> 00:23:22.180
we basically promoted it
to being render-blocking,

00:23:22.180 --> 00:23:24.440
to being part of the
critical rendering path,

00:23:24.440 --> 00:23:26.731
and we're making that critical
rendering path that much

00:23:26.731 --> 00:23:27.290
longer.

00:23:27.290 --> 00:23:31.950
And so data URIs too, they
tend to be quite big, right?

00:23:31.950 --> 00:23:32.825
So here's our markup.

00:23:35.400 --> 00:23:37.140
So if you look at
your CSS, and you're

00:23:37.140 --> 00:23:38.520
using this technique
lots of sites do,

00:23:38.520 --> 00:23:39.978
you'll notice
probably the majority

00:23:39.978 --> 00:23:41.750
of bites in your CSS
files may actually

00:23:41.750 --> 00:23:43.167
be from these inline data URIs.

00:23:43.167 --> 00:23:45.750
And what you're doing is, you're
increasing that critical path

00:23:45.750 --> 00:23:48.860
length pretty significantly,
and actually causing users

00:23:48.860 --> 00:23:50.640
to have to wait to
see any content at all

00:23:50.640 --> 00:23:52.650
on the screen as a result.

00:23:52.650 --> 00:23:57.070
So you'll actually render the
other content on the screen

00:23:57.070 --> 00:24:00.516
more quickly if you just
switch back to that CSS sprite

00:24:00.516 --> 00:24:01.890
with the external
file reference,

00:24:01.890 --> 00:24:04.560
or, if you're using something
like [INAUDIBLE] where spriting

00:24:04.560 --> 00:24:06.540
doesn't really bring
you any benefit,

00:24:06.540 --> 00:24:09.710
just keeping each
image asset separate,

00:24:09.710 --> 00:24:11.880
reducing the size
of the CSS, reducing

00:24:11.880 --> 00:24:13.630
the size of your
critical rendering path,

00:24:13.630 --> 00:24:17.987
and making the page load
that much more quickly.

00:24:17.987 --> 00:24:19.320
This is pretty easy to test out.

00:24:19.320 --> 00:24:20.950
Create a simple page.

00:24:20.950 --> 00:24:23.300
Inline a bunch of data
URIs and a style sheet.

00:24:23.300 --> 00:24:25.952
Create a second
version that page.

00:24:25.952 --> 00:24:27.410
Use the technique
here where you've

00:24:27.410 --> 00:24:28.900
got a separate image asset.

00:24:28.900 --> 00:24:31.260
Make sure there's some
non-image content on the page,

00:24:31.260 --> 00:24:33.510
so put some text in
there, whatever it may be.

00:24:33.510 --> 00:24:35.260
And then compare the
two in web page test.

00:24:35.260 --> 00:24:36.980
Do a video comparison
on a 3G network.

00:24:36.980 --> 00:24:39.057
And you'll see that when
you inline data URIs

00:24:39.057 --> 00:24:40.640
into your style
sheet, you're blocking

00:24:40.640 --> 00:24:42.348
rendering of all the
content on the page.

00:24:42.348 --> 00:24:46.390
You're blocking the
text, whatever it may be.

00:24:46.390 --> 00:24:49.950
So on mobile, again where
downloading additional content

00:24:49.950 --> 00:24:53.000
in the critical rendering
path is expensive,

00:24:53.000 --> 00:24:55.910
I encourage people to
not take that approach--

00:24:55.910 --> 00:24:58.620
except for maybe
very small data URIs.

00:24:58.620 --> 00:25:02.577
I would say that large data URIs
inlined in render-blocking CSS

00:25:02.577 --> 00:25:04.410
are actually harmful
for render performance,

00:25:04.410 --> 00:25:11.617
and I would avoid
using that approach.

00:25:11.617 --> 00:25:12.950
So then a couple more questions.

00:25:12.950 --> 00:25:15.270
OK, so I've identified
my critical CSS.

00:25:15.270 --> 00:25:16.520
I've removed my data URIS.

00:25:16.520 --> 00:25:17.840
I made it nice and small.

00:25:17.840 --> 00:25:20.320
How should I load
that critical CSS?

00:25:20.320 --> 00:25:22.740
So there's two ways
to go about this.

00:25:22.740 --> 00:25:24.340
In PageSpeed
Insights we actually

00:25:24.340 --> 00:25:28.000
in line the critical CSS
as a style block in line,

00:25:28.000 --> 00:25:30.450
keeping that critical rendering
path as short as we can.

00:25:30.450 --> 00:25:32.120
We don't want to
go back to network

00:25:32.120 --> 00:25:34.760
to download an external
style sheet, in our case,

00:25:34.760 --> 00:25:37.180
because that incurs additional
network round trips, which

00:25:37.180 --> 00:25:40.190
can add anywhere from 500
millis to maybe a second,

00:25:40.190 --> 00:25:42.477
depending on how
it's loaded, of time

00:25:42.477 --> 00:25:44.060
the user is staring
at a blank screen.

00:25:44.060 --> 00:25:47.300
So for us, we felt like the
best approach was to inline.

00:25:47.300 --> 00:25:50.390
The CSS needed to style
the initial view directly

00:25:50.390 --> 00:25:52.780
in our HTML payload.

00:25:52.780 --> 00:25:55.010
But I wouldn't say that's
necessarily a requirement.

00:25:55.010 --> 00:25:56.950
I think it's still
perfectly reasonable

00:25:56.950 --> 00:26:00.370
to load that critical
CSS resource, as long

00:26:00.370 --> 00:26:03.190
as the critical resource
is small, in the head,

00:26:03.190 --> 00:26:04.310
as an external resource.

00:26:04.310 --> 00:26:05.789
The page will be
slower for people

00:26:05.789 --> 00:26:07.330
who don't have the
resource in cache,

00:26:07.330 --> 00:26:08.913
because now they
have to go to network

00:26:08.913 --> 00:26:12.280
to download that
additional resource.

00:26:12.280 --> 00:26:13.810
But you've got some
other benefits.

00:26:13.810 --> 00:26:16.169
You're reducing bytes sent
on the wire for repeat views,

00:26:16.169 --> 00:26:17.960
because once it's in
cache the user doesn't

00:26:17.960 --> 00:26:19.650
have to download it again.

00:26:19.650 --> 00:26:22.980
You may introduce a faster
full cache experience

00:26:22.980 --> 00:26:23.680
for repeat view.

00:26:23.680 --> 00:26:24.460
It really depends.

00:26:24.460 --> 00:26:25.580
It's not guaranteed
by any means.

00:26:25.580 --> 00:26:27.246
It's sort of a little
counter intuitive.

00:26:27.246 --> 00:26:29.810
You would think, well the
HTML payload is smaller,

00:26:29.810 --> 00:26:31.860
so the page should load faster.

00:26:31.860 --> 00:26:35.164
But it actually depends, it's
not necessarily the case.

00:26:35.164 --> 00:26:37.580
But in any case, either of
these approaches is reasonable.

00:26:37.580 --> 00:26:38.480
And it really just depends.

00:26:38.480 --> 00:26:39.563
You're making a trade off.

00:26:39.563 --> 00:26:42.050
Do I want the
fastest performance?

00:26:42.050 --> 00:26:43.552
In which case, you
want to inline.

00:26:43.552 --> 00:26:45.010
Or do I want a
little bit, perhaps,

00:26:45.010 --> 00:26:47.020
more maintainable approach?

00:26:47.020 --> 00:26:49.940
In which case you
could keep it external,

00:26:49.940 --> 00:26:54.510
and pay a little bit of a
performance penalty for that.

00:26:54.510 --> 00:26:58.600
So things get kind of fuzzier
the further along we go here.

00:26:58.600 --> 00:27:02.050
So the last bit, once we've
loaded our critical CSS-- now

00:27:02.050 --> 00:27:04.470
we've got this other CSS
needed to style other parts

00:27:04.470 --> 00:27:06.720
of our app-- how do we
load that in a way that

00:27:06.720 --> 00:27:09.370
doesn't block
rendering of the page?

00:27:09.370 --> 00:27:15.331
Unfortunately, today there's not
a great simple, straightforward

00:27:15.331 --> 00:27:15.830
technique.

00:27:15.830 --> 00:27:17.496
Like we have with
script, we have async.

00:27:17.496 --> 00:27:20.444
It's a really easy, first
class feature of the platform.

00:27:20.444 --> 00:27:22.110
The same does not
exist for style sheet.

00:27:22.110 --> 00:27:24.880
Any style sheet found in
the document by the parser

00:27:24.880 --> 00:27:28.584
will cause the rendering
engine to say, OK,

00:27:28.584 --> 00:27:30.250
I'm going to wait and
not paint anything

00:27:30.250 --> 00:27:32.650
until I finished fully
downloading this style sheet.

00:27:32.650 --> 00:27:35.600
So you can't just throw link
rel stylesheet href equals

00:27:35.600 --> 00:27:38.087
noncritical CSS in the
footer of your HTML.

00:27:38.087 --> 00:27:39.170
The parser will find that.

00:27:39.170 --> 00:27:41.200
And as soon as it does,
if it hasn't painted

00:27:41.200 --> 00:27:42.908
the content above yet,
it will say, whoa,

00:27:42.908 --> 00:27:46.337
I'm not going to paint anything,
even the markup above that,

00:27:46.337 --> 00:27:47.670
until that finishes downloading.

00:27:47.670 --> 00:27:51.020
So you have to be careful here.

00:27:51.020 --> 00:27:52.870
So what we want is this
lazy load attribute.

00:27:52.870 --> 00:27:54.320
And that's coming soon.

00:27:54.320 --> 00:27:56.030
Some Chrome engineers,
IE engineers

00:27:56.030 --> 00:27:57.680
are working together on a spec.

00:27:57.680 --> 00:28:00.730
And what that says basically--
it's similar to async--

00:28:00.730 --> 00:28:02.812
and it basically says,
I need this resource.

00:28:02.812 --> 00:28:04.020
It shouldn't block rendering.

00:28:04.020 --> 00:28:05.430
It shouldn't block onload.

00:28:05.430 --> 00:28:08.000
Load it, and when it's
available, I'll make use of it.

00:28:08.000 --> 00:28:09.750
In the meantime, we
don't have that today.

00:28:09.750 --> 00:28:10.250
It's coming.

00:28:10.250 --> 00:28:11.670
It's being speced.

00:28:11.670 --> 00:28:13.730
There are a couple ways
you can work around this.

00:28:17.220 --> 00:28:19.420
It's listed here.
requestAnimationFrame,

00:28:19.420 --> 00:28:21.050
so you wait for the first paint.

00:28:21.050 --> 00:28:23.892
You could load the
resource and hidden iframe.

00:28:23.892 --> 00:28:25.600
You could actually
load it as JavaScript.

00:28:25.600 --> 00:28:26.720
I've seen people do this.

00:28:26.720 --> 00:28:29.470
JavaScript has async, so you
could load a CSS resource

00:28:29.470 --> 00:28:30.480
to JavaScript.

00:28:30.480 --> 00:28:35.240
As I say each of these, part
of me is feeling not great.

00:28:35.240 --> 00:28:39.060
This is really not
the kind of APIs

00:28:39.060 --> 00:28:41.170
we want for this kind of thing.

00:28:41.170 --> 00:28:44.050
But fortunately, the lazy
load attribute is coming,

00:28:44.050 --> 00:28:47.230
and that will be the right thing
to use once that's shipped.

00:28:50.750 --> 00:28:52.615
So some high level
recommendations

00:28:52.615 --> 00:28:55.600
for render-blocking CSS.

00:28:55.600 --> 00:28:57.270
How are we doing on time?

00:28:57.270 --> 00:28:59.670
A couple minutes.

00:28:59.670 --> 00:29:02.309
Avoid inlining data URIs.

00:29:02.309 --> 00:29:03.100
Keep them external.

00:29:03.100 --> 00:29:06.330
Keep the CSS as
small as possible.

00:29:06.330 --> 00:29:08.707
Critical CSS, what that
is, keeping that in mind,

00:29:08.707 --> 00:29:11.040
and making sure you're focusing
on only delivering that.

00:29:11.040 --> 00:29:12.926
But all this said--
and if you're

00:29:12.926 --> 00:29:14.550
hearing me talk about
this critical CSS

00:29:14.550 --> 00:29:16.550
and oh, I have to load
some early and some late,

00:29:16.550 --> 00:29:19.240
and that sounds like
a lot of overhead--

00:29:19.240 --> 00:29:22.190
the good news is if your
total CSS is reasonably small,

00:29:22.190 --> 00:29:24.270
like if it's under
say 15k compressed,

00:29:24.270 --> 00:29:26.730
which might mean
45km compressed,

00:29:26.730 --> 00:29:28.859
it's probably small
enough that you can just

00:29:28.859 --> 00:29:29.900
treat it all as critical.

00:29:29.900 --> 00:29:32.100
Just don't worry about
partitioning out.

00:29:32.100 --> 00:29:33.989
It's only when it
becomes really big

00:29:33.989 --> 00:29:35.530
that you don't want
to load all of it

00:29:35.530 --> 00:29:38.970
in a way that blocks rendering
anything at all to the screen.

00:29:38.970 --> 00:29:44.122
So the common case, I hope, is
that your CSS is already small,

00:29:44.122 --> 00:29:45.830
and you just load that
up front and don't

00:29:45.830 --> 00:29:48.669
worry about this concept
of noncritical CSS.

00:29:48.669 --> 00:29:50.210
If you do have a
lot of CSS, you want

00:29:50.210 --> 00:29:51.960
to load that in a
render-blocking manner--

00:29:51.960 --> 00:29:53.860
we talked about the two
techniques for that--

00:29:53.860 --> 00:29:56.318
and then load the remaining
CSS in that non-blocking manner

00:29:56.318 --> 00:29:59.290
using, for the time being, one
of those requestAnimationFrame

00:29:59.290 --> 00:30:01.880
or whatever it may be
techniques, longer term using

00:30:01.880 --> 00:30:04.690
that lazy load attribute.

00:30:04.690 --> 00:30:08.080
So just to summarize really high
level, the things that we found

00:30:08.080 --> 00:30:09.380
were really important.

00:30:09.380 --> 00:30:12.060
Eliminate render-block
in JavaScript.

00:30:12.060 --> 00:30:13.500
Load JavaScript asynchronously.

00:30:13.500 --> 00:30:15.690
Get it out of the
critical rendering path.

00:30:15.690 --> 00:30:19.230
So design your apps
with that in mind.

00:30:19.230 --> 00:30:21.440
Don't depend JavaScript
having to load synchronously

00:30:21.440 --> 00:30:22.970
in order to render your page.

00:30:22.970 --> 00:30:25.560
And along those lines,
render the initial view

00:30:25.560 --> 00:30:27.440
to HTML on the server.

00:30:27.440 --> 00:30:29.840
So don't use JavaScript
client-side to render

00:30:29.840 --> 00:30:31.070
the initial view.

00:30:31.070 --> 00:30:32.460
It's an inherently slow process.

00:30:32.460 --> 00:30:35.670
We saw Twitter had performance
problems with this, Airbnb,

00:30:35.670 --> 00:30:37.480
my team had the same issues.

00:30:37.480 --> 00:30:40.480
And then finally,
serve up as little CSS

00:30:40.480 --> 00:30:42.580
as you need to render
the initial view.

00:30:42.580 --> 00:30:46.890
Be mindful of just how
much you're serving.

00:30:46.890 --> 00:30:48.500
And largely, you
can accomplish that

00:30:48.500 --> 00:30:50.910
by just not inlining large
data URIs in your CSS.

00:30:50.910 --> 00:30:52.810
I think if we stop
doing that, I think

00:30:52.810 --> 00:30:55.600
our CSS size, for the most
part, will become manageable,

00:30:55.600 --> 00:30:59.260
and will be reasonable to
load in a render-blocking way.

00:30:59.260 --> 00:31:02.190
So that's everything.

