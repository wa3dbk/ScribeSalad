WEBVTT
Kind: captions
Language: en

00:00:00.700 --> 00:00:03.460
MIKE MAHEMOFF: Yes, so as
Sam said, I'm Mike.

00:00:03.460 --> 00:00:06.950
Right now, I'm actually working
on Player FM, which is

00:00:06.950 --> 00:00:08.330
very much around audio.

00:00:08.330 --> 00:00:10.980
So audio is really the aspect
of media that's been most

00:00:10.980 --> 00:00:12.200
interesting to me.

00:00:12.200 --> 00:00:15.700
And as well as that, it is
actually a responsive web app.

00:00:15.700 --> 00:00:18.470
So images for any web app is
going to be important.

00:00:18.470 --> 00:00:22.200
And I think something that I
focus a lot on is the concept

00:00:22.200 --> 00:00:26.890
of developer experience, and
looking at developers as users

00:00:26.890 --> 00:00:30.540
as well, and basically
understanding what it's like

00:00:30.540 --> 00:00:33.790
for a developer to perform
any particular task.

00:00:33.790 --> 00:00:36.100
And what are the complications
they're having?

00:00:36.100 --> 00:00:40.940
For me, as just working
as a one man band, my

00:00:40.940 --> 00:00:42.160
time is very valuable.

00:00:42.160 --> 00:00:45.700
And so a lot of this too
is not just about pure

00:00:45.700 --> 00:00:46.460
functionality--

00:00:46.460 --> 00:00:48.590
what sort of media capabilities
have we got?

00:00:48.590 --> 00:00:51.340
But it's also about making it
really straightforward for

00:00:51.340 --> 00:00:54.030
developers to do it without
having to spend too much time.

00:00:54.030 --> 00:00:56.080
I know most of my images
are kind of

00:00:56.080 --> 00:00:57.190
responsive to the user.

00:00:57.190 --> 00:01:00.070
They look responsive, but
they're loading way too much

00:01:00.070 --> 00:01:02.490
data, just because I don't
have the time to do

00:01:02.490 --> 00:01:03.350
it the right way.

00:01:03.350 --> 00:01:06.170
So those are the kinds of things
I hope we can focus on

00:01:06.170 --> 00:01:07.470
as well today.

00:01:07.470 --> 00:01:09.130
So do you want to go around,
and we'll just really

00:01:09.130 --> 00:01:10.410
briefly-- we're pretty
short on time.

00:01:10.410 --> 00:01:14.740
So just say who you are
and what you do.

00:01:14.740 --> 00:01:15.560
JUSTIN UBERTI: Hi, I'm
Justin Uberti.

00:01:15.560 --> 00:01:18.060
I'm a tech lead for Chrome.

00:01:18.060 --> 00:01:20.880
And I am one of the founders
of WebRTC.

00:01:24.500 --> 00:01:26.040
JASON GRIGSBY: Hi, I'm
Jason Grigsby.

00:01:26.040 --> 00:01:28.090
I'm one of the co-founders
of Cloud Four.

00:01:28.090 --> 00:01:31.470
And I've spent way too
much time looking

00:01:31.470 --> 00:01:33.410
at responsive images.

00:01:33.410 --> 00:01:34.740
JOHN MELLOR: Hi, I'm
John Mellor.

00:01:34.740 --> 00:01:36.480
I work for Chrome for
Android in London.

00:01:36.480 --> 00:01:40.200
I've got view ports and worked
on those kinds of things.

00:01:40.200 --> 00:01:43.580
And I like to work on
images as well.

00:01:43.580 --> 00:01:44.640
ANDRE BEHRENS: My name
is Andre Behrens.

00:01:44.640 --> 00:01:47.720
I work for the "New York Times"
on the Chrome app.

00:01:47.720 --> 00:01:50.770
And my job title is developer
advocate.

00:01:50.770 --> 00:01:52.390
My real title is troublemaker.

00:01:52.390 --> 00:01:53.600
And I have complained
to the Chrome

00:01:53.600 --> 00:01:56.730
team a lot about images.

00:01:56.730 --> 00:01:58.700
MIKE MAHEMOFF: So I thought
actually Andre might be a good

00:01:58.700 --> 00:01:59.140
person to start.

00:01:59.140 --> 00:02:01.970
Because you've got some
impressively scary stats about

00:02:01.970 --> 00:02:05.200
how many images you have to deal
with at "New York Times."

00:02:05.200 --> 00:02:08.050
Do you want to talk a little bit
about the challenges you

00:02:08.050 --> 00:02:11.165
face and how you actually
deal with them?

00:02:11.165 --> 00:02:13.300
ANDRE BEHRENS: The challenge we
face is that we publish 300

00:02:13.300 --> 00:02:14.550
articles every day--

00:02:17.750 --> 00:02:20.210
300, 300 articles every day.

00:02:20.210 --> 00:02:22.370
And if you're making something
that's supposed to show the

00:02:22.370 --> 00:02:25.260
whole "New York Times," that
means you have to show 300.

00:02:25.260 --> 00:02:28.830
So to give an example of how
awful that is, I used to have

00:02:28.830 --> 00:02:31.810
a section that came from our
"Times" wire feed that would

00:02:31.810 --> 00:02:33.770
do the last 24 hours
of articles.

00:02:33.770 --> 00:02:36.796
And it crashed the app,
so I took it out.

00:02:36.796 --> 00:02:39.440
It just couldn't load
that much stuff.

00:02:39.440 --> 00:02:43.580
And we like to show these nice,
big, beautiful images

00:02:43.580 --> 00:02:46.830
that we pay people a lot of
money to put up to take-- and

00:02:46.830 --> 00:02:49.330
that they put their lives
on the line to get

00:02:49.330 --> 00:02:50.650
a lot of the times.

00:02:50.650 --> 00:02:53.150
And those big, beautiful images
in it, in order to fit

00:02:53.150 --> 00:02:56.500
into our apps, the way we used
to do it on the website was

00:02:56.500 --> 00:03:00.500
the whole thing was structured
kind of around the images.

00:03:00.500 --> 00:03:01.806
This is how big it can be,
because this is how

00:03:01.806 --> 00:03:03.080
big the image is.

00:03:03.080 --> 00:03:05.390
And so we would just have people
manually cutting them

00:03:05.390 --> 00:03:08.900
whenever they could, pulling
from this giant database.

00:03:08.900 --> 00:03:12.130
And now we're trying to move
into a more fluid style, both

00:03:12.130 --> 00:03:14.490
on our website and in
some of our apps.

00:03:14.490 --> 00:03:18.010
And a big reckoning call was
when the iPad came out.

00:03:18.010 --> 00:03:20.810
And they were saying, well, we
don't want to have to look.

00:03:20.810 --> 00:03:23.630
Because we would have images
for certain things in

00:03:23.630 --> 00:03:24.570
different sizes.

00:03:24.570 --> 00:03:26.420
They didn't fit together.

00:03:26.420 --> 00:03:30.180
So we made people put
in the big ones.

00:03:30.180 --> 00:03:31.590
So now you're doing a
thing where you're

00:03:31.590 --> 00:03:33.735
resizing all your images--

00:03:33.735 --> 00:03:35.560
big performance problem.

00:03:35.560 --> 00:03:38.090
And then, retina stuff
came out, and these

00:03:38.090 --> 00:03:40.200
stupid pixels came out.

00:03:40.200 --> 00:03:43.750
And now the main image we use--
that's the main one to

00:03:43.750 --> 00:03:44.845
work with-- is called jumbo.

00:03:44.845 --> 00:03:49.810
And that's 1024 by 768, which is
full screen on an old iPad.

00:03:49.810 --> 00:03:53.120
Then, the retinas came out, so
we had to double the size.

00:03:53.120 --> 00:03:55.640
So they are 2048 on a side.

00:03:55.640 --> 00:03:58.840
And they take a long
time to download.

00:03:58.840 --> 00:04:00.820
And they take a long
time to render.

00:04:00.820 --> 00:04:03.270
And they affect everything
else.

00:04:03.270 --> 00:04:06.100
And if you are casually resizing
them, which a lot of

00:04:06.100 --> 00:04:08.090
our developers will be inclined
to do in this sort of

00:04:08.090 --> 00:04:10.810
lazy way, it slows
everything down.

00:04:10.810 --> 00:04:13.290
And it doesn't make sense why
it's taking so long to load.

00:04:13.290 --> 00:04:16.910
And it's just a problem.

00:04:16.910 --> 00:04:19.010
MIKE MAHEMOFF: And do you have
any particular techniques that

00:04:19.010 --> 00:04:20.709
you're using to pick
up on that?

00:04:24.010 --> 00:04:26.320
ANDRE BEHRENS: We are
considering a fairly insane

00:04:26.320 --> 00:04:28.850
one for the Chrome app.

00:04:28.850 --> 00:04:34.020
We actually built an enormous
Amazon-backed socket connected

00:04:34.020 --> 00:04:37.660
system that has multiple
balancing layers.

00:04:37.660 --> 00:04:40.750
And I raised the crazy idea,
well, why don't we just draw

00:04:40.750 --> 00:04:44.050
every image at every
pixel size--

00:04:44.050 --> 00:04:48.400
1024, 1023, 1022, 1021, 1020.

00:04:48.400 --> 00:04:51.090
And I went to the guys, and I
said, why don't we do it?

00:04:51.090 --> 00:04:53.350
And they were like,
storage is cheap.

00:04:53.350 --> 00:04:57.190
So we might try that--

00:04:57.190 --> 00:04:59.176
no promises.

00:04:59.176 --> 00:05:01.580
But I don't think that's really
realistic for the

00:05:01.580 --> 00:05:03.240
average web developer.

00:05:03.240 --> 00:05:05.900
MIKE MAHEMOFF: Yeah, well it
sort of leads to responsive

00:05:05.900 --> 00:05:07.610
images-- one sec.

00:05:07.610 --> 00:05:09.450
You can come up and ask a
question after, actually, if

00:05:09.450 --> 00:05:10.680
you want to come up now.

00:05:10.680 --> 00:05:10.965
ROB: We're doing that now.

00:05:10.965 --> 00:05:13.250
MIKE MAHEMOFF: Oh, OK, you're
already doing that technique

00:05:13.250 --> 00:05:15.780
of drawing images at
every dimension.

00:05:15.780 --> 00:05:17.020
ROB: Whatever's requested.

00:05:17.020 --> 00:05:18.575
MIKE MAHEMOFF: Whatever's
requested, you'll just pull it

00:05:18.575 --> 00:05:21.265
out and probably cache
it on demand, right?

00:05:21.265 --> 00:05:23.400
Yeah, OK, and who are you?

00:05:23.400 --> 00:05:23.955
Can you say?

00:05:23.955 --> 00:05:24.280
ROB: I'm sorry.

00:05:24.280 --> 00:05:25.126
Rob from "Times."

00:05:25.126 --> 00:05:28.270
MIKE MAHEMOFF: Rob from
"Financial Times," OK, so it

00:05:28.270 --> 00:05:30.530
sort of leads to responsive
images, which you guys are

00:05:30.530 --> 00:05:31.960
working on pretty closely.

00:05:31.960 --> 00:05:34.420
Do either of you want
to comment?

00:05:34.420 --> 00:05:36.520
JOHN MELLOR: I'll start by
making a distinction.

00:05:36.520 --> 00:05:40.410
There's fixed width images, like
maybe a logo or an icon,

00:05:40.410 --> 00:05:43.310
where the main problem is
resolution switching.

00:05:43.310 --> 00:05:44.590
You want to load your
retina image or

00:05:44.590 --> 00:05:45.610
your non-retina image.

00:05:45.610 --> 00:05:47.430
And it's not just 1x and 2x.

00:05:47.430 --> 00:05:49.100
So you've got more ones.

00:05:49.100 --> 00:05:51.660
But there's actually
a simpler problem.

00:05:51.660 --> 00:05:53.675
And the really hard problem
tends to be where flexible

00:05:53.675 --> 00:05:55.130
width images were.

00:05:55.130 --> 00:05:56.770
You want the image to be--

00:05:56.770 --> 00:05:57.890
say its width 100% is CSS.

00:05:57.890 --> 00:06:00.940
It needs to match the size of
the page for whatever device

00:06:00.940 --> 00:06:02.310
you're loading it on.

00:06:02.310 --> 00:06:05.170
And doing [INAUDIBLE]
mark-up is really

00:06:05.170 --> 00:06:08.200
tricky at the moment.

00:06:08.200 --> 00:06:11.000
JASON GRIGSBY: Yeah, so the way
that I tend to think about

00:06:11.000 --> 00:06:14.290
it is, we've got a big conflict
between what the

00:06:14.290 --> 00:06:17.650
browser wants, which is to be
able to start requesting

00:06:17.650 --> 00:06:21.150
assets as soon as it can
recognize the assets in the

00:06:21.150 --> 00:06:24.310
document, versus what people
want to do in responsive

00:06:24.310 --> 00:06:27.460
design, which is to have the
elements on the page, and

00:06:27.460 --> 00:06:33.600
particular images, basically
size based on the element that

00:06:33.600 --> 00:06:36.420
it actually is, like the size
of the element in the page.

00:06:36.420 --> 00:06:39.400
And to me, it's sort of akin to
when I've gone on vacations

00:06:39.400 --> 00:06:43.520
with members of our family who
want to script every part of

00:06:43.520 --> 00:06:44.480
the vacation.

00:06:44.480 --> 00:06:46.610
And then, you've got other
people who don't want to plan

00:06:46.610 --> 00:06:47.690
ahead at all.

00:06:47.690 --> 00:06:51.190
And those are incredibly
tense vacations.

00:06:51.190 --> 00:06:53.790
And that's what's going on
from sort of an imaging

00:06:53.790 --> 00:06:56.590
perspective, where we've got
this conflict between what

00:06:56.590 --> 00:06:59.020
responsive design people
generally want to do, which is

00:06:59.020 --> 00:07:02.730
to wait until the layout is
determined by the viewport

00:07:02.730 --> 00:07:05.540
size and other characteristics
of the device, and what the

00:07:05.540 --> 00:07:08.480
browser wants to do, which is
to start selecting assets as

00:07:08.480 --> 00:07:09.730
soon as it can.

00:07:12.430 --> 00:07:13.730
JUSTIN UBERTI: One of the things
I think is interesting

00:07:13.730 --> 00:07:17.200
is that for a long time, we were
sort of told that JPEG

00:07:17.200 --> 00:07:20.410
was fine, that JPEG was
a standard algorithm.

00:07:20.410 --> 00:07:21.220
We should all use that.

00:07:21.220 --> 00:07:24.240
If you save 20%, it doesn't
really matter.

00:07:24.240 --> 00:07:28.870
Now, with retina size images,
saving 20 or 30% is actually

00:07:28.870 --> 00:07:30.830
translating into real user
experience benefit.

00:07:30.830 --> 00:07:34.590
And so with WebP, where we can
get an additional 30, 40%

00:07:34.590 --> 00:07:37.070
compression on images, that
makes a real difference in

00:07:37.070 --> 00:07:41.390
terms of page mode when the
actual vast majority of the

00:07:41.390 --> 00:07:43.805
bytes is coming from images.

00:07:43.805 --> 00:07:46.810
MIKE MAHEMOFF: OK, but what
are the actual practical

00:07:46.810 --> 00:07:50.440
techniques you're seeing, for
instance, Jason, in terms of--

00:07:50.440 --> 00:07:52.180
are people using JavaScript?

00:07:52.180 --> 00:07:57.150
Are people finding it just
doesn't work in practice?

00:07:57.150 --> 00:08:03.560
JASON GRIGSBY: So I think the
first answer is that there

00:08:03.560 --> 00:08:06.260
isn't a solution that isn't
sort of a hack, right?

00:08:06.260 --> 00:08:10.250
What people are doing right
now is picking which

00:08:10.250 --> 00:08:12.970
compromise they want to use.

00:08:12.970 --> 00:08:15.360
So what we've been
advising people--

00:08:15.360 --> 00:08:20.180
and I just recently consulted
a company that has over

00:08:20.180 --> 00:08:21.260
800,000 images.

00:08:21.260 --> 00:08:23.000
And they've got a very
similar process.

00:08:23.000 --> 00:08:24.290
Images are coming
in all the time.

00:08:24.290 --> 00:08:25.140
They're dealing with
this stuff.

00:08:25.140 --> 00:08:29.500
And essentially, what we're
looking at is, one, they've

00:08:29.500 --> 00:08:31.250
been hand cutting everything.

00:08:31.250 --> 00:08:34.390
They're moving to a system that
will automate resizing on

00:08:34.390 --> 00:08:35.500
the server.

00:08:35.500 --> 00:08:37.830
And then, they're actually
using picture fills.

00:08:37.830 --> 00:08:39.659
So they're using the JavaScript
library to make

00:08:39.659 --> 00:08:43.690
decisions like what the picture
element would do if

00:08:43.690 --> 00:08:46.530
the picture element
were to come out.

00:08:46.530 --> 00:08:52.430
But they're centralizing that
into a single function so that

00:08:52.430 --> 00:08:57.080
when it changes, whatever the
new format will be, whatever

00:08:57.080 --> 00:08:59.070
the standard ends up
being, they can

00:08:59.070 --> 00:09:00.520
quickly change that out.

00:09:00.520 --> 00:09:02.780
Because it's clear that whatever
you implement now

00:09:02.780 --> 00:09:03.530
will be deprecated.

00:09:03.530 --> 00:09:04.670
We just don't know what
it's going to be

00:09:04.670 --> 00:09:08.916
deprecated in favor of.

00:09:08.916 --> 00:09:10.850
JOHN MELLOR: So it's a balance
between quality, performance,

00:09:10.850 --> 00:09:11.920
and simplicity.

00:09:11.920 --> 00:09:14.610
There aren't really any simple
approaches at the moment for

00:09:14.610 --> 00:09:15.750
flexible width images.

00:09:15.750 --> 00:09:17.085
So that's out, anyway.

00:09:17.085 --> 00:09:20.100
But then, you want the
images to load fast.

00:09:20.100 --> 00:09:21.960
And we also want to
load high quality.

00:09:21.960 --> 00:09:26.240
And it's kind of a fundamental
conflict between these.

00:09:26.240 --> 00:09:28.680
So in terms of techniques with
flexible width images, there's

00:09:28.680 --> 00:09:29.260
JavaScript.

00:09:29.260 --> 00:09:32.950
But JavaScript techniques tend
to load images only when the

00:09:32.950 --> 00:09:36.540
DOM is fully loaded, a
DOMContentLoaded event.

00:09:36.540 --> 00:09:39.430
And by this point, typically
about a third of the page's

00:09:39.430 --> 00:09:41.970
content, including all the
resources, has already

00:09:41.970 --> 00:09:43.290
finished downloading.

00:09:43.290 --> 00:09:45.420
And the page would be ready to
display if it weren't for the

00:09:45.420 --> 00:09:47.930
images, which is holding
everything back.

00:09:47.930 --> 00:09:50.270
And so it's really too
late to be requesting

00:09:50.270 --> 00:09:51.580
images at that point.

00:09:51.580 --> 00:09:54.120
And the images need to be
somehow in the markup before

00:09:54.120 --> 00:09:56.270
that happens.

00:09:56.270 --> 00:09:57.340
MIKE MAHEMOFF: So what's
the solution?

00:09:57.340 --> 00:10:00.236
It sounds almost like
it can't be solved.

00:10:00.236 --> 00:10:05.715
JOHN MELLOR: Yeah, so there
are some server-side

00:10:05.715 --> 00:10:08.410
solutions, and you can do device
detection, which isn't

00:10:08.410 --> 00:10:11.380
great, because device
databases suck.

00:10:11.380 --> 00:10:14.070
You can do things like setting
cookies or changing the base

00:10:14.070 --> 00:10:17.430
href for your page at the
top of your head.

00:10:17.430 --> 00:10:23.680
And then, any images requested
relative URL will be served

00:10:23.680 --> 00:10:26.270
from an appropriate directory
in your server.

00:10:26.270 --> 00:10:28.635
And you'll set up base href
based on the screen width and

00:10:28.635 --> 00:10:30.810
the device pixel ratio,
for example.

00:10:30.810 --> 00:10:32.790
So there are techniques
you can use today

00:10:32.790 --> 00:10:33.670
that sort of work.

00:10:33.670 --> 00:10:36.970
But yeah, we need better
solutions in the future.

00:10:36.970 --> 00:10:38.160
MIKE MAHEMOFF: And what's
happening with that, the

00:10:38.160 --> 00:10:38.910
picture element?

00:10:38.910 --> 00:10:40.920
Is that something that's
realistically going to be

00:10:40.920 --> 00:10:44.241
coming out this year,
for instance?

00:10:44.241 --> 00:10:45.500
JOHN MELLOR: The picture
element's under

00:10:45.500 --> 00:10:47.260
discussion a lot.

00:10:47.260 --> 00:10:48.220
There's [INAUDIBLE]

00:10:48.220 --> 00:10:50.520
you can go read.

00:10:50.520 --> 00:10:53.320
I think it doesn't seem
like it at the moment.

00:10:53.320 --> 00:10:55.910
And everyone's still hashing
out use cases

00:10:55.910 --> 00:10:57.790
for it, and so on.

00:10:57.790 --> 00:11:00.890
It also doesn't really solve
this problem directly.

00:11:00.890 --> 00:11:05.150
Because you still get this
fundamental conflict--

00:11:05.150 --> 00:11:06.396
well, not conflict.

00:11:06.396 --> 00:11:08.900
But to actually put a picture
element that will load the

00:11:08.900 --> 00:11:11.670
right image on various different
devices or different

00:11:11.670 --> 00:11:15.140
resolutions, you need 10
different rules for every

00:11:15.140 --> 00:11:18.330
single image, like all the
widths times all the device

00:11:18.330 --> 00:11:19.720
pixel ratios.

00:11:19.720 --> 00:11:21.760
And it's really hard
to actually--

00:11:21.760 --> 00:11:26.160
well, it is not a great
solution [INAUDIBLE].

00:11:26.160 --> 00:11:29.220
MIKE MAHEMOFF: OK, does anyone
else want to comment about the

00:11:29.220 --> 00:11:31.140
whole issue of images
before we move on to

00:11:31.140 --> 00:11:34.150
WebRTC, and so on?

00:11:34.150 --> 00:11:36.950
Or any questions, by
the way, feel free.

00:11:36.950 --> 00:11:38.680
ANDRE BEHRENS: Just to add on,
the same problem with the

00:11:38.680 --> 00:11:41.880
performance, the developers are
not used to dealing with

00:11:41.880 --> 00:11:42.690
this at all.

00:11:42.690 --> 00:11:45.860
Because literally the easiest
thing in the world to do in a

00:11:45.860 --> 00:11:49.430
web page, is put an image
referred to a URL and have it

00:11:49.430 --> 00:11:51.640
show up, and you do nothing.

00:11:51.640 --> 00:11:52.420
And now I'm coming to you--

00:11:52.420 --> 00:11:55.020
OK, so we need about
30 different sizes.

00:11:55.020 --> 00:11:56.480
And we have these different
stop points in

00:11:56.480 --> 00:11:57.260
our responsive design.

00:11:57.260 --> 00:11:58.090
We're going to put
these in here.

00:11:58.090 --> 00:11:59.250
And you have to think about
putting this here.

00:11:59.250 --> 00:12:01.210
And maybe we're changing
formats.

00:12:01.210 --> 00:12:05.480
And nobody on our team has ever
thought about this in

00:12:05.480 --> 00:12:08.610
their life ever until
right now.

00:12:08.610 --> 00:12:10.235
They have no experience
with it.

00:12:13.210 --> 00:12:15.620
JASON GRIGSBY: I think one
of the things that--

00:12:15.620 --> 00:12:19.560
so I've spent a lot of time
working with the responsive

00:12:19.560 --> 00:12:22.040
images community group and
talking about the different

00:12:22.040 --> 00:12:26.990
use cases, whether it's the art
direction use case or the

00:12:26.990 --> 00:12:28.290
resolution switching use case.

00:12:28.290 --> 00:12:31.880
And all of this has been in an
effort to sort of create that

00:12:31.880 --> 00:12:35.830
balance between what the
preparser wants and what

00:12:35.830 --> 00:12:38.250
responsive designers want.

00:12:38.250 --> 00:12:42.550
And I was talking yesterday
about how, increasingly, I'm

00:12:42.550 --> 00:12:46.410
beginning to wonder if it is
solvable, or if we're going to

00:12:46.410 --> 00:12:48.560
end up in a situation where
we have to choose

00:12:48.560 --> 00:12:49.610
between one or the other.

00:12:49.610 --> 00:12:54.010
And so Estelle has this
really, really amazing

00:12:54.010 --> 00:12:59.100
technique using SVG where you
can do media queries inside

00:12:59.100 --> 00:13:01.040
SVG, and SVG also does raster.

00:13:01.040 --> 00:13:04.660
And so basically, you can have
an SVG image that is basically

00:13:04.660 --> 00:13:10.290
an image bundle that
is responsive.

00:13:10.290 --> 00:13:12.520
SVG isn't supported across--

00:13:12.520 --> 00:13:13.560
it isn't on Android 2.3.

00:13:13.560 --> 00:13:17.020
And there are some other sort
of weird quirks around SVG,

00:13:17.020 --> 00:13:20.350
because SVG is sort of
weird generally.

00:13:20.350 --> 00:13:21.840
But it's promising.

00:13:21.840 --> 00:13:26.030
And more importantly to me, it's
like the moment I saw the

00:13:26.030 --> 00:13:30.280
clown car technique, which
has an awesome name.

00:13:30.280 --> 00:13:33.140
I found myself thinking that
if I had access to this, I

00:13:33.140 --> 00:13:35.710
would totally use it.

00:13:35.710 --> 00:13:38.340
Because it's actually the
problem that I want to solve.

00:13:38.340 --> 00:13:41.460
I want to make decisions about
the size of images and the

00:13:41.460 --> 00:13:44.430
sources of images based on the
size of the images in the

00:13:44.430 --> 00:13:48.950
page, not based on device width,
not based on viewport

00:13:48.950 --> 00:13:51.220
width, not based on all these.

00:13:51.220 --> 00:13:53.420
All those other things are
basically like wearing boxing

00:13:53.420 --> 00:13:55.290
gloves and trying to
pick a pencil up

00:13:55.290 --> 00:13:56.550
off the ground, right?

00:13:56.550 --> 00:13:58.880
They're crude implements.

00:13:58.880 --> 00:14:02.740
And so when I saw the clown car
technique, I'm not sure if

00:14:02.740 --> 00:14:05.510
that actually will end up being
something that we, as

00:14:05.510 --> 00:14:08.070
web designers, end up using.

00:14:08.070 --> 00:14:13.360
But if it actually worked, I
don't think that the preparser

00:14:13.360 --> 00:14:14.780
would have a choice.

00:14:14.780 --> 00:14:17.000
I think web designers would
adopt it, and just move

00:14:17.000 --> 00:14:19.830
forward, and say, figure
it out, browsers.

00:14:19.830 --> 00:14:22.050
MIKE MAHEMOFF: Right, but that
would need the browsers to

00:14:22.050 --> 00:14:23.960
support that format, really.

00:14:23.960 --> 00:14:26.530
JASON GRIGSBY: Well, the format

00:14:26.530 --> 00:14:28.320
works in a lot of ways--

00:14:28.320 --> 00:14:30.440
nearly all modern browsers.

00:14:30.440 --> 00:14:34.310
So that's not as much of an
issue as it is that, by doing

00:14:34.310 --> 00:14:37.895
so, then you are in fact causing
the problems that John

00:14:37.895 --> 00:14:40.550
was talking about, where the
images can't be requested

00:14:40.550 --> 00:14:43.700
until much later.

00:14:43.700 --> 00:14:45.050
JOHN MELLOR: So there's really
two things on the horizon that

00:14:45.050 --> 00:14:47.770
I see as possible solutions
to this.

00:14:47.770 --> 00:14:50.120
One is the client-end setter,
proposed by [INAUDIBLE], in

00:14:50.120 --> 00:14:53.480
fact, where the browser would
provide information as to its

00:14:53.480 --> 00:14:58.370
device pixel ratio and device
width with every HTP request.

00:14:58.370 --> 00:15:00.100
And this would allow servers--

00:15:00.100 --> 00:15:02.360
you would just specify a single
image in your markup,

00:15:02.360 --> 00:15:05.102
and the server would send you an
appropriate image based on

00:15:05.102 --> 00:15:08.520
your device using this
information without any device

00:15:08.520 --> 00:15:11.456
databases and that kind
of [INAUDIBLE].

00:15:11.456 --> 00:15:14.530
The other, and perhaps the
most promising but least

00:15:14.530 --> 00:15:18.630
certain solution, is to use
a progressive image format

00:15:18.630 --> 00:15:20.940
coupled with smarter browsers.

00:15:20.940 --> 00:15:23.930
The idea is web developers
would save one ultra high

00:15:23.930 --> 00:15:27.270
resolution image in a
progressive format, link to

00:15:27.270 --> 00:15:30.380
that in their website, and then
the browser would only

00:15:30.380 --> 00:15:32.800
load as many bytes
as it needs.

00:15:32.800 --> 00:15:35.300
So initially, the browser would
start loading all the

00:15:35.300 --> 00:15:38.470
images on a page in parallel,
because it knows it's going to

00:15:38.470 --> 00:15:42.280
need at least some data
for all those images.

00:15:42.280 --> 00:15:46.060
But then, based on the layout
size of the image, it'll then

00:15:46.060 --> 00:15:48.680
decide when to stop downloading
images.

00:15:48.680 --> 00:15:51.080
And maybe even if you pinch zoom
in, it'll load some more

00:15:51.080 --> 00:15:53.430
images at that point.

00:15:53.430 --> 00:15:56.230
So actually Simon Jordan has
got a prototype of this.

00:15:56.230 --> 00:15:57.320
We're looking into it--

00:15:57.320 --> 00:15:59.360
no promises yet.

00:15:59.360 --> 00:16:03.990
MIKE MAHEMOFF: Cool, so we
should move onto WebRTC.

00:16:03.990 --> 00:16:06.250
Well, I think Sam asked an
interesting question, which is

00:16:06.250 --> 00:16:07.740
kind of the standard one.

00:16:07.740 --> 00:16:09.070
Do you want to ask that
question again?

00:16:12.694 --> 00:16:16.450
SAM: Yeah, just really, I see
WebRTC with mobile as the

00:16:16.450 --> 00:16:18.100
natural home of WebRTC.

00:16:18.100 --> 00:16:23.420
And I'm just wondering where
we can take this beyond the

00:16:23.420 --> 00:16:24.700
kind of obvious application--

00:16:24.700 --> 00:16:31.350
video chat apps and so on-- so
obviously directed at Justin.

00:16:31.350 --> 00:16:33.600
JUSTIN UBERTI: So I think
there's a bunch of use cases

00:16:33.600 --> 00:16:37.840
that people are starting to
realize where WebRTC is not

00:16:37.840 --> 00:16:38.990
just making a phone call.

00:16:38.990 --> 00:16:41.090
It's being used to kind of
take media that's on one

00:16:41.090 --> 00:16:43.180
device and push it
onto another.

00:16:43.180 --> 00:16:45.980
And one example is that you have
this very small screen

00:16:45.980 --> 00:16:46.570
for a phone.

00:16:46.570 --> 00:16:48.850
And wouldn't it be nice if you
could take that and shoot that

00:16:48.850 --> 00:16:50.910
somewhere else?

00:16:50.910 --> 00:16:54.040
Another thing is just that I
think a lot of carriers who

00:16:54.040 --> 00:16:57.300
typically had very, very long
cycles to update any sort of

00:16:57.300 --> 00:17:00.490
phone or device that's on their
network now see this

00:17:00.490 --> 00:17:02.660
idea to be able to push in a web
app as a way to provide a

00:17:02.660 --> 00:17:07.010
lot more value added services,
and do this in a way where it

00:17:07.010 --> 00:17:09.410
prevents them from being kind
of just like a pipe.

00:17:09.410 --> 00:17:13.760
And one of the things that's a
challenge to get from where we

00:17:13.760 --> 00:17:16.359
are now to there is the fact
that right now, if you're a

00:17:16.359 --> 00:17:20.160
web app, your traffic is
competing with, as I like to

00:17:20.160 --> 00:17:21.460
say, cat videos.

00:17:21.460 --> 00:17:23.930
You want to send voice traffic
or video traffic, and you're

00:17:23.930 --> 00:17:25.280
just another packet
on the internet.

00:17:25.280 --> 00:17:27.119
But carriers have the
ability to do

00:17:27.119 --> 00:17:28.480
prioritization for traffic.

00:17:28.480 --> 00:17:30.100
They do this already
for voice.

00:17:30.100 --> 00:17:32.420
The voice calls that you make
are sent over a separate thing

00:17:32.420 --> 00:17:35.170
than all the actual
3G and 4G data.

00:17:35.170 --> 00:17:39.170
And to be able to expose that
QoS stuff to these voice

00:17:39.170 --> 00:17:42.065
communication apps is what's
going to be able to make it on

00:17:42.065 --> 00:17:45.770
a level playing field and allow
this web communication

00:17:45.770 --> 00:17:48.235
to be the future of telephony
and communications.

00:17:52.070 --> 00:17:54.170
MIKE MAHEMOFF: Sort of related
to that, the whole issue of

00:17:54.170 --> 00:17:56.230
performance and bandwidth,
is also peer to peer.

00:17:56.230 --> 00:18:00.460
And that's also potentially a
big part of WebRTC, right?

00:18:00.460 --> 00:18:01.770
JUSTIN UBERTI: Sure, and I think
that you can think of

00:18:01.770 --> 00:18:03.390
things like video
distribution.

00:18:03.390 --> 00:18:06.180
One of the historical challenges
for over the top

00:18:06.180 --> 00:18:09.820
video sites is that every time
you have a new subscriber,

00:18:09.820 --> 00:18:11.640
that's an additional amount
of bandwidth you

00:18:11.640 --> 00:18:12.470
need to send down.

00:18:12.470 --> 00:18:14.845
And if you compare that to the
broadcast model where they put

00:18:14.845 --> 00:18:16.830
up the towers, there's a fixed
cost, and then they have as

00:18:16.830 --> 00:18:18.570
many subscribers as they want.

00:18:18.570 --> 00:18:23.150
Moving to over the top video
is a lot more costly.

00:18:23.150 --> 00:18:24.190
But if we think about--

00:18:24.190 --> 00:18:28.230
for popular videos, if you could
then sort of get some of

00:18:28.230 --> 00:18:30.750
the data from peers who are down
your street or something

00:18:30.750 --> 00:18:33.100
like that, what could that
do to the actual data

00:18:33.100 --> 00:18:34.540
distribution cost?

00:18:34.540 --> 00:18:38.120
And WebRTC makes peer to
peer possible for just

00:18:38.120 --> 00:18:39.470
a regular web app.

00:18:39.470 --> 00:18:41.180
And I think you're going to
see some very interesting

00:18:41.180 --> 00:18:43.990
transformations based on that.

00:18:43.990 --> 00:18:46.140
MIKE MAHEMOFF: Yeah, I heard
someone from BitTorrent

00:18:46.140 --> 00:18:49.400
talking about this as such a
tragedy that for each extra

00:18:49.400 --> 00:18:53.160
user as a video user, you sort
of actually have to pay for

00:18:53.160 --> 00:18:53.920
that bandwidth.

00:18:53.920 --> 00:18:56.855
Whereas from someone like
BitTorrent's point of view, or

00:18:56.855 --> 00:18:59.790
a peer to peer network, it's
actually a benefit for every

00:18:59.790 --> 00:19:00.300
extra user.

00:19:00.300 --> 00:19:01.530
It's the exact opposite.

00:19:01.530 --> 00:19:04.010
So it is a real tragedy that
it doesn't happen.

00:19:04.010 --> 00:19:06.400
And I think he was explaining
that it was to do with

00:19:06.400 --> 00:19:09.690
analytics and content owners
wanting to be able to track

00:19:09.690 --> 00:19:11.060
this sort of thing
and license it.

00:19:11.060 --> 00:19:14.130
But I think those solutions are
also still possible with

00:19:14.130 --> 00:19:15.910
WebRTC, aren't they?

00:19:15.910 --> 00:19:18.090
JUSTIN UBERTI: Yeah, that's
definitely true.

00:19:18.090 --> 00:19:21.740
I mean, I think that just
because you're not sending the

00:19:21.740 --> 00:19:24.260
actual bytes of data down to
the client doesn't mean you

00:19:24.260 --> 00:19:26.470
can't still collect analytics,
doesn't mean you can't still

00:19:26.470 --> 00:19:28.880
collect play counts and
that sort of thing.

00:19:28.880 --> 00:19:31.510
There still has to be some
master tracker to know where

00:19:31.510 --> 00:19:32.600
you get your data from.

00:19:32.600 --> 00:19:35.450
And so you can still keep all
those things in control, but

00:19:35.450 --> 00:19:37.670
you'll send 1/1,000
of the data.

00:19:37.670 --> 00:19:39.400
You don't need to actually
send a two

00:19:39.400 --> 00:19:42.998
megabit 720p stream.

00:19:42.998 --> 00:19:44.910
MIKE MAHEMOFF: So we've got
a question from Matt.

00:19:44.910 --> 00:19:46.350
Is Matt here, Matt Lockier?

00:19:51.978 --> 00:19:53.228
OK, you can read your
own question then.

00:19:56.770 --> 00:20:01.852
MATT LOCKIER: OK, oh yeah,
it was just sort of--

00:20:01.852 --> 00:20:05.760
oh, this is kind of unrelated
really to this section.

00:20:05.760 --> 00:20:07.283
Did I ask another one?

00:20:07.283 --> 00:20:10.990
Oh yeah, what's the status
of the audio API?

00:20:10.990 --> 00:20:14.280
Also, will it kill my battery if
I'm analyzing for a really,

00:20:14.280 --> 00:20:17.170
really long time, like if I'm
just listening and doing

00:20:17.170 --> 00:20:19.835
distortion and trying to provide
cool things on mobile?

00:20:26.540 --> 00:20:29.230
JUSTIN UBERTI: So we're trying
to get the Web Audio API lit

00:20:29.230 --> 00:20:29.950
up on mobile.

00:20:29.950 --> 00:20:33.230
And Ray, who's in the back of
the room, would be the person

00:20:33.230 --> 00:20:35.020
who has the best
answer on that.

00:20:35.020 --> 00:20:38.440
But one of the great things
about Web Audio is that the

00:20:38.440 --> 00:20:41.125
heavy lifting of the actual
audio processing is done sort

00:20:41.125 --> 00:20:44.170
of inside the browser, not
necessarily by JavaScript.

00:20:44.170 --> 00:20:46.230
So it can be done very,
very efficiently.

00:20:46.230 --> 00:20:51.000
And one of things I expect that
we'll see going forward

00:20:51.000 --> 00:20:53.300
on mobile is that more and more
stuff will get offloaded

00:20:53.300 --> 00:20:54.320
to hardware.

00:20:54.320 --> 00:20:56.650
And so if there are cases where
we're seeing the stuff

00:20:56.650 --> 00:20:59.595
really used for hotword
detection, or things like that

00:20:59.595 --> 00:21:03.730
for speech, if it's killing
battery, we'll find some way

00:21:03.730 --> 00:21:07.900
to make it efficient so that
your phone lasts all day.

00:21:10.980 --> 00:21:13.430
MIKE MAHEMOFF: Also just
thinking about video a bit,

00:21:13.430 --> 00:21:16.930
I've got a question here from
Rayhan, who's a friend of mine

00:21:16.930 --> 00:21:17.860
in London, actually.

00:21:17.860 --> 00:21:19.170
And he's basically
got a start-up to

00:21:19.170 --> 00:21:20.570
do with real estate.

00:21:20.570 --> 00:21:23.320
And he was wondering about how
he could use the camera and

00:21:23.320 --> 00:21:26.110
actually sort of overlay things,
or do programmatic

00:21:26.110 --> 00:21:29.240
transformations on top of it
as part of the stream that

00:21:29.240 --> 00:21:33.960
gets recorded and played
back or uploaded.

00:21:33.960 --> 00:21:36.210
JUSTIN UBERTI: Does he mean in
the user interface, or for

00:21:36.210 --> 00:21:38.750
actually sort of decorating the
video as it's captured?

00:21:38.750 --> 00:21:40.542
MIKE MAHEMOFF: Yeah, potentially
uploading that or

00:21:40.542 --> 00:21:41.440
streaming that.

00:21:41.440 --> 00:21:44.000
JUSTIN UBERTI: Right, so I
mentioned Web Audio is not

00:21:44.000 --> 00:21:46.070
something that can be used to
actually post-process the

00:21:46.070 --> 00:21:47.710
audio after it's captured.

00:21:47.710 --> 00:21:50.355
And we're adding a similar
sort of API for video.

00:21:50.355 --> 00:21:52.720
This is kind of all pre-standard
stuff, but

00:21:52.720 --> 00:21:57.290
something where, within your
actual web application, you

00:21:57.290 --> 00:21:59.770
can get the audio,
then process it.

00:21:59.770 --> 00:22:01.903
If you wanted to do some sort
of special effect to it, put

00:22:01.903 --> 00:22:05.200
on a silly hat or whatever,
you could then take that,

00:22:05.200 --> 00:22:08.060
process it in JavaScript, and
then when it's sent out to

00:22:08.060 --> 00:22:10.150
whatever the other peer is
that's going to then consume

00:22:10.150 --> 00:22:12.610
it on the server, or maybe just
your friend on the other

00:22:12.610 --> 00:22:15.940
side of the country, they'll
see the post-process video.

00:22:15.940 --> 00:22:18.320
And you could also imagine
just generating a video

00:22:18.320 --> 00:22:19.540
stream, too.

00:22:19.540 --> 00:22:22.840
Perhaps it's not a traditional
sort of video chat example.

00:22:22.840 --> 00:22:25.340
But maybe you want some way to
check in on some sort of

00:22:25.340 --> 00:22:26.950
sensor network or something.

00:22:26.950 --> 00:22:29.560
And the way it does so is
through some video output.

00:22:29.560 --> 00:22:34.410
And you could create this actual
thing from some API.

00:22:34.410 --> 00:22:36.500
MIKE MAHEMOFF: JavaScript.

00:22:36.500 --> 00:22:38.530
JASON GRIGSBY: Just on the
subject of video, I've

00:22:38.530 --> 00:22:40.690
actually got a request.

00:22:40.690 --> 00:22:43.160
And that's to get the
adaptive streaming

00:22:43.160 --> 00:22:45.610
stuff sorted out ASAP.

00:22:45.610 --> 00:22:52.350
For people who are attempting to
do responsive design, from

00:22:52.350 --> 00:22:53.810
a responsive design
perspective,

00:22:53.810 --> 00:22:54.850
you'd like to have--

00:22:54.850 --> 00:22:57.570
in the same way in which images
are a problem, source

00:22:57.570 --> 00:22:59.250
video is an issue, right?

00:22:59.250 --> 00:23:03.710
So you can provide
different codets.

00:23:03.710 --> 00:23:05.890
But ideally, what you'd like
is, you'd like different

00:23:05.890 --> 00:23:09.420
sources based on bit
rate, based on

00:23:09.420 --> 00:23:10.580
the size of the screen.

00:23:10.580 --> 00:23:12.800
It doesn't make sense for
somebody on a phone to

00:23:12.800 --> 00:23:15.890
download a 1080p video.

00:23:15.890 --> 00:23:21.580
And at the moment, we've got
HTTP live streaming on iOS.

00:23:21.580 --> 00:23:24.610
But we don't yet have
implementations on the other

00:23:24.610 --> 00:23:28.090
mobile devices so that we can
do the same sort of stuff.

00:23:28.090 --> 00:23:32.550
And so I know that there's a
lot of work going into it.

00:23:32.550 --> 00:23:34.120
I hope to see it on
devices soon.

00:23:34.120 --> 00:23:37.650
Because if you end up in the
video space, it becomes very

00:23:37.650 --> 00:23:38.170
problematic.

00:23:38.170 --> 00:23:41.150
And you basically have to,
again, sort of make JavaScript

00:23:41.150 --> 00:23:43.806
changes in order to
make it happen.

00:23:50.020 --> 00:23:55.140
MIKE MAHEMOFF: OK, yeah, so then
that becomes a challenge

00:23:55.140 --> 00:23:57.510
of you'd have to actually have
all those videos, right?

00:23:57.510 --> 00:23:59.570
So again, you might have to do
something like Andre was

00:23:59.570 --> 00:24:02.300
talking about of actually
generating those videos on the

00:24:02.300 --> 00:24:04.560
fly, which could
be quite scary.

00:24:04.560 --> 00:24:06.760
ANDRE BEHRENS: We're doing
more of that, too.

00:24:06.760 --> 00:24:08.212
MIKE MAHEMOFF: Getting
into that, yeah.

00:24:11.830 --> 00:24:15.300
JASON GRIGSBY: The days of save
to the web for video or

00:24:15.300 --> 00:24:17.430
for images are over.

00:24:17.430 --> 00:24:20.600
You need some way to automate
it on the server side.

00:24:20.600 --> 00:24:22.220
MIKE MAHEMOFF: It leaves us
some interesting denial of

00:24:22.220 --> 00:24:24.840
service possibilities,
doesn't it?

00:24:24.840 --> 00:24:28.720
If you generate every pixel, or
every quality level, then

00:24:28.720 --> 00:24:32.530
you have to generate a new
whole video for that.

00:24:32.530 --> 00:24:34.230
JUSTIN UBERTI: You don't have
to generate every sort of

00:24:34.230 --> 00:24:34.535
combination.

00:24:34.535 --> 00:24:36.890
I think the matrix can still
be fairly sparse.

00:24:36.890 --> 00:24:40.190
Because really, you see this
sort of linear progression of

00:24:40.190 --> 00:24:41.930
bit rate goes up with
resolution.

00:24:41.930 --> 00:24:44.870
And so if you watch Netflix,
what you'll see is that they

00:24:44.870 --> 00:24:46.980
start sending you the lowest
quality thing while they're

00:24:46.980 --> 00:24:48.830
still figuring out what
bandwidth you

00:24:48.830 --> 00:24:49.430
can actually support.

00:24:49.430 --> 00:24:53.690
And as you actually say, oh,
I can support 240p, 360p,

00:24:53.690 --> 00:24:55.460
they'll keep ramping you up.

00:24:55.460 --> 00:24:58.240
In Chrome, we do this through
the media source API, which is

00:24:58.240 --> 00:25:01.060
the ability to sort of feed
in blocks of video.

00:25:01.060 --> 00:25:04.220
And those blocks can keep
going up in size.

00:25:04.220 --> 00:25:07.070
As each block comes in, the
actual entire video--

00:25:07.070 --> 00:25:08.770
you don't have to get the
whole thing each time.

00:25:08.770 --> 00:25:10.120
You just get each
little chunk.

00:25:10.120 --> 00:25:13.270
And each chunk can be in
a different resolution.

00:25:13.270 --> 00:25:15.030
MIKE MAHEMOFF: That makes
sense, actually--

00:25:15.030 --> 00:25:16.980
sort of a little bit like
media query breakpoints.

00:25:16.980 --> 00:25:19.110
You'd end up with.

00:25:19.110 --> 00:25:22.140
So just last question
before we wrap up is

00:25:22.140 --> 00:25:23.640
about Blink, actually.

00:25:23.640 --> 00:25:27.310
Also Matt asked, what are
we going to see about

00:25:27.310 --> 00:25:28.050
fragmentation?

00:25:28.050 --> 00:25:29.805
And what are we going to see
from Blink in general?

00:25:32.600 --> 00:25:34.425
This is for all the media types
we've been discussing.

00:25:40.200 --> 00:25:41.440
JASON GRIGSBY: I believe
that Blink is--

00:25:41.440 --> 00:25:45.510
no, I can't speak to this.

00:25:45.510 --> 00:25:46.850
JOHN MELLOR: Blink's goal is to
work closer to [INAUDIBLE]

00:25:46.850 --> 00:25:47.690
community.

00:25:47.690 --> 00:25:50.720
And so we're going to try
and avoid [INAUDIBLE].

00:25:50.720 --> 00:25:53.650
We're also trying to add more
testing about WPC, and so on.

00:25:53.650 --> 00:25:55.845
And so we're tyring to make sure
that the implementations

00:25:55.845 --> 00:25:59.090
of different browsers
are interoperable.

00:25:59.090 --> 00:26:03.855
And so no particular media
has been on this.

00:26:03.855 --> 00:26:06.650
It's kind of hard.

00:26:06.650 --> 00:26:07.520
JUSTIN UBERTI: I think just
one of the interesting

00:26:07.520 --> 00:26:12.150
questions is, what will
Blink mean for WebKit?

00:26:12.150 --> 00:26:14.420
Because there are a
lot of Chromian

00:26:14.420 --> 00:26:16.240
people working on WebKit.

00:26:16.240 --> 00:26:19.850
And now that they're not there,
what will that mean for

00:26:19.850 --> 00:26:21.840
the velocity of WebKit?

00:26:21.840 --> 00:26:24.320
I don't know the
answer to that.

00:26:24.320 --> 00:26:25.970
MIKE MAHEMOFF: Very much
an open question, so--

00:26:25.970 --> 00:26:28.234
yeah, Bruce.

00:26:28.234 --> 00:26:28.970
BRUCE: Can I ask a question?

00:26:28.970 --> 00:26:30.680
MIKE MAHEMOFF: Yeah, go on--
one quick question, yeah.

00:26:30.680 --> 00:26:33.850
BRUCE: About WebP--

00:26:33.850 --> 00:26:36.035
hi, Bruce from Opera.

00:26:36.035 --> 00:26:39.280
At Opera, we like WebP.

00:26:39.280 --> 00:26:41.750
And we've used it for a long
time in the Presto

00:26:41.750 --> 00:26:42.990
incarnation.

00:26:42.990 --> 00:26:45.320
We've got something called Opera
Turbo to speed up the

00:26:45.320 --> 00:26:47.420
desktop on slower networks.

00:26:47.420 --> 00:26:50.340
And that transcodes images
on the fly to

00:26:50.340 --> 00:26:52.220
WebP on slow networks.

00:26:52.220 --> 00:26:54.210
That's still faster than

00:26:54.210 --> 00:26:55.830
rendering the JPEG or whatever.

00:26:58.500 --> 00:27:00.610
WebP is Google's format.

00:27:00.610 --> 00:27:04.940
What plans are there to
popularize it and make it more

00:27:04.940 --> 00:27:05.700
widespread?

00:27:05.700 --> 00:27:07.440
I know that Firefox's initial

00:27:07.440 --> 00:27:09.520
opposition seems to be softening.

00:27:09.520 --> 00:27:13.260
I wonder if Microsoft's
opposition might soften now

00:27:13.260 --> 00:27:17.550
that the WebM format
is clarified

00:27:17.550 --> 00:27:19.475
vis-a-vis the MPEG LA.

00:27:19.475 --> 00:27:23.210
But what are you going to do
to allow it to fall back on

00:27:23.210 --> 00:27:26.310
browsers that don't support
WebP, for example?

00:27:26.310 --> 00:27:27.300
JOHN MELLOR: It's
a good question.

00:27:27.300 --> 00:27:28.550
Ilya, do you want to give them
more on this, perhaps.

00:27:31.260 --> 00:27:34.120
ILYA: So part of the answer is,
we have a session on WebP

00:27:34.120 --> 00:27:35.890
tomorrow where we're going
to cover exactly that.

00:27:35.890 --> 00:27:39.620
But the short of it is, I
think we can make the

00:27:39.620 --> 00:27:41.410
negotiation of WebP
much simpler.

00:27:41.410 --> 00:27:44.315
So today, it's actually hard
to deploy WebP, right?

00:27:44.315 --> 00:27:46.630
Either you have to use a
JavaScript fall back, either

00:27:46.630 --> 00:27:50.400
you need to use a user agent
sniffing solution, and neither

00:27:50.400 --> 00:27:51.430
one of those is good.

00:27:51.430 --> 00:27:54.250
So we're actually fixing a bunch
of things in Chrome to

00:27:54.250 --> 00:27:54.890
make that easier.

00:27:54.890 --> 00:27:55.880
So you guys actually--

00:27:55.880 --> 00:27:58.500
Opera has been advertising
image WebP in Accept.

00:27:58.500 --> 00:28:01.510
We're lending that, and Chrome
now is in Canary.

00:28:01.510 --> 00:28:02.810
That's going to fix
a lot of things.

00:28:02.810 --> 00:28:05.070
It makes it very simple.

00:28:05.070 --> 00:28:06.930
Just recently, we actually
had an integration

00:28:06.930 --> 00:28:09.890
with an image CDN.

00:28:09.890 --> 00:28:11.490
So CDN Connect--

00:28:11.490 --> 00:28:14.050
cool service which does all
the imagery sizing and

00:28:14.050 --> 00:28:15.260
everything on the fly.

00:28:15.260 --> 00:28:18.710
It'll also detect that you're
advertising the right accept

00:28:18.710 --> 00:28:20.880
header and serve the
appropriate image.

00:28:20.880 --> 00:28:21.870
So that's one example.

00:28:21.870 --> 00:28:24.290
Another example is something--
so I'm sure you guys have

00:28:24.290 --> 00:28:25.400
heard that Facebook was

00:28:25.400 --> 00:28:27.510
experimenting with WebP, right?

00:28:27.510 --> 00:28:30.490
And they ran into a couple of
issues where users would save

00:28:30.490 --> 00:28:32.200
the image, but then they
can't open it.

00:28:32.200 --> 00:28:34.060
So we're fixing that as well.

00:28:34.060 --> 00:28:35.750
Right now, we've registered
Chrome to

00:28:35.750 --> 00:28:37.330
be the default viewer.

00:28:37.330 --> 00:28:39.110
So at least you can
double click on it

00:28:39.110 --> 00:28:40.340
and view the image.

00:28:40.340 --> 00:28:42.100
Now, can you open
it in Photoshop?

00:28:42.100 --> 00:28:43.170
You need a plug-in for that.

00:28:43.170 --> 00:28:45.660
And this kind of thing
takes time.

00:28:45.660 --> 00:28:47.720
One kind of crazy and
interesting idea that we're

00:28:47.720 --> 00:28:52.600
also experimenting with is, what
if you had a safe Save

00:28:52.600 --> 00:28:54.970
option, which is, when you right
click, and you click,

00:28:54.970 --> 00:28:58.250
and you go Save As, we save,
I don't know, a JPEG or

00:28:58.250 --> 00:29:00.440
something, which is transcoded
to some format that we know

00:29:00.440 --> 00:29:01.310
that works?

00:29:01.310 --> 00:29:03.200
And this is not specific
to WebP, right?

00:29:03.200 --> 00:29:05.930
I hope that we have more image
formats in the future.

00:29:05.930 --> 00:29:08.480
And if we can have the right
mechanisms to address these

00:29:08.480 --> 00:29:11.440
issues, whether that's accept
header and a save and all the

00:29:11.440 --> 00:29:14.170
rest, that'll help everybody.

00:29:14.170 --> 00:29:17.760
BRUCE: Well, there's a level
four CSS module whose name

00:29:17.760 --> 00:29:21.540
escapes me, because it's
typically snappily titled.

00:29:21.540 --> 00:29:26.520
And instead of saying,
background image URL blah dot

00:29:26.520 --> 00:29:29.130
PNG, you can say, background
image.

00:29:29.130 --> 00:29:30.440
And then, it's image.

00:29:30.440 --> 00:29:32.375
And then there, you can
give a list of images.

00:29:32.375 --> 00:29:34.490
So you can have WebP,
then comma JPEG.

00:29:34.490 --> 00:29:36.360
And that would make developers'
lives a lot easier

00:29:36.360 --> 00:29:38.770
if that were turned
on in Blink.

00:29:38.770 --> 00:29:39.930
ILYA: So that's really
interesting.

00:29:39.930 --> 00:29:41.140
I actually wanted to ask--

00:29:41.140 --> 00:29:42.780
I know that we're running
out of time.

00:29:42.780 --> 00:29:44.640
But I want to ask you
guys about this.

00:29:44.640 --> 00:29:50.320
So I think that solutions like
picture tag make the whole

00:29:50.320 --> 00:29:52.270
situation much worse and
much more complicated.

00:29:52.270 --> 00:29:57.250
Negotiating which format, or
which compression level, like

00:29:57.250 --> 00:29:59.960
2x versus 1x--

00:29:59.960 --> 00:30:01.170
you don't compress.

00:30:01.170 --> 00:30:03.730
You don't have an index
HTML and index dot

00:30:03.730 --> 00:30:06.380
html.gz on your server.

00:30:06.380 --> 00:30:08.320
The server just does
that for you.

00:30:08.320 --> 00:30:11.130
Negotiating 1x versus
2x versus 2.5x

00:30:11.130 --> 00:30:12.720
should be the same thing.

00:30:12.720 --> 00:30:15.900
Are we actually doing the
developers a favor by giving

00:30:15.900 --> 00:30:18.390
them a picture tag, which is
15 lines long, because you

00:30:18.390 --> 00:30:22.920
have a combinatorial explosion
of image formats times number,

00:30:22.920 --> 00:30:26.130
or DPI resolutions times number
of art directions times

00:30:26.130 --> 00:30:27.940
number whatever?

00:30:27.940 --> 00:30:31.160
It just seems like
a step backwards.

00:30:31.160 --> 00:30:32.900
ANDRE BEHRENS: I am strongly
in favor of not having to

00:30:32.900 --> 00:30:34.150
think about things.

00:30:38.220 --> 00:30:39.110
JASON GRIGSBY: Is it a favor?

00:30:39.110 --> 00:30:41.830
No.

00:30:41.830 --> 00:30:42.660
Part of the reason--

00:30:42.660 --> 00:30:48.310
I look at this like whether
it's picture or SRC set or

00:30:48.310 --> 00:30:50.950
whatever it is, continue
to advance those.

00:30:50.950 --> 00:30:53.640
Because if people don't like
them, sooner or later,

00:30:53.640 --> 00:30:54.970
somebody will be motivated
to come out

00:30:54.970 --> 00:30:56.700
with something better.

00:30:56.700 --> 00:30:59.850
And so the problem is
truly a problem.

00:30:59.850 --> 00:31:01.590
And it's a problem for the
clients that we consult with.

00:31:01.590 --> 00:31:03.720
It's a problem on the
projects we work on.

00:31:03.720 --> 00:31:08.550
So we've got to continue to try
to find better solutions.

00:31:08.550 --> 00:31:09.730
ILYA: So this is interesting.

00:31:09.730 --> 00:31:12.590
Because when I talk to W3C and
other communities, they

00:31:12.590 --> 00:31:16.610
actually tell me, hey, no, we
really want a markup solution.

00:31:16.610 --> 00:31:19.250
We don't want to rely on
the server to do this.

00:31:22.240 --> 00:31:25.060
JASON GRIGSBY: Sorry, I think
that it would be strange to

00:31:25.060 --> 00:31:28.670
have a fundamental element of
HTML that required the server.

00:31:34.370 --> 00:31:35.635
There's no precedent for that.

00:31:35.635 --> 00:31:38.200
ILYA: But 1x and 2x is just
a compression setting.

00:31:38.200 --> 00:31:40.950
You don't specify
a [INAUDIBLE]

00:31:40.950 --> 00:31:42.200
link for--

00:31:42.200 --> 00:31:45.670
go to this page, it's
compressed.

00:31:45.670 --> 00:31:47.540
JASON GRIGSBY: Correct, yes--

00:31:47.540 --> 00:31:50.014
I don't know, maybe.

00:31:50.014 --> 00:31:51.310
MIKE MAHEMOFF: All right,
we've got to finish up.

00:31:51.310 --> 00:31:55.040
So just in 30 seconds or less,
maybe you can just give out

00:31:55.040 --> 00:31:56.860
one best practice that you'd
like to see more

00:31:56.860 --> 00:31:59.500
developers be doing.

00:31:59.500 --> 00:32:01.570
JUSTIN UBERTI: I'd like to see
people take advantage of the

00:32:01.570 --> 00:32:04.060
peer to peer APIs that WebRTC
will be providing.

00:32:04.060 --> 00:32:08.930
It's sort of at no cost, the
ability to get bulk data much

00:32:08.930 --> 00:32:11.250
more cheaply.

00:32:11.250 --> 00:32:16.820
JASON GRIGSBY: We know that
96% or 94% of responsive

00:32:16.820 --> 00:32:20.710
designs are bloated crap.

00:32:20.710 --> 00:32:23.530
And it would be really nice if
people built stuff mobile

00:32:23.530 --> 00:32:27.120
first and performant when it
came to responsive design.

00:32:27.120 --> 00:32:28.810
JOHN MELLOR: Be careful that you
always get poly-fills for

00:32:28.810 --> 00:32:30.700
things like the picture
elements and so on.

00:32:30.700 --> 00:32:32.500
Don't just assume they'll
perform well.

00:32:32.500 --> 00:32:35.670
Actually measure that and cross
fingers for the best in

00:32:35.670 --> 00:32:38.340
the future.

00:32:38.340 --> 00:32:41.320
ANDRE BEHRENS: I think I would
say, notice there's a problem.

00:32:41.320 --> 00:32:42.110
Open DevTools--

00:32:42.110 --> 00:32:43.980
notice that not dealing with
it is a problem, and notice

00:32:43.980 --> 00:32:46.880
that the solutions are a
problem, and make noise.

00:32:46.880 --> 00:32:49.920
Because that's where solutions
come from.

00:32:49.920 --> 00:32:50.980
MIKE MAHEMOFF: Get on
the Bug Tracker.

00:32:50.980 --> 00:32:52.030
All right, thank you.

00:32:52.030 --> 00:33:06.303
[APPLAUSE]

