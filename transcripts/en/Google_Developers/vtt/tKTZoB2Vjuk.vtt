WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.830
&gt;&gt; PARLANTE: All right, hey there. Hey, good
morning. Welcome to the PyQuick Basic Python

00:00:05.830 --> 00:00:12.120
Class. My name is Nick Parlante and I work
in Google's engEDU group which deals with

00:00:12.120 --> 00:00:18.220
sort of technical training in engineering.
And also I have a job at Stanford where I

00:00:18.220 --> 00:00:22.640
work as a lecturer. So, the Python today is--or
rather, it's actually a 2-day class. So this

00:00:22.640 --> 00:00:29.750
class is about just the basic useful normal
Python. And Python is sort of--you know, it's

00:00:29.750 --> 00:00:34.480
a nice friendly learn--and you can actually
learn a lot of Python in two days. So, that's

00:00:34.480 --> 00:00:38.260
the good news. This is the class where the
prerequisite is not--you don't need to be

00:00:38.260 --> 00:00:42.420
like super-expert engineer to come in here
and learn Python. What we want is just that

00:00:42.420 --> 00:00:48.460
you have some experience in some language.
So, like, yeah, you have some idea what a

00:00:48.460 --> 00:00:52.370
variable is or something like that. And then,
and Python's going to meet you halfway on

00:00:52.370 --> 00:00:56.210
this. Python, like I was saying before, you
know, it's a nicely designed language. It--a

00:00:56.210 --> 00:01:01.440
lot of things work pretty easily and so you
can learn a lot of Python pretty quickly.

00:01:01.440 --> 00:01:06.790
So, this is a 2-day class. And what's going
to happen is it'll be a mix of lecture and

00:01:06.790 --> 00:01:12.970
coding sections. I'll kind of alternate between
the two. The good news or I guess the bad

00:01:12.970 --> 00:01:18.509
news or whatever; the news is that the class
moves pretty quickly. So, I'll show few things

00:01:18.509 --> 00:01:20.750
in lecture and, you know, kind of demonstrate
couple of things. And I want to get pretty

00:01:20.750 --> 00:01:25.050
quickly to you trying that in coding because,
really, when you code it up, you know, that's

00:01:25.050 --> 00:01:29.740
when you're going to learn it. So, as I lecture
through stuff, don't feel like--I don't want

00:01:29.740 --> 00:01:33.250
you to have the idea like, "Oh,"--where you're
memorizing or writing down everything that

00:01:33.250 --> 00:01:40.900
I say. So, [INDISTINCT] few here for a second,
so there's a--for the PyQuick class, we have

00:01:40.900 --> 00:01:44.980
a whole set of written materials and here's
the PyQuick page, it links all of them. And

00:01:44.980 --> 00:01:49.509
particular today, there's this one PyQuick
Basics. And that's pretty much what we're

00:01:49.509 --> 00:01:53.270
going to talk about today. It's pretty long
and it talks about strings and lists and modules

00:01:53.270 --> 00:01:57.159
and a bunch of things that I'm going to lecture
about. So, my goal is in the lecture sections,

00:01:57.159 --> 00:02:00.250
just kind of pick up the basic idea of what
I'm showing you. But don't feel like you need

00:02:00.250 --> 00:02:05.300
to memorize every detail of it. And then later,
when we're in the lab section, yeah, you can

00:02:05.300 --> 00:02:08.320
go to the [INDISTINCT] packing it. You can
go, "Oh, rightly, he said something about

00:02:08.320 --> 00:02:13.520
strings," you can sort of orient yourself
a little bit and figure it out how this stuff

00:02:13.520 --> 00:02:17.950
works. So, there's also--I had, sort of--I
printed some copies of this Basics thing but

00:02:17.950 --> 00:02:20.319
then I didn't make quite enough before class
started, so I'll go get those when we're at

00:02:20.319 --> 00:02:24.821
the next break so I'll also give you a printed
dead-tree version of this document for you

00:02:24.821 --> 00:02:33.250
to get started. Alrighty, so, let's just get
started. So, Python is a--actually kind of

00:02:33.250 --> 00:02:38.580
an old language. It was created by a guy name
Guido van Rossum, who actually works at Google,

00:02:38.580 --> 00:02:42.040
and it was created in 1990. So, I think about
it as, like, a little bit old by, you know,

00:02:42.040 --> 00:02:46.331
hip language standards. However, in the most
recent years, Python seems to have gotten

00:02:46.331 --> 00:02:49.980
a lot of momentums. It's becoming pretty popular.
And I think it stems from--I get it, it's

00:02:49.980 --> 00:02:54.560
basically a pretty good language. I think
of Python as being sort of a quick and light

00:02:54.560 --> 00:02:58.489
language. So, if I have some little tasks,
some little automation, I just want to just

00:02:58.489 --> 00:03:03.159
dance, encode and be done. Python seems to
work very well, like it's very, sort of, frictionless.

00:03:03.159 --> 00:03:08.519
It's just--quick little things just happen
very nicely. I think you would categorize

00:03:08.519 --> 00:03:14.080
Python as a scripting language. So, it's similar
to maybe Pearl or Bash or Ruby or maybe JavaScript,

00:03:14.080 --> 00:03:19.349
the whole sort of space of languages that
don't have a real heavy type system. So, Python

00:03:19.349 --> 00:03:24.959
is certainly a nice example in there. Python
as a--I'll show you as we start mess around

00:03:24.959 --> 00:03:29.230
with Python. Python is good at, sort of, quick
turnaround. So, you could--if you have an

00:03:29.230 --> 00:03:32.470
idea, a little experiment you want to run,
you just type it in and you could just try

00:03:32.470 --> 00:03:36.200
it immediately. There's not a big compile
stuff or anything, sort of, slow. So, we're

00:03:36.200 --> 00:03:39.290
going to--I'm going to encourage you to have
a development style where you have a, sort

00:03:39.290 --> 00:03:45.519
of, quick turnaround between editing and running
and I'll demo that in a minute. So Python

00:03:45.519 --> 00:03:50.010
is certainly very appropriate for small projects,
with little bits of animation. Within Google,

00:03:50.010 --> 00:03:55.240
Python gets used for all sorts of little things
like that. There is debate about whether or

00:03:55.240 --> 00:03:59.069
not Python is also good for huge projects,
since it lacks a big type system--and I'm

00:03:59.069 --> 00:04:02.090
not going to settle that debate today. But,
you know, there's certainly advocates for

00:04:02.090 --> 00:04:06.989
both sides. But, certainly, as you know, Python
is a wonderful language to learn for solving

00:04:06.989 --> 00:04:14.150
small encoding problems. Ah, all right. So,
let me show you--a little bit of Python code

00:04:14.150 --> 00:04:20.470
here. Let's see. So, Python is an interpretive
language. So, there's this program called

00:04:20.470 --> 00:04:26.000
Python. And later on, we're going to write
Python programs, the Python--this is called

00:04:26.000 --> 00:04:29.570
the Python interpreter. It's actually going
to, kind of, do the running for us. So, one

00:04:29.570 --> 00:04:33.949
of the nice qualities of Python is that you
can just run the interpreter, so I just type

00:04:33.949 --> 00:04:39.520
"python" in here. And then, I can just type
little snippets of codes, just add it and

00:04:39.520 --> 00:04:42.940
it'll, sort of, compile and run them just
as we go. And so, this is a marvelous way

00:04:42.940 --> 00:04:47.350
to sort of see what's going on. So, I can
just show you some basic Python here. So,

00:04:47.350 --> 00:04:52.191
I'll assign a variable "a," I'll say, you
know, "a is 6." And so, what the interpreter

00:04:52.191 --> 00:04:56.139
does here is what's called the read eval print
loop. So, I type a little bit of code to it.

00:04:56.139 --> 00:04:59.410
When I hit return, it's going to evaluate
it and its going to come back with a prompt.

00:04:59.410 --> 00:05:03.900
It'll say, "Okay, I know you--now what do
you want to do?" So if I type "a," just a

00:05:03.900 --> 00:05:08.100
value, what it does is it evaluates it. In
some sense, it kind of prints like, "Well,

00:05:08.100 --> 00:05:11.740
here's, sort of, the ASCII form of that,"
and then it comes back with a prompt. This

00:05:11.740 --> 00:05:16.220
is a very standard interpreter sort of thing.
So, a couple of notes; please notice there.

00:05:16.220 --> 00:05:20.759
Notice I didn't have to declare that I was
going to have a variable "a" or that it was

00:05:20.759 --> 00:05:25.700
going to be an "int," no. Python, it's all
about quick light. We're just like, get right

00:05:25.700 --> 00:05:30.751
to it. So, just by assigning to "a" that it
cause us to exist. Later on, I could say,

00:05:30.751 --> 00:05:36.710
"Oh, let's have 'a' be the string 'hello,'"
Well, okay. We're fine. So, there's not a

00:05:36.710 --> 00:05:41.930
compiled time type that associated with "a."
Instead, "a" just points to whatever it points

00:05:41.930 --> 00:05:46.120
to. So right now--so I have to hit "a" here.
So, yeah, so now it's a string, earlier it

00:05:46.120 --> 00:05:49.780
wasn't it. Though, with the jolly a little
bit aligned, the way you can think about in

00:05:49.780 --> 00:05:54.331
Python is that a value, you know, "a" in this
case, it points to something and in or a string.

00:05:54.331 --> 00:05:59.060
And whatever it points to knows what type
it is. That's stored at runtime. And so, then,

00:05:59.060 --> 00:06:04.570
as the code runs, it just uses the types of
the objects as they are at runtime. And we'll

00:06:04.570 --> 00:06:10.870
certainly see that theme in a lot of the cases.
Okay, I'll show you just syntax, at least.

00:06:10.870 --> 00:06:14.850
So, there's a built-in function called Len.
And so, if I wanted to take the, you know,

00:06:14.850 --> 00:06:18.400
find the length of that string, I could say,
"Len of a," and okay, it turns out, that's

00:06:18.400 --> 00:06:26.880
"5." Also, Python is case sensitive. So, if
I type an upper case "A" I'm going to get

00:06:26.880 --> 00:06:31.889
this error. So it says, "nah, blah-blah."
This bottom part, I think it's almost English,

00:06:31.889 --> 00:06:36.270
"Name error: name "A" is not defined." Okay,
well, that's telling you something. So, in

00:06:36.270 --> 00:06:41.240
Python, if it comes across a variable or some
other symbol which has not previously been

00:06:41.240 --> 00:06:45.540
given some value, then that's an error. Then
there's a little bit in contrast to some languages

00:06:45.540 --> 00:06:49.030
where if it's undefined, it's like, "Well,
you know, let's just use the empty string."

00:06:49.030 --> 00:06:53.751
Or, you know, "Let's just kind of blunder
ahead." Python is not that way. So, this will

00:06:53.751 --> 00:06:56.580
also come up like when you go out and bounce
an array or do some other thing where it's

00:06:56.580 --> 00:07:01.230
a little bit like it doesn't seem to match
up, Python will halt. And I think giving you

00:07:01.230 --> 00:07:06.229
an experience, the Python language is just--since
the greatest source of delays in your code-working

00:07:06.229 --> 00:07:11.090
is bugs. And so, it's bad, or if it's been
found, it's bad if a bug is, sort of, sitting

00:07:11.090 --> 00:07:14.830
in there, hidden. Really, if there's an error,
you want to know. And so, Python reflects,

00:07:14.830 --> 00:07:22.051
or reflects that style. So, let me show--so,
what's going to happen is we're going to do

00:07:22.051 --> 00:07:27.770
all sorts of Python. And the interpreter is
a great source of doing little experiments.

00:07:27.770 --> 00:07:31.660
So, for example, what's going to happen is
someone's going to ask me some questions about

00:07:31.660 --> 00:07:35.009
Python and I'm just not going to know the
answer. I mean, of course. And--but rather

00:07:35.009 --> 00:07:40.669
than admit that, what I'm going to say is,
"Oh, that's an excellent question. Hey, let's

00:07:40.669 --> 00:07:44.460
try it in the interpreter and see." And in
that way, I'm never at risk of being wrong,

00:07:44.460 --> 00:07:47.590
or whatever, it's just going to do whatever
it is going to do. So, for example, you might

00:07:47.590 --> 00:07:54.190
wonder, "Oh, well, what if I want to have
a string and an int together?" So, I'll say,

00:07:54.190 --> 00:08:01.009
"'Hello' + 6." Now, what does that do? Okay,
it turns out that doesn't work. I was mentioning

00:08:01.009 --> 00:08:04.669
the solution, so you're already at "+"--in
Java that works and some of the--in Python

00:08:04.669 --> 00:08:08.389
though, "+" between a string and it does not
automatically convert then it fix it. Oh,

00:08:08.389 --> 00:08:12.419
in the interpreter, by the way, the "Up arrow"
works. So it's, sort of, like in Bash, I can,

00:08:12.419 --> 00:08:18.280
like, flip the previous lines. So it just
happens, if I call, there's an "str" function.

00:08:18.280 --> 00:08:22.300
So, if I do "str" on it then "str" on kind
of anything. Then that makes, or tries to

00:08:22.300 --> 00:08:26.900
make a string out of it and then the code
works. I'll talk more about strings and stuff

00:08:26.900 --> 00:08:31.169
later on. But you can do that yourself, right?
You can be the interpreter and if you have

00:08:31.169 --> 00:08:35.220
some questions about, "Oh, what if I do to--do
the--where?" It's just so quick like, well,

00:08:35.220 --> 00:08:39.130
just, you know, fire up the interpreter and
try it out. And so, Python does work. I guess

00:08:39.130 --> 00:08:43.500
it's in an interactive style. And I'm being
a little repetitious about this because coming

00:08:43.500 --> 00:08:48.230
from a Java or C++ background, this feature
isn't very foreign. So, it's not something

00:08:48.230 --> 00:08:51.830
you would necessary have an instinct to do.
But in Python, it works very well. So I will

00:08:51.830 --> 00:08:55.740
certainly encourage you to go that way. Oh,
all right. So let me get out this. I'll show

00:08:55.740 --> 00:09:01.010
you how quit the interpreter; the way I do
it. What I do is I type the word, "quit,"

00:09:01.010 --> 00:09:07.390
and it doesn't work. But in the error message,
it says--"Oh, right, right, Control D." Okay,

00:09:07.390 --> 00:09:13.269
good. And so then I type 'control'--Oops.
So, here we go. So, in our in--you know, later

00:09:13.269 --> 00:09:16.339
on, oh, you don't have to do it now, but later
on we'll have this PyQuick directory. It's

00:09:16.339 --> 00:09:20.030
going to have a bunch of exercises for you
to do. And I'll analyze my selling here. And

00:09:20.030 --> 00:09:26.519
in particular, I've got this "hello.py" file.
And so, I'm going to use that as kind of a--just

00:09:26.519 --> 00:09:33.280
real basic example to start things up. So,
one of the required, you know, in order to

00:09:33.280 --> 00:09:35.921
do this class, what you want to do is you're
going to have a way of editing and running,

00:09:35.921 --> 00:09:38.510
and switching between those two very quickly.
And there's a separate handout that talks

00:09:38.510 --> 00:09:41.899
about that. So, I won't repeat that in lecture.
In this case, I'm going to have these two

00:09:41.899 --> 00:09:46.950
windows. So up here, I've got this like, you
know, whatever, primitive EmEx editor but

00:09:46.950 --> 00:09:50.959
while I can do editing in that screen and
then in this screen, I can do running. So,

00:09:50.959 --> 00:09:55.940
what I'd like to do is, you know, right here
is a very basic Python program. I'd like to

00:09:55.940 --> 00:10:03.080
just talk about the parts of this thing. So,
up here at the very top, you've have this

00:10:03.080 --> 00:10:07.630
standard user bin, Python, you know, sort
of, or, you know, number sign--bang! Just

00:10:07.630 --> 00:10:12.140
talking about what interpreter is going to
use this. We're going to--today, we're going

00:10:12.140 --> 00:10:17.260
to use Python 2.4. It's a perfectly modern
version and this is also the official modern

00:10:17.260 --> 00:10:21.830
version used here in Google. There's also
a 2.5 and a 2.6. But those differences are

00:10:21.830 --> 00:10:26.890
like not real big, so I wouldn't worry about
those. I would not use Python 2.2 because

00:10:26.890 --> 00:10:33.420
that at--is actually different. So, 2.4. Go
with that. Python 3 actually just came out

00:10:33.420 --> 00:10:38.450
and it does have some real differences; although,
it's not in wide use yet. Here and there--mostly,

00:10:38.450 --> 00:10:43.290
we're doing just totally straight-ahead normal
standard Python. And so, that's not very different

00:10:43.290 --> 00:10:47.240
in Python 3000--in Python 3. But in a couple
of places, I may point out things that are

00:10:47.240 --> 00:10:50.430
going to be over little different in Python
3. But for the most part, the stuff we're

00:10:50.430 --> 00:10:55.190
going to do, we'll all come through fine.
The "-tt" thing, I'll talk about in a second.

00:10:55.190 --> 00:11:04.800
Okay, let's get rid with this import system.
There. So, what this says, this is a "def

00:11:04.800 --> 00:11:10.162
main: print 'Hello.'" That defines a function.
So, you say, "def" and space and then the

00:11:10.162 --> 00:11:11.170
name of the thing. Yeah, question?
&gt;&gt; [INDISTINCT]

00:11:11.170 --> 00:11:18.600
&gt;&gt; PARLANTE: Oh, I'm sorry. It's coming off
a bit. Oh, thank you. There we go, all right.

00:11:18.600 --> 00:11:22.740
So, this is just a simple function definition.
In this case, I can get whatever name I want.

00:11:22.740 --> 00:11:26.399
But it's very conventional in Python that
whatever is going to be, kind of, like the

00:11:26.399 --> 00:11:30.550
main thing you do, you'll call lower case
m, "main." In this case, it turns out Python

00:11:30.550 --> 00:11:35.800
has a print operator. And so, you can say
"print" and then there's a series of things

00:11:35.800 --> 00:11:40.550
and separate them with commas and it prints
them. So, in this case, it just prints out,

00:11:40.550 --> 00:11:47.060
"Hello." This thing at the bottom is a little
unfortunate but I'm going to--it's boilerplate

00:11:47.060 --> 00:11:52.500
syntax. And that is the boilerplate syntax
to run the "main," that we find above. And

00:11:52.500 --> 00:11:57.450
I will mention very briefly why this is here.
But then, you should think of this as just

00:11:57.450 --> 00:11:59.770
something that's just mechanically you just
put at the bottom of the file and then don't

00:11:59.770 --> 00:12:05.639
think about too much. The way this works is
that a Python program can be--in this case,

00:12:05.639 --> 00:12:10.860
"Hello.py," you can run it like [INDISTINCT]
like I want to invoke this program. And in

00:12:10.860 --> 00:12:15.019
that case, that if statement will be true,
the way the interpreter sets things up. And

00:12:15.019 --> 00:12:18.399
so, since it's true then here what does is
it's calling the main function. So, actually,

00:12:18.399 --> 00:12:24.700
I can just demonstrate that. So, if I go down
here to my--same directory, so, the way you

00:12:24.700 --> 00:12:30.201
run this thing--well, there's two ways, you
could type "python," the name of the interpreter,

00:12:30.201 --> 00:12:34.959
and then give it "hello.py," say, "Hey, please
run that." And then, you could see here it

00:12:34.959 --> 00:12:40.390
prints, "Hello." So, there's my marvelous
program functioning. In the Unix way, the

00:12:40.390 --> 00:12:46.010
more modern thing is that you would--you have
the XQ bit set--I'll have talk about this

00:12:46.010 --> 00:12:49.620
a little bit, and so then, you can just say,
that's the, you know, whatever. "hello.py"

00:12:49.620 --> 00:12:57.709
and it just runs it. So, either of those techniques
will work okay. All right. So, in that example,

00:12:57.709 --> 00:13:04.240
I'm running it and so that then this if statement
is trying out to be true and so then it runs

00:13:04.240 --> 00:13:08.800
"main." There is this other way that you can
load a Python program. Where one Python module

00:13:08.800 --> 00:13:13.330
wants to load another one and use it essentially
like a library--which I, actually, am going

00:13:13.330 --> 00:13:19.690
to demonstrate, I think, tomorrow. And in
that case, I want to load the Python module,

00:13:19.690 --> 00:13:23.579
it's sort of synonymous with [INDISTINCT]
file in Python. I want to load it but I don't

00:13:23.579 --> 00:13:28.630
want to run it. I just want to have its definitions
available and so, in that case, this if statement

00:13:28.630 --> 00:13:32.899
will be false if I load it. And so then, it
will bring the module in but it won't run

00:13:32.899 --> 00:13:39.310
its main. So, that's what the if statement
is for. But for today, we're just always going

00:13:39.310 --> 00:13:43.510
to run it just like hello.py so you don't
need to worry about this too much. Okay, so

00:13:43.510 --> 00:13:48.310
let me show you--I want to, you know, I going
to add a few features to this thing; and so

00:13:48.310 --> 00:13:53.529
just to, kind of, show you some things. So
first thing I'm going to do is, I want to

00:13:53.529 --> 00:13:56.529
print out the command-line arguments from
my main here. It's just a very common thing

00:13:56.529 --> 00:14:06.529
to want to do. And it turns out, there's a
module called "sys." And the sys module, there's

00:14:06.529 --> 00:14:10.740
a Python--standard Python thing, it includes
a lot of, sort of, operating system interface-type

00:14:10.740 --> 00:14:16.180
stuff. So, you could access command-line arguments
or you could exit the whole program or whatever.

00:14:16.180 --> 00:14:21.120
I'll show you how to bring up the documentation
in a second. In Python, the way that you refer

00:14:21.120 --> 00:14:24.500
to some external module of stuff you'd like
to pull in is you have an import statement.

00:14:24.500 --> 00:14:29.310
You say, "import sys" or import--I'll show
you a bunch of different ones over the next

00:14:29.310 --> 00:14:34.130
few days. And then, down here, to refer to
something inside of the module, you say module

00:14:34.130 --> 00:14:37.680
name, so "sys" and then dot and then and you'll
just need to know the name. In this case,

00:14:37.680 --> 00:14:43.490
it's, "sys.argv," is the name of the command-line
arguments in that module. So, I'm going to

00:14:43.490 --> 00:14:50.540
save that and then down here, I'll run, "hello,"
and I'll just say like "aaa bbb ccc," right?

00:14:50.540 --> 00:14:59.680
So, those are command-line arguments. So now,
when I run it, see it prints these out. So

00:14:59.680 --> 00:15:07.160
that is a Python list. It has four--so Python
lists have square brackets around them. And

00:15:07.160 --> 00:15:10.970
we'll mess with this a lot more later on.
In this case, this list has four elements

00:15:10.970 --> 00:15:14.600
in it, which is, kind of, the old Unix standard
way of doing command-line arguments. The first

00:15:14.600 --> 00:15:21.000
argument, it points to the script itself,
so that's "./hello.py." And then, the subsequently

00:15:21.000 --> 00:15:29.949
three elements--these guys here, that's just--Oops!
These guys then just correspond to the arguments

00:15:29.949 --> 00:15:36.210
here of that I passed at. So, what I want
to show you--so, I'm going back to my source

00:15:36.210 --> 00:15:41.110
code here. So, so far, this part doesn't really
do anything very useful. But I do want to

00:15:41.110 --> 00:15:44.829
show you just the idea of a module like, yeah,
there's--we're going to use modules a lot

00:15:44.829 --> 00:15:48.270
today. So, that's how we're going to pull
stuff, you know, you use codec way to write

00:15:48.270 --> 00:15:56.959
by code of my program. Now, a very reasonable
question is like, "Oh, 'sys,' like, how am

00:15:56.959 --> 00:16:01.880
I supposed to know that?" like, "Where did
that come from?" So, I want to show you two

00:16:01.880 --> 00:16:07.889
ways that you can, kind of, research what
a module is and what it has in it. And I'm

00:16:07.889 --> 00:16:13.730
going to show you two. There's the hi-tech
way and there's the easy way. And they both

00:16:13.730 --> 00:16:16.649
work fine. So, you could use either of these
ways. First of all, I'll show you the hi-tech

00:16:16.649 --> 00:16:23.639
way. All right, so I'm going to fire up the
Python interpreter, and actually in the Python

00:16:23.639 --> 00:16:27.959
interpreter, I can say "import sys." I mean,
it really kind of looks like a program. It's

00:16:27.959 --> 00:16:34.300
just that I get to type stuff interactively.
So then, inside of--there are two functions

00:16:34.300 --> 00:16:41.170
in here. One is "dir," so I can do a "dir"
on sys. And what that does is to just, kind

00:16:41.170 --> 00:16:45.120
of, shows me all the symbols that are defined
in there. So, it's sort of an homage to dash,

00:16:45.120 --> 00:16:50.959
I always think of dir. And so, you can see,
you know, if you didn't know about "argv,"

00:16:50.959 --> 00:16:54.230
or whatever, you'd say like, "Oh, exit." "Oh,
that's probably the exit function," and--where's

00:16:54.230 --> 00:16:59.320
"argv?" Oh, all right. Check it out. There's
"argv." So this--some of these are data, some

00:16:59.320 --> 00:17:03.970
of them are codes but you can at least get
a feel for what's inside of there. So, dir,

00:17:03.970 --> 00:17:10.079
that's the first one; then there's a companion
called help. And what help does is it kind

00:17:10.079 --> 00:17:15.819
of pulls up sort of a JavaDoc, sort of a man
page documents about like, oh, what is going

00:17:15.819 --> 00:17:21.530
on with this module? And so, with dir and
help, you can kind of poke around a little

00:17:21.530 --> 00:17:26.110
bit and orient yourself. And what's nice--if
you look at my list here, for example, there's--this

00:17:26.110 --> 00:17:32.170
is my example, there's exit. So, that's sys
dot exit that's a function. I can actually

00:17:32.170 --> 00:17:39.330
say help of sys dot exit, and then it pulls
up just help about that function. So, just

00:17:39.330 --> 00:17:44.730
in Python and in lecture or whatever, I will
say, "Oh, use the Ebola ABC Module," and I'll

00:17:44.730 --> 00:17:47.230
kind of mention a couple of functions that
you need to use but I won't give you further

00:17:47.230 --> 00:17:50.590
direction than that. And so then, what you
know, which is a very realistic position to

00:17:50.590 --> 00:17:54.730
be in. And what will happen is that in Python,
you can use dir and help to kind of dig around

00:17:54.730 --> 00:18:02.150
and get better docs, or you know, using--using
this technique. I'll do another example. Remember

00:18:02.150 --> 00:18:08.630
I talked about the len function earlier? So,
I could say help of len and that like, gives

00:18:08.630 --> 00:18:12.710
you like, okay--not pretty scant description
but a little bit of description about that.

00:18:12.710 --> 00:18:17.190
One thing I'll point out about this first
of all, usual--notice why, when I type help

00:18:17.190 --> 00:18:22.810
len, I'm just typing len without a set of
parentheses after it? And that's a kind of

00:18:22.810 --> 00:18:30.640
subtle syntactic distinction. When I say len
paren hello like that, I'm calling the len

00:18:30.640 --> 00:18:37.230
function. But when I just say len with no
parens like that, I'm just referring to the

00:18:37.230 --> 00:18:39.790
len function. I'm pointing to say, well, here
is some code. Don't run it, I just want to

00:18:39.790 --> 00:18:47.860
talk about this code. So, here when I call
help, notice it's just len and it's just unadorned,

00:18:47.860 --> 00:18:53.370
all righty? So, let me show you--so that's
the high-tech way of doing dir and help, certainly

00:18:53.370 --> 00:19:00.110
very useful. Now, I'll show you the easy way.
The easy way is you go to your browser and

00:19:00.110 --> 00:19:08.140
you just go to Google and you just type Python--like
what did we just do? I'll say Python sys exit

00:19:08.140 --> 00:19:12.610
and then whatever; Google searches, for whatever
reason, just work really well with Python.

00:19:12.610 --> 00:19:16.910
So, like the first couple hits, like yeah,
it just is the docs for the Python sys exit

00:19:16.910 --> 00:19:23.080
function or I've been doing a Python--I'll
show you strings in a second. So, if I say

00:19:23.080 --> 00:19:30.580
Python string, type that out, oh yeah, first
hit here. So, Python.org is the official--so,

00:19:30.580 --> 00:19:35.830
Python, I should mention, is you know open-source
and all, like good minor stuff. Python.org

00:19:35.830 --> 00:19:40.070
is sort of the official Python home and so
if you see a link that's docs.Python.org a

00:19:40.070 --> 00:19:44.850
lot--you know that--Python.org has excellent
documentation and tutorials and all sorts

00:19:44.850 --> 00:19:47.770
of stuff like that. And so, if you get a Google
search that just kind of points into that

00:19:47.770 --> 00:19:52.450
a lot of times, so that's going to be nice
authoritative answer. So, just doing Google

00:19:52.450 --> 00:19:56.660
actually works amazing alone. I was feel like
I'm being kind of powerful and hip if I use

00:19:56.660 --> 00:20:01.780
like, dir and help to dig around, but I must
admit that in fact, just doing a Google search

00:20:01.780 --> 00:20:06.690
that, like, any six-year old could do, like,
in fact, works great. And so, you know, both

00:20:06.690 --> 00:20:11.610
those techniques are available, you have to
use whichever one you like, all righty. So,

00:20:11.610 --> 00:20:19.360
let me show you--let me go back to my--get
out of here. So, I want to build up the Python

00:20:19.360 --> 00:20:25.390
code inside of a--inside of this function
bit, show you couple of things. One thing,

00:20:25.390 --> 00:20:34.890
I'm going to show you a very common error,
real quick. So, I'm going to comment out the

00:20:34.890 --> 00:20:39.010
import sys. So, incidentally the number sign
is the comment character, so like, and that

00:20:39.010 --> 00:20:43.590
just goes to the end of the line. So, this
is a very typical way I would write this code.

00:20:43.590 --> 00:20:49.340
I'm using sys.argv, but I've forgotten to
do the import. So, I want to show you what

00:20:49.340 --> 00:20:57.510
that looks like. So, if I say hello, I get
an error. So, this is a Python error trace.

00:20:57.510 --> 00:21:03.950
So, the most interesting part here is maybe
at the bottom, says, "Global name sys is not

00:21:03.950 --> 00:21:08.240
defined." Now, the error is not very specific
here but it's kind of--it doesn't quite know

00:21:08.240 --> 00:21:11.591
if I wanted to have a variable name sys or
module, it doesn't know. It just looks like

00:21:11.591 --> 00:21:16.660
S-Y-S to it, but it is that error like, while
I came across the symbol and it was not previously

00:21:16.660 --> 00:21:19.470
defined. So, you could see that that is one
of the basic rules of Python that if you--if

00:21:19.470 --> 00:21:24.120
you're going to use a symbol, it previously
needs to have been given a value. So, when

00:21:24.120 --> 00:21:27.909
you see something like that and it refers
to a module that you're trying to use, then

00:21:27.909 --> 00:21:34.530
what that means is--oh, right, I forgot to
do the import. So, I go back here, I'll put

00:21:34.530 --> 00:21:39.900
the import back. So, essentially what the
import does is it takes the symbol S-Y-S and

00:21:39.900 --> 00:21:44.830
it binds it to point to something so that
then down stream, when you say sys dot whatever,

00:21:44.830 --> 00:21:48.750
it's able to see if it'll actually work. So,
let's try that much and now work again. Okay

00:21:48.750 --> 00:21:53.669
good, now we're back to just pitching the
arguments. All right, so I'd like to do--well,

00:21:53.669 --> 00:22:00.980
I'll show you how to build a real program
out of this. So, I'm going to define a hello

00:22:00.980 --> 00:22:05.020
function that does something. So, I'll say
hello and then let's say this will take in

00:22:05.020 --> 00:22:17.559
a string. So, I'm doing a second def here
and let's say--let's say this is a name, actually.

00:22:17.559 --> 00:22:26.820
I'll say prints, "hello" and then the print--you
can actually separate things with commas.

00:22:26.820 --> 00:22:30.120
So, if I say "hello" name--and you can have
multiple comments, multiple things in it;

00:22:30.120 --> 00:22:38.390
it sort of prints those out and puts them
on a line. So, what I'll do down here actually

00:22:38.390 --> 00:22:48.240
and when I'm all set, let's have--let's put
a bunch of exclamation marks after the name.

00:22:48.240 --> 00:22:51.659
So, that's my little "hello" function that
has two lines in it and I'll talk about the

00:22:51.659 --> 00:22:55.850
plus and--you know, I'm glossing over some
details there, but you can sort of see what

00:22:55.850 --> 00:23:01.360
it does. And then down here, I'll call my
"hello" function and what I'm going to do

00:23:01.360 --> 00:23:07.060
is I'm going to pass in the first command
line argument. So that was sys.argv and that

00:23:07.060 --> 00:23:15.740
turns out the zeroth element refers to the
script itself which is--that's just an ancient

00:23:15.740 --> 00:23:21.860
convention. So, the element that I really
care about is sys.argv one there. So, I'm

00:23:21.860 --> 00:23:27.270
going to save that and I'll see if this works,
so I'll say, "Hello Alice," and so there,

00:23:27.270 --> 00:23:31.600
check it out. All right, so now it prints
"Hello Alice," you can sort of see the results

00:23:31.600 --> 00:23:35.679
there. All right, so let me talk a little
bit. I just want to use this as a vehicle

00:23:35.679 --> 00:23:42.080
to kind of talk about what's going on syntactically
with Python. So, I'll sort of o through this

00:23:42.080 --> 00:23:46.760
top to bottom. So, I give this thing an argument
called name. Notice just like--just as with

00:23:46.760 --> 00:23:51.390
the variables, I didn't have to declare that
this was a string or an ant or anything like

00:23:51.390 --> 00:23:55.080
that. I just say well, whatever; it's just
called name and it just points to whatever

00:23:55.080 --> 00:24:00.020
it points to. So, arguments and variables
are similar, they're both just names that

00:24:00.020 --> 00:24:05.130
point to some value. Then, in Python when
you want set off a block of code, it very

00:24:05.130 --> 00:24:09.010
often uses the colon, as you see here. So,
I'm going to say define this function and

00:24:09.010 --> 00:24:12.190
there's a colon. Now, I'm going to go to the
next line and I'm going to have, you know,

00:24:12.190 --> 00:24:17.780
how are many lines of code I want to have.
Now, this brings us to Python's most sort

00:24:17.780 --> 00:24:25.950
of famous syntactic feature which is that
Python does not have any sort--any left curly

00:24:25.950 --> 00:24:33.919
brace, right curly brace notion to enclose
a block of code, instead, Python uses indentation.

00:24:33.919 --> 00:24:37.809
So, notice under the def here--so the Google
standard is to indent by two spaces, and so

00:24:37.809 --> 00:24:42.970
that's a fine thing to do for today. So under
the def, this first line is indented by two

00:24:42.970 --> 00:24:47.100
and this next line is indented by two. So,
that's what's putting them inside of that

00:24:47.100 --> 00:24:51.820
function and there just isn't a left curly
brace or right curly brace I typed to put

00:24:51.820 --> 00:24:56.620
those in there. So, this is--it's a little
bit controversial. I'll just give you my take

00:24:56.620 --> 00:25:02.039
on it. I think the idea is that if we were
writing this in Java--I'll disturb all the

00:25:02.039 --> 00:25:05.510
real Python people here, you know. I don't
know. Suppose it looked like this ... sounds

00:25:05.510 --> 00:25:11.240
really funny, all right. Suppose we had that,
right? We're blocking out the code that makes

00:25:11.240 --> 00:25:16.520
this function and what we would've indented--like
we would've had one set of brain cells that

00:25:16.520 --> 00:25:20.570
was managing the curly bracers and putting
them in right. But then, we also would've

00:25:20.570 --> 00:25:23.789
indented correctly, right? And we were raised
right and it looks terrible. So, of course,

00:25:23.789 --> 00:25:25.921
we would've indented correctly as well; that
would've been a second set of brain cells,

00:25:25.921 --> 00:25:29.830
those. So, we would've maintaining these two
things kind of in parallel. But if you start

00:25:29.830 --> 00:25:33.500
to think about it, those two bits of syntax
would've been reflecting the same piece of

00:25:33.500 --> 00:25:37.140
information; they always would've moved in
tandem. And so, the Python idea is like you

00:25:37.140 --> 00:25:40.850
know, having two bits of syntax that represent
the same thing and then we're just trying

00:25:40.850 --> 00:25:45.760
to keep them in sync is dumb. Like, we want
to just do the quickest, most minimal, clean

00:25:45.760 --> 00:25:48.950
thing and that's kind what Python looks like,
and so it's like, you know what? Let's just

00:25:48.950 --> 00:25:53.799
get rid of the curly braces. If the--if we
want to look right--so I'll put the colon

00:25:53.799 --> 00:25:59.440
back there--let's just have the indentation
define how the blocks of code go. I'll fill

00:25:59.440 --> 00:26:03.400
this--this function have to be little longer
so you'd get a better feel for what indentation

00:26:03.400 --> 00:26:08.270
looks like. My advice about this is that it
seems extremely foreign, weird and slightly

00:26:08.270 --> 00:26:13.110
wrong for about the first 11 minutes that
you use it. And then, it's just fine. I mean,

00:26:13.110 --> 00:26:17.400
it's just basically very logical and reason
why--it's kind of visual and so, it very quickly

00:26:17.400 --> 00:26:22.330
just seems normal. So I encourage you just
not worry about it. All right, so let me--I

00:26:22.330 --> 00:26:24.620
want to make this function a little longer;
then allow me to demonstrate the indentation

00:26:24.620 --> 00:26:30.240
a little more. Yeah, question?
&gt;&gt; It has space between hello and Alice [INDISTINCT].

00:26:30.240 --> 00:26:33.640
&gt;&gt; PARLANTE: Oh, so yeah, the question is,
where does the space come? That's a quality

00:26:33.640 --> 00:26:37.929
of print that when you separate things with
a comma, it puts a single space between them.

00:26:37.929 --> 00:26:43.360
If I wanted to bunch those together, I could've
done a plus. The plus in string space just

00:26:43.360 --> 00:26:48.920
crams them together, so that would've done
it. All right, so, let me show you--so, I

00:26:48.920 --> 00:26:55.059
want to make this a little fancier here. I'm
going to put in an If statement. So, let's

00:26:55.059 --> 00:26:59.950
see. I'll say if--let's say, if name and I
know I'll just end up showing you how Boolean

00:26:59.950 --> 00:27:09.810
this stuff work. If name is, let's say, Alice,
then we'll say--I'm just going to--this won't

00:27:09.810 --> 00:27:18.779
be very meaningful. Here, we'll add some question
marks on there. So the--I'll just start at

00:27:18.779 --> 00:27:23.740
the top here. So, this is what an If statement
looks like. You say if and then you have the

00:27:23.740 --> 00:27:28.140
test and then there's a colon and then it
has whatever--block of statements underneath

00:27:28.140 --> 00:27:33.730
it. Now, just to get with this idea of indentation,
if I wanted to also do multiple things, I

00:27:33.730 --> 00:27:39.510
could say you know, you know, I'd consider,
you know, "Alert: Alice Mode" here or something.

00:27:39.510 --> 00:27:43.919
The fact that those two lines, the print alert
and these two lines are underneath the If,

00:27:43.919 --> 00:27:47.340
that's what's putting them, you know, under
the control of that if statement. And then

00:27:47.340 --> 00:27:52.440
here, when this line is indented back to Alt
that--that's what putting me outside the If

00:27:52.440 --> 00:27:55.530
statement. So, this is what it means to say
that the indentation is significant, right?

00:27:55.530 --> 00:28:01.000
Where something is placed left-right does
control what the code means and so that's

00:28:01.000 --> 00:28:07.750
the foreign part. All right, so let's start
about this If statement. Here, I'm using "= =." "= =" does

00:28:07.750 --> 00:28:12.200
sort of an intuitive deep comparison. In some
languages, you kind of have to worry, well,

00:28:12.200 --> 00:28:16.539
is this a point of comparison or whatever?
In Python, you do not to have that worry.

00:28:16.539 --> 00:28:20.419
 "= =" does what I have described as a kind
of a real comparison. It takes the thing on

00:28:20.419 --> 00:28:24.559
the left, the thing in the right and it really
fleshes them out and compares them. So, it

00:28:24.559 --> 00:28:27.649
works for integers, it works for strings;
later on, I'll show you it works for entire

00:28:27.649 --> 00:28:32.410
lists. So, you could have relatively big data
structures and just compare them with "= =" and

00:28:32.410 --> 00:28:42.700
you'd still get a reasonable result. In C++
or Java, you always got to have the parentheses

00:28:42.700 --> 00:28:48.700
around the test. In Python, the parentheses
are not required. And then, so it's regarded

00:28:48.700 --> 00:28:52.760
as the best Python style to not put them in.
It's a little bit like--it's like speaking

00:28:52.760 --> 00:28:56.270
with your sort of vulgar accent. Like if you
put the parens in, then everyone's like, "Oh,

00:28:56.270 --> 00:29:03.260
I see. One of you is, you know, C++ refugees."
So, you could sort of show off your modernity

00:29:03.260 --> 00:29:08.850
by, like, not putting in it. If you want to
have a logical connective, this is a little

00:29:08.850 --> 00:29:17.580
bit strange. The logical connectives are spelled
out with letters. So, or is O-R and is A-N-D

00:29:17.580 --> 00:29:24.850
and not is--it's a little hard to say in English--not
isn't the thing above the one on the keyboard,

00:29:24.850 --> 00:29:33.840
its N-O-T. So, I'll say, you know, if name
is, you know, Nick. So, finally, I'll put

00:29:33.840 --> 00:29:44.890
a--I'll put an else in here just to show off.
So I'll say else colon--what do we do in the

00:29:44.890 --> 00:29:52.080
else case? I'll print "Else." Okay. So, now
you that--you could sort of see the indentation

00:29:52.080 --> 00:29:57.820
and you're really working here and we've got
this kind of modest Python program. All those

00:29:57.820 --> 00:30:01.740
mentioned, you know, all the regular Boolean
stuff. You know, there's less than and equal

00:30:01.740 --> 00:30:06.350
equal and, you know, all the kind of regular
Boolean stuff works in Python as it does in

00:30:06.350 --> 00:30:11.270
other languages. There are Boolean true and
false values, although those aren't used very

00:30:11.270 --> 00:30:19.760
often. The rule in Python is that if you have
appointed (ph) or something, there's a few

00:30:19.760 --> 00:30:25.020
kind of null values that count as false. So,
if a number is zero that counts as false.

00:30:25.020 --> 00:30:31.330
If a string is the empty string that counts
as false and any other value or, you know,

00:30:31.330 --> 00:30:34.210
and the--or if the string is not empty or
if a number is not zero, then those count

00:30:34.210 --> 00:30:39.290
as true. So, that's similar to how other languages
do it. All right, so let me just try running

00:30:39.290 --> 00:30:45.679
this a little bit. So, I guess if I run this
and I say "Hello Alice," then my If statement

00:30:45.679 --> 00:30:49.320
kicks in, so I get all those question marks
and then the line below kicks in and I go--oh,

00:30:49.320 --> 00:30:56.470
it's pretty doofy, pretty doofy looking out,
but hey, at least it works. So, I'm going

00:30:56.470 --> 00:31:02.250
to show you--I'm going to make a very sweeping
claim about how Python works. Python does

00:31:02.250 --> 00:31:10.320
everything at the last possible second. So,
in C++ or Java, it takes your code and it

00:31:10.320 --> 00:31:12.950
compiles and it checks it in a million different
ways and you might get a lot of different

00:31:12.950 --> 00:31:17.750
compile errors, and then only after all that
compile checking, then it runs it. That's

00:31:17.750 --> 00:31:24.300
not how Python works. When you feed your Python
code like my hello.py in the Python, it just

00:31:24.300 --> 00:31:29.010
looks at it in the most superficial way, it
checks pretty much nothing; it just starts

00:31:29.010 --> 00:31:35.049
running it. And each line it gets to, it evaluates
at that line kind of in the moment. So, in

00:31:35.049 --> 00:31:39.230
the moment, it looks at what those variables
point to and oh, he's got a string and an

00:31:39.230 --> 00:31:43.000
ant here and it just tries to do it just at
the last possible second. And only at that

00:31:43.000 --> 00:31:47.299
second does it notice if there's an error,
maybe a variable is not defined or you're

00:31:47.299 --> 00:31:50.230
calling a function that doesn't exist or you
know, dividing by zero--I mean, we're always,

00:31:50.230 --> 00:31:56.581
you know, aware of bugs. So, to highlight
that, I want to try calling a function here.

00:31:56.581 --> 00:32:04.970
I'm going to call a function called DoesNotExist.
Here, I'll pass in a name. Now, there is no

00:32:04.970 --> 00:32:09.210
such function. I haven't defined it, there's
not a built in code DoesNotExist, it's just

00:32:09.210 --> 00:32:16.720
wrong, all right? That else is just incorrect.
This does demonstrate a deep quality of Python.

00:32:16.720 --> 00:32:24.590
Now, if I call hello.py and pass Alice, you
know what? It's going to work fine. All right,

00:32:24.590 --> 00:32:29.680
this is what I mean. What happens is Python
only checks a line when it runs that line,

00:32:29.680 --> 00:32:35.960
all right? And so, because it just kind of
never hit this else, whatever, it just kind

00:32:35.960 --> 00:32:41.470
of never knows that that was wrong. Now, in
the great, you know--as we understand the

00:32:41.470 --> 00:32:45.760
universe, you don't get something for nothing.
Well, in Python it means there's not a big

00:32:45.760 --> 00:32:51.340
barrier between you and just, like, your code
running. And that can be a real virtue in

00:32:51.340 --> 00:32:56.170
a lot of cases. But also, you're giving up
a certain amount of checking that some languages

00:32:56.170 --> 00:33:02.169
might have done. This also means that in a
more industrial sense, because Python doesn't

00:33:02.169 --> 00:33:06.419
really check a lot at a compel time, for industrial
code, it's more important for it have to have

00:33:06.419 --> 00:33:10.019
good units test coverage. Like you actually
need to have run all the lines to see that

00:33:10.019 --> 00:33:13.890
they're correct. Now, for our two days, we're
going to work on things that are just kind

00:33:13.890 --> 00:33:16.909
of medium sized little utilities where, you
know, if they're incorrect, you can see pretty

00:33:16.909 --> 00:33:22.660
clearly and so for that kind of problem Python
is really a good match. All righty. So, let

00:33:22.660 --> 00:33:28.740
me show you--I think I'm going to go back
to the Python interpreter here. And I've showed

00:33:28.740 --> 00:33:31.960
you--I've sort of used strings and lists and
a few things informally, but I never really

00:33:31.960 --> 00:33:35.850
explained them, so I want to kind of slowdown
a little bit here and actually talk about

00:33:35.850 --> 00:33:44.960
how some of these things work. So, the Python
string-type is enclosed in quotes. So, there's

00:33:44.960 --> 00:33:51.179
like this string "hello" I've been done. You
can also actually put the string in double

00:33:51.179 --> 00:33:59.760
quotes or--here I'll do a different one. Isn't--oops--that
works the same. There's not a deep semantic

00:33:59.760 --> 00:34:02.700
difference you could--it's just your choice,
you can either use single quotes or double

00:34:02.700 --> 00:34:08.399
quotes. The one difference is that inside
of a double quoted string, as I have here,

00:34:08.399 --> 00:34:12.849
you can put a single quote like isn't there
and it just, just works. And, likewise, if

00:34:12.849 --> 00:34:19.740
I'd use single quotes, on the outside, I could
put a double quote inside. There's not a real

00:34:19.740 --> 00:34:24.429
strong preference. You can kind of use which
the one you prefer. I tend to use the single

00:34:24.429 --> 00:34:27.540
quote one. It's just, it looks a little Python
to me. Yeah, question.

00:34:27.540 --> 00:34:30.619
&gt;&gt; What kind string that you want include
single and double quotes?

00:34:30.619 --> 00:34:33.919
&gt;&gt; PARLANTE: Ah, in fairness to your question,
so if want to--so let's say I'll do a double

00:34:33.919 --> 00:34:39.610
quoted one and I want to put a double quote
inside of it. So say like--I--what would you

00:34:39.610 --> 00:34:44.399
say, I'd say like--I--what you do is you put
a back quote, a back taken from it. So I'd

00:34:44.399 --> 00:34:51.530
say, "I love this exercise," yeah, that's
fine. Well, alternately, I could have done

00:34:51.530 --> 00:34:58.710
it, and set some quotes. All right. So, I
should you--let's see what's a--isn't. So

00:34:58.710 --> 00:35:08.869
I showed you the "len." Oops. The "len" function
earlier. So strings also––as I think I've

00:35:08.869 --> 00:35:16.859
already done, they--the plus works. So if
I'd say "a + you know yay" then that puts

00:35:16.859 --> 00:35:23.839
it together, you know, plus put strings together
to make a bigger string. Strings in Python

00:35:23.839 --> 00:35:29.000
are what is called immutable and that means
that once the string is created it never changes.

00:35:29.000 --> 00:35:32.770
It's like a little read only thing. That's
a pretty modern style that turns out to be

00:35:32.770 --> 00:35:36.320
pretty popular in a lot of languages. So for
an example when I did that little plus there,

00:35:36.320 --> 00:35:43.280
if I look at the original "a" it's unchanged.
All right, the--so whenever anything you do

00:35:43.280 --> 00:35:47.260
with strings, lowercase, uppercase, I'm gonna
show you a few things. It's always creating

00:35:47.260 --> 00:35:53.670
new strings to sort of show you the result,
but the original string it's always left unchanged.

00:35:53.670 --> 00:36:01.630
So, well, maybe I'll do is I'll set "a" to
let's say uppercase "hello." Now it turns

00:36:01.630 --> 00:36:08.330
out there are a bunch of built-in string what
are called methods and I'll show you one now.

00:36:08.330 --> 00:36:14.329
So for example there's one called "lower"
and what that does is it makes the lowercase

00:36:14.329 --> 00:36:19.090
version of a string. Now the reason this is
called a method and this is basic object oriented

00:36:19.090 --> 00:36:23.250
programming just as a--you know there's some--a
few things that are very easy and that's we're

00:36:23.250 --> 00:36:29.230
going to work on for the next couple of days.
"A" this is, it points to the string, all

00:36:29.230 --> 00:36:33.001
right, I could think of a string object and
with this syntax where I say pointer to a

00:36:33.001 --> 00:36:38.730
thing dot and them the name of the method
I want to run. What that means is run that

00:36:38.730 --> 00:36:47.150
method on that object. So if I had "b" is
equal to like "yay," so if I say "b.lower"

00:36:47.150 --> 00:36:51.520
okay, well, it runs on that string. Whereas
when I'd say "a.lower" then it ran on "a,"

00:36:51.520 --> 00:36:55.730
so that's basic, it's, it's, it doesn't, it's
a different syntax for running a piece of

00:36:55.730 --> 00:37:00.710
code called the method on an object and that's
you know hopefully pretty--that's done pretty

00:37:00.710 --> 00:37:05.210
intuitively. So, what I was saying before
is that strings are immutable, they are never

00:37:05.210 --> 00:37:11.010
changed. So for example, if I look at the
original--so here, I'll do it again. If I

00:37:11.010 --> 00:37:17.210
say "a.lower" that's not changing "a" that's
returning to me a new string that's the lowercase

00:37:17.210 --> 00:37:25.970
version I wanted. d if I look at the original
"a, it's unchanged. Now Python has--there

00:37:25.970 --> 00:37:35.599
are many built-in string methods. I showed
you lower. I can show you--there's like a

00:37:35.599 --> 00:37:42.170
find, just for example. So if I say "a.find
of "e" and what that does is it searches in

00:37:42.170 --> 00:37:47.820
the string for the first occurrence of that
and then returns to me in the index. Now in

00:37:47.820 --> 00:37:53.040
reality, there are probably dozens of built-in
string methods and I'm not gonna demo them

00:37:53.040 --> 00:37:56.970
all in lecture. I just want you to know that
there are a lot of built-in ones and either

00:37:56.970 --> 00:38:00.589
you could look at the Python (ph) where it
talks about some of the common ones, or you

00:38:00.589 --> 00:38:05.910
could type, you know, in Google, type, Python
string, or maybe Python string method and

00:38:05.910 --> 00:38:10.660
go to the page where it list them all. One
of the theme--you know one of the reasons

00:38:10.660 --> 00:38:16.090
that software is a lot more productive than
it was say 15 years ago is that we've gotten

00:38:16.090 --> 00:38:20.440
better at having what I think sort of built-in
codes. Like a code you didn't write that,

00:38:20.440 --> 00:38:25.800
but that you can call and it just solves basic
problems for you, sort of code reuse, and

00:38:25.800 --> 00:38:30.700
Python like any modern language actually has
a lot of code already done for you. And so

00:38:30.700 --> 00:38:35.640
one of the basic skills--I think it's kind
of living higher on the food chain is when

00:38:35.640 --> 00:38:38.609
you're solving a problem, you don't necessarily
like, "Oh, now I'm gonna manually ride a loop

00:38:38.609 --> 00:38:42.620
to solve that." Very often your first instinct
is to find the module and dig around a little

00:38:42.620 --> 00:38:45.650
bit to find some code that somebody else already
wrote, it's already done and you're going

00:38:45.650 --> 00:38:49.589
to build your solution on top of that. That
is, that's a sort of good modern technique

00:38:49.589 --> 00:38:53.310
and it's an excellent Python technique. Python
has a lot of built-in stuff and you know over

00:38:53.310 --> 00:38:59.400
the cost of few days, I will certainly point
you where a lot of that code list. All right.

00:38:59.400 --> 00:39:05.970
So, I haven't talked about how to look inside
of a string. It turns out you can use a square

00:39:05.970 --> 00:39:11.463
brackets to look inside of a string. So if
I'd say, "a [0]" that's the left most character

00:39:11.463 --> 00:39:21.670
in "a [1]" that's the "e" and so on. If I
go out of bounds here then that's an error,

00:39:21.670 --> 00:39:29.140
so I really need to adjust you know keep within
the bounds of the actual thing. So one last--some

00:39:29.140 --> 00:39:36.020
text--I'll show you for this--this is a little
less--so you can use the plus to put together.

00:39:36.020 --> 00:39:39.589
You know if I wanted to have a string and
whatever, I could use the plus to put together.

00:39:39.589 --> 00:39:46.491
There's another form that uses seized print-up
syntax where I could say like "hi % s" and

00:39:46.491 --> 00:39:51.950
the "% s" is a place holder where I'd like
a string to go and I could say like, "I have"

00:39:51.950 --> 00:39:58.619
you know "% d donuts" and so that's, that's
called a format string and it a sort of--it's

00:39:58.619 --> 00:40:02.460
a good way of mixing in. You have this outer
skeleton and you want to sort of substitute

00:40:02.460 --> 00:40:09.721
in a few things and so then you use the "%" sign
and then you combine it with what you want.

00:40:09.721 --> 00:40:19.671
So here I'll say, "Alice and 42." And so using
this sort of "%" construct, you can have a

00:40:19.671 --> 00:40:23.880
string in sort of substitute values into it
into make a bigger string. Does not it really

00:40:23.880 --> 00:40:28.500
ever required, you could always have gotten
that result using plus to kind of put the

00:40:28.500 --> 00:40:33.190
string together but, it's fairly common to
use this so I'll just, I'll just mention it.

00:40:33.190 --> 00:40:37.119
The last thing I'll say about strings is that,
the strings that I'm showing you right here

00:40:37.119 --> 00:40:43.960
these are Unicode strings. Python's Unicode
treatment has been like a little uneven and

00:40:43.960 --> 00:40:49.260
particular in Python 3 it changed a little
bit, it got better. So for here I just want

00:40:49.260 --> 00:40:53.230
you to realize like, yeah, these are not Python
strings. These are not Unicode strings but--and

00:40:53.230 --> 00:40:58.760
in the handout talks about there's a slightly
difference route by which you create Unicode

00:40:58.760 --> 00:41:03.400
string. But once you've got a Unicode string
then all the things I showed you still work.

00:41:03.400 --> 00:41:08.300
The square brackets, the "len", the ".lower,"
all that kind of stuff, it's the same interface

00:41:08.300 --> 00:41:12.810
is just you created or so in a different way.
And so, I will--but for our purposes this

00:41:12.810 --> 00:41:17.570
will work. These strings essentially are just
serious and bites, it's just a (buck) of bites.

00:41:17.570 --> 00:41:22.930
All right. So that's almost--I'm going to
show there. So, I want to, I want to show

00:41:22.930 --> 00:41:29.070
you this one--how are we do on time? Oh, excellent.
I want to show this last string feature and

00:41:29.070 --> 00:41:36.900
I want to block out time for our first exercise.
So, in order to show you this, I'm going to

00:41:36.900 --> 00:41:45.700
go to the py quick basics document. I want
to--very high tech here. I'm going to attempt

00:41:45.700 --> 00:41:50.430
to--here we go. It's just possible. I'm going
to try and show the interpreter in a little

00:41:50.430 --> 00:41:58.760
bit of art that I put in there to end up.
Okay, oh, perfect. All right. So here, I'll

00:41:58.760 --> 00:42:05.140
say, "a = hello," so I've got the same string.
So, in that little piece of art, all I've

00:42:05.140 --> 00:42:10.750
done is I've drawn in the index numbers, so
like all the languages in Python, the things

00:42:10.750 --> 00:42:15.210
are--if I want a number and when your sequence
of things, they are numbered from zero, starting

00:42:15.210 --> 00:42:22.020
at the left. So, if I'd say--if I refer to
"a [0]" that's the "h"--this is how I should

00:42:22.020 --> 00:42:27.500
have done it for or "a [1]" that's the "e."
Or if I say, "What's the len of this thing?"

00:42:27.500 --> 00:42:35.619
that's "5," so that just sort of conventional
indexing into something. Now Python has a

00:42:35.619 --> 00:42:42.490
syntax for referring to not just a single
element in a string like this but a kind of

00:42:42.490 --> 00:42:50.780
subpart of it, and this syntax is gonna use
the colon. So the way this is going to work

00:42:50.780 --> 00:42:54.560
is if I say "a" and I'll put the square bracket
but I'm going to put a colon in the middle

00:42:54.560 --> 00:42:59.619
here, and I'm going to refer--I'm going to
indicate both the start and the end. So, for

00:42:59.619 --> 00:43:04.839
example, if I'd say, "What, what?" I want
you to start at one; so that's the first index

00:43:04.839 --> 00:43:10.569
number and then the second number--yeah, it's
going to say, it's going to go up to but not

00:43:10.569 --> 00:43:18.470
including that one. In Python, this is called
a slice. So if I'd say "a [1:3]" that's the

00:43:18.470 --> 00:43:25.790
subpart of the string starting at the one
and going up to but not including the three.

00:43:25.790 --> 00:43:31.620
This is called--it's only entitled called
the slice. There's a--the word Pythonic is

00:43:31.620 --> 00:43:37.770
not a word I just made up, it's a real one,
in the nerdoroty (ph), and this is a very

00:43:37.770 --> 00:43:44.589
Pythonic feature. Python likes having syntaxes
which are sort of very short but crisp but

00:43:44.589 --> 00:43:49.220
then again you know it express something that
a common thing that you might want to do.

00:43:49.220 --> 00:43:58.330
So, if I wanted to--if I wanted to say, "Hello,"
I guess, I could say, what is it, a one--oops,

00:43:58.330 --> 00:44:05.290
"a [1:5]." That's a little weird. The five
is kind of one out of bounds there but, actually,

00:44:05.290 --> 00:44:12.319
what you could do in the slice syntax is if
you omit the second, the thing after the colon,

00:44:12.319 --> 00:44:17.920
it just goes all the way through the end of
the string. And, if you omit the first one,

00:44:17.920 --> 00:44:22.581
it starts at the beginning. So actually it
is a truism that if I'd just say square bracket,

00:44:22.581 --> 00:44:27.829
colon square bracket, well, I just get the
whole of whatever it was. So this is a very

00:44:27.829 --> 00:44:33.849
heavy syntax. For say, for example, if I want
to, you know, remove the first level--level--letter.

00:44:33.849 --> 00:44:38.890
I could just say one colon (ph) so like instead
of starting at zero, start at one and then

00:44:38.890 --> 00:44:46.620
just go through the end. So that's, so far
that's like pretty neat. But now, just a little

00:44:46.620 --> 00:44:55.220
bit of scrolling, I'd show you the slightly
other crazy thing it does. So, thus far, I've

00:44:55.220 --> 00:45:04.910
just used the positive numbers, but in Python,
they also added a second set of numbers that

00:45:04.910 --> 00:45:08.540
also index into the strings. So it's just
using the negative numbers and the negative

00:45:08.540 --> 00:45:14.800
numbers instead of starting at the left, they
start at the right. So minus one refers to

00:45:14.800 --> 00:45:19.589
the rightmost character and minus two refers
to the next one and the minus three and so

00:45:19.589 --> 00:45:24.050
on. You can think of essentially as there's
an implicit len there that--the minus one

00:45:24.050 --> 00:45:29.180
essentially saying len minus one, right. So
len in this case is five. Len minus one is

00:45:29.180 --> 00:45:35.480
four. I'll check it out for you. So do you
have written a code in a zero based system

00:45:35.480 --> 00:45:38.589
but it means that referring to things that
happen to be at the left is very convenient

00:45:38.589 --> 00:45:41.400
because like zero, one, two, you always know
where you are. But then referring to things

00:45:41.400 --> 00:45:45.580
at the right is like a pain because you always
have to add len and subtract something. So

00:45:45.580 --> 00:45:50.170
the negative numbers scheme just also makes
it convenient to refer to things on the right

00:45:50.170 --> 00:45:59.930
hand side, and they work in slices too. So,
for example, how about I say that I want to

00:45:59.930 --> 00:46:05.760
omit--first, I'll just do my earlier example.
So I could say what is it? "[-4:-2]"--oops.

00:46:05.760 --> 00:46:16.830
I'll put the "a" there. That's exactly equivalent
to the one where earlier it was a one colon

00:46:16.830 --> 00:46:22.099
three, right. The minus four is just another
way of saying that. I'm going to get a more

00:46:22.099 --> 00:46:27.762
realistic example. Say for example, I wanted
to omit the last three characters of the string.

00:46:27.762 --> 00:46:32.589
I didn't know how long it was. I could just
write that as colon minus three. All right,

00:46:32.589 --> 00:46:37.660
that it's going to go up to but not included.
I know minus three is the third in. So like

00:46:37.660 --> 00:46:42.550
I could "he" or I could do a getaway. What
if I only want the last three characters of

00:46:42.550 --> 00:46:50.530
a string? I guess right that is minus three
colon. So, it just--I think, syntactically,

00:46:50.530 --> 00:46:54.970
this is maybe it looks a little bit weird
but I found--the slice syntax, I find it--it's

00:46:54.970 --> 00:47:00.270
just useful in a lot of situations. So I would
encourage you to go ahead and actually learn

00:47:00.270 --> 00:47:05.660
this one and we're going to have all these
exercises and stuff in a little bit. Certainly,

00:47:05.660 --> 00:47:11.430
I have hidden inside of their little opportunities
for you to end up going to use the slice syntax.

00:47:11.430 --> 00:47:18.700
So that is a nice one to get the stuff going.
Okay, so that actually concludes the first

00:47:18.700 --> 00:47:27.750
lecture section. So what I would like you
to do is pull up the exercises and so if you

00:47:27.750 --> 00:47:37.790
go to the py quick page--just do it here--it
points to this page, py quick exercises, here

00:47:37.790 --> 00:47:43.300
you go. And then that explains how you copy
and I--if you could raise your hand, I'm happy

00:47:43.300 --> 00:47:49.270
to kind of walk on. How you can copy--this
is--said directory, direct, directories. It's

00:47:49.270 --> 00:47:53.220
going to look like this and let me--now, let
me show what I want you to do. So inside here,

00:47:53.220 --> 00:47:58.220
there's like day one, day two, and some other
stuff. Today, we're doing day one. So go in

00:47:58.220 --> 00:48:05.710
the day one directory, and the first thing
I want you to look at is there's this, there's

00:48:05.710 --> 00:48:10.770
a file there called--oops, no, not that one.
There's a file there called "string1.py" and

00:48:10.770 --> 00:48:20.660
I'm just going to look inside of there. A
so what this thing has--is in the comments--sorry,

00:48:20.660 --> 00:48:25.920
I'll make this a little bigger. There are
some little exercises in here that just use

00:48:25.920 --> 00:48:30.240
the stuff in lecture that we've done so far.
So, for example, here's, you know, exercise

00:48:30.240 --> 00:48:35.130
"A: Dr. Evil" and just in English, there's
a little description of like what it is I

00:48:35.130 --> 00:48:40.710
want you to do and it gives a little example
but then the code it just not done. And so

00:48:40.710 --> 00:48:45.650
your job is fill in the code there to actually
compute what it's suppose to compute; there's

00:48:45.650 --> 00:48:52.349
a few of these things. And then at the bottom,
I have filled in little bits of test code.

00:48:52.349 --> 00:48:54.599
And so you see that you don't have to touch
that, that's already done. They're just going

00:48:54.599 --> 00:48:56.670
to call the functions above and just kind
of check that they were trying the right thing.

00:48:56.670 --> 00:49:04.200
So it's kind of a primitive form of unit testing.
So if I run this thing right now, what it

00:49:04.200 --> 00:49:09.660
does is they all fail, because yeah, there
is no code and so what's gonna happen is as

00:49:09.660 --> 00:49:14.020
you fill those bits of function in then somebody's
pass--this discussion start passing. You can

00:49:14.020 --> 00:49:18.750
just run it each time to just very quickly
just get feedback about how it's going. So

00:49:18.750 --> 00:49:26.760
that is string one, I'd like everyone to do
string one. If you are just so fast, you get

00:49:26.760 --> 00:49:33.059
a little bored, there's also a string two.
In string two, it just contains more. And

00:49:33.059 --> 00:49:35.070
so, optionally, if we you have more time to
kill, I'd be happy for you to go ahead and

00:49:35.070 --> 00:49:41.860
do that. The last thing I need to point out
here--let's see, I'll just look at string

00:49:41.860 --> 00:49:52.041
one here. There's a thing I mentioned earlier
that I never explained. This "-tt" flag. What

00:49:52.041 --> 00:49:58.770
that refers to is in a Python file, what I
would recommend is you just always indent

00:49:58.770 --> 00:50:03.080
with spaces and that that is the Google standard,
just always indent with spaces and you're

00:50:03.080 --> 00:50:06.970
okay. But, in your editor, maybe by habit
or whatever you might accidentally hit the

00:50:06.970 --> 00:50:11.781
tab key, and if you have a Python file that
has a mixture where it uses and spaces in

00:50:11.781 --> 00:50:18.200
some places, in tabs and other places that
is deeply confusing, because visually where

00:50:18.200 --> 00:50:23.900
the codes appears to vertically appears to
a line may not correspond to how it really

00:50:23.900 --> 00:50:27.900
aligns as far as Python is concerned. So what
the "-tt" flag does is if it ever finds a

00:50:27.900 --> 00:50:32.930
mixture of spaces and tabs, it just immediately
halts, which is for--when you're on your first

00:50:32.930 --> 00:50:36.309
day of Python programming that's absolutely
what you want. So this will help you find

00:50:36.309 --> 00:50:39.809
the case where you want to do is the [INDISTINCT]
I've talked about. You want to set your editor

00:50:39.809 --> 00:50:45.350
so that if you ever hit the tab key, it understands
to just put in spaces. So put the "-tt" flag

00:50:45.350 --> 00:50:50.990
will protect you if, if you end up with--make
a mistake with that. Oh, all right so here's

00:50:50.990 --> 00:50:56.740
what I'd like to do, it's now, it's about
10:50, so I'm going to imagine; I want you

00:50:56.740 --> 00:51:01.520
to work on this with me maybe about half hour
for that, so that's--what I'd like you to

00:51:01.520 --> 00:51:12.270
do is then go have lunch. So what I'd like
you to do is be back in here--I'll have do

00:51:12.270 --> 00:51:17.970
all the math here. Back in here at 1:15 and
so I'm going to leave you some time for doing

00:51:17.970 --> 00:51:21.770
Python coding and then some time for having
for having lunch. You, it allows you to bounce

00:51:21.770 --> 00:51:24.980
something and of course, you know, I'm in
here to answer questions or whatever during

00:51:24.980 --> 00:51:28.039
that whole time. All right. So, so please
go ahead and get started with that.

