WEBVTT
Kind: captions
Language: en

00:00:01.050 --> 00:00:03.429
&gt;&gt;Reto Meier: So good morning, everyone.

00:00:03.429 --> 00:00:04.670
Thanks for coming along to the session.

00:00:04.670 --> 00:00:06.330
It's great to see a huge turnout.

00:00:06.330 --> 00:00:07.750
My name is Reto Meier.

00:00:07.750 --> 00:00:11.430
I'm the developer advocate on the development
team at Google.

00:00:11.430 --> 00:00:16.820
I'm going present to you today, hopefully,
Protips on how to build expert apps for Android.

00:00:16.820 --> 00:00:21.869
Before we get started, we've got a couple
housekeeping notes.

00:00:21.869 --> 00:00:24.660
We've got the session feedback.

00:00:24.660 --> 00:00:28.070
For those in the audience who want to give
feedback either during or preferably at the

00:00:28.070 --> 00:00:32.200
end of the session, please don't take the
advice of the previous session and give their

00:00:32.200 --> 00:00:34.460
bad advice to me.

00:00:34.460 --> 00:00:37.460
Maybe save it all up for the next session.

00:00:37.460 --> 00:00:41.699
For those of you who are at home watching
via the YouTube stream, you can ask questions

00:00:41.699 --> 00:00:43.929
via the moderator link, which is up there.

00:00:43.929 --> 00:00:49.019
And, hopefully, we'll be able to get to some
of those by the end of session as well.

00:00:49.019 --> 00:00:51.390
So this is supposed to be an expert session.

00:00:51.390 --> 00:00:52.390
A 301.

00:00:52.390 --> 00:00:53.390
And it's a packed room.

00:00:53.390 --> 00:00:59.690
I think I need to ask how many of you consider
yourselves to be expert Android developers?

00:00:59.690 --> 00:01:01.390
That's a majority.

00:01:01.390 --> 00:01:02.390
Excellent.

00:01:02.390 --> 00:01:04.070
Hopefully, this will help get you there.

00:01:04.070 --> 00:01:07.690
For those of you who did, hopefully, there's
going to be some stuff here that you will

00:01:07.690 --> 00:01:09.500
find interesting and new.

00:01:09.500 --> 00:01:13.250
I should warn you there is a lot of code in
this presentation.

00:01:13.250 --> 00:01:15.910
Don't feel like you need to scribble it all
down now.

00:01:15.910 --> 00:01:22.000
The recorded video and the slides will be
available for your copying and pasting pleasure

00:01:22.000 --> 00:01:23.070
pretty quickly after I/O.

00:01:23.070 --> 00:01:27.020
So don't feel like you have to scribble it
down now.

00:01:27.020 --> 00:01:32.242
So as experts, what do you think is the most
common question that I get asked by bury other

00:01:32.242 --> 00:01:33.530
expert developers?

00:01:33.530 --> 00:01:40.210
I can tell you that more than any single technical
question, the most common thing I get asked

00:01:40.210 --> 00:01:41.830
is how do I get featured?

00:01:41.830 --> 00:01:43.650
[ Laughter ]
Yeah?

00:01:43.650 --> 00:01:45.800
I'm sure plenty of you asked me this yourselves.

00:01:45.800 --> 00:01:46.800
How do I get featured?

00:01:46.800 --> 00:01:51.590
How do I rank more highly, and how do I show
up in search results?

00:01:51.590 --> 00:01:54.780
The answer is both pretty simple and quite
complicated.

00:01:54.780 --> 00:01:58.100
I'm going to try to cover both of those things
today.

00:01:58.100 --> 00:02:01.200
Let's start by putting this into a little
bit of context.

00:02:01.200 --> 00:02:04.350
How many of you have apps in the Android market?

00:02:04.350 --> 00:02:05.350
Keep your hands up.

00:02:05.350 --> 00:02:10.590
If you don't want your app featured, you can
put your hand down.

00:02:10.590 --> 00:02:13.910
What that represents is a graphic that looks
a little like this.

00:02:13.910 --> 00:02:16.760
Pretty much every app wants to be featured.

00:02:16.760 --> 00:02:21.540
I tried to make it to scale, but the half
pixel didn't render.

00:02:21.540 --> 00:02:25.470
What's left is a group of people who don't
know about featuring.

00:02:25.470 --> 00:02:26.760
Awesome.

00:02:26.760 --> 00:02:30.340
The tiny sliver are apps which are already
featured.

00:02:30.340 --> 00:02:34.030
So let's have a closer look at that.

00:02:34.030 --> 00:02:37.410
That sliver represents about 30 apps at any
given time.

00:02:37.410 --> 00:02:42.850
Now, if you do the math, there's about 150-
I think 200,000 apps now in the Android Market.

00:02:42.850 --> 00:02:47.240
There's about 2,000 people in the keynote
this morning, which means, if the keynote

00:02:47.240 --> 00:02:51.440
represents the market, one person would have
been featured.

00:02:51.440 --> 00:02:56.800
Even in this room we've got a much higher
percentage of quality Android-developers.

00:02:56.800 --> 00:03:00.200
Say you're 10 times more likely to get featured.

00:03:00.200 --> 00:03:04.370
That means there's two, maybe three apps here
which will be featured.

00:03:04.370 --> 00:03:05.569
Look around.

00:03:05.569 --> 00:03:09.680
If there's someone else who has a better app
than you, you're already in trouble.

00:03:09.680 --> 00:03:13.490
The simple answer is you need to build the
best app in the room.

00:03:13.490 --> 00:03:17.730
The slightly more complicated answer is how
do I go about doing that, which I'm hopefully

00:03:17.730 --> 00:03:19.580
going to try to show you guys today.

00:03:19.580 --> 00:03:24.380
I'm going to start off with some APIs you've
probably already seen, you've already blogged

00:03:24.380 --> 00:03:25.380
about.

00:03:25.380 --> 00:03:28.340
But I'm going to show you new ways to use
these existing APIs.

00:03:28.340 --> 00:03:31.000
I'm going to go through a couple Rookie Mistakes.

00:03:31.000 --> 00:03:35.080
I see expert developers do this day in and
day out.

00:03:35.080 --> 00:03:40.780
I'm going to put it out there for you guys,
so you don't make the same mistake.

00:03:40.780 --> 00:03:43.430
Hopefully the last half hour of the presentation,
if I run vaguely to schedule, is going to

00:03:43.430 --> 00:03:47.410
be purely Protips, all code.

00:03:47.410 --> 00:03:50.620
So how do you build the best app in the room?

00:03:50.620 --> 00:03:52.650
Well, in some ways it's actually really simple.

00:03:52.650 --> 00:03:54.709
You build an app that people want.

00:03:54.709 --> 00:03:58.760
Things like e-mail, news, maps, these sorts
of apps people have been trying to get this

00:03:58.760 --> 00:04:02.470
information onto their phones since long before
phones had Internet connections.

00:04:02.470 --> 00:04:07.620
Where it gets a little bit more challenging
is creating apps that people want but they

00:04:07.620 --> 00:04:09.470
don't realize that they want.

00:04:09.470 --> 00:04:12.520
Good examples -- Shazam, Google Goggles.

00:04:12.520 --> 00:04:15.459
How many have played Angry Birds?

00:04:15.459 --> 00:04:19.299
How many are playing Angry Birds right now?

00:04:19.299 --> 00:04:20.669
That's all right.

00:04:20.669 --> 00:04:22.569
I'm not offended.

00:04:22.569 --> 00:04:24.210
So what do these apps have in common?

00:04:24.210 --> 00:04:27.139
They're apps which are a step ahead of the
game.

00:04:27.139 --> 00:04:32.570
Whether it's using microphone API to sample
music or whether it's using video APIs to

00:04:32.570 --> 00:04:39.069
do video recognition, or it's just simply
using a high res screen in a great way to

00:04:39.069 --> 00:04:42.599
create an immersive game play, they're at
the cutting edge.

00:04:42.599 --> 00:04:50.130
What I'm going to talk about today is using
some of the more current APIs, some of the

00:04:50.130 --> 00:04:54.039
stuff which is only available in Gingerbread
or, in some cases, Honeycomb.

00:04:54.039 --> 00:04:58.069
The reason why I think you guys need to consider
this is you need to create the app which is

00:04:58.069 --> 00:04:59.389
better than everyone else's.

00:04:59.389 --> 00:05:01.150
It's not just about quality.

00:05:01.150 --> 00:05:05.259
It's also about innovation and using these
new APIs as a way that you can be the new

00:05:05.259 --> 00:05:11.830
Shazam or new Google Goggles or next Angry
Birds by using really advanced APIs and creating

00:05:11.830 --> 00:05:16.560
apps that aren't just things people use on
their shiny new tablets but they're reasons

00:05:16.560 --> 00:05:18.849
to go out and buy the tablets to begin with.

00:05:18.849 --> 00:05:26.210
But now that you all have tablets, you have
no excuse for not developing the new APIs.

00:05:26.210 --> 00:05:27.210
It's not only that.

00:05:27.210 --> 00:05:32.000
You also get to take advantage of efficiency
improvements on each of the platforms so each

00:05:32.000 --> 00:05:36.430
user is using the most efficient app that
they can.

00:05:36.430 --> 00:05:40.449
And it's also a matter of creating the best
user experience so everything is optimized

00:05:40.449 --> 00:05:43.490
for what you're using.

00:05:43.490 --> 00:05:45.439
Let's look at how you go about doing this.

00:05:45.439 --> 00:05:49.870
It's not as difficult as you think to create
applications that work on both smart phones

00:05:49.870 --> 00:05:54.389
and new modern OS versions.

00:05:54.389 --> 00:05:57.729
This is an activity that I think of as parallel
activity pattern.

00:05:57.729 --> 00:06:04.969
What you're looking at here is a simple pattern
where you're creating, essentially, a shim

00:06:04.969 --> 00:06:05.969
class.

00:06:05.969 --> 00:06:10.060
We start off by looking at what is the version
of the APKs we have.

00:06:10.060 --> 00:06:12.199
Do we have -- are we running on Honeycomb?

00:06:12.199 --> 00:06:18.599
Do we have shiny new APIs, or are we doing
things on a earlier version?

00:06:18.599 --> 00:06:23.789
So all that happens with OnCreate is we're
checking to see whether or not APIs are available

00:06:23.789 --> 00:06:29.629
and starting a new activity, a different activity
depending on which level of APIs are available.

00:06:29.629 --> 00:06:31.719
So here we call start activity.

00:06:31.719 --> 00:06:35.089
What this is doing is meaning this is a shim
activity.

00:06:35.089 --> 00:06:36.089
It has no UI.

00:06:36.089 --> 00:06:41.119
It doesn't do anything other than launch one
set of parallel activity streams.

00:06:41.119 --> 00:06:45.449
Now the good news is that you don't actually
need to have a completely parallel set of

00:06:45.449 --> 00:06:46.900
code base.

00:06:46.900 --> 00:06:49.889
For the most part your layouts are going to
be consistent.

00:06:49.889 --> 00:06:55.460
If you're using the new fragments library,
which is compatible all the way back to 1.6,

00:06:55.460 --> 00:07:01.659
most of your UI is going to be encapsulated
into the fragments, which means they're going

00:07:01.659 --> 00:07:05.849
to be consistent across the activity streams,
particularly when you're interfacing using

00:07:05.849 --> 00:07:06.879
the resources hierarchy.

00:07:06.879 --> 00:07:12.210
So you've, actually, only got one set of fragments,
which is using a different layout to display

00:07:12.210 --> 00:07:13.770
the same information.

00:07:13.770 --> 00:07:18.559
Now, the advantage of this is that, rather
than having to have completely separate sets

00:07:18.559 --> 00:07:22.770
of activities, all you need to do is optimize
particular experience.

00:07:22.770 --> 00:07:28.190
And so for Honeycomb, as we learned, the Action
Bar, for example, isn't available, isn't backwards

00:07:28.190 --> 00:07:29.190
compatible.

00:07:29.190 --> 00:07:36.619
So on a Honeycomb device you use the action
bar and animation framework.

00:07:36.619 --> 00:07:40.699
And on a pre-Honeycomb device using the same
fragments, but you're having to create your

00:07:40.699 --> 00:07:43.139
own activity bar implementation.

00:07:43.139 --> 00:07:49.319
So it's a way to, essentially, optimize based
on the level of APIs available.

00:07:49.319 --> 00:07:51.249
Now, that's one approach.

00:07:51.249 --> 00:07:53.939
The other thing you can do is just use good
old interfaces.

00:07:53.939 --> 00:07:56.259
You'll all experts, so you're all at Google
I/O.

00:07:56.259 --> 00:08:00.080
So I don't think I need to go into what an
interface is.

00:08:00.080 --> 00:08:04.699
But it gives you an opportunity to create
different implementations based on hardware

00:08:04.699 --> 00:08:08.699
and software you have available to you.

00:08:08.699 --> 00:08:11.360
So this piece of code shows exactly how to
do this.

00:08:11.360 --> 00:08:12.979
So we're looking at three different things.

00:08:12.979 --> 00:08:16.639
So, if you've got -- what we're trying to
do is find the orientation of the device.

00:08:16.639 --> 00:08:18.970
There's a few variations.

00:08:18.970 --> 00:08:22.169
The initial version, which was pre-Cupcake,
had a lot of information.

00:08:22.169 --> 00:08:26.879
So we check to see if we're still running
pre-Cupcake, which is pretty good effort at

00:08:26.879 --> 00:08:27.879
this point.

00:08:27.879 --> 00:08:32.279
We're also going to check so see whether we
have a gyroscope, because we can use the gyro

00:08:32.279 --> 00:08:36.289
to smooth out orientation changes.

00:08:36.289 --> 00:08:40.789
And then the bulk of the class is going to
be instantiate a different implementation

00:08:40.789 --> 00:08:42.490
of that sensor listener.

00:08:42.490 --> 00:08:47.120
So all the reflection, does the gyroscope
exist, all that stuff can be encapsulated

00:08:47.120 --> 00:08:51.959
away in those implementations?

00:08:51.959 --> 00:08:56.410
So that's one way is to create, using the
new APIs, something innovative.

00:08:56.410 --> 00:09:01.000
The other thing you want to do is build apps
which are really good.

00:09:01.000 --> 00:09:04.600
A great way of doing that is by getting real
user feedback.

00:09:04.600 --> 00:09:07.360
Now my slides are already out of date.

00:09:07.360 --> 00:09:10.000
There's, apparently, over 300 Android devices
available these days.

00:09:10.000 --> 00:09:15.519
And in well over 1-, probably 200 countries,
so really something global.

00:09:15.519 --> 00:09:20.990
And the ability for you guys as developers
to actually test for all of these devices

00:09:20.990 --> 00:09:23.410
and all of these countries is pretty much
impossible.

00:09:23.410 --> 00:09:28.620
And the solution to that -- at Google what
we do is we have a system called dogfooding

00:09:28.620 --> 00:09:34.410
where we get everyone in the company to use
these new apps or new operating systems.

00:09:34.410 --> 00:09:36.480
And we can get a lot of feedback from them.

00:09:36.480 --> 00:09:38.110
We have more than 20,000 employees.

00:09:38.110 --> 00:09:40.490
And they're spread all across the world.

00:09:40.490 --> 00:09:43.430
And they're all within the same corporate
intranet, so it's really easy for us to get

00:09:43.430 --> 00:09:44.440
feedback.

00:09:44.440 --> 00:09:49.060
It's much more challenging for you guys who
probably have slightly smaller companies.

00:09:49.060 --> 00:09:53.699
So one thing you can do to try to get that
feedback is use analytics tracking, not only

00:09:53.699 --> 00:09:56.230
in your live version, but in your betas.

00:09:56.230 --> 00:10:02.300
So what we're doing in this particular piece
of code is we're going to track exceptions.

00:10:02.300 --> 00:10:05.970
So we're going to look to see every time an
exception gets thrown, we're going to track

00:10:05.970 --> 00:10:06.970
that.

00:10:06.970 --> 00:10:08.290
So we can find out is there clustering?

00:10:08.290 --> 00:10:12.819
Are we seeing a particular exception get thrown
a lot in a particular country in a particular

00:10:12.819 --> 00:10:17.670
language in a particular device type or just
corresponding to a particular workflow?

00:10:17.670 --> 00:10:21.329
So it's all about bug tracking, getting as
much information as possible.

00:10:21.329 --> 00:10:26.980
What's a little more interesting, I think,
is actually doing A/B testing using the same

00:10:26.980 --> 00:10:27.980
technique.

00:10:27.980 --> 00:10:32.589
So we're going to start off just by generating
a random number and splitting people into

00:10:32.589 --> 00:10:33.589
one of two groups.

00:10:33.589 --> 00:10:35.589
Are they A or B group?

00:10:35.589 --> 00:10:39.680
And then, within your own create method, we're
going to set the content type differently.

00:10:39.680 --> 00:10:42.350
So it's either going to be an A or B group.

00:10:42.350 --> 00:10:45.970
Now that layout can be completely different.

00:10:45.970 --> 00:10:50.331
It can be as complicated as having completely
different button layouts -- some in the Action

00:10:50.331 --> 00:10:52.660
Bar, some on menu, some on screen.

00:10:52.660 --> 00:10:55.889
Or it can be as easy as trying to figure out
which shade of blue your users appreciate

00:10:55.889 --> 00:10:57.459
more.

00:10:57.459 --> 00:11:01.329
Because we're tracking each of the users based
on the group they're in, we're able to see

00:11:01.329 --> 00:11:03.050
how does this affect their engagement?

00:11:03.050 --> 00:11:04.660
Are they using your app more?

00:11:04.660 --> 00:11:07.699
Are they doing the things which you want them
to do more?

00:11:07.699 --> 00:11:12.110
These are the sorts of things which make it
much easier for you to understand how your

00:11:12.110 --> 00:11:13.110
app is working.

00:11:13.110 --> 00:11:17.990
It's optimizing your beta by getting real
feedback as to how your app is being used,

00:11:17.990 --> 00:11:23.009
what the user engagement is and lets you do
that optimization.

00:11:23.009 --> 00:11:28.250
If you're going to do a widespread beta of
that kind, good approach is to use the Android

00:11:28.250 --> 00:11:29.620
market to do that.

00:11:29.620 --> 00:11:32.240
There's a lot of things you should take into
account.

00:11:32.240 --> 00:11:36.329
Particularly as soon as you're making it globally
available, putting it on the market, you make

00:11:36.329 --> 00:11:39.759
sure that users understand that it is a beta.

00:11:39.759 --> 00:11:44.000
Now whether that's by making a private beta
with a log-in code or simply obscuring the

00:11:44.000 --> 00:11:48.790
name and making it unclear what the app is,
it's important to set that expectation so

00:11:48.790 --> 00:11:51.670
that people know they shouldn't be expecting
a finished product.

00:11:51.670 --> 00:11:56.410
They should be expecting frequent updates
and slightly more polished, as you bring it

00:11:56.410 --> 00:11:57.410
to market.

00:11:57.410 --> 00:12:01.829
I've seen this being done very successfully
with a number of apps launched recently.

00:12:01.829 --> 00:12:06.709
and it's helped them to create a better application
based on what people have said rather than

00:12:06.709 --> 00:12:09.200
what they've thought.

00:12:09.200 --> 00:12:14.820
So, if we are going to do this, you introduce
the idea of the first possible Rookie Mistake

00:12:14.820 --> 00:12:16.329
you can make.

00:12:16.329 --> 00:12:18.879
And that's not protecting your package name.

00:12:18.879 --> 00:12:25.019
Now, as soon as your APK leaves your dev box,
the first thing you should probably want to

00:12:25.019 --> 00:12:29.730
do is put that in market because the package
name is unique.

00:12:29.730 --> 00:12:34.830
If someone gets your APK, they can upload
it to market and they own your package name.

00:12:34.830 --> 00:12:38.279
So now, if you want to launch, you have to
go through this whole hassle.

00:12:38.279 --> 00:12:42.199
I've seen this happen before by experts who
should know better.

00:12:42.199 --> 00:12:47.100
At the same time, make sure as soon as you've
used your signing key to sign your APK, that

00:12:47.100 --> 00:12:51.600
you've backed it up and backed it up again
in another country in a fireproof box.

00:12:51.600 --> 00:12:55.250
This is the only way you can update your app.

00:12:55.250 --> 00:12:58.860
If you lose the signing certificate, it doesn't
matter who at Google -- you can bump into

00:12:58.860 --> 00:13:00.010
Andy Rubin on the street.

00:13:00.010 --> 00:13:02.740
He's not going to be able to update that app
for you.

00:13:02.740 --> 00:13:06.170
Make sure you keep that certificate secure.

00:13:06.170 --> 00:13:10.269
Another big tip, when you create the market
account, don't use your personal e-mail account

00:13:10.269 --> 00:13:15.290
or the CEO's e-mail account or the intern
who's doing it after lunch.

00:13:15.290 --> 00:13:18.620
That's the account you're going to need to
log into to do updates and changes.

00:13:18.620 --> 00:13:22.069
You don't want to have to call someone at
3:00 a.m. on their holiday so you can login

00:13:22.069 --> 00:13:28.580
into their personal e-mail account and change
the release text.

00:13:28.580 --> 00:13:32.000
Next Rookie Mistake is going to be a little
more technical.

00:13:32.000 --> 00:13:34.600
And that's assuming that the device is portrait.

00:13:34.600 --> 00:13:37.860
So you're all proud new tablet owners.

00:13:37.860 --> 00:13:41.800
So you'll learn firsthand that a lot of these
tablet devices are designed to be used in

00:13:41.800 --> 00:13:43.899
landscape mode.

00:13:43.899 --> 00:13:49.970
A lot of games developers have said my app,
my game can only be played in landscape mode.

00:13:49.970 --> 00:13:54.699
And I'm using the orientation sensors, and
that's how the layout is designed.

00:13:54.699 --> 00:13:56.120
So they've done coding.

00:13:56.120 --> 00:13:57.120
And okay.

00:13:57.120 --> 00:14:00.519
Smartphone at landscape mode is 90Â°.

00:14:00.519 --> 00:14:06.889
So we're going to rotate our accelerometer
logic to take that 90% turn into account.

00:14:06.889 --> 00:14:12.589
The thing is you put that on a tablet and
it's at 000, because it's not just the branding

00:14:12.589 --> 00:14:16.550
which is orientated in landscape mode; it's
also the orientation sensor.

00:14:16.550 --> 00:14:20.370
So now, because you're making that assumption,
you're going to get the orientation 90 degrees

00:14:20.370 --> 00:14:21.370
off.

00:14:21.370 --> 00:14:24.430
And your game is going to controlled in portrait
mode.

00:14:24.430 --> 00:14:27.660
It's actually really easy to get this right.

00:14:27.660 --> 00:14:31.449
You get rotation on the display object that's
going to tell you to the nearest 90 degrees

00:14:31.449 --> 00:14:33.410
what the actual orientation is.

00:14:33.410 --> 00:14:38.339
And then you can simply remap the coordinate
system on the sensor manager so it's always

00:14:38.339 --> 00:14:39.339
zeroed out.

00:14:39.339 --> 00:14:44.689
So, if you want to lock the device to landscape
for game play, assume it's at zero, check

00:14:44.689 --> 00:14:50.600
using the display get rotation and remap the
coordinate systems accordingly.

00:14:50.600 --> 00:14:55.410
Another Rookie Mistake we see is people trying
to detect and track a particular device instead

00:14:55.410 --> 00:14:57.249
of a particular installation.

00:14:57.249 --> 00:15:00.339
There's a lot of good reasons why you want
to track a particular installation.

00:15:00.339 --> 00:15:04.499
You want to let people save settings on the
server without having to create a log-in.

00:15:04.499 --> 00:15:05.800
That's all great.

00:15:05.800 --> 00:15:09.050
What you don't want to do is track a particular
piece of hardware.

00:15:09.050 --> 00:15:11.610
Now, there's a few reasons that you shouldn't.

00:15:11.610 --> 00:15:14.740
And the first reason is it's actually quite
difficult to do.

00:15:14.740 --> 00:15:16.850
You can get telephony manager.

00:15:16.850 --> 00:15:21.029
But, if there is no telephony manager, then
it returns null.

00:15:21.029 --> 00:15:22.029
You can say okay.

00:15:22.029 --> 00:15:25.070
If the telephony manager returns null, then
I'll get the Mac address.

00:15:25.070 --> 00:15:29.860
If Bluetooth or Wi-Fi is turned off, that
also returns null.

00:15:29.860 --> 00:15:35.439
What's even worse is, with both of these circumstances,
if you wipe the device and give it to your

00:15:35.439 --> 00:15:40.120
friends or sell it on eBay and someone else
logs in, it's going to have the same device

00:15:40.120 --> 00:15:41.120
number.

00:15:41.120 --> 00:15:43.769
So now your settings are being applied to
someone else's device.

00:15:43.769 --> 00:15:47.639
And, from a developer perspective, this is
a really bad time.

00:15:47.639 --> 00:15:51.699
It has privacy implications as well as usability
implications.

00:15:51.699 --> 00:15:54.589
You can use the Android ID field and secure
settings.

00:15:54.589 --> 00:15:59.760
It doesn't work reliably prior to Android
2.2.

00:15:59.760 --> 00:16:03.829
You're still asking the user for a scary permission.

00:16:03.829 --> 00:16:06.569
This device needs access to use your secure
settings.

00:16:06.569 --> 00:16:08.110
I've just downloaded Solitaire.

00:16:08.110 --> 00:16:11.660
Why on earth do they need access to my secure
settings?

00:16:11.660 --> 00:16:15.079
The solution is fairly straightforward.

00:16:15.079 --> 00:16:19.360
All you need to do is generate a unique identifier
for the application.

00:16:19.360 --> 00:16:20.800
And so that's all that this code is doing.

00:16:20.800 --> 00:16:23.529
There's a lot on screen, but this is the only
bit which is really important.

00:16:23.529 --> 00:16:31.059
I'm going create a new random universal unique
identifier.

00:16:31.059 --> 00:16:34.970
So from this moment onwards, this application
is uniquely identifiable.

00:16:34.970 --> 00:16:41.269
So you can score settings, user preferences,
all those sorts of things on the server.

00:16:41.269 --> 00:16:45.579
The last Rookie Mistake is a really easy one.

00:16:45.579 --> 00:16:47.260
It's a bit of a gimme.

00:16:47.260 --> 00:16:51.180
If you've watched the previous session, you'll
note they gave about half a dozen shoutouts

00:16:51.180 --> 00:16:52.600
to the Android developer blog.

00:16:52.600 --> 00:16:54.870
We're not trying to keep secrets from you
guys.

00:16:54.870 --> 00:16:56.089
We love doing Google I/O.

00:16:56.089 --> 00:16:57.589
We love doing these sessions.

00:16:57.589 --> 00:17:02.139
Day in and day out, each week, when we're
releasing new things or finding new opportunities

00:17:02.139 --> 00:17:06.600
to help you guys build better apps, this is
where we're going to put the new information.

00:17:06.600 --> 00:17:10.450
It's not on your frequently read list, be
sure to check it out.

00:17:10.450 --> 00:17:14.080
That's where all the tips I'm talking about
today will be or shortly appear.

00:17:14.080 --> 00:17:18.640
That's the simple stuff.

00:17:18.640 --> 00:17:19.940
I'm sure you'll be glad to know.

00:17:19.940 --> 00:17:22.589
The rest of this gets slightly more technical.

00:17:22.589 --> 00:17:26.930
So, if you're not cool with lots of code on
screen, now is a good time to maybe check

00:17:26.930 --> 00:17:29.590
your e-mail, catch up on Twitter.

00:17:29.590 --> 00:17:34.540
That's okay, I won't be offended.

00:17:34.540 --> 00:17:35.540
That's cool.

00:17:35.540 --> 00:17:36.540
So you're all experts.

00:17:36.540 --> 00:17:39.280
I assume you already know the deadly sins
which I talked about last year.

00:17:39.280 --> 00:17:42.060
You need to make your apps fast and efficient
and intuitive.

00:17:42.060 --> 00:17:45.650
And they need to be beautiful and generous,
and you need to use widgets and all that good

00:17:45.650 --> 00:17:46.650
stuff.

00:17:46.650 --> 00:17:52.290
I've got a few new attributes, which are going
to help you transition from apps that people

00:17:52.290 --> 00:17:57.300
really like to apps that people love, that
they rave about and we want to use in Sandbox

00:17:57.300 --> 00:17:59.130
and have up on stage in keynotes.

00:17:59.130 --> 00:18:06.060
We've got four attributes, and I'll introduce
the first one now.

00:18:06.060 --> 00:18:08.760
Oh, wonderful.

00:18:08.760 --> 00:18:12.580
I should have pointed out earlier that I am
doing something of an experiment today by

00:18:12.580 --> 00:18:15.420
running my presentation off a tablet.

00:18:15.420 --> 00:18:24.080
And this is what happens when the tablet reboots
when it tries to play a video on HDMI, which

00:18:24.080 --> 00:18:27.270
has only happened once so far, not during
the rehearsal.

00:18:27.270 --> 00:18:40.160
So I'm going to have to dance while I wait
for this to reboot.

00:18:40.160 --> 00:18:41.250
It's a really nice video, too.

00:18:41.250 --> 00:18:47.320
I think you really would have appreciated
it.

00:18:47.320 --> 00:18:58.610
[ Laughter ]
Big question is do I try the video again after

00:18:58.610 --> 00:19:00.180
the device has loaded?

00:19:00.180 --> 00:19:01.400
Give it another shot?

00:19:01.400 --> 00:19:02.400
All right.

00:19:02.400 --> 00:19:05.790
There's four of these videos, so we've got
four additional chances after this for it

00:19:05.790 --> 00:19:07.930
all to go horribly wrong.

00:19:07.930 --> 00:19:17.830
Special shoutout to the hundreds of thousands
watching on the live stream.

00:19:17.830 --> 00:19:31.580
[ Laughter ]
We'll go through all of these once again.

00:19:31.580 --> 00:19:38.190
Consider this review, revision, if you didn't
see them properly the first time.

00:19:38.190 --> 00:19:48.410
It's good, because my session actually goes
for about 50 minutes.

00:19:48.410 --> 00:19:51.160
So this extra time is really helping me.

00:19:51.160 --> 00:19:54.950
Let's try one more time for the first attribute.

00:19:54.950 --> 00:19:56.580
Yes!

00:19:56.580 --> 00:20:04.740
That doesn't deserve a clap.

00:20:04.740 --> 00:20:08.010
That does.

00:20:08.010 --> 00:20:10.809
So thank you.

00:20:10.809 --> 00:20:15.330
[ Applause ]
With that slight delay, and quite appropriately,

00:20:15.330 --> 00:20:19.160
I'd like to introduce the concept of freshness.

00:20:19.160 --> 00:20:20.310
So what is a fresh app?

00:20:20.310 --> 00:20:23.670
A fresh app is one which is always up to date.

00:20:23.670 --> 00:20:27.110
It's an app which you don't have to wait for
things.

00:20:27.110 --> 00:20:30.330
You don't have to wait for the orientation
to update.

00:20:30.330 --> 00:20:34.150
You don't have to wait for the data to be
up to date.

00:20:34.150 --> 00:20:39.840
In fact, in a perfect world, there is no such
thing as an app being too fresh.

00:20:39.840 --> 00:20:45.270
Ideally, you're going to have an app which
knows exactly where you are and is going to

00:20:45.270 --> 00:20:50.330
have exactly the most current information
for you to see at any given time.

00:20:50.330 --> 00:20:55.580
Now, unfortunately, as we're all aware, battery
doesn't last forever.

00:20:55.580 --> 00:21:00.390
So a lot of the time what you're going to
have to do is find a compromise between apps

00:21:00.390 --> 00:21:04.670
being able to be as fresh as possible and
have a battery that lasts for longer than

00:21:04.670 --> 00:21:05.670
two hours.

00:21:05.670 --> 00:21:09.770
So what I wanted to introduce to you now is
a couple of techniques for being able to have

00:21:09.770 --> 00:21:13.770
a fresher app in terms of location and data.

00:21:13.770 --> 00:21:14.890
So let's start with location.

00:21:14.890 --> 00:21:19.710
One of the fancy new things which we introduced,
I think it was in Honeycomb, it may have been

00:21:19.710 --> 00:21:21.860
Gingerbread, is the passive location provider.

00:21:21.860 --> 00:21:24.370
How many of you guys have heard of the passive
location provider?

00:21:24.370 --> 00:21:25.950
A decent few, handful.

00:21:25.950 --> 00:21:33.220
For those of you who haven't, what this lets
do you is listen for updates in locations

00:21:33.220 --> 00:21:36.250
from other apps, and to have them within your
own apps.

00:21:36.250 --> 00:21:39.910
So if Google Maps is running in the foreground,
you are able to receive each of those location

00:21:39.910 --> 00:21:41.630
updates.

00:21:41.630 --> 00:21:45.950
Works exactly the same way as any other location
provider, so GPS or Wi-Fi.

00:21:45.950 --> 00:21:49.220
Specify the minimum distance, the minimum
time that you are allowed.

00:21:49.220 --> 00:21:53.110
Specify that as the provider, and then request
those location updates.

00:21:53.110 --> 00:21:57.880
Because you don't have control over what the
underlying provider is, your app still requires

00:21:57.880 --> 00:22:02.240
the find location permission, and then when
do you want to feigned out what the underlying

00:22:02.240 --> 00:22:07.660
provider was, you can simply call get provider
on the location object that gets passed into

00:22:07.660 --> 00:22:11.090
your location listener.

00:22:11.090 --> 00:22:14.010
Something which has actually been around for
quite a lot longer but hasn't received a lot

00:22:14.010 --> 00:22:19.410
of use is this idea of being able to use intents
to listen for location updates.

00:22:19.410 --> 00:22:24.660
So this is as an alternative to the location
listener, is you can actually specify a pending

00:22:24.660 --> 00:22:26.670
intent, and that's what we can see here.

00:22:26.670 --> 00:22:30.850
And the most important part here is the action
string, which we're going to broadcast.

00:22:30.850 --> 00:22:33.270
So we construct this pending intent.

00:22:33.270 --> 00:22:35.000
And then request those location updates.

00:22:35.000 --> 00:22:39.000
And instead of specifying a location listener,
we're going to specify the pending intent

00:22:39.000 --> 00:22:40.340
which is going to get broadcast.

00:22:40.340 --> 00:22:45.080
So now every time the provider which we have
specified receives an update, it's going to

00:22:45.080 --> 00:22:47.630
broadcast this intent.

00:22:47.630 --> 00:22:50.500
To listen for it works exactly as you'd expect.

00:22:50.500 --> 00:22:52.040
You register a new broadcast receiver.

00:22:52.040 --> 00:22:53.780
The implemenation, you can see there.

00:22:53.780 --> 00:22:59.360
The key part is you are extracting the current
location which is bundled in with the extras

00:22:59.360 --> 00:23:01.990
of that broadcast intent.

00:23:01.990 --> 00:23:09.590
Now, where things get really interesting is
if you use these in combination.

00:23:09.590 --> 00:23:14.540
So now what we can do is actually use intents
to update your location, even when your application

00:23:14.540 --> 00:23:15.540
isn't running.

00:23:15.540 --> 00:23:16.820
And how is that going to work?

00:23:16.820 --> 00:23:20.320
Well, we're broadcasting intents, which means
you can register a manifest receiver which

00:23:20.320 --> 00:23:21.830
is going to listen for those updates.

00:23:21.830 --> 00:23:26.120
So you will note here that the action we are
listening for is the same action we specified

00:23:26.120 --> 00:23:29.410
when creating our pending intent for those
location updates.

00:23:29.410 --> 00:23:34.870
If we specify the location provider as a passive
location provider, we have now got a circumstance

00:23:34.870 --> 00:23:40.250
where our app can sit in the background, not
even running at all, and then when we've specified

00:23:40.250 --> 00:23:45.270
hopefully a pretty conservative min time and
minimum distance for receiving those updates,

00:23:45.270 --> 00:23:50.120
our receiver is going to spin up and allow
us to do something with that information.

00:23:50.120 --> 00:23:56.421
So all of a sudden you are getting away from
the situation where every time you get to

00:23:56.421 --> 00:24:01.480
a location, so you have just used maps or
navigation to find your way to a venue, and

00:24:01.480 --> 00:24:06.590
then you have to wait 30 seconds while it
gets the GPS sync and then downloads the nearby

00:24:06.590 --> 00:24:09.120
locations or the ability to check in.

00:24:09.120 --> 00:24:14.280
So by using this instead, it gives you that
ability to have a much fresher location without

00:24:14.280 --> 00:24:21.690
any additional battery cost because you are
relying on someone else's use of the GPS.

00:24:21.690 --> 00:24:22.980
Let's take that one step further.

00:24:22.980 --> 00:24:27.140
So what we are really trying to do here is
to get fresher results in that circumstance

00:24:27.140 --> 00:24:29.780
when you first start up your app.

00:24:29.780 --> 00:24:32.720
So even without using the passive provider
of these location intents, there are a couple

00:24:32.720 --> 00:24:34.640
of techniques you can use.

00:24:34.640 --> 00:24:37.460
The first is simply to check what the last
known location was.

00:24:37.460 --> 00:24:42.580
And you will note that I parsed in false here
to get providers, and what this is saying

00:24:42.580 --> 00:24:48.870
is I don't care whether the particular provider
is active or not; just return all the providers.

00:24:48.870 --> 00:24:53.220
Because if someone has used navigation, gotten
to their destination and turned off GPS, that

00:24:53.220 --> 00:24:56.430
doesn't mean that last location received on
GPS isn't useful.

00:24:56.430 --> 00:25:01.470
So what we are going to do here is go through
each of the location providers and find out

00:25:01.470 --> 00:25:04.580
how accurate was your last reading and when
was it.

00:25:04.580 --> 00:25:09.690
If it was ten seconds ago, accurate within
the nearest ten meters, that's useful information.

00:25:09.690 --> 00:25:14.900
And that's probably a good enough value for
you to start pulling down the current data,

00:25:14.900 --> 00:25:20.240
without having to wait for your first GPS
location update.

00:25:20.240 --> 00:25:21.600
Another tip.

00:25:21.600 --> 00:25:23.880
Monitor the best provider available.

00:25:23.880 --> 00:25:25.330
Even if it isn't currently active.

00:25:25.330 --> 00:25:29.890
Users can turn on or off GPS or Wi-Fi with
a simple click of the button on the home screen

00:25:29.890 --> 00:25:34.410
so it's important when you are using criteria
to find the best possible provider that you

00:25:34.410 --> 00:25:38.040
check to see whether the better provider gets
turned on.

00:25:38.040 --> 00:25:45.460
And then you can do that transition seamlessly
without the user having to do anything.

00:25:45.460 --> 00:25:47.780
The other thing -- So that pretty much covers
location.

00:25:47.780 --> 00:25:49.210
So now we want to have a look at data.

00:25:49.210 --> 00:25:51.600
How do we get fresher data?

00:25:51.600 --> 00:25:56.480
Generally, when we are talking about data
updates in Android, we're talking about things

00:25:56.480 --> 00:25:57.730
happening in the background.

00:25:57.730 --> 00:26:04.500
So how frequently do you wake up your app
and have it pull down new data from the server.

00:26:04.500 --> 00:26:09.040
Well, generally, again, this is a compromise
between how frequently you want to do it and

00:26:09.040 --> 00:26:11.720
how frequently you want the battery to run
down.

00:26:11.720 --> 00:26:16.140
So what I'm suggesting here is rather than
doing that as a one-off, you actually make

00:26:16.140 --> 00:26:19.040
that variable based on a number of conditions.

00:26:19.040 --> 00:26:20.690
We can start off really simply.

00:26:20.690 --> 00:26:24.380
So if we're talking about recurring alarms,
you actually have two options.

00:26:24.380 --> 00:26:26.800
It can be a wakeup alarm or a nonwakeup alarm.

00:26:26.800 --> 00:26:32.260
A wake alarm is going to spin up the device
even if it's in spanned by mode just so you

00:26:32.260 --> 00:26:33.270
can do what you need to do.

00:26:33.270 --> 00:26:37.450
So this is a great way of making sure your
app is up-to-date but it does have an impact

00:26:37.450 --> 00:26:39.020
on your battery life.

00:26:39.020 --> 00:26:43.360
A nonwaking alarm is still going to get triggered,
but it's not going to wake the device out

00:26:43.360 --> 00:26:46.060
of standby until it's out of standby itself.

00:26:46.060 --> 00:26:49.570
So if you say every 30 minutes and the user
doesn't turn their phone on for an hour, that's

00:26:49.570 --> 00:26:52.320
when it will get triggered straight away.

00:26:52.320 --> 00:26:56.000
So rather than trying to come up with a compromise
between which of these approaches to use,

00:26:56.000 --> 00:26:57.290
why not use both?

00:26:57.290 --> 00:27:02.390
Here we are going to specify a best-case scenario
where we are saying ideally we want to update

00:27:02.390 --> 00:27:06.220
every 30 minutes, but if the device is on
standby, they are not using it anyway, we

00:27:06.220 --> 00:27:09.150
can probably get by with updating only twice
day.

00:27:09.150 --> 00:27:11.790
And then just set both of those alarms.

00:27:11.790 --> 00:27:17.580
I assume you are all using inexact repeating
but this is an instance where you can improve

00:27:17.580 --> 00:27:22.590
both freshness by having those nonwaking alarms
happening more frequently and the battery

00:27:22.590 --> 00:27:26.620
life by pulling back on the wake alarms.

00:27:26.620 --> 00:27:29.170
Now, that's a fairly straightforward approach.

00:27:29.170 --> 00:27:33.280
What you can do, which is a little bit more
interesting is actually vary those particulars

00:27:33.280 --> 00:27:37.310
values, the best case and worst case scenario
based on the device state.

00:27:37.310 --> 00:27:42.020
Things like connectivity, whether the device
is docked, whether it's charging or the battery

00:27:42.020 --> 00:27:43.020
is low.

00:27:43.020 --> 00:27:46.670
All of these things should have an impact
on how frequently you want these alarms to

00:27:46.670 --> 00:27:48.170
go off.

00:27:48.170 --> 00:27:50.960
Let's have a look at each of them in sequence.

00:27:50.960 --> 00:27:55.220
If we look at the connectivity, using the
connectivity manager we can check a couple

00:27:55.220 --> 00:27:56.220
of things.

00:27:56.220 --> 00:27:59.250
We can check to see whether we are connected
to the Internet at all.

00:27:59.250 --> 00:28:03.670
If we're not connected to the Internet, you
can probably disable all of your refreshing

00:28:03.670 --> 00:28:04.670
alarms.

00:28:04.670 --> 00:28:07.020
Certainly the ones which are going to pull
data from the cloud.

00:28:07.020 --> 00:28:10.720
If you don't have an Internet connection,
there's no point starting up the service running

00:28:10.720 --> 00:28:15.220
the receivers so just disable it completely
until you get that connectivity back.

00:28:15.220 --> 00:28:19.130
We can also check to see what kind of connection
we have.

00:28:19.130 --> 00:28:22.450
If we're connected via Wi-Fi, we can probably
crank in number up.

00:28:22.450 --> 00:28:27.970
It's cheaper, it's faster to get those updates,
whereas if we are on 2G mobile, again we probably

00:28:27.970 --> 00:28:29.450
want to scale back.

00:28:29.450 --> 00:28:32.430
We're talking about battery.

00:28:32.430 --> 00:28:34.200
Let's have a look at the battery monitor.

00:28:34.200 --> 00:28:38.340
So the way the battery manager works, it will
actually transmit a sticky broadcast, which

00:28:38.340 --> 00:28:40.700
means we can co-register a receiver.

00:28:40.700 --> 00:28:44.740
And even passing in a null receiver as we
have done here, we are still able to get the

00:28:44.740 --> 00:28:48.370
last battery status which was broadcast.

00:28:48.370 --> 00:28:54.840
In this instance all I am looking at is whether
the battery is being charged or it's full.

00:28:54.840 --> 00:28:59.130
If the battery is being charged there is no
battery implication from doing your updates

00:28:59.130 --> 00:29:00.570
more frequently.

00:29:00.570 --> 00:29:06.450
So in that case you can make your worst case
scenario, your waking alarm, be equal to your

00:29:06.450 --> 00:29:07.450
best-case scenario.

00:29:07.450 --> 00:29:10.990
So you are going to wake the device every
30 minutes and get that update because you

00:29:10.990 --> 00:29:14.290
don't have to worry about running the battery
down.

00:29:14.290 --> 00:29:16.140
Docking state works the pretty much the same
way.

00:29:16.140 --> 00:29:20.380
Here we are just checking to see whether the
device is docked or undocked.

00:29:20.380 --> 00:29:23.860
You can also check to see whether it's in
a car dock, a desk dock, if it's digital or

00:29:23.860 --> 00:29:25.990
an analog dock.

00:29:25.990 --> 00:29:30.110
All these things are going to potentially
affect how frequently you do your updates.

00:29:30.110 --> 00:29:34.549
And how you affect it will be entirely based
on your data.

00:29:34.549 --> 00:29:38.910
So if what you are doing is checking road
conditions, then if it's in a car dock, you

00:29:38.910 --> 00:29:43.371
probably want to do those updates pretty frequently,
whereas if it's in a desk dock, you may want

00:29:43.371 --> 00:29:44.690
to slow them right down.

00:29:44.690 --> 00:29:50.910
So again, it's a case of use the information
in a way that makes sense with your data.

00:29:50.910 --> 00:29:52.180
And ultimately, that's what you want to do.

00:29:52.180 --> 00:29:54.360
You want to take all these things into account.

00:29:54.360 --> 00:29:58.140
We are on Wi-Fi, we are being charged, we
are in a desk dock.

00:29:58.140 --> 00:30:02.480
If what my app does is check sports scores,
maybe during the game it makes sense to have

00:30:02.480 --> 00:30:04.500
update every two minutes.

00:30:04.500 --> 00:30:11.430
The same app in a car dock on a 2G mobile
network, which is actually decreasing in charge,

00:30:11.430 --> 00:30:15.570
you probably want to disable that or at least
make it a lot less frequently.

00:30:15.570 --> 00:30:20.360
The thing about device state is it is obviously
very dynamic.

00:30:20.360 --> 00:30:21.600
So I have listed these all together.

00:30:21.600 --> 00:30:25.590
They should obviously be separate intent filters
but effectively what we are saying you can

00:30:25.590 --> 00:30:28.520
monitor to say has the dock being state changed.

00:30:28.520 --> 00:30:32.680
You can't monitor the battery level in real
time but you can check to see whether you

00:30:32.680 --> 00:30:37.160
are at a low battery state or whether the
device has been connected or disconnected

00:30:37.160 --> 00:30:38.160
from power.

00:30:38.160 --> 00:30:42.830
So this is a really important way that you
can modify how your app is behaving.

00:30:42.830 --> 00:30:46.480
And probably the most important is the connectivity
change.

00:30:46.480 --> 00:30:50.620
So check, if we lose Internet connection,
then disable all of your recurring alarms

00:30:50.620 --> 00:30:52.900
and turn off a lot of your intent receivers.

00:30:52.900 --> 00:30:55.490
You can also use this to put things off.

00:30:55.490 --> 00:30:57.520
We have a 100 meg file we want to download.

00:30:57.520 --> 00:31:02.590
We don't want to do that in 2G or 3G, so we
are going to set an alarm that says when you

00:31:02.590 --> 00:31:05.170
have Wi-Fi connection, initiate that download.

00:31:05.170 --> 00:31:10.540
So I said something there that you could enable
and disable your receivers.

00:31:10.540 --> 00:31:13.650
That's actually something you can do even
from manifest receivers.

00:31:13.650 --> 00:31:18.790
So within code at run time, you can actually
use the package manager, find out what is

00:31:18.790 --> 00:31:24.470
the component name of your receiver class,
and then we're just going to enable or disable

00:31:24.470 --> 00:31:26.540
it based on the conditions.

00:31:26.540 --> 00:31:30.870
So for that connectivity example, you are
going to say, okay, when the connectivity

00:31:30.870 --> 00:31:36.700
changes, if we have no active network, then
disable all of my state-change receivers because

00:31:36.700 --> 00:31:40.930
there's no point running up my app if there's
nothing for it to do.

00:31:40.930 --> 00:31:44.680
So be a good system citizen and disable all
of those things when they are not going to

00:31:44.680 --> 00:31:47.140
be useful.

00:31:47.140 --> 00:31:50.600
Most of these receivers, they are going to
trigger services to actually do the work of

00:31:50.600 --> 00:31:52.240
pulling down the downloads.

00:31:52.240 --> 00:31:53.891
Key here is everything needs to be done asynchronously.

00:31:53.891 --> 00:32:00.100
I am going to already assume that your services
are asynchronous, that they are going to be

00:32:00.100 --> 00:32:02.780
short-lived, they are going to be well behaved.

00:32:02.780 --> 00:32:06.220
One of the things I wanted to highlight is
the ability to change the way that the onstart

00:32:06.220 --> 00:32:08.450
command return result works.

00:32:08.450 --> 00:32:12.560
So hopefully a lot of you already know you
can either return start sticky, which is going

00:32:12.560 --> 00:32:17.970
to cause the system to keep restarting the
service should it need to kill it in order

00:32:17.970 --> 00:32:22.920
to get some additional resources, and not
sticky is going to say if the system kills

00:32:22.920 --> 00:32:26.600
it to regain memory right now, let it stay
dead.

00:32:26.600 --> 00:32:30.890
What the little piece of code underneath does
is we're just going to have a look to say

00:32:30.890 --> 00:32:32.610
when was the last time that it was successful?

00:32:32.610 --> 00:32:36.830
How many times have we tried to run up this
service only for the system to kill it?

00:32:36.830 --> 00:32:39.330
And what that lets us do is make this variable.

00:32:39.330 --> 00:32:44.870
So we say if it's been longer than what we
consider to be an allowable period since it

00:32:44.870 --> 00:32:49.650
last worked, force the system to make this
sticky, and otherwise let it die.

00:32:49.650 --> 00:32:56.340
So it's a really easy way to make this dynamic
rather than a one-off compromise.

00:32:56.340 --> 00:33:02.330
So that brings us to our next video, so please
cross your fingers.

00:33:02.330 --> 00:33:10.330
[ Making noises ]
&gt;&gt;Reto Meier: So let's talk about how to make

00:33:10.330 --> 00:33:12.810
your apps psychic.

00:33:12.810 --> 00:33:13.810
What's a psychic app?

00:33:13.810 --> 00:33:18.160
A psychic app knows things without you having
to explicitly tell it.

00:33:18.160 --> 00:33:19.240
It's like a stage magician.

00:33:19.240 --> 00:33:24.180
It just seems to know things which you probably
told it at some point, but you didn't realize

00:33:24.180 --> 00:33:25.710
it would be usable in this circumstance.

00:33:25.710 --> 00:33:27.670
And it's the same thing with forgetting things.

00:33:27.670 --> 00:33:29.130
It never forgets anything.

00:33:29.130 --> 00:33:32.530
What does that mean in practice?

00:33:32.530 --> 00:33:36.920
Before I get into that, I want to point out
that a psychic app has a potential of being

00:33:36.920 --> 00:33:39.390
a very creepy app.

00:33:39.390 --> 00:33:44.440
It's very important if you are using this
information to be very aware of how this impacts

00:33:44.440 --> 00:33:45.860
user privacy.

00:33:45.860 --> 00:33:48.470
You don't want them to go, "How did you know
that?"

00:33:48.470 --> 00:33:50.500
You want them to be like, "Oh, great.

00:33:50.500 --> 00:33:51.500
That's excellent.

00:33:51.500 --> 00:33:53.950
I don't need to complete this again."

00:33:53.950 --> 00:33:57.040
So it's really important to make sure users
understand where the data is coming from and

00:33:57.040 --> 00:33:59.270
how it's getting used.

00:33:59.270 --> 00:34:02.590
So one of the ways you can do that is using
the account manager.

00:34:02.590 --> 00:34:06.990
That already has the login names and e-mail
addresses people have used to login accounts

00:34:06.990 --> 00:34:07.990
on the phone.

00:34:07.990 --> 00:34:10.290
This is really useful information.

00:34:10.290 --> 00:34:13.700
You can actually go through and extract each
of these account names.

00:34:13.700 --> 00:34:19.659
Now, to do that, you do need to have the get
accounts permission so the user will be asked

00:34:19.659 --> 00:34:23.840
are you willing to let this app get permission
to your account data.

00:34:23.840 --> 00:34:28.920
Now, this is a good example where you need
to consider what the payoffs are.

00:34:28.920 --> 00:34:32.780
Is it going to make sense or are they going
to say "know understand why a wallpaper app

00:34:32.780 --> 00:34:35.800
needs to see my account permissions."

00:34:35.800 --> 00:34:36.800
Be conscious of that.

00:34:36.800 --> 00:34:38.399
Make sure it makes sense in your instance.

00:34:38.399 --> 00:34:42.510
Tweetdeck is a great example of an app which
does this really, really well, to suggest

00:34:42.510 --> 00:34:47.630
the user names for each of the services which
you can sign in, Twitter, four square, Facebook,

00:34:47.630 --> 00:34:49.440
et cetera, and Tweetdeck itself.

00:34:49.440 --> 00:34:52.879
It suggests them all as auto completions when
you are putting in your data.

00:34:52.879 --> 00:34:57.460
It makes it easier, it makes sense in that
instance.

00:34:57.460 --> 00:35:00.400
We talked about never forgetting anything.

00:35:00.400 --> 00:35:02.090
So this is across the board.

00:35:02.090 --> 00:35:06.770
If you have got a native app which has an
equivalent Web app, make sure those preferences

00:35:06.770 --> 00:35:08.350
are synced.

00:35:08.350 --> 00:35:10.230
They shouldn't have to put in the same data
again.

00:35:10.230 --> 00:35:11.240
You already know who they are.

00:35:11.240 --> 00:35:13.040
They have given you that information once.

00:35:13.040 --> 00:35:16.370
It should be synced across those devices.

00:35:16.370 --> 00:35:19.910
If users aren't logged in, well, we already
talked earlier in the day about how to create

00:35:19.910 --> 00:35:24.330
a universal unique identifier so you can track
an installation anonymously, so you are still

00:35:24.330 --> 00:35:26.700
able to back up that information on your server.

00:35:26.700 --> 00:35:30.280
And then when the user does create a login,
that shouldn't wipe their preferences.

00:35:30.280 --> 00:35:35.640
It should all sync together so that their
phone-based preferences are now applied to

00:35:35.640 --> 00:35:39.630
their new Web-based account.

00:35:39.630 --> 00:35:43.770
So what happens, though, if you'd like to
back up this information but you don't have

00:35:43.770 --> 00:35:45.240
a server to back up with?

00:35:45.240 --> 00:35:48.010
Well, you can actually use one which we prepared
earlier.

00:35:48.010 --> 00:35:53.130
So using the backup manager, you can back
up shared preferences to our cloud-based backup

00:35:53.130 --> 00:35:54.130
service.

00:35:54.130 --> 00:35:55.640
So this is all entirely opt in.

00:35:55.640 --> 00:35:59.750
You note when you opt into your device it
asks do you want to backup your information.

00:35:59.750 --> 00:36:04.520
If you say yes it will remember what apps
you downloaded and it will redownload for

00:36:04.520 --> 00:36:06.180
them if you wipe your device.

00:36:06.180 --> 00:36:10.610
In some cases if you get a new device, it
will download those apps automatically which

00:36:10.610 --> 00:36:12.630
is really handy.

00:36:12.630 --> 00:36:16.410
So using the Android backup service, you are
able to persist additional information into

00:36:16.410 --> 00:36:21.160
the cloud as well, so that when they back
up their apps, you are also backing up your

00:36:21.160 --> 00:36:22.890
application data alongside it.

00:36:22.890 --> 00:36:27.370
So if the device does get wiped, you are able
to not only get your apps back but the preferences

00:36:27.370 --> 00:36:29.550
for all of those apps as well.

00:36:29.550 --> 00:36:30.780
Really handy.

00:36:30.780 --> 00:36:33.030
Now, you might remember -- Sorry.

00:36:33.030 --> 00:36:37.190
Before I go on, I should say this is how it
actually works.

00:36:37.190 --> 00:36:41.950
So for shared preferences in particular, we've
made this as simple as possible.

00:36:41.950 --> 00:36:45.970
So you can see we are creating a backup agent
helper, and within on create, which is this

00:36:45.970 --> 00:36:49.550
bit here, we are creating a new shared preferences
backup helper.

00:36:49.550 --> 00:36:50.930
This is really straightforward.

00:36:50.930 --> 00:36:56.060
We're specifying the name of the shared preferences
file, which we have defined at the top here,

00:36:56.060 --> 00:37:00.970
that's just user preferences, and we are adding
a helper for each of the keys you want to

00:37:00.970 --> 00:37:01.970
back up.

00:37:01.970 --> 00:37:06.800
In this instance, you probably don't want
to be persisting instance information, like

00:37:06.800 --> 00:37:07.800
application state.

00:37:07.800 --> 00:37:11.810
You want to be persisting only user preferences,
and so this is how you can define exactly

00:37:11.810 --> 00:37:15.950
which of those keys within the shared preference
file you want to back up.

00:37:15.950 --> 00:37:21.290
To make that work, you need to add a new attribute
to your application node specifying your backup

00:37:21.290 --> 00:37:25.770
agent and you need to also have a meta data
tag which has your API key for the backup

00:37:25.770 --> 00:37:29.060
service.

00:37:29.060 --> 00:37:34.310
So as I was saying earlier, you saw how we
create this universal unique ID.

00:37:34.310 --> 00:37:38.720
We actually did all of that by storing it
as a shared preference.

00:37:38.720 --> 00:37:42.850
So what that means is that now you can use
this in combination with a backup manager

00:37:42.850 --> 00:37:48.390
to persist that installation identifier, if
the user has opted in, so that if the device

00:37:48.390 --> 00:37:53.380
gets wiped, they get their preferences back,
and they get their universally unique identifier

00:37:53.380 --> 00:37:54.380
back.

00:37:54.380 --> 00:37:58.070
So any preferences that you have saved on
your server side are going to be consistent

00:37:58.070 --> 00:38:00.850
on this new device or after it's been flashed.

00:38:00.850 --> 00:38:05.240
It's very easy for user to opt out or to clear
their data so there's limit privacy concerns

00:38:05.240 --> 00:38:09.270
but again, you want to be aware of what you
are storing on the server and how that's going

00:38:09.270 --> 00:38:12.350
to be identifiable to users.

00:38:12.350 --> 00:38:19.180
The last psychic tip is something which has
existed since the very beginning but a disappointingly

00:38:19.180 --> 00:38:23.920
large number of people haven't been taking
advantage of can and that's intercepting links

00:38:23.920 --> 00:38:26.070
to content.

00:38:26.070 --> 00:38:27.070
So you have seen this before.

00:38:27.070 --> 00:38:28.070
Google Maps, YouTube.

00:38:28.070 --> 00:38:32.750
You follow a link, it asks you do you want
to view this in the native app or use the

00:38:32.750 --> 00:38:33.750
browser?

00:38:33.750 --> 00:38:38.700
You can do exactly the same thing and it's
as simple as adding this data node or data

00:38:38.700 --> 00:38:44.170
attribute within the intent filter node of
the activity which is able to handle that

00:38:44.170 --> 00:38:45.170
content.

00:38:45.170 --> 00:38:48.720
So here I am specifying a particular Web site
with a prefix to a path.

00:38:48.720 --> 00:38:52.500
Every time someone clicks on that link it's
going to ask if I would like to use my activity

00:38:52.500 --> 00:38:53.830
to view it.

00:38:53.830 --> 00:38:58.990
If you have built a native app and it's not
the best way to view your content, then I've

00:38:58.990 --> 00:39:03.140
got some pretty serious questions about why
you bothered to build a native app to begin

00:39:03.140 --> 00:39:04.140
with.

00:39:04.140 --> 00:39:05.140
All right?

00:39:05.140 --> 00:39:07.710
So make sure that it is the best way to view
your content, and then make it available to

00:39:07.710 --> 00:39:08.860
your users.

00:39:08.860 --> 00:39:10.430
All right.

00:39:10.430 --> 00:39:11.990
Next video.

00:39:11.990 --> 00:39:16.410
[ Making noises ]
[ Laughter ]

00:39:16.410 --> 00:39:26.540
&gt;&gt;Reto Meier: I want to talk about making
your apps adaptive.

00:39:26.540 --> 00:39:27.970
So what's an adaptive app?

00:39:27.970 --> 00:39:31.500
Well, it's one which doesn't stick out in
ways that you don't want it to; right?

00:39:31.500 --> 00:39:33.170
It should be invisible to the user.

00:39:33.170 --> 00:39:36.680
Now, I'm not saying you shouldn't have an
app which stands out.

00:39:36.680 --> 00:39:37.680
It should.

00:39:37.680 --> 00:39:39.780
You should create something unique and interesting
and innovative.

00:39:39.780 --> 00:39:45.530
But all the things which you take for granted
text input, audio behavior, all of those things

00:39:45.530 --> 00:39:49.230
should just happen the way users expect them
to happen.

00:39:49.230 --> 00:39:50.940
And that's what being adaptive is all about.

00:39:50.940 --> 00:39:56.390
So let's start off by looking at one of the
most simple things, and that's text input.

00:39:56.390 --> 00:40:01.250
Make sure that the right keyboard comes up
when the user is putting things into the edit

00:40:01.250 --> 00:40:02.250
text.

00:40:02.250 --> 00:40:03.790
So you have a number of options.

00:40:03.790 --> 00:40:08.250
It can be plain text, it can be a number,
it can be a phone number, it can be a date

00:40:08.250 --> 00:40:09.250
or time.

00:40:09.250 --> 00:40:13.860
And each of these are going to have different
ideal ways of putting in data.

00:40:13.860 --> 00:40:18.150
The way you specify that is simply by setting
the input type within each of your edit text

00:40:18.150 --> 00:40:21.100
so they show the right kind of input.

00:40:21.100 --> 00:40:22.390
So in this case we are putting phone.

00:40:22.390 --> 00:40:26.510
That's going to show you the traditional phone
dialer, because that's going to be the easiest

00:40:26.510 --> 00:40:27.800
way to input phone information.

00:40:27.800 --> 00:40:30.480
So this is all handled by the IME.

00:40:30.480 --> 00:40:33.250
You just need to tell it what kind of input
you want.

00:40:33.250 --> 00:40:40.920
In the case of text input, you have the option
of URIs, email addresses, people's names.

00:40:40.920 --> 00:40:44.430
This is going to change not only what's available
on the keyboard, but the kind of entry.

00:40:44.430 --> 00:40:50.140
For people's names, you want auto correction
only to come from the contact page and you

00:40:50.140 --> 00:40:51.870
want to have each word capitalized.

00:40:51.870 --> 00:40:54.570
All of this stuff is going to be variable.

00:40:54.570 --> 00:40:59.670
You're going to be able to specify that by
specifying what kind of text you want to use.

00:40:59.670 --> 00:41:04.680
Here we are's specifying e-mail and URI.

00:41:04.680 --> 00:41:08.140
At the bottom left of your keyboard, sometimes
you see a little .com symbol or a little @ symbol

00:41:08.140 --> 00:41:12.920
to make it more easy to type in a Web address
or an email address, and that is the attribute

00:41:12.920 --> 00:41:18.030
which is controlling that.

00:41:18.030 --> 00:41:21.570
When you are doing text input, you can actually
add another level of flags which are going

00:41:21.570 --> 00:41:24.470
to have a much greater level of customization.

00:41:24.470 --> 00:41:28.680
You can control capitalization, auto correction,
and multiline input.

00:41:28.680 --> 00:41:31.270
And, in fact, in this example, that's exactly
what we're doing.

00:41:31.270 --> 00:41:35.850
We're specifying that we want auto correction
turned on, capitalize the sentences, and we

00:41:35.850 --> 00:41:38.020
want to support multiline input.

00:41:38.020 --> 00:41:41.810
You know we've actually specified the maximum
length of the string and the maximum number

00:41:41.810 --> 00:41:45.100
of lines as well.

00:41:45.100 --> 00:41:48.119
The other thing you can do with the keyboard
is actually specify an action which should

00:41:48.119 --> 00:41:51.720
be initiated by the user when they're entering
text.

00:41:51.720 --> 00:41:54.990
And so this is something you'll see in the
bottom right of the keyboard.

00:41:54.990 --> 00:41:57.750
If it's multiline text, it's the enter key.

00:41:57.750 --> 00:42:02.780
Otherwise, it's going to be either the "done"
or next -- it's going to say "done" or "next"

00:42:02.780 --> 00:42:06.250
depending whether there's another field for
the user to move on to next.

00:42:06.250 --> 00:42:08.790
I want to think about specifying that explicitly.

00:42:08.790 --> 00:42:13.750
If you have a browser or an instant messaging
client or Twitter client, it will make more

00:42:13.750 --> 00:42:15.230
sense to say "send?"

00:42:15.230 --> 00:42:18.560
So the user doesn't have to close the action
and then initiate the action.

00:42:18.560 --> 00:42:24.300
He can do it all within the keyboard display.

00:42:24.300 --> 00:42:25.300
So this is how you do that.

00:42:25.300 --> 00:42:29.660
So you set the IME rather than the input type,
and you can see here we specified the send

00:42:29.660 --> 00:42:30.660
action.

00:42:30.660 --> 00:42:34.680
In this case, we've actually said if we do
have a hardware keyboard, something which

00:42:34.680 --> 00:42:39.270
has a solid enter key, I don't want that to
represent send, because something like that

00:42:39.270 --> 00:42:43.270
you probably want the user to explicitly hit
the button rather than just pressing "enter."

00:42:43.270 --> 00:42:46.870
This is something that you can control and
you should control, so that it makes sense,

00:42:46.870 --> 00:42:50.690
given your context.

00:42:50.690 --> 00:42:54.320
If you are doing that sort of thing, obviously,
you need to then listen for those button clicks

00:42:54.320 --> 00:42:58.110
so that it actually does something when the
user presses the action.

00:42:58.110 --> 00:42:59.110
That's what we're looking at here.

00:42:59.110 --> 00:43:03.170
We're simply going to create a new editor
action listener, listen for a particular key

00:43:03.170 --> 00:43:12.580
press and then do something accordingly, straightforward.

00:43:12.580 --> 00:43:13.770
The next thing, that's your keyboard.

00:43:13.770 --> 00:43:16.490
Your keyboard's pimped out, doing everything
it should be.

00:43:16.490 --> 00:43:21.270
The next thing I wanted to talk about is to
have a look at how you can handle audio.

00:43:21.270 --> 00:43:25.520
So there's a number of different ways that
audio is going to be impacted by your app.

00:43:25.520 --> 00:43:29.400
You're going to have volume control, you're
going to have playback buttons on Bluetooth

00:43:29.400 --> 00:43:30.750
and wide keyboards.

00:43:30.750 --> 00:43:32.150
And you're going to have audio focus.

00:43:32.150 --> 00:43:33.760
So there's background apps.

00:43:33.760 --> 00:43:36.050
Multiple media players can all be playing
at once.

00:43:36.050 --> 00:43:39.740
How do you decide which is playing, which
is listening to those playback buttons, and

00:43:39.740 --> 00:43:42.410
whose volume is getting controlled.

00:43:42.410 --> 00:43:43.890
Volume control is actually really simple.

00:43:43.890 --> 00:43:48.410
On Android by default, the volume keys are
going to control whatever media stream is

00:43:48.410 --> 00:43:49.410
playing.

00:43:49.410 --> 00:43:53.100
So if you've got a game or a media player
and it's not playing audio, it's going to

00:43:53.100 --> 00:43:54.910
default back to the ringer.

00:43:54.910 --> 00:43:58.290
So in most cases, what you want to do is call
this within your oncreate.

00:43:58.290 --> 00:44:03.880
And that's going to assure that every time
you hit the video controls -- I should say

00:44:03.880 --> 00:44:07.020
every time you hit the volume controls, it's
going to adjust the stream, the music stream

00:44:07.020 --> 00:44:08.080
volume.

00:44:08.080 --> 00:44:14.520
A real easy way to produce something which
is much more intuitive to use is media buttons

00:44:14.520 --> 00:44:15.850
are a little bit more complicated.

00:44:15.850 --> 00:44:19.920
It's all intent-based so you want to specify
a manifest receiver that says I'm interested

00:44:19.920 --> 00:44:22.619
in listening for media buttons.

00:44:22.619 --> 00:44:24.350
Create your broadcast receiver.

00:44:24.350 --> 00:44:25.350
And then simply listen.

00:44:25.350 --> 00:44:26.740
And that's the red highlighted text.

00:44:26.740 --> 00:44:29.210
We're looking at what button got pressed.

00:44:29.210 --> 00:44:33.100
So play, stop, pause, skip, et cetera.

00:44:33.100 --> 00:44:36.850
We mentioned that there are a number of devices
which could potentially be listening for these

00:44:36.850 --> 00:44:38.720
media button clicks.

00:44:38.720 --> 00:44:44.160
So using this code, you're able to then say,
okay, now is when I want to actually listen

00:44:44.160 --> 00:44:47.110
for those play button clicks or stop button
clicks.

00:44:47.110 --> 00:44:53.530
Now, naively, you could put these in the unresume
or unpause methods of your activities.

00:44:53.530 --> 00:44:54.940
That's probably not what you want.

00:44:54.940 --> 00:44:58.610
You still want to be listening to those even
if your app is in the background.

00:44:58.610 --> 00:45:03.170
You only want to stop listening to them if
another app is doing the play back.

00:45:03.170 --> 00:45:06.730
The way to handle that is by listening for
audio focus changes.

00:45:06.730 --> 00:45:12.030
As soon as you want your app to be the main
application playing back audio, you request

00:45:12.030 --> 00:45:13.030
the audio focus.

00:45:13.030 --> 00:45:16.050
You specify the stream which you're using
to play back that audio.

00:45:16.050 --> 00:45:20.300
Music is going to be almost always what you
are specifying.

00:45:20.300 --> 00:45:24.130
And here we're saying that we want to take
control of the audio permanently.

00:45:24.130 --> 00:45:27.540
As an alternative, we can actually say we
only want to do it transiently.

00:45:27.540 --> 00:45:32.350
Take control for a brief instance, play some
music, and then return control back.

00:45:32.350 --> 00:45:37.190
In that case, the listening app is going to
want to continue to listen to the play, stop,

00:45:37.190 --> 00:45:39.660
you know, pause buttons.

00:45:39.660 --> 00:45:43.580
When we've finished play back, we abandon
audio focus which tells the system somebody

00:45:43.580 --> 00:45:46.650
else is in charge of playing back audio.

00:45:46.650 --> 00:45:49.910
Flip side of that is the change listener.

00:45:49.910 --> 00:45:53.640
This is how you listen to find out when another
app has taken control.

00:45:53.640 --> 00:45:58.340
If your app is playing back music, someone
launches something else, they hit play, your

00:45:58.340 --> 00:46:01.810
app should stop play back and should stop
listening for the media button controls because

00:46:01.810 --> 00:46:04.410
someone else is doing it now.

00:46:04.410 --> 00:46:08.280
The most basic case is audio focus loss, which
is this one here.

00:46:08.280 --> 00:46:13.800
This corresponds to the audio focus gain call
when someone is requesting audio focus.

00:46:13.800 --> 00:46:16.100
There's two additional variations.

00:46:16.100 --> 00:46:17.780
And that's highlighted here.

00:46:17.780 --> 00:46:22.500
You can then -- the calling app can actually
say, look, it's only going to be transient.

00:46:22.500 --> 00:46:24.270
I'm just going to play something back very
briefly.

00:46:24.270 --> 00:46:26.790
I want you to continue to have focus after
that.

00:46:26.790 --> 00:46:30.050
So in that instance, you probably want to
hit "pause."

00:46:30.050 --> 00:46:34.730
As an alternative, say, for example, if you
are listening to an app which is giving you

00:46:34.730 --> 00:46:39.140
turn-by-turn navigation, saying I want to
turn left in 50 meters, you want to hear that

00:46:39.140 --> 00:46:42.119
but don't necessarily want to pause play back
of music.

00:46:42.119 --> 00:46:44.310
You want to lower volume.

00:46:44.310 --> 00:46:48.130
That's called ducking.

00:46:48.130 --> 00:46:50.870
You can say it's transient and duck.

00:46:50.870 --> 00:46:53.210
So rather than pausing, just lower the volume.

00:46:53.210 --> 00:46:58.260
That's what we're listening for here.

00:46:58.260 --> 00:47:03.590
Really simple tip for adaptive apps which
is a really easy one, and surprisingly few

00:47:03.590 --> 00:47:07.810
people do it, is providing translations for
your app title and descriptions in the Android

00:47:07.810 --> 00:47:08.810
Market.

00:47:08.810 --> 00:47:10.500
This is a really simple one.

00:47:10.500 --> 00:47:13.950
You're probably thinking, it's okay, a lot
of Android users, they're bilingual, they're

00:47:13.950 --> 00:47:15.090
quite happy to use my app.

00:47:15.090 --> 00:47:16.130
It's not that much text, anyway.

00:47:16.130 --> 00:47:17.130
It's a game.

00:47:17.130 --> 00:47:18.130
It's fine.

00:47:18.130 --> 00:47:19.160
That's probably true.

00:47:19.160 --> 00:47:22.690
But when they're searching for your app in
the Android Market, there's a very good chance

00:47:22.690 --> 00:47:25.100
they'll be using their native language.

00:47:25.100 --> 00:47:28.500
So rather than having to do your entire app,
which you should still do, you can start by

00:47:28.500 --> 00:47:32.790
simply giving a really good, accurate translation
for your title and description.

00:47:32.790 --> 00:47:37.980
Make it that much more discoverable for users
who aren't native English speakers.

00:47:37.980 --> 00:47:43.790
In the few minutes remaining, the last section,
last video.

00:47:43.790 --> 00:47:46.620
[ Video.

00:47:46.620 --> 00:47:55.920
]
&gt;&gt;Reto Meier: It's about making your apps

00:47:55.920 --> 00:47:56.920
smooth.

00:47:56.920 --> 00:47:58.190
So what do we mean by smooth?

00:47:58.190 --> 00:47:59.190
All right.

00:47:59.190 --> 00:48:01.060
So a smooth app is exactly that.

00:48:01.060 --> 00:48:02.670
Everything feels like it's running on rails.

00:48:02.670 --> 00:48:07.300
It's a lot of the stuff that Chet and Romain
were talking about in the previous system.

00:48:07.300 --> 00:48:11.680
It's about using animations, making things
fast and efficient.

00:48:11.680 --> 00:48:14.710
You should never have to pause for anything.

00:48:14.710 --> 00:48:20.060
A key to that is really making everything
asynchronous, really with no exceptions.

00:48:20.060 --> 00:48:21.060
Why is that?

00:48:21.060 --> 00:48:24.960
If it's not interacting with the UI thread,
it shouldn't be happening on the UI thread

00:48:24.960 --> 00:48:28.220
or the main application thread, as it's otherwise
known.

00:48:28.220 --> 00:48:33.730
A 16-millisecond delay can cause a jatter
on a 60-frame-per-second animation, and that

00:48:33.730 --> 00:48:37.840
jatter is going to make a user think that
things aren't working the way that they should.

00:48:37.840 --> 00:48:41.150
So it's really important that you make your
apps as efficient as possible and put things

00:48:41.150 --> 00:48:44.150
in the background as much as you can.

00:48:44.150 --> 00:48:48.030
Now, as experts, I'm sure that a lot of these
classes are already quite familiar to you

00:48:48.030 --> 00:48:49.030
guys.

00:48:49.030 --> 00:48:54.100
Hopefully, AsyncTask and intent services are
mainstays of your arsenal.

00:48:54.100 --> 00:48:57.710
But I did want to point out a couple of relatively
new classes.

00:48:57.710 --> 00:49:03.920
That's the abstract loader class and the implementation
of the cursor loader.

00:49:03.920 --> 00:49:05.260
These are both part of Honeycomb.

00:49:05.260 --> 00:49:08.000
They're actually available, like Fragments,
as an external API.

00:49:08.000 --> 00:49:12.240
So you can use these to improve your app performance
today.

00:49:12.240 --> 00:49:15.200
Now, the code looks a little bit scary.

00:49:15.200 --> 00:49:17.530
It's not actually as complicated as you might
think.

00:49:17.530 --> 00:49:21.650
We're going to start off by getting an instance
of the loader manager.

00:49:21.650 --> 00:49:24.050
That's what's going to let us do the work.

00:49:24.050 --> 00:49:27.350
And then everything -- all the magic happens
here.

00:49:27.350 --> 00:49:28.840
So oncreate loader.

00:49:28.840 --> 00:49:33.609
Now, the cursor loader, which we're call there
the constructor with all those null strings,

00:49:33.609 --> 00:49:37.830
this is essentially where you're able to construct
the cursor, which you want to load in a background

00:49:37.830 --> 00:49:38.840
thread.

00:49:38.840 --> 00:49:40.690
The base URI there is the key.

00:49:40.690 --> 00:49:44.930
That's the base URI to the content provider
which you want to extract content from.

00:49:44.930 --> 00:49:50.800
And you can specify selection, projections,
"where" clauses, all of those things, as you

00:49:50.800 --> 00:49:57.260
would if you were using a content resolvers
to extract a query in the traditional sense.

00:49:57.260 --> 00:50:00.800
Once the loading is finished, that cursor
data is going to be populated and it's going

00:50:00.800 --> 00:50:02.420
to be passed back into your application.

00:50:02.420 --> 00:50:04.840
So all of that loading will be done in the
background.

00:50:04.840 --> 00:50:08.410
You don't have to worry about what parts of
the content resolution process happen on the

00:50:08.410 --> 00:50:10.300
foreground or the background thread.

00:50:10.300 --> 00:50:11.451
This does it all for you.

00:50:11.451 --> 00:50:15.890
Then you get your cursor and apply it to your
adapter or do whatever else you need to do

00:50:15.890 --> 00:50:16.890
with that data.

00:50:16.890 --> 00:50:20.820
So how do you know if you've done it right?

00:50:20.820 --> 00:50:23.480
Well, you start off by using strict mode.

00:50:23.480 --> 00:50:27.810
Hopefully, again, you've all used this, are
familiar with it.

00:50:27.810 --> 00:50:31.530
Great way to be able to find out if anything
like disk reads, writes, network action any

00:50:31.530 --> 00:50:34.140
of that is happening on the foreground thread
and fixing it.

00:50:34.140 --> 00:50:36.570
I do want to point out it's a development
tool.

00:50:36.570 --> 00:50:40.590
You do want to have it so it only runs on
the development version.

00:50:40.590 --> 00:50:45.000
Should make a difference because you have
fixed all these things before you release.

00:50:45.000 --> 00:50:49.240
Just in case they do slip through, turn it
off for the runtime version.

00:50:49.240 --> 00:50:52.980
You don't want the screen flashing or dialogue
boxes of the burst logging or any of that

00:50:52.980 --> 00:50:57.280
stuff on your release builds.

00:50:57.280 --> 00:50:58.280
So turn it off.

00:50:58.280 --> 00:50:59.280
So that's it.

00:50:59.280 --> 00:51:01.660
That's all of the extra attributes I wanted
to go through today.

00:51:01.660 --> 00:51:06.230
Hopefully, I've given you enough information
so that most of you guys in this piece of

00:51:06.230 --> 00:51:09.140
the pie can become this piece of the pie.

00:51:09.140 --> 00:51:13.590
And, hopefully, you'll be able to come away
with some ideas of how to make your device

00:51:13.590 --> 00:51:20.650
-- how to make your applications fresh, Psychic,
adaptive, and smooth.

00:51:20.650 --> 00:51:25.120
Thank you very much.

00:51:25.120 --> 00:51:31.260
[ Applause ]
&gt;&gt;Reto Meier: Now, I think we do have some

00:51:31.260 --> 00:51:32.260
time.

00:51:32.260 --> 00:51:34.140
I think we're heading into lunch, but we do
have a few minutes left for questions.

00:51:34.140 --> 00:51:37.410
If you do have any in the room, head up to
the mike.

00:51:37.410 --> 00:51:42.780
And I have a few on the moderator page as
well.

00:51:42.780 --> 00:51:46.100
Lunch wins.

00:51:46.100 --> 00:51:47.100
All right.

00:51:47.100 --> 00:51:48.260
I'll read these out because I don't think
we're going to get them on the screen.

00:51:48.260 --> 00:51:52.300
Do we have any tips for working with SQLLite
databases through Eclipse?

00:51:52.300 --> 00:51:57.040
At the minute, I rely on external tools to
view data that is in the database on the phone.

00:51:57.040 --> 00:51:58.530
No tips.

00:51:58.530 --> 00:52:01.780
That is all you're going to have to do.

00:52:01.780 --> 00:52:05.360
Eclipse is a wonderful development tool.

00:52:05.360 --> 00:52:06.540
However, it is clunky.

00:52:06.540 --> 00:52:08.890
How many of you use Eclipse?

00:52:08.890 --> 00:52:10.859
Yeah, how many of you think it's clunky?

00:52:10.859 --> 00:52:11.859
Yeah.

00:52:11.859 --> 00:52:12.859
It is.

00:52:12.859 --> 00:52:14.820
So we're going to do a bunch of stuff.

00:52:14.820 --> 00:52:19.890
So there's some sessions tomorrow, or, indeed,
later today, about the Android development

00:52:19.890 --> 00:52:20.890
tools.

00:52:20.890 --> 00:52:25.170
Should definitely check that out, there's
great information there about how to use those

00:52:25.170 --> 00:52:28.220
tools more effectively.

00:52:28.220 --> 00:52:33.070
&gt;&gt;&gt; About that cursor loader, if you use that
to -- yeah, so -- do things asynchronously,

00:52:33.070 --> 00:52:44.200
but you need the cursor to fill the activities
or a way to save data away into the database,

00:52:44.200 --> 00:52:46.190
you cannot really use that.

00:52:46.190 --> 00:52:52.610
You need to have it done immediately, because
the work flow of the app requires that you

00:52:52.610 --> 00:52:53.610
continue; right?

00:52:53.610 --> 00:52:54.610
&gt;&gt;Reto Meier: Exactly.

00:52:54.610 --> 00:52:58.470
So what you would do is you would have the
cursor loader is going to get a new cursor,

00:52:58.470 --> 00:53:01.370
which you would then swap out for your adapter.

00:53:01.370 --> 00:53:05.010
So for most cases, what you have is a view,
like a ListView, which has an adapter backing

00:53:05.010 --> 00:53:06.010
it.

00:53:06.010 --> 00:53:10.050
Then you can call swap adapter and it's just
going to exchange the new cursor with the

00:53:10.050 --> 00:53:11.050
old one.

00:53:11.050 --> 00:53:14.520
&gt;&gt;&gt; That's assuming you have an old one.

00:53:14.520 --> 00:53:17.300
So the first one needs to be done synchronously,
then.

00:53:17.300 --> 00:53:21.140
&gt;&gt;Reto Meier: No, you still do it asynchronously
you still do your ListView with nothing in

00:53:21.140 --> 00:53:27.010
it and then wait until you have that data
and then start to populate it.

00:53:27.010 --> 00:53:29.590
Yeah.

00:53:29.590 --> 00:53:33.300
&gt;&gt;&gt; So you mentioned the connectivity provider
or connectivity messaging.

00:53:33.300 --> 00:53:35.610
I was curious.

00:53:35.610 --> 00:53:47.280
We were using that, and it seems like you
will go in and out of connectivity on a frequent

00:53:47.280 --> 00:53:48.280
basis.

00:53:48.280 --> 00:53:53.240
How expensive is that to wake up, let you
know that you've entered connectivity, but

00:53:53.240 --> 00:53:56.690
it's not the right type, or things like that?

00:53:56.690 --> 00:53:57.690
&gt;&gt;Reto Meier: Sure, absolutely.

00:53:57.690 --> 00:53:58.830
So you want to keep it as lightweight as possible.

00:53:58.830 --> 00:54:03.150
So you want to have a receiver, possibly one
which is happening in a separate process to

00:54:03.150 --> 00:54:07.280
the rest of your application so that your
whole app isn't necessarily getting spun up

00:54:07.280 --> 00:54:08.690
each time.

00:54:08.690 --> 00:54:12.080
Then you want that to be as lightweight as
possible of just checking to see what the

00:54:12.080 --> 00:54:13.120
connectivity change is.

00:54:13.120 --> 00:54:16.600
&gt;&gt;&gt; But that would be a separate process within
the same APK?

00:54:16.600 --> 00:54:17.810
&gt;&gt;Reto Meier: Yes.

00:54:17.810 --> 00:54:18.810
Yeah.

00:54:18.810 --> 00:54:19.810
&gt;&gt;&gt; Thank you.

00:54:19.810 --> 00:54:20.810
&gt;&gt;Reto Meier: No problem.

00:54:20.810 --> 00:54:26.600
&gt;&gt;&gt; In your first discussion, there is a lot
of things you can register for the event,

00:54:26.600 --> 00:54:30.632
such as low battery and the change in those
things; right?

00:54:30.632 --> 00:54:31.632
&gt;&gt;Reto Meier: Uh-huh.

00:54:31.632 --> 00:54:35.050
&gt;&gt;&gt; And those things should have dependency
or priority or contribute to each other sometimes.

00:54:35.050 --> 00:54:41.710
Is there any way you can define what those
things that need to be done by the receiver?

00:54:41.710 --> 00:54:45.109
&gt;&gt;Reto Meier: I guess you can define that
within your receiver to basically receive

00:54:45.109 --> 00:54:46.660
--
&gt;&gt;&gt; In that case, the receiver can have a

00:54:46.660 --> 00:54:48.070
-- can be bigger and bigger.

00:54:48.070 --> 00:54:51.940
For example, they cannot just check low battery,
because they need to also check the connectivity

00:54:51.940 --> 00:54:52.940
sometimes; right?

00:54:52.940 --> 00:54:55.670
&gt;&gt;Reto Meier: So you can do that within the
receiver.

00:54:55.670 --> 00:54:58.500
Within the receiver, you are just getting
triggered by changing connectivity.

00:54:58.500 --> 00:55:05.140
&gt;&gt;&gt; Is there a good way you can also define
those dependency or priority when you register

00:55:05.140 --> 00:55:06.140
those things?

00:55:06.140 --> 00:55:08.270
&gt;&gt;Reto Meier: No.

00:55:08.270 --> 00:55:09.270
No simple way.

00:55:09.270 --> 00:55:12.599
The --
&gt;&gt;&gt; Not simple way, but you can -- that will,

00:55:12.599 --> 00:55:15.180
like, reduce those event, basically, right?

00:55:15.180 --> 00:55:16.180
&gt;&gt;Reto Meier: Absolutely.

00:55:16.180 --> 00:55:20.580
&gt;&gt;&gt; Otherwise, have a lot of different events,
and then everything is up to application,

00:55:20.580 --> 00:55:23.109
then may cause some problem; right?

00:55:23.109 --> 00:55:25.230
&gt;&gt;Reto Meier: That's absolutely true.

00:55:25.230 --> 00:55:28.560
You do need to be aware of the fact that if
you have 12 different receivers all listening

00:55:28.560 --> 00:55:31.510
for common things, it's going to have its
own impact on battery life.

00:55:31.510 --> 00:55:34.330
&gt;&gt;&gt; If you can have an additional API for
that, that would be good, too.

00:55:34.330 --> 00:55:35.330
&gt;&gt;Reto Meier: Absolutely.

00:55:35.330 --> 00:55:37.890
I'll pass it on to the team.

00:55:37.890 --> 00:55:39.230
Yes.

00:55:39.230 --> 00:55:43.050
&gt;&gt;&gt; You mentioned the passive location provider.

00:55:43.050 --> 00:55:49.530
How different is that from -- in the freshness
sense of view, from getting last-known position?

00:55:49.530 --> 00:55:53.160
Like, I mean, you're going to get the same
data; right?

00:55:53.160 --> 00:55:54.160
&gt;&gt;Reto Meier: Exactly.

00:55:54.160 --> 00:55:55.550
It depends how you want to use it.

00:55:55.550 --> 00:55:59.560
The passive location provider is better if
you plan on doing something with that data

00:55:59.560 --> 00:56:01.369
while you're in the background.

00:56:01.369 --> 00:56:03.780
So if all you're going to do is say, look,
I don't want to do anything in the background,

00:56:03.780 --> 00:56:08.080
I just want to wait until the app starts and
then get the last known location, you're better

00:56:08.080 --> 00:56:09.840
off using that.

00:56:09.840 --> 00:56:14.380
Whereas if you're saying well, I actually
want to say every 15 minutes, every half hour

00:56:14.380 --> 00:56:16.869
if the location is changed, I want to get
that data.

00:56:16.869 --> 00:56:19.340
So as soon as the app starts, it has that
current information.

00:56:19.340 --> 00:56:21.930
That has, obviously, a very significant battery
impact.

00:56:21.930 --> 00:56:26.051
But that would be the difference between the
two.

00:56:26.051 --> 00:56:27.051
&gt;&gt;&gt; Thanks.

00:56:27.051 --> 00:56:28.051
&gt;&gt;Reto Meier: Have a quick look on the moderator.

00:56:28.051 --> 00:56:32.340
You better mention better not to lose your
sign-in key, but how to update your app when

00:56:32.340 --> 00:56:33.340
your (inaudible) expired.

00:56:33.340 --> 00:56:36.349
(inaudible) a certificate with a very long
expiry date.

00:56:36.349 --> 00:56:40.000
That's the reason you can't sign your certificates
with a debug key, because the expirations

00:56:40.000 --> 00:56:41.000
are too short.

00:56:41.000 --> 00:56:45.740
We will worry about how to transition them
in 2050, when most of them should have expired.

00:56:45.740 --> 00:56:46.740
Please.

00:56:46.740 --> 00:56:51.490
&gt;&gt;&gt; Hypothetically speaking, if we created
an application and deployed it under our personal

00:56:51.490 --> 00:56:56.750
GMail account, is there anything that we can
do now to move that to another account?

00:56:56.750 --> 00:56:57.750
&gt;&gt;Reto Meier: No.

00:56:57.750 --> 00:56:59.359
[ Applause ]
&gt;&gt;Reto Meier: That is a good question.

00:56:59.359 --> 00:57:00.359
&gt;&gt;&gt; (inaudible) fresh application?

00:57:00.359 --> 00:57:03.770
&gt;&gt;Reto Meier: The only thing you can do right
now is unpublish the app, create a new one,

00:57:03.770 --> 00:57:04.770
and publish it.

00:57:04.770 --> 00:57:10.760
It would be nice if you could transition or
invite other people into a particular application.

00:57:10.760 --> 00:57:11.760
It's not something that's available now.

00:57:11.760 --> 00:57:16.530
But we are talking about -- some of the guys
who are doing improvements on market are going

00:57:16.530 --> 00:57:17.530
to give a presentation.

00:57:17.530 --> 00:57:22.390
I don't think that's changed since the last
time I heard, but they would be the right

00:57:22.390 --> 00:57:23.849
folks to ask.

00:57:23.849 --> 00:57:27.349
Do developers at Google use any hardware emulators
to speed up development.

00:57:27.349 --> 00:57:30.599
Could you please recommend one.

00:57:30.599 --> 00:57:32.380
We use actual hardware where we have it.

00:57:32.380 --> 00:57:34.660
And we are trying to improve the emulator.

00:57:34.660 --> 00:57:39.950
So, again, check out the talk on developer
tools, and hopefully there will be some news

00:57:39.950 --> 00:57:40.950
there.

00:57:40.950 --> 00:57:41.950
Yes.

00:57:41.950 --> 00:57:46.160
&gt;&gt;&gt; For various reasons, we're thinking of
distributing our app on the SD card.

00:57:46.160 --> 00:57:50.740
And that will be installed in the Android
phones.

00:57:50.740 --> 00:57:57.880
So is there, like, an Eclipse way to download
that and how to do that mechanism?

00:57:57.880 --> 00:58:01.320
&gt;&gt;Reto Meier: I don't think I understand.

00:58:01.320 --> 00:58:07.300
&gt;&gt;&gt; So we're thinking of physically -- it's
kind of a weird thing, but we're physically

00:58:07.300 --> 00:58:10.590
thinking of distributing the app on the SD
card.

00:58:10.590 --> 00:58:11.590
&gt;&gt;Reto Meier: Okay.

00:58:11.590 --> 00:58:16.420
&gt;&gt;&gt; And then, you know, going to salespeople
and then putting it in their phones and then

00:58:16.420 --> 00:58:19.760
running the app that way instead of downloading.

00:58:19.760 --> 00:58:21.200
&gt;&gt;Reto Meier: No, there's nothing supported
for that.

00:58:21.200 --> 00:58:25.820
So you could potentially install it from the
SD card by navigating it using a file manager

00:58:25.820 --> 00:58:26.960
on the device.

00:58:26.960 --> 00:58:31.900
But there's no simple way of doing that.

00:58:31.900 --> 00:58:32.940
Yes.

00:58:32.940 --> 00:58:33.980
&gt;&gt;&gt; Hi.

00:58:33.980 --> 00:58:36.050
Thank you.

00:58:36.050 --> 00:58:44.090
Does the location manager -- when you register
for location updates, does it, like, hold

00:58:44.090 --> 00:58:45.090
a WakeLock?

00:58:45.090 --> 00:58:49.000
Or let's say you want to run continuous location
tracking, and I know it's not a good thing,

00:58:49.000 --> 00:58:56.580
and we're not doing this for, like, a consumer
app, it's for a research app.

00:58:56.580 --> 00:59:02.420
Do we have to, like, have a long list service
that holds the WakeLock that will, you know,

00:59:02.420 --> 00:59:06.030
be alive the whole time that is listening
for the location updates?

00:59:06.030 --> 00:59:09.920
Or if we just register location updates, will
that, like, you know, keep the server -- keep

00:59:09.920 --> 00:59:11.240
the service alive automatically?

00:59:11.240 --> 00:59:15.750
In practice, we've noticed it seems like the
service never dies, even if we don't hold

00:59:15.750 --> 00:59:18.900
the WakeLock, but --
&gt;&gt;Reto Meier: It's hard to kill services.

00:59:18.900 --> 00:59:22.930
And because they by default will get restarted
automatically for something like a location

00:59:22.930 --> 00:59:25.080
listener, it works.

00:59:25.080 --> 00:59:29.320
If it's music, then you'll hear a pause as
the service gets killed and the system restarts

00:59:29.320 --> 00:59:30.320
it.

00:59:30.320 --> 00:59:32.350
So that's why you want to make that an ongoing
activity.

00:59:32.350 --> 00:59:37.910
Generally, I think if you register a location
listener using the intent mechanism, that

00:59:37.910 --> 00:59:40.250
is sort of independent of any running application.

00:59:40.250 --> 00:59:42.710
So that receiver is always going to get triggered.

00:59:42.710 --> 00:59:46.930
Generally speaking, you do want to have a
service which continues to deliver good form

00:59:46.930 --> 00:59:50.730
in an ongoing service so users can see that.

00:59:50.730 --> 00:59:52.830
&gt;&gt;&gt; What about the WakeLock aspect of it?

00:59:52.830 --> 00:59:58.470
If you register with the intent mechanism,
do you need to -- will that, like, --

00:59:58.470 --> 01:00:02.090
&gt;&gt;Reto Meier: You'll need to create -- so
the intent receiver will run for -- I think

01:00:02.090 --> 01:00:07.310
it has a WakeLock for -- within the on receive
action, to be completed within, I think, ten

01:00:07.310 --> 01:00:08.310
seconds.

01:00:08.310 --> 01:00:12.260
So anything which is happening outside of
that, you would need to have a WakeLock for

01:00:12.260 --> 01:00:14.789
the service to continue.

01:00:14.789 --> 01:00:15.789
&gt;&gt;&gt; Okay.

01:00:15.789 --> 01:00:16.789
Thank you.

01:00:16.789 --> 01:00:17.789
&gt;&gt;Reto Meier: No problem.

01:00:17.789 --> 01:00:18.789
&gt;&gt;&gt; And do you mind me asking, what are you
using for the presentation?

01:00:18.789 --> 01:00:19.789
What app?

01:00:19.789 --> 01:00:23.950
&gt;&gt;Reto Meier: For the -- the app for the presentation
was something I hand-created.

01:00:23.950 --> 01:00:29.630
So if -- including the video crashing, if
you are interested, I'll be looking to open

01:00:29.630 --> 01:00:31.780
source that at some time in the future.

01:00:31.780 --> 01:00:33.290
&gt;&gt;&gt; That would be awesome.

01:00:33.290 --> 01:00:34.290
Thanks.

01:00:34.290 --> 01:00:35.290
&gt;&gt;Reto Meier: All right.

01:00:35.290 --> 01:00:41.300
&gt;&gt;&gt; Do you have any tips how to optimize compatibility
on Web views?

01:00:41.300 --> 01:00:48.040
Because some of the versions of the browser
are broken on the JavaScript bridges and other

01:00:48.040 --> 01:00:49.040
stuff.

01:00:49.040 --> 01:00:53.270
&gt;&gt;Reto Meier: Not my area, but check out the
Chrome team's office hours.

01:00:53.270 --> 01:00:59.630
They are the browser experts, so it's not
a Chrome browser, but they do know all about,

01:00:59.630 --> 01:01:01.200
you know, browsers and those sorts of things.

01:01:01.200 --> 01:01:04.550
And some of the mobile guys will be able to
give you some advice.

01:01:04.550 --> 01:01:05.550
Cool.

01:01:05.550 --> 01:01:06.869
Thanks very much, everyone.

