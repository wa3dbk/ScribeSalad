WEBVTT
Kind: captions
Language: en

00:00:02.530 --> 00:00:03.825
JOHN STUPPY: Welcome,
everyone.

00:00:03.825 --> 00:00:05.270
I'm glad you're here.

00:00:05.270 --> 00:00:07.136
You guys excited for I/O?

00:00:07.136 --> 00:00:07.500
AUDIENCE: Yeah.

00:00:07.500 --> 00:00:08.740
JOHN STUPPY: Great.

00:00:08.740 --> 00:00:10.380
Well, let me introduce
the team.

00:00:10.380 --> 00:00:11.470
My name is John Stuppy.

00:00:11.470 --> 00:00:13.710
And I'm joined by Jon
Boekenoogen, my colleague on

00:00:13.710 --> 00:00:17.260
the Google Wallet Instant Buy
team as well as Haisoo Shin,

00:00:17.260 --> 00:00:19.680
Director of Engineering and Lead
Android Developer for The

00:00:19.680 --> 00:00:22.210
Fancy, one of our first initial
integration partners

00:00:22.210 --> 00:00:24.720
of Google Wallet Instant Buy.

00:00:24.720 --> 00:00:27.220
Today we're discussing building
compelling mCommerce

00:00:27.220 --> 00:00:29.120
experiences on Android.

00:00:29.120 --> 00:00:32.140
So let's get started.

00:00:32.140 --> 00:00:35.490
As you heard earlier today,
there are 900 million Android

00:00:35.490 --> 00:00:37.900
devices in the world.

00:00:37.900 --> 00:00:39.360
And what are people using
these devices

00:00:39.360 --> 00:00:40.810
for more and more?

00:00:40.810 --> 00:00:42.560
Shopping.

00:00:42.560 --> 00:00:45.130
But it's not as easy as just
having compelling products and

00:00:45.130 --> 00:00:47.930
services to get users to
actually convert on your

00:00:47.930 --> 00:00:49.640
mCommerce applications.

00:00:52.330 --> 00:00:54.720
We find three big challenges.

00:00:54.720 --> 00:00:56.410
The first, discovery.

00:00:56.410 --> 00:00:58.760
How do people find your
applications and products?

00:00:58.760 --> 00:01:01.950
How do they get excited
about them?

00:01:01.950 --> 00:01:05.019
Then, when a user likes your
application, how does she tell

00:01:05.019 --> 00:01:07.280
you a little bit more about
herself and sign up for your

00:01:07.280 --> 00:01:09.870
application so that you can then
tell her about upcoming

00:01:09.870 --> 00:01:11.695
product promotions
and other offers?

00:01:14.360 --> 00:01:16.820
And finally, when she finds
something she likes, how does

00:01:16.820 --> 00:01:18.610
she pay for it?

00:01:18.610 --> 00:01:22.870
Now we find that the last two
challenges here are entirely

00:01:22.870 --> 00:01:24.190
within your application.

00:01:24.190 --> 00:01:27.480
But they're large friction
points due to mobile forms and

00:01:27.480 --> 00:01:30.360
other causes of pain that lead
to a high mobile cart

00:01:30.360 --> 00:01:32.580
abandonments rate.

00:01:32.580 --> 00:01:35.000
And that's what we tried to
solve with Google Wallet

00:01:35.000 --> 00:01:36.250
Instant Buy.

00:01:38.420 --> 00:01:42.330
As announced earlier today,
Google Wallet Instant Buy is a

00:01:42.330 --> 00:01:45.620
small library that's part
of Google Play services,

00:01:45.620 --> 00:01:50.270
available on every device
with the Play Store.

00:01:50.270 --> 00:01:53.050
Now this means that a user with
Google Wallet can make

00:01:53.050 --> 00:01:56.390
faster checkouts of physical
goods and services in only a

00:01:56.390 --> 00:01:57.640
few taps on their phone.

00:02:00.640 --> 00:02:03.030
Further, as a merchant, the
integration is very

00:02:03.030 --> 00:02:05.100
lightweight.

00:02:05.100 --> 00:02:09.490
Google Wallet sends your
application a usable proxy

00:02:09.490 --> 00:02:14.460
card, complete with expiration
date, CVC, building address,

00:02:14.460 --> 00:02:16.510
as well the shipping address
that the user would like those

00:02:16.510 --> 00:02:18.760
items sent.

00:02:18.760 --> 00:02:23.300
Because we're using a virtual
proxy card, the user is secure

00:02:23.300 --> 00:02:25.740
in knowing that their physical
real data cards

00:02:25.740 --> 00:02:27.960
are not being sent.

00:02:27.960 --> 00:02:30.980
And further, it's free for
merchants and consumers.

00:02:30.980 --> 00:02:32.230
So it's great.

00:02:34.970 --> 00:02:38.150
So in creating the Google Wallet
Instant Buy app, we

00:02:38.150 --> 00:02:42.010
focused on three major areas of
concern for users, in hopes

00:02:42.010 --> 00:02:44.200
to avoid mobile cart
app abandonment.

00:02:44.200 --> 00:02:46.870
And we'd like to share some of
our techniques and tips and

00:02:46.870 --> 00:02:49.480
tricks that we've learned with
you and ways that you can

00:02:49.480 --> 00:02:51.880
improve your own applications.

00:02:51.880 --> 00:02:56.110
We focused on mobile-friendly
forms, reducing latency, and

00:02:56.110 --> 00:02:58.870
improving security and privacy
for our users.

00:03:02.210 --> 00:03:04.460
So how many of you have ever
been in an application, you've

00:03:04.460 --> 00:03:07.000
added items to your shopping
cart, you go to check out and

00:03:07.000 --> 00:03:09.810
have seen very lengthy forms
asking you to sign up, asking

00:03:09.810 --> 00:03:12.610
for credit card information
and shipping information?

00:03:12.610 --> 00:03:14.310
And you see these forms,
and have you ever said,

00:03:14.310 --> 00:03:15.210
I don't have time?

00:03:15.210 --> 00:03:15.900
I'm on the go.

00:03:15.900 --> 00:03:18.170
I'm using an Android
tablet or a phone.

00:03:18.170 --> 00:03:19.750
I just can't do it.

00:03:19.750 --> 00:03:21.630
And so you bailed on
the transaction.

00:03:21.630 --> 00:03:25.830
So we tried to focus on
making the interaction

00:03:25.830 --> 00:03:27.840
as smooth as possible.

00:03:27.840 --> 00:03:30.910
And while returning Wallet users
will be able to complete

00:03:30.910 --> 00:03:32.990
a checkout process on your
application in two to three

00:03:32.990 --> 00:03:36.990
taps, new Wallet users will
experience a signup flow.

00:03:36.990 --> 00:03:39.550
So we've tried to optimize that
as much as possible using

00:03:39.550 --> 00:03:41.270
mobile-friendly forms.

00:03:41.270 --> 00:03:42.520
Let's show how that's done.

00:03:49.850 --> 00:03:52.510
So I'm a new user using
Google Wallet.

00:03:52.510 --> 00:03:56.840
And I'll say, Buy with
Google Wallet.

00:03:56.840 --> 00:03:59.000
And as I'm a new user, Google
Wallet's going to ask me for

00:03:59.000 --> 00:04:00.560
some information.

00:04:00.560 --> 00:04:02.530
So the first piece is the
credit card number.

00:04:02.530 --> 00:04:06.080
So I'll get out my credit card,
and I'll start typing.

00:04:08.820 --> 00:04:11.360
And as we type, we see that
we're doing real time

00:04:11.360 --> 00:04:13.740
formatting of the card number,
so if I were to make a

00:04:13.740 --> 00:04:16.180
mistake, I could correct it
very easily, because I'm

00:04:16.180 --> 00:04:17.959
following along as I go.

00:04:21.100 --> 00:04:24.730
And when I do make a mistake, we
alert the user right away,

00:04:24.730 --> 00:04:27.470
using simple client-side checks
and algorithm, known as

00:04:27.470 --> 00:04:30.330
the loon algorithm, that
the card is invalid.

00:04:30.330 --> 00:04:32.620
So I, as the user, can now
correct this card while the

00:04:32.620 --> 00:04:35.140
card is still out on the table
and it's still fresh in my

00:04:35.140 --> 00:04:37.170
mind what I'm doing.

00:04:37.170 --> 00:04:40.170
So I'll go back, and I'll
correct the card.

00:04:40.170 --> 00:04:42.180
It's a little hard to see on the
screen, but we were able

00:04:42.180 --> 00:04:44.620
to auto advance from the credit
card field to the

00:04:44.620 --> 00:04:46.650
expiration month, because we
knew that the user has

00:04:46.650 --> 00:04:48.820
completed the credit card.

00:04:48.820 --> 00:04:51.270
This allows me to simply follow
along with the credit

00:04:51.270 --> 00:04:53.820
card data that I see and
continue my form.

00:04:58.430 --> 00:05:00.970
Now by auto advancing from field
to field, we reduce the

00:05:00.970 --> 00:05:03.900
need for the user from having
to find the next key, or

00:05:03.900 --> 00:05:07.000
worse, hiding the keyboard,
scrolling to the next field

00:05:07.000 --> 00:05:09.180
manually, and tapping into it.

00:05:09.180 --> 00:05:11.970
And again, this is just to ease
user friction and help

00:05:11.970 --> 00:05:14.635
users get through
the form faster.

00:05:14.635 --> 00:05:26.660
So now I'll fill out my
name and continue.

00:05:26.660 --> 00:05:29.360
And now we're at the always
troubling billing address.

00:05:29.360 --> 00:05:31.650
Now addresses differ from credit
cards, in that they're

00:05:31.650 --> 00:05:36.090
well known to the user, myself,
but they are difficult

00:05:36.090 --> 00:05:36.950
to type out.

00:05:36.950 --> 00:05:39.670
There's many fields, they come
in various forms, and they

00:05:39.670 --> 00:05:42.330
switch from letters and
numbers all the time.

00:05:42.330 --> 00:05:45.790
So we've integrated this logic
to be able to provide very

00:05:45.790 --> 00:05:51.910
fast help by using the Places
API from Google Maps.

00:05:51.910 --> 00:05:53.670
So right now we're
at 747 Howard

00:05:53.670 --> 00:05:56.010
Street, here in San Francisco.

00:05:56.010 --> 00:05:58.930
If you're typing 747 and the
letter H, we see that our

00:05:58.930 --> 00:06:03.520
first result is where and our
required billing address.

00:06:03.520 --> 00:06:05.670
So rather than type all
those details out, I

00:06:05.670 --> 00:06:07.360
can select the address.

00:06:07.360 --> 00:06:10.420
It fills out the form for me,
and I can continue on.

00:06:10.420 --> 00:06:12.140
We don't have an apartment
or suite, so

00:06:12.140 --> 00:06:14.520
I'll just scroll down.

00:06:14.520 --> 00:06:17.830
For phone number, this device
does not have a cell network,

00:06:17.830 --> 00:06:19.060
so there's no phone
number tied to it.

00:06:19.060 --> 00:06:21.390
If it did, we could
prefill that.

00:06:21.390 --> 00:06:24.780
So we'll just fill it in.

00:06:24.780 --> 00:06:26.910
And I want to use this as my
shipping address, and I want

00:06:26.910 --> 00:06:28.580
to use Google Wallet
to pay for future

00:06:28.580 --> 00:06:30.506
purchases on this merchant.

00:06:30.506 --> 00:06:31.756
So I'll continue.

00:06:34.810 --> 00:06:38.430
Now in just that time, we have
signed up for Google Wallet

00:06:38.430 --> 00:06:40.960
and continued through our
checkout process, saving the

00:06:40.960 --> 00:06:44.110
user time now and later.

00:06:44.110 --> 00:06:47.760
So let's show how we did
some of these features.

00:06:47.760 --> 00:06:49.390
The first was our ability
to auto advance

00:06:49.390 --> 00:06:51.330
from field to field.

00:06:51.330 --> 00:06:54.380
To do that with our credit card,
we needed to know when

00:06:54.380 --> 00:06:58.790
the credit card was complete
and also when it was valid.

00:06:58.790 --> 00:07:00.990
So here's a very simple
implementation of this

00:07:00.990 --> 00:07:04.310
interface for credit cards.

00:07:04.310 --> 00:07:06.230
We'll say that a credit
card is complete if it

00:07:06.230 --> 00:07:08.482
has at least 15 digits.

00:07:08.482 --> 00:07:11.430
And we'll say that a credit card
is valid if it passes our

00:07:11.430 --> 00:07:12.680
loon algorithm.

00:07:14.530 --> 00:07:17.030
And now if it's valid, we want
to clear any errors on the

00:07:17.030 --> 00:07:20.580
text field and return true.

00:07:20.580 --> 00:07:23.980
If it's not valid, we want to
mark an error on the text

00:07:23.980 --> 00:07:27.510
field for user action
and return false.

00:07:27.510 --> 00:07:31.220
So how do we tie this into
our application?

00:07:31.220 --> 00:07:34.340
For every field we want to
enable auto advance, we first

00:07:34.340 --> 00:07:38.390
add a text watcher so that every
time the text changes we

00:07:38.390 --> 00:07:41.720
can perform three actions.

00:07:41.720 --> 00:07:43.670
The first is we ask
our validator,

00:07:43.670 --> 00:07:44.950
is the field complete?

00:07:44.950 --> 00:07:47.850
Does it have the correct
number of digits or

00:07:47.850 --> 00:07:49.240
characters?

00:07:49.240 --> 00:07:51.850
If so, we then ask
our validator to

00:07:51.850 --> 00:07:53.970
validate that field.

00:07:53.970 --> 00:07:57.780
If it's valid, we then use that
Android native library to

00:07:57.780 --> 00:07:59.430
find the next focusable
element and

00:07:59.430 --> 00:08:03.130
request focus on it.

00:08:03.130 --> 00:08:06.130
So now let's turn to
the address fields.

00:08:06.130 --> 00:08:10.810
By combining with various data
sources, we're able to provide

00:08:10.810 --> 00:08:13.520
suggestions to the user on ways
they can complete that

00:08:13.520 --> 00:08:17.080
address form as fast
as possible.

00:08:17.080 --> 00:08:19.970
But we wanted to optimize
it, so we have

00:08:19.970 --> 00:08:21.320
multiple data sources.

00:08:21.320 --> 00:08:24.510
We use the Google Wallet
previous data as well as

00:08:24.510 --> 00:08:26.590
Places API.

00:08:26.590 --> 00:08:29.900
Now with any autosuggestion
feature with multiple data

00:08:29.900 --> 00:08:32.679
sources, you want to strike
a balance between the most

00:08:32.679 --> 00:08:35.490
relevant data to the user and
the data that is fastest to

00:08:35.490 --> 00:08:37.539
acquire and show.

00:08:37.539 --> 00:08:39.820
And in our case, previous Wallet
data meets both of

00:08:39.820 --> 00:08:42.280
these criteria.

00:08:42.280 --> 00:08:44.830
If you're a returning Wallet
user entering a new credit

00:08:44.830 --> 00:08:47.520
card, for example, there's a
good chance that your billing

00:08:47.520 --> 00:08:49.890
address will be the same as
your previous credit card.

00:08:49.890 --> 00:08:52.810
And so like querying this data
locally and memory using

00:08:52.810 --> 00:08:55.750
simple string comparisons, we
can determine if you're typing

00:08:55.750 --> 00:08:57.690
the same address.

00:08:57.690 --> 00:09:02.210
If not, or if you're a new
Wallet user, we'll then go to

00:09:02.210 --> 00:09:06.020
the Places API.

00:09:06.020 --> 00:09:07.530
This data is very rich.

00:09:07.530 --> 00:09:09.740
However, it is not as personal,
in that it doesn't

00:09:09.740 --> 00:09:14.370
include things like apartment
or a suite number.

00:09:14.370 --> 00:09:17.070
Further, it requires a network
I/O and a round trip, so it's

00:09:17.070 --> 00:09:21.490
not as fast as doing local
onboard memory.

00:09:21.490 --> 00:09:24.200
So let's see some
code for this.

00:09:24.200 --> 00:09:27.250
So a lot of autosuggestion
is really done within the

00:09:27.250 --> 00:09:29.130
AutoCompleteTextView.

00:09:29.130 --> 00:09:33.390
And this is a subclass of the
EditText component within

00:09:33.390 --> 00:09:35.730
Android that has been a
part of the library

00:09:35.730 --> 00:09:39.000
since Version 1.

00:09:39.000 --> 00:09:41.280
The AutoCompleteTextView
component handles a lot of the

00:09:41.280 --> 00:09:44.180
logistics and pain that's
caused by providing

00:09:44.180 --> 00:09:48.360
autosuggestion results, leaving
the developer with two

00:09:48.360 --> 00:09:50.170
simple operations.

00:09:50.170 --> 00:09:53.840
The first is to provide the
results for a given query

00:09:53.840 --> 00:09:57.040
using the perform filtering
method, which is run in a

00:09:57.040 --> 00:10:00.460
background thread, so you're
able to do longstanding

00:10:00.460 --> 00:10:02.240
operations, like fetching
data from the

00:10:02.240 --> 00:10:05.790
network, disk, et cetera.

00:10:05.790 --> 00:10:08.280
When you have the data, you then
need to tell the adapter

00:10:08.280 --> 00:10:10.580
and the TextView that that
data is available.

00:10:10.580 --> 00:10:12.860
And you do that from the
published results.

00:10:12.860 --> 00:10:15.750
This notifies the TextView that
it needs to re-render the

00:10:15.750 --> 00:10:19.910
drop-down with the appropriate
selections.

00:10:19.910 --> 00:10:22.120
So we tried here to make the
form as easy and friendly to

00:10:22.120 --> 00:10:25.780
fill out so that a user
could get through it

00:10:25.780 --> 00:10:27.790
as quickly as possible.

00:10:27.790 --> 00:10:32.240
Now with more on how to make
your applications faster and

00:10:32.240 --> 00:10:34.090
more secure, I'll turn to Jon.

00:10:38.390 --> 00:10:39.660
JON BOEKENOOGEN: Thank
you, John.

00:10:39.660 --> 00:10:42.030
I want to start off by asking,
how many of you have used a

00:10:42.030 --> 00:10:44.810
commerce application and
encountered a loading screen

00:10:44.810 --> 00:10:48.710
that took a very long
time to complete?

00:10:48.710 --> 00:10:50.520
And how many of you, after
encountering that loading

00:10:50.520 --> 00:10:53.680
screen, either exited out of
the application or never

00:10:53.680 --> 00:10:56.410
completed your transaction?

00:10:56.410 --> 00:10:57.680
A lot of you.

00:10:57.680 --> 00:10:59.920
As you look around the room,
you can see that this is a

00:10:59.920 --> 00:11:02.420
major contributing factor
to today's mobile cart

00:11:02.420 --> 00:11:03.670
abandonment rate.

00:11:03.670 --> 00:11:05.280
And today, I'm going to provide
some tips on how to

00:11:05.280 --> 00:11:07.980
make a good first impression
on your users and how to

00:11:07.980 --> 00:11:11.950
improve the responsiveness of
your application once a user

00:11:11.950 --> 00:11:13.200
has launched it.

00:11:16.490 --> 00:11:20.120
125 milliseconds.

00:11:20.120 --> 00:11:23.530
That is the time it takes from
when Instant Buy is launched

00:11:23.530 --> 00:11:26.310
to when the user can
interact with it.

00:11:26.310 --> 00:11:27.615
There's no loading dialogue.

00:11:27.615 --> 00:11:29.450
A user can select a
shipping address.

00:11:29.450 --> 00:11:31.200
They can select a credit card.

00:11:31.200 --> 00:11:34.050
They can complete their
transaction.

00:11:34.050 --> 00:11:36.170
We accomplish this by using
a technique known

00:11:36.170 --> 00:11:39.390
as On Device Caching.

00:11:39.390 --> 00:11:41.470
What you do here is you look for
that data you're going to

00:11:41.470 --> 00:11:44.340
display on your first activity,
store it on the

00:11:44.340 --> 00:11:47.850
device before your activity is
launched, so that way, the

00:11:47.850 --> 00:11:50.910
next time your activity is
launched, you can populate the

00:11:50.910 --> 00:11:53.725
UI from disk and provide a very
responsive experience for

00:11:53.725 --> 00:11:56.440
your users.

00:11:56.440 --> 00:11:58.610
Our team has found that caching
data that changes

00:11:58.610 --> 00:12:01.770
infrequently is very good for
this technique, since it has a

00:12:01.770 --> 00:12:04.120
low synchronization
requirements.

00:12:04.120 --> 00:12:06.690
And more specifically, we use
it for loading our chooser

00:12:06.690 --> 00:12:10.010
dialogue with shipping addresses
and mass credit card

00:12:10.010 --> 00:12:13.783
info that's shown when we
launch Instant Buy.

00:12:17.860 --> 00:12:19.630
However, there are some
challenges that come up with

00:12:19.630 --> 00:12:20.545
this technique.

00:12:20.545 --> 00:12:22.290
You need to know where you're
going to store this

00:12:22.290 --> 00:12:25.050
information on the device,
how often you're going to

00:12:25.050 --> 00:12:28.691
synchronize data from the Cloud
to the device, and how

00:12:28.691 --> 00:12:29.900
to handle any cache

00:12:29.900 --> 00:12:32.830
inconsistencies that may occur.

00:12:32.830 --> 00:12:34.740
With storage, if you're going
to store any sensitive

00:12:34.740 --> 00:12:38.080
information about the user or
your application, you need to

00:12:38.080 --> 00:12:39.700
make sure that only your
app can read and

00:12:39.700 --> 00:12:41.930
write to this file.

00:12:41.930 --> 00:12:44.640
A popular place that people
like to store info on the

00:12:44.640 --> 00:12:48.040
device is the SD card, due
to its large capacity.

00:12:48.040 --> 00:12:51.930
But any app on the device can
read and write to the SD card

00:12:51.930 --> 00:12:53.260
with the appropriate
permission.

00:12:53.260 --> 00:12:57.390
So you shouldn't put sensitive
info there.

00:12:57.390 --> 00:12:59.750
Once you start synchronizing
data from the Cloud to your

00:12:59.750 --> 00:13:02.230
device, you need to be able to
handle any merge conflicts

00:13:02.230 --> 00:13:03.450
that may come up.

00:13:03.450 --> 00:13:05.500
Think about how this is going
to impact your user's

00:13:05.500 --> 00:13:08.340
experience, if you're going to
provide any messaging about

00:13:08.340 --> 00:13:11.420
what's going on.

00:13:11.420 --> 00:13:14.370
And then with synchronization,
the frequency that you

00:13:14.370 --> 00:13:17.210
synchronize data from the Cloud
to the device really

00:13:17.210 --> 00:13:19.780
depends on your application and
the freshness of data that

00:13:19.780 --> 00:13:21.530
your app requires.

00:13:21.530 --> 00:13:24.490
But you should consider how this
synchronization strategy

00:13:24.490 --> 00:13:26.910
will impact your user's
battery life and

00:13:26.910 --> 00:13:28.870
their network usage.

00:13:28.870 --> 00:13:32.200
These are limited resources on
any smartphone or tablet.

00:13:32.200 --> 00:13:34.250
And if you abuse them, a
user may uninstall your

00:13:34.250 --> 00:13:35.500
application.

00:13:39.170 --> 00:13:43.220
So now I'm going to dive into
an example of a cache for

00:13:43.220 --> 00:13:46.260
shipping addresses using
Shared Preferences.

00:13:46.260 --> 00:13:48.840
Here I've created an address
store class.

00:13:48.840 --> 00:13:50.630
In the Constructor, we're
grabbing a handle to Shared

00:13:50.630 --> 00:13:51.330
Preferences.

00:13:51.330 --> 00:13:53.570
We're specifying Context
Mode, Private.

00:13:53.570 --> 00:13:56.330
Since shipping addresses are
sensitive information about a

00:13:56.330 --> 00:13:59.080
user, this makes sure that only
my app can read and write

00:13:59.080 --> 00:14:02.210
to this file.

00:14:02.210 --> 00:14:03.700
Next, we have the getAddresses
method.

00:14:03.700 --> 00:14:05.590
This'll simply convert from
the strings in Shared

00:14:05.590 --> 00:14:08.850
Preferences to address
objects.

00:14:08.850 --> 00:14:11.010
Finally, we have the
writeAddresses method, which

00:14:11.010 --> 00:14:14.610
will convert a list of addresses
to strings to store

00:14:14.610 --> 00:14:16.190
in Shared Preferences.

00:14:16.190 --> 00:14:18.080
Here I'm using the compatibility
library for

00:14:18.080 --> 00:14:19.240
performing the write.

00:14:19.240 --> 00:14:21.180
So on newer versions
of Android,

00:14:21.180 --> 00:14:23.930
it'll be more efficient.

00:14:23.930 --> 00:14:27.330
So that's how to make
a good first

00:14:27.330 --> 00:14:28.230
impression on your users.

00:14:28.230 --> 00:14:31.600
Now let's make a lasting one.

00:14:31.600 --> 00:14:34.250
So for this, we use the
technique we call prefetching

00:14:34.250 --> 00:14:36.580
or precomputing data.

00:14:36.580 --> 00:14:38.700
What you do here is you should
look for instances in your

00:14:38.700 --> 00:14:42.950
application where you perform
an expensive operation after

00:14:42.950 --> 00:14:46.380
an event or a user action,
such as a button click.

00:14:46.380 --> 00:14:48.580
Try and move these up
earlier in the flow.

00:14:48.580 --> 00:14:52.130
Perform them asynchronously once
you know all the inputs.

00:14:52.130 --> 00:14:54.590
So that way, when that event is
fired, you can return the

00:14:54.590 --> 00:14:57.300
result immediately.

00:14:57.300 --> 00:14:58.960
Our team specifically
uses this for

00:14:58.960 --> 00:15:01.110
prefetching auth tokens.

00:15:01.110 --> 00:15:03.410
So that way, when a user clicks
the Submit button on

00:15:03.410 --> 00:15:07.110
the bottom of the form, we can
just call the Wallet servers,

00:15:07.110 --> 00:15:09.330
rather than having to fetch the
auth token and then call

00:15:09.330 --> 00:15:11.080
the Wallet servers.

00:15:11.080 --> 00:15:13.860
And after doing this, we
were able to reduce

00:15:13.860 --> 00:15:19.540
our latency by 30%.

00:15:19.540 --> 00:15:20.340
Again, there are some

00:15:20.340 --> 00:15:22.420
challenges with this technique.

00:15:22.420 --> 00:15:24.530
You shouldn't be using this for
any requests that modify

00:15:24.530 --> 00:15:28.710
state about the user, such as
adding a shipping address.

00:15:28.710 --> 00:15:32.840
These types of operations make
modifications on data that is

00:15:32.840 --> 00:15:34.350
near and dear to the user.

00:15:34.350 --> 00:15:36.460
And doing it without their
explicit consent or button

00:15:36.460 --> 00:15:38.110
click is not within their
expectations.

00:15:40.860 --> 00:15:43.200
And second, a further
optimization you can perform

00:15:43.200 --> 00:15:44.640
with this technique
is what we call

00:15:44.640 --> 00:15:46.990
handling the pending state.

00:15:46.990 --> 00:15:49.900
Imagine you fire off a prefetch
request, and then

00:15:49.900 --> 00:15:52.540
that event that requires the
response is triggered while

00:15:52.540 --> 00:15:55.210
that request is ongoing.

00:15:55.210 --> 00:15:58.270
Rather than firing a duplicate
request and starting over from

00:15:58.270 --> 00:16:00.985
scratch, you should wait till
the prefetch request completes

00:16:00.985 --> 00:16:03.140
and return that result.

00:16:03.140 --> 00:16:05.395
This will further reduce the
loading dialogue in this case.

00:16:08.510 --> 00:16:11.180
So now I'm going to jump into
an example of actually

00:16:11.180 --> 00:16:16.140
prefetching an auth token
for a Google server.

00:16:16.140 --> 00:16:18.470
Here I've defined the prefetch
auth token method.

00:16:18.470 --> 00:16:22.160
We're going to kick
off an AsyncTask.

00:16:22.160 --> 00:16:25.690
Call off to GoogleAuthUtil to
actually fetch the token.

00:16:25.690 --> 00:16:28.030
This'll store the token on disk,
so future calls will

00:16:28.030 --> 00:16:30.440
read from disk rather than
hitting the network.

00:16:30.440 --> 00:16:33.060
For those that are wondering,
GoogleAuthUtil is also part of

00:16:33.060 --> 00:16:36.010
Google Play services and could
be used for fetching tokens

00:16:36.010 --> 00:16:37.260
for things like App Engine.

00:16:40.760 --> 00:16:43.070
After that, we need to hook
up the prefetch auth token

00:16:43.070 --> 00:16:46.750
method, after our
UI's displayed.

00:16:46.750 --> 00:16:48.500
And finally, we need
to use that token.

00:16:48.500 --> 00:16:50.960
Here we're doing it in
anonClickHandler.

00:16:50.960 --> 00:16:53.000
We're going to fire off
another AsyncTask.

00:16:53.000 --> 00:16:53.810
Read the token.

00:16:53.810 --> 00:16:55.440
This time, it should
come from disk.

00:16:55.440 --> 00:16:58.720
And we're going to
call our server.

00:16:58.720 --> 00:17:00.520
Now some of you may notice that
I don't have the Pending

00:17:00.520 --> 00:17:02.740
state being handled
on this slide.

00:17:02.740 --> 00:17:04.260
And it was just too
much to fit.

00:17:04.260 --> 00:17:06.740
I will be sending out a full
working example with the deck.

00:17:11.380 --> 00:17:14.270
So now I'm going to jump into
some security and privacy

00:17:14.270 --> 00:17:17.220
techniques that you can use
in your application.

00:17:17.220 --> 00:17:19.930
Security and privacy is one of
those unseen user experience

00:17:19.930 --> 00:17:23.092
features of any commerce
application.

00:17:23.092 --> 00:17:25.700
And I'm going to provide some
quick tips to make sure that

00:17:25.700 --> 00:17:29.350
you are handling your user's
information more safely and

00:17:29.350 --> 00:17:32.915
how to maintain that trusting
relationship with your users.

00:17:36.280 --> 00:17:38.590
So first and foremost, if you're
sending any sensitive

00:17:38.590 --> 00:17:40.800
information about your
user or your

00:17:40.800 --> 00:17:42.820
application to a remote server--

00:17:42.820 --> 00:17:44.220
this is something that
all of you commerce

00:17:44.220 --> 00:17:46.100
developers should be doing--

00:17:46.100 --> 00:17:47.850
you need to make sure
that it's encrypted.

00:17:47.850 --> 00:17:50.640
And we suggest HTTPS for this.

00:17:50.640 --> 00:17:52.960
If you don't do this, a
malicious software or a

00:17:52.960 --> 00:17:55.540
malicious user could view this
data over the network and

00:17:55.540 --> 00:17:56.790
perform fraudulent activities.

00:18:00.420 --> 00:18:02.430
Another thing you should
consider is data that you're

00:18:02.430 --> 00:18:04.650
sending to Logcat.

00:18:04.650 --> 00:18:09.660
On pre-Jelly-Bean devices, any
app on the phone can read any

00:18:09.660 --> 00:18:11.910
other app's logs, as long as
they have the get logs'

00:18:11.910 --> 00:18:13.770
permission.

00:18:13.770 --> 00:18:16.640
From there, they can send these
logs to a remote server,

00:18:16.640 --> 00:18:18.950
parse out pieces that they're
interested in, and

00:18:18.950 --> 00:18:20.200
do what they want.

00:18:22.080 --> 00:18:25.640
So our team uses Proguard
to not only optimize our

00:18:25.640 --> 00:18:29.300
application but also
strip logging.

00:18:29.300 --> 00:18:31.250
And the reason we chose Proguard
is it doesn't require

00:18:31.250 --> 00:18:34.550
any code modifications and can
easily be done on release

00:18:34.550 --> 00:18:37.170
builds before uploading
to the Play Store.

00:18:37.170 --> 00:18:40.520
This comes in two steps.

00:18:40.520 --> 00:18:43.140
First, you need to enable
Proguard optimizations for

00:18:43.140 --> 00:18:44.290
your application.

00:18:44.290 --> 00:18:46.340
This is done by adding
this one line to your

00:18:46.340 --> 00:18:47.610
project.properties file.

00:18:50.310 --> 00:18:52.930
And second, you need to tell
Projuard which method calls to

00:18:52.930 --> 00:18:54.740
remove from your app.

00:18:54.740 --> 00:18:58.840
Here we're removing
android.util.log i, v, and d.

00:18:58.840 --> 00:19:02.080
And this is done by using this
assumenosideeffects clause.

00:19:02.080 --> 00:19:04.800
When paired with Proguard
optimizations, Proguard will

00:19:04.800 --> 00:19:07.500
treat these method calls as
NoOps and completely remove

00:19:07.500 --> 00:19:08.750
them from your app.

00:19:12.790 --> 00:19:16.230
So that concludes some of the
tips that the Instant Buy team

00:19:16.230 --> 00:19:20.850
used for improving our users'
experience and their safety.

00:19:20.850 --> 00:19:23.160
I'm going to hand it off to
Haisoo from The Fancy, and

00:19:23.160 --> 00:19:24.900
he's going to tell you how
they wowed their users.

00:19:28.020 --> 00:19:29.270
HAISOO SHIN: Thank you.

00:19:31.450 --> 00:19:35.890
So The Fancy is the place to
discover and collect from a

00:19:35.890 --> 00:19:39.270
Cloud-created catalog of unique
and amazing things.

00:19:39.270 --> 00:19:42.010
Here you will find all these
beautiful gadgets, fashion

00:19:42.010 --> 00:19:45.200
items, traveling spots, and many
more, and you can fancy

00:19:45.200 --> 00:19:46.770
anything you like.

00:19:46.770 --> 00:19:48.780
And when you find something you
like, you'll want to buy

00:19:48.780 --> 00:19:50.320
and own them as well.

00:19:50.320 --> 00:19:54.950
So at Fancy, whether a $5
keyring, $3,000 watch, or even

00:19:54.950 --> 00:19:59.520
$3 million helicopter, you can
buy them right inside our app.

00:19:59.520 --> 00:20:04.310
So my focus is to provide a
frictionless experience from

00:20:04.310 --> 00:20:05.900
signup to checkout.

00:20:05.900 --> 00:20:08.950
And the Google API has really
helped us achieve that on

00:20:08.950 --> 00:20:10.370
Android platform.

00:20:10.370 --> 00:20:12.210
So I'm going to dive right
into demo and show

00:20:12.210 --> 00:20:13.656
you how we did it.

00:20:16.990 --> 00:20:20.120
Let's start with signin.

00:20:20.120 --> 00:20:21.790
So this is the first
screen you see when

00:20:21.790 --> 00:20:23.420
you launch our app.

00:20:23.420 --> 00:20:25.590
I'm going to show you how Google
Signin works and press

00:20:25.590 --> 00:20:26.580
that button.

00:20:26.580 --> 00:20:28.800
So we were one of the
[INAUDIBLE] to partner to

00:20:28.800 --> 00:20:31.520
implement this, and the adoption
has been so much

00:20:31.520 --> 00:20:33.520
faster than expected.

00:20:33.520 --> 00:20:35.370
One of the reasons must be this
screen, which you see

00:20:35.370 --> 00:20:35.870
right there.

00:20:35.870 --> 00:20:38.890
Because here you can see exactly
what information of

00:20:38.890 --> 00:20:41.730
you we will have access to.

00:20:41.730 --> 00:20:43.650
And I'm just going
to press OK here.

00:20:43.650 --> 00:20:46.500
But you can actually fine-tune
all these privacy settings and

00:20:46.500 --> 00:20:49.500
really control your data.

00:20:49.500 --> 00:20:52.510
So you can see how this is great
for users who are more

00:20:52.510 --> 00:20:54.590
sensitive about their privacy.

00:20:54.590 --> 00:20:55.930
Now you're signed in.

00:20:55.930 --> 00:20:58.840
So as you can see,
it's fast, easy.

00:20:58.840 --> 00:21:00.320
It's very transparent.

00:21:00.320 --> 00:21:04.320
And it has all the cool
features, like this morning at

00:21:04.320 --> 00:21:07.710
the keynote, over at the
[INAUDIBLE] store and

00:21:07.710 --> 00:21:10.150
cross-platform authentication.

00:21:10.150 --> 00:21:13.590
And finally, users just
tend to trust Google.

00:21:13.590 --> 00:21:15.440
So it's a great way
to reduce friction

00:21:15.440 --> 00:21:18.160
from your signup process.

00:21:18.160 --> 00:21:20.610
And it also plays well
with Google Wallet.

00:21:20.610 --> 00:21:24.500
So let's see if there's anything
I might want to buy.

00:21:24.500 --> 00:21:27.580
Everything looks great.

00:21:27.580 --> 00:21:29.530
This one looks particularly
good.

00:21:29.530 --> 00:21:32.730
So I'm just going to open
up the item page.

00:21:32.730 --> 00:21:35.680
And one of the exciting features
we have introduced

00:21:35.680 --> 00:21:38.360
together with Google Wallet is
this Buy Now button you see at

00:21:38.360 --> 00:21:40.180
the item page.

00:21:40.180 --> 00:21:42.850
As the name suggests, it'll
skip all the intermediate

00:21:42.850 --> 00:21:45.190
steps, like the Cart page,
and goes right

00:21:45.190 --> 00:21:46.580
into the payment flow.

00:21:46.580 --> 00:21:48.470
So I'll show you how it works.

00:21:48.470 --> 00:21:51.520
Press this button.

00:21:51.520 --> 00:21:54.140
And very quickly you will be
prompted with this Google

00:21:54.140 --> 00:21:55.010
Wallet dialog.

00:21:55.010 --> 00:21:57.560
Where your information is
already filled out from other

00:21:57.560 --> 00:21:59.400
services or Google services.

00:21:59.400 --> 00:22:02.380
And notice that there's this
little checkbox there.

00:22:02.380 --> 00:22:07.320
And what this does is you're
saying you approve to use

00:22:07.320 --> 00:22:12.170
Google Wallet at Fancy
for future purchases.

00:22:12.170 --> 00:22:14.320
So you won't see this
dialog again when

00:22:14.320 --> 00:22:15.695
you buy from us again.

00:22:15.695 --> 00:22:18.920
I'm just going to
press Continue.

00:22:18.920 --> 00:22:22.520
And you're already at the last
stage where you can see the

00:22:22.520 --> 00:22:25.250
final process and you
can press Complete.

00:22:25.250 --> 00:22:26.770
And now you're done.

00:22:26.770 --> 00:22:29.700
So as you can see, from the item
page where I decided to

00:22:29.700 --> 00:22:33.370
buy this, I only needed
to tap three times to

00:22:33.370 --> 00:22:34.290
complete the purchase.

00:22:34.290 --> 00:22:36.390
And next time, it'll
be only two taps.

00:22:36.390 --> 00:22:38.020
So that's very amazing.

00:22:38.020 --> 00:22:41.780
And the whole Buy Now button
really works for us, because

00:22:41.780 --> 00:22:44.610
we have a great deal of
single-item orders, especially

00:22:44.610 --> 00:22:45.860
on Android.

00:22:48.510 --> 00:22:50.810
So we believe this will
be a major way for our

00:22:50.810 --> 00:22:52.370
users to buy from us.

00:22:52.370 --> 00:22:54.290
And we are very excited.

00:22:54.290 --> 00:22:57.590
Now that I just bought something
very cool, I want to

00:22:57.590 --> 00:22:59.880
brag about it to my friends
and family.

00:22:59.880 --> 00:23:01.140
So I'm going to share
it on Google+.

00:23:03.880 --> 00:23:06.210
So this is the kind of
opportunity you want to take

00:23:06.210 --> 00:23:08.390
advantage of to promote
your app and create

00:23:08.390 --> 00:23:09.580
some word of mouth.

00:23:09.580 --> 00:23:11.870
And Google+ Interactive
Posts is really the

00:23:11.870 --> 00:23:13.830
right tool for this.

00:23:13.830 --> 00:23:19.060
I'm just going to share it right
there and go back to the

00:23:19.060 --> 00:23:22.300
slide and show how that looks.

00:23:22.300 --> 00:23:25.190
So every Interactive Post, they
have something called a

00:23:25.190 --> 00:23:27.070
Call to Action button.

00:23:27.070 --> 00:23:30.240
In this case, it's
a buy button.

00:23:30.240 --> 00:23:33.530
You can name it from the long
list of button labels.

00:23:33.530 --> 00:23:37.410
And when you click this, it'll
actually then link it to our

00:23:37.410 --> 00:23:39.140
app and opens up the relevant
page, in this

00:23:39.140 --> 00:23:40.820
case the item page.

00:23:40.820 --> 00:23:43.540
If you do not have our app
installed already, then you'll

00:23:43.540 --> 00:23:46.910
be taken to Google Play Store
page, where you can install

00:23:46.910 --> 00:23:48.120
it, launch it.

00:23:48.120 --> 00:23:50.820
And you can sign in,
and you'll still be

00:23:50.820 --> 00:23:52.620
taken to the item page.

00:23:52.620 --> 00:23:55.300
And remember, this button is
coming from your friends and

00:23:55.300 --> 00:23:58.770
family, so this is a very
personal and effective way to

00:23:58.770 --> 00:24:00.910
promote your app.

00:24:00.910 --> 00:24:02.980
And we are seeing very
[INAUDIBLE] rates of this

00:24:02.980 --> 00:24:05.140
button on Android.

00:24:05.140 --> 00:24:07.560
But the bigger picture I'm
trying to show you through

00:24:07.560 --> 00:24:11.870
this demo is that with this tool
you can achieve a viral

00:24:11.870 --> 00:24:16.560
cycle where discovery converts
into purchase with minimum

00:24:16.560 --> 00:24:19.495
friction, and purchase brings
in more discoveries.

00:24:23.860 --> 00:24:26.260
Now we are going to share some
other tips we have learned

00:24:26.260 --> 00:24:28.570
from our own experience
at Fancy.

00:24:28.570 --> 00:24:30.520
We have a very international
user base.

00:24:30.520 --> 00:24:32.140
We have orders from all
over the world.

00:24:32.140 --> 00:24:34.150
And here are some of the things
you might want to

00:24:34.150 --> 00:24:36.550
consider for your international
users.

00:24:36.550 --> 00:24:39.967
So most of you must be used to
the form where the country is

00:24:39.967 --> 00:24:42.460
placed at the left after
the state box.

00:24:42.460 --> 00:24:46.090
But really, you want to reverse
them, because state

00:24:46.090 --> 00:24:48.190
box actually depends
on the country.

00:24:48.190 --> 00:24:52.730
So if you have United States
selected, it will be a usual

00:24:52.730 --> 00:24:54.570
dropbox with state.

00:24:54.570 --> 00:24:59.070
And if it's Canada, you'll be
prompted with a dropbox with a

00:24:59.070 --> 00:25:00.240
list of provinces.

00:25:00.240 --> 00:25:02.560
For some other countries, maybe
you want to fall back to

00:25:02.560 --> 00:25:06.590
a plain textbox, which
can be optional.

00:25:06.590 --> 00:25:08.460
And postal code,
it looks easy.

00:25:08.460 --> 00:25:10.470
But I made the mistake
of assuming

00:25:10.470 --> 00:25:11.950
they are always numbers.

00:25:11.950 --> 00:25:16.060
And I made our postal code
box number only.

00:25:16.060 --> 00:25:18.080
And it turns out some countries,
like the United

00:25:18.080 --> 00:25:20.280
Kingdom or Canada, they
also use letters.

00:25:20.280 --> 00:25:23.240
So I actually prevented some
users from placing

00:25:23.240 --> 00:25:24.530
an order from us.

00:25:24.530 --> 00:25:28.510
So you do not want to make
the same mistake.

00:25:28.510 --> 00:25:31.570
Now you, of course, want to
localize your app for your

00:25:31.570 --> 00:25:32.380
international users.

00:25:32.380 --> 00:25:35.750
But you have to remember, once
you do that, people will start

00:25:35.750 --> 00:25:38.510
to enter their addresses
in their own languages.

00:25:38.510 --> 00:25:41.990
So make sure your apps, your
backend codes, and even your

00:25:41.990 --> 00:25:45.270
logistic teams are ready
to handle that.

00:25:45.270 --> 00:25:47.970
Finally, we found out it's a
very good idea to predict the

00:25:47.970 --> 00:25:52.040
user's country and present
that as a default.

00:25:52.040 --> 00:25:55.760
It sounds minor and trivial,
but it's not just about

00:25:55.760 --> 00:25:58.630
eliminating the pain to go
through hundreds of countries

00:25:58.630 --> 00:25:59.900
just to find your own.

00:25:59.900 --> 00:26:02.540
But it's also about sending out
the message that you are

00:26:02.540 --> 00:26:04.800
able to handle their
orders correctly.

00:26:04.800 --> 00:26:07.930
Because when I buy something
internationally, I tend to be

00:26:07.930 --> 00:26:09.280
cautious, and I get worried.

00:26:09.280 --> 00:26:10.980
Do they even ship
to my country?

00:26:10.980 --> 00:26:12.960
Or what about the import tax?

00:26:12.960 --> 00:26:13.780
Stuff like that.

00:26:13.780 --> 00:26:16.810
But when I see my country
selected when I open up the

00:26:16.810 --> 00:26:20.030
form, it gives me a certain
degree of confidence.

00:26:20.030 --> 00:26:23.140
So there are a couple
of ways to do that.

00:26:23.140 --> 00:26:28.810
The most accurate and fastest
way to do it is pull it from

00:26:28.810 --> 00:26:33.740
the carrier using this class
called TelephonyManager.

00:26:33.740 --> 00:26:37.990
It's accurate and fast, but
it's not always available.

00:26:37.990 --> 00:26:40.990
A few carriers or Wi-Fi-only
devices, you wouldn't have

00:26:40.990 --> 00:26:42.430
this information available.

00:26:42.430 --> 00:26:45.780
So make sure your fall back to
the Local settings, which is

00:26:45.780 --> 00:26:47.890
linked to your Languages
setting, so it'll won't be

00:26:47.890 --> 00:26:48.910
always accurate.

00:26:48.910 --> 00:26:52.310
But it's always available, so
you can fall back to that.

00:26:52.310 --> 00:26:55.680
If your app happens to be using
the user's location info

00:26:55.680 --> 00:26:58.040
for some other reason, you
could also use that.

00:26:58.040 --> 00:27:00.620
And you could also do
the GeoIP lookup.

00:27:04.530 --> 00:27:07.910
So now that on the mobile
environment you know that even

00:27:07.910 --> 00:27:10.790
a single button click can cause
a significant latency

00:27:10.790 --> 00:27:13.970
and friction, you want to avoid
that as much as you can

00:27:13.970 --> 00:27:17.790
by predicting what a user
is going to do early.

00:27:17.790 --> 00:27:20.790
One obvious example is payment
and shipping address, because

00:27:20.790 --> 00:27:23.880
you know they will use the
same one in most cases.

00:27:23.880 --> 00:27:27.040
So you can precalculate tax and
shipping and show that at

00:27:27.040 --> 00:27:29.490
an early stage, like
the Cart page.

00:27:29.490 --> 00:27:32.500
And you can let them pay with
their last credit card without

00:27:32.500 --> 00:27:35.700
going through additional steps,
like the Payment page.

00:27:35.700 --> 00:27:38.430
Of course, they should be
presented with a chance to

00:27:38.430 --> 00:27:40.790
change it at some point
during the process.

00:27:40.790 --> 00:27:44.520
But my point here is that you do
not want to make your users

00:27:44.520 --> 00:27:49.540
move their finger just to do
something you can anticipate.

00:27:49.540 --> 00:27:50.350
That's it from me.

00:27:50.350 --> 00:27:54.770
And I'll hand the stage
back to John.

00:27:54.770 --> 00:27:55.805
JOHN STUPPY: Thank
you, Haisoo.

00:27:55.805 --> 00:27:58.410
We were very excited to work
with Fancy on integrating

00:27:58.410 --> 00:28:00.050
Instant Buy into their
application.

00:28:00.050 --> 00:28:02.730
It's available today on the Play
Store, and I encourage

00:28:02.730 --> 00:28:03.260
you to check it out.

00:28:03.260 --> 00:28:04.130
It's very cool.

00:28:04.130 --> 00:28:05.500
There are some very unique
items on there.

00:28:08.070 --> 00:28:10.470
So let's wrap up.

00:28:10.470 --> 00:28:13.730
Today we discussed how using
Google Wallet Instant Buy can

00:28:13.730 --> 00:28:16.420
improve conversion on your
site by eliminating or

00:28:16.420 --> 00:28:20.550
reducing a lot of the pain
that users experience in

00:28:20.550 --> 00:28:22.420
checking out of payment
applications.

00:28:25.330 --> 00:28:28.300
We leveraged a lot of cool
mobile-friendly form

00:28:28.300 --> 00:28:31.150
technology, such as real time
formatting, instant

00:28:31.150 --> 00:28:34.600
validation, auto advancing
form fields, and input

00:28:34.600 --> 00:28:35.980
suggestions.

00:28:35.980 --> 00:28:37.550
And these are things that
you can do in your own

00:28:37.550 --> 00:28:38.800
applications as well.

00:28:42.430 --> 00:28:45.260
Further, we mentioned how
on device caching and

00:28:45.260 --> 00:28:48.240
precomputing and fetching data
before it's needed can help

00:28:48.240 --> 00:28:51.040
with that first impression on
the user's mind as well as

00:28:51.040 --> 00:28:53.950
their lasting impression as
they use your app and

00:28:53.950 --> 00:28:56.540
learn to love it.

00:28:56.540 --> 00:29:01.620
We also stressed how handling
user data safely is a very

00:29:01.620 --> 00:29:05.220
large concern, because it
instills a degree of trust in

00:29:05.220 --> 00:29:08.450
your users that encourages
them to buy with your

00:29:08.450 --> 00:29:10.940
applications.

00:29:10.940 --> 00:29:13.690
Haisoo mentioned how leveraging
the Google+ Sign In

00:29:13.690 --> 00:29:17.300
has helped Fancy with Android
developers, signing them into

00:29:17.300 --> 00:29:20.630
the application and getting
them started.

00:29:20.630 --> 00:29:22.850
He also mentioned a number of
international tips that you

00:29:22.850 --> 00:29:25.320
should be aware of to be
more accessible in

00:29:25.320 --> 00:29:26.570
international markets.

00:29:28.900 --> 00:29:31.510
So where can you go from here?

00:29:31.510 --> 00:29:33.680
You can sign up for
Instant Buy at

00:29:33.680 --> 00:29:34.930
getinstantbuy.withgoogle.com.

00:29:37.585 --> 00:29:40.900
There will be an Instant Buy
Code Lab on Friday at 9:00 AM

00:29:40.900 --> 00:29:43.130
with our colleagues, in which
you'll go through the

00:29:43.130 --> 00:29:45.700
integration process of
Instant Buy into a

00:29:45.700 --> 00:29:48.640
sample merchant app.

00:29:48.640 --> 00:29:50.870
Also, there will be Wallet
office hours and a Developer

00:29:50.870 --> 00:29:52.940
Sandbox on the second floor.

00:29:52.940 --> 00:29:55.820
In addition, Fancy will be at
the Google+ Developer Sandbox,

00:29:55.820 --> 00:29:58.050
also located on the
second floor.

00:29:58.050 --> 00:30:00.670
And again, I encourage you to
check out Fancy with Instant

00:30:00.670 --> 00:30:04.140
Buy on the Play Store,
available today.

00:30:04.140 --> 00:30:05.410
So thank you very much.

00:30:05.410 --> 00:30:09.110
I'll now invite our Product
Manager up, Prakash, to help

00:30:09.110 --> 00:30:10.680
answer some questions.

00:30:10.680 --> 00:30:11.930
Are there any questions?

00:30:15.696 --> 00:30:18.660
JON BOEKENOOGEN: Please
go to the mic.

00:30:18.660 --> 00:30:19.170
JOHN STUPPY: Oh, and
please go to the

00:30:19.170 --> 00:30:20.420
mic, if you have questions.

00:30:23.836 --> 00:30:26.590
We've got one.

00:30:26.590 --> 00:30:27.710
AUDIENCE: Just wondering
if this works on the

00:30:27.710 --> 00:30:30.842
mobile web at all?

00:30:30.842 --> 00:30:31.640
Is this strictly--

00:30:31.640 --> 00:30:34.611
JOHN STUPPY: So does this
work on mobile web?

00:30:34.611 --> 00:30:35.110
PRAKASH HARIRAMANI: Yeah.

00:30:35.110 --> 00:30:38.930
So we have a similar solution
which has been public.

00:30:38.930 --> 00:30:40.670
You can go to our
Developer page.

00:30:40.670 --> 00:30:42.350
And essentially, we have
Instant Buy for

00:30:42.350 --> 00:30:43.420
mobile web and apps.

00:30:43.420 --> 00:30:45.580
What we announced today was
Instant Buy for mobile apps.

00:30:45.580 --> 00:30:48.166
Instant Buy for mobile web has
been live since last fall.

00:30:48.166 --> 00:30:48.642
AUDIENCE: OK.

00:30:48.642 --> 00:30:49.120
Cool.

00:30:49.120 --> 00:30:50.476
Thanks.

00:30:50.476 --> 00:30:50.970
AUDIENCE: Yeah.

00:30:50.970 --> 00:30:53.580
We're always having to be
cognizant of accessibility.

00:30:53.580 --> 00:30:56.410
And I was wondering, with your
auto advancing features, how

00:30:56.410 --> 00:30:57.660
does that play with
accessibility?

00:31:04.000 --> 00:31:06.110
JOHN STUPPY: So how does auto
advancing play with

00:31:06.110 --> 00:31:07.360
accessibility?

00:31:13.140 --> 00:31:14.420
Can you go to Prakash
on this one?

00:31:14.420 --> 00:31:14.710
PRAKASH HARIRAMANI: OK.

00:31:14.710 --> 00:31:20.890
So basically, with the auto
advancement, because it's very

00:31:20.890 --> 00:31:24.690
intuitive, it's less input
required by the user.

00:31:24.690 --> 00:31:27.470
It basically guides our user
to a flow, so it helps with

00:31:27.470 --> 00:31:31.350
the accessibility challenge,
if you will.

00:31:31.350 --> 00:31:33.560
AUDIENCE: Does it announce the
fields as you march through

00:31:33.560 --> 00:31:37.030
them or allow you to read back
what you've entered?

00:31:37.030 --> 00:31:37.900
I can't see.

00:31:37.900 --> 00:31:40.780
And so I've just entered a
credit card number, and I need

00:31:40.780 --> 00:31:42.750
to be able to validate it.

00:31:42.750 --> 00:31:45.290
Validation errors,
do they get read?

00:31:45.290 --> 00:31:47.350
I'm just wondering if that's
something that you have to

00:31:47.350 --> 00:31:51.200
roll yourself or
how that works.

00:31:51.200 --> 00:31:51.550
JON BOEKENOOGEN: Yes.

00:31:51.550 --> 00:31:54.540
As it progresses through the
form, it will read out the

00:31:54.540 --> 00:31:57.700
description of what the field
is based on the hint text.

00:31:57.700 --> 00:32:00.120
And if there's an error that
comes up, it will also speak

00:32:00.120 --> 00:32:01.432
what the error is.

00:32:01.432 --> 00:32:01.780
AUDIENCE: Cool.

00:32:01.780 --> 00:32:03.030
Thank you.

00:32:06.190 --> 00:32:07.440
JON BOEKENOOGEN: Any
other questions?

00:32:12.930 --> 00:32:13.390
All right.

00:32:13.390 --> 00:32:13.850
JOHN STUPPY: Great.

00:32:13.850 --> 00:32:15.100
JON BOEKENOOGEN: Well, thank
you all for coming.

