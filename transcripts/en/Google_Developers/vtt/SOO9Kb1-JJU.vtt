WEBVTT
Kind: captions
Language: en

00:00:00.130 --> 00:00:00.450
MALE SPEAKER: OK.

00:00:00.450 --> 00:00:04.440
Our third panel is going to be
about testing and tooling.

00:00:04.440 --> 00:00:07.700
And our moderator is
Todd Anglin, who's

00:00:07.700 --> 00:00:08.900
executive VP at Telerik.

00:00:08.900 --> 00:00:12.360
They produce tools
for developers

00:00:12.360 --> 00:00:13.690
and developer teams.

00:00:13.690 --> 00:00:17.140
You might know him best for
Kendo UI, and I've seen him.

00:00:17.140 --> 00:00:18.810
So take it away, Todd.

00:00:18.810 --> 00:00:19.340
TODD ANGLIN: Great.

00:00:19.340 --> 00:00:22.510
So I am strictly the time
keeper up here.

00:00:22.510 --> 00:00:25.240
Telerik obviously creates a lot
of tools, but I think our

00:00:25.240 --> 00:00:27.910
panel, which is quite diverse
today has the full

00:00:27.910 --> 00:00:29.310
perspective.

00:00:29.310 --> 00:00:34.120
We've got about six questions
total in the moderating queue.

00:00:34.120 --> 00:00:37.190
So we'll probably start there
to kick it off, but I

00:00:37.190 --> 00:00:38.990
definitely want to make this
as interactive as possible.

00:00:38.990 --> 00:00:41.830
I know we're starting to stand
between you guys and alcohol,

00:00:41.830 --> 00:00:44.270
which is always a great
place to be.

00:00:44.270 --> 00:00:46.370
So to kick it off, I will
let the panel introduce

00:00:46.370 --> 00:00:47.010
themselves.

00:00:47.010 --> 00:00:49.090
I was introduced Todd Anglin,
work with Telerik, you guys

00:00:49.090 --> 00:00:50.800
known as Kendo UI, but I'll
let the panel introduce

00:00:50.800 --> 00:00:53.390
themselves.

00:00:53.390 --> 00:00:54.700
PAVEL FELDMAN: I'm Peter
Beverl-- oh no.

00:00:54.700 --> 00:00:55.810
Sorry.

00:00:55.810 --> 00:00:58.310
I'm Pavel Feldman, software
engineer working on Chrome

00:00:58.310 --> 00:01:00.080
Developer Tools.

00:01:00.080 --> 00:01:01.320
YEHUDA KATZ: Hey, I'm Yehuda.

00:01:01.320 --> 00:01:04.980
I work on Ember mostly these
days I've historically worked

00:01:04.980 --> 00:01:07.785
on jQuery and Rails.

00:01:07.785 --> 00:01:10.010
ANTON KOVALYOV: Hey,
I'm Anton Kovalyov.

00:01:10.010 --> 00:01:10.650
I work at Mozilla.

00:01:10.650 --> 00:01:13.710
We make a web browser and a
mobile operating system.

00:01:13.710 --> 00:01:17.526
And I work on Firefox developer
tools there.

00:01:17.526 --> 00:01:19.120
JONATHAN LIPPS: I'm Jonathan
Lipps, and I

00:01:19.120 --> 00:01:20.650
work at Sauce Labs.

00:01:20.650 --> 00:01:23.220
And this year, I've been working
on open source project

00:01:23.220 --> 00:01:26.098
for mobile automation
called Appium.

00:01:26.098 --> 00:01:27.090
BRIAN LEROUX: Hi.

00:01:27.090 --> 00:01:27.950
I'm Brian.

00:01:27.950 --> 00:01:30.430
I work on PhoneGap and
Cordova and a thing

00:01:30.430 --> 00:01:32.865
called Topcoat at Adobe.

00:01:32.865 --> 00:01:33.540
TODD ANGLIN: Very good.

00:01:33.540 --> 00:01:34.850
So very diverse panel.

00:01:34.850 --> 00:01:35.410
Guys, kick it off.

00:01:35.410 --> 00:01:38.270
First question here,
it's from Rob.

00:01:38.270 --> 00:01:41.650
And the question is basically
asking how does Google test

00:01:41.650 --> 00:01:42.860
its mobile products.

00:01:42.860 --> 00:01:46.210
So what are the things you use
to test your mobile products?

00:01:46.210 --> 00:01:48.340
But to make a bit more generic,
I think we can just

00:01:48.340 --> 00:01:48.870
open it up.

00:01:48.870 --> 00:01:50.960
How do you test your mobile
products today?

00:01:50.960 --> 00:01:53.310
What are the techniques you
use to ensure that you're

00:01:53.310 --> 00:01:55.280
delivering good mobile
experience?

00:01:55.280 --> 00:01:58.884
So we'll kick it off linear and
start here with Google.

00:01:58.884 --> 00:02:00.310
PAVEL FELDMAN: OK.

00:02:00.310 --> 00:02:04.960
so I'm working on Chrome, not
really any mobile app or web

00:02:04.960 --> 00:02:05.820
for Chrome.

00:02:05.820 --> 00:02:10.770
But we use the same tooling for
testing Chrome aggressions

00:02:10.770 --> 00:02:15.450
as our apps are using, and
that's telemetry, which

00:02:15.450 --> 00:02:17.890
applies pretty much
to everything

00:02:17.890 --> 00:02:20.050
WebGet Chrome based.

00:02:20.050 --> 00:02:22.330
It has been mentioned earlier.

00:02:22.330 --> 00:02:24.290
Check out it on the
Chromium web site.

00:02:24.290 --> 00:02:25.940
There's documentation for it.

00:02:25.940 --> 00:02:29.280
It's a lightweight script
framework with a friendly

00:02:29.280 --> 00:02:31.720
Python framework front end.

00:02:31.720 --> 00:02:35.480
It's based on remove
debugging prodigal.

00:02:35.480 --> 00:02:39.000
You can automate things there,
simple automations,

00:02:39.000 --> 00:02:40.770
navigations, scrolling.

00:02:40.770 --> 00:02:43.960
And you can capture all of the
data that Chrome dev tools can

00:02:43.960 --> 00:02:47.400
capture, all of those pages and
all of those scenarios.

00:02:47.400 --> 00:02:50.860
So you get full-fledged timeline
there, and everything

00:02:50.860 --> 00:02:51.910
is Jason based.

00:02:51.910 --> 00:02:53.470
You can analyze this data.

00:02:53.470 --> 00:02:58.120
And we are internally building
regression charts for that, a

00:02:58.120 --> 00:03:00.720
lot of birth data for each of
the commits, each of the

00:03:00.720 --> 00:03:03.720
builds we see what has
happened there.

00:03:03.720 --> 00:03:07.140
And we can go back
and [INAUDIBLE].

00:03:07.140 --> 00:03:08.450
So that's pretty simple.

00:03:08.450 --> 00:03:10.940
And that's what we expect
everybody to do.

00:03:13.766 --> 00:03:15.060
YEHUDA KATZ: Hey.

00:03:15.060 --> 00:03:19.290
So I pretty much use your
product for testing.

00:03:19.290 --> 00:03:23.920
I don't have a huge array
of physical devices and

00:03:23.920 --> 00:03:24.600
little start up.

00:03:24.600 --> 00:03:30.830
So I definitely like the test as
many pieces of hardware as

00:03:30.830 --> 00:03:33.010
I can, and you guys have
a really good group.

00:03:33.010 --> 00:03:36.800
And if I was much bigger, I
would want to have more

00:03:36.800 --> 00:03:39.580
devices to test with
but sadly enough.

00:03:43.052 --> 00:03:47.120
ANTON KOVALYOV: So I work on
Firefox for desktops, so I

00:03:47.120 --> 00:03:51.240
don't really work on actual
mobile web apps.

00:03:51.240 --> 00:03:55.900
But the closest we have, I
guess, to the testing mobile

00:03:55.900 --> 00:03:59.220
web apps would be Firefox apps,
and as far as I know we

00:03:59.220 --> 00:04:00.240
have another Mozilla here.

00:04:00.240 --> 00:04:06.680
So if I'm saying something
stupid, correct me.

00:04:06.680 --> 00:04:09.620
I think we use the same
framework as our own written

00:04:09.620 --> 00:04:12.190
framework as we use for Firefox
or desktop, which

00:04:12.190 --> 00:04:17.410
basically simulates all the
events you can have.

00:04:17.410 --> 00:04:23.160
And as all testing frameworks
out there, no offense to any

00:04:23.160 --> 00:04:26.820
framework writers, it
could be way better.

00:04:26.820 --> 00:04:32.290
And its partial our job as
well as Firefox Developer

00:04:32.290 --> 00:04:35.820
Tools engineers to
make it better.

00:04:35.820 --> 00:04:39.280
So far it's getting there.

00:04:39.280 --> 00:04:42.180
But really, unfortunately, I
don't have a better answer

00:04:42.180 --> 00:04:46.700
what we use for actual testing
our mobile web apps, if

00:04:46.700 --> 00:04:48.670
Mozilla has any mobile
web apps.

00:04:48.670 --> 00:04:49.490
JONATHAN LIPPS: That's it?

00:04:49.490 --> 00:04:50.410
ANTON KOVALYOV: No.

00:04:50.410 --> 00:04:53.410
TODD ANGLIN: This is a
highly-qualified panel.

00:04:53.410 --> 00:04:54.760
JONATHAN LIPPS: Yeah.

00:04:54.760 --> 00:04:59.180
So at Sauce, we use this project
called Appium, which

00:04:59.180 --> 00:05:01.920
if any of you guys have done
testing of your web apps, you

00:05:01.920 --> 00:05:03.180
might have used Selenium.

00:05:03.180 --> 00:05:07.750
Appium uses the same protocol,
and it can test the native

00:05:07.750 --> 00:05:11.610
mode of your applications, or
native Android, or native iOS

00:05:11.610 --> 00:05:11.960
applications.

00:05:11.960 --> 00:05:15.470
It can also test if you have a
mobile web app, you can use

00:05:15.470 --> 00:05:19.290
the native web application,
Safari, and Chrome, and also

00:05:19.290 --> 00:05:21.335
test kind of the hybrid views
of each of those.

00:05:21.335 --> 00:05:24.100
So you kind of get all of the
levels of your application

00:05:24.100 --> 00:05:26.470
especially if you have a hybrid
application, that's

00:05:26.470 --> 00:05:27.330
pretty hard to do.

00:05:27.330 --> 00:05:31.446
So it works pretty well.

00:05:31.446 --> 00:05:32.870
BRIAN LEROUX: OK.

00:05:32.870 --> 00:05:39.970
So on the PhoneGap project, we
built a big ass wall, and we

00:05:39.970 --> 00:05:43.270
stuck a shit load of phones to
it, and we wired all those

00:05:43.270 --> 00:05:45.000
phones up to a Mac mini.

00:05:45.000 --> 00:05:47.860
And every time a commit lands
inside of Apache Cordova,

00:05:47.860 --> 00:05:50.710
which is the open source or
the project, we compile

00:05:50.710 --> 00:05:53.560
PhoneGap, we load it with the
web app that has a bunch of

00:05:53.560 --> 00:05:54.880
Jasmine tests.

00:05:54.880 --> 00:05:57.140
Some of the tests are in queue
unit, but that's just

00:05:57.140 --> 00:05:58.450
historical.

00:05:58.450 --> 00:06:00.290
And then we post those
results of those

00:06:00.290 --> 00:06:01.710
tests back to a couch.

00:06:01.710 --> 00:06:04.750
And you could see this stuff,
I think it's like at

00:06:04.750 --> 00:06:06.075
test.cordova.io.

00:06:06.075 --> 00:06:08.940
And so you have to test
on real devices.

00:06:08.940 --> 00:06:09.940
You can't get around that.

00:06:09.940 --> 00:06:13.510
Devices have sensors, and you
can test for things like, say

00:06:13.510 --> 00:06:16.600
is there an accelerometer, but
you can't actually test the

00:06:16.600 --> 00:06:19.040
accelerometer data coming
through unless you build a

00:06:19.040 --> 00:06:21.740
robot, which we're talking
about with Sauce.

00:06:21.740 --> 00:06:22.670
So we're doing that.

00:06:22.670 --> 00:06:23.820
It's an open source project.

00:06:23.820 --> 00:06:25.200
It's called medic.

00:06:25.200 --> 00:06:27.710
If you're interested in
automating, pushing native

00:06:27.710 --> 00:06:29.580
apps to phones, and get
test results, we

00:06:29.580 --> 00:06:30.970
can talk about later.

00:06:30.970 --> 00:06:33.300
There's another project at Adobe
call Topcoat, which is

00:06:33.300 --> 00:06:37.830
CSS project, and we're using
telemetry from Chrome to get

00:06:37.830 --> 00:06:40.980
the data out of that.

00:06:40.980 --> 00:06:44.260
So we have a custom build, at
Chrome, CF, and when we land a

00:06:44.260 --> 00:06:49.300
commit into our CSS, we add that
to a page, and then we

00:06:49.300 --> 00:06:52.840
load it, and then we add like
200 elements to a page.

00:06:52.840 --> 00:06:54.760
And we load that, and
we scrolled it.

00:06:54.760 --> 00:06:58.840
And we measure load time,
layout, and frames per second.

00:06:58.840 --> 00:07:00.670
And so we know that in each
commit that the CSS is

00:07:00.670 --> 00:07:02.190
actually getting faster
and faster.

00:07:02.190 --> 00:07:03.750
And all that's open
source too.

00:07:03.750 --> 00:07:06.890
It's at Topcoat organization
inside of GitHub.

00:07:09.872 --> 00:07:11.953
ANTON KOVALYOV: I have
a [INAUDIBLE]

00:07:11.953 --> 00:07:13.030
a question or more
like rambling.

00:07:13.030 --> 00:07:16.610
So I feel like there's a notion
in the mobile net world

00:07:16.610 --> 00:07:19.720
where you have to test
on the actual device.

00:07:19.720 --> 00:07:20.630
And this is true.

00:07:20.630 --> 00:07:21.040
You have to.

00:07:21.040 --> 00:07:24.110
You can get away from that,
but I don't know if we're

00:07:24.110 --> 00:07:26.720
actually working so it's
reducing the amount of testing

00:07:26.720 --> 00:07:30.980
we need to do on actual
hardware, because attaching a

00:07:30.980 --> 00:07:33.470
shit load of phones to the wall
doesn't scale when you

00:07:33.470 --> 00:07:35.130
have 200 engineers.

00:07:35.130 --> 00:07:38.630
Because then you have hundreds
of commits per day, every

00:07:38.630 --> 00:07:42.240
commit launches a phone and then
you wait for the test to

00:07:42.240 --> 00:07:46.020
be done in like what,
2 hours, 10 hours.

00:07:46.020 --> 00:07:50.984
So shouldn't we like I said
tell to the developers, I

00:07:50.984 --> 00:07:56.040
guess, work on reducing
the hardware

00:07:56.040 --> 00:07:58.130
dependency or adding--

00:07:58.130 --> 00:08:01.370
and I'm just throwing out
ideas because I haven't

00:08:01.370 --> 00:08:02.810
actually thought about that--

00:08:02.810 --> 00:08:08.510
or adding better simulation
to devices, or even better

00:08:08.510 --> 00:08:12.630
assimilation so the log grade
hardware to the hardware

00:08:12.630 --> 00:08:13.390
limitations.

00:08:13.390 --> 00:08:16.360
So that I could say, run this
test and then run this test

00:08:16.360 --> 00:08:20.060
when you have only 2 megabytes
of memory left.

00:08:20.060 --> 00:08:24.888
And so the question actually
mostly to you guys.

00:08:24.888 --> 00:08:28.540
JONATHAN LIPPS: So I do think
that simulators and emulators

00:08:28.540 --> 00:08:31.610
provide a good kind of
base-level testing, they're

00:08:31.610 --> 00:08:36.280
actually advantages over using
real devices, things like

00:08:36.280 --> 00:08:38.690
making sure that you have a
clean, stable environment.

00:08:38.690 --> 00:08:41.419
But you're really only testing
the changes in your code

00:08:41.419 --> 00:08:43.490
making it easier to run as
part of your continuous

00:08:43.490 --> 00:08:45.200
integration on every commit.

00:08:45.200 --> 00:08:48.530
Maybe you want to run your
full battery of mobile

00:08:48.530 --> 00:08:51.880
functional test on emulators
because that's cheap and easy,

00:08:51.880 --> 00:08:54.580
but you don't want to run
on all of the huge

00:08:54.580 --> 00:08:56.200
matrix of real devices.

00:08:56.200 --> 00:08:58.150
You want to do that when you're
ready to cut a release

00:08:58.150 --> 00:09:00.160
or whatever and then have
a little bit more

00:09:00.160 --> 00:09:01.170
confidence around it.

00:09:01.170 --> 00:09:04.190
So I think you can view it as
kind of a two-phase process,

00:09:04.190 --> 00:09:07.260
or you do more of the cheaper
resource, which is

00:09:07.260 --> 00:09:10.540
emulators/simulators which you
can virtualize the shit out of

00:09:10.540 --> 00:09:13.070
and then less of the more
expensive resource, which is

00:09:13.070 --> 00:09:16.472
sticking devices on walls.

00:09:16.472 --> 00:09:18.950
BRIAN LEROUX: Yeah, the device
wall does not scale.

00:09:18.950 --> 00:09:20.130
That's true.

00:09:20.130 --> 00:09:21.230
But you've got to do it.

00:09:21.230 --> 00:09:23.880
So the simulator/emulator thing,
the only problem with

00:09:23.880 --> 00:09:26.100
it is, you're in a virtualized
environment and then you're

00:09:26.100 --> 00:09:30.000
probably on good hardware, with
good network, with lots

00:09:30.000 --> 00:09:34.421
of memory, which is basically
what mobile isn't.

00:09:34.421 --> 00:09:38.410
YEHUDA KATZ: I think Anton's
point was, hey, people who

00:09:38.410 --> 00:09:41.620
make simulators, maybe you could
not have it emulate a

00:09:41.620 --> 00:09:42.620
perfect environment.

00:09:42.620 --> 00:09:43.320
BRIAN LEROUX: Yeah.

00:09:43.320 --> 00:09:44.025
YEHUDA KATZ: Right?

00:09:44.025 --> 00:09:44.610
BRIAN LEROUX: Yeah.

00:09:44.610 --> 00:09:44.960
I agree.

00:09:44.960 --> 00:09:45.460
It would be nice.

00:09:45.460 --> 00:09:50.010
I know the Book to Gecko
simulator, what was it called,

00:09:50.010 --> 00:09:51.440
R2-- it was a terrible name.

00:09:51.440 --> 00:09:56.250
What was it called R2D2,
V2G or something crazy?

00:09:56.250 --> 00:09:59.370
Anyways the Firefox OS simulator
is kind of cool

00:09:59.370 --> 00:10:02.110
because it is that and it
is the environment.

00:10:02.110 --> 00:10:05.210
Whereas like iOS and everything
is not quite the

00:10:05.210 --> 00:10:05.870
real thing.

00:10:05.870 --> 00:10:07.960
And the other problem is like
all these sensors like, I

00:10:07.960 --> 00:10:10.940
guess we can just chuck fake
data at it, hope that it's

00:10:10.940 --> 00:10:11.720
doing the right thing.

00:10:11.720 --> 00:10:13.720
But it's a complicated
problem for sure.

00:10:13.720 --> 00:10:16.230
There's another way to test and
that's just release often.

00:10:19.510 --> 00:10:20.505
That's a bad, bad solution.

00:10:20.505 --> 00:10:22.110
PAVEL FELDMAN: There's
another aspect to it.

00:10:22.110 --> 00:10:25.510
Everything we're talking about
today has this performance

00:10:25.510 --> 00:10:27.320
aspect, so everything
is performance when

00:10:27.320 --> 00:10:29.610
we're talking testing.

00:10:29.610 --> 00:10:31.510
Testing is testing, and
testing as a group

00:10:31.510 --> 00:10:32.320
performance.

00:10:32.320 --> 00:10:35.640
And the latter is
important to us.

00:10:35.640 --> 00:10:39.230
And the later is challenging
to emulate or simulate.

00:10:39.230 --> 00:10:42.280
We've been doing something
profiling for Intel and ARM.

00:10:42.280 --> 00:10:44.770
And the pictures that
we were having were

00:10:44.770 --> 00:10:46.030
just radically different.

00:10:46.030 --> 00:10:49.790
And hardware assimilated stuff
isn't entirely different.

00:10:49.790 --> 00:10:53.430
So if you're interested in the
end result and the interest in

00:10:53.430 --> 00:10:57.270
not regressing the end result
on the device, as of today,

00:10:57.270 --> 00:11:00.810
there's no other way other
than getting it to the

00:11:00.810 --> 00:11:02.780
hardware and testing it there.

00:11:02.780 --> 00:11:05.700
BRIAN LEROUX: Like one other
thing to throw out there for

00:11:05.700 --> 00:11:09.110
people, like measuring is like
super important because then

00:11:09.110 --> 00:11:11.920
that's how you get to a better
result ultimately.

00:11:11.920 --> 00:11:14.680
But the problem with all this
is that it requires a lot of

00:11:14.680 --> 00:11:16.780
boilerplate set up that
developers just

00:11:16.780 --> 00:11:17.550
do not want to do.

00:11:17.550 --> 00:11:19.930
When you're writing code, you
don't want to go put on your

00:11:19.930 --> 00:11:22.660
profiler hat and start
profiling.

00:11:22.660 --> 00:11:24.020
You want to write code, right?

00:11:24.020 --> 00:11:27.150
And ideally, you're notified
that hay, something just got

00:11:27.150 --> 00:11:29.000
slower, fix that.

00:11:29.000 --> 00:11:32.710
Instead of finding out after you
deploy out of context in a

00:11:32.710 --> 00:11:33.470
context switching.

00:11:33.470 --> 00:11:35.750
So there's a definite need for
better tools that happen

00:11:35.750 --> 00:11:37.715
during authoring time.

00:11:37.715 --> 00:11:39.450
PAVEL FELDMAN: I think
we'll get there.

00:11:39.450 --> 00:11:42.500
Telemetry is a perfect first
step there, because USS

00:11:42.500 --> 00:11:45.260
performance as your app
runs, you want to

00:11:45.260 --> 00:11:47.130
add the script running.

00:11:47.130 --> 00:11:49.860
WebDriver is just not evolving
fast enough to capture all

00:11:49.860 --> 00:11:54.500
that data, so telemetry is kind
of a fast and hackier way

00:11:54.500 --> 00:11:57.130
for WebDriver plus the
instrumentation.

00:11:57.130 --> 00:12:00.480
And running profilers, and
raising flags, doing all that,

00:12:00.480 --> 00:12:01.555
that will all come.

00:12:01.555 --> 00:12:04.130
We're just only starting
there.

00:12:04.130 --> 00:12:06.870
YEHUDA KATZ: So I have an
honest question about

00:12:06.870 --> 00:12:09.460
profilers in general, which
is do people who write the

00:12:09.460 --> 00:12:13.090
profilers actually, is there
like any user testing at all?

00:12:13.090 --> 00:12:15.060
And I don't mean like, get your
grandmother, but I mean

00:12:15.060 --> 00:12:18.210
like, get me to sit in front of
it and look at me trying to

00:12:18.210 --> 00:12:20.370
use a heap profile dump.

00:12:20.370 --> 00:12:22.850
Like, if you just watched me
for 10 minutes, I think you

00:12:22.850 --> 00:12:26.010
probably have 10 good ideas
on how to make it better.

00:12:26.010 --> 00:12:28.635
I guess it's a question
for Pavel.

00:12:28.635 --> 00:12:29.885
PAVEL FELDMAN: Yeah.

00:12:32.130 --> 00:12:32.540
OK.

00:12:32.540 --> 00:12:34.670
So memory profiling is hard.

00:12:34.670 --> 00:12:40.030
And no matter what platform
you're in, be it Native or

00:12:40.030 --> 00:12:42.830
Java or JavaScript,
historically, memory profiling

00:12:42.830 --> 00:12:45.890
has been a separate task that
you were forced to do.

00:12:45.890 --> 00:12:47.710
You didn't want to do that.

00:12:47.710 --> 00:12:51.150
Just because you are always
forced to do it because you're

00:12:51.150 --> 00:12:52.250
out of memory.

00:12:52.250 --> 00:12:55.300
And you don't want to do it,
because it's is hard and

00:12:55.300 --> 00:12:55.620
challenging.

00:12:55.620 --> 00:13:00.650
Because memory heap is a graph
and it's really complex.

00:13:00.650 --> 00:13:03.050
But I guess what you're talking
about is Chrome Dev

00:13:03.050 --> 00:13:04.970
Tools UX for heap profiler.

00:13:04.970 --> 00:13:09.330
We are making some good
improvements there.

00:13:09.330 --> 00:13:11.050
Some of them are recently
demoed.

00:13:11.050 --> 00:13:15.380
We are aware of certain
complexities there and certain

00:13:15.380 --> 00:13:20.050
degree of education that you
need to gain the hard way

00:13:20.050 --> 00:13:22.650
before you get a sense of it.

00:13:22.650 --> 00:13:26.630
We threw out the garbage of the
UI and of the heap, we're

00:13:26.630 --> 00:13:30.620
removing certain data, but you
shouldn't fool yourself.

00:13:30.620 --> 00:13:35.340
It's a hard problem to tackle,
and it will remain hard.

00:13:35.340 --> 00:13:37.190
Hopefully, we are trying to
make it simpler for you.

00:13:37.190 --> 00:13:39.250
BRIAN LEROUX: You know, one
thing to throw on top of that,

00:13:39.250 --> 00:13:42.520
this is something sort of like
we're ashamed of in the

00:13:42.520 --> 00:13:44.400
Topcoat part of the reality,
we're using telemetry.

00:13:44.400 --> 00:13:44.760
We love it.

00:13:44.760 --> 00:13:46.080
It works really well.

00:13:46.080 --> 00:13:48.260
It's a good way to get
a measurement and our

00:13:48.260 --> 00:13:51.330
assumption, which is probably
not true, is if we're using

00:13:51.330 --> 00:13:53.240
telemetry data, that means we're
using Chrome and that

00:13:53.240 --> 00:13:54.180
means we're measuring Chrome.

00:13:54.180 --> 00:13:56.660
And we figure if it's getting
faster in Chrome, it's

00:13:56.660 --> 00:13:59.000
probably faster in
other places.

00:13:59.000 --> 00:14:00.230
But that's an assumption.

00:14:00.230 --> 00:14:02.110
And so we need these
APIs actually back

00:14:02.110 --> 00:14:03.330
in the browser proper.

00:14:03.330 --> 00:14:05.640
We need them in IEs.

00:14:05.640 --> 00:14:07.525
YEHUDA KATZ: So a couple
of examples--

00:14:07.525 --> 00:14:12.410
BRIAN LEROUX: Not calling out
IE specifically any more.

00:14:12.410 --> 00:14:12.850
I probably should shut up.

00:14:12.850 --> 00:14:16.100
YEHUDA KATZ: I could get
a little more concrete.

00:14:16.100 --> 00:14:18.170
So a couple of examples on the
heap profiling thing, one of

00:14:18.170 --> 00:14:21.990
them is, so heap profiling
basically tells you if you're

00:14:21.990 --> 00:14:22.770
leaking memory.

00:14:22.770 --> 00:14:26.430
It says like, hey, after running
a GC pass, we can see

00:14:26.430 --> 00:14:27.560
that there's X amount
of memory.

00:14:27.560 --> 00:14:29.700
But actually the thing that
sucks about garbage is not the

00:14:29.700 --> 00:14:32.170
garbage that's left, it's
often just like you're

00:14:32.170 --> 00:14:34.250
generating a ton of garbage
and it's causing jank.

00:14:34.250 --> 00:14:36.970
And as far as I know none of the
heap profilers allow you

00:14:36.970 --> 00:14:39.320
to say like, hey, I want you to
tell me what's on the heap

00:14:39.320 --> 00:14:41.240
now, but don't run a GC first.

00:14:41.240 --> 00:14:42.810
And this is not a very
complicated thing.

00:14:42.810 --> 00:14:46.050
It literally means don't run the
GC first and then tell me

00:14:46.050 --> 00:14:48.430
the same thing that you're
telling me already and use the

00:14:48.430 --> 00:14:50.970
same differencing tools
to do that.

00:14:50.970 --> 00:14:55.750
And I think there's things
like this that, I mean, I

00:14:55.750 --> 00:14:58.150
wonder how the Chrome
team is--

00:14:58.150 --> 00:15:00.650
surely the Chrome team and the
Firefox team occasionally run

00:15:00.650 --> 00:15:02.870
its issues where they're writing
some self-hosted code

00:15:02.870 --> 00:15:04.450
and they generate a
lot of garbage.

00:15:04.450 --> 00:15:06.680
They want to know what
the garbage is.

00:15:06.680 --> 00:15:08.300
I'm curious what they
are doing for

00:15:08.300 --> 00:15:10.135
these types of problems.

00:15:10.135 --> 00:15:12.980
PAVEL FELDMAN: So this
particular one, the underlying

00:15:12.980 --> 00:15:15.340
implementation is that you
can visit all your

00:15:15.340 --> 00:15:16.630
heap within the GCM.

00:15:16.630 --> 00:15:18.510
That's the only way you
can visit your heap in

00:15:18.510 --> 00:15:19.845
[INAUDIBLE].

00:15:19.845 --> 00:15:21.690
You could work around it.

00:15:21.690 --> 00:15:27.130
And I think this particular
thing just did not come up.

00:15:27.130 --> 00:15:29.850
To answer your previous
question, our clients, the

00:15:29.850 --> 00:15:31.910
biggest client that
we have is Gmail.

00:15:31.910 --> 00:15:36.320
And all of the headache that
we were getting was Gmail.

00:15:36.320 --> 00:15:41.990
And it was more than a gig of
RAM before they started using

00:15:41.990 --> 00:15:45.820
it, and then it was like, back
and forth iterative process.

00:15:45.820 --> 00:15:47.360
Gmail was improving, tools
were improving.

00:15:47.360 --> 00:15:52.410
So in-house, we were working
like with large web apps where

00:15:52.410 --> 00:15:55.080
memory matters most.

00:15:55.080 --> 00:15:57.170
YEHUDA KATZ: so you were
worried more about

00:15:57.170 --> 00:15:59.500
applications that had a lot of
persistent memory and less

00:15:59.500 --> 00:16:02.490
about just like a bunch of
memory that got created like

00:16:02.490 --> 00:16:03.870
during scrolling, let's say.

00:16:03.870 --> 00:16:08.320
PAVEL FELDMAN: We're just
picking Gmail as the largest

00:16:08.320 --> 00:16:11.510
like crazy app out there.

00:16:11.510 --> 00:16:15.310
ANTON KOVALYOV: To answer this
question, so I run into these

00:16:15.310 --> 00:16:18.820
issues when writing Firefox
front end code since it's all

00:16:18.820 --> 00:16:20.520
JavaScript.

00:16:20.520 --> 00:16:23.620
And what I do, I usually
cry myself to sleep.

00:16:23.620 --> 00:16:28.460
Then I wake up and use our very
basic tools that we have

00:16:28.460 --> 00:16:32.460
to kind of fix the problem.

00:16:32.460 --> 00:16:37.760
So it's not the answer that we
have a solution for this.

00:16:37.760 --> 00:16:42.620
My answer is that everything
pretty much sucks, but we're

00:16:42.620 --> 00:16:47.000
working towards improving
that.

00:16:47.000 --> 00:16:50.140
So Yehuda already gave us really
good feedback, but if

00:16:50.140 --> 00:16:55.040
anyone else has feedback on
how the memory profiling,

00:16:55.040 --> 00:16:58.490
what's in the garbage, and other
things could improve

00:16:58.490 --> 00:17:00.610
your lives, that's
really helpful.

00:17:00.610 --> 00:17:03.760
Because I used to be
a web developer.

00:17:03.760 --> 00:17:06.109
Now I mostly work on the
platform for desktops, so I

00:17:06.109 --> 00:17:07.839
don't do that much
web development.

00:17:07.839 --> 00:17:09.910
So we need input from
the outside.

00:17:09.910 --> 00:17:12.530
TODD ANGLIN: So I think that's
a fair point to transition

00:17:12.530 --> 00:17:13.819
almost as a natural follow up.

00:17:13.819 --> 00:17:16.210
I mean, I think we would all
agree dev tools and browsers

00:17:16.210 --> 00:17:19.030
have come a long way in
a very short time.

00:17:19.030 --> 00:17:21.210
But they're clearly not
done improving.

00:17:21.210 --> 00:17:23.440
From your perspective, working
with them, really digging into

00:17:23.440 --> 00:17:26.210
them, what are the things
we most need still

00:17:26.210 --> 00:17:27.690
in browser dev tools?

00:17:27.690 --> 00:17:32.344
And this can be Chrome or just
cross browsers in particular.

00:17:32.344 --> 00:17:33.310
YEHUDA KATZ: Yeah.

00:17:33.310 --> 00:17:34.320
Hey.

00:17:34.320 --> 00:17:36.530
This is my topic.

00:17:36.530 --> 00:17:41.200
So in my opinion, the dev tools
have come a long way,

00:17:41.200 --> 00:17:44.790
and the biggest gaps in the
current dev tool story verses

00:17:44.790 --> 00:17:48.880
like some native tools is
there's a very limited ability

00:17:48.880 --> 00:17:51.430
for framework and library
developers to help the dev

00:17:51.430 --> 00:17:53.050
tools present information
in a more useful way.

00:17:53.050 --> 00:17:55.060
So let me give you
a simple example.

00:17:55.060 --> 00:17:56.190
If you are writing--

00:17:56.190 --> 00:17:58.020
a lot of the code that's inside
of Chrome is actually

00:17:58.020 --> 00:17:59.020
written in JavaScript.

00:17:59.020 --> 00:18:02.720
And for example, you might
imagine that for each forum,

00:18:02.720 --> 00:18:04.380
native arrays is written
in JavaScript.

00:18:04.380 --> 00:18:07.440
But of course, when you press
the down arrow to step into

00:18:07.440 --> 00:18:10.640
your code, you don't actually
see the native code, you just

00:18:10.640 --> 00:18:12.230
see your own code.

00:18:12.230 --> 00:18:15.180
Because the browser has the
ability to say, I do not want

00:18:15.180 --> 00:18:16.740
to show you this
internal code.

00:18:16.740 --> 00:18:18.670
But as a framework author,
I don't actually have any

00:18:18.670 --> 00:18:21.280
ability tell the browser like,
hey, unless the user really

00:18:21.280 --> 00:18:22.950
wants to see this, they
shouldn't see this.

00:18:22.950 --> 00:18:24.970
So you may have like a number of
frames that the user has to

00:18:24.970 --> 00:18:27.080
step through that's
an abstraction.

00:18:27.080 --> 00:18:29.170
And maybe sometimes they want
to see it, but 99% of the

00:18:29.170 --> 00:18:31.250
time, they want to see
their own code.

00:18:31.250 --> 00:18:33.845
There's other things like
ability to annotate a stack

00:18:33.845 --> 00:18:37.420
tray so that if there's async
code you can basically

00:18:37.420 --> 00:18:39.350
stitched together a bunch
of stack traces.

00:18:39.350 --> 00:18:41.670
And this is information that I
have as a framework developer

00:18:41.670 --> 00:18:44.040
because I'm the one doing
the deferral.

00:18:44.040 --> 00:18:47.570
So I do a lot of crazy stuff
in Ember, but even simple

00:18:47.570 --> 00:18:50.140
things like jQuery and Backbone
will benefit a lot.

00:18:50.140 --> 00:18:52.850
And I think as far as I can
tell, there's basically been

00:18:52.850 --> 00:18:56.380
essentially no work done on this
area when there's been a

00:18:56.380 --> 00:18:57.600
lot of work done on
a lot of things.

00:18:57.600 --> 00:19:01.060
So of course, it's possible to
say, well, this is a low

00:19:01.060 --> 00:19:04.430
priority, but I think given the
amount of people that use

00:19:04.430 --> 00:19:07.260
dev tools and use frameworks and
libraries, I think will be

00:19:07.260 --> 00:19:08.212
very beneficial.

00:19:08.212 --> 00:19:08.870
JONATHAN LIPPS: Yeah.

00:19:08.870 --> 00:19:11.290
I think another thing that would
be pretty cool is better

00:19:11.290 --> 00:19:14.960
cross platform dev tools so
each of the platforms has

00:19:14.960 --> 00:19:18.920
their own somewhat good in some
cases set of dev tools.

00:19:18.920 --> 00:19:19.820
But then you have to learn

00:19:19.820 --> 00:19:21.230
something completely different.

00:19:21.230 --> 00:19:25.020
And so if there was, I don't
know, maybe there are

00:19:25.020 --> 00:19:26.230
standards in the works.

00:19:26.230 --> 00:19:29.425
You seem really anxious to
talk about something.

00:19:29.425 --> 00:19:33.420
But I mean, you could say the
same thing with the native

00:19:33.420 --> 00:19:35.770
mobile layer, which we're not
really talking about too much

00:19:35.770 --> 00:19:38.780
right now, but is also obviously
important right now

00:19:38.780 --> 00:19:41.144
in history.

00:19:41.144 --> 00:19:43.110
ANTON KOVALYOV: I'm very anxious
to talk about it

00:19:43.110 --> 00:19:46.940
because people ask this question
a lot for Firefox

00:19:46.940 --> 00:19:50.040
mostly since we're still
catching up obviously with

00:19:50.040 --> 00:19:50.680
Chrome dev source.

00:19:50.680 --> 00:19:52.230
So like, oh, why don't
you just do the

00:19:52.230 --> 00:19:54.500
same debugging protocol?

00:19:54.500 --> 00:19:57.870
Well, this is not going to
happen anytime soon mostly

00:19:57.870 --> 00:20:03.630
because both Chrome and us and,
I don't know, whatever

00:20:03.630 --> 00:20:07.740
Internet Explorer has, we all
want to iterate really fast,

00:20:07.740 --> 00:20:09.180
and we have different
priorities.

00:20:09.180 --> 00:20:13.010
For us, for example, I just
want to describe why the

00:20:13.010 --> 00:20:15.100
standardization of their mobile
debugging protocols is

00:20:15.100 --> 00:20:16.680
not happening right now.

00:20:16.680 --> 00:20:19.550
For us, for example, the Firefox
is a priority, right?

00:20:19.550 --> 00:20:23.810
So what we are working on, like
among other things, is

00:20:23.810 --> 00:20:30.340
the ability to send files or
giant blobs over the protocol.

00:20:30.340 --> 00:20:32.780
Giants multi megabyte and
encrypted-generated files is

00:20:32.780 --> 00:20:33.950
also a priority for us.

00:20:33.950 --> 00:20:35.530
I don't know if it's a
priority for Chrome.

00:20:35.530 --> 00:20:38.530
And it might not as well
be, and it's cool.

00:20:38.530 --> 00:20:42.390
But if we will start converging
the protocols and

00:20:42.390 --> 00:20:44.160
doing any kind of synergization,
this will slow

00:20:44.160 --> 00:20:45.330
everyone's down.

00:20:45.330 --> 00:20:49.590
So the solution to this, I
think, and I ask my team

00:20:49.590 --> 00:20:54.300
yesterday, so my team's solution
is to write a shim to

00:20:54.300 --> 00:20:55.100
the protocol.

00:20:55.100 --> 00:21:00.990
So when the time comes and we
want to use our protocol, our

00:21:00.990 --> 00:21:02.930
developer tools for Chrome, for
example, we can write a

00:21:02.930 --> 00:21:07.020
shim that will just make a
bridge between two protocols,

00:21:07.020 --> 00:21:08.270
and then we can do that.

00:21:11.738 --> 00:21:13.560
BRIAN LEROUX: So just quickly.

00:21:13.560 --> 00:21:15.970
It is going to be standardized
TC-39.

00:21:15.970 --> 00:21:19.440
And I know folks at Adobe are
trying to take the lead on

00:21:19.440 --> 00:21:21.780
that, and yes, it's not going
to happen any time soon.

00:21:21.780 --> 00:21:22.970
And I totally acknowledge
that.

00:21:22.970 --> 00:21:26.320
But it's kind of ironic, I don't
often do this, but I'm

00:21:26.320 --> 00:21:28.140
going to praise Java.

00:21:28.140 --> 00:21:29.340
Java did this.

00:21:29.340 --> 00:21:32.180
It has debugging as a part of
a language first class, and

00:21:32.180 --> 00:21:35.190
JavaScript does not, and
hence, here we are.

00:21:35.190 --> 00:21:38.360
And this is desperately needed
to have third-party tool

00:21:38.360 --> 00:21:40.460
ecosystem that sits outside
of the browser.

00:21:40.460 --> 00:21:42.120
Right now, it's almost a
browser differentiator.

00:21:42.120 --> 00:21:46.340
PAVEL FELDMAN: I would second
though the standardization is

00:21:46.340 --> 00:21:47.140
going to slow us down.

00:21:47.140 --> 00:21:49.810
We don't want to evolve
as fast as Java.

00:21:49.810 --> 00:21:52.410
We want to evolve
a bit faster.

00:21:52.410 --> 00:21:56.550
And when we were on the
beginning of our journey,

00:21:56.550 --> 00:21:57.150
there was a protocol.

00:21:57.150 --> 00:22:01.420
There was scope, [INAUDIBLE],
and we didn't adopt it.

00:22:01.420 --> 00:22:04.320
We came up with our own thing,
and our thinking was we need

00:22:04.320 --> 00:22:07.090
to do it as fast as possible,
and as convenient ourselves as

00:22:07.090 --> 00:22:09.900
possible, as close to the
underlying system as possible.

00:22:09.900 --> 00:22:12.980
So you would see that our
network domain, for example,

00:22:12.980 --> 00:22:14.860
is very much a WebGet
specific.

00:22:14.860 --> 00:22:18.690
It has things like loader IDs,
resource IDs, which are not

00:22:18.690 --> 00:22:21.700
used in Firefox, so the concepts
are different.

00:22:21.700 --> 00:22:25.850
And of course, we were thinking
if it becomes a big

00:22:25.850 --> 00:22:30.350
thing, we'll be standardizing,
but the further we are ahead

00:22:30.350 --> 00:22:33.230
in the process, the more chances
that the protocol that

00:22:33.230 --> 00:22:36.650
we implemented natively becomes
the de facto standard.

00:22:36.650 --> 00:22:40.790
And I could understand the
willingness to do the same

00:22:40.790 --> 00:22:42.220
thing again.

00:22:42.220 --> 00:22:45.720
And we were also thinking that
changing adapters in the

00:22:45.720 --> 00:22:49.840
protocols on the Jason or Wire
level will solve it.

00:22:49.840 --> 00:22:52.870
Because debugging domain
is very conservative.

00:22:52.870 --> 00:22:55.740
You just step through
stuff, and you

00:22:55.740 --> 00:22:57.380
don't do anything fancy.

00:22:57.380 --> 00:23:00.990
And once you stop doing anything
fancy, it starts to

00:23:00.990 --> 00:23:02.850
differ from browser
to browser.

00:23:02.850 --> 00:23:07.760
So we are still waiting for
a number of big players to

00:23:07.760 --> 00:23:11.490
become clients of several
browsers to see that there is

00:23:11.490 --> 00:23:14.080
a need for that, there is an
investment to it, and then it

00:23:14.080 --> 00:23:16.210
will be a clear signal
that there is a

00:23:16.210 --> 00:23:17.230
need for such a standard.

00:23:17.230 --> 00:23:17.460
BRIAN LEROUX: Yeah.

00:23:17.460 --> 00:23:19.980
I don't think one comes at the
expense of the other at all.

00:23:19.980 --> 00:23:22.920
And just to like throw some
weight behind Yehuda's

00:23:22.920 --> 00:23:25.140
comment, I think it's well
beyond time that we have

00:23:25.140 --> 00:23:27.750
better instrumentation points to
the browser so that we can

00:23:27.750 --> 00:23:30.210
see the framework start
providing better hooks.

00:23:30.210 --> 00:23:33.260
Because the abstraction layer,
like nobody wants to step

00:23:33.260 --> 00:23:33.970
through jQuery.

00:23:33.970 --> 00:23:35.290
That's insane.

00:23:35.290 --> 00:23:36.880
TODD ANGLIN: So we've answered
two questions.

00:23:36.880 --> 00:23:38.160
We don't have a ton of time.

00:23:38.160 --> 00:23:39.250
If we can move it forward.

00:23:39.250 --> 00:23:40.260
MALE SPEAKER: We'll take
the final reply.

00:23:40.260 --> 00:23:41.530
TODD ANGLIN: We'll take the
final reply on this then we'll

00:23:41.530 --> 00:23:42.350
move on to--

00:23:42.350 --> 00:23:44.350
YEHUDA KATZ: The final
reply it was, what do

00:23:44.350 --> 00:23:45.310
you want from tools?

00:23:45.310 --> 00:23:48.520
So whatever you want from tools,
please file the bugs.

00:23:48.520 --> 00:23:50.010
We are bugs driven.

00:23:50.010 --> 00:23:54.950
It's yourbug.com If you are a
framework author, please post

00:23:54.950 --> 00:23:58.100
to all your framework clients
to start this bug, and we'll

00:23:58.100 --> 00:24:01.276
have no other option
of implementing it.

00:24:01.276 --> 00:24:02.660
TODD ANGLIN: There you go.

00:24:02.660 --> 00:24:04.610
That's how you can
force your way.

00:24:04.610 --> 00:24:08.120
Before we're forced into our
final count down, I want to

00:24:08.120 --> 00:24:10.040
make sure we at least giving our
audience a chance to ask a

00:24:10.040 --> 00:24:10.820
question directly.

00:24:10.820 --> 00:24:12.940
So if there's anybody who has
a question in the space of

00:24:12.940 --> 00:24:15.940
tools and tooling, I was told
there are a lot of questions.

00:24:15.940 --> 00:24:16.790
Any questions here?

00:24:16.790 --> 00:24:19.342
Here we go right here.

00:24:19.342 --> 00:24:21.900
BEN DILTS: Ben Dilts
from Lucidchart.

00:24:21.900 --> 00:24:24.340
One thing that's been a real
challenge for us over time is

00:24:24.340 --> 00:24:28.440
trying to collect error
reports in production.

00:24:28.440 --> 00:24:32.200
So like in the Closure Library,
there's something

00:24:32.200 --> 00:24:36.060
about like an error collector
and it has very widely-varying

00:24:36.060 --> 00:24:38.930
usefulness of data that comes
out of that based on what

00:24:38.930 --> 00:24:42.930
browser, what version,
or what have you.

00:24:42.930 --> 00:24:45.570
And it's almost impossible to
get a stack trace of where you

00:24:45.570 --> 00:24:47.940
currently are because
you have like the

00:24:47.940 --> 00:24:49.720
caller on the function.

00:24:49.720 --> 00:24:52.030
But obviously, once you have
a circular reference.

00:24:52.030 --> 00:24:55.450
Anyway so is there some master
plan for making that better,

00:24:55.450 --> 00:24:57.882
because it's really terrible
right now.

00:24:57.882 --> 00:25:01.370
ANTON KOVALYOV: I'll
start answering.

00:25:01.370 --> 00:25:02.950
Everything is very sad.

00:25:02.950 --> 00:25:09.210
So when I was working at Disqus,
we had this problem

00:25:09.210 --> 00:25:13.600
where we wanted to send reports,
and everything was

00:25:13.600 --> 00:25:14.270
really sad.

00:25:14.270 --> 00:25:16.890
Now, I checked actually a couple
of weeks ago because a

00:25:16.890 --> 00:25:19.830
friend of mine asked, and across
a browser, it's like

00:25:19.830 --> 00:25:22.340
it's pretty good in
Chrome, think it's

00:25:22.340 --> 00:25:24.590
kind of good in Firefox.

00:25:24.590 --> 00:25:35.640
But when you get like cross
browser, it's really basic.

00:25:35.640 --> 00:25:39.685
And unfortunately, this is not
what developer tools team can

00:25:39.685 --> 00:25:40.620
fix at Firefox.

00:25:40.620 --> 00:25:46.500
This is either DOM or language
design thing.

00:25:46.500 --> 00:25:50.820
And with DOM, you have WebID
and then it starts to cry.

00:25:50.820 --> 00:25:52.702
BRIAN LEROUX: What
about TowTruck?

00:25:52.702 --> 00:25:53.670
ANTON KOVALYOV: Oh, our thing?

00:25:53.670 --> 00:25:54.420
BRIAN LEROUX: Yeah.

00:25:54.420 --> 00:25:54.840
You're thing.

00:25:54.840 --> 00:25:56.512
ANTON KOVALYOV: Yeah,
it's pretty cool.

00:25:56.512 --> 00:25:57.135
BRIAN LEROUX: Great.

00:25:57.135 --> 00:26:03.590
ANTON KOVALYOV: So yeah, one
thing I want to say is that if

00:26:03.590 --> 00:26:06.640
there is even more important for
mobile development because

00:26:06.640 --> 00:26:11.560
there when you have an error on
the desktop, you're like,

00:26:11.560 --> 00:26:12.510
oh, what are you using?

00:26:12.510 --> 00:26:14.010
Are you using Firefox 21.

00:26:14.010 --> 00:26:14.280
OK.

00:26:14.280 --> 00:26:15.870
You'll launch our Firefox
[INAUDIBLE]

00:26:15.870 --> 00:26:17.050
for use.

00:26:17.050 --> 00:26:18.910
On mobile like, oh, we're using

00:26:18.910 --> 00:26:22.230
this Firefox 900 Android--

00:26:22.230 --> 00:26:23.766
I don't know what their version
is so I'm going to

00:26:23.766 --> 00:26:25.950
have to use 2.4 or something,
something.

00:26:25.950 --> 00:26:27.560
And then you cannot really
reproduce it.

00:26:27.560 --> 00:26:30.150
So your best choice is to
collect data and save data to

00:26:30.150 --> 00:26:31.190
the server all time.

00:26:31.190 --> 00:26:35.000
It will only be grounded about
every sub trace and stuff.

00:26:35.000 --> 00:26:37.410
And I was helping my friend
in Century to do it for

00:26:37.410 --> 00:26:40.120
JavaScript, and that's
why I was really

00:26:40.120 --> 00:26:42.560
anxious to answer that.

00:26:42.560 --> 00:26:45.570
You should bug everyone you know
about the browser vendor

00:26:45.570 --> 00:26:47.150
to fix that.

00:26:47.150 --> 00:26:48.330
You should just not stop.

00:26:48.330 --> 00:26:50.360
You should demand this, because
this is really Ember

00:26:50.360 --> 00:26:52.820
for the web that we cannot send
the stack traces to the

00:26:52.820 --> 00:26:54.700
server normally across
a browser.

00:26:54.700 --> 00:26:57.910
So I'm just acknowledging.

00:26:57.910 --> 00:27:01.660
YEHUDA KATZ: I also agree,
and I've raised this a

00:27:01.660 --> 00:27:04.220
few times on TC-39.

00:27:04.220 --> 00:27:08.640
And there is a low appetite
for standardizing stack

00:27:08.640 --> 00:27:11.580
traces, but I think
this is a mistake.

00:27:11.580 --> 00:27:15.060
So the issue to get past is
that when you standardize

00:27:15.060 --> 00:27:18.240
stack traces, you are forcing
the VM authors into particular

00:27:18.240 --> 00:27:20.750
pattern of how they have
to collect and

00:27:20.750 --> 00:27:22.100
maintain their code.

00:27:22.100 --> 00:27:27.430
And this is not a good excuse,
and I agree with Anton.

00:27:27.430 --> 00:27:30.200
You should make sure that all
the browser vendors and VM

00:27:30.200 --> 00:27:31.800
pointers that you know
know you don't

00:27:31.800 --> 00:27:33.910
think it's a good excuse.

00:27:33.910 --> 00:27:36.670
Like this is probably,
it's like a

00:27:36.670 --> 00:27:37.930
first step of debugging.

00:27:37.930 --> 00:27:40.170
It's like before print after
debugging, it's like give me a

00:27:40.170 --> 00:27:41.350
stack trace.

00:27:41.350 --> 00:27:43.160
And we don't even have
it on the browser.

00:27:43.160 --> 00:27:48.540
And it is probably sufficient to
leave open a little bit of

00:27:48.540 --> 00:27:50.690
wiggle room in terms
of what exactly you

00:27:50.690 --> 00:27:51.470
are required to do.

00:27:51.470 --> 00:27:53.780
But having some notion of like
some standardization here

00:27:53.780 --> 00:27:54.696
would be very helpful.

00:27:54.696 --> 00:27:55.132
Yes.

00:27:55.132 --> 00:27:58.314
And people should ask.

00:27:58.314 --> 00:28:00.260
TODD ANGLIN: So I've got the
five-minute warning, which

00:28:00.260 --> 00:28:04.160
means that it's probably time to
take our 30-second answers.

00:28:04.160 --> 00:28:08.030
So I hate to be repetitive to
the other panels here, but

00:28:08.030 --> 00:28:10.150
there's not many better ways
to wrap up than to ask you

00:28:10.150 --> 00:28:13.290
guys, with the perspectives
represented here both two

00:28:13.290 --> 00:28:17.120
authors and consumers and
platforms, if we were back on

00:28:17.120 --> 00:28:19.325
the stage a year from now, and
we're talking about tooling

00:28:19.325 --> 00:28:21.850
and testing, either one given
the subject, what is the thing

00:28:21.850 --> 00:28:24.850
you would hope is most changed
a year from now?

00:28:24.850 --> 00:28:26.260
I mean, there's a lot of things
that need to be done.

00:28:26.260 --> 00:28:27.560
We've been told it's
a very sad state of

00:28:27.560 --> 00:28:28.380
affairs right now.

00:28:28.380 --> 00:28:30.050
It's a very depressing panel.

00:28:30.050 --> 00:28:31.960
But what is the thing you would
hope a year from now is

00:28:31.960 --> 00:28:33.490
not depressing relative
to today?

00:28:33.490 --> 00:28:36.334
We'll just run down the line.

00:28:36.334 --> 00:28:39.596
PAVEL FELDMAN: There'd just
be better tooling.

00:28:39.596 --> 00:28:41.530
TODD ANGLIN: That's
your job, right?

00:28:41.530 --> 00:28:42.010
PAVEL FELDMAN: Right.

00:28:42.010 --> 00:28:43.300
And we'll make that.

00:28:43.300 --> 00:28:45.180
So imagine you're running
your app--

00:28:45.180 --> 00:28:46.690
30 seconds, right?

00:28:46.690 --> 00:28:50.850
You're running your app, and you
can go forward and back in

00:28:50.850 --> 00:28:53.060
time explore everything,
everything that

00:28:53.060 --> 00:28:55.030
was consuming time.

00:28:55.030 --> 00:28:58.910
All of the causes fixed in live,
the replay thing, it

00:28:58.910 --> 00:29:02.480
works faster, then make sure
that it does regress.

00:29:02.480 --> 00:29:03.905
Just a miracle.

00:29:03.905 --> 00:29:07.550
TODD ANGLIN: So that's
May 16, 2014.

00:29:07.550 --> 00:29:09.040
And we've got a commitment
here.

00:29:09.040 --> 00:29:09.812
All right.

00:29:09.812 --> 00:29:13.390
YEHUDA KATZ: The answer I used
to say to this was some

00:29:13.390 --> 00:29:17.540
browser, any browser, pause
on Stack Overflow.

00:29:17.540 --> 00:29:18.870
Thankfully, Firefox does it.

00:29:18.870 --> 00:29:20.410
Chrome, please pause
on Stack Overflows.

00:29:20.410 --> 00:29:21.610
This is ridiculous.

00:29:21.610 --> 00:29:24.480
But in all seriousness, what I
want, in general, is just more

00:29:24.480 --> 00:29:27.750
ability as a library and
framework author to control

00:29:27.750 --> 00:29:31.120
what it is that the tools are
showing to my users, because

00:29:31.120 --> 00:29:33.820
having my code be essentially
treated as equivalent to their

00:29:33.820 --> 00:29:36.420
code is really not a good
experience, and it is, I

00:29:36.420 --> 00:29:39.272
think, beyond a small issue.

00:29:39.272 --> 00:29:40.750
ANTON KOVALYOV: So understanding
in terms of

00:29:40.750 --> 00:29:44.640
mobile tooling, I think it would
be really nice, and I

00:29:44.640 --> 00:29:47.520
know both Chrome and Firefox
are working on that, is to

00:29:47.520 --> 00:29:54.020
lower the barrier entry to
using the dev tools.

00:29:54.020 --> 00:29:59.460
The fact that we require, like
Firefox requires web

00:29:59.460 --> 00:30:03.920
developers to install Android
SDK and use ADB to connect to

00:30:03.920 --> 00:30:06.780
Firefox to Android to debug
their god damn web application

00:30:06.780 --> 00:30:08.230
is insanity.

00:30:08.230 --> 00:30:10.640
There should be a Firefox add
on or something, Android

00:30:10.640 --> 00:30:13.945
plug-in or Chrome plug-in that
says, OK, now, you can connect

00:30:13.945 --> 00:30:14.480
your device.

00:30:14.480 --> 00:30:16.130
Now, you're all good.

00:30:16.130 --> 00:30:18.930
And we're actually
working on that.

00:30:18.930 --> 00:30:20.610
Someone told me today that
Chrome is working on that.

00:30:20.610 --> 00:30:24.600
So it's really good, and
hopefully, in a year or less,

00:30:24.600 --> 00:30:27.250
we'll have a much lower barrier
of entry for web

00:30:27.250 --> 00:30:29.840
developers to actually
use tools to

00:30:29.840 --> 00:30:32.108
debug mobile web sites.

00:30:32.108 --> 00:30:35.470
JONATHAN LIPPS: Taking a more
testing prospective, what I

00:30:35.470 --> 00:30:40.880
want to see is you check code
for your iPhone application,

00:30:40.880 --> 00:30:43.510
your Android application, and
your web application.

00:30:43.510 --> 00:30:47.850
And to GitHub your continuous
integration pulls that down.

00:30:47.850 --> 00:30:50.470
All three versions of the
application are built.

00:30:50.470 --> 00:30:52.540
All three versions of the
application are automatically

00:30:52.540 --> 00:30:57.220
tested using the one, single
test suite, not three.

00:30:57.220 --> 00:31:01.840
And then it's built, signed for
deployment, deployed to

00:31:01.840 --> 00:31:07.610
your fleet of beta users, and
then given some standard

00:31:07.610 --> 00:31:10.960
metric that you're tracking,
automatically deployed to your

00:31:10.960 --> 00:31:12.770
app store to the web.

00:31:12.770 --> 00:31:16.090
I think continuous deployment
integration for mobile is

00:31:16.090 --> 00:31:18.884
awesome, and it's
not there yet.

00:31:18.884 --> 00:31:21.966
BRIAN LEROUX: Fuck,
I'd love that.

00:31:21.966 --> 00:31:23.490
Good luck.

00:31:23.490 --> 00:31:28.620
So there's like two ways to
look at the whole problem.

00:31:28.620 --> 00:31:31.470
Steve Souders has an awesome
article about how the mobile

00:31:31.470 --> 00:31:32.670
web is getting faster.

00:31:32.670 --> 00:31:33.350
It's like something--

00:31:33.350 --> 00:31:33.770
I don't know.

00:31:33.770 --> 00:31:34.330
I can remember.

00:31:34.330 --> 00:31:35.570
It's a percentage faster.

00:31:35.570 --> 00:31:38.990
But the problem is developers
are still writing bigger and

00:31:38.990 --> 00:31:40.210
bigger web apps.

00:31:40.210 --> 00:31:42.440
And the web apps themselves are
getting bigger, and so the

00:31:42.440 --> 00:31:45.540
performance gains on sort of
the platform side are being

00:31:45.540 --> 00:31:46.930
lost due to the weight.

00:31:46.930 --> 00:31:50.050
So to me, I'd view very much
as a bit of a documentation

00:31:50.050 --> 00:31:52.080
issue that we got to get in
front of developers and tell

00:31:52.080 --> 00:31:54.960
them to start measuring their
stuff so they start actually

00:31:54.960 --> 00:31:58.080
building improvements themselves
instead of just

00:31:58.080 --> 00:32:00.520
loading a whole bunch of script
tags and large images,

00:32:00.520 --> 00:32:03.170
they have to start thinking
[INAUDIBLE] side about how

00:32:03.170 --> 00:32:05.560
they're going architect
their apps.

00:32:05.560 --> 00:32:06.320
That's what I hope for.

00:32:06.320 --> 00:32:06.580
TODD ANGLIN: Cool.

00:32:06.580 --> 00:32:08.490
So on that note, thank
you, panel.

