WEBVTT
Kind: captions
Language: en

00:00:03.550 --> 00:00:05.200
SAM DUTTON: And I think
we're off, yeah?

00:00:05.200 --> 00:00:07.770
We're all ready to go.

00:00:07.770 --> 00:00:10.090
I think we're live and
broadcasting now.

00:00:10.090 --> 00:00:14.790
The wonders of real-time
communication.

00:00:14.790 --> 00:00:19.800
We've crossed over and just to
say hello and apologies for

00:00:19.800 --> 00:00:21.770
the problems earlier of trying
get us hooked up.

00:00:21.770 --> 00:00:23.510
But we are up and running now.

00:00:23.510 --> 00:00:26.220
So just to introduce myself--
my name is Sam Dutton.

00:00:26.220 --> 00:00:29.990
I'm a developer advocate for
Google Chrome based in London,

00:00:29.990 --> 00:00:32.520
coming from London today.

00:00:32.520 --> 00:00:35.270
Yeah, we've got people from
all around the world.

00:00:35.270 --> 00:00:38.070
So if we could just cross over
to the others now, and people

00:00:38.070 --> 00:00:40.630
could introduce themselves
and see who's here.

00:00:43.790 --> 00:00:46.610
JUSTIN UBERTI: Hi, I'm
Justin Uberti.

00:00:46.610 --> 00:00:49.900
MALANET: Hi, I'm Malanet
[INAUDIBLE].

00:00:49.900 --> 00:00:52.570
TOM: And I'm Tom [INAUDIBLE].

00:00:52.570 --> 00:00:54.205
SERGE LACHAPELLE: And I'm from
Stockholm, I'm Serge

00:00:54.205 --> 00:00:55.970
Lachapelle.

00:00:55.970 --> 00:00:57.170
SAM DUTTON: Fantastic.

00:00:57.170 --> 00:00:59.350
It's great to see
everyone here.

00:00:59.350 --> 00:01:03.030
So what we're going to today is
we're going to kind of give

00:01:03.030 --> 00:01:07.370
an overview of WebRTC and see
where we are now, and talk

00:01:07.370 --> 00:01:09.930
through, just very quickly,
the sort of basics of the

00:01:09.930 --> 00:01:12.430
technology, and then really
go over the questions.

00:01:12.430 --> 00:01:14.830
We've had great questions on
Moderator from everyone.

00:01:14.830 --> 00:01:17.310
So thanks very much
for that stuff.

00:01:17.310 --> 00:01:21.980
First, I'd just like to just
give you two inspirational

00:01:21.980 --> 00:01:23.283
quotes from people
that I've heard.

00:01:23.283 --> 00:01:26.330
And the first one is from
Brendan Eich, who's the

00:01:26.330 --> 00:01:28.180
inventor of JavaScript.

00:01:28.180 --> 00:01:33.540
And he says that's be believes
that "WebRTC is a new front in

00:01:33.540 --> 00:01:36.250
the long war for an open
and unencumbered

00:01:36.250 --> 00:01:38.520
web," so strong words.

00:01:38.520 --> 00:01:43.050
And another quote from Phil
Edholm, blogger, who says

00:01:43.050 --> 00:01:47.010
that, "Potentially WebRTC and
HTML5 could enable the same

00:01:47.010 --> 00:01:49.810
transformation for real-time
communications that the

00:01:49.810 --> 00:01:53.350
original browser did
for information."

00:01:53.350 --> 00:01:54.480
So it's strong stuff.

00:01:54.480 --> 00:02:00.410
And we believe that WebRTC
has huge potential.

00:02:00.410 --> 00:02:03.230
So for those who are kind of new
to the topic, just a very

00:02:03.230 --> 00:02:06.200
quick overview of what
WebRTC actually is.

00:02:06.200 --> 00:02:10.080
And it's kind of a collection
of standards for real-time

00:02:10.080 --> 00:02:14.030
plug-in free video, audio,
and data communication.

00:02:14.030 --> 00:02:16.390
Now there are some existing
services that

00:02:16.390 --> 00:02:18.210
do stuff like this--

00:02:18.210 --> 00:02:20.600
Google Talk and Skype
and so on.

00:02:20.600 --> 00:02:23.650
But all of these use plug-ins.

00:02:23.650 --> 00:02:28.610
And we believe that WebRTC
can do real time more

00:02:28.610 --> 00:02:30.870
efficiently than that.

00:02:30.870 --> 00:02:34.137
So the first question, I guess,
people are asking is,

00:02:34.137 --> 00:02:37.790
well, what do I need
to do WebRTC?

00:02:37.790 --> 00:02:42.140
Well, you're going to need a
source of streaming video, or

00:02:42.140 --> 00:02:45.640
audio, or, in the
future, data.

00:02:45.640 --> 00:02:50.290
You're going to need a way to
communicate that video, audio,

00:02:50.290 --> 00:02:52.750
or data to other peers.

00:02:52.750 --> 00:02:58.420
And you're going to have to
exchange some kind of messages

00:02:58.420 --> 00:03:00.960
between each other to initiate
sessions, to close sessions,

00:03:00.960 --> 00:03:04.700
and also, of course, to report
errors as they happen.

00:03:04.700 --> 00:03:07.820
And you're going to need to be
able to exchange, between

00:03:07.820 --> 00:03:11.850
peers, information about media
and configuration--

00:03:11.850 --> 00:03:15.350
things like resolution
and format.

00:03:15.350 --> 00:03:19.530
And of course, you're also going
to need ways to actually

00:03:19.530 --> 00:03:22.040
let people get in touch
with each other.

00:03:22.040 --> 00:03:27.150
So in terms of what WebRTC has
brought to the web, in terms

00:03:27.150 --> 00:03:32.840
of APIs, we have MediaStream
for getting streaming data.

00:03:32.840 --> 00:03:38.880
We have PeerConnection for
communicating data, and then

00:03:38.880 --> 00:03:42.640
what we're going to be seeing
implemented is Data Channel as

00:03:42.640 --> 00:03:46.200
a method of exchanging
streaming data.

00:03:46.200 --> 00:03:50.450
So a really powerful
set of APIs there.

00:03:50.450 --> 00:03:54.000
Now, that's looking on
the client side.

00:03:54.000 --> 00:03:58.170
If we go to the server,
WebRTC, real-time

00:03:58.170 --> 00:04:00.540
communication, is always
going to need

00:04:00.540 --> 00:04:02.400
servers, however simple.

00:04:02.400 --> 00:04:06.270
You need for users to be able to
discover each other, users

00:04:06.270 --> 00:04:10.170
to be able send in details to
each other, and communication

00:04:10.170 --> 00:04:14.040
that can survive network
glitches.

00:04:14.040 --> 00:04:18.370
And so that client applications
can send data

00:04:18.370 --> 00:04:21.329
about the media they're working
with, like I said.

00:04:21.329 --> 00:04:25.710
So information about resolution,
format, and so on.

00:04:25.710 --> 00:04:28.370
And we also-- this is
very important--

00:04:28.370 --> 00:04:31.600
of course, lots of client
applications are going to be

00:04:31.600 --> 00:04:33.720
behind net gateways--

00:04:33.720 --> 00:04:34.970
firewalls and so on.

00:04:34.970 --> 00:04:38.800
And so WebRTC client
applications are going to need

00:04:38.800 --> 00:04:42.310
to be able to communicate
across those barriers.

00:04:42.310 --> 00:04:47.180
So thinking from the server
side, WebRTC needs two types

00:04:47.180 --> 00:04:49.430
of server-side functionality.

00:04:49.430 --> 00:04:53.760
You need stuff to do user
discovery communication

00:04:53.760 --> 00:04:58.670
signaling between clients, and
then you need servers that can

00:04:58.670 --> 00:05:04.900
help with net traversal and
streaming data communication.

00:05:04.900 --> 00:05:10.230
So what I would suggest is, if
you haven't done so already,

00:05:10.230 --> 00:05:14.230
especially if you're to WebRTC
is, do take a look at Justin

00:05:14.230 --> 00:05:17.640
Uberti's video from Google
I/O. You can

00:05:17.640 --> 00:05:18.680
find that on YouTube.

00:05:18.680 --> 00:05:24.960
So Justin Uberti's WebRTC Google
I/O video, which is

00:05:24.960 --> 00:05:25.820
great stuff.

00:05:25.820 --> 00:05:28.200
And if you want to find
out more about

00:05:28.200 --> 00:05:30.560
getUserMedia, the sort of--

00:05:30.560 --> 00:05:36.030
what you might have seen in
terms of stuff for using media

00:05:36.030 --> 00:05:38.860
stream-- take a look
at the HTML5 Rocks.

00:05:38.860 --> 00:05:43.070
HTML5rocks.com has a lot of
great documentation about

00:05:43.070 --> 00:05:45.600
using media streams, in
particular of course,

00:05:45.600 --> 00:05:46.850
getUserMedia.

00:05:49.780 --> 00:05:55.820
Now, what I would also suggest
is having a look, initially,

00:05:55.820 --> 00:05:58.540
to get your head around the
idea of peer connection.

00:05:58.540 --> 00:06:02.670
And if you looked at WebRTC.org,
you'll find some

00:06:02.670 --> 00:06:04.230
great information there.

00:06:04.230 --> 00:06:08.900
But one of the sites I would
recommend just to begin

00:06:08.900 --> 00:06:15.390
looking at peer connection is
WebRTC-demos.appspot.com,

00:06:15.390 --> 00:06:17.760
that's WebRTC-demos.appspot.com.

00:06:17.760 --> 00:06:21.672
And we will have links for these
available on the site.

00:06:24.270 --> 00:06:27.273
And then, once you've understood
something of peer

00:06:27.273 --> 00:06:31.040
connection, what you need to
do, I think, is move on to

00:06:31.040 --> 00:06:32.790
significalling and data
communication.

00:06:32.790 --> 00:06:35.375
And a great place to start that
is appRTC.appspot.com.

00:06:38.080 --> 00:06:40.330
And again, we'll put the
links up for that.

00:06:40.330 --> 00:06:44.140
So just to get straight down
here, we've, like I said, had

00:06:44.140 --> 00:06:49.100
some great questions from people
who are coming in to

00:06:49.100 --> 00:06:53.710
see what they'd like to
find out about WebRTC.

00:06:53.710 --> 00:06:57.830
So I'm just going to go over
now to the questions.

00:06:57.830 --> 00:07:02.700
And see what we've got on
Moderator, and then ask our

00:07:02.700 --> 00:07:04.470
panel of experts here.

00:07:04.470 --> 00:07:08.460
So OK, just starting straight
at the top.

00:07:08.460 --> 00:07:12.490
And, I guess Serge, I'll let
you dive in and see who you

00:07:12.490 --> 00:07:13.910
think might be best
to answer this.

00:07:13.910 --> 00:07:18.940
First question is from AIDGAB,
coming from Kazan.

00:07:18.940 --> 00:07:22.140
Please give some explanation
about how media can be

00:07:22.140 --> 00:07:25.816
broadcast using peer
connection.

00:07:25.816 --> 00:07:30.571
Are there any relays that
can be used with WebRTC?

00:07:30.571 --> 00:07:33.350
I think there's a couple of
questions inherent in this.

00:07:33.350 --> 00:07:34.600
SERGE LACHAPELLE: Justin, you
want to take that one?

00:07:37.790 --> 00:07:39.070
JUSTIN UBERTI: Sure.

00:07:39.070 --> 00:07:46.390
So the basic idea of doing a
multi-party communication,

00:07:46.390 --> 00:07:50.450
there's a couple ways that
you can approach this.

00:07:50.450 --> 00:07:53.710
One way is that you could
create multiple peer

00:07:53.710 --> 00:07:57.870
connections, one to each
participant, and create what's

00:07:57.870 --> 00:07:59.300
called a mesh network.

00:07:59.300 --> 00:08:01.840
And for small conferences,
this can

00:08:01.840 --> 00:08:03.310
actually work pretty well.

00:08:03.310 --> 00:08:05.940
You basically send your video
and audio to every other

00:08:05.940 --> 00:08:08.750
participant, and they
do the same.

00:08:08.750 --> 00:08:12.000
But, as you probably have
noticed, as this gets to

00:08:12.000 --> 00:08:16.410
larger conferences, this
becomes less efficient.

00:08:16.410 --> 00:08:20.550
And so this is where the fact
that we're working with the

00:08:20.550 --> 00:08:25.250
ITF and using standard protocols
allows others to

00:08:25.250 --> 00:08:28.030
create what we call
middle boxes.

00:08:28.030 --> 00:08:32.280
Middle boxes can be conferencing
servers that can

00:08:32.280 --> 00:08:34.059
do various things like
a traditional--

00:08:34.059 --> 00:08:36.419
what they call an MCU.

00:08:36.419 --> 00:08:40.690
An MCU basically takes all the
incoming video feeds, in this

00:08:40.690 --> 00:08:43.669
case from each peer connection,
would composite

00:08:43.669 --> 00:08:47.020
them into a single image, and
then would send it back out

00:08:47.020 --> 00:08:49.910
as, basically, the
group video with

00:08:49.910 --> 00:08:52.010
everybody's picture and sound.

00:08:52.010 --> 00:08:56.820
And WebRTC doesn't provide this
technology per se, but

00:08:56.820 --> 00:08:58.860
you can create it using--

00:08:58.860 --> 00:09:03.070
there are various products
that exist in internet.

00:09:03.070 --> 00:09:06.910
Things like Asterisk, other
services that people are

00:09:06.910 --> 00:09:09.900
creating based on WebRTC that
will be able to ride this sort

00:09:09.900 --> 00:09:11.720
of functionality.

00:09:11.720 --> 00:09:15.960
And then secondly, instead of
also doing that sort of

00:09:15.960 --> 00:09:18.480
compositor, you can also
think of these

00:09:18.480 --> 00:09:20.260
things are simple relays.

00:09:20.260 --> 00:09:23.780
That, when the data comes in, it
gets sort of broadcast out

00:09:23.780 --> 00:09:25.190
to all participants.

00:09:25.190 --> 00:09:28.180
And, again, these are things
that you can create using

00:09:28.180 --> 00:09:31.650
standard RTP protocols
because that's what

00:09:31.650 --> 00:09:33.282
WebRTC is built upon.

00:09:36.230 --> 00:09:38.210
SAM DUTTON: Thanks very much.

00:09:38.210 --> 00:09:40.182
One thing I'd like
to clear up--

00:09:40.182 --> 00:09:44.220
I guess I think when I was first
looking in WebRTC and

00:09:44.220 --> 00:09:47.510
trying to get my head around
it, there was some stuff

00:09:47.510 --> 00:09:50.330
relating to the different server
technologies that came

00:09:50.330 --> 00:09:53.040
up that was really new to
me as a web developer.

00:09:53.040 --> 00:09:55.670
And I was wondering if
one of you guys could

00:09:55.670 --> 00:09:56.610
talk us through that.

00:09:56.610 --> 00:09:59.860
So the three specific things I'm
talking about are-- well,

00:09:59.860 --> 00:10:04.370
the ICE Framework, and what that
consists of, and how TURN

00:10:04.370 --> 00:10:07.600
servers work, and what's a STUN
server, how does this

00:10:07.600 --> 00:10:08.380
stuff work?

00:10:08.380 --> 00:10:10.420
And why do we need it?

00:10:10.420 --> 00:10:11.630
And how does it fit?

00:10:11.630 --> 00:10:15.100
Where do I get one?

00:10:15.100 --> 00:10:18.780
JUSTIN UBERTI: OK, so, it
is a confusing area.

00:10:18.780 --> 00:10:21.060
In part it's because
the technology--

00:10:21.060 --> 00:10:23.490
and the names are kind
of overloaded.

00:10:23.490 --> 00:10:28.290
So when we talk about STUN, STUN
could be a mechanism for

00:10:28.290 --> 00:10:31.690
actually retrieving your IP
address as seen by the outside

00:10:31.690 --> 00:10:34.070
world from a STUN server.

00:10:34.070 --> 00:10:38.270
So it could also be the method
through which you do ICE.

00:10:38.270 --> 00:10:43.240
The type of connectivity check
message that you send from one

00:10:43.240 --> 00:10:46.170
side to the other are called
STUN messages.

00:10:46.170 --> 00:10:52.510
And recognizing this, the
authors of STUN have changed

00:10:52.510 --> 00:10:56.480
the acronym that STUN means
over time-- from being one

00:10:56.480 --> 00:10:58.730
specific thing now, it's
Session Traversal

00:10:58.730 --> 00:11:00.130
Utilities for Nat.

00:11:00.130 --> 00:11:02.040
It's kind of like a bag
of different tricks.

00:11:02.040 --> 00:11:05.080
Well anyway, so what does this
mean to the developer.

00:11:05.080 --> 00:11:10.090
Well, let's back up and look at
the fundamental part of the

00:11:10.090 --> 00:11:11.670
ice process.

00:11:11.670 --> 00:11:14.940
And Ice is Interactive
Connectivity Establishment.

00:11:14.940 --> 00:11:20.440
In a nutshell, what ICE involves
is that the client on

00:11:20.440 --> 00:11:24.590
either side will go and retrieve
as many IP addresses

00:11:24.590 --> 00:11:25.850
as they can find.

00:11:25.850 --> 00:11:29.290
Typically, this will be if the
local IP address, the IP

00:11:29.290 --> 00:11:32.990
address of its actual network
adapter, the STUN address,

00:11:32.990 --> 00:11:37.420
which is basically what the
outside world sees your IP

00:11:37.420 --> 00:11:38.910
addresses as being.

00:11:38.910 --> 00:11:41.430
You send a ping to a STUN
server, and the STUN server

00:11:41.430 --> 00:11:43.770
replies back with the IP
address that it saw

00:11:43.770 --> 00:11:45.500
that ping come from.

00:11:45.500 --> 00:11:47.710
And that gives you your
outside address.

00:11:47.710 --> 00:11:52.660
And then lastly, you can ask
TURN server, which is

00:11:52.660 --> 00:11:56.030
basically a network interface
in the cloud, if you will.

00:11:56.030 --> 00:11:59.290
And it's an IP address in the
cloud that you can kind of

00:11:59.290 --> 00:12:02.730
access and, in some cases,
this is the one you'll

00:12:02.730 --> 00:12:04.080
actually want to use.

00:12:04.080 --> 00:12:08.330
Now as I mentioned, each client
server retrieves these

00:12:08.330 --> 00:12:12.910
addresses, the STUN, the TURN,
and local address, and they

00:12:12.910 --> 00:12:17.090
send them to the other side and
then both sides basically

00:12:17.090 --> 00:12:20.790
send checks from their network
interfaces to these addresses

00:12:20.790 --> 00:12:23.110
they've been provided
with by a peer.

00:12:23.110 --> 00:12:25.820
And they figure out which ones
are actually usable for

00:12:25.820 --> 00:12:27.800
sending and receiving data.

00:12:27.800 --> 00:12:30.740
And whichever one ends up being
the one that works and

00:12:30.740 --> 00:12:32.560
is the most efficient is
the one that's actually

00:12:32.560 --> 00:12:33.820
used for the call.

00:12:33.820 --> 00:12:37.780
So looking back, the
terminology, ICE is the

00:12:37.780 --> 00:12:41.130
process through which these
checks are done.

00:12:41.130 --> 00:12:44.590
TURN is the actual server that
lives in the cloud that

00:12:44.590 --> 00:12:48.980
provides you with a sort of
IP address in the cloud.

00:12:48.980 --> 00:12:50.480
In cases where your
STUN address

00:12:50.480 --> 00:12:52.080
isn't immediately usable.

00:12:52.080 --> 00:12:54.590
And there some cases, depending
on your NAT behavior

00:12:54.590 --> 00:12:57.540
where the STUN address just
won't work for actual

00:12:57.540 --> 00:12:58.270
communication.

00:12:58.270 --> 00:13:04.380
And then STUN, is, in addition
to this sort of bag of

00:13:04.380 --> 00:13:08.360
utilities for making all this
stuff happen, it's the type of

00:13:08.360 --> 00:13:11.960
server that's used to discover
your NAT address, and it's the

00:13:11.960 --> 00:13:15.010
type of sort of
connectivity-check message

00:13:15.010 --> 00:13:17.470
that's sent from client
to client as

00:13:17.470 --> 00:13:19.760
part of the ICE process.

00:13:19.760 --> 00:13:22.190
Does that all make sense?

00:13:22.190 --> 00:13:24.330
SAM DUTTON: Yeah, thank
you, thank you.

00:13:24.330 --> 00:13:27.890
Serge, I think you've got
a nice diagram up there.

00:13:27.890 --> 00:13:29.200
Should we go over to that?

00:13:32.630 --> 00:13:34.580
JUSTIN UBERTI: Ah yeah, that's
a great diagram.

00:13:34.580 --> 00:13:38.310
SAM DUTTON: Yeah,
can we see this.

00:13:38.310 --> 00:13:43.655
So yeah, but maybe we could just
talk through that briefly

00:13:43.655 --> 00:13:45.760
and see what's there?

00:13:45.760 --> 00:13:47.460
JUSTIN UBERTI: So right, I mean
this is a great diagram.

00:13:47.460 --> 00:13:50.510
It shows two peers, each
behind a NAT device.

00:13:58.720 --> 00:13:59.520
SERGE LACHAPELLE: Oops,
Justin, I think

00:13:59.520 --> 00:14:00.770
you got muted, sorry.

00:14:03.650 --> 00:14:04.470
JUSTIN UBERTI: Sorry.

00:14:04.470 --> 00:14:07.615
OK, as I was saying, so we
have two peers here each

00:14:07.615 --> 00:14:09.020
behind NAT.

00:14:09.020 --> 00:14:12.330
And then the relay server, which
is also known as the

00:14:12.330 --> 00:14:15.020
TURN server, typically,
and STUN server.

00:14:15.020 --> 00:14:19.240
And the peer contacts the STUN
server can learn the address

00:14:19.240 --> 00:14:20.870
of its NAT.

00:14:20.870 --> 00:14:21.530
[INAUDIBLE]

00:14:21.530 --> 00:14:25.890
TURN server can learn the
IP address in the cloud.

00:14:25.890 --> 00:14:30.080
And then it shares those
addresses with remote peer

00:14:30.080 --> 00:14:32.020
through the cloud.

00:14:32.020 --> 00:14:34.750
And then they perform the
connectivity checks.

00:14:34.750 --> 00:14:36.640
That part isn't shown here.

00:14:36.640 --> 00:14:39.370
But basically, we could figure
out what pathway the media can

00:14:39.370 --> 00:14:40.790
actually take.

00:14:40.790 --> 00:14:46.470
And for most consumer NATs,
it'll be the STUN address.

00:14:46.470 --> 00:14:49.920
Because the NAT basically says
that the address learned from

00:14:49.920 --> 00:14:53.390
the STUN server can also be
used for communication.

00:14:53.390 --> 00:14:57.320
On some enterprise-grade NATs,
the rules are a little

00:14:57.320 --> 00:15:01.290
different, that the address
learned from the STUN server

00:15:01.290 --> 00:15:03.070
can't actually be used
for communication

00:15:03.070 --> 00:15:04.100
with a remote peer.

00:15:04.100 --> 00:15:07.810
And in these cases, at least one
side will need to use the

00:15:07.810 --> 00:15:09.710
relay server in order
to get the media

00:15:09.710 --> 00:15:12.830
from one side to another.

00:15:12.830 --> 00:15:14.080
SERGE LACHAPELLE: Great.

00:15:16.260 --> 00:15:17.110
SAM DUTTON: That's brilliant.

00:15:17.110 --> 00:15:21.620
I guess they way I understand
it, just correct me if this is

00:15:21.620 --> 00:15:25.670
wrong, so the understanding I
have is that when you're using

00:15:25.670 --> 00:15:30.190
WebRTC, essentially, the
framework will attempt to make

00:15:30.190 --> 00:15:34.580
a direct connection between the
peers and if that fails

00:15:34.580 --> 00:15:37.150
will revert to using
a relay server.

00:15:37.150 --> 00:15:39.430
That's probably a gross
simplification but is that

00:15:39.430 --> 00:15:42.490
something like what's
happening here.

00:15:42.490 --> 00:15:44.580
JUSTIN UBERTI: Yeah, that's
exactly what going on.

00:15:44.580 --> 00:15:47.870
I would say it's a little bit
more than that because rather

00:15:47.870 --> 00:15:50.940
than have to sort of try one
thing, and then only fall back

00:15:50.940 --> 00:15:54.550
and use the other thing if it
fails, and have a delay

00:15:54.550 --> 00:15:57.320
associated with that, we're
kind of trying all these

00:15:57.320 --> 00:15:58.870
things in parallel.

00:15:58.870 --> 00:16:02.640
And that may mean that we use
the relay connection first,

00:16:02.640 --> 00:16:06.040
and then we maybe find out later
that another connection

00:16:06.040 --> 00:16:06.770
is actually better.

00:16:06.770 --> 00:16:09.950
And in a case like that, we can
get the call running as

00:16:09.950 --> 00:16:12.840
soon as possible on the first
connection we have and then

00:16:12.840 --> 00:16:17.310
maybe transition to a more
efficient connection type as

00:16:17.310 --> 00:16:20.590
the actual ICE process
proceeds.

00:16:20.590 --> 00:16:22.440
SAM DUTTON: Gotcha, so it's not
just about connectivity.

00:16:22.440 --> 00:16:23.400
It's about efficient

00:16:23.400 --> 00:16:27.710
connectivity and data transfer.

00:16:27.710 --> 00:16:30.710
OK, I'm just going to go over to
the questions again because

00:16:30.710 --> 00:16:33.680
we've got a stack of
good ones here.

00:16:33.680 --> 00:16:36.300
So yeah, this is a question a
lot of developers are asking.

00:16:36.300 --> 00:16:40.400
From Fred in [INAUDIBLE] in
Germany, "When will data

00:16:40.400 --> 00:16:43.590
connections be available for
developers." So I guess

00:16:43.590 --> 00:16:45.600
thinking here about
data channels.

00:16:45.600 --> 00:16:48.910
SERGE LACHAPELLE: So I
can answer that one.

00:16:48.910 --> 00:16:52.250
We've posted our roadmap
on the Chromium blog.

00:16:52.250 --> 00:16:57.510
So if you search on the Chromium
blog and for WebRTC,

00:16:57.510 --> 00:16:58.530
you'll find it there.

00:16:58.530 --> 00:17:05.430
Basically we first want to go
into Chrome stable with just

00:17:05.430 --> 00:17:06.750
audio and video.

00:17:06.750 --> 00:17:09.690
And once that's working well,
we'll start cranking on the

00:17:09.690 --> 00:17:11.650
data channel thing.

00:17:11.650 --> 00:17:15.359
So it's just a question of
having to focus and prioritize

00:17:15.359 --> 00:17:17.319
things properly.

00:17:17.319 --> 00:17:20.220
And so we decided to go with
audio and video first.

00:17:20.220 --> 00:17:24.420
And right after that, once
you've seen audio and video go

00:17:24.420 --> 00:17:28.490
from behind a flag into the
public Chrome, that's a good

00:17:28.490 --> 00:17:30.020
signal that we're starting
to work on the

00:17:30.020 --> 00:17:32.140
data channel stuff.

00:17:32.140 --> 00:17:34.510
SAM DUTTON: Cool, cool It's
incredibly powerful.

00:17:34.510 --> 00:17:37.330
I don't know who'd like to
just talk this through.

00:17:37.330 --> 00:17:40.860
But data channel is going to
be a whole other set of

00:17:40.860 --> 00:17:45.540
possibilities for all kinds
of applications.

00:17:45.540 --> 00:17:48.150
JUSTIN UBERTI: Oh absolutely,
it basically changes any web

00:17:48.150 --> 00:17:51.450
application into a peer-to-peer
application.

00:17:51.450 --> 00:17:56.680
And by providing great tools
built in-- we'll have support

00:17:56.680 --> 00:17:59.130
for unreliable and
reliable data and

00:17:59.130 --> 00:18:01.630
things like flow control--

00:18:01.630 --> 00:18:05.510
we basically solve a lot of
the problems that P2P apps

00:18:05.510 --> 00:18:07.720
right now have to solve
themselves.

00:18:07.720 --> 00:18:11.470
So the bag of tools that we're
going to be providing web

00:18:11.470 --> 00:18:15.450
developers in a really
easy-to-use package, I think

00:18:15.450 --> 00:18:17.330
is just going to be very
transformative.

00:18:17.330 --> 00:18:19.660
There's all sorts of
applications that need to send

00:18:19.660 --> 00:18:24.200
a lot of data, or send data
with very low latency.

00:18:24.200 --> 00:18:27.175
And what they'll be able to
do with this API should be

00:18:27.175 --> 00:18:29.270
incredible.

00:18:29.270 --> 00:18:30.840
SAM DUTTON: One of the questions
I've had personally

00:18:30.840 --> 00:18:34.530
is people asking, what's the
relationship between web

00:18:34.530 --> 00:18:37.070
sockets and so WebRTC.

00:18:37.070 --> 00:18:39.930
Are these two technologies
doing the same thing or

00:18:39.930 --> 00:18:41.876
something different?

00:18:41.876 --> 00:18:44.950
JUSTIN UBERTI: Well, they're
slightly different, but

00:18:44.950 --> 00:18:47.890
conceptually they're
kind of the same.

00:18:47.890 --> 00:18:51.770
They're a pipe that you want
to be able to send data to

00:18:51.770 --> 00:18:54.770
somebody else in any format.

00:18:54.770 --> 00:18:58.310
And so a web socket will
transmit a server, because

00:18:58.310 --> 00:19:02.730
it's done over HTTP and goes
to a web server, whereas a

00:19:02.730 --> 00:19:05.440
data channel will go
directly to a peer.

00:19:05.440 --> 00:19:10.100
Now those kind of differences
don't really affect the

00:19:10.100 --> 00:19:12.960
overall architecture of
how you can send data.

00:19:12.960 --> 00:19:16.280
And so what we've done is we've
created an API for the

00:19:16.280 --> 00:19:20.580
data channel that matches what
the web socket API is

00:19:20.580 --> 00:19:21.750
syntactically.

00:19:21.750 --> 00:19:24.072
And so if you have an
application that's written to

00:19:24.072 --> 00:19:27.120
use web sockets, you should be
able to transition it to use

00:19:27.120 --> 00:19:30.870
data channels extremely easily
because we've tried to keep

00:19:30.870 --> 00:19:33.830
that difference as small
as possible.

00:19:33.830 --> 00:19:36.820
And in most cases, the syntax
should be identical.

00:19:36.820 --> 00:19:40.420
But the real difference is that
a web socket is always

00:19:40.420 --> 00:19:43.450
reliable, there's no support
for unreliable data, and it

00:19:43.450 --> 00:19:46.088
always goes to a server.

00:19:46.088 --> 00:19:50.190
A data channel will always will
go to a peer, although

00:19:50.190 --> 00:19:51.790
the peer could be a server.

00:19:51.790 --> 00:19:53.850
You could also talk to a server
if you wanted to send

00:19:53.850 --> 00:19:56.000
unreliable data to a server.

00:19:56.000 --> 00:19:59.030
But it has a lot more
flexibility in terms of what

00:19:59.030 --> 00:20:02.000
the actual communication
protocol should be because

00:20:02.000 --> 00:20:06.008
we're not having to constrain
ourselves to HTTP.

00:20:06.008 --> 00:20:08.390
SAM DUTTON: OK, thanks
for that.

00:20:08.390 --> 00:20:15.540
Just going over to a very
specific question on the

00:20:15.540 --> 00:20:20.000
Moderator questions here
from Lorenzo Minero.

00:20:20.000 --> 00:20:22.630
He's asking, "Are you going
to add a way to specify

00:20:22.630 --> 00:20:26.060
resolution and frame rate
for an outgoing stream?

00:20:26.060 --> 00:20:28.830
Would this is the media stream
property or something that

00:20:28.830 --> 00:20:32.330
would need to be adjusted
to via JSEP?"

00:20:32.330 --> 00:20:36.070
Just before we go into that,
maybe a little quick

00:20:36.070 --> 00:20:39.310
explanation about JSEP.

00:20:39.310 --> 00:20:45.030
Now, what people may have seen
was the original WebKit peer

00:20:45.030 --> 00:20:49.520
connection object, which has
become WebKit deprecated peer

00:20:49.520 --> 00:20:49.990
connection.

00:20:49.990 --> 00:20:54.420
Now, the idea of this is that
the original implementation

00:20:54.420 --> 00:20:58.980
pre-JSEP, the demos that used
that stuff and applications

00:20:58.980 --> 00:21:02.330
could still use that format.

00:21:02.330 --> 00:21:07.130
And now, as we move on to JSEP
implementations before full

00:21:07.130 --> 00:21:13.140
standardization, that we can
call those by a different

00:21:13.140 --> 00:21:16.640
name-- peer connection, 00,
something like that.

00:21:16.640 --> 00:21:19.660
Maybe Justin would like to just
tell us a little bit more

00:21:19.660 --> 00:21:21.070
about that, or maybe
for Tommy.

00:21:23.730 --> 00:21:24.350
TOM: So--

00:21:24.350 --> 00:21:27.570
and if you are really
interested this.

00:21:27.570 --> 00:21:31.620
If you look at the latest
editor's draft of the peer

00:21:31.620 --> 00:21:37.090
connection standard, you'll
see that we have objects

00:21:37.090 --> 00:21:39.330
called media constraints.

00:21:39.330 --> 00:21:40.890
That's not the final name.

00:21:40.890 --> 00:21:46.370
But they will contain
constraints that are either

00:21:46.370 --> 00:21:49.020
optional or mandatory.

00:21:49.020 --> 00:21:54.110
So you can say that, I want a
video at at least 320 pixels.

00:21:54.110 --> 00:22:00.210
But I they really want to
have 640-wide video.

00:22:00.210 --> 00:22:01.530
And that can be--

00:22:01.530 --> 00:22:04.230
those kind of specifications can
be added when you create

00:22:04.230 --> 00:22:08.330
the peer connection, but also
when you create your own

00:22:08.330 --> 00:22:11.090
answer or create your offer.

00:22:11.090 --> 00:22:15.220
And also when you add your
stream to the peer connection.

00:22:15.220 --> 00:22:18.040
So yes. there will be complete
configurability for this.

00:22:21.010 --> 00:22:23.500
SAM DUTTON: Great,
thanks very much.

00:22:23.500 --> 00:22:25.080
Interesting stuff.

00:22:25.080 --> 00:22:27.490
A couple of questions
from that Ted at

00:22:27.490 --> 00:22:31.290
Cloudeo based in Poland.

00:22:31.290 --> 00:22:33.870
I guess that's Poland, Poland.

00:22:33.870 --> 00:22:35.550
But a couple of good
questions.

00:22:35.550 --> 00:22:40.800
Firstly asking, "Do you plan to
add an ability to transmit

00:22:40.800 --> 00:22:44.960
multiple streams using a
single VPN connection?

00:22:44.960 --> 00:22:47.350
I'm thinking about a
conferencing server built

00:22:47.350 --> 00:22:52.910
using WebRTC library that will
use single peer connection per

00:22:52.910 --> 00:22:55.637
participant." Who would
like to take that?

00:22:58.930 --> 00:23:00.260
JUSTIN UBERTI: I can
speak to that one.

00:23:02.770 --> 00:23:07.040
We've got the addstream API,
where you can basically add a

00:23:07.040 --> 00:23:08.390
stream to a peer connection.

00:23:08.390 --> 00:23:11.820
But there is obviously no reason
why you couldn't add

00:23:11.820 --> 00:23:13.070
more than one stream.

00:23:13.070 --> 00:23:17.315
And especially on the remote
side, you could have the

00:23:17.315 --> 00:23:19.200
remote side, if you have some
conferencing server, add

00:23:19.200 --> 00:23:22.060
multiple streams to your
incoming peer connection.

00:23:22.060 --> 00:23:25.380
And you'd be notified as to
each one of these streams.

00:23:25.380 --> 00:23:32.800
And the mechanism for which this
is done is we're thinking

00:23:32.800 --> 00:23:36.350
that within a given RTP session
that's on a peer

00:23:36.350 --> 00:23:42.110
connection, you can have what
we call multiple SSRC And an

00:23:42.110 --> 00:23:45.010
SSRC corresponds to a
media stream track.

00:23:45.010 --> 00:23:48.400
And then tracks, as you know,
go into a media stream.

00:23:48.400 --> 00:23:53.600
And so you could imagine in a
multi-user conference you

00:23:53.600 --> 00:23:57.740
could end up getting multiple
media streams, and then

00:23:57.740 --> 00:23:59.770
basically each meda stream
would correspond to a

00:23:59.770 --> 00:24:01.290
participant.

00:24:01.290 --> 00:24:04.480
And then each stream would have
a track for audio and a

00:24:04.480 --> 00:24:07.248
track for video for each
participant's audio and video.

00:24:11.890 --> 00:24:14.030
SAM DUTTON: Thanks very much,
that's interesting stuff.

00:24:14.030 --> 00:24:18.395
Another question from the
moderator stream that we're

00:24:18.395 --> 00:24:19.440
getting here.

00:24:19.440 --> 00:24:21.960
This is from the Dimitri
in Moscow.

00:24:21.960 --> 00:24:26.810
The question is, "We need a way
to save and send recorded

00:24:26.810 --> 00:24:30.250
video and audio via media
stream record, which was

00:24:30.250 --> 00:24:33.100
announced on Google I/O 2012.

00:24:33.100 --> 00:24:35.440
When will appear in Chrome?"

00:24:35.440 --> 00:24:39.840
Before we answer that, just one
thing I'd like to-- just a

00:24:39.840 --> 00:24:42.940
warning, really, that people may
have seen on the web blog

00:24:42.940 --> 00:24:49.680
posts talking about platforms
that implement WebRTC, where

00:24:49.680 --> 00:24:52.820
in fact the platforms have
actually only implemented

00:24:52.820 --> 00:24:55.080
getUserMedia.

00:24:55.080 --> 00:24:59.880
There's, of course, more to
WebRTC than just getUserMedia.

00:24:59.880 --> 00:25:02.170
There's the whole,
actual real-time

00:25:02.170 --> 00:25:04.000
communication part of it.

00:25:04.000 --> 00:25:07.550
But going back to the question,
maybe Serge, if you

00:25:07.550 --> 00:25:08.800
could take this one.

00:25:11.750 --> 00:25:12.080
SERGE LACHAPELLE: Sure.

00:25:12.080 --> 00:25:15.490
There's been a ton of requests
for being able to record media

00:25:15.490 --> 00:25:17.490
locally from the browser.

00:25:17.490 --> 00:25:22.770
And unfortunately, the API for
media recording isn't fully

00:25:22.770 --> 00:25:23.910
baked right now.

00:25:23.910 --> 00:25:27.230
So we're kind of taking a step
back and letting the standards

00:25:27.230 --> 00:25:30.180
process do its thing.

00:25:30.180 --> 00:25:35.300
And when there's a stable draft,
we will start working

00:25:35.300 --> 00:25:36.710
on implementing that.

00:25:36.710 --> 00:25:41.100
Right now we'll be focusing on
real-time audio and video

00:25:41.100 --> 00:25:43.306
going forward.

00:25:43.306 --> 00:25:44.570
SAM DUTTON: OK, thanks
very much.

00:25:44.570 --> 00:25:48.760
Another question that we've had
from a lot of developers.

00:25:48.760 --> 00:25:52.650
Going over to [? Hersian ?]
from Hazara in Pakistan.

00:25:52.650 --> 00:25:56.437
"Is there any possibility for
audio-only communication among

00:25:56.437 --> 00:25:58.030
peers in future.

00:25:58.030 --> 00:26:01.920
That is audio tag can understand
remote streams and

00:26:01.920 --> 00:26:05.370
generated blogs." And I
think I'll give this

00:26:05.370 --> 00:26:10.340
to Malanet, I think.

00:26:10.340 --> 00:26:11.760
MALANET: Yeah.

00:26:11.760 --> 00:26:13.390
I think that that's definitely
possible.

00:26:13.390 --> 00:26:16.300
I mean, you can have
it [INAUDIBLE]

00:26:16.300 --> 00:26:18.320
[? spend ?] having this
[? article. ?]

00:26:18.320 --> 00:26:21.570
And right now we aren't
implementing that tag, but we

00:26:21.570 --> 00:26:23.710
are in the process of
implementing a tag according

00:26:23.710 --> 00:26:24.960
to that feature.

00:26:28.230 --> 00:26:30.850
SAM DUTTON: OK, thanks
very much.

00:26:30.850 --> 00:26:34.200
Another question from
Ted at Cloudeo.

00:26:34.200 --> 00:26:36.750
He's asking about HTTP
streaming fallback.

00:26:36.750 --> 00:26:43.060
The IETF WebRTC use cases and
requirements doc has NF37

00:26:43.060 --> 00:26:46.470
requirements stating that the
browser must be able to stream

00:26:46.470 --> 00:26:49.200
data using HTTP.

00:26:49.200 --> 00:26:53.440
Any idea on how you plan
to achieve this?

00:26:53.440 --> 00:26:57.550
JUSTIN UBERTI: So I'll
take this one.

00:26:57.550 --> 00:27:01.580
There are a bunch of techniques
that apps today use

00:27:01.580 --> 00:27:08.430
to work over HTTP because most
of our communication apps we

00:27:08.430 --> 00:27:11.420
run in environments where the
firewalls basically knock down

00:27:11.420 --> 00:27:13.390
everything except HTTP.

00:27:13.390 --> 00:27:14.500
And we still need to work.

00:27:14.500 --> 00:27:17.010
And so WebRTC needs to work
in this scenario too.

00:27:17.010 --> 00:27:21.500
And there are a bunch of tricks
that can be done to

00:27:21.500 --> 00:27:22.240
accomplish this.

00:27:22.240 --> 00:27:25.630
I won't go into all the details,
but one easy one is

00:27:25.630 --> 00:27:30.630
to do HTTP Connect, which is
kind of the way that SSL is

00:27:30.630 --> 00:27:33.550
used to connect through
an HTTP proxy.

00:27:33.550 --> 00:27:40.050
And basically, an SLL
connection, the data is opaque

00:27:40.050 --> 00:27:43.010
to the proxy or opaque to
whatever's making this

00:27:43.010 --> 00:27:43.870
connection.

00:27:43.870 --> 00:27:49.950
And so if we send our data and
make it look HTTPS then,

00:27:49.950 --> 00:27:52.020
basically, we can go
through proxies.

00:27:52.020 --> 00:27:54.940
We can go through things that
are restricting to HTTP and

00:27:54.940 --> 00:27:56.260
HTTPS only.

00:27:56.260 --> 00:28:01.630
And this is obviously a very
important part of making sure

00:28:01.630 --> 00:28:03.360
WebRTC can work everywhere.

00:28:03.360 --> 00:28:07.750
And servers, turn servers and
such, will need to sort of be

00:28:07.750 --> 00:28:10.110
aware, when you're making
extensions to the

00:28:10.110 --> 00:28:14.455
specifications, to deal with
being able to allocate ports

00:28:14.455 --> 00:28:17.320
and stuff like that over
HTTPS instead of over

00:28:17.320 --> 00:28:18.980
just vanilla TCP.

00:28:18.980 --> 00:28:22.300
But like I said, it's already
in use today in various

00:28:22.300 --> 00:28:26.910
products, and it'll definitely
find its way into WebRTC.

00:28:26.910 --> 00:28:29.106
SAM DUTTON: Cool, cool,
thanks so much.

00:28:29.106 --> 00:28:32.020
We've got a question about
protocols, actually, but this

00:28:32.020 --> 00:28:35.820
raise, to my mind, it's a big
question about the way

00:28:35.820 --> 00:28:38.250
signaling works with WebRTC.

00:28:38.250 --> 00:28:43.950
And one thing about WebRTC is
that so it doesn't make

00:28:43.950 --> 00:28:46.840
specifications for
signaling methods

00:28:46.840 --> 00:28:48.500
or signaling protocols.

00:28:48.500 --> 00:28:54.320
And as I understand it, the kind
of name this architecture

00:28:54.320 --> 00:28:57.830
has been called JSEP.

00:28:57.830 --> 00:29:01.650
And I'm just wondering if is one
of the people we're with

00:29:01.650 --> 00:29:04.210
there could just give us a
little bit more detail.

00:29:04.210 --> 00:29:06.240
What is this JSEP thing?

00:29:06.240 --> 00:29:13.250
And what was the design process
that led to that.

00:29:13.250 --> 00:29:17.190
So some talk about protocols,
signaling, and the

00:29:17.190 --> 00:29:17.880
methods we can use.

00:29:17.880 --> 00:29:23.300
Because I've seen different
approaches using XHR, and the

00:29:23.300 --> 00:29:25.290
channel API Google,
or with websites.

00:29:25.290 --> 00:29:29.310
So yeah, maybe Serge could
kick this off.

00:29:29.310 --> 00:29:32.995
SERGE LACHAPELLE: So JSEP
means JavaScript--

00:29:32.995 --> 00:29:36.010
God, I always forget the E.

00:29:36.010 --> 00:29:36.770
JUSTIN UBERTI: Establishment.

00:29:36.770 --> 00:29:38.290
SERGE LACHAPELLE: Establishment,
thank you.

00:29:38.290 --> 00:29:40.060
JavaScript Establishment
Protocol.

00:29:40.060 --> 00:29:50.360
And it reuses the strength
of the browser.

00:29:50.360 --> 00:29:53.330
Browsers are great at
communicating over HTTP.

00:29:53.330 --> 00:29:59.730
And so JSEP reuses that channel
for all its signaling

00:29:59.730 --> 00:30:06.960
and what JSEP gives us are a
low-level API that allows us

00:30:06.960 --> 00:30:10.100
to then encapsulate other
protocols on it.

00:30:10.100 --> 00:30:12.440
So it's really protocol-neutral.

00:30:12.440 --> 00:30:17.700
And so we think that JSEP
strikes a good balance for web

00:30:17.700 --> 00:30:21.870
developers that want to get up
and running quickly, and more

00:30:21.870 --> 00:30:25.410
advanced developers that might
want to encapsulate other

00:30:25.410 --> 00:30:28.570
established voice-over-IP
protocols or create their own

00:30:28.570 --> 00:30:30.370
more advanced protocols.

00:30:30.370 --> 00:30:35.560
So it's really a lower-level
API that allows you to

00:30:35.560 --> 00:30:38.780
encapsulate other protocols.

00:30:38.780 --> 00:30:40.350
JUSTIN UBERTI: And we're seeing
people do great stuff

00:30:40.350 --> 00:30:42.600
with this already.

00:30:42.600 --> 00:30:45.480
People already have SIP
in the browser.

00:30:45.480 --> 00:30:47.280
It's something called SIPML5.

00:30:49.900 --> 00:30:56.250
By taking the JSEP API and
converting it into SIP.

00:30:56.250 --> 00:30:59.650
And we've already seen other
things where the API can be

00:30:59.650 --> 00:31:01.840
converted into XMTP.

00:31:01.840 --> 00:31:06.040
The whole idea behind JSEP is
to not bake the signalling

00:31:06.040 --> 00:31:07.440
protocol in the browser.

00:31:07.440 --> 00:31:10.410
So that applications can use
whatever they need, whether

00:31:10.410 --> 00:31:12.800
it's SIP, whether it's XMTP,
whether it's something custom

00:31:12.800 --> 00:31:17.230
to the application, and not
constrained by the API.

00:31:17.230 --> 00:31:19.730
And so far we're seeing
that work out

00:31:19.730 --> 00:31:22.610
exactly as we had intended.

00:31:22.610 --> 00:31:23.440
SAM DUTTON: Cool, OK, thanks.

00:31:23.440 --> 00:31:26.220
I just realized we've got about
three minutes to go.

00:31:26.220 --> 00:31:30.080
So another couple of
quick questions.

00:31:30.080 --> 00:31:33.051
Again, something I've heard from
developers, from Matt in

00:31:33.051 --> 00:31:35.390
the United States-- "How
is security handled?

00:31:35.390 --> 00:31:38.080
Could chat sessions be
intercepted or accessed by

00:31:38.080 --> 00:31:45.140
third parties?" Maybe, Serge?

00:31:45.140 --> 00:31:48.450
SERGE LACHAPELLE: Well, we've
taken the opportunity, when

00:31:48.450 --> 00:31:55.640
designing and proposing this API
and the protocols, to make

00:31:55.640 --> 00:31:57.270
sure that encryption
was turned on

00:31:57.270 --> 00:31:59.100
from the very beginning.

00:31:59.100 --> 00:32:04.390
So encryption for communication
peer-to-pere is

00:32:04.390 --> 00:32:05.900
not an option.

00:32:05.900 --> 00:32:07.590
It's on by default.

00:32:07.590 --> 00:32:14.940
And so right now, at the ITF
there are discussions on what

00:32:14.940 --> 00:32:16.790
types of encryption
and what types of

00:32:16.790 --> 00:32:18.470
authentication to use.

00:32:18.470 --> 00:32:22.440
But I think there's strong
sentiment to have encryption

00:32:22.440 --> 00:32:24.590
be on from the start.

00:32:24.590 --> 00:32:29.570
Maybe Justin can fill in where
our implementation is in

00:32:29.570 --> 00:32:31.550
regards to encryption today.

00:32:31.550 --> 00:32:35.700
JUSTIN UBERTI: Right, so we
support SRTP, which is a

00:32:35.700 --> 00:32:38.990
secure RTP in our current
implementation right now.

00:32:38.990 --> 00:32:42.590
And as Serge mentioned, that's
going to be the standard it's

00:32:42.590 --> 00:32:46.065
been required for
implementations of WebRTC.

00:32:46.065 --> 00:32:51.610
And that uses AES and
SHA1, really, it's

00:32:51.610 --> 00:32:53.870
state-of-the-art security.

00:32:53.870 --> 00:32:58.340
And we're also looking at
doing something a step

00:32:58.340 --> 00:33:02.600
further, which is something
called DTLS SRTP, which uses

00:33:02.600 --> 00:33:06.650
the datagram TMS protocol to
set up the keys for SRTP,

00:33:06.650 --> 00:33:10.500
which makes it a lot harder
for any sort of man in the

00:33:10.500 --> 00:33:15.450
middle or anything like
that to be able to

00:33:15.450 --> 00:33:16.430
interface to the keys.

00:33:16.430 --> 00:33:17.960
Because the keys are,
basically, only

00:33:17.960 --> 00:33:19.920
know by either side.

00:33:19.920 --> 00:33:23.790
And it provides a little bit
more traditional guarantee

00:33:23.790 --> 00:33:26.770
that, not only is the media
secure, but that the keying

00:33:26.770 --> 00:33:31.330
and everything like that has
been done in a form that's

00:33:31.330 --> 00:33:32.580
future-safe.

00:33:34.660 --> 00:33:36.160
SAM DUTTON: Cool, OK.

00:33:36.160 --> 00:33:39.440
And another question we've,
again, had from a lot of

00:33:39.440 --> 00:33:44.960
developers is just wondering
when we might see WebRTC

00:33:44.960 --> 00:33:49.250
implemented in Chrome
for Android.

00:33:49.250 --> 00:33:51.620
SERGE LACHAPELLE: Android, and
mobiles in general, are

00:33:51.620 --> 00:33:53.650
extremely interesting for us.

00:33:53.650 --> 00:34:00.320
As a team, we've decided to
iterate on the API spec and

00:34:00.320 --> 00:34:07.020
help the API get to 1.0 version
using the desktop.

00:34:07.020 --> 00:34:08.730
So that's really been how we've

00:34:08.730 --> 00:34:10.170
been executing currently.

00:34:10.170 --> 00:34:13.270
We've been working on the
desktop to be sure that we can

00:34:13.270 --> 00:34:17.699
provide good strong feedback
to the W3C and the ITF.

00:34:17.699 --> 00:34:25.400
Now once we come out from behind
the flag, and the API

00:34:25.400 --> 00:34:27.810
has reached a stable state,
we're going to start cranking

00:34:27.810 --> 00:34:28.980
on mobile as well.

00:34:28.980 --> 00:34:32.449
So if you look at the
code.webrtc.com, you'll see

00:34:32.449 --> 00:34:34.389
there's a lot of mobile
components

00:34:34.389 --> 00:34:37.170
that are there already.

00:34:37.170 --> 00:34:42.159
We'll just need to package it
all in into nice WebRTC for

00:34:42.159 --> 00:34:44.520
the Chrome browser on Android.

00:34:44.520 --> 00:34:46.659
But first, desktop.

00:34:46.659 --> 00:34:49.370
SAM DUTTON: Yeah, and that
brings me to my final question

00:34:49.370 --> 00:34:51.470
actually, which again
there's a few of

00:34:51.470 --> 00:34:54.739
these on the Moderator.

00:34:54.739 --> 00:34:57.450
If we could just have an
overview of where we are now

00:34:57.450 --> 00:35:03.660
with implementation on the
desktop in Chrome.

00:35:03.660 --> 00:35:06.660
SERGE LACHAPELLE: So you
probably saw, a blog post

00:35:06.660 --> 00:35:09.560
recently about getUserMedia.

00:35:09.560 --> 00:35:13.510
And so that's the ability to
access basic webcam and

00:35:13.510 --> 00:35:16.210
microphone from the browser.

00:35:16.210 --> 00:35:19.510
And that's going
into Chrome 21.

00:35:19.510 --> 00:35:23.600
In Chrome 22, we're going to
add the ability to remember

00:35:23.600 --> 00:35:25.570
decisions for secure websites.

00:35:25.570 --> 00:35:29.870
So if you're on an HTTPS
website, you'll be able to

00:35:29.870 --> 00:35:33.970
always allow certain websites
to use the camera and

00:35:33.970 --> 00:35:34.590
microphone.

00:35:34.590 --> 00:35:39.560
And this is going to make many
web app developers very happy.

00:35:39.560 --> 00:35:43.000
So then we won't have to press
the allow buttom all the time.

00:35:43.000 --> 00:35:49.000
Post that, we've just gotten
a new draft from the W3C

00:35:49.000 --> 00:35:51.700
specifying the WebRTC API.

00:35:51.700 --> 00:35:56.310
We think that this draft is good
enough now to implement,

00:35:56.310 --> 00:35:59.970
and modify our implementation
a little bit, and try to get

00:35:59.970 --> 00:36:01.500
that from behind a the flag.

00:36:01.500 --> 00:36:05.900
I don't know exactly where on
the Chrome releases we're

00:36:05.900 --> 00:36:09.790
going to end up, but fairly soon
we're going to be coming

00:36:09.790 --> 00:36:12.850
out from behind the flag.

00:36:12.850 --> 00:36:14.630
SAM DUTTON: That's
fantastic news.

00:36:14.630 --> 00:36:16.180
Thanks very much
for joining us.

00:36:16.180 --> 00:36:19.340
If you'd like to find out more
about WebRTC, please look

00:36:19.340 --> 00:36:23.600
WebRTC.org or we've got an
introductory article about

00:36:23.600 --> 00:36:26.350
WebRTC on HTML5rocks.com.

00:36:26.350 --> 00:36:28.510
We'll put the links to all
that stuff, all those

00:36:28.510 --> 00:36:33.250
resources on the post for this
hangout and on WebRTC.

00:36:33.250 --> 00:36:35.130
And we'll tweak that
and so on.

00:36:35.130 --> 00:36:38.920
And just to apologize for the
late start time today, really

00:36:38.920 --> 00:36:41.360
apologize for the technical
problems we've had with

00:36:41.360 --> 00:36:43.050
real-time communication.

00:36:43.050 --> 00:36:46.800
And thank you so much
for joining us.

00:36:46.800 --> 00:36:49.670
And we'll have to be having
more hangouts

00:36:49.670 --> 00:36:50.480
like this in the future.

00:36:50.480 --> 00:36:54.250
And just a big thank you to
all of the panel today for

00:36:54.250 --> 00:36:56.250
spending valuable
time with us.

00:36:56.250 --> 00:36:58.450
SERGE LACHAPELLE: Thank you, I
look forward to doing this

00:36:58.450 --> 00:36:59.130
soon again.

00:36:59.130 --> 00:37:02.230
SAM DUTTON: Yeah, So thank
you Justin, Malanet,

00:37:02.230 --> 00:37:03.380
and Tommy and Serge.

00:37:03.380 --> 00:37:05.970
It's been fantastic.

00:37:05.970 --> 00:37:07.490
JUSTIN UBERTI: It was
fun to be here.

00:37:07.490 --> 00:37:08.290
SAM DUTTON: OK.

00:37:08.290 --> 00:37:08.850
See you guys.

00:37:08.850 --> 00:37:10.100
MALANET: Bye-bye.

