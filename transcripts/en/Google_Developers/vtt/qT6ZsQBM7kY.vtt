WEBVTT
Kind: captions
Language: en

00:00:00.770 --> 00:00:03.709
&gt;&gt;Ray: Welcome to Faster Apps, Faster Apps
Faster. I hope you guys had a good lunch and

00:00:03.709 --> 00:00:09.190
you're, you're ready to process some information
about the GWT compiler. So, my name is Ray

00:00:09.190 --> 00:00:13.660
Cromwell and I work on the GWT compiler for
the GWT team.

00:00:13.660 --> 00:00:19.090
And one of the things I hope to show you today
is how the GWT compiler works, how it actually

00:00:19.090 --> 00:00:23.710
makes your job script faster and smaller,
and then to maybe give you a couple of tips

00:00:23.710 --> 00:00:29.869
about how to help, help the compiler along
a little bit. And then we'll talk about how

00:00:29.869 --> 00:00:31.860
to make your builds faster.

00:00:31.860 --> 00:00:36.250
So, if you want to follow along, there is
a bitly link for you: bit.ly/io2010-gwt2.

00:00:36.250 --> 00:00:45.880
That will be a Google Wave where there's live
note taking and I think you can ask some questions

00:00:45.880 --> 00:00:50.280
there. So, as I said, there's going to be
two things covered in this presentation.

00:00:50.280 --> 00:00:56.570
One is --is-- building faster Apps; how the
GWT compiler actually helps y-, your Apps

00:00:56.570 --> 00:01:00.591
execute faster, load faster and so on. So,
I'll get into the details of the compiler

00:01:00.591 --> 00:01:03.850
in a way, maybe, that it hasn't been explained
before.

00:01:03.850 --> 00:01:09.469
And the second part is I'll try to help you
actually speed up your compilation so that

00:01:09.469 --> 00:01:13.869
you're waiting less for your builds to actually
happen.

00:01:13.869 --> 00:01:17.220
So, here's the inspiration for this. I don't
really think I need to preach to the choir

00:01:17.220 --> 00:01:21.329
too much, but, latency matters and if you
saw Kelly--

00:01:21.329 --> 00:01:22.329
[phone rings]

00:01:22.329 --> 00:01:27.899
Uh-oh. I have call there. If you saw Kelly's
presentation on Speed Tracer earlier, you

00:01:27.899 --> 00:01:33.890
really know how much latency matters, but
there's a monetary reason why as well. Amazon

00:01:33.890 --> 00:01:37.439
actually presented at a Web conference last
year and reported that for every hundred milliseconds

00:01:37.439 --> 00:01:42.149
of latency they lost one percent in sales;
that's real money.

00:01:42.149 --> 00:01:46.079
Likewise, Google actually did a focus group
study of people using their browser and they

00:01:46.079 --> 00:01:50.329
found out for every 500 milliseconds of latency
it takes for the search results page to come

00:01:50.329 --> 00:01:54.340
back, they would lose 20 percent of their
traffic. That's, that's huge.

00:01:54.340 --> 00:01:59.649
So, we definitely want to speed up the rate
at which your Apps can load in and return

00:01:59.649 --> 00:02:05.600
results to the user. And GWT helps a lot with
that. So, here's an example, if you were a

00:02:05.600 --> 00:02:12.250
user who started out in 2006 on GWT 1.3, and
all you did was simply recompile your application,

00:02:12.250 --> 00:02:16.200
you made no other changes to your code, just
downloaded the new SSDK and recompiled it,

00:02:16.200 --> 00:02:17.870
your JavaScript got 30 percent smaller.

00:02:17.870 --> 00:02:22.970
So, you di--, you didn't have to do any work
at all. And I think that's, that's pretty

00:02:22.970 --> 00:02:26.750
good. And what we've done over time is we've
continued to iterate on the GWT compiler and

00:02:26.750 --> 00:02:31.310
tried to make the code smaller and faster
so that all you have to do is simply update

00:02:31.310 --> 00:02:35.600
to later versions of the compiler and we make
your Web App just run faster.

00:02:35.600 --> 00:02:36.600
[clears throat]

00:02:36.600 --> 00:02:41.840
Here's another measurement. This is between
GWT 1.7 and GWT 2.0 startup time lengths.

00:02:41.840 --> 00:02:46.730
See how fast it takes for your App to first
show to the user. And this graph is kind of

00:02:46.730 --> 00:02:51.320
hard to read, but, GWT 1.7 is represented
as a 1.0 factor.

00:02:51.320 --> 00:02:57.840
On Safari, if y-, if you recompile with GWT
2.0, the speedup was 2.5. So, that means the

00:02:57.840 --> 00:03:03.590
latency went down by a factor of 2.5. So,
if it was a 250 millisecond start, it went

00:03:03.590 --> 00:03:07.650
down to a hundred milliseconds. Likewise,
for Firefox, the, the improvement wasn't so

00:03:07.650 --> 00:03:14.210
dramatic but it did get a factor of 1.25 improvement.

00:03:14.210 --> 00:03:20.070
So, with that said, let's talk about what
the GWT compiler is. So, a lot of people,

00:03:20.070 --> 00:03:24.780
they're not r-, really sure what it is, they
just think, "Ok, it translates Java to JavaScript,

00:03:24.780 --> 00:03:28.910
maybe it maps a Java method directly to a
function, declaration in JavaScript. It's

00:03:28.910 --> 00:03:32.660
just a straight one-to-one translation." And
actually, it's not.

00:03:32.660 --> 00:03:37.410
The GWT compiler is a totally classical compiler
just like your C compiler or your Pascal compiler

00:03:37.410 --> 00:03:43.290
and things like that. It aggressively optimizes
the code; really changes it and moves it around

00:03:43.290 --> 00:03:48.360
a lot. Moreover, it actually produces multiple
executables. So, it's kind of like a cross-compiler.

00:03:48.360 --> 00:03:52.770
Like if you were cross-compiling for x86 and
ARM, only the target platforms are not two

00:03:52.770 --> 00:03:57.790
different CPUs; their two different browsers,
or mobile, or different locales like Chinese

00:03:57.790 --> 00:03:59.260
or some German.

00:03:59.260 --> 00:04:03.230
And just like your C compiler, it now has
a linker so there's additional steps you can

00:04:03.230 --> 00:04:06.990
do with the artifacts that are produced with
the compiler, like repackaging them for different

00:04:06.990 --> 00:04:11.230
things, like, let's say you wanted to install
a GWT application as an Android application

00:04:11.230 --> 00:04:15.760
and it appears on a menu. You can write a
linker for that.

00:04:15.760 --> 00:04:20.531
So, here are some of the core concepts of
the compiler. One of the most important ones

00:04:20.531 --> 00:04:26.430
is this thing we call permutations. So, basically,
the compiler has the capability, as it's compiling,

00:04:26.430 --> 00:04:31.039
based on rules that you write, to basically
search and replace classes.

00:04:31.039 --> 00:04:38.509
So, maybe you've got a class and you called
it "payment service". Well, maybe you went

00:04:38.509 --> 00:04:41.630
through GWT compiler, replace that for different
patterns. Maybe on Android you want to use

00:04:41.630 --> 00:04:45.540
protocol buffers and on GWT you want to use
RPC or something. Well, the compiler can do

00:04:45.540 --> 00:04:49.919
that and it's called wh--, what we call Differed
Binding. So, it's the ability to do dependency

00:04:49.919 --> 00:04:53.529
injection at the compile time instead of runtime.

00:04:53.529 --> 00:04:57.889
And the interesting this is, is that after
the replacements are done, the compiler looks

00:04:57.889 --> 00:05:02.840
at the, all the permutations that have been,
had the substitutions done. And for every

00:05:02.840 --> 00:05:09.570
unique substitution it does a separate compilation.
So, you get a different executable in a sense.

00:05:09.570 --> 00:05:14.960
Here's the more famous example, it's in the
gwt-log user library. So, GWT has this class

00:05:14.960 --> 00:05:19.539
called DOM, which delegates the DOMlmpl. And
DOMlmpl basically knows how to do things like

00:05:19.539 --> 00:05:22.360
a append childs; shows them to the DOM to
create elements that attach to event listeners

00:05:22.360 --> 00:05:28.550
and so on. How, it's the API for manip--,
interfacing with the browser. But, because

00:05:28.550 --> 00:05:33.840
different browsers, as you know, have different
ways of interacting, like IE uses a attachEvent

00:05:33.840 --> 00:05:38.539
every other browser uses addListener, addEventListener.
You need different implementations of that.

00:05:38.539 --> 00:05:42.870
In the traditional way it's done, in most
AJAX libraries is you have like a test. You

00:05:42.870 --> 00:05:49.960
say, like, if element.@attachEvent, then it's
the IE version and if it's alt it's the HTML5

00:05:49.960 --> 00:05:55.189
version. And that means that when you send
your application to a Firefox user, it's got

00:05:55.189 --> 00:05:59.229
all this IE code in there that's never executed.
It's just tested for but not run.

00:05:59.229 --> 00:06:02.409
What we're doing with GWT compiler is say,
"Look, when the compiler is compiling the

00:06:02.409 --> 00:06:07.770
thing, if you're going to, if you're compiling
for IE, let's just only include the classical

00:06:07.770 --> 00:06:13.539
DOMlmpl IE or DOMlmpl IE8, which enclose all
the IE specific versions of those methods

00:06:13.539 --> 00:06:18.520
and if then if you're on Firefox or WebKit,
let's substitute in a, a special version for

00:06:18.520 --> 00:06:23.650
those." In which case, you're producing now
two or more executables; one for each browser.

00:06:23.650 --> 00:06:30.530
But, their smaller because each one doesn't
have to know about the browser's edge cases.

00:06:30.530 --> 00:06:34.840
So, but, there's more to this than just that.
What this does, actually, is it permits the

00:06:34.840 --> 00:06:41.009
compiler to make better optimizations. So,
for example, if you had a class called "Animal"

00:06:41.009 --> 00:06:46.249
and had two subclasses, "Cat" and "Dog", and
let's say in the Safari browser you instantiate

00:06:46.249 --> 00:06:51.479
a "Cat" and in IE's you instantiate a "Dog".
Well, what happens is the compiler c-, when

00:06:51.479 --> 00:06:56.930
it compiles these two separate permutations,
only one of the classes is in-, instantiated

00:06:56.930 --> 00:07:01.009
in each. So, the way the compiler sees it
is, "An Animal is always a Cat. There's no

00:07:01.009 --> 00:07:02.680
type of other animal than a Cat."

00:07:02.680 --> 00:07:06.800
And likewise in the other browsers. So, it's
actually permits the compiler to replace all

00:07:06.800 --> 00:07:11.520
those polymorphic method calls that may be
overwritten with just a direct Inline call

00:07:11.520 --> 00:07:12.900
to a "Cat" method.

00:07:12.900 --> 00:07:14.439
[clears throat]

00:07:14.439 --> 00:07:17.849
So, that's sort of the preliminary, we get
that out of the way.

00:07:17.849 --> 00:07:22.369
Here are the major phases of the compiler.
So, there's five of them. So, the first one

00:07:22.369 --> 00:07:26.120
is called precompile. So, what precompile
does is, is it basically looks at the source

00:07:26.120 --> 00:07:31.309
code in text form that's on your disk, sucks
it all into the compiler and creates intermediate

00:07:31.309 --> 00:07:36.530
data structures, like abstracts and text trees.
And then hands it off to another phase or,

00:07:36.530 --> 00:07:40.900
as you'll see later, it can actually send
it out to a network where it can be distributed,

00:07:40.900 --> 00:07:45.699
you can build it in a distributed build. So
that phase doesn't do much except for like,

00:07:45.699 --> 00:07:47.419
parsing and some other fix-ups.

00:07:47.419 --> 00:07:52.160
The next phase that's more important, that's
the Java optimization phase. This is basically

00:07:52.160 --> 00:07:55.899
where the compiler is saying, "I know about
Java. I know particular things about the Java

00:07:55.899 --> 00:08:01.110
Type System, so I'm going to do optimizations
based on what I know about Java." But, of

00:08:01.110 --> 00:08:05.740
course, there are some things in, in a JavaScript
application that a Java Optimizer wouldn't

00:08:05.740 --> 00:08:12.120
know about, like closures, function redefinitions,
property lookups, and things like that. They

00:08:12.120 --> 00:08:13.229
just don't exist in Java.

00:08:13.229 --> 00:08:18.659
So, there's a separate JavaScript optimization
phase that wor--, works on a JavaScript AST.

00:08:18.659 --> 00:08:24.460
This phase actually does what many of you
might be familiar with what's called code-splitting

00:08:24.460 --> 00:08:26.069
in GWT 2.0.

00:08:26.069 --> 00:08:30.360
Finally, after you take that Java script and
you do, build optimizations on it, you have

00:08:30.360 --> 00:08:35.840
to get it back to text on the J-, on the,
as a .js file. So, when you serialize it out,

00:08:35.840 --> 00:08:39.800
this text, you want to do minification and
obfuscation and all kinds of compressions.

00:08:39.800 --> 00:08:43.690
So, there's actually optimizations that we
do purely on the text alone, like we don't

00:08:43.690 --> 00:08:47.620
even know what the code is, we're just doing
actual text transformations and I'll show

00:08:47.620 --> 00:08:48.980
you some of that later.

00:08:48.980 --> 00:08:51.260
Finally, there's the linking stage that I
mentioned earlier which is how you package

00:08:51.260 --> 00:08:57.550
it all up, yeah. So, let's go on to talk about
Java optimizations. So, there's many more

00:08:57.550 --> 00:09:01.240
than this, but these are some of the most
important ones. The first one is called "type

00:09:01.240 --> 00:09:02.240
tightening".

00:09:02.240 --> 00:09:06.920
Second one's called c-, what we call "converting",
we call "statification", it's sort of a mouth

00:09:06.920 --> 00:09:12.720
full. It's converting non-overwritten methods
to static methods. Finalizing, pruning and

00:09:12.720 --> 00:09:15.780
dead code elimination and method call inlining.

00:09:15.780 --> 00:09:21.770
So, type tightening, what is it? So, before
I use the example of, of subtyping "animal"

00:09:21.770 --> 00:09:26.310
into separate permutations, but even if in
one permutation you have two classes, sometimes

00:09:26.310 --> 00:09:31.630
the compiler can reason that there's only
ever one that's going to be used in a particular

00:09:31.630 --> 00:09:32.630
circumstance.

00:09:32.630 --> 00:09:35.811
So, here we have "Animal" and it has a "Cat"
and a "Dog" subclass. And you have a method,

00:09:35.811 --> 00:09:42.320
you have a, an assignment here which is "Animal
a = new Cat();" If "Dog" is never instantiated

00:09:42.320 --> 00:09:46.530
by newCall in this method or in any other
method, the compiler will say, "Well, look,

00:09:46.530 --> 00:09:51.779
I know no one ever created the 'Dog', so I'll
just change that left-hand side of the equation

00:09:51.779 --> 00:09:57.140
to be a 'Cat' type." Likewise, there's a method
there called "public static Dog getAnimal()",

00:09:57.140 --> 00:10:02.060
right? So the return type of this method is
always a "Dog". So, if you were to say "Object

00:10:02.060 --> 00:10:05.950
o = getAnimal();" the compiler will say, "Well,
hey, that thing always returns a 'Dog', so

00:10:05.950 --> 00:10:11.340
let me fix up the type on the left-hand side
to a tighter bound." Right? That's why we

00:10:11.340 --> 00:10:16.270
call it type tightening. And this helps a
lot when we get to inlining.

00:10:16.270 --> 00:10:20.930
So, status-, staticifying methods, this is
kind of a hard thing to pronounce, it, basically

00:10:20.930 --> 00:10:26.840
what this does, is here you have two methods
in "Animal." One is "public String toString()"

00:10:26.840 --> 00:10:31.970
and it returns a name field, and it's not
overridden in any subclasses. The next method

00:10:31.970 --> 00:10:37.010
is "public void speak() { alert(""); }" and
this one is overridden in the "Cat" subclass.

00:10:37.010 --> 00:10:42.320
So, since the compiler knows that "toString"
is never overridden, it's fundamentally not

00:10:42.320 --> 00:10:46.240
polymorphic. So, the compiler can say, "Ok,
well I'm gon--, actually just take that off

00:10:46.240 --> 00:10:50.530
the object and make it a global top-level
function." And the result is what you see

00:10:50.530 --> 00:10:54.300
at the bottom, which is "public static String
toString", and now what would normally be

00:10:54.300 --> 00:10:57.430
the "this pointer" for the object is passed
in as an argument.

00:10:57.430 --> 00:11:03.010
And this has a lot of benefits, for example,
like a, top-level functions actually tend

00:11:03.010 --> 00:11:08.460
to execute faster and, in Chrome V8, so there's
some JavaScript VM things going on. But also,

00:11:08.460 --> 00:11:12.740
it actually allows the compiler to inline
it because since it's not polymorphic it actually

00:11:12.740 --> 00:11:17.640
knows that there's only one method 'toString'
for animal types, ever. It doesn't matter

00:11:17.640 --> 00:11:22.590
if it's a "Cat" or a "Dog", whatever; it's
always "X.name". So, it just will inline it

00:11:22.590 --> 00:11:24.060
as "X.name".

00:11:24.060 --> 00:11:28.270
So, finalizing, sort of an addendum to that,
we notice that a method is never overridden,

00:11:28.270 --> 00:11:32.010
a class is never subclassed, or a variable
is never reassigned. We'll just change it

00:11:32.010 --> 00:11:36.010
to be final-, we'll use a "final" qualifier
for that. And that helps the compiler out

00:11:36.010 --> 00:11:40.940
because if it knows, let's say a constant,
like "X = 10" is final, then later on when

00:11:40.940 --> 00:11:45.560
there's a reference back to that variable,
it can just go, "Wow, that thing's never been

00:11:45.560 --> 00:11:50.400
assigned a different value. It's just a constant."
So, it can actually just replace a later reference

00:11:50.400 --> 00:11:55.430
with 'X' with the actual number, thereby eliminating
the variable assignment.

00:11:55.430 --> 00:12:01.560
So, pruning by far, is the most important
thing in a GWT compiler. And basically, it

00:12:01.560 --> 00:12:05.500
works like code garbage collection. What we
do is we start out at the entry point of your

00:12:05.500 --> 00:12:10.510
program and we trace through in the compiler.
And we determine every possible bit of reachable

00:12:10.510 --> 00:12:14.560
code that could ever be touched by executing
the program from the entry point.

00:12:14.560 --> 00:12:18.190
And when we do that, at the end we have a
collection of what's called the "live" methods,

00:12:18.190 --> 00:12:23.672
the live fields, the live classes; everything
else, we just throw away. So, the result of

00:12:23.672 --> 00:12:28.030
this is if you're using GWT and you're using
a bunch of libraries or whatever, you usually

00:12:28.030 --> 00:12:34.000
don't pay for code you don't use. You could
have, you know, 500K of libraries and you

00:12:34.000 --> 00:12:37.301
call one method, you don't incur the costs
of compiling all that JavaScript into your

00:12:37.301 --> 00:12:40.380
output application.

00:12:40.380 --> 00:12:45.190
Dead Code Elimination is a phase of the GWT
compiler that's, I think it's somewhat poorly

00:12:45.190 --> 00:12:49.500
named, it really should be called Static Evaluation
or Compile Time Evaluation, because what it

00:12:49.500 --> 00:12:54.490
does is it looks at the code and says, "If
there's some piece of code that I know just

00:12:54.490 --> 00:13:00.220
by looking at it that I could replace it with
the answer of evaluating that at compile time,

00:13:00.220 --> 00:13:01.220
then I'll do it."

00:13:01.220 --> 00:13:06.040
So, for example, if you had an expression
like, "false &amp;&amp; expression" the compiler can

00:13:06.040 --> 00:13:09.690
just go, "That's always false." Because the
right hand side will never be evaluated so

00:13:09.690 --> 00:13:14.430
it'll just replace the, the left hand side
with "false". Or, maybe you have "if (false)"

00:13:14.430 --> 00:13:19.270
so you have, like, "if (debug)" and "debug"
is a variable somewhere and you have a bunch

00:13:19.270 --> 00:13:23.110
of debug code, if you declare that at the
top-level of your program as like, "debug

00:13:23.110 --> 00:13:27.630
 = false", the compiler will just make all
those debugging statements go away.

00:13:27.630 --> 00:13:30.730
Constant folding, if you're doing a bunch
of string concatenation, every time there's

00:13:30.730 --> 00:13:35.360
two constants that are side by side, the compiler
will just go ahead and add those together

00:13:35.360 --> 00:13:39.040
so it won't incur any runtime costs for string
concatenation.

00:13:39.040 --> 00:13:44.440
Likewise, with numbers, and there's just a
whole bunch more that it does. It can convert

00:13:44.440 --> 00:13:49.240
post fix ops that are never assigned into
pre fix. That might not seem very important,

00:13:49.240 --> 00:13:56.650
but it turns out that it helps out the JavaScript
JITs a lot when they're doing a bunch of increments,

00:13:56.650 --> 00:13:59.310
like a loop. Constant propagation I kind of
already covered.

00:13:59.310 --> 00:14:00.310
[clears throat]

00:14:00.310 --> 00:14:04.060
And here's an example of what you get. So,
last year, I pr-, presented this library called

00:14:04.060 --> 00:14:12.410
"GWT Query" which was a reimplementation of
jQuery in GWT. And the library is actually

00:14:12.410 --> 00:14:17.750
about 300 kilobytes of Java Source on disk.
Here, I've gzipped it to make the comparisons

00:14:17.750 --> 00:14:23.200
fair, but the source code of this library
is 50KB gzipped. And I wrote a sample application

00:14:23.200 --> 00:14:27.360
that applies a bunch of progressive enhancement
to a page, but I only use a couple of the

00:14:27.360 --> 00:14:31.800
functions in the GWTware library, like 'alt3'
CSS or doing ":hover" or something like that.

00:14:31.800 --> 00:14:37.700
The result, the resulting application compressed
is 780 bytes. So the compiler threw away 99.99

00:14:37.700 --> 00:14:43.970
percent of that code. So all you're left with
is a couple of Inline functions that actually

00:14:43.970 --> 00:14:48.480
got called. And you don't tend to get this
situation when using Java-, through JavaScript

00:14:48.480 --> 00:14:54.180
because you don't tend to know ahead of time
what methods were gonna be called so you actually

00:14:54.180 --> 00:14:58.320
have to strip down the entire JS with all
the functions because you don't know ahead

00:14:58.320 --> 00:14:59.390
of time.

00:14:59.390 --> 00:15:04.360
But, because we have a compile step, the compiler
gets to see all of the code that is expected

00:15:04.360 --> 00:15:08.660
to be sent to the user ahead of time. So,
it can actually make that determination.

00:15:08.660 --> 00:15:13.610
Here's another example. This is of a graph
showing that, how big your application will

00:15:13.610 --> 00:15:17.830
be as you start to call more methods in the
GWT Widget library. So, you start out with

00:15:17.830 --> 00:15:21.161
nothing, you get this little empty one down
there. I know this chart's kind of hard to

00:15:21.161 --> 00:15:26.250
see, but it's not really relevant what those
bottom axes labels are, but basically, each

00:15:26.250 --> 00:15:30.510
one of them is another widget you're using;
text box, tree, and so on. And as you add

00:15:30.510 --> 00:15:34.279
each widget, the size of the application output
goes up a little bit.

00:15:34.279 --> 00:15:38.470
But, as you can see, it tapers off because
there's a lot of code sharing that happens

00:15:38.470 --> 00:15:43.420
between widgets that use the same base class,
they use the same java.util.Collections. So,

00:15:43.420 --> 00:15:47.190
it doesn't grow without bound, but if you
want to actually make a small application,

00:15:47.190 --> 00:15:51.750
you can. You just have to be a little bit
careful about what methods or what widgets

00:15:51.750 --> 00:15:55.720
you're going to use. And that's what I did
in jQuery.

00:15:55.720 --> 00:16:00.630
So, Method Inlining. So this is, is another
really important optimization in GWT. And

00:16:00.630 --> 00:16:06.620
what it basically does is what it says. If
you see a function, like "addTip(float bill,

00:16:06.620 --> 00:16:11.300
float rate)" and it has an expression, "(return
bill*(1+rate);)" and the compiler can actually

00:16:11.300 --> 00:16:16.120
determine what the target method is, like
it's not overridden by five different limitations.

00:16:16.120 --> 00:16:20.900
It will just take the parameters that you
see at the call site and substitute them for

00:16:20.900 --> 00:16:24.540
the actual variables in the body of the method
and then replace that at the call site. So,

00:16:24.540 --> 00:16:32.820
you see that the "addTip(100,Of, O.2f);" becomes,
after inlining, "100*(1+0.2f)". But then,

00:16:32.820 --> 00:16:36.800
because of that dead code elimination phase,
the compiler goes, "Hey, everything there

00:16:36.800 --> 00:16:41.660
is constant." So it actually just rewrites
that as the answer, which is just 120. So,

00:16:41.660 --> 00:16:46.400
if this was a real application, it, well you
can see is actually the addTip method got

00:16:46.400 --> 00:16:49.231
totally eliminated. It never even made it
in the download to the user.

00:16:49.231 --> 00:16:56.420
The Java Method Inliner is not perfect; it
actually has a lot of restrictions, but some

00:16:56.420 --> 00:17:00.880
of those are for good reason. It does three
things really well. One is, is that it reduces

00:17:00.880 --> 00:17:04.360
most of the Java getter/setter calls. So,
when you tend to program in Java, you tend

00:17:04.360 --> 00:17:06.559
to have property getters and setters.

00:17:06.559 --> 00:17:10.650
And the Inliner definitely will eliminate
almost all of those because they're usually

00:17:10.650 --> 00:17:14.790
not overridden and they're usually small.
It tries to avoid bloating the code, though.

00:17:14.790 --> 00:17:18.059
So if the method is more than a couple of
lines long it won't inline it because it will

00:17:18.059 --> 00:17:23.309
tend to make the JavaScript bigger and that's
one of the main things you want to guard against.

00:17:23.309 --> 00:17:26.770
Finally, it enables optimization stages to
work better. So, for example; if you've got

00:17:26.770 --> 00:17:30.550
like one method and it's calling another method;
it's gonna pull that other method in to this

00:17:30.550 --> 00:17:34.930
method and then the compiler kind of has more
context to see when it's tracing to the code,

00:17:34.930 --> 00:17:39.930
what's being, what's depending on what, so
it can eliminate more because maybe there's

00:17:39.930 --> 00:17:42.910
some dead code in there that got pulled in.

00:17:42.910 --> 00:17:47.590
So, after it's finished with the JavaScript
optimization stage, it goes on to do-, sorry,

00:17:47.590 --> 00:17:52.270
the Java optimization, it goes on to do the
Java optimization. So, it takes the Java code

00:17:52.270 --> 00:17:57.550
that's optimized and it dumps it into a JavaScript
data structure. And then it performs many

00:17:57.550 --> 00:18:02.240
of the same optimizations, so static evaluations,
like the same things you saw for like constant

00:18:02.240 --> 00:18:07.140
expression elimination and so on; it does
it in JavaScript as well because there are

00:18:07.140 --> 00:18:11.100
probably some things it didn't catch like
variables that came in from JSOs and things

00:18:11.100 --> 00:18:12.100
like that.

00:18:12.100 --> 00:18:15.640
That, the compiler, the Java part of the compiler
does not know about JavaScript so it can't

00:18:15.640 --> 00:18:20.800
do that part of the work. The Inliner is also
in there and there's a reason why you want

00:18:20.800 --> 00:18:27.140
to have a JavaScript Inliner is because JSNI
methods don't get inlined by the Java part

00:18:27.140 --> 00:18:30.040
of the c-, because it doesn't know about JavaScript
methods.

00:18:30.040 --> 00:18:34.280
Likewise, if you have like a method that has
a closure in it, you can't really inline it

00:18:34.280 --> 00:18:39.050
because the closure wi--, captures the scope
of where it's declared. And if you, if you

00:18:39.050 --> 00:18:41.880
basically inline the body into another scope,
you've, you've changed the meaning of the

00:18:41.880 --> 00:18:43.500
code.

00:18:43.500 --> 00:18:49.540
Unused Function Remover is like a pruning
and code splitting, of course, people have

00:18:49.540 --> 00:18:55.120
probably heard of if you're a GWT user. I
kind of already covered the JavaScript Inliner.

00:18:55.120 --> 00:18:58.750
So, but here is the result. This is the part
of the thing you're more interested in. So,

00:18:58.750 --> 00:19:04.290
when you do --do-- inlining, although V8 and
Nitro and many of the other JavaScript engines,

00:19:04.290 --> 00:19:08.430
and like TraceMonkey, and whatever, we're
getting pretty good at this. Theyâ€™re still

00:19:08.430 --> 00:19:09.430
not perfect.

00:19:09.430 --> 00:19:14.490
So, when a compiler does inlining it still
actually help the performance of these advanced

00:19:14.490 --> 00:19:19.790
JavaScript VMs. In this case, what we have
here is a demonstration of capability detection

00:19:19.790 --> 00:19:25.590
versus polymorphic versus inline. What this
means is let's say you had some particular

00:19:25.590 --> 00:19:28.170
piece of code that had to run differently
on different browsers.

00:19:28.170 --> 00:19:35.611
So, in IE, maybe you did like, "if element.attachEvent,
then some bit of code, else, some bit of code

00:19:35.611 --> 00:19:38.960
for Firefox, and so on." Another way you could
do that, of course, is you can make a different

00:19:38.960 --> 00:19:44.160
object and have it overridden for IE and have
it overridden for Firefox, like, you know,

00:19:44.160 --> 00:19:49.170
attach element as a method on something. That's
the polymorphic case.

00:19:49.170 --> 00:19:53.620
And the third case is inlining. And so you
can see the difference between capability

00:19:53.620 --> 00:19:58.240
detection and polymorphic is not that different
on the ma-, the modern browsers. But actually,

00:19:58.240 --> 00:20:03.660
when the compiler inlines these things, it,
it results in a ten percent performance improvement.

00:20:03.660 --> 00:20:06.250
And there's a more dramatic example of this.

00:20:06.250 --> 00:20:12.940
Kelly Norton, who did the Measure to Milliseconds
talk earlier, ported the Suns-, the SunSpider

00:20:12.940 --> 00:20:17.140
browser benchmarks from JavaScript to Java
and let the GWT compiler have at it. And this

00:20:17.140 --> 00:20:24.250
is the result. GWT is in yellow and the JavaScript
version is in blue on the same browser. And

00:20:24.250 --> 00:20:27.650
you can see there's some dramatic performance
improvements in some of these benchmarks,

00:20:27.650 --> 00:20:29.150
purely because of the optimizations I outlined
earlier.

00:20:29.150 --> 00:20:34.900
So, GWT produces code that usually can be
made actually smaller than what you write

00:20:34.900 --> 00:20:38.640
by hand, but actually it produces faster code
and that's the more important thing.

00:20:38.640 --> 00:20:40.050
[clears throat]

00:20:40.050 --> 00:20:45.540
This is probably a, an even better one. This
is Gwt Query. It's my jQuery port, so I rewrote

00:20:45.540 --> 00:20:51.809
the CSS Selector Engine that jQuery has in
Java for GWT. And then I let GWT have at it.

00:20:51.809 --> 00:20:57.240
This is a comparison of Prototype, Dojo, jQuery,
and GwtQuery on the slickspeed CSS Selector

00:20:57.240 --> 00:21:02.820
benchmark that they all use. And as you can
see, Prototype came in at about 3,800 milliseconds,

00:21:02.820 --> 00:21:09.431
Dojo was about 1,200, jQuery was about 600,
and GwtQuery was about 400. So, GWT basically

00:21:09.431 --> 00:21:14.380
produced code faster than the best JavaScript
Ninja's in the industry could produce by hand.

00:21:14.380 --> 00:21:18.030
And I think that's, the, a something to say.

00:21:18.030 --> 00:21:21.460
So, after you've done JavaScript optimizations,
 --

00:21:21.460 --> 00:21:24.640
[pause]

00:21:24.640 --> 00:21:29.420
we have to get it on disk so it can be sent
back to your browser. And we call; this is

00:21:29.420 --> 00:21:32.040
the text based optimizations part of the browser.

00:21:32.040 --> 00:21:35.360
So, the first thing we're going to do, is
we're going to take that tree in memory of

00:21:35.360 --> 00:21:41.390
the JavaScript program and we're gonna serialize
it, the text. But as we're serializing it,

00:21:41.390 --> 00:21:47.880
we can remove all extraneous whitespace, semicolons
and parenthesis and so on. So, a common thing,

00:21:47.880 --> 00:21:50.530
of course, and I didn't even know this until
I started doing this, but like, you can leave

00:21:50.530 --> 00:21:54.830
off parenthesis when you're calling JavaScript
constructors that don't take arguments.

00:21:54.830 --> 00:21:59.880
So, if you have "newFoo( )" you can actually
change this to "newFoo", without the parenthesis.

00:21:59.880 --> 00:22:04.820
That actually dropped the size of GWT applications
by about one percent. And that's a pretty

00:22:04.820 --> 00:22:09.429
good improvement for such a small change.
The compiler also knows a lot about the JavaScript

00:22:09.429 --> 00:22:12.270
language and the precedence of operators.

00:22:12.270 --> 00:22:18.410
So, if someone accidentally put extra parenthesis
around an expression like, "a+(b*c)" because

00:22:18.410 --> 00:22:22.890
they w-, weren't sure whether or not "a+b"
was going to be evaluated first. The compiler

00:22:22.890 --> 00:22:29.420
will go ahead and just remove that. But the
next stage of course is, is, is, is more important.

00:22:29.420 --> 00:22:35.550
The compiler per-, performs a aggressive obfuscation
far more than y-, you'll get in like YUI Compressor,

00:22:35.550 --> 00:22:38.860
or any of the other JavaScript libraries.
And the reason why it can do that is because

00:22:38.860 --> 00:22:43.010
it knows every single method that will ever
be called from the start of your program.

00:22:43.010 --> 00:22:46.510
So, it knows whether it's public, private,
who's using it and so on. And so it's free

00:22:46.510 --> 00:22:50.850
to totally rename everything, and I mean everything.
A lot of the other minifiers don't because

00:22:50.850 --> 00:22:56.470
they're not sure if a given method like, "createWidget",
or whatever, "createSlider" is actually going

00:22:56.470 --> 00:23:00.490
to be called from outside the library or whether
it's an internal function only.

00:23:00.490 --> 00:23:04.980
So, the compiler knows a lot more information
about what's actually called. So, pretty much

00:23:04.980 --> 00:23:08.750
in a GWT program, when it's actually compiled
and it's on disk, there's almost none of the

00:23:08.750 --> 00:23:13.210
original identifiers are present and everything
is changed into one or two character variable

00:23:13.210 --> 00:23:14.480
names.

00:23:14.480 --> 00:23:18.470
The interesting thing though, is when you
do this to a GWT program and you look at the

00:23:18.470 --> 00:23:23.350
output, you'll see a lot of functions that
look identical. Like, like functions duplicated

00:23:23.350 --> 00:23:27.520
over and over again, like dozens. And you're
saying like, "Why, why are there, why would

00:23:27.520 --> 00:23:31.309
someone write the same function like ten times?"
And it turns out that what happens is --is--

00:23:31.309 --> 00:23:36.190
that every setter method or getter method
you write, after its obfuscated, will tend

00:23:36.190 --> 00:23:37.190
to look identical.

00:23:37.190 --> 00:23:43.250
So, if you had like on a employ object, let's
say you had "setFirstName" and it was saying,

00:23:43.250 --> 00:23:45.590
"This.FirstName=something." And then on, like,
a car object you had "set.ModelYear", you

00:23:45.590 --> 00:23:53.600
know, "This.ModelYear=something." Well, after
you compile those and obfuscate them, they

00:23:53.600 --> 00:23:59.320
look identical. They both say, "This.X=Y"
after obfuscated because they get the same

00:23:59.320 --> 00:24:03.500
identifiers assigned because they're just
methods so we give them a first available

00:24:03.500 --> 00:24:09.210
letter, which might be A or B or C, so you
have like, you know, "This.A=B" or something.

00:24:09.210 --> 00:24:14.690
So, because you can do-, w-, because that's
actually, the compiler does this, we just

00:24:14.690 --> 00:24:16.620
simply do a simple search and replace.

00:24:16.620 --> 00:24:21.440
So, what we do is we say, we take everything
method body and we just store it aside and

00:24:21.440 --> 00:24:25.890
compute a hash of it and when we're about
to emit another method, we check to see if

00:24:25.890 --> 00:24:30.080
it's already been emitted. And if it already
is, then instead of emitting that r-, method

00:24:30.080 --> 00:24:34.330
the same, a second time we just emit a reference
to the first one.

00:24:34.330 --> 00:24:42.790
So --as a-- as a result, if you have let's
say 20 beans in your application, the first

00:24:42.790 --> 00:24:48.110
field assignment property setter will be the
one function for all 20 of them. It'll just

00:24:48.110 --> 00:24:53.179
be a static method that just applies to the
bean. Likewise, for the second and so on.

00:24:53.179 --> 00:24:59.480
So, it, it, it actually th--, it reduces the
output size by about two to five percent depending

00:24:59.480 --> 00:25:03.090
on how many property setters and getters you
have.

00:25:03.090 --> 00:25:09.800
Finally, and this is probably a, a, an interesting
one, I was doing some research on trying to

00:25:09.800 --> 00:25:16.200
make gzip work better, like, how can I tweak
the output of the compiler so that the compression

00:25:16.200 --> 00:25:23.531
ratio goes up? And it turns out that there
are actually some things you can do. If you

00:25:23.531 --> 00:25:30.260
take the code and you sort it such that functions
that only differ by a few characters are closer

00:25:30.260 --> 00:25:35.170
together in the output. Then the gzip algorithm,
when it's searching backwards in the program

00:25:35.170 --> 00:25:41.580
to look for a match w-, when it's doing it's
compression, so it, it actually can find it

00:25:41.580 --> 00:25:45.150
easier because it gives up after a window
of like, eight to thirty-two KB.

00:25:45.150 --> 00:25:49.620
So, if your application is like 100K and it,
there's a function called "Foo", and it's

00:25:49.620 --> 00:25:53.460
looking backwards for another one that's similar
to "Foo" so it can compress the two together,

00:25:53.460 --> 00:25:57.740
if, if it's further back in the file than
eight KB or thirty-two KB, it gives up so

00:25:57.740 --> 00:26:01.360
it never sees the other one it could have
used for better compression. So, you simply

00:26:01.360 --> 00:26:05.910
bring the com-, the, the functions that are
similar closer together in the output file,

00:26:05.910 --> 00:26:07.299
it boosts the compression efficiency.

00:26:07.299 --> 00:26:11.710
And there are some other reasons why that
happens too, but the-, they're, they're more

00:26:11.710 --> 00:26:15.299
complicated. But, he-, here's an example if
you had something like "BAT CAT RAT BAT CAT

00:26:15.299 --> 00:26:19.460
RAT BAT CAT RAT" and we re-, simply reordered
those and there's, let's re-, those represented

00:26:19.460 --> 00:26:23.290
functions, simply reordered those so it's
"BAT BAT BAT CAT CAT CAT RAT RAT", you see

00:26:23.290 --> 00:26:29.920
that the, the redundancy is more clear to
the compressor. And this, when I implement

00:26:29.920 --> 00:26:34.920
this --it-- in some cases it's a, maybe a
one or two percent compressency increase,

00:26:34.920 --> 00:26:40.120
but I've seen it go up to 15 percent better
gzip compression. So, it depends on the application,

00:26:40.120 --> 00:26:41.870
but it's kind of a unique thing that the GWT
Compiler does.

00:26:41.870 --> 00:26:43.870
[clears throat]

00:26:43.870 --> 00:26:50.250
So, that's it for how GWT works in terms of
the optimizations. What I wanted to, to talk

00:26:50.250 --> 00:26:58.300
about here was to give you some advice on
how to change your code so that the compiler

00:26:58.300 --> 00:27:01.410
would work a little better. But, on second
thought, when I started thinking about it,

00:27:01.410 --> 00:27:07.530
actually don't want to do that because it's
our job to not hamper your coding style to

00:27:07.530 --> 00:27:08.530
fit the compiler.

00:27:08.530 --> 00:27:12.030
It's our job to make the compiler better so
that you can just code the way you want for

00:27:12.030 --> 00:27:16.360
maximum productivity. So, rather than give
you a bunch of micro-optimizations, I just

00:27:16.360 --> 00:27:18.930
wanted to, I just want to give you some general
principles here.

00:27:18.930 --> 00:27:24.260
One is, because of that static evaluation,
the thing I showed you earlier where if you

00:27:24.260 --> 00:27:28.290
have like, "if(False)" it just eliminates
code, one of the best things you can do is

00:27:28.290 --> 00:27:33.410
if you have some bit of code that maybe only
runs on one browser or runs in one locale

00:27:33.410 --> 00:27:38.340
or runs, let's say, in debugging mode versus
production mode, you can put it behind a guard.

00:27:38.340 --> 00:27:43.840
In this case, I'm using a logging example.
So, let's see how you want to log, you want

00:27:43.840 --> 00:27:47.040
to do some logging code. If you put it behind
something like, "if(Log.isLoggingEnabled())",

00:27:47.040 --> 00:27:51.301
then what you can do is use the deferred binding
mechanism I talked about earlier where the

00:27:51.301 --> 00:27:56.730
compiler can substitute the implementation.
And you can have a subset in your debug permutation,

00:27:56.730 --> 00:28:01.650
the compiler will replace that log class with
one where "isLoggingEnabled" returns "True".

00:28:01.650 --> 00:28:06.700
So the compiler will not eliminate the debug
code in that c-, in that compile.

00:28:06.700 --> 00:28:10.630
But, for the production version, you could
substitute a version where it returns "False",

00:28:10.630 --> 00:28:15.270
in which case, if you went to town on logging
statements and you've got like hundreds or

00:28:15.270 --> 00:28:18.590
thousands of logging statements all in your
program, this is all go away. And none of

00:28:18.590 --> 00:28:24.690
it shows up in your production case. So, that's
one, that's one tip. The other, the other

00:28:24.690 --> 00:28:28.710
thing is, in general, if you do have code
that's intended specifically for different

00:28:28.710 --> 00:28:34.940
locales and browsers you do use differed binding
mechanism; read up on it.

00:28:34.940 --> 00:28:41.440
So, static initializers are a potential source
of problem. How many people kn--, know what

00:28:41.440 --> 00:28:45.710
a static initializer is? I just wanna get
some hands, yes. So, if you have a static

00:28:45.710 --> 00:28:50.900
field on a class, you know that when you reference
the class the compiler, well, the Java VM

00:28:50.900 --> 00:28:55.440
has, is basically already run the initializer
that you might have had on that class. Like

00:28:55.440 --> 00:28:59.290
if you had like, "static HashMap=newHashMap()",
right?

00:28:59.290 --> 00:29:05.520
Well, the compiler has to ensure that if you
ever call like, "object.HashMap", you reference

00:29:05.520 --> 00:29:09.790
that field. It has to make sure that initializer
was called first. So, the GWT Compiler has

00:29:09.790 --> 00:29:14.470
to be faithful for those, to those semantics
in Java. And the way it does that is --is--

00:29:14.470 --> 00:29:19.910
whenever you have a static method and you
call it from another part of your GWT code,

00:29:19.910 --> 00:29:25.120
GWT will insert another function call in front
of your call at the call site, which is called

00:29:25.120 --> 00:29:32.480
cl-init which will ensure that first it called
that initialization to set up that field before

00:29:32.480 --> 00:29:34.510
the method is allowed to execute.

00:29:34.510 --> 00:29:39.780
And the second time it, it, it's called, of
course it won't in-, it won't do the initializer.

00:29:39.780 --> 00:29:42.200
It's kind of like it will check to see if
it's already been initialized and then won't

00:29:42.200 --> 00:29:47.010
do it. But, that bit of code is always there.
So, every time you call a method, first it's

00:29:47.010 --> 00:29:50.240
going to check that field got set up and if
it didn't, it leaves it alone, but its still

00:29:50.240 --> 00:29:51.290
"bloat".

00:29:51.290 --> 00:29:57.720
So, my advice would be is that, stay away
from sing-, well, not use singletons, but

00:29:57.720 --> 00:30:04.600
be careful when you use singletons and static
fields and opt for objects and lazy evaluation

00:30:04.600 --> 00:30:08.590
where you can, it tends to help you out a
little bit.

00:30:08.590 --> 00:30:13.540
In general, if you keep methods small and
functional, by small I mean it's just a few

00:30:13.540 --> 00:30:19.419
lines long and by functional I mean they don't
mutate much, or they don't mutate anything

00:30:19.419 --> 00:30:23.490
at all. So, like they just kind of take the
parameters, perform some kind of computation,

00:30:23.490 --> 00:30:27.299
and return it. The compiler will be able to
do a better job because it can reason better

00:30:27.299 --> 00:30:31.309
about pure, pure functional code than about
code that mutates a bunch of stuff all over

00:30:31.309 --> 00:30:33.940
the program.

00:30:33.940 --> 00:30:38.900
And finally, use code splitting. So, code
splitting is too complex for me to go into

00:30:38.900 --> 00:30:43.540
in this presentation, so I hope everybody
is aware of it. But, code splitting can dramatically

00:30:43.540 --> 00:30:49.419
reduce the size of you application. For instance,
for Google Wave, it reduced it by a very significant

00:30:49.419 --> 00:30:55.059
factor, from like a megabyte application to
like 100K for like the start-up.

00:30:55.059 --> 00:30:56.280
[clears throat]

00:30:56.280 --> 00:31:00.610
Ok, so, here are some tips that you can do
that don't rely on you changing your code.

00:31:00.610 --> 00:31:05.470
Its tips that you can do that you can tweak
the compiler to make the applets smaller.

00:31:05.470 --> 00:31:14.669
So, in GWT 2.0, we introduced this new thing
called Stack Stripping. So, GWT 2.0 had this

00:31:14.669 --> 00:31:19.370
ability to turn on stack emulation traces
for IE6, wh--, this is basically like if you

00:31:19.370 --> 00:31:24.039
get an exception thrown in JavaScript, we
will actually show you a Java stack trace.

00:31:24.039 --> 00:31:28.630
So you'll actually be able to know where to
go in your code to find out what caused the

00:31:28.630 --> 00:31:30.260
problem on IE.

00:31:30.260 --> 00:31:34.270
On other browsers actually, on like Crome,
WebKits and so on, they actually have some

00:31:34.270 --> 00:31:40.660
built-in stack trace functionality. But, this
relies on the fact of keeping the original

00:31:40.660 --> 00:31:44.860
function symbol names in the source code because
otherwise, you won't know what the function

00:31:44.860 --> 00:31:51.080
is, be called like, "Function X." So, what
was added was this new thing called the stack

00:31:51.080 --> 00:31:55.740
stripping mode, if you turn on stack stripping
mode, what it does is, it tries to rename

00:31:55.740 --> 00:31:59.510
as many functions as possible in your program
to anonymous functions, meaning they have

00:31:59.510 --> 00:32:03.940
no identifier at all. Just like, "Function
open closed parenthesis." And the benefit

00:32:03.940 --> 00:32:07.400
of that is --is-- that it frees up the obfuscated
identifier table.

00:32:07.400 --> 00:32:12.210
So, you know the compiler is trying to assign
one or two character names to everything to

00:32:12.210 --> 00:32:16.070
make your JavaScript as small as possible
so for every function that's able to change

00:32:16.070 --> 00:32:20.160
to an anonymous function, that's another extra
identifier that can be used somewhere else

00:32:20.160 --> 00:32:26.120
for a variable name. So, it actually tends
to reduce the code by about a milli--, five

00:32:26.120 --> 00:32:31.370
percent, depending on how many methods can
be anonymized.

00:32:31.370 --> 00:32:35.690
Another thing the GWT compiler does is it
tries to faithfully allow you to call things

00:32:35.690 --> 00:32:41.600
like the Java line class .getName method and
.getPackage and so on. So, most people don't

00:32:41.600 --> 00:32:45.220
need to do, because GWT doesn't allow dynamic
classes, so most people don't need to access

00:32:45.220 --> 00:32:50.790
the Java line class method because class,
class class.

00:32:50.790 --> 00:32:54.500
Because we don't have reflection and things
like that at runtime. So, you can, for production,

00:32:54.500 --> 00:33:01.549
you can turn on this flag called "-XdisableClassMetadata",
and if you do that the compiler, basically,

00:33:01.549 --> 00:33:06.150
doesn't even keep the names of classes around
in your program. It basically just renames

00:33:06.150 --> 00:33:09.830
every possible class to be like, class one,
class two, class three. That also significantly

00:33:09.830 --> 00:33:12.380
reduces the size of the program.

00:33:12.380 --> 00:33:18.200
Finally, a lot of the semantics that people
use debugging GWT applications like getting

00:33:18.200 --> 00:33:23.170
class cast exceptions or array store exceptions
and things like that, are not needed for production

00:33:23.170 --> 00:33:25.780
now because the production user's not going
to know what to do with it anyway. If, you

00:33:25.780 --> 00:33:29.902
know, you sent-, some guys reading Gmail and
he gets a class cast exception, what's he

00:33:29.902 --> 00:33:37.700
going to do with it, right? So, you can, you
can add this parameter called "-XdisableCastChecking"

00:33:37.700 --> 00:33:43.460
and the compiler will remove all of the runtime
cl-, cast checks all throughout the program,

00:33:43.460 --> 00:33:46.070
making it smaller.

00:33:46.070 --> 00:33:53.289
So, if you're using GWT RPC, there's a relatively
hidden cl-, module that not many people know

00:33:53.289 --> 00:34:00.049
about called Remote Service Obfuscate Tightenings.
So, when you perform a RPC call in GWT to

00:34:00.049 --> 00:34:04.130
the server, you know it serializes your Java
classes on the client site and sends them

00:34:04.130 --> 00:34:07.770
to the server and vice versa. So, when it's
communicating with the server it has to tell

00:34:07.770 --> 00:34:12.119
it, "Hey, this is an employ object. This is
a array list object." And so on.

00:34:12.119 --> 00:34:16.550
It has to say what the names of the types
are sending over the wire. But it actually

00:34:16.550 --> 00:34:21.399
doesn't need to have them be the same names
that they are in the server side VM. So, if

00:34:21.399 --> 00:34:26.530
you turn this on, it will actually obfuscate
the actual names of the types that are being

00:34:26.530 --> 00:34:29.599
sent over the wire. And this is actually for
two things.

00:34:29.599 --> 00:34:34.890
One is it will make the RPC payload smaller
and it will make the actual code of the GWT

00:34:34.890 --> 00:34:39.300
applications smaller. But, two, for security
reasons, you might have some classes on your

00:34:39.300 --> 00:34:44.909
server site that you don't want to expose
to the client. So, this will actually we-,

00:34:44.909 --> 00:34:52.310
make it so these don't show up in the RPC
payloads. If you have adopted GWT 2.0 and

00:34:52.310 --> 00:34:57.710
you've started to use UiBinder and ClientBundle,
you know that there is the ability to have

00:34:57.710 --> 00:35:02.349
GWT actually compile and apply optimizations
to CSS style sheets.

00:35:02.349 --> 00:35:10.740
You can minimize and combine properties, it
can collapse combinators in CSS and all kinds

00:35:10.740 --> 00:35:15.970
of like, useful things. But, it actually can
obfuscate class names and a lot of other things

00:35:15.970 --> 00:35:20.190
as well, too. Because if you turn on this
property, GWT will get a lot more aggressive

00:35:20.190 --> 00:35:25.420
about how it obfuscates all your CSS class
names. So, it's relatively useful if you're

00:35:25.420 --> 00:35:28.910
using like, UiBinder or ClientBundles.

00:35:28.910 --> 00:35:33.790
When all else fails and your application is
still too large and you want to make it a

00:35:33.790 --> 00:35:40.730
little bit smaller, one of the first things
you could do is try to eliminate RPC. RPC

00:35:40.730 --> 00:35:43.950
does tend to add some bloat to your application
and you've got a backend that's written in

00:35:43.950 --> 00:35:47.980
an old language like PHP or Python or so on,
and using JSON for your pailer, or you're

00:35:47.980 --> 00:35:53.531
willing to use JSON, moving from RPC to JSON
can buy you some space. Likewise, you can

00:35:53.531 --> 00:35:58.710
use a thin client library like GWTQuery. Instead
of using GWT Widgets, you progressively enhance

00:35:58.710 --> 00:36:03.110
things like you would do if you were doing
JavaScript.

00:36:03.110 --> 00:36:08.890
There are some upcoming optimizations this
year that should be, make the GWT Compiler

00:36:08.890 --> 00:36:14.040
a lot better. We're making the Inliner a lot
smarter about what it can do, what can be

00:36:14.040 --> 00:36:19.940
inlined. So, you're codes should get a little
bit faster and hopefully a little bit smaller.

00:36:19.940 --> 00:36:24.040
There's a totally new optimization framework
that's being put into the compiler called

00:36:24.040 --> 00:36:25.040
GFlow.

00:36:25.040 --> 00:36:29.349
It's a new data flow optimization framework
which some of the most sophisticated C compilers

00:36:29.349 --> 00:36:35.210
are using. So, this will allow us to do a
lot of amazing stuff like a, object field

00:36:35.210 --> 00:36:39.500
inlining, so we, so we can do things like
if you have an iterator over a collection

00:36:39.500 --> 00:36:43.390
we can change that into a for loop and get
rid of the iterator object in Java and just

00:36:43.390 --> 00:36:48.540
make it like, "for(i=1-10) on an array list.
So, the iterator can just go bye-bye.

00:36:48.540 --> 00:36:53.920
eNom optimizations. So, if you've used eNom
in Java, a lot of people have complained that

00:36:53.920 --> 00:36:59.640
they tend to add bloat because each value
object in an eNom, the way Java translates

00:36:59.640 --> 00:37:03.870
it, becomes a separate subtype of the eNom.
It's like a separate class. So, if you've

00:37:03.870 --> 00:37:07.520
got an eNom that's got a hundred values in
it, you kind of have a hundred class declarations

00:37:07.520 --> 00:37:13.090
in your output. And that's not really that
good. Especially if the eNom's only being

00:37:13.090 --> 00:37:18.310
used as sort of a type safe number, in a sense.
Or like you're passing, you don't use it in

00:37:18.310 --> 00:37:19.310
a switch case statement.

00:37:19.310 --> 00:37:23.680
So, some of the new optimizations we're doing
is things like, we detect this and we eliminate

00:37:23.680 --> 00:37:27.820
the eNom and just turn it into an integer
from one to ten. So, we replace all the eNoms

00:37:27.820 --> 00:37:34.040
with just numbers. But, our end goal is to
dramatically reduce the weight and cost of

00:37:34.040 --> 00:37:40.360
the Java runtime environment that's used by
GWT. And hopefully, that will be coming to

00:37:40.360 --> 00:37:44.260
a GWT compiler near you and, in the future
this year.

00:37:44.260 --> 00:37:56.520
So, that covers the compiler and that's sort
of quite a lot to take on. But, all of this

00:37:56.520 --> 00:38:01.000
stuff comes at a cost, so if you've, you were
a JavaScript programmer or maybe you adopted

00:38:01.000 --> 00:38:06.330
GWT, you might have realized that your compiles
are taking longer. You're, you know, things

00:38:06.330 --> 00:38:10.071
are kind of, you're waiting around, you, you're
checking your Twitter account while the compile

00:38:10.071 --> 00:38:17.250
is running and there's a reason for that.
It's not because we don't realize that the

00:38:17.250 --> 00:38:20.119
compile has gotten slow over the years.

00:38:20.119 --> 00:38:25.530
The reason why it's like that is because we
started out focusing on latency; on the performance

00:38:25.530 --> 00:38:31.200
for the end-user. So, we looked at things
and we said, "If we can make the application

00:38:31.200 --> 00:38:35.530
five percent smaller, we can shave off like
a couple milli-- hundred milliseconds off

00:38:35.530 --> 00:38:40.500
the start-up or something like that, but it
takes you an extra 30 seconds to compile it;

00:38:40.500 --> 00:38:45.560
we're going to do it. And you should, you
should not be, feel too bad about it because

00:38:45.560 --> 00:38:51.240
look, you're spending 30 seconds of your own
time compiling it, but, a million of your

00:38:51.240 --> 00:38:55.650
users are getting back a hundred milliseconds
of their time." So, it's, it's, it's a good

00:38:55.650 --> 00:38:58.609
trade-off for your end users because those
are the ones who are paying the bills.

00:38:58.609 --> 00:39:03.560
However, we do realize that it kind of impacts
your productivity a little bit. But, in most

00:39:03.560 --> 00:39:07.410
cases, if you're a hardcore GWT developer,
you're probably using, or if not, you should

00:39:07.410 --> 00:39:11.599
be using DevMode because that will reduce
most of your compile-edit-debug cycle to about

00:39:11.599 --> 00:39:13.610
one to two seconds.

00:39:13.610 --> 00:39:17.180
The problem is that if you're in a larger
organization, not everybody is going to be

00:39:17.180 --> 00:39:21.780
using the GWT tool chain. For example, you
might be building a GWT application that's

00:39:21.780 --> 00:39:26.460
kind of like a portlet that's part of a larger
enterprise dashboard or larger application,

00:39:26.460 --> 00:39:32.400
in which case, some guy is editing JavaScript
or CSS off in the corner is waiting for a

00:39:32.400 --> 00:39:36.820
continuous integration build of the GWT compiler
to get, like, the latest stuff so he can copy

00:39:36.820 --> 00:39:41.851
it over and run it. So, not everybody who
depends on GWT code is actually a GWT user

00:39:41.851 --> 00:39:43.260
runs GWT Tooling.

00:39:43.260 --> 00:39:49.420
So, we realize that and with that in mind,
let's see if we can speed up the GWT Compiler

00:39:49.420 --> 00:39:54.220
for you. So, here's some of the things I recommend
to do. Some of you might already be doing

00:39:54.220 --> 00:39:58.321
this but hopefully there's a couple things
in here you haven't thought of.

00:39:58.321 --> 00:40:02.691
First, use two modules. So, normally, you
might have a, a, a mod-, a GWT module like

00:40:02.691 --> 00:40:09.910
MyProject.gwt.xml. So, create another one
like, MyProjectDev.gwt.xml. And what you're

00:40:09.910 --> 00:40:13.920
going to do is one of them is going to be
your full production build, all browsers,

00:40:13.920 --> 00:40:20.000
all locales, no debugging, no class metadata,
stripping out everything we can to make it

00:40:20.000 --> 00:40:24.770
as small as possible with aggressive optimizations
turned on. The second one is going to be the

00:40:24.770 --> 00:40:29.400
Dev build. That's going to have all the logging,
all the debugging, printing mode, no obfuscation,

00:40:29.400 --> 00:40:33.869
but it's going to be tied to a single browser
in a single locale. In this case, what I'm

00:40:33.869 --> 00:40:38.750
showing is, is I've forced the compilation,
only to compile for Safari, and only to compile

00:40:38.750 --> 00:40:45.911
for English. What that does, it limits the
amount of separate executables the compiler

00:40:45.911 --> 00:40:49.030
has to compile for.

00:40:49.030 --> 00:40:55.030
But, you can do a little bit more. What you
can do is--is you can add this flag called

00:40:55.030 --> 00:41:00.080
"-draftCompile" which was added to GWT 2.0.
And if you do this what the compiler does

00:41:00.080 --> 00:41:05.660
is it still does some optimizations but it
doesn't run them in a loop. So, the compiler

00:41:05.660 --> 00:41:11.440
kind of, when it's doing optimizations, it
does an optimization pass and then it says,

00:41:11.440 --> 00:41:16.119
"Well, if anything changed or if it, it got
some kind of gain, let's try it one more time."

00:41:16.119 --> 00:41:19.180
And then as the code gets smaller, it says,
"Oh, let's go back through and run this optimization

00:41:19.180 --> 00:41:24.160
again." And will keep iterating until it can't
squeeze your application down any more. And

00:41:24.160 --> 00:41:28.300
what the -draftCompile says is, "Oh, I'll
do the iteration once." So do a quick optimization

00:41:28.300 --> 00:41:32.600
pass, but don't keep going back trying to
find more, squeeze out more and more.

00:41:32.600 --> 00:41:36.620
Here's a real world example, I have a large,
relatively large graphing library called "Timescope",

00:41:36.620 --> 00:41:43.790
300KB of code on a disk. A production compile
on my MacPro four Core machine takes three

00:41:43.790 --> 00:41:50.070
minutes and forty-seven seconds. A Dev compile
with the module I showed you using -draftCompile

00:41:50.070 --> 00:41:54.070
takes 42 seconds. Now, 42 seconds, it's still
a lot, right?

00:41:54.070 --> 00:41:57.000
We-, we'll try to improve on that but, that's
a relatively, that's a si--, six times, I

00:41:57.000 --> 00:42:03.860
don't what it is that, five times, six times,
seven times reduction. It's pretty good. But

00:42:03.860 --> 00:42:10.160
for reference, a Dev mode refresh is two seconds,
so, don't do what I'm telling you. Well, do

00:42:10.160 --> 00:42:14.700
--do-- it because it does help, but don't
really rely on it. Don't rely on doing full

00:42:14.700 --> 00:42:21.640
compiles if Dev mode is available for you.
You'll be lu--, you'll be a lot less irritated.

00:42:21.640 --> 00:42:27.580
However, we can go further. It turns out,
a MacPro is four, is two times faster than

00:42:27.580 --> 00:42:32.790
a MacBook. Well, why should that be? Well,
I, the one I have at home versus my desktop

00:42:32.790 --> 00:42:37.520
mach-, my MacPro is the same CPU, same frequency.
Well, the GWT Compild--, the GWT Compiler

00:42:37.520 --> 00:42:41.520
uses multiple threads. So, the more cor--,
cores you have, the faster it's going to be

00:42:41.520 --> 00:42:48.109
and it farms those out. So, buy a faster machine
is one thing to do.

00:42:48.109 --> 00:42:49.109
[laughs]

00:42:49.109 --> 00:42:52.430
If you have a RAID array, the compiler is
relatively Disk I/O hungry, so if have a RAID

00:42:52.430 --> 00:42:57.670
array or an SSD drive, it does tend to produce
a benefit. It varies; I've measured it to

00:42:57.670 --> 00:43:05.040
be about 50 percent on my machine. 64-bit
Java 6 VM on the Mac, if I enable Dash Server

00:43:05.040 --> 00:43:11.620
when I'm running the GWT compiler, I get a
15 percent small, faster compile. And if I

00:43:11.620 --> 00:43:18.540
enable 2GB of memory and Dash Server, my compiles
reduce from 42 seconds to 26 seconds. So,

00:43:18.540 --> 00:43:25.200
it's going back 42 seconds to 26 seconds.
That's pretty good. So, use -draftCompile,

00:43:25.200 --> 00:43:34.450
use Dev module, add more memory, add some
more CPUs, and use Dash Server and you can

00:43:34.450 --> 00:43:37.450
double your compile speed.

00:43:37.450 --> 00:43:43.320
So, there's one other thing you can do. GWT
has this thing called Generators, some of

00:43:43.320 --> 00:43:51.140
you may be aware of it but basically the compiler
can execute a plug-in sort of, of your writing

00:43:51.140 --> 00:43:55.460
at compile time and generate code and then
compile it. And this is how GWT RPC works.

00:43:55.460 --> 00:44:02.980
If you are willing to go the route of eliminating
RPC and other generator dependant libraries,

00:44:02.980 --> 00:44:09.920
the compiler will run faster. But don't do
it unless you really have to because you'll

00:44:09.920 --> 00:44:10.920
lose some productivity.

00:44:10.920 --> 00:44:15.310
Now, some of you are just a little bit more
impatient and 26 seconds for a compile is

00:44:15.310 --> 00:44:19.369
still too much, so if you've got a little
bit of extra money in your pocket and you

00:44:19.369 --> 00:44:25.900
got a cluster sitting around in your, in your
home or your place of business or you can

00:44:25.900 --> 00:44:29.620
use your, you know you can sort of hack in
to your, your botnet into your co-workers

00:44:29.620 --> 00:44:31.880
machines, you can use distributed builds.

00:44:31.880 --> 00:44:36.680
So, this was added to GWT but it wasn't really
documented but GWT does have the capability

00:44:36.680 --> 00:44:42.930
of farming out the compiles to a cluster.
Now, the components for doing this are there,

00:44:42.930 --> 00:44:46.610
but the glue isn't because we don't know what
your internal network is. So, we can't just

00:44:46.610 --> 00:44:50.820
write something that's going to distribute
stuff out because how your machines copy,

00:44:50.820 --> 00:44:53.890
wha--, what's your network look like, you
got a SAN, network storage, we don't know

00:44:53.890 --> 00:44:59.240
that. So you have to write that stuff to marshal
that stuff around. That's the piece you have

00:44:59.240 --> 00:45:01.490
to write, but we'll provide all the other
goodies.

00:45:01.490 --> 00:45:04.800
So, the first step is, you have to write a
precompile. That's that first phase of the

00:45:04.800 --> 00:45:09.050
compiler. So, let's imagine somewhere on your
computer, on, on your corporate network there's

00:45:09.050 --> 00:45:15.730
a shared network attached directory called
"work." So, you run this command: java.come.google.dev.gwtdev.Precompile

00:45:15.730 --> 00:45:21.060
and you give the name of your GWT module.
And you give it "-work.dir" and this network

00:45:21.060 --> 00:45:22.060
attached directory.

00:45:22.060 --> 00:45:28.050
So, the GWT Compiler will do that initial
parsing step, take the Java AST and serialize

00:45:28.050 --> 00:45:32.650
in to that directory and will run out an extra
file called permCount.txt. What this says

00:45:32.650 --> 00:45:39.740
is how many permutations is going to be compiled.
Like if you've got Safari, IE, Opera, and

00:45:39.740 --> 00:45:43.920
Firefox is four. If you've got two different
languages, it's two times that so it's eight,

00:45:43.920 --> 00:45:48.520
and so on. So, that will tell you how many
permutations the compiler is going to compile.

00:45:48.520 --> 00:45:52.839
Which kind of tells you how many machines
you might want to maximally distribute it

00:45:52.839 --> 00:45:53.839
to.

00:45:53.839 --> 00:45:56.880
The second step is the slowest part of the
compiler. This is distributed; this is called

00:45:56.880 --> 00:46:02.100
the CompilePerms part. It's a highly paralizable
part; it's also the part that does most of

00:46:02.100 --> 00:46:05.060
the optimizations. So, what we want to do
is, if you have n machines, and you've got

00:46:05.060 --> 00:46:10.380
n permutations, so let's say you have eight
machines and you've got eight permutations

00:46:10.380 --> 00:46:17.520
to compile. For each machine in your cluster,
we're going to run this command: com.google.gwt.dev.CompilePerms

00:46:17.520 --> 00:46:20.490
and we're going to give it the module, the
"hello" module.

00:46:20.490 --> 00:46:24.109
You give it the same work.dir you did the
precompile, which is on your network somewhere

00:46:24.109 --> 00:46:30.531
and you give it -perms i, where i is one to
eight. So, on the first machine, it's -perms

00:46:30.531 --> 00:46:35.109
1 and on the eighth machine in your cluster
it's -perms 8. And that will map to some particular

00:46:35.109 --> 00:46:39.740
thing like, English Firefox and Chinese IE,
or whatever; whatever you're compiling for.

00:46:39.740 --> 00:46:43.349
If you've got less than the number per-, machines
than the number of permutations, let's say

00:46:43.349 --> 00:46:47.890
you have 32 permutations, we only got eight
machines, you have to have some kind of queuing

00:46:47.890 --> 00:46:53.170
system that you built yourself, some kind
of script where you, you basically have a

00:46:53.170 --> 00:46:56.770
list of the things that have to be built,
the perms have to be built and you dequeue

00:46:56.770 --> 00:46:58.700
the one and when your machine is done it,
the next free machine will dequeue the next

00:46:58.700 --> 00:47:03.650
one, and so on. But, you guys are really smart
and you'll figure that out.

00:47:03.650 --> 00:47:07.550
The final step is after all of the various
permutations have been compiled, you're going

00:47:07.550 --> 00:47:12.250
to do a link stage. And what this does is
it compiles all the generated artifacts, all

00:47:12.250 --> 00:47:18.040
the JavaScript files, all the sprited images,
all of the HTML files, everything the GWT

00:47:18.040 --> 00:47:21.900
Compiler produced and it has to package them
up. And the standard linker is going to package

00:47:21.900 --> 00:47:25.510
it for like, war deployment, but I mean there
are other linkers out there people have wrote

00:47:25.510 --> 00:47:28.010
deploying on an Android device and things
like that.

00:47:28.010 --> 00:47:31.960
There's all kinds of fancy stuff you can do.
And what you do is you run java.com.google.gwt.dev.Link

00:47:31.960 --> 00:47:38.099
and you give it the module and again, you
give it the work.dir, you give it war.dir,

00:47:38.099 --> 00:47:42.420
which is where it's going to deposit the war
structured application and you give it this

00:47:42.420 --> 00:47:48.070
directory called "aux", which is where you
want files that you don't want to serve up

00:47:48.070 --> 00:47:54.380
from the war; because the compiler generates
various extra files, like serialization policy

00:47:54.380 --> 00:48:00.900
things, the story of your compile, which is
what the compiler did to your code and where

00:48:00.900 --> 00:48:04.310
all this, this, what's taking the most amount
of space.

00:48:04.310 --> 00:48:09.349
So, you don't want that to be visible to the
user. Now remember, the link phase, like the

00:48:09.349 --> 00:48:14.331
precompile phase, executes on a single machine;
that's the serializa-, the serialized part.

00:48:14.331 --> 00:48:20.200
I also remember that the work.dir, the gwt.dev.jar,
that has the GWT Compiler in it, the gwt.user.jar

00:48:20.200 --> 00:48:23.530
and all your applications source and other
resources have to be network visible because

00:48:23.530 --> 00:48:25.849
if you're going to farm this out to all your
machines, they have to be able to see it.

00:48:25.849 --> 00:48:31.630
But that's basically it, those three simple
steps and you guys will be building, you know,

00:48:31.630 --> 00:48:38.440
doing builds in one or two seconds if you're
fast. So, here's some, here's that live notes

00:48:38.440 --> 00:48:43.650
link ag--, again if you want to look at the
Wave where the notes are being taken. I think

00:48:43.650 --> 00:48:48.970
it also asks questions there but, I'm ready
to take questions, so if you want to, you

00:48:48.970 --> 00:48:51.260
can come up to one of the two mics and I'll
be happy to answer. Thank you.

00:48:51.260 --> 00:49:04.000
[applause]

00:49:04.000 --> 00:49:09.190
Or I can look at the Wave and somebody already
asked a question.

00:49:09.190 --> 00:49:10.190
[pause]

00:49:10.190 --> 00:49:11.190
Yes.

00:49:11.190 --> 00:49:17.000
&gt;&gt;man1: Yes, could you talk a little bit more
about the linking cycle? You, you mentioned

00:49:17.000 --> 00:49:22.400
that, you know, it, it, is that going to like
let you link modules together without necessarily

00:49:22.400 --> 00:49:27.410
recompiling all of them in one big go, or,
what, what not, just talk a little bit about

00:49:27.410 --> 00:49:28.410
it.

00:49:28.410 --> 00:49:33.300
&gt;&gt;Ray: Ok, so the linking cycle is essentially
responsible for a couple things. One is --is--

00:49:33.300 --> 00:49:38.840
it generates the bootstrap scripts, or the
.nocache.js script which is different depending

00:49:38.840 --> 00:49:43.369
on where you intend to ultimately deploy your
application. So, for example, you know that

00:49:43.369 --> 00:49:47.420
there's the cross-site linker, which is if
you've got a GWT application and you want

00:49:47.420 --> 00:49:51.490
to sort of source script it from a third party
to a main versus another linker we have called

00:49:51.490 --> 00:49:55.410
the iFrame linker where it actually kind of
loads the GWT application up in a, in a hidden

00:49:55.410 --> 00:49:57.130
frame.

00:49:57.130 --> 00:50:00.859
There are other linkers like there is a gadget
linker. So, if you want to write an iGoogle

00:50:00.859 --> 00:50:06.520
gadget using GWT, there's a linker that's
able to structure the code so instead it can

00:50:06.520 --> 00:50:14.619
load up to a proxy server in an iGoogle context.
So, but, essentially what the linker is supposed

00:50:14.619 --> 00:50:19.790
to do is it gets a list of artifacts, which
are all the compiled JS artifacts, the files

00:50:19.790 --> 00:50:26.210
that are related to those, like PNG, sprited
images, CSS that's been optimized or compiled

00:50:26.210 --> 00:50:30.020
and things like that. And it basically has
to put them in the right directory so its

00:50:30.020 --> 00:50:35.230
free to basically zip them up, put them in
whatever directory structure it wants, and

00:50:35.230 --> 00:50:40.760
finally it has to generate the bootstrap code
because since it knows all of the output.js,

00:50:40.760 --> 00:50:47.240
it is the one responsible for generating the
nocache.js file which knows which right, correct

00:50:47.240 --> 00:50:51.330
permutation to actually load up. So, it will
say, in the script it will say, "If you're

00:50:51.330 --> 00:50:57.040
an IE browser, then you have to load up this
particular artifact versus if you're on Firefox

00:50:57.040 --> 00:51:03.099
it will load up this particular one." So,
the script does detection, loading, so it

00:51:03.099 --> 00:51:07.260
generates the nocache file and it packages,
essentially. Yes?

00:51:07.260 --> 00:51:13.970
&gt;&gt;man2: Thank you. You talked earlier about
the obfuscation on the RPC data types. I'm

00:51:13.970 --> 00:51:18.660
curious how that works because you're backend
wouldn't know what the obfuscation was.

00:51:18.660 --> 00:51:23.989
&gt;&gt;Ray: You know, I'm actually not that, Bob
Walter would know more, exactly how it works.

00:51:23.989 --> 00:51:28.640
But I believe that there's a file written
to disk that knows the map between obfuscated

00:51:28.640 --> 00:51:33.240
name and the real name so that when it gets
a serialized payload on the server, it will

00:51:33.240 --> 00:51:36.360
look up via the obfuscated identifier what
the real Java identifier was.

00:51:36.360 --> 00:51:38.340
&gt;&gt;man2: Ok, that makes sense. Thanks.

00:51:38.340 --> 00:51:39.340
&gt;&gt;Ray: Ok.

00:51:39.340 --> 00:51:45.880
&gt;&gt;man3: Is there any way to avoid a full compile
in run devmode when you change things that

00:51:45.880 --> 00:51:51.839
are server i-, in the server packet. I'm sorry,
shared, if you know that the branch of code

00:51:51.839 --> 00:51:59.030
isn't going to be affected on the server;
you're just doing front-end, you know, front-end

00:51:59.030 --> 00:52:01.740
debugging but it just happens to be a shared
class.

00:52:01.740 --> 00:52:04.000
&gt;&gt;Ray: Yeah, that's a good question and we've
heard that a lot and unfortunately there's

00:52:04.000 --> 00:52:10.450
no good answer for it because sometimes the,
if you run the server in debug mode, sometimes

00:52:10.450 --> 00:52:15.200
the VM can be told to reload a class that's
been modified and sometimes it can't. But

00:52:15.200 --> 00:52:18.870
we're working on a couple things to ameliorate
that. We have some people working on what's

00:52:18.870 --> 00:52:23.609
called SuperDevmode that sort of tries to
e-, eliminate what the com-, the, tries to

00:52:23.609 --> 00:52:28.410
make the refresh in devmode faster from the
aspect of it has to run the generators every

00:52:28.410 --> 00:52:33.920
time because if something could have changed
there. And also, to sort of make the server

00:52:33.920 --> 00:52:38.440
site reloading happen better. But, I, I can't
give you a, a direct answer for that because

00:52:38.440 --> 00:52:43.150
we're still kind of thinking about how best
to do it. But you might want to look at something

00:52:43.150 --> 00:52:48.170
called JavaRebel, if you've seen that. It's
a, I believe it's a utility that you can use

00:52:48.170 --> 00:52:53.661
that allows you to reload any class at runtime
on the server site. So, I think people use

00:52:53.661 --> 00:52:57.400
it to get around the limitations of, they
changed something in Eclipse, this is even,

00:52:57.400 --> 00:53:02.390
this is outside of GWT, it's like for any
Java application where they can modify class

00:53:02.390 --> 00:53:07.130
and then --they-- they want to reload it and
a lot of times the debugger and codes will

00:53:07.130 --> 00:53:11.270
say it can't reload this class. You have to
restart it, restart the server. But I think

00:53:11.270 --> 00:53:14.000
Java Rebel allows you to get around that limitation.

00:53:14.000 --> 00:53:16.890
&gt;&gt;man3: Do you know if that's, do you know
if that's applicable if you're running under

00:53:16.890 --> 00:53:20.730
no server where you have your own deployment
container?

00:53:20.730 --> 00:53:25.470
&gt;&gt;Ray: Actually, it would be even more applicable
because then, you'd have more control over

00:53:25.470 --> 00:53:31.430
how the, the server gets started if you're
running your own server rather than the devmode

00:53:31.430 --> 00:53:32.430
server.

00:53:32.430 --> 00:53:33.430
&gt;&gt;man3: The name of that was again, I'm sorry.

00:53:33.430 --> 00:53:36.210
&gt;&gt;Ray: It was, I think its Java Rebel, is
the name of it. I could, I could be misremembering,

00:53:36.210 --> 00:53:37.210
but--

00:53:37.210 --> 00:53:38.619
&gt;&gt;man3: Thank you.

00:53:38.619 --> 00:53:44.740
&gt;&gt;man4: I'm curious about turning off the
Java class data, the disabling it?

00:53:44.740 --> 00:53:45.740
&gt;&gt;Ray: Yeah.

00:53:45.740 --> 00:53:49.630
&gt;&gt;man4: If you're doing it, if I turn that
off and another developer does an instanceof

00:53:49.630 --> 00:53:54.869
is it always true, is it always false, or
does it do an error?

00:53:54.869 --> 00:54:00.030
&gt;&gt;Ray: It still will be able to do instanceof
correctly because the, the way that GWT implements

00:54:00.030 --> 00:54:04.100
instanceof is by this hidden field that it
puts on the prototype of every field that

00:54:04.100 --> 00:54:08.750
it called the typeid. The instanceof operator
operates on that. The class metadata is really

00:54:08.750 --> 00:54:14.640
just kind of string data that is really for
display purposes and it's not actually, it

00:54:14.640 --> 00:54:17.020
doesn't really matter too much to the logic
of implementing the instanceof operator.

00:54:17.020 --> 00:54:21.560
&gt;&gt;man4: Do you lose the class, like two string
on the class?

00:54:21.560 --> 00:54:25.550
&gt;&gt;Ray: Yeah, if you two string the class instead
of being like, you know, "employee", it would

00:54:25.550 --> 00:54:32.579
be like, "class $1" or something like that.

00:54:32.579 --> 00:54:36.270
&gt;&gt;man5: You mentioned that the singleton pattern
implemented with the static initializer was

00:54:36.270 --> 00:54:39.690
slightly inefficient in, in GWT because of
static initializer--

00:54:39.690 --> 00:54:40.690
&gt;&gt;Ray: Yes.

00:54:40.690 --> 00:54:46.420
&gt;&gt;man5: What if you use the eNom pattern for
singleton as opposed to a list of constants

00:54:46.420 --> 00:54:48.530
because there's that other issue with the
eNom--

00:54:48.530 --> 00:54:49.530
&gt;&gt;Ray: Yeah.

00:54:49.530 --> 00:54:50.530
&gt;&gt;man5: Which one's better?

00:54:50.530 --> 00:54:54.760
&gt;&gt;Ray: It's still inefficient so any time
you have a static field that is initialized

00:54:54.760 --> 00:54:59.690
by a static initializer, and an eNom is an
implicit static initializer, it's always there.

00:54:59.690 --> 00:55:04.040
However, we do have two optimizations where
they're in a pipeline that both reduce the

00:55:04.040 --> 00:55:10.220
cost of static field initializers by tracking
if an, if it, if a, if a initializer has been

00:55:10.220 --> 00:55:15.560
called once, then later in the code it won't
call ever again. So, it reduces the amount

00:55:15.560 --> 00:55:20.569
of times it's going to check and secondly,
we can, we can a lot of times hoist those

00:55:20.569 --> 00:55:26.560
initializations up to the front of the program
so that after the program has been boot strapped,

00:55:26.560 --> 00:55:31.420
right, basically no initialization happens
at all. So, there are a lot of things we have

00:55:31.420 --> 00:55:34.180
in the pipeline and hope, and I don't want
to encourage people too much to change their

00:55:34.180 --> 00:55:39.180
code, only until GWT 2.2 comes out if you're
really desperate, you can look at like changing

00:55:39.180 --> 00:55:43.859
fields from static being lazy with it. Thanks.

00:55:43.859 --> 00:55:50.839
Ok, I got four minutes left if anybody has
any questions, otherwise, thanks for coming.

00:55:50.839 --> 00:55:54.650
Oh, and by the way, advertisement, the next
session you definitely want to stay around

00:55:54.650 --> 00:56:02.369
for it, its architecting GWT apps for performance
and it's done by Joel Webber and Adam of the

00:56:02.369 --> 00:56:04.660
Wave team. So, you definitely want to stick
around for that because they're going to teach

00:56:04.660 --> 00:56:08.210
you a lot of the tricks they use to make Wave
run fast. Thank you.

00:56:08.210 --> 00:56:13.320
[applause]

