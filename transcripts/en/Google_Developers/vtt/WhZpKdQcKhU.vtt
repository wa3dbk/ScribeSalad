WEBVTT
Kind: captions
Language: en

00:00:05.203 --> 00:00:07.100
AMBER WEINBERG: Hello,
everybody.

00:00:07.100 --> 00:00:08.546
Can you hear me?

00:00:08.546 --> 00:00:09.010
All right.

00:00:09.010 --> 00:00:10.200
Was lunch great?

00:00:10.200 --> 00:00:12.250
Lunch was great, huh?

00:00:12.250 --> 00:00:14.314
So in this panel we
will be talking

00:00:14.314 --> 00:00:16.010
about responsive layout.

00:00:16.010 --> 00:00:18.520
And George Crawford
is our opener.

00:00:18.520 --> 00:00:22.440
He is the Lead Developer of The
Economist's HTML5 project

00:00:22.440 --> 00:00:25.560
and the maintainer of FT
Columnflow, which is this

00:00:25.560 --> 00:00:28.350
really cool magazine-like thing
that I hope he will

00:00:28.350 --> 00:00:30.770
explain to all of us.

00:00:30.770 --> 00:00:32.840
Then we have Razvan.

00:00:32.840 --> 00:00:37.720
He works on CSS Regions, CSS
Exclusions, and other ways of

00:00:37.720 --> 00:00:40.580
improving digital publishing
on the web.

00:00:40.580 --> 00:00:42.810
Then we have Andy over here.

00:00:42.810 --> 00:00:46.110
He was formerly the Lead
Engineer on Bing maps and then

00:00:46.110 --> 00:00:49.470
worked for the awesome Clearleft
offices in Brighton.

00:00:49.470 --> 00:00:54.580
And currently, he does the
client-side work at Guardian.

00:00:54.580 --> 00:00:57.320
So George, if you want to come
up and give your presentation.

00:01:06.330 --> 00:01:09.487
GEORGE CRAWFORD: So responsive
design is a bit of a buzzword.

00:01:09.487 --> 00:01:12.790
I'm sure you're all familiar
with it, but it sort of lacks

00:01:12.790 --> 00:01:14.040
definition.

00:01:16.976 --> 00:01:19.990
First slide is coming up.

00:01:19.990 --> 00:01:22.860
So responsive design,
it lacks definition.

00:01:22.860 --> 00:01:24.750
We need some clarity.

00:01:24.750 --> 00:01:29.105
I'm sure you've all thought
from time to time about

00:01:29.105 --> 00:01:32.430
various considerations we need
to take in mind when thinking

00:01:32.430 --> 00:01:34.757
about responsive development.

00:01:34.757 --> 00:01:36.720
I liked a quote on
Andy's blog--

00:01:36.720 --> 00:01:39.710
"Responsiveness is what a
website does when it's loaded

00:01:39.710 --> 00:01:43.080
into an unknown browser on an
unknown device by an unknown

00:01:43.080 --> 00:01:46.970
individual." So websites need
to respond to the device and

00:01:46.970 --> 00:01:49.890
the environment and to the user
and to many other factors

00:01:49.890 --> 00:01:52.290
to offer the best experience.

00:01:52.290 --> 00:01:54.700
But dealing with all of these
considerations is far too

00:01:54.700 --> 00:01:57.430
broad for this session, so we're
just going to talk about

00:01:57.430 --> 00:01:58.680
responsive layout.

00:02:01.614 --> 00:02:05.770
So here's a typical example of
a site that really thinks

00:02:05.770 --> 00:02:09.695
about responsive layout
that's only really

00:02:09.695 --> 00:02:11.862
based on viewport width.

00:02:11.862 --> 00:02:15.666
This is something I stole from
Amber's blog posts, the United

00:02:15.666 --> 00:02:16.250
Pixelworkers.

00:02:16.250 --> 00:02:20.630
Yeah, it's funky, and it's
a really nice sort of

00:02:20.630 --> 00:02:21.991
interactive experience.

00:02:21.991 --> 00:02:26.200
And that doesn't really answer
all of the questions that we

00:02:26.200 --> 00:02:28.045
need to answer.

00:02:28.045 --> 00:02:30.410
So we don't need to just
consider the aesthetics of a

00:02:30.410 --> 00:02:32.690
layout but also the whole
effect on the reading

00:02:32.690 --> 00:02:35.760
experience and the way that
a user will [INAUDIBLE]

00:02:35.760 --> 00:02:37.691
the sites.

00:02:37.691 --> 00:02:41.120
Like, if we need to do extra
processing to achieve a better

00:02:41.120 --> 00:02:44.640
layout, we might need to wait
longer for the network, we

00:02:44.640 --> 00:02:47.450
might need to wait for the CPU,
we might decrease the

00:02:47.450 --> 00:02:49.560
frame weight.

00:02:49.560 --> 00:02:52.284
So following the discussion we
had earlier in the network

00:02:52.284 --> 00:02:56.000
panel, we need to consider
things like this.

00:02:56.000 --> 00:02:58.640
With the Economist web app that
I've been working on, our

00:02:58.640 --> 00:03:02.690
first page load, we just use
real links to real images.

00:03:02.690 --> 00:03:06.290
But as the user navigates to
an addition, subsequent

00:03:06.290 --> 00:03:09.110
articles, we download
with Ajax requests.

00:03:09.110 --> 00:03:12.160
And we actually send the
dimensions of the viewports in

00:03:12.160 --> 00:03:15.180
the request, so that images can
be dynamically re-sized on

00:03:15.180 --> 00:03:19.240
the server, A64-encoded, added
in line to the HTML.

00:03:19.240 --> 00:03:20.880
Now, there are obviously
pros and cons to

00:03:20.880 --> 00:03:22.680
that, as we've discussed.

00:03:22.680 --> 00:03:28.410
But it has a great advantage in
that we don't need to do so

00:03:28.410 --> 00:03:29.950
much work on the client.

00:03:29.950 --> 00:03:34.680
And also, once the first type of
device, like the first iPad

00:03:34.680 --> 00:03:38.940
or the first PlayBook, has
rendered that article, we can

00:03:38.940 --> 00:03:41.510
store it in the cache
for faster

00:03:41.510 --> 00:03:43.740
performance in the future.

00:03:43.740 --> 00:03:47.130
So my experience is mostly with
the Financial Times and

00:03:47.130 --> 00:03:50.340
the Economist, which are very
much reading platforms.

00:03:50.340 --> 00:03:53.430
So let's look at some of the
problems that newspapers and

00:03:53.430 --> 00:03:56.730
magazines present on the web.

00:03:56.730 --> 00:04:00.440
So the FT wanted a column
layout, which is obviously

00:04:00.440 --> 00:04:03.210
inspired by their
print edition.

00:04:03.210 --> 00:04:06.160
CSS columns is useful, but
it's not enough, even to

00:04:06.160 --> 00:04:08.210
create a simple layout
like this.

00:04:08.210 --> 00:04:10.940
This headline that spans column
one and two, you can't

00:04:10.940 --> 00:04:12.120
do that with CSS columns.

00:04:12.120 --> 00:04:14.810
You have the options to span all
of the columns or one of

00:04:14.810 --> 00:04:15.920
the columns.

00:04:15.920 --> 00:04:18.950
So we need to turn to JavaScript
straightaway.

00:04:18.950 --> 00:04:22.630
And our first approach was to
iterate through every single

00:04:22.630 --> 00:04:26.680
word in a paragraph, even in
an optimized way, find out

00:04:26.680 --> 00:04:29.990
where to cut the paragraph, and
move the contents to the

00:04:29.990 --> 00:04:30.610
next column.

00:04:30.610 --> 00:04:34.340
You know that dealing with
text is really bad for

00:04:34.340 --> 00:04:36.650
performance, so we looked
into other ways of

00:04:36.650 --> 00:04:37.660
speeding this up.

00:04:37.660 --> 00:04:39.890
And we developed
FT Columnflow.

00:04:39.890 --> 00:04:41.970
This is Columnflow in action
on the Economist's app.

00:04:41.970 --> 00:04:45.170
And actually, the FT, the page
before, was also running

00:04:45.170 --> 00:04:46.630
Columnflow.

00:04:46.630 --> 00:04:50.620
And if we look a bit closer at
what's happening here, we can

00:04:50.620 --> 00:04:53.130
see the paragraphs highlighted
in red.

00:04:53.130 --> 00:04:55.420
And you can see that the
paragraph at the bottom of

00:04:55.420 --> 00:04:58.060
column one has been cloned
and moved to the

00:04:58.060 --> 00:04:59.840
top of column two.

00:04:59.840 --> 00:05:03.350
So yes, we have twice the
weight in the DOM.

00:05:03.350 --> 00:05:07.070
But if we hide the overflow,
we get a nice result.

00:05:07.070 --> 00:05:09.970
And it's actually much faster
than iterating through each

00:05:09.970 --> 00:05:11.220
word in the paragraph.

00:05:14.140 --> 00:05:16.290
So Columnflow has some other
features which really help

00:05:16.290 --> 00:05:17.600
with responsive layout.

00:05:17.600 --> 00:05:21.920
You can add classes on to the
flowed elements to stop

00:05:21.920 --> 00:05:24.210
elements wrapping, so by
default, for example, it

00:05:24.210 --> 00:05:26.060
doesn't wrap images.

00:05:26.060 --> 00:05:28.210
You can also keep headings
attached to the paragraph

00:05:28.210 --> 00:05:30.350
which follows them.

00:05:30.350 --> 00:05:33.030
And you can position fixed
elements like headlines and

00:05:33.030 --> 00:05:36.440
images on a particular page, a
particular column, spanning

00:05:36.440 --> 00:05:37.930
any number of columns.

00:05:37.930 --> 00:05:41.100
Columnflow will try and avoid
orphaned lines at the ends of

00:05:41.100 --> 00:05:41.525
paragraphs.

00:05:41.525 --> 00:05:44.790
So it would prefer two lines in
the next column rather than

00:05:44.790 --> 00:05:47.420
one line on its own.

00:05:47.420 --> 00:05:51.320
And it will try and determine
the vertical grid height and

00:05:51.320 --> 00:05:54.120
add padding dynamically to
images and headlines so that

00:05:54.120 --> 00:05:59.260
they conform to the grid, so
that you get a nice vertical

00:05:59.260 --> 00:06:02.036
grid running through the page.

00:06:02.036 --> 00:06:04.100
Columnflow does have
some side effects.

00:06:04.100 --> 00:06:05.680
It's not perfect.

00:06:05.680 --> 00:06:09.380
And one interesting one is
that fonts must be loaded

00:06:09.380 --> 00:06:11.020
before it runs.

00:06:11.020 --> 00:06:14.240
If a font loads after Columnflow
has laid out the

00:06:14.240 --> 00:06:17.190
absolute position of each
paragraph, then you get into

00:06:17.190 --> 00:06:18.350
big problems.

00:06:18.350 --> 00:06:21.190
You can see here that there's
clipping at the bottom of

00:06:21.190 --> 00:06:23.730
column one and at the
top of column two.

00:06:23.730 --> 00:06:26.290
So in the Economist, we
actually use a font

00:06:26.290 --> 00:06:31.090
pre-loader, which presents a
whole load of other problems.

00:06:31.090 --> 00:06:34.525
Anyone who's looked into
determining precisely when a

00:06:34.525 --> 00:06:35.850
font loads, it's a nightmare.

00:06:35.850 --> 00:06:39.230
And there's a CSS3 fonts module,
which will hopefully,

00:06:39.230 --> 00:06:41.480
in the future, add an
onload event or

00:06:41.480 --> 00:06:43.160
something similar for fonts.

00:06:43.160 --> 00:06:45.930
But not much browser support
yet, of course.

00:06:45.930 --> 00:06:49.130
So taking it further, how
might we improve the

00:06:49.130 --> 00:06:50.390
Economist's responsive layout?

00:06:50.390 --> 00:06:53.530
I've hacked the code base
a little bit, added some

00:06:53.530 --> 00:06:54.150
experimental enhance--

00:06:54.150 --> 00:06:58.180
[AUDIO CUTS OUT]

00:06:58.180 --> 00:07:00.500
GEORGE CRAWFORD: So this
article layout is

00:07:00.500 --> 00:07:02.880
designed for the iPad.

00:07:02.880 --> 00:07:05.630
And what that means is that
the number of columns is

00:07:05.630 --> 00:07:06.780
hard-coded.

00:07:06.780 --> 00:07:09.460
And even the aspect ratio of
the image is determined,

00:07:09.460 --> 00:07:11.685
editorially, for the
iPad layout.

00:07:14.360 --> 00:07:17.600
So when we launched on hardware
with a different

00:07:17.600 --> 00:07:20.760
aspect ratio, the easiest
solution is to add white

00:07:20.760 --> 00:07:22.410
gutters on the sides.

00:07:22.410 --> 00:07:26.530
It's not a terrible solution,
but it's losing a little

00:07:26.530 --> 00:07:30.310
element of that immersive
experience.

00:07:30.310 --> 00:07:32.200
So why can't we add some
flexibility to this?

00:07:32.200 --> 00:07:34.380
We don't need to hard-code
the number of columns.

00:07:34.380 --> 00:07:38.310
We can determine the optimum
number of columns by thinking

00:07:38.310 --> 00:07:41.220
about things like the
typographic measure.

00:07:41.220 --> 00:07:44.280
So the measure is the number
of characters in a line.

00:07:44.280 --> 00:07:47.400
And as the font size changes,
the number of characters you

00:07:47.400 --> 00:07:49.730
can fit in a line will
also change.

00:07:49.730 --> 00:07:53.310
So if we go for an ideal
typographic measure, then we

00:07:53.310 --> 00:07:57.190
can also, based on the viewport,
determine the ideal

00:07:57.190 --> 00:07:59.260
number of columns.

00:07:59.260 --> 00:08:01.230
We can improve legibility
a bit by

00:08:01.230 --> 00:08:03.350
modifying the line height.

00:08:03.350 --> 00:08:06.840
So for longer lines of text,
it's a generally-accepted

00:08:06.840 --> 00:08:10.280
principle that you want a bit
more space between lines, and

00:08:10.280 --> 00:08:13.240
for shorter lines, a bit
less line height.

00:08:13.240 --> 00:08:15.700
These are quite well-known print
concepts, but they're

00:08:15.700 --> 00:08:19.760
only slowly coming to the web
as our devices provide more

00:08:19.760 --> 00:08:21.880
and more immersive reading
experiences.

00:08:21.880 --> 00:08:23.720
And also, there's some
technology that we're

00:08:23.720 --> 00:08:25.760
waiting for, too.

00:08:25.760 --> 00:08:29.110
We can vary the number of
columns that the image spans

00:08:29.110 --> 00:08:31.100
based on the total number
of columns--

00:08:31.100 --> 00:08:34.380
and also the width and also the
height of the viewport,

00:08:34.380 --> 00:08:38.289
because we have to take the
aspect ratio into account.

00:08:38.289 --> 00:08:41.850
So this is the first draft.

00:08:41.850 --> 00:08:43.830
It's making better use of
the available space.

00:08:43.830 --> 00:08:45.180
It's more immersive.

00:08:45.180 --> 00:08:49.000
It feels like the app has been
tailor-made for your screen.

00:08:49.000 --> 00:08:52.670
And it does increase
the legibility.

00:08:52.670 --> 00:08:55.200
I'll just run through a range
of viewport sizes.

00:08:55.200 --> 00:09:00.160
You can see some of the things
that we're changing.

00:09:00.160 --> 00:09:03.650
So as the line length increases,
it goes too far for

00:09:03.650 --> 00:09:07.130
the ideal measure, so we
add in extra columns.

00:09:07.130 --> 00:09:10.070
And you can see the line height
changing slightly based

00:09:10.070 --> 00:09:11.910
on the length of the lines.

00:09:11.910 --> 00:09:14.810
And that image started off
spanning one column, then to

00:09:14.810 --> 00:09:16.060
two, then to three.

00:09:19.380 --> 00:09:22.180
So the same logic can be applied
to a static viewport,

00:09:22.180 --> 00:09:24.230
but when the user is changing
the font size.

00:09:28.740 --> 00:09:32.020
So as we increase the font size,
we have fewer characters

00:09:32.020 --> 00:09:34.675
per line, so we actually
need fewer columns.

00:09:43.580 --> 00:09:45.660
We can go even further,
improving the article's

00:09:45.660 --> 00:09:46.310
typesetting.

00:09:46.310 --> 00:09:48.900
We can learn from techniques
used to layout newspaper

00:09:48.900 --> 00:09:51.550
columns like hyphenation
and justification.

00:09:51.550 --> 00:09:54.600
So the default here is a ragged
right edge, which with

00:09:54.600 --> 00:09:57.990
a narrow column gets a little
bit difficult to read.

00:09:57.990 --> 00:10:04.040
But if you set justification,
it doesn't help [INAUDIBLE].

00:10:04.040 --> 00:10:07.050
We get these large areas of
white space, and they can

00:10:07.050 --> 00:10:10.560
sometimes form very
ugly rivers.

00:10:10.560 --> 00:10:13.570
So we can add in hyphenation.

00:10:13.570 --> 00:10:15.990
CSS Hyphenation, again, doesn't
have great browser

00:10:15.990 --> 00:10:18.350
support, so I've used a
JavaScript library here.

00:10:18.350 --> 00:10:21.600
And performance analysts
might worry about this.

00:10:21.600 --> 00:10:25.660
It took 10 milliseconds to
hyphenate this entire article.

00:10:25.660 --> 00:10:28.550
So I think it's worth
considering

00:10:28.550 --> 00:10:32.360
for text-heavy layouts.

00:10:32.360 --> 00:10:36.180
Now, we mentioned in the network
session earlier that

00:10:36.180 --> 00:10:38.670
we might be able to do
more with images

00:10:38.670 --> 00:10:42.320
and responsive workflows.

00:10:42.320 --> 00:10:44.650
So maybe it's worth considering
on the editorial

00:10:44.650 --> 00:10:48.290
side that they might even embed
metadata into image

00:10:48.290 --> 00:10:50.830
files with a selection
of possible crops.

00:10:50.830 --> 00:10:54.170
So you might be able to choose,
on the client side, a

00:10:54.170 --> 00:10:55.640
range of aspect ratios.

00:10:55.640 --> 00:10:57.960
Some may be a tighter
crop if the image is

00:10:57.960 --> 00:10:59.280
going to be very small.

00:10:59.280 --> 00:11:02.020
And then you can determine,
based on the size and the

00:11:02.020 --> 00:11:04.890
aspect ratio of the space you
have, which would be the best

00:11:04.890 --> 00:11:06.560
one of those crops to use.

00:11:06.560 --> 00:11:10.820
So we can improve this layout by
maybe having a shorter and

00:11:10.820 --> 00:11:13.480
wider image or having a tighter
crop that can just

00:11:13.480 --> 00:11:16.720
occupy one column.

00:11:16.720 --> 00:11:19.480
So what technology do we have
around for our disposal for

00:11:19.480 --> 00:11:20.625
responsive layouts?

00:11:20.625 --> 00:11:21.875
And what's coming up?

00:11:27.738 --> 00:11:31.220
You've probably all seen grids
like this, the 960 Grid and

00:11:31.220 --> 00:11:32.410
Twitter's Bootstrap.

00:11:32.410 --> 00:11:33.990
These don't give a perfect
solution for

00:11:33.990 --> 00:11:34.740
the responsive layout.

00:11:34.740 --> 00:11:37.920
They're either completely fixed
width, or they only

00:11:37.920 --> 00:11:40.340
adapt a little bit and then
instantly snap to a single

00:11:40.340 --> 00:11:42.205
column on mobile devices.

00:11:45.030 --> 00:11:46.800
So we've got some emerging
technologies which

00:11:46.800 --> 00:11:47.810
will help us a lot.

00:11:47.810 --> 00:11:51.250
In the Economist and the FT,
we're using Flexbox to help

00:11:51.250 --> 00:11:54.430
with layouts, it's very powerful
and can be quite

00:11:54.430 --> 00:11:55.535
complicated.

00:11:55.535 --> 00:11:59.300
And then the CSS Grid Layout
module, which is only

00:11:59.300 --> 00:12:01.720
currently in Internet Explorer,
is going to help a

00:12:01.720 --> 00:12:05.492
lot with designing responsive
grid layouts.

00:12:05.492 --> 00:12:07.840
And then Razvan's team at Adobe
are working on some

00:12:07.840 --> 00:12:11.530
really nice proposals for
new CSS modules--

00:12:11.530 --> 00:12:15.150
the CSS Regions and Pagination
templates for rich,

00:12:15.150 --> 00:12:16.910
magazine-like layouts.

00:12:16.910 --> 00:12:20.200
So I've devoted quite a lot of
time to Columnflow, but with

00:12:20.200 --> 00:12:21.590
any luck, modules
like this will

00:12:21.590 --> 00:12:23.390
eventually make it redundant.

00:12:23.390 --> 00:12:26.190
Until we get browser support,
of course, we do need

00:12:26.190 --> 00:12:30.510
JavaScript polyfills
to do the same job.

00:12:30.510 --> 00:12:33.970
And then the CSS Exclusions,
allowing you to flow text

00:12:33.970 --> 00:12:38.210
inside and outside shapes
and even images.

00:12:42.600 --> 00:12:45.320
And we've got technology like
seamless iframes, web

00:12:45.320 --> 00:12:48.970
components, the shadow DOM,
custom elements-- which, when

00:12:48.970 --> 00:12:52.900
they're combined, might lead
to give us context-agnostic

00:12:52.900 --> 00:12:56.700
encapsulated modules of HTML
and CSS which can adapt and

00:12:56.700 --> 00:12:59.600
respond to their available space
rather than actually

00:12:59.600 --> 00:13:01.840
worrying about the viewports
so much.

00:13:01.840 --> 00:13:04.970
So we're looking into this
a lot for the FT web app,

00:13:04.970 --> 00:13:07.600
creating individually-styled
modules which can be dropped

00:13:07.600 --> 00:13:10.240
into any part of any
page without

00:13:10.240 --> 00:13:12.590
interfering with other elements.

00:13:12.590 --> 00:13:14.930
So hopefully that's given you
some ideas about responsive

00:13:14.930 --> 00:13:16.890
layouts for magazines
and newspapers.

00:13:16.890 --> 00:13:18.840
But what about the
other problems

00:13:18.840 --> 00:13:20.310
that other sites have?

00:13:20.310 --> 00:13:23.320
And how else do people deal
with responsive layouts?

00:13:23.320 --> 00:13:26.755
I'll hand it back to Amber.

00:13:26.755 --> 00:13:33.185
[APPLAUSE]

00:13:37.065 --> 00:13:38.050
AMBER WEINBERG: All right.

00:13:38.050 --> 00:13:41.630
So our first question is
actually going to be my

00:13:41.630 --> 00:13:44.770
question, because it is a
problem that I have been

00:13:44.770 --> 00:13:48.050
facing lately and I'm sure
many other devs have.

00:13:48.050 --> 00:13:52.410
Kind of with the performance
talk as well, but is it worth

00:13:52.410 --> 00:13:57.050
taking the performance hit and
extra time deving to serve up

00:13:57.050 --> 00:13:58.350
retina images?

00:13:58.350 --> 00:14:01.000
Or should we only pay attention
to retina images

00:14:01.000 --> 00:14:03.490
when it's really important--
for things like icons or

00:14:03.490 --> 00:14:04.880
photo-heavy websites?

00:14:04.880 --> 00:14:08.190
Because a lot of sites don't
really matter as far

00:14:08.190 --> 00:14:11.840
as the images go.

00:14:11.840 --> 00:14:14.091
So George?

00:14:14.091 --> 00:14:16.980
GEORGE CRAWFORD: Well, my
experience with the FT and the

00:14:16.980 --> 00:14:20.420
Economist is that first of all,
it is a shock to see your

00:14:20.420 --> 00:14:25.390
site on a retina display when
you haven't prepared for it.

00:14:25.390 --> 00:14:28.730
It's really interesting, the
difference between a large

00:14:28.730 --> 00:14:31.550
JPEG image, like the ones I
was showing, and the tiny

00:14:31.550 --> 00:14:32.960
interface icons.

00:14:32.960 --> 00:14:37.020
I think because we're so used to
really nice font rendering

00:14:37.020 --> 00:14:44.500
and really nice PDF support,
just seeing a PNG, a tiny file

00:14:44.500 --> 00:14:47.030
that could easily be doubled
without worrying too much

00:14:47.030 --> 00:14:49.600
about the overhead, it really
makes a big difference.

00:14:49.600 --> 00:14:54.250
And I think you can get away
with non-retina, large JPEGs.

00:14:54.250 --> 00:14:56.460
And I think that's definitely
the first step.

00:14:56.460 --> 00:15:00.020
And maybe then look into how
much overhead you're going to

00:15:00.020 --> 00:15:01.400
add with large feature images.

00:15:01.400 --> 00:15:03.920
But of course, some sites are
not using feature images to

00:15:03.920 --> 00:15:05.370
the extent that we do.

00:15:05.370 --> 00:15:08.790
ANDY HUME: Yeah, I think it
depends exactly what you're

00:15:08.790 --> 00:15:12.240
trying to do on a given
site or a given page.

00:15:12.240 --> 00:15:15.260
Clearly, a lot of the stuff
in the newspapers is about

00:15:15.260 --> 00:15:18.690
high-resolution imagery, and
we have apps that are

00:15:18.690 --> 00:15:22.500
specifically tailored to showing
those in engaging,

00:15:22.500 --> 00:15:23.180
beautiful ways.

00:15:23.180 --> 00:15:26.880
So those do need to be the
high-resolution stuff.

00:15:26.880 --> 00:15:31.560
I think for the more Chrome
interface stuff, I'm sort of

00:15:31.560 --> 00:15:33.350
in two minds.

00:15:33.350 --> 00:15:36.850
I think as much as you can get
the browser to render this

00:15:36.850 --> 00:15:42.180
stuff itself natively and get
away from images with some of

00:15:42.180 --> 00:15:45.830
the visual stuff in CSS, making
sure you're using

00:15:45.830 --> 00:15:48.330
rounded corners and drop
shadows as much as--

00:15:48.330 --> 00:15:50.180
GEORGE CRAWFORD: And then icon
fonts and things like that.

00:15:50.180 --> 00:15:50.620
ANDY HUME: Yeah.

00:15:50.620 --> 00:15:54.200
And SVG to a degree as well.

00:15:54.200 --> 00:15:55.880
And I think it depends.

00:15:55.880 --> 00:15:58.420
Some icons, I'm not that
fussed about them

00:15:58.420 --> 00:15:59.830
not looking as great.

00:15:59.830 --> 00:16:02.900
I think things like the logo
is where you notice it, and

00:16:02.900 --> 00:16:04.480
all other people notice
it as well.

00:16:04.480 --> 00:16:09.030
GEORGE CRAWFORD: I've worked
with the Economist on getting

00:16:09.030 --> 00:16:12.700
the articles to work offline,
and the number of stages you

00:16:12.700 --> 00:16:15.630
go through where you add
size to the data.

00:16:15.630 --> 00:16:22.215
So if we A64-encode our images
and then store them in Web SQL

00:16:22.215 --> 00:16:29.030
or IndexedDB, which tends to be
A16-encoded, every time you

00:16:29.030 --> 00:16:30.790
encode the image differently,
you're adding

00:16:30.790 --> 00:16:31.790
massively to the overhead.

00:16:31.790 --> 00:16:35.030
So if we then double the size
or quadruple the size of the

00:16:35.030 --> 00:16:37.980
image file as well, this
is a big issue.

00:16:37.980 --> 00:16:41.840
But as I say, I think interface
icons are really

00:16:41.840 --> 00:16:45.548
important and other
things not so.

00:16:45.548 --> 00:16:46.460
AMBER WEINBERG: OK.

00:16:46.460 --> 00:16:50.880
So our own Andrew over here
asked an important question.

00:16:50.880 --> 00:16:55.360
Is increased page weight an
inevitable side effect of

00:16:55.360 --> 00:16:59.310
responsive web design versus
just a regular

00:16:59.310 --> 00:17:02.162
separate mobile site?

00:17:02.162 --> 00:17:02.860
RAZVAN CALIMAN: Yeah.

00:17:02.860 --> 00:17:06.930
So if you talk about responsive
websites and you

00:17:06.930 --> 00:17:10.220
look at images, for example, or
written images, there's no

00:17:10.220 --> 00:17:12.490
clear-cut way of getting
around that.

00:17:12.490 --> 00:17:14.924
Yes, you will have increased
file size with

00:17:14.924 --> 00:17:16.859
the responsive website.

00:17:16.859 --> 00:17:20.869
But then again, as Ilya and
other people mentioned

00:17:20.869 --> 00:17:24.720
earlier, the overhead you have
afterwards is just some fishy

00:17:24.720 --> 00:17:26.109
amount, some CSS.

00:17:26.109 --> 00:17:29.070
And we're hoping to have the
extra markup you're using for

00:17:29.070 --> 00:17:36.330
responsive layouts fixed in
proposals such as grid layout

00:17:36.330 --> 00:17:37.080
or Flexbox.

00:17:37.080 --> 00:17:40.870
Because that's mainly where
you're adding extra markup or

00:17:40.870 --> 00:17:43.770
extra CSS to handle
various parts of

00:17:43.770 --> 00:17:45.110
your responsive layout.

00:17:45.110 --> 00:17:50.580
So in terms of adding size,
yes, I think right now

00:17:50.580 --> 00:17:55.460
responsive websites do incur a
price penalty in file size if

00:17:55.460 --> 00:17:57.620
you want to deal with different
size images, which

00:17:57.620 --> 00:18:01.290
you should if you do care
about the performance on

00:18:01.290 --> 00:18:03.592
different devices and
different browsers.

00:18:03.592 --> 00:18:06.610
ANDY HUME: I think you've got to
be careful about taking it

00:18:06.610 --> 00:18:08.060
to extremes, though.

00:18:08.060 --> 00:18:12.270
Because you can start going down
a road where you end up

00:18:12.270 --> 00:18:15.380
polyfilling things like
media queries in all

00:18:15.380 --> 00:18:16.790
the versions of [? IE8, ?]

00:18:16.790 --> 00:18:19.605
which there are libraries
to do that, and

00:18:19.605 --> 00:18:20.360
they do it very well.

00:18:20.360 --> 00:18:24.440
But I think that's kind
of missing the point.

00:18:24.440 --> 00:18:27.820
If you have to add more and more
of these pieces of these

00:18:27.820 --> 00:18:31.580
JavaScript libraries and
polyfills and the like to make

00:18:31.580 --> 00:18:34.320
stuff responsive, I think you
will end up in a situation

00:18:34.320 --> 00:18:38.540
where your responsive site's
mobile view, if you like, is

00:18:38.540 --> 00:18:40.900
worse than it would have been if
you had just optimized for

00:18:40.900 --> 00:18:42.130
mobile in the first place.

00:18:42.130 --> 00:18:43.280
RAZVAN CALIMAN: Yeah.

00:18:43.280 --> 00:18:44.872
I totally agree on this.

00:18:44.872 --> 00:18:48.360
Of course you need to look at
the device, the context, and

00:18:48.360 --> 00:18:49.910
where people are going
to use it.

00:18:49.910 --> 00:18:52.770
Of course it doesn't make any
sense to polyfill for media

00:18:52.770 --> 00:18:56.190
queries and the like.

00:18:56.190 --> 00:19:01.040
So yeah, I do agree.

00:19:01.040 --> 00:19:03.410
You find your lowest common
denominator, and you build up

00:19:03.410 --> 00:19:05.640
from that, but you ensure you
give your users a good

00:19:05.640 --> 00:19:07.170
experience.

00:19:07.170 --> 00:19:11.220
The point is that I am in
favor of quite a lot of

00:19:11.220 --> 00:19:14.120
polyfills right now, because
there's a lot of technology

00:19:14.120 --> 00:19:16.800
that hasn't been tested quite
yet, and everybody's waiting

00:19:16.800 --> 00:19:18.810
for it to come into browsers.

00:19:18.810 --> 00:19:21.550
And polyfills give you a very
good opportunity to build the

00:19:21.550 --> 00:19:24.610
technology experiment with it
and learn that some use cases

00:19:24.610 --> 00:19:25.700
just don't fit--

00:19:25.700 --> 00:19:28.210
like, see the AppCache model.

00:19:28.210 --> 00:19:30.570
ANDY HUME: Or the Columnflow
stuff.

00:19:30.570 --> 00:19:34.430
GEORGE CRAWFORD: I think at
every stage of the way we need

00:19:34.430 --> 00:19:38.830
to bear in mind the good
user interface as well.

00:19:38.830 --> 00:19:42.540
As soon as people get on to the
bandwagon of responsive

00:19:42.540 --> 00:19:47.440
design and layout and
development, it's so easy to

00:19:47.440 --> 00:19:50.780
add bells and whistles that
really aren't necessary or to

00:19:50.780 --> 00:19:54.810
change the feature image for
each 50 pixel breakpoint as

00:19:54.810 --> 00:19:57.860
the user resizes their browser
window and things like that.

00:19:57.860 --> 00:20:01.720
And you have to really consider
how your users are

00:20:01.720 --> 00:20:05.300
going to work through the site
and whether some of the

00:20:05.300 --> 00:20:08.186
enhancements are really
necessary.

00:20:08.186 --> 00:20:11.870
AMBER WEINBERG: Well, kind
of related to polyfills--

00:20:11.870 --> 00:20:15.740
the newest CSS3 specs and stuff
are getting really,

00:20:15.740 --> 00:20:18.330
really complicated in the
area of responsive

00:20:18.330 --> 00:20:19.800
development and stuff.

00:20:19.800 --> 00:20:22.190
And a user--

00:20:22.190 --> 00:20:23.690
you, George--

00:20:23.690 --> 00:20:27.610
asked, is it OK to continue to
push for more and more CSS

00:20:27.610 --> 00:20:31.130
modules like Regions, Grid
Layout, et cetera?

00:20:31.130 --> 00:20:32.930
Or is it actually
OK to just use

00:20:32.930 --> 00:20:37.010
JavaScript solutions instead?

00:20:37.010 --> 00:20:40.400
I kind of wonder that myself,
because CSS was known to be a

00:20:40.400 --> 00:20:42.030
simple language--

00:20:42.030 --> 00:20:43.640
easy to use, easy to learn.

00:20:43.640 --> 00:20:46.250
And now it's becoming so
much more complicated.

00:20:46.250 --> 00:20:48.820
GEORGE CRAWFORD: That's my point
totally-- that it's not

00:20:48.820 --> 00:20:51.430
that I believe that we should do
these things in JavaScript.

00:20:51.430 --> 00:20:55.760
Of course there are massive
performance gains to be had

00:20:55.760 --> 00:20:59.070
from pushing things to GPUs and
all that kind of stuff.

00:20:59.070 --> 00:21:04.860
But just looking at the average
CSS file now, it's

00:21:04.860 --> 00:21:08.220
already complicated enough.

00:21:08.220 --> 00:21:10.760
A lot of people who have
moved to Sass and other

00:21:10.760 --> 00:21:13.550
preprocessors would agree that
we're pushing the limits of

00:21:13.550 --> 00:21:16.390
what quite a simple syntax
can include.

00:21:16.390 --> 00:21:20.920
And as soon as we get other
modules coming in, it just

00:21:20.920 --> 00:21:21.830
gets more and more complex.

00:21:21.830 --> 00:21:26.230
And maybe the question is-- is
CSS the right language or the

00:21:26.230 --> 00:21:28.523
right technology to
deal with it?

00:21:28.523 --> 00:21:29.470
RAZVAN CALIMAN: OK.

00:21:29.470 --> 00:21:32.890
So first of all, that's
a very good question.

00:21:32.890 --> 00:21:35.960
And I'd like to start
out with Hakim, the

00:21:35.960 --> 00:21:37.590
guy that built Reveal.

00:21:37.590 --> 00:21:41.070
He sent a tweet recently that
we're asking so much more of

00:21:41.070 --> 00:21:43.770
HTML and CSS right now,
considering that it was meant

00:21:43.770 --> 00:21:53.030
as a textiling declarative
markup language.

00:21:53.030 --> 00:21:56.400
In response to your question,
I do think that we need to

00:21:56.400 --> 00:22:00.730
push for more CSS module and
more support in the browser,

00:22:00.730 --> 00:22:04.220
specifically on those areas
where JavaScript isn't really

00:22:04.220 --> 00:22:05.730
supposed to be working at.

00:22:05.730 --> 00:22:08.230
Like in terms of layout,
the browser itself

00:22:08.230 --> 00:22:08.760
is doing the layout.

00:22:08.760 --> 00:22:12.330
So I would much rather leave it
do the layout and focus my

00:22:12.330 --> 00:22:15.080
JavaScript resources, which are
oh-so-scarce, on various

00:22:15.080 --> 00:22:18.550
devices, given the complexity
of web applications, not

00:22:18.550 --> 00:22:21.110
necessarily the complexity
of web design.

00:22:21.110 --> 00:22:23.800
GEORGE CRAWFORD: We realize
that we're sort of almost

00:22:23.800 --> 00:22:26.070
wasting time by trying to
optimize things like

00:22:26.070 --> 00:22:29.680
Columnflow, because it's really,
as you say, a layout

00:22:29.680 --> 00:22:30.900
technology.

00:22:30.900 --> 00:22:36.290
And it feels counter-intuitive
to go over and over and over--

00:22:36.290 --> 00:22:38.210
why isn't JavaScript perfect
for this job?

00:22:38.210 --> 00:22:41.510
It's because it's not designed
for this job.

00:22:41.510 --> 00:22:43.530
RAZVAN CALIMAN: It's not
designed for this job, but the

00:22:43.530 --> 00:22:45.800
reality is that most CSS modules
don't really give you

00:22:45.800 --> 00:22:47.510
the access you need
in JavaScript.

00:22:47.510 --> 00:22:50.820
So up until now, there's
been a pretty much

00:22:50.820 --> 00:22:52.100
all-or-nothing solution.

00:22:52.100 --> 00:22:54.410
Is it all in CSS or
all in JavaScript?

00:22:54.410 --> 00:22:57.820
And I really think that stuff
like CSS Regions--

00:22:57.820 --> 00:23:00.680
it's intended to be a building
block, so it's not going to

00:23:00.680 --> 00:23:02.645
solve your complete
problem in CSS.

00:23:02.645 --> 00:23:05.890
But it gives you access via the
CSS object model, so you

00:23:05.890 --> 00:23:08.390
can understand how your layout
has been rendered and your

00:23:08.390 --> 00:23:09.330
various boxes.

00:23:09.330 --> 00:23:12.770
And I think that's really
where CSS and JavaScript

00:23:12.770 --> 00:23:15.400
should really work together--
in handing, for example,

00:23:15.400 --> 00:23:19.965
layout and event handlers and
content flow differently.

00:23:19.965 --> 00:23:23.950
GEORGE CRAWFORD: I was really
excited to hear, when I looked

00:23:23.950 --> 00:23:28.020
into Regions, that, yeah, you
start off with CSS, but when

00:23:28.020 --> 00:23:31.660
you run out of regions, when you
run out of flowed areas,

00:23:31.660 --> 00:23:34.580
JavaScript gets involved,
right?

00:23:34.580 --> 00:23:36.640
You have events, and you can
create new elements for

00:23:36.640 --> 00:23:37.640
content to flow into.

00:23:37.640 --> 00:23:40.270
And there's an

00:23:40.270 --> 00:23:41.380
interoperability between the two.

00:23:41.380 --> 00:23:42.700
RAZVAN CALIMAN: Yeah.

00:23:42.700 --> 00:23:46.190
And at this point, this is
because CSS Regions is

00:23:46.190 --> 00:23:49.960
supposed to be a building block,
and it doesn't handle

00:23:49.960 --> 00:23:51.340
the complete refill
of the content.

00:23:51.340 --> 00:23:56.280
And you go to use JavaScript to
listen to if your content

00:23:56.280 --> 00:23:58.320
has fit in all of
those regions.

00:23:58.320 --> 00:24:01.910
And that is seen as a limitation
by some people.

00:24:01.910 --> 00:24:04.800
And to some extent they're
right, because you need some

00:24:04.800 --> 00:24:06.380
sort of a method in CSS.

00:24:06.380 --> 00:24:08.580
If you think about layout,
CSS should handle

00:24:08.580 --> 00:24:09.670
the complete layout.

00:24:09.670 --> 00:24:15.210
So right now the spec is
supposed to work really fine

00:24:15.210 --> 00:24:18.480
with other specs like
Grid Layout.

00:24:18.480 --> 00:24:21.750
But it's using empty
developments and it's using

00:24:21.750 --> 00:24:26.500
the JavaScript just because we
don't have any other spec at

00:24:26.500 --> 00:24:27.550
this point that will work.

00:24:27.550 --> 00:24:29.960
What I personally would like
to see is some sort of

00:24:29.960 --> 00:24:32.960
adoption of multiples to do
elements, so you can actually

00:24:32.960 --> 00:24:37.820
define your complete
template in CSS.

00:24:37.820 --> 00:24:42.270
Because basically, that's what
I want from my CSS, right?

00:24:42.270 --> 00:24:45.980
I want it to easily swap out
templates, easily flow out

00:24:45.980 --> 00:24:49.480
content, and leave the markup
to handle just the semantics

00:24:49.480 --> 00:24:52.393
and describing my actual
content, right?

00:24:52.393 --> 00:24:55.580
ANDY HUME: Do you think part
of the complexity at the

00:24:55.580 --> 00:24:59.770
moment is that there are a
number of emerging new CSS

00:24:59.770 --> 00:25:03.230
layout modules, and it's not
necessarily clear until we've

00:25:03.230 --> 00:25:05.470
started playing around with them
and experimenting which

00:25:05.470 --> 00:25:09.360
ones are going to be good for
what type of problems?

00:25:09.360 --> 00:25:15.220
So for example, the Regions
stuff is enabling lots of very

00:25:15.220 --> 00:25:18.200
new kinds of layouts that
haven't been possible at all

00:25:18.200 --> 00:25:21.230
before, really, without things
like Columnflow, too, and

00:25:21.230 --> 00:25:24.010
Exclusions in the certain column
and things like that.

00:25:24.010 --> 00:25:27.720
Whereas Grid seems to me to be
more about helping us do the

00:25:27.720 --> 00:25:32.100
kind of layouts we've been doing
for a while but in a

00:25:32.100 --> 00:25:37.850
simpler way, a way that's more
suited to a real layout system

00:25:37.850 --> 00:25:39.775
rather than sort of hacking
floats and positionings.

00:25:39.775 --> 00:25:40.410
GEORGE CRAWFORD: Sure.

00:25:40.410 --> 00:25:42.980
And something the browser can
optimize as well, the

00:25:42.980 --> 00:25:43.770
performance of it.

00:25:43.770 --> 00:25:45.554
Yeah.

00:25:45.554 --> 00:25:47.070
AMBER WEINBERG: All right.

00:25:47.070 --> 00:25:51.460
So would it be useful to have
native CSS media queries at

00:25:51.460 --> 00:25:53.980
the element component
widget level and

00:25:53.980 --> 00:25:56.300
not just the viewport?

00:25:56.300 --> 00:25:59.630
And that is related
to our other

00:25:59.630 --> 00:26:01.130
question about page weight.

00:26:01.130 --> 00:26:04.050
Would that help?

00:26:04.050 --> 00:26:06.250
ANDY HUME: From my point of
view, that would be a very

00:26:06.250 --> 00:26:08.110
nice thing to be able to do.

00:26:11.580 --> 00:26:14.645
That's not something you can
abstract into a system and

00:26:14.645 --> 00:26:18.100
have work at the moment
for various reasons.

00:26:18.100 --> 00:26:20.150
But it's desirable.

00:26:20.150 --> 00:26:21.840
And maybe there's something
around--

00:26:21.840 --> 00:26:26.000
George mentioned web components
and being able to

00:26:26.000 --> 00:26:29.820
codify behavior for a particular
type of interface

00:26:29.820 --> 00:26:32.430
element and deal with those kind
of exceptions that might

00:26:32.430 --> 00:26:34.545
arise on a sort of case-by-case
basis.

00:26:34.545 --> 00:26:38.210
GEORGE CRAWFORD: I think this
modular idea is really

00:26:38.210 --> 00:26:40.450
interesting, where in the
JavaScript world, we're

00:26:40.450 --> 00:26:43.040
leaning more and more towards
modularized code, which is

00:26:43.040 --> 00:26:46.090
good development practice
anyway.

00:26:46.090 --> 00:26:48.380
The work I mentioned that we
were doing is mostly being

00:26:48.380 --> 00:26:51.920
done by Wilson over there
on the FT's web app.

00:26:51.920 --> 00:26:56.730
And he's sort of almost faking
the shadow DOM and custom

00:26:56.730 --> 00:27:00.920
elements before it's arrived
by using media queries to

00:27:00.920 --> 00:27:05.090
write before and after
pseudo-elements with content

00:27:05.090 --> 00:27:09.200
on individual modules in the
page, and then in JavaScript

00:27:09.200 --> 00:27:12.850
reading those tags.

00:27:12.850 --> 00:27:15.700
So for example, for a certain
module, you might--

00:27:15.700 --> 00:27:19.930
with a before or after
pseudo-element, you might

00:27:19.930 --> 00:27:24.440
write the words "column" or
"row." And then the module now

00:27:24.440 --> 00:27:26.880
knows that it should behave
as a column or a row.

00:27:26.880 --> 00:27:31.580
So that's starting to
fake the media query

00:27:31.580 --> 00:27:32.480
on a modular level.

00:27:32.480 --> 00:27:35.820
And who knows what's
coming up?

00:27:35.820 --> 00:27:41.910
But the problem, of course, is
that we also always need to

00:27:41.910 --> 00:27:44.950
wait for the browsers to catch
up with what we need and that

00:27:44.950 --> 00:27:47.830
the spec writers need to wait
to hear what we want.

00:27:47.830 --> 00:27:51.340
But I think this kind of modular
layout is really

00:27:51.340 --> 00:27:51.750
interesting.

00:27:51.750 --> 00:27:55.780
AMBER WEINBERG: Do you think
that interrupts the idea that

00:27:55.780 --> 00:27:58.740
the content should be exactly
the same on the desktop and

00:27:58.740 --> 00:28:04.470
mobile that we're kind of
following right now, if we are

00:28:04.470 --> 00:28:06.360
able to swap out different
things

00:28:06.360 --> 00:28:08.600
for different viewports?

00:28:08.600 --> 00:28:11.220
GEORGE CRAWFORD: So this is
another question that I put in

00:28:11.220 --> 00:28:15.170
the Moderator is I think we
probably all come up against

00:28:15.170 --> 00:28:20.560
on our mobile devices sites that
are basically truncated

00:28:20.560 --> 00:28:23.470
in terms of their usability
until you get to the bottom of

00:28:23.470 --> 00:28:26.490
the page and you click
the link that says

00:28:26.490 --> 00:28:27.760
View Desktop Site.

00:28:27.760 --> 00:28:30.470
And then you can actually
use some functionality.

00:28:30.470 --> 00:28:33.240
This gets really,
really boring.

00:28:33.240 --> 00:28:37.490
And it's going back to the UI
and the content providers.

00:28:37.490 --> 00:28:42.030
Is designing for mobile simply
cutting out 30% of the useful

00:28:42.030 --> 00:28:42.930
information on the page?

00:28:42.930 --> 00:28:44.145
No, of course it's not.

00:28:44.145 --> 00:28:47.840
ANDY HUME: I think at some point
in the past, there's

00:28:47.840 --> 00:28:50.700
been a desire to try
and second guess

00:28:50.700 --> 00:28:52.865
what people call context.

00:28:52.865 --> 00:28:55.800
Why are you using the sites
on a mobile device?

00:28:55.800 --> 00:28:57.730
Oh, it's because you're walking
down the street and

00:28:57.730 --> 00:28:59.535
you want the phone number
of the restaurant

00:28:59.535 --> 00:29:01.780
you're going to.

00:29:01.780 --> 00:29:05.110
But whether that was ever true
or not is kind of irrelevant,

00:29:05.110 --> 00:29:07.340
because it's certainly
not true now.

00:29:07.340 --> 00:29:12.890
And deriving some kind
of context, I don't

00:29:12.890 --> 00:29:13.650
know how that works.

00:29:13.650 --> 00:29:14.690
I'm not sure that you can.

00:29:14.690 --> 00:29:16.970
GEORGE CRAWFORD: It was
immediately interesting for me

00:29:16.970 --> 00:29:19.430
to hear a proposal that, on
the server, for the first

00:29:19.430 --> 00:29:22.390
request, we might know the
viewport dimensions and not

00:29:22.390 --> 00:29:23.880
have to do user agent
sniffing.

00:29:23.880 --> 00:29:28.010
But actually, as was pointed
out, you can't tell very much

00:29:28.010 --> 00:29:30.230
about a device just from
the viewport dimension.

00:29:30.230 --> 00:29:31.690
You certainly can't tell
the conditions in

00:29:31.690 --> 00:29:32.810
which it's being viewed.

00:29:32.810 --> 00:29:36.590
So you don't know whether they
want a huge word displayed on

00:29:36.590 --> 00:29:38.900
the screen with the answer to
their question, or whether

00:29:38.900 --> 00:29:42.860
they want a 5,000-word article
to read, because you can't

00:29:42.860 --> 00:29:43.870
predict that kind
of information.

00:29:43.870 --> 00:29:45.930
So we need to give
them flexibility.

00:29:45.930 --> 00:29:48.420
But I think having a View
Desktop Site link at the

00:29:48.420 --> 00:29:50.714
bottom of the page is
not the answer.

00:29:50.714 --> 00:29:51.940
RAZVAN CALIMAN: Yeah.

00:29:51.940 --> 00:29:54.360
In terms of using web
components, I'm actually quite

00:29:54.360 --> 00:29:55.250
excited about this.

00:29:55.250 --> 00:29:57.870
Because when you think about
your content, it's not

00:29:57.870 --> 00:30:01.110
necessarily only to give it to
your users in full in mobile

00:30:01.110 --> 00:30:01.910
versus on desktop.

00:30:01.910 --> 00:30:04.560
You also have to think
about the context.

00:30:04.560 --> 00:30:08.440
And if you swap out and you
don't think about content like

00:30:08.440 --> 00:30:11.650
text content, you think about
web application controls,

00:30:11.650 --> 00:30:13.970
they're different on the
interaction mode on a mobile

00:30:13.970 --> 00:30:16.730
device rather than on
a desktop device.

00:30:16.730 --> 00:30:21.640
And to answer the question if
media queries are OK inside of

00:30:21.640 --> 00:30:24.520
web components or small,
isolated elements, I think

00:30:24.520 --> 00:30:28.330
that's really important and
useful, because it gives you

00:30:28.330 --> 00:30:34.881
the flexibility of reusing
most of your elements.

00:30:34.881 --> 00:30:36.940
GEORGE CRAWFORD: It's not just
that they're isolated from

00:30:36.940 --> 00:30:39.640
each other but also that they
can be dropped into other

00:30:39.640 --> 00:30:40.250
projects, right?

00:30:40.250 --> 00:30:41.650
ANDY HUME: Isolated from
the layout from

00:30:41.650 --> 00:30:43.110
the particular page.

00:30:43.110 --> 00:30:45.570
MALE SPEAKER: So this is a great
discussion, but I think

00:30:45.570 --> 00:30:48.150
that media queries
on other elements

00:30:48.150 --> 00:30:50.330
is the wrong approach--

00:30:50.330 --> 00:30:53.510
in part because if you look at
how the browsers today treat

00:30:53.510 --> 00:30:56.770
media queries, they don't work
too well when the page is

00:30:56.770 --> 00:30:57.890
being constructed.

00:30:57.890 --> 00:30:59.800
We don't have access
to the viewport.

00:30:59.800 --> 00:31:01.300
We don't evaluate the rules.

00:31:01.300 --> 00:31:03.510
Like if you look at your rule
right now, if you look at the

00:31:03.510 --> 00:31:06.430
webkit, it says, hey, this looks
complicated in the sense

00:31:06.430 --> 00:31:07.850
that it's not [? screened, ?]

00:31:07.850 --> 00:31:09.095
which means that we're
just going to

00:31:09.095 --> 00:31:10.930
download the resource.

00:31:10.930 --> 00:31:12.700
And this is a fundamental
trade off.

00:31:12.700 --> 00:31:14.950
We don't know the viewport
information when we're

00:31:14.950 --> 00:31:16.190
constructing this page.

00:31:16.190 --> 00:31:17.950
So this is not the
right mechanism.

00:31:17.950 --> 00:31:20.720
Right now, if you declare a
bunch of CSS [INAUDIBLE],

00:31:20.720 --> 00:31:22.620
we'll download them all.

00:31:22.620 --> 00:31:25.230
So having this information
on elements is not the

00:31:25.230 --> 00:31:25.870
right way to do it.

00:31:25.870 --> 00:31:28.520
What we're talking about here
is service-side adaptation.

00:31:28.520 --> 00:31:33.150
So I think the premise that we
need some way to exclude

00:31:33.150 --> 00:31:36.390
certain chunks of functionality
is right.

00:31:36.390 --> 00:31:39.265
I think media queries is
the wrong way to do it.

00:31:39.265 --> 00:31:40.490
ANDY HUME: Yeah.

00:31:40.490 --> 00:31:42.630
I don't think we're necessarily
saying media

00:31:42.630 --> 00:31:44.910
queries is the right
technology.

00:31:44.910 --> 00:31:50.200
In fact, media queries at the
moment, they make us fixate on

00:31:50.200 --> 00:31:50.850
the viewport.

00:31:50.850 --> 00:31:56.660
Because in terms of measuring
the width of something, that's

00:31:56.660 --> 00:31:58.480
the only thing we have.

00:31:58.480 --> 00:32:01.760
And it's actually not
very interesting

00:32:01.760 --> 00:32:02.650
that you can do that.

00:32:02.650 --> 00:32:04.560
You can do some interesting
things with it, and that's why

00:32:04.560 --> 00:32:07.570
responsive design now has
a name and everyone's

00:32:07.570 --> 00:32:08.270
talking about it.

00:32:08.270 --> 00:32:12.160
But I think, yeah, it's more
granular than that.

00:32:12.160 --> 00:32:16.360
The context which you want to
respond to from a layout point

00:32:16.360 --> 00:32:19.480
of view is more granular
than just the viewport.

00:32:19.480 --> 00:32:25.325
And yeah, whatever you guys
think is the right way to let

00:32:25.325 --> 00:32:27.785
us do these kind of things,
I'll go with that.

00:32:27.785 --> 00:32:31.410
AMBER WEINBERG: So are there any
front-end alternatives to

00:32:31.410 --> 00:32:34.940
responsive web design that can
fulfill the promise of being

00:32:34.940 --> 00:32:36.050
device-agnostic?

00:32:36.050 --> 00:32:38.787
Or could there be?

00:32:38.787 --> 00:32:42.000
ANDY HUME: Java.

00:32:42.000 --> 00:32:43.990
RAZVAN CALIMAN: I don't
know what you mean by

00:32:43.990 --> 00:32:44.960
device-agnostic.

00:32:44.960 --> 00:32:48.540
If you look at the web as we
see it right now, yes.

00:32:48.540 --> 00:32:52.550
HTML, CSS, that fulfills the
job of making something

00:32:52.550 --> 00:32:53.170
responsive.

00:32:53.170 --> 00:32:57.650
But if you look only just a bit
ahead of what devices are

00:32:57.650 --> 00:32:59.950
coming and what device-agnostic
means for

00:32:59.950 --> 00:33:01.700
Google Glass, for example--

00:33:01.700 --> 00:33:08.740
does responsive web design work
for your contact lens?

00:33:08.740 --> 00:33:11.530
I think we need to think
about that technology.

00:33:11.530 --> 00:33:15.580
And that's maybe a space where
native will actually win.

00:33:15.580 --> 00:33:18.300
Because the web as we see it
right now, it works really OK

00:33:18.300 --> 00:33:21.070
for one-dimensional,
two-dimensional layout.

00:33:21.070 --> 00:33:24.410
What happens in three
dimensions?

00:33:24.410 --> 00:33:27.000
I don't have a clear-cut
answer to that.

00:33:27.000 --> 00:33:30.500
So whatever we're doing right
now, it's optimized for touch.

00:33:30.500 --> 00:33:36.030
It's optimized for pointing,
different screen sizes.

00:33:36.030 --> 00:33:39.340
But whenever you change the
screen sizing, whenever you

00:33:39.340 --> 00:33:43.410
change the interaction model
from touching to speaking, for

00:33:43.410 --> 00:33:48.510
example, does the web offer
the same flexibility to

00:33:48.510 --> 00:33:50.850
building responsive?

00:33:50.850 --> 00:33:52.115
What do you guys think?

00:33:52.115 --> 00:33:54.840
ANDY HUME: I guess it depends
how you define the

00:33:54.840 --> 00:33:57.120
scope of the web.

00:33:57.120 --> 00:33:59.640
Is it any client technology
ever?

00:33:59.640 --> 00:34:00.750
What defines the web?

00:34:00.750 --> 00:34:02.360
Is it the open nature of it?

00:34:02.360 --> 00:34:05.562
Or is it the--

00:34:05.562 --> 00:34:08.632
GEORGE CRAWFORD: Yeah, I
think you've said it.

00:34:08.632 --> 00:34:12.120
RAZVAN CALIMAN: The
answer is no.

00:34:12.120 --> 00:34:14.810
There isn't a catch-all
technology right now.

00:34:14.810 --> 00:34:15.800
AMBER WEINBERG: Right.

00:34:15.800 --> 00:34:21.429
So should the browser be more
chatty about its environment,

00:34:21.429 --> 00:34:25.420
which we spoke about
in another session?

00:34:25.420 --> 00:34:28.350
Should we know what the
viewport size is, what

00:34:28.350 --> 00:34:32.290
connection it is,
their bandwidth?

00:34:32.290 --> 00:34:34.639
GEORGE CRAWFORD: From the work
I've been doing, step one is

00:34:34.639 --> 00:34:39.810
just, well, give us the right
information and ideally, give

00:34:39.810 --> 00:34:42.449
it in a unified way
across browsers.

00:34:42.449 --> 00:34:45.070
That would really, really
help, right?

00:34:45.070 --> 00:34:50.750
When a device incorrectly just
announces its pixel ratio or

00:34:50.750 --> 00:34:53.179
something like that, it
basically means you either

00:34:53.179 --> 00:34:58.370
added another seven lines of
hack or you have to not query

00:34:58.370 --> 00:34:59.740
that information.

00:34:59.740 --> 00:35:02.900
And I find that more
frustrating, I think, than not

00:35:02.900 --> 00:35:05.040
knowing some things about
the environment.

00:35:05.040 --> 00:35:09.240
I think we've probably covered
network and bandwidth and

00:35:09.240 --> 00:35:09.870
things like that.

00:35:09.870 --> 00:35:17.340
But I think if what we're trying
to do is to provide as

00:35:17.340 --> 00:35:20.840
immersive an experience as
native apps, then yeah, we do

00:35:20.840 --> 00:35:25.250
need to know a lot about
the device that is

00:35:25.250 --> 00:35:26.490
displaying the app.

00:35:26.490 --> 00:35:26.980
But--

00:35:26.980 --> 00:35:28.160
ANDY HUME: Do we need to
know about that on

00:35:28.160 --> 00:35:31.385
the server as well?

00:35:31.385 --> 00:35:33.060
GEORGE CRAWFORD: I think
it would help.

00:35:33.060 --> 00:35:37.830
I think if I'm working really
hard to store as many issues

00:35:37.830 --> 00:35:40.580
of the Economist offline on
someone's device, I know I've

00:35:40.580 --> 00:35:42.900
only got 50 meg and that that's
actually 25, because

00:35:42.900 --> 00:35:45.150
it's all A16-encoded.

00:35:45.150 --> 00:35:50.580
And I would really like to be
able to optimize my images and

00:35:50.580 --> 00:35:55.180
to package things up and
effectively do what a native

00:35:55.180 --> 00:35:57.990
iOS app is going to do, which is
sort of prepare everything

00:35:57.990 --> 00:35:59.470
in advance and ship it.

00:35:59.470 --> 00:36:01.900
And then you can cache the hell
out of that, and you get

00:36:01.900 --> 00:36:04.940
a really, really good
experience.

00:36:04.940 --> 00:36:07.190
You do run into issues where,
if you're running a

00:36:07.190 --> 00:36:09.960
JavaScript-heavy site, you
have to, we've already

00:36:09.960 --> 00:36:11.760
mentioned, like Mustache
templates on

00:36:11.760 --> 00:36:12.710
the server and client.

00:36:12.710 --> 00:36:16.080
You even have to start preparing
articles and

00:36:16.080 --> 00:36:18.810
additions using Node on the
server, because you have to

00:36:18.810 --> 00:36:21.080
use the same logic that you're
using on the client.

00:36:21.080 --> 00:36:24.670
But maybe that's fine.

00:36:24.670 --> 00:36:30.690
I do understand that any changes
to HTTP are enormous.

00:36:30.690 --> 00:36:34.250
And adding one line to a header
is going to massively

00:36:34.250 --> 00:36:35.680
affect web traffic as a whole.

00:36:35.680 --> 00:36:40.490
But I think in return, we can
stop wasting bandwidth by

00:36:40.490 --> 00:36:43.892
delivering totally
useless images.

00:36:43.892 --> 00:36:46.790
ANDY HUME: And people are
still doing user agent

00:36:46.790 --> 00:36:48.755
detection on the server to--

00:36:48.755 --> 00:36:50.160
GEORGE CRAWFORD: Sure,
as was said in an--

00:36:50.160 --> 00:36:51.370
ANDY HUME: [INAUDIBLE] --device
into mobile, tablet,

00:36:51.370 --> 00:36:52.350
or desktop or whatever.

00:36:52.350 --> 00:36:54.550
GEORGE CRAWFORD: As we said in
an earlier session, we're

00:36:54.550 --> 00:36:55.510
doing it already.

00:36:55.510 --> 00:37:00.960
So test to see which approach
is fastest.

00:37:00.960 --> 00:37:04.640
And please, browser vendors,
either don't declare a

00:37:04.640 --> 00:37:07.960
property or declare it correctly
or let us know that

00:37:07.960 --> 00:37:08.410
it's buggy.

00:37:08.410 --> 00:37:11.930
But it really, really makes our
life a lot harder when you

00:37:11.930 --> 00:37:13.180
give the wrong information.

00:37:15.772 --> 00:37:17.860
RAZVAN CALIMAN: Just one
point to add to this.

00:37:17.860 --> 00:37:21.720
It does actually happen on
server-side right now.

00:37:21.720 --> 00:37:24.740
And it's particularly useful for
digital publications when

00:37:24.740 --> 00:37:27.030
you want to target a whole
slew of devices.

00:37:27.030 --> 00:37:30.040
So even though it's not
responsive in the responsive

00:37:30.040 --> 00:37:32.680
sense that it happens on the
client side and it reacts to

00:37:32.680 --> 00:37:36.030
anything, there's a lot of
versions of the same

00:37:36.030 --> 00:37:38.020
publication rendered
server-side.

00:37:38.020 --> 00:37:42.040
And you just go there, and
your device is just the

00:37:42.040 --> 00:37:43.870
terminal, and it receives
the end result.

00:37:43.870 --> 00:37:46.910
And right now that works
pretty fine because

00:37:46.910 --> 00:37:47.730
everything is stored.

00:37:47.730 --> 00:37:49.190
Everything is controlled.

00:37:49.190 --> 00:37:52.090
Ideally, you would want to give
this to the end user,

00:37:52.090 --> 00:37:55.500
because you can't really
simulate all of the user

00:37:55.500 --> 00:37:58.540
agent's font rendering--

00:37:58.540 --> 00:38:01.670
does it have or doesn't it have

00:38:01.670 --> 00:38:03.530
hyphenation, stuff like that.

00:38:03.530 --> 00:38:07.950
So it's happening right now,
and I think we should move

00:38:07.950 --> 00:38:08.880
away from that.

00:38:08.880 --> 00:38:12.660
But we need to wait for browser
vendors to catch up on

00:38:12.660 --> 00:38:16.980
the technologies we actually
need like decent layout, grid

00:38:16.980 --> 00:38:19.880
template, Flexbox, all of that,
because we're actually

00:38:19.880 --> 00:38:21.880
hacking right now with those.

00:38:21.880 --> 00:38:26.640
So up until we get these HTML
and CSS improvements, we're

00:38:26.640 --> 00:38:28.750
going to see a lot more digital
publications which are

00:38:28.750 --> 00:38:30.590
just images at this
point because

00:38:30.590 --> 00:38:31.600
they're simple to render.

00:38:31.600 --> 00:38:35.130
And yes, that's a 700 megabyte
magazine, but it will work

00:38:35.130 --> 00:38:38.045
across all of your devices,
because they're pre-rendered

00:38:38.045 --> 00:38:40.135
for each screen size.

00:38:40.135 --> 00:38:44.440
GEORGE CRAWFORD: But do you
agree in principle that it's

00:38:44.440 --> 00:38:47.730
an advantage if you know at
least a little information

00:38:47.730 --> 00:38:50.660
about the viewport dimensions,
for example, on the server,

00:38:50.660 --> 00:38:54.740
and that you accept that there's
going to be a bit of

00:38:54.740 --> 00:38:56.030
downscaling of images?

00:38:56.030 --> 00:39:02.100
But rather than enormous to
very small, you can ship a

00:39:02.100 --> 00:39:04.380
medium-sized image at the very
least, because you know

00:39:04.380 --> 00:39:06.470
something about the viewport
dimensions on the server?

00:39:06.470 --> 00:39:07.260
RAZVAN CALIMAN: Definitely.

00:39:07.260 --> 00:39:10.350
I agree we need that kind of
information, but you need to

00:39:10.350 --> 00:39:12.490
be responsible in
how you use it.

00:39:12.490 --> 00:39:15.640
For example, we had an
example earlier--

00:39:15.640 --> 00:39:17.850
knowing the bandwidth and the
bandwidth being wrong, you

00:39:17.850 --> 00:39:22.920
might assume something wrong
about the device and give it a

00:39:22.920 --> 00:39:26.900
bad user experience or a very
good user experience.

00:39:26.900 --> 00:39:29.210
But the device cannot
download it.

00:39:29.210 --> 00:39:31.910
So yeah, I do agree you need
that kind of information

00:39:31.910 --> 00:39:33.270
server-side.

00:39:33.270 --> 00:39:36.330
As a developer, you need to use
it and not make too many

00:39:36.330 --> 00:39:37.830
assumptions about the device.

00:39:37.830 --> 00:39:39.240
GEORGE CRAWFORD: It's
interesting, then, Ilya's

00:39:39.240 --> 00:39:42.540
points on media queries that
that's actually responsible

00:39:42.540 --> 00:39:45.050
for so much of what we discuss
when it comes to responsive

00:39:45.050 --> 00:39:45.730
layout, right?

00:39:45.730 --> 00:39:47.740
And the reason we're obsessed
with viewport dimensions is

00:39:47.740 --> 00:39:51.040
because that's the one thing
we have on the client to--

00:39:51.040 --> 00:39:53.370
well, one of the chief
things we have in

00:39:53.370 --> 00:39:55.200
CSS to control behavior.

00:39:55.200 --> 00:39:58.930
So it's got a lot to answer
for in a way.

00:39:58.930 --> 00:40:00.770
AMBER WEINBERG: Well,
let's move on to the

00:40:00.770 --> 00:40:02.760
flip side of the coin.

00:40:02.760 --> 00:40:05.000
With all this new stuff that
we have to take into

00:40:05.000 --> 00:40:08.600
consideration, what about the
arguments that responsive web

00:40:08.600 --> 00:40:12.620
design isn't worth it at all
and that there is merit to

00:40:12.620 --> 00:40:16.050
just having normal
zoom-and-swipe sites?

00:40:16.050 --> 00:40:18.810
Considering that's
originally--

00:40:18.810 --> 00:40:22.510
when Steve Jobs came on stage,
he touted you could have the

00:40:22.510 --> 00:40:24.610
full web on your phone.

00:40:28.578 --> 00:40:34.600
ANDY HUME: I guess people want
to create designs that fit

00:40:34.600 --> 00:40:35.940
that device.

00:40:35.940 --> 00:40:38.520
And if you look at what people
create for the iPhone natively

00:40:38.520 --> 00:40:43.000
and the iPad natively, it's not
double-tap to zoom in on a

00:40:43.000 --> 00:40:44.800
column and swipe around.

00:40:44.800 --> 00:40:47.370
And I think that's what's
driving what we want to do

00:40:47.370 --> 00:40:49.990
with web technology, is the
stuff that's happening native,

00:40:49.990 --> 00:40:52.370
to try and create more engaging

00:40:52.370 --> 00:40:54.560
experiences, to coin a phrase.

00:40:54.560 --> 00:40:56.360
GEORGE CRAWFORD: We've struggled
to define what a web

00:40:56.360 --> 00:40:58.110
app really is sometimes.

00:40:58.110 --> 00:41:02.350
But one possible definition is
to do with how immersive it is

00:41:02.350 --> 00:41:04.150
and whether you feel
your app has been

00:41:04.150 --> 00:41:05.680
designed for your screen.

00:41:05.680 --> 00:41:10.140
And if you see the whole of the
BBC News front page on a

00:41:10.140 --> 00:41:13.300
screen that size, it's
fantastically easy to get to

00:41:13.300 --> 00:41:15.580
the-- if you know the layout of
the page, you don't need to

00:41:15.580 --> 00:41:16.060
read the words.

00:41:16.060 --> 00:41:18.530
You know that the link you're
looking for is in the

00:41:18.530 --> 00:41:19.720
bottom-right of the page.

00:41:19.720 --> 00:41:23.320
It's super quick to get to that
content, but it doesn't

00:41:23.320 --> 00:41:25.500
feel so immersive.

00:41:25.500 --> 00:41:28.360
But then maybe we go too far the
other way that you get a

00:41:28.360 --> 00:41:30.650
beautiful layout with
a full-sized image.

00:41:30.650 --> 00:41:33.560
And you know you can swipe
through 12 images, and it's a

00:41:33.560 --> 00:41:34.790
satisfying experience.

00:41:34.790 --> 00:41:37.580
But where the hell are the
links to find my content?

00:41:37.580 --> 00:41:43.080
And we really have to take
both kinds of directions

00:41:43.080 --> 00:41:44.200
before we find the answer.

00:41:44.200 --> 00:41:48.660
We were talking earlier about
pagination and what the

00:41:48.660 --> 00:41:54.600
solution is for presenting
text-heavy sites and visual

00:41:54.600 --> 00:41:57.290
media-heavy sites in
terms of pages.

00:41:57.290 --> 00:41:58.840
Do we want the content
to scroll?

00:41:58.840 --> 00:42:01.010
Do we want it to be
split into pages?

00:42:01.010 --> 00:42:02.580
And I think this
kind of thing--

00:42:02.580 --> 00:42:04.980
the third option maybe is to
present everything at once and

00:42:04.980 --> 00:42:08.690
then to have a tap-to-zoom
kind of paradigm.

00:42:08.690 --> 00:42:12.820
It really depends
on the content.

00:42:12.820 --> 00:42:17.060
The point I made was, for the FT
and the Economist, I think

00:42:17.060 --> 00:42:18.160
pagination's really useful.

00:42:18.160 --> 00:42:20.770
Because if you are distracted or
look away for some reason,

00:42:20.770 --> 00:42:22.160
everyone knows how
to read a book.

00:42:22.160 --> 00:42:25.380
We all know that if you look
away and you look back to the

00:42:25.380 --> 00:42:27.650
book, you have a rough idea that
you were halfway down the

00:42:27.650 --> 00:42:29.535
right-hand column.

00:42:29.535 --> 00:42:31.910
But when you're looking at a
single-scrolling column of

00:42:31.910 --> 00:42:33.300
text, it's sometimes
very hard.

00:42:33.300 --> 00:42:37.220
And I find that I have to
concentrate more on the

00:42:37.220 --> 00:42:39.660
mechanics of what I'm doing
when I'm scrolling.

00:42:39.660 --> 00:42:42.210
And just to simply tap
or swipe to go to the

00:42:42.210 --> 00:42:43.610
next page is great.

00:42:43.610 --> 00:42:45.890
But then you made the point
that this is not at all

00:42:45.890 --> 00:42:47.450
appropriate for some
other sites.

00:42:47.450 --> 00:42:47.980
RAZVAN CALIMAN: Yeah.

00:42:47.980 --> 00:42:51.210
We need to take into
consideration media-rich

00:42:51.210 --> 00:42:52.690
digital publications.

00:42:52.690 --> 00:42:55.470
And you want to do it in a
paginated responsive view.

00:42:55.470 --> 00:42:58.820
You easily find that you're
going to lose context between

00:42:58.820 --> 00:43:01.820
the text and illustrations or
pictures the text is referring

00:43:01.820 --> 00:43:04.770
to if you want to embrace
responsiveness.

00:43:04.770 --> 00:43:08.800
And cutting off an image
at the middle page is

00:43:08.800 --> 00:43:10.110
not really an option.

00:43:10.110 --> 00:43:12.750
And if you do move the image
or the illustration to a

00:43:12.750 --> 00:43:15.590
different page, you end up with
a lot of white space on

00:43:15.590 --> 00:43:18.060
your pages, which you can't
really control.

00:43:18.060 --> 00:43:20.670
And you have to understand
that a lot of digital

00:43:20.670 --> 00:43:23.640
publications are coming
from print.

00:43:23.640 --> 00:43:26.340
And that's where designers are
used to having a lot of

00:43:26.340 --> 00:43:30.110
control over where content goes,
where text is on the

00:43:30.110 --> 00:43:32.030
same page with the
illustration.

00:43:32.030 --> 00:43:36.130
And the trade off when you take
on responsive web design

00:43:36.130 --> 00:43:39.240
with paginated view is that
you lose a lot of that

00:43:39.240 --> 00:43:41.960
fine-grain control over where
your content is heading.

00:43:41.960 --> 00:43:45.800
So I am actually keen to
understand even more how

00:43:45.800 --> 00:43:50.280
people see pagination as an
advantage on the web when we

00:43:50.280 --> 00:43:53.650
are accustomed to the paradigm
of scrolling or tapping.

00:43:53.650 --> 00:43:58.270
And where it makes sense, for
example, in text-heavy

00:43:58.270 --> 00:44:01.090
articles, like you mentioned,
that's a very valid point.

00:44:01.090 --> 00:44:03.650
But does it make sense
for anything else?

00:44:03.650 --> 00:44:06.610
AMBER WEINBERG: So should
responsive web design, then,

00:44:06.610 --> 00:44:08.270
emulate print?

00:44:08.270 --> 00:44:12.380
On a 27-inch screen, is having
six columns go all the way

00:44:12.380 --> 00:44:16.020
down and all the way across
going to be easy to read?

00:44:16.020 --> 00:44:17.710
RAZVAN CALIMAN: I think
web design should

00:44:17.710 --> 00:44:18.940
emulate a bit of print.

00:44:18.940 --> 00:44:22.870
And that's something the
Exclusions spec is doing.

00:44:22.870 --> 00:44:25.060
And that's something
specifically that should be in

00:44:25.060 --> 00:44:28.640
CSS, because JavaScript is not
really meant to do something

00:44:28.640 --> 00:44:31.290
like that, flowing text inside
of shapes or around shapes.

00:44:31.290 --> 00:44:33.670
GEORGE CRAWFORD: And typography
as well, like the

00:44:33.670 --> 00:44:34.560
hyphenation and stuff.

00:44:34.560 --> 00:44:37.400
It would be great to have good
support for that, right?

00:44:37.400 --> 00:44:41.550
RAZVAN CALIMAN: In terms of
moving the complete idea of

00:44:41.550 --> 00:44:45.860
print to digital, I think
that's the wrong idea.

00:44:45.860 --> 00:44:49.030
You don't really get anything
with six columns of text.

00:44:49.030 --> 00:44:55.280
You don't get more information
out of that page.

00:44:55.280 --> 00:44:57.910
You have to understand that
print has evolved like that

00:44:57.910 --> 00:45:00.530
into multi-column layout and
having multiple articles on

00:45:00.530 --> 00:45:02.750
the same page because of the
physical constraints of the

00:45:02.750 --> 00:45:05.620
page, something we don't
have on the web.

00:45:05.620 --> 00:45:10.930
You can actually use the device
size to your advantage.

00:45:10.930 --> 00:45:14.960
And if you do have a large
screen size, that doesn't mean

00:45:14.960 --> 00:45:16.540
you have to put in more columns

00:45:16.540 --> 00:45:18.660
because you have space.

00:45:18.660 --> 00:45:20.980
There's the point that
George made.

00:45:20.980 --> 00:45:24.700
What's the distance between
the user and the device?

00:45:24.700 --> 00:45:26.550
Are you reading that on a TV?

00:45:26.550 --> 00:45:27.920
Six columns is not
going to help.

00:45:27.920 --> 00:45:31.620
You're going to need larger type
and something optimized

00:45:31.620 --> 00:45:34.680
for your laying back on the
couch and reading the content.

00:45:34.680 --> 00:45:36.890
GEORGE CRAWFORD: Any graphic
designer will draw your

00:45:36.890 --> 00:45:39.670
attention to the whole concept
of white space, that that

00:45:39.670 --> 00:45:40.940
really helps.

00:45:40.940 --> 00:45:43.900
Maybe I was wrong with my slide
going from the white

00:45:43.900 --> 00:45:46.410
gutters on the side to filling
all the available space.

00:45:46.410 --> 00:45:49.010
Because it's quite an assault,
visually, to deal with that

00:45:49.010 --> 00:45:49.410
kind of thing.

00:45:49.410 --> 00:45:51.130
And white space is incredibly
important.

00:45:51.130 --> 00:45:54.730
So for sure, the answer is no,
we don't want to fill a

00:45:54.730 --> 00:45:56.580
27-inch monitor with columns.

00:45:56.580 --> 00:46:00.507
But we need to really learn a
lot from print and then adopt

00:46:00.507 --> 00:46:01.410
it to our own.

00:46:01.410 --> 00:46:04.060
ANDY HUME: Yeah, I think it's
natural that we look at things

00:46:04.060 --> 00:46:07.690
like print or what's been in
the past to kind of inform

00:46:07.690 --> 00:46:09.470
what we're trying to
do in a new medium.

00:46:09.470 --> 00:46:11.740
But the reality is it
is a new medium, and

00:46:11.740 --> 00:46:13.120
it's still quite young.

00:46:13.120 --> 00:46:16.040
And these things, as we learn
by adopting bits of print--

00:46:16.040 --> 00:46:19.560
and some stuff does work,
some stuff doesn't--

00:46:19.560 --> 00:46:21.490
we'll learn more about the
medium that we're actually

00:46:21.490 --> 00:46:22.580
working in.

00:46:22.580 --> 00:46:25.850
That's assuming it doesn't
move so fast that lessons

00:46:25.850 --> 00:46:30.280
we've learned one week aren't
relevant the next, when you

00:46:30.280 --> 00:46:33.800
consider we're now talking about
TVs and the distance

00:46:33.800 --> 00:46:37.740
from the screen and things.

00:46:37.740 --> 00:46:38.440
AMBER WEINBERG: OK.

00:46:38.440 --> 00:46:45.570
So kind of on the same layout
issue, Oliver asked-- current

00:46:45.570 --> 00:46:47.710
responsive web design solutions
to grid systems make

00:46:47.710 --> 00:46:51.140
for very complicated
presentational HTML.

00:46:51.140 --> 00:46:53.630
Defining the same behaviors with
CSS, on the other hand,

00:46:53.630 --> 00:46:54.640
is very tricky.

00:46:54.640 --> 00:46:56.260
So what needs to be
the middleman?

00:46:56.260 --> 00:46:58.160
Is that still JavaScript?

00:46:58.160 --> 00:46:59.920
Or is there going to
be something else?

00:47:04.030 --> 00:47:07.020
ANDY HUME: So I'm not sure
that there is a middleman

00:47:07.020 --> 00:47:08.370
available at the moment.

00:47:11.270 --> 00:47:15.960
I think I understand what he's
saying when he says there's

00:47:15.960 --> 00:47:19.280
lots of presentational
class names in HTML.

00:47:19.280 --> 00:47:25.050
And I think at the current
point in time, that's the

00:47:25.050 --> 00:47:27.605
solution you should
move towards.

00:47:27.605 --> 00:47:33.890
As I said, I find being able to
have a layout system that

00:47:33.890 --> 00:47:36.600
is abstracted from everything
else, a grid system, and then

00:47:36.600 --> 00:47:41.460
implement it in markup easily
is very valuable for all the

00:47:41.460 --> 00:47:42.440
reasons we've talked about--

00:47:42.440 --> 00:47:44.390
making sure components
are extracted

00:47:44.390 --> 00:47:46.580
from layouts and pages.

00:47:46.580 --> 00:47:49.610
And at the moment, the easiest
and simplest, most

00:47:49.610 --> 00:47:52.680
maintainable way of doing that,
in my view, is with more

00:47:52.680 --> 00:47:54.320
presentational class names.

00:47:54.320 --> 00:47:58.090
What we have coming in the
future that I think will help

00:47:58.090 --> 00:47:59.960
this is the Grid
Layout module.

00:48:04.378 --> 00:48:05.515
AMBER WEINBERG: Is that it?

00:48:05.515 --> 00:48:06.850
OK.

00:48:06.850 --> 00:48:09.410
So we just have a couple
of minutes left.

00:48:09.410 --> 00:48:11.310
I have one more question
for you.

00:48:11.310 --> 00:48:16.130
Very quickly, if you could have
one thing, anything in

00:48:16.130 --> 00:48:19.760
responsive web design approved
by the spec or majorly

00:48:19.760 --> 00:48:22.770
implemented in any browsers,
what would your

00:48:22.770 --> 00:48:26.802
dream feature be?

00:48:26.802 --> 00:48:29.200
RAZVAN CALIMAN: Overnight
grid layout templates.

00:48:32.100 --> 00:48:33.930
GEORGE CRAWFORD: I think,
because of my work on

00:48:33.930 --> 00:48:35.670
Columnflow, I think Regions.

00:48:35.670 --> 00:48:39.430
Maybe I'm not so clear on how
they all interlink, but the

00:48:39.430 --> 00:48:43.080
demos I've seen of Regions
just look great.

00:48:43.080 --> 00:48:46.340
I've spent a long time flowing
text into areas.

00:48:46.340 --> 00:48:47.690
And just to have something
that will do that

00:48:47.690 --> 00:48:51.042
for me would be great.

00:48:51.042 --> 00:48:53.690
ANDY HUME: I'm inclined to
agree with grids mainly

00:48:53.690 --> 00:48:57.740
because I get just as excited
about new stuff that's going

00:48:57.740 --> 00:49:03.290
to make my life easier rather
than new, shiny stuff.

00:49:03.290 --> 00:49:09.220
And also media queries at a
component level, however that

00:49:09.220 --> 00:49:10.300
might be implemented.

00:49:10.300 --> 00:49:12.336
And call it media queries.

00:49:12.336 --> 00:49:15.550
AMBER WEINBERG: Well, I would
like something for retina,

00:49:15.550 --> 00:49:17.850
something easy.

00:49:17.850 --> 00:49:18.220
All right.

00:49:18.220 --> 00:49:20.610
Well, that is it for the
responsive panel.

00:49:20.610 --> 00:49:21.880
And thank you, guys.

00:49:21.880 --> 00:49:28.113
[APPLAUSE]

