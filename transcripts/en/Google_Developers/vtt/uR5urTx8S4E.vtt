WEBVTT
Kind: captions
Language: en

00:00:02.200 --> 00:00:06.200
&gt;&gt;Ilya Grogorik: Hi everyone. My name is Ilya
Grigorik. I'm a developer advocate with the

00:00:06.200 --> 00:00:12.269
make the web fast team at Google. One of the
projects we have is the PageSpeed family of

00:00:12.269 --> 00:00:16.820
products that can help you both automate web
performance and also give you insights about

00:00:16.820 --> 00:00:21.360
what are the kinds of things you can do to
improve the performance of your applications.

00:00:21.360 --> 00:00:27.190
So first of all, why do we need this? Why
does web performance matter? It is more to

00:00:27.190 --> 00:00:32.160
start at the beginning, motivate the use case.
First of all, as you saw during the keynote.

00:00:32.160 --> 00:00:35.570
The web of today, the things we are building
on the web are much more ambitious and more

00:00:35.570 --> 00:00:42.410
powerful and more complex, in many ways, and
speed is a feature. We are increasingly hearing

00:00:42.410 --> 00:00:48.290
this from our partners that are connecting
performance to bottom line things like revenue

00:00:48.290 --> 00:00:54.310
and engagement -- user engagement and other
things. This is not just something that we

00:00:54.310 --> 00:00:59.400
feel is getting more complex. In fact, we
can show this. There's a great project called

00:00:59.400 --> 00:01:05.180
HP archive which crawls the web and gathers
statistics about how the web is constructed

00:01:05.180 --> 00:01:08.939
and how it is changing over time. And what
this graph shows you very clearly is that

00:01:08.939 --> 00:01:13.250
the complexity of our pages, the amount of
HTML, JavaScript, the markup we are putting

00:01:13.250 --> 00:01:18.840
on our pages is growing very, very fast. If
anything, if you look at this number here,

00:01:18.840 --> 00:01:23.700
an average page on the web today is over one
megabyte in size for desktop size and 700

00:01:23.700 --> 00:01:29.490
kilobytes in mobile, which is very large.
Most of that is actually images. So if nothing

00:01:29.490 --> 00:01:34.439
else, this is a real interesting insight to
say you should optimize your images or 60%

00:01:34.439 --> 00:01:39.119
of all the bytes are images. That's the first
constant. The web is getting -- we are building

00:01:39.119 --> 00:01:43.289
more ambitious applications and they are more
complex. The other interesting thing is that

00:01:43.289 --> 00:01:50.619
despite the ever-increasing speed of and demand
from users for performance and other things,

00:01:50.619 --> 00:01:54.970
an accelerating pace of life, or so it seems,
there are some pretty good constants. There's

00:01:54.970 --> 00:01:59.090
good research that shows in order to feel
instant, an interaction needs to be acknowledged

00:01:59.090 --> 00:02:04.369
back to the user within basically a couple
hundred milliseconds. If you respond within

00:02:04.369 --> 00:02:09.020
200 milliseconds, it feels nearly instant.
Then there is that kind of gray zone around

00:02:09.020 --> 00:02:14.900
one second where the user is still engaged
in the task when they click the button but

00:02:14.900 --> 00:02:20.020
after you cross that one-second threshold,
you lose the context as a user. So all of

00:02:20.020 --> 00:02:23.599
the sudden your context switch, oh, yeah,
I have to send an email to Bob, and follow

00:02:23.599 --> 00:02:31.019
up with Jamie. Before you know it, you lost
track of your user, right? And if you go anywhere

00:02:31.019 --> 00:02:37.030
above that, basically the user gets disengaged.
The goal for us is to render pages within

00:02:37.030 --> 00:02:41.849
one second and preferably actually much faster,
right? We want a seamless experience for our

00:02:41.849 --> 00:02:46.430
easers. That's something we care a lot about
at Google. This is great, right? We have this

00:02:46.430 --> 00:02:52.720
research, but you might be something at this
point, that's great and all, but really does

00:02:52.720 --> 00:02:57.719
it matter? Does it affect my site? The answer
is yes, it does. There are a number of case

00:02:57.719 --> 00:03:02.280
studies out there. This was a case study done.
This was a joint research project between

00:03:02.280 --> 00:03:07.000
Google and Bing. What we had done is we actually
slowed down -- intentionally slowed down our

00:03:07.000 --> 00:03:11.870
search pages. The results that you are seeing
here are actually from Bing.com where they

00:03:11.870 --> 00:03:16.909
added extra latency into their search pages.
They just measured, how does that impact the

00:03:16.909 --> 00:03:23.089
use behavior on the site. Do they click more
or less and other things, right? What you

00:03:23.089 --> 00:03:27.219
can see is basically there's a lot of red.
There's a lot of negative signs, and when

00:03:27.219 --> 00:03:34.480
the add 2,000 milliseconds, two seconds, the
per-user dropped by 4.3%, which is, of course,

00:03:34.480 --> 00:03:39.690
a huge number for a big site like Bing and
Google search. Now, this is not only applicable

00:03:39.690 --> 00:03:43.640
to large sites, like search sites, but also
across the web in general. This is a great

00:03:43.640 --> 00:03:49.280
case study done by [indiscernible] which looked
at 160 large e-commerce sites. What they found

00:03:49.280 --> 00:03:57.380
was that adding one second of extra delay
decreased the user conversions. 7%. Fewer

00:03:57.380 --> 00:04:04.249
page views and obviously the customer satisfaction
also dropped quite dramatically. So very quickly

00:04:04.249 --> 00:04:08.269
this translates into real dollar. This is
not just dollars and cents, this is millions

00:04:08.269 --> 00:04:14.520
of dollars for many large sites. And I think
you'll find this is true for your site as

00:04:14.520 --> 00:04:18.531
well. So out of that, of course, we have the
web performance optimization industry, or

00:04:18.531 --> 00:04:24.020
WPO industry if you have been following the
space. The basic premise of the WPO industry

00:04:24.020 --> 00:04:31.120
is we have this waterfall graph. We are using
a lot of requests, 86 requests an average,

00:04:31.120 --> 00:04:36.750
for an average page, over one megabyte. What
can we do to this waterfall graph to make

00:04:36.750 --> 00:04:41.000
everything look faster? Can we download less?
Can we execute the code faster? You heard

00:04:41.000 --> 00:04:44.940
about the great improvements that we are doing
in JavaScript space and rendering performance

00:04:44.940 --> 00:04:50.940
in Chrome. What else can we do as app developers?
The platform can advance, but we can do a

00:04:50.940 --> 00:04:58.280
lot of things as developers to optimize this.
Of course, there are a lot of best practices

00:04:58.280 --> 00:05:03.160
out there, a lot of good tips about how to
optimize this kind of thing. Great books by

00:05:03.160 --> 00:05:07.750
Steve Seibers and others. We have techniques
that I think many of us already do in our

00:05:07.750 --> 00:05:13.170
applications and things like image compression
resizing, minimizing assets, caching. The

00:05:13.170 --> 00:05:18.660
laundry list goes on and on and on and the
question at this point, of course, great.

00:05:18.660 --> 00:05:23.720
We have the industry. We have all the best
practices, so why isn't it that all the web

00:05:23.720 --> 00:05:29.340
sites are fast by default? I think the answer
here is that a lot of these practices around

00:05:29.340 --> 00:05:34.000
performance can actually slow you down in
other ways. For example, doing things like

00:05:34.000 --> 00:05:38.390
image spreading means that you need to talk
to your designers and get them think about

00:05:38.390 --> 00:05:45.980
image formats and invest in build tool chain
and a lot of these things, frankly, are hacked.

00:05:45.980 --> 00:05:52.920
They slow us down. We want to build features,
we want to focus on features in our apps.

00:05:52.920 --> 00:05:57.460
Not necessarily think about minute details
of should I concatenate these back and forth.

00:05:57.460 --> 00:06:03.800
It's a trade-off,right. It's a feature. It's
a feature that requires a lot of investment.

00:06:03.800 --> 00:06:10.690
It is not something you add at the end. You
don't build your app and at the end say, yeah,

00:06:10.690 --> 00:06:14.840
we're going to do a performance print to clean
it up, right? That's how you get it wrong.

00:06:14.840 --> 00:06:18.700
It needs to be part of your culture. It needs
to be part of the tool chain. So it's a continuous

00:06:18.700 --> 00:06:24.540
process. So that's what PageSpeed is all about.
We do three things. PageSpeed tries to help

00:06:24.540 --> 00:06:28.880
you identify what are the potential performance
problems currently on your site? Think of

00:06:28.880 --> 00:06:34.720
it as a performance Linter for your application.
Second one is just explaining and providing

00:06:34.720 --> 00:06:39.680
guidance for how do you address these problems.
The last one, which I think is the most exciting,

00:06:39.680 --> 00:06:45.390
is the automation part. We can actually take
a way a lot of the day-to-day work that you

00:06:45.390 --> 00:06:51.900
have to do and do it for you, which is great.
So the rest of this talk is split into two

00:06:51.900 --> 00:06:56.860
parts. First we will look at the analysis
and then the optimization parts.

00:06:56.860 --> 00:07:02.120
On the analysis part, we have a number of
different options that you should play with.

00:07:02.120 --> 00:07:05.800
And each one is good in a different context.
We will cover each. And then there's a number

00:07:05.800 --> 00:07:10.190
of optimization products. So we have a plug-ins
for your servers that you can install that

00:07:10.190 --> 00:07:15.330
will automate a lot of these best practices.
Let's dive in. Let's start with the analysis

00:07:15.330 --> 00:07:20.550
part and look at PageSpeed Insights. PageSpeed
Insights is an extension that you can install

00:07:20.550 --> 00:07:25.030
in Google Chrome. Go need to go to the Chrome
store, search for PageSpeed Insights. You

00:07:25.030 --> 00:07:30.490
will get a new panel in your DevTools that
will give you a lot of nice performance tips.

00:07:30.490 --> 00:07:36.390
Let's actually do a live demo. I was getting
a little hungry earlier today. Looking at

00:07:36.390 --> 00:07:43.830
redrobin.com, beautiful site, beautiful images.
Nice little gallery here. Let's open up DevTools.

00:07:43.830 --> 00:07:50.840
I have the PageSpeed insights extension installed.
I should click here. I can click analyze.

00:07:50.840 --> 00:07:54.710
What it will do, it will reload the page.
It will basically monitor all the network

00:07:54.710 --> 00:08:00.240
traffic, all of the assets that you're specifying
on the page and run a number different rules

00:08:00.240 --> 00:08:05.770
against them and checks against them. So you
can see, great, here's our report. This page

00:08:05.770 --> 00:08:11.260
got a score of 49 out of 100. That immediately
tells me there's room for improvement. The

00:08:11.260 --> 00:08:14.820
real interesting stuff is actually here on
the left. So if you pay attention here, right,

00:08:14.820 --> 00:08:20.170
we basically prioritize a lot of recommendations
on the left saying there's some high priority

00:08:20.170 --> 00:08:24.650
things you can take care of right now to help
optimize your page and then there's other

00:08:24.650 --> 00:08:30.310
stuff. Let's start at the top. Optimize images.
It turns out this Red Robin page is actually

00:08:30.310 --> 00:08:36.460
about 10 megabytes in size every time you
load it. So -- and we will come back to why

00:08:36.460 --> 00:08:42.200
"every time you load it." By optimizing images,
it turns out that red Robin is actually using

00:08:42.200 --> 00:08:48.550
PNG images for the beautiful gallery. By just
converting that to a jpeg or a webp, as you

00:08:48.550 --> 00:08:53.990
heard during the keynote, we can save 50%
of the bytes sent for this page. We can reduce

00:08:53.990 --> 00:08:59.150
the total size of the page is 4.7 megabytes.
This is a huge amount. Think of the difference

00:08:59.150 --> 00:09:05.070
this will make both in speed on desktop and
on mobile. One cool little tip that I like

00:09:05.070 --> 00:09:10.230
to share PageSpeed insights, how do we know
that we can save all this data? What PageSpeed

00:09:10.230 --> 00:09:15.451
insights does is it takes the images and actually
optimizes it when you run the analysis. It

00:09:15.451 --> 00:09:19.890
can give you the optimized assets. So you
have this original picture here, right? We

00:09:19.890 --> 00:09:27.100
can click on this guy. If I can go back, I
click on see optimize content. This is the

00:09:27.100 --> 00:09:33.940
optimized version. Can you guys see the difference
between the two? It's a lot smaller. Right?

00:09:33.940 --> 00:09:38.780
It's about 1.5 megabytes smaller. Right there
and then, you can right click on that image

00:09:38.780 --> 00:09:43.820
and save it into your application and be done
with it. Right? Step number one, optimizing

00:09:43.820 --> 00:09:47.870
images. Then you continue going down the list.
Things like browser caching. So it turns out

00:09:47.870 --> 00:09:53.730
we analyzed all of the assets. This site is
not specifying cache control headers. Every

00:09:53.730 --> 00:09:58.260
time you visit the page, you have refetch
all of the CSS, JavaScript and the images.

00:09:58.260 --> 00:10:03.691
Instead we should be able to cache on a client.
So very simple thing to fix. If you are not

00:10:03.691 --> 00:10:07.450
sure what this actually means or how to do
this, click on learn more, it will take you

00:10:07.450 --> 00:10:12.450
to the documentation slide to explain that.
Enabling compression, so it turns out -- we

00:10:12.450 --> 00:10:17.460
talked about images compression. But for text-based
assets, things like JavaScript and CSS, the

00:10:17.460 --> 00:10:23.580
site also doesn't have JSUP enabled. There's
a lot of savings we can get here. We also

00:10:23.580 --> 00:10:28.640
found that there's a lot of small images.
You can put this into a Sprite. You can minimize

00:10:28.640 --> 00:10:32.210
JavaScript to get more performance. You can
see how just going through this list, this

00:10:32.210 --> 00:10:37.280
is your performance Linter. You can run this
against any web site, your own site, locally

00:10:37.280 --> 00:10:41.940
or elsewhere.
So really, really nice tool. This is effectively

00:10:41.940 --> 00:10:46.430
when we just went through. That's the PageSpeed
extension. You can install it, run it against

00:10:46.430 --> 00:10:51.650
any app locally or remote. That's great. We
also provide the web tools. If you are just

00:10:51.650 --> 00:10:58.080
curious to play with it, you can go to our
developers.google.com/speed site. You can

00:10:58.080 --> 00:11:02.480
type in any website and we will run all the
same rules against that site and give you

00:11:02.480 --> 00:11:07.170
a report card. As you can see here, it all
looks the same. All the same high priority

00:11:07.170 --> 00:11:11.450
recommendations. That's because it's the same
code running under the hood. But great way

00:11:11.450 --> 00:11:17.130
to capture this. I can send this to my buddies
and say, hey, we've got a performance problem.

00:11:17.130 --> 00:11:23.890
We have to address it. If nothing else, a
great way to play with it.

00:11:23.890 --> 00:11:28.600
And finally we also have the PageSpeed insights
API. This is great if you really want to take

00:11:28.600 --> 00:11:33.650
it to the next level. So now you have some
built infrastructure, you're checking in code,

00:11:33.650 --> 00:11:38.090
you have continues builds kicking off every
time you check in code. You can actually script

00:11:38.090 --> 00:11:42.690
this and use our PageSpeed rule engine to
run a number of checks against your code or

00:11:42.690 --> 00:11:46.780
against your site periodically and basically
build a performance report. We have things

00:11:46.780 --> 00:11:51.020
like -- you can specify strategy. So you can
say, I want to evaluate the rules against

00:11:51.020 --> 00:11:55.650
desktop site and mobile site. We have slightly
different rule sets for mobile, for obvious

00:11:55.650 --> 00:12:00.650
reasons, right? It's a very different environment.
I want to check for a specific type of rule.

00:12:00.650 --> 00:12:04.640
For example, I want to make sure all the images
optimized. There's a lot of fine grain control.

00:12:04.640 --> 00:12:08.910
And a lot of tools are integrating or using
PageSpeed Insights API to pull in that extra

00:12:08.910 --> 00:12:14.330
meta data. This is a regular Google API. There's
no extra quirks to it. This is just a quick

00:12:14.330 --> 00:12:20.880
example in ruby. Really, really handy. So
that's a very quickly an overview of what

00:12:20.880 --> 00:12:26.420
you can do by just leveraging PageSpeed to
find performance problems, right? PageSpeed

00:12:26.420 --> 00:12:33.420
insights gives you that hands on look. You
can use the web or the native version. And

00:12:33.420 --> 00:12:37.750
then you can use the API to script this stuff
and automate a lot of this work.

00:12:37.750 --> 00:12:44.670
Now, we built a rule engine that can scan
your pages. It can track what things you should

00:12:44.670 --> 00:12:49.440
do. Can't we just do it for you? Like we have
already given you all of this practices. Giving

00:12:49.440 --> 00:12:53.251
you the images. Let's go one step further,
right? That's what PageSpeed Optimization

00:12:53.251 --> 00:12:58.400
is all about. So we have this core project,
an open source project that can be leveraged

00:12:58.400 --> 00:13:03.480
as part of any web server called PageSpeed
Optimization Libraries. It's basically a set

00:13:03.480 --> 00:13:09.589
of C++ classes that takes in some input, say
a style sheet or an image file or something

00:13:09.589 --> 00:13:16.200
else, and then optimizes that based on a number
of criteria. So how does this actually look?

00:13:16.200 --> 00:13:23.550
The way I think about PageSpeed Optimization
is as a performance jit for your site. Just

00:13:23.550 --> 00:13:29.060
like V8 takes your JavaScript and does all
kinds of crazy optimizations to make it run

00:13:29.060 --> 00:13:35.020
fast, that's what we do on the server except
we are rewriting and optimizing your JavaScript

00:13:35.020 --> 00:13:41.470
CSS images and html. All of that is automated
for you. So you don't have to change your

00:13:41.470 --> 00:13:46.610
application. I think that's the real exciting
part. We have a ton of sites, over 400,000

00:13:46.610 --> 00:13:52.040
sites using PageSpeed today already and there
is a lot of different filters that will do

00:13:52.040 --> 00:13:57.950
this work. So let's take a look at what it
actually does. At a very high level, I have

00:13:57.950 --> 00:14:02.670
intentionally made these graphs really, really
tiny. The point is not to focus on what are

00:14:02.670 --> 00:14:07.170
each of the assets. But basically, once you
turn on PageSpeed this is hopefully what you

00:14:07.170 --> 00:14:12.340
see. We try to reduce the number of requests
by concatenating files and applying all the

00:14:12.340 --> 00:14:27.089
best practices. It's a better experience for
the user.

00:14:27.089 --> 00:14:30.270
So once again, the cool thing about this is
you don't have to modify your application.

00:14:30.270 --> 00:14:34.190
We are not talking about adding more build
steps. This is not something that you run

00:14:34.190 --> 00:14:39.360
on a check-in and it mangles your code and
rewrites your code. You don't have to bug

00:14:39.360 --> 00:14:44.380
your designer buddies to say, hey, you should
pay attention to image compression because

00:14:44.380 --> 00:14:50.460
all this is done on the server. This is especially
awesome for things like user-generated content.

00:14:50.460 --> 00:14:54.180
It's one thing for us as developers to build
really optimized sites. Then we hand over

00:14:54.180 --> 00:15:00.810
the keys to our awesome, fast-performing sites
to our users. They grab their awesome 50 megapixel

00:15:00.810 --> 00:15:06.050
or something camera, snap a couple photos
of kittens, throw up the 80 MEG version on

00:15:06.050 --> 00:15:10.310
the web, there you are, right, downloading
these high res images. We can automate that

00:15:10.310 --> 00:15:13.899
for you.
So here's an example, right?

00:15:13.899 --> 00:15:17.940
This is all really abstract. Let's take a
look at a real example. Let's say you have

00:15:17.940 --> 00:15:22.560
some code like the one at the top here. So
we have four different style sheets: yellow,

00:15:22.560 --> 00:15:26.680
blue, big, and bold. So we know that one of
the best practices is we want to concatenate

00:15:26.680 --> 00:15:32.250
files to reduce the number of requests, such
that it downloads faster.

00:15:32.250 --> 00:15:37.520
What PageSpeed will do is it will actually
look at the HTML when the server is serving

00:15:37.520 --> 00:15:43.140
that HTML and it will actually rewrite all
of those into this command at the bottom.

00:15:43.140 --> 00:15:47.940
And basically this is like a -- this tells
us the exact thing that we need to do to reconstruct

00:15:47.940 --> 00:15:51.740
the entire asset, right? You can kind of decipher
it. It basically says "I want you to combine

00:15:51.740 --> 00:15:56.470
yellow with blue with big with bold." Dot
PageSpeed is just our extension that says

00:15:56.470 --> 00:16:01.870
to our module that "Hey, you should intercept
it in the future." "cc" stands for combined

00:16:01.870 --> 00:16:08.390
CSS. And then we provide a fingerprint. And
the fingerprint is important, because when

00:16:08.390 --> 00:16:13.041
you change later the contents of any one of
these files and say blue.CSS, you don't want

00:16:13.041 --> 00:16:17.980
to think about like do I need to revalidate
the cache, how does this even work with PageSpeed.

00:16:17.980 --> 00:16:21.460
We do all of that for you. We fingerprint
each file such that the moment you change

00:16:21.460 --> 00:16:26.540
it we automatically rev the version of the
file. You don't need to think about that.

00:16:26.540 --> 00:16:29.520
There's no extra build steps there.
And the other cool thing is because we're

00:16:29.520 --> 00:16:35.500
fingerprinting this entire file, we can cache-extend
it for a year, right? This plays really, really

00:16:35.500 --> 00:16:41.070
nicely with CDNs and all of your caches that
you're running. Squid, Varnish, and other

00:16:41.070 --> 00:16:44.630
things.
So that's kind of a cute example with CSS.

00:16:44.630 --> 00:16:48.840
I think a more interesting one is images,
because images as we said is 60% of the bytes,

00:16:48.840 --> 00:16:52.470
so what can we do there?
Well, let's take a look at this example. We

00:16:52.470 --> 00:16:57.680
have an image which is an awesome cat image
and we want to display it at 800 pixels wide,

00:16:57.680 --> 00:17:01.399
right?
Now, this is a PNG file and we know that PNGs

00:17:01.399 --> 00:17:05.620
are not good for photos, right? They're not
the most efficient format for serving photos,

00:17:05.620 --> 00:17:10.199
so that's already kind of a tipoff. Well,
what PageSpeed will do is it will in the background

00:17:10.199 --> 00:17:15.309
take this PNG file which is right now 350
kilobytes and it will try to recompress it

00:17:15.309 --> 00:17:20.720
using other codecs. So JPEG and WebP. And
it will kind of stash those in the background,

00:17:20.720 --> 00:17:25.350
right? So think of it as a background thread
just optimizing these images for you. We haven't

00:17:25.350 --> 00:17:29.110
done anything yet.
Then a request comes to a server, and PageSpeed

00:17:29.110 --> 00:17:35.520
will actually run a user agent check to say,
"Okay, this is a Chrome browser. Chrome understands

00:17:35.520 --> 00:17:43.249
WebP, which means I can serve it a WebP file,"
versus, "Hey, this is an IE user coming, you

00:17:43.249 --> 00:17:48.649
know, an older client coming to my site. They
don't understand WebP so I'll serve a JPEG,"

00:17:48.649 --> 00:17:50.330
right?
And all of that is completely transparent

00:17:50.330 --> 00:17:54.230
to the user and to your application. This
is done by the server.

00:17:54.230 --> 00:17:59.379
Then the next thing that we do is we're actually
much smarter than that. We look at the markup

00:17:59.379 --> 00:18:04.320
and we notice that you said you want this
image to be 800 pixels wide, right?

00:18:04.320 --> 00:18:08.029
We look at the image that's actually on disk
that you've given us and we say is it 800

00:18:08.029 --> 00:18:12.470
pixels wide or are you shipping the -- you
know, the large image and resizing it on the

00:18:12.470 --> 00:18:14.679
client?
Well, turns out because this is an awesome

00:18:14.679 --> 00:18:19.790
cat picture, he's 8,000 pixels wide, right?
So you would ship the large version, resize

00:18:19.790 --> 00:18:24.529
it on the client. Instead, we will resize
it on the server and serve the right image.

00:18:24.529 --> 00:18:29.289
So in the end, what PageSpeed will put in
your markup is kind of this cryptic URL at

00:18:29.289 --> 00:18:33.119
the bottom which actually is not that cryptic
once you understand what it does. It's encoding

00:18:33.119 --> 00:18:39.580
the size of the image, the name.PageSpeed.image
conversion and once again that half. So if

00:18:39.580 --> 00:18:42.139
you change your version, we'll just run the
version.

00:18:42.139 --> 00:18:47.999
And this basically automates the entire workflow.
We went from PNG to serving a dynamic WebP

00:18:47.999 --> 00:18:53.330
file, right? From 350 kilobytes to 60 kilobytes.
And your application hasn't changed. Which

00:18:53.330 --> 00:18:57.779
I think is the best part.
So those are just two examples. We have over

00:18:57.779 --> 00:19:02.389
40 different optimization filters as part
of PageSpeed. We can do things like rewriting

00:19:02.389 --> 00:19:06.820
JavaScript, combining JavaScript. We can defer
JavaScript. So we find that a lot of pages

00:19:06.820 --> 00:19:12.739
have blocking, CSS, and JavaScript files which
are blocking rendering. For example, social

00:19:12.739 --> 00:19:16.850
widgets and all the rest. Which we can safely
defer until later such that the page paints

00:19:16.850 --> 00:19:21.809
and then we add the extra functionality, things
like social widgets and other things.

00:19:21.809 --> 00:19:26.290
Simple things -- or actually they're not simple.
Things like lazy loading of images, right?

00:19:26.290 --> 00:19:29.059
How many people here have tried doing lazy
loading of images.

00:19:29.059 --> 00:19:30.880
[ Show of hands ]
&gt;&gt;Ilya Grigorik: Right? It's a pain in the

00:19:30.880 --> 00:19:36.210
butt, right? It's like which library do I
use and how do I detect the unscroll event?

00:19:36.210 --> 00:19:39.739
When do I know it's in my viewport? We take
care of all of that, right? You basically

00:19:39.739 --> 00:19:45.960
set one command line flag in your config and
we just do all of that work for you.

00:19:45.960 --> 00:19:51.190
So one thing to note is, of course, you know,
this doesn't come for free, necessarily, so

00:19:51.190 --> 00:19:56.320
this runs on your server, and it does consume
some extra cycles. But all the optimizations

00:19:56.320 --> 00:20:01.309
are done on demand. So for example, you come
and visit my gallery page. We will optimize

00:20:01.309 --> 00:20:05.480
the images in the background. Our goal is
to make your site fast and sometimes optimizing

00:20:05.480 --> 00:20:09.990
images may take a while, right? Like it may
take a couple hundred milliseconds. We're

00:20:09.990 --> 00:20:15.320
not going to slow down your site. On the first
hit, we may actually serve the original image

00:20:15.320 --> 00:20:19.609
because we don't want to block the client,
but on a subsequent visit, we will serve the

00:20:19.609 --> 00:20:23.539
optimized assets and you guys will see this
in a second.

00:20:23.539 --> 00:20:27.620
So the very cool thing about PageSpeed is,
of course, it's an open source project and

00:20:27.620 --> 00:20:31.919
we have modules for Apache, Nginx, and we
have a Google hosted version which means that

00:20:31.919 --> 00:20:37.019
we've had a lot of partners that have adopted
PageSpeed. And for example, DreamHost, GoDaddy,

00:20:37.019 --> 00:20:41.789
and a number of other hosting providers basically
offer it as a toggle button for your Web site,

00:20:41.789 --> 00:20:43.850
right?
You literally go into the control panel and,

00:20:43.850 --> 00:20:48.179
just like it says, make my site fast. And
that's what it does. It enables PageSpeed

00:20:48.179 --> 00:20:51.850
under the hood.
We have CDNs, large CDNs that are deploying

00:20:51.850 --> 00:20:55.690
this technology at the edge, such that they
can revalidate your assets on the fly for

00:20:55.690 --> 00:20:59.809
you. And of course we're DogFooding it at
Google as well.

00:20:59.809 --> 00:21:05.989
Earlier today at the keynote, you guys saw
Linus talk about Chrome data compression,

00:21:05.989 --> 00:21:10.440
so the way that works is your phone connects
to a Google server when you send the request,

00:21:10.440 --> 00:21:15.120
and then it's the Google servers that fetch
the content that you requested, we optimize

00:21:15.120 --> 00:21:19.539
it, and serve you the optimized version, right?
Which gives us a huge savings in data compression

00:21:19.539 --> 00:21:22.669
and other things.
And the core of that is actually powered by

00:21:22.669 --> 00:21:26.320
a lot of the PageSpeed logic that we've been
just talking about here, so we're reusing

00:21:26.320 --> 00:21:30.190
that same technology to drive Chrome data
compression.

00:21:30.190 --> 00:21:37.080
And 50% data compression is a huge win for
a lot of users. Bytes are literally expensive

00:21:37.080 --> 00:21:42.120
for a lot of people, right?
You can be charged as high as a dollar per

00:21:42.120 --> 00:21:45.970
megabyte when you're roaming, so this stuff
adds up really quickly.

00:21:45.970 --> 00:21:50.009
So if you guys haven't tried it yet, I'd definitely
encourage you to. Go and download Chrome beta

00:21:50.009 --> 00:21:53.950
from the apps store and go into your settings
and enable this and I think you'll notice

00:21:53.950 --> 00:21:59.269
that your pages load much, much faster.
Which is yet more motivation to -- for why

00:21:59.269 --> 00:22:04.460
you need to optimize your pages.
This is a great case study. AOL is rolling

00:22:04.460 --> 00:22:11.201
out mod_pagespeed which is our Apache plug-in
for PageSpeed, and they're deploying it on

00:22:11.201 --> 00:22:15.190
a number of sites. These are the two most
recent ones, both very high traffic sites.

00:22:15.190 --> 00:22:20.289
They enabled PageSpeed and they immediately
got 40% and 20% Page Load Time improvement

00:22:20.289 --> 00:22:24.530
by just enabling PageSpeed, right? So no applications
changes. Everything is done by the Apache

00:22:24.530 --> 00:22:30.100
server. Nice win.
We've been working with ZippyKid, which is

00:22:30.100 --> 00:22:34.830
a great hosting provider for Wordpress and
really focused on performance. We ran a number

00:22:34.830 --> 00:22:40.270
of tests, so they're actually using the Nginx
plugin for their servers, and they found that,

00:22:40.270 --> 00:22:45.299
you know, they're getting a speedup of over
50% and a huge reduction in savings.

00:22:45.299 --> 00:22:49.899
So it turns out that Wordpress sites are very
media heavy. Surprise, right? Like that's

00:22:49.899 --> 00:22:53.739
-- that shouldn't be a surprise.
And you can see results like the one on the

00:22:53.739 --> 00:22:57.879
-- on the left here where the original site
was over 7 megabytes in size. Once we ran

00:22:57.879 --> 00:23:03.700
the image optimization and other kind of best
practices, we're down to -- let's see -- 1

00:23:03.700 --> 00:23:07.640
megabyte and a little bit more, right? 1.4
megabytes.

00:23:07.640 --> 00:23:12.190
So huge, huge savings.
So how do you get started?

00:23:12.190 --> 00:23:16.940
The best place is actually to just go to mod_pagespeed.com
or Nginx_PageSpeed. I think those are -- those

00:23:16.940 --> 00:23:20.499
are two of the most popular servers out there.
It's open source. You can grab it. You can

00:23:20.499 --> 00:23:26.769
play with it. We provide the packaging for
it. You can basically grab the RPM and install

00:23:26.769 --> 00:23:34.570
it and also a shout-out to a couple of community-developed
modules. So if you're using IIS server, you

00:23:34.570 --> 00:23:39.150
can actually also use PageSpeed. There's a
great new project called IIS Speed that's

00:23:39.150 --> 00:23:45.259
being developed and gives you the same functionality
within IIS. And also, the guys at LinkedIn

00:23:45.259 --> 00:23:50.450
are running PageSpeed and they're using Apache
traffic server, so they're the ones developing

00:23:50.450 --> 00:23:53.999
the Apache traffic server module, which I
think is really cool.

00:23:53.999 --> 00:24:00.519
So we're all building off the same core and
continuing to improve this infrastructure.

00:24:00.519 --> 00:24:05.679
So this is great, right? Like I have my Web
server. I can install this module. I can configure

00:24:05.679 --> 00:24:09.399
it. I can do other things.
But there's still more that I can do. I can

00:24:09.399 --> 00:24:15.460
still deploy my assets to a CDN. I want to
have some protection against denial of service

00:24:15.460 --> 00:24:19.990
attacks. And a number of other features. Wouldn't
it be nice if somebody did all of this work

00:24:19.990 --> 00:24:25.259
for you?
And that, in effect, is what PageSpeed service

00:24:25.259 --> 00:24:28.380
is.
So this is a beta product and project that

00:24:28.380 --> 00:24:33.820
we have at Google today. You can sign up for
it. It's currently in beta. And the way it

00:24:33.820 --> 00:24:38.580
works is, the traffic to your site is routed
through Google servers.

00:24:38.580 --> 00:24:45.299
So, you know, if you want to get technical,
you create -- you cname your www domain to

00:24:45.299 --> 00:24:50.019
point to Google servers, such that when users
type in, you know, www your site dot com,

00:24:50.019 --> 00:24:54.249
they actually hit a Google server. The Google
server then goes to your server and requests

00:24:54.249 --> 00:24:59.330
the actual content. It grabs that content,
does all of the optimization, saves all of

00:24:59.330 --> 00:25:03.990
the optimized assets in the Google cloud,
in the Google CDN, and, you know, we have

00:25:03.990 --> 00:25:09.779
a few servers around the world to do that
kind of thing, and serves the optimized assets.

00:25:09.779 --> 00:25:15.609
So you're getting the benefit of CDN and dynamic
optimization, which is really, really cool.

00:25:15.609 --> 00:25:19.979
So I actually have it running on my site and
I want to show you guys a demo of how this

00:25:19.979 --> 00:25:25.399
works in practice.
So here I am. Here's my site. I have this

00:25:25.399 --> 00:25:30.979
beautiful little gallery of, you know, my
favorite travel photos. I -- I love them in

00:25:30.979 --> 00:25:35.200
all of their high-res glory because I'm a
photographer and I would never think about,

00:25:35.200 --> 00:25:39.220
you know, doing anything less, but I think
we can do a lot better, right? So if you go

00:25:39.220 --> 00:25:43.259
to the network tab and if we just sort the
file size on the page, you can see that there's

00:25:43.259 --> 00:25:49.899
three images, Tokyo, Oxford, and Aurora, weighing
in at about 3 megabytes and they're served

00:25:49.899 --> 00:25:54.489
as PNG files. That's how I saved them as.
I think we can do better.

00:25:54.489 --> 00:26:01.659
So I have PageSpeed service running on my
site. If I go to my Google API console, I'm

00:26:01.659 --> 00:26:06.169
looking at the PageSpeed service tab here.
Let's go to "Overview." So basically what's

00:26:06.169 --> 00:26:10.409
happening here is here's my origin server,
PageSpeed server, so the Google servers are

00:26:10.409 --> 00:26:16.480
in between, and if we go to configure rewriters,
this is where all of the magic happens, right?

00:26:16.480 --> 00:26:21.559
We -- we basically have a set of check boxes
and let me make that a little bit bigger.

00:26:21.559 --> 00:26:25.999
Oops, that's not blowing up.
We have a set of check boxes that just allow

00:26:25.999 --> 00:26:31.989
you to apply optimizations without actually
modifying your app. So for example, I'm concerned

00:26:31.989 --> 00:26:38.210
about images, so let's go into optimize images
and I want to do a few things.

00:26:38.210 --> 00:26:42.179
So I want to resize images on the server,
such that if I'm serving a file size of -- or

00:26:42.179 --> 00:26:46.619
an image that is larger than what I meant
to display, just optimize it for me.

00:26:46.619 --> 00:26:52.169
And also convert PNG files to JPEG.
That sounds about like what I want, right?

00:26:52.169 --> 00:26:58.419
I'm serving PNGs so let me save that.
I'm going to apply this to the live site and

00:26:58.419 --> 00:27:02.129
we're going to refresh the site.
And we're actually going to do this twice.

00:27:02.129 --> 00:27:04.789
And the reason we do this twice is remember
what I said earlier, we don't want to slow

00:27:04.789 --> 00:27:10.840
down the site? So the first time we may server
the unoptimized asset or the original asset,

00:27:10.840 --> 00:27:14.809
but then on the next load, you can see that
the filename has changed. It now has this

00:27:14.809 --> 00:27:19.149
PageSpeed URL and now it's being served as
a JPEG. So what PageSpeed service has done

00:27:19.149 --> 00:27:22.769
-- notice that I haven't -- like I haven't
done anything on my site, right? The Google

00:27:22.769 --> 00:27:26.499
cloud is handling all of this. It's rewritten
the image, it's fingerprinted the image, and

00:27:26.499 --> 00:27:34.919
it's serving a JPEG, and the images, they're
the same size. That's not good. There we go.

00:27:34.919 --> 00:27:40.760
That was just a caching error. So a hundred
kilobytes versus one megabyte, right? But

00:27:40.760 --> 00:27:45.070
I think we can do better, right? So right
now, our image -- our total size of this page

00:27:45.070 --> 00:27:52.220
is 467 kilobytes so let's go back to the console
and also enable convert JPEG to WebP and -- sure,

00:27:52.220 --> 00:27:56.649
let's just enable it all. Why not. And apply
to live. And we're going to do the same test

00:27:56.649 --> 00:28:00.059
again so we'll refresh it again.
Now, Chrome, of course, understands WebP,

00:28:00.059 --> 00:28:06.080
so in theory we should see WebP images coming
through once they're optimized, and there

00:28:06.080 --> 00:28:12.970
they are. So we have the WebP -- let's just
re-share -- resort here.

00:28:12.970 --> 00:28:17.250
So we have the Tokyo file. It's now at 81
kilobytes. Previously it was 120. And the

00:28:17.250 --> 00:28:22.649
total size of the page is 328 kilobytes. So
we went from a page that's over 3 megabytes

00:28:22.649 --> 00:28:28.609
to 328 kilobytes. That's a 10X improvement,
right? And I didn't have to modify my application.

00:28:28.609 --> 00:28:32.809
The images are rescaled on the server and
served in the best possible format.

00:28:32.809 --> 00:28:36.539
If we were to open this in IE, it would just
serve a JPEG. I don't have to worry about

00:28:36.539 --> 00:28:41.460
that.
So that's pretty awesome.

00:28:41.460 --> 00:28:46.019
Now, this works, of course, for any site that
you host on, you know, any hosting provider.

00:28:46.019 --> 00:28:50.389
You just need to cname your site. But if you're
using AppEngine, you can also take advantage

00:28:50.389 --> 00:28:55.059
of Google PageSpeed service.
What you need to do -- and unfortunately it's

00:28:55.059 --> 00:28:59.970
a little bit small here -- you can modify
your app.yaml file, and you have good documentation

00:28:59.970 --> 00:29:04.489
how to do this, and you can just specify which
filters you want PageSpeed service to apply.

00:29:04.489 --> 00:29:08.899
And before the request gets routed to your
application server, it will actually be processed

00:29:08.899 --> 00:29:14.029
by our PageSpeed service proxy and it will
do all this work for you.

00:29:14.029 --> 00:29:19.679
So we ran this experiment on HTML5 Rocks.
I'm sure you guys have seen the site. If not,

00:29:19.679 --> 00:29:23.889
I encourage you to. Lots of great material.
It's actually an AppEngine app. It's a Python

00:29:23.889 --> 00:29:27.029
AppEngine app. It's open source. You can actually
check it out on Github and you can check the

00:29:27.029 --> 00:29:33.359
exact modules and optimizations we're applying.
So we used Google Analytics to run an experiment

00:29:33.359 --> 00:29:38.190
and say what happens if we enable PageSpeed
service and then disable it? So we ran an

00:29:38.190 --> 00:29:45.749
A/B test, and, you know, we added six or seven
lines, whatever it is, to our app.yaml file

00:29:45.749 --> 00:29:51.499
and we made our site 10% faster. This is as
measured by Page Load Time, right? And there's

00:29:51.499 --> 00:29:55.979
another -- a number of other metrics which
we've improved as well.

00:29:55.979 --> 00:30:03.029
So this is a huge, huge win.
Especially for seven lines of modifications.

00:30:03.029 --> 00:30:08.200
So I think the takeaway here is automating
Web performance best practices offers a lot

00:30:08.200 --> 00:30:12.789
of benefits. First of all, performance is
a continuous process, it's not a checklist

00:30:12.789 --> 00:30:16.349
item, it's not something that you add at the
end. Right? So building or leveraging these

00:30:16.349 --> 00:30:22.049
automated tools allows us to just not worry
about that.

00:30:22.049 --> 00:30:25.820
The other thing is, we just don't have to
worry about things anymore, a lot of things

00:30:25.820 --> 00:30:30.489
anymore. So for example, when I save my images
on my own site, I just save them as whatever

00:30:30.489 --> 00:30:33.570
format I'm working with, right? Like I'll
save them as a PNG. I don't have to think

00:30:33.570 --> 00:30:38.580
about what is the optimal format for this
image. I'll let the computer or the servers

00:30:38.580 --> 00:30:42.129
figure that out for me. I can just go into
my control panel and kind of fiddle with the

00:30:42.129 --> 00:30:46.109
quality of what goes in and other things.
Not only that but I can also dynamically adjust

00:30:46.109 --> 00:30:51.859
the quality based on the client, right? Maybe
for a mobile site, you want to serve slightly

00:30:51.859 --> 00:30:55.779
lower quality images because the screens are
smaller, and frankly, the users won't notice,

00:30:55.779 --> 00:30:59.190
but that's a huge byte savings that you could
have.

00:30:59.190 --> 00:31:02.799
These kinds of things you can't do manually,
right? How do you implement that in your application?

00:31:02.799 --> 00:31:06.460
You would have to do -- use JavaScript with,
you know, detection of the client. It's a

00:31:06.460 --> 00:31:09.299
mess, right?
Let the server handle that for you.

00:31:09.299 --> 00:31:13.989
Not only that, but we can do dynamic optimizations
that you can't, frankly, do manually, right?

00:31:13.989 --> 00:31:19.249
So you saw us serving WebP files. That would
be a disaster to build into your application,

00:31:19.249 --> 00:31:24.460
right? It's doable but it's hard.
And then there's things like work on HTTP

00:31:24.460 --> 00:31:30.850
2.0 and SPDY, so our SPDY protocol is now
being standardized as HTTP 2.0 and they're

00:31:30.850 --> 00:31:34.379
adding a lot of great new improvements to
it, and frankly, it's going to address a lot

00:31:34.379 --> 00:31:38.679
of the problems that we have to deal with
today. Things like concatenating files? We

00:31:38.679 --> 00:31:43.190
don't have to do that anymore with HTTP 2.0.
Right? So now that all of you guys have concatenated

00:31:43.190 --> 00:31:46.710
all of your files, please go ahead and undo
all of that, because that's what you do to

00:31:46.710 --> 00:31:51.289
improve performance on HTTP 2.0, right? But
then how do you serve the optimized version

00:31:51.289 --> 00:31:56.120
for both, right? Because HTTP 2.0 is not going
to come overnight. It will take a while. And

00:31:56.120 --> 00:31:59.970
this is where automation can come in. This
is where the server can automatically decide

00:31:59.970 --> 00:32:04.090
and figure out like, "Hey, you're an HTTP
2.0 client. I just won't do this class of

00:32:04.090 --> 00:32:11.179
optimizations for you," right? So this is
a great reason to invest into this -- into

00:32:11.179 --> 00:32:14.169
these kinds of tools. And frankly, at the
end of the day it just allows you to focus

00:32:14.169 --> 00:32:19.970
on your application. So with that, we have
a little bit of time for questions, and if

00:32:19.970 --> 00:32:25.749
you guys can, please grab one of the mics.
&gt;&gt;&gt; Thank you. This is really awesome.

00:32:25.749 --> 00:32:30.129
Two questions. Firstly, retina images. Any
thoughts on that?

00:32:30.129 --> 00:32:34.869
&gt;&gt;Ilya Grigorik: Yeah. So retina images is
a big discussion, I think, in the web community

00:32:34.869 --> 00:32:41.440
today. We're looking at a couple of solutions
for serving high DPI images, like 2X images.

00:32:41.440 --> 00:32:47.299
We don't have any built-in filters today,
but we have some in the works, and right now,

00:32:47.299 --> 00:32:51.999
I guess the problem is we don't have a generic
way to do that across browsers.

00:32:51.999 --> 00:32:56.539
&gt;&gt;&gt; Okay. And sorry, the second one, the service
looks even better. Is that something you expect

00:32:56.539 --> 00:32:58.929
to be a paid service when it comes out of
beta?

00:32:58.929 --> 00:33:02.940
&gt;&gt;Ilya Grigorik: PageSpeed? Right. So PageSpeed
service is in beta right now. It is free while

00:33:02.940 --> 00:33:06.559
it's in beta and we are still trying to determine
what is the right module to actually, you

00:33:06.559 --> 00:33:11.330
know, charge for it and all the rest. Because
it is being served through the Google cloud

00:33:11.330 --> 00:33:14.659
and, you know, there's -- there may be some
additional fee in the future,

00:33:14.659 --> 00:33:17.909
But I don't think we have a good answer yet.
Yeah.

00:33:17.909 --> 00:33:21.599
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; Can PageSpeed help you if you use a single-page

00:33:21.599 --> 00:33:25.960
Web app who loads its content using Ajax?
&gt;&gt;Ilya Grigorik: Yeah, so can PageSpeed help

00:33:25.960 --> 00:33:31.830
us with single-page apps? Perhaps not as much,
right, because you are probably doing a lot

00:33:31.830 --> 00:33:37.599
of the loading through JavaScript over your
assets and all the rest. But you can -- if

00:33:37.599 --> 00:33:44.169
you leverage things like just regular image
tags and other things, you can configure PageSpeed

00:33:44.169 --> 00:33:48.940
to do transparent rewriting and optimization
of images.

00:33:48.940 --> 00:33:53.599
I showed you examples where you rewrite the
URL. You can actually configure it the other

00:33:53.599 --> 00:33:58.629
way around such that the image is -- the URL
is the same and then still leverage some of

00:33:58.629 --> 00:34:03.229
the functionality.
&gt;&gt;&gt; All right. Thank you.

00:34:03.229 --> 00:34:10.299
&gt;&gt;&gt; Let me interrupt you. Sorry. So as a Rails
developer, are there any caveats that we have

00:34:10.299 --> 00:34:14.500
to worry about when developing more dynamic
apps? Is this suitable for just sort of static

00:34:14.500 --> 00:34:18.289
pages? Or what's the -- or what do we need
to know about using PageSpeed for dynamic

00:34:18.289 --> 00:34:20.039
things?
&gt;&gt;Ilya Grigorik: I don't think there are any

00:34:20.039 --> 00:34:24.960
constraints whether it is a static app or
a dynamic app. It really doesn't matter.

00:34:24.960 --> 00:34:29.579
So the way PageSpeed works, it basically intercepts
your request at the very end before it gets

00:34:29.579 --> 00:34:33.020
served by the server. So it doesn't matter
who generated.

00:34:33.020 --> 00:34:37.159
For Rails specifically, Rails, of course,
has asset pipeline and other things that try

00:34:37.159 --> 00:34:41.020
to do a lot of this work at deploy time, right,
concatenating files and all the rest.

00:34:41.020 --> 00:34:43.809
I would actually say you don't need to do
that anymore. You don't have to worry about

00:34:43.809 --> 00:34:48.799
it. PageSpeed will do all of that for you,
plus more, because we can do dynamic optimizations.

00:34:48.799 --> 00:34:55.669
&gt;&gt;&gt; So quick question. With the beta that
you have running, is there an upper limit

00:34:55.669 --> 00:35:00.020
on the number of assets that we could have
cached if I want to do A/B testing for my

00:35:00.020 --> 00:35:02.760
company?
&gt;&gt;Ilya Grigorik: No, there's no limit on that.

00:35:02.760 --> 00:35:09.400
&gt;&gt;&gt; Okay. And just to sort of -- to tag onto
the previous gentleman's question, how would

00:35:09.400 --> 00:35:13.770
PageSpeed handle something, like I said, of
using RequireJS or something where we're sort

00:35:13.770 --> 00:35:20.950
of doing, like, lazy load of static assets?
&gt;&gt;Ilya Grigorik: Yeah. So we have our own

00:35:20.950 --> 00:35:26.599
filters that do, for example, defer JavaScript,
right, which will grab your code and actually

00:35:26.599 --> 00:35:30.130
wrap it in our own kind of markup to defer
it to load later.

00:35:30.130 --> 00:35:34.550
So RequireJS is effectively that, but you
are doing it manually.

00:35:34.550 --> 00:35:40.079
We don't have -- and it would be very hard
to build scripts that introspect into RequireJS.

00:35:40.079 --> 00:35:44.430
So we may not be able to as much if you are
doing this kind of dynamic construction of

00:35:44.430 --> 00:35:46.760
the page.
But that's really an area that we are looking

00:35:46.760 --> 00:35:50.141
for feedback from you guys as well because,
you know, I think these are -- these are the

00:35:50.141 --> 00:35:55.010
new apps that are being built. So if there
is more interest in that, we'll start looking

00:35:55.010 --> 00:35:58.279
in that direction.
&gt;&gt;&gt; Thank you.

00:35:58.279 --> 00:36:06.599
&gt;&gt;&gt; I actually have three questions. One is
can we use this with sites that have SSL enabled?

00:36:06.599 --> 00:36:09.340
I wouldn't be comfortable giving Google my
SSL certificate.

00:36:09.340 --> 00:36:15.200
&gt;&gt;Ilya Grigorik: Yeah, so for SSL, the answer
is yes. Basically, you would determine your

00:36:15.200 --> 00:36:20.069
SSL at your server, right? So, okay, there
is a couple, I guess, questions.

00:36:20.069 --> 00:36:23.529
Open source or PageSpeed service?
&gt;&gt;&gt; The PageSpeed service.

00:36:23.529 --> 00:36:27.380
&gt;&gt;Ilya Grigorik: For PageSpeed service, you
would have to upload your certificates to

00:36:27.380 --> 00:36:32.829
one of our servers, so I have it set up on
my site. You can actually try it. I upload

00:36:32.829 --> 00:36:36.510
the certificate and the connection is terminated
at the Google server.

00:36:36.510 --> 00:36:42.279
&gt;&gt;&gt; Okay. The second question I had was how
much of an additional load in terms of CPU

00:36:42.279 --> 00:36:46.510
and memory does PageSpeed module add onto
Apache or Nginx?

00:36:46.510 --> 00:36:54.640
&gt;&gt;Ilya Grigorik: That's a great question.
For example, it can take a while, right, hundreds

00:36:54.640 --> 00:37:00.980
of milliseconds to do.
So I think it is giving me the boot.

00:37:00.980 --> 00:37:04.500
So what we do is we actually give you knobs
to control how much resources you are willing

00:37:04.500 --> 00:37:09.300
to give the server. So, for example, you can
tweak the number of threads that we will employ

00:37:09.300 --> 00:37:15.020
in the background to optimize the stuff. You
can also tweak the size of our cache. For

00:37:15.020 --> 00:37:20.530
multi-server deployments, we actually provide
mem cache -- caching. Instead of storing the

00:37:20.530 --> 00:37:25.029
optimized assets on just one server, you can
share it across a cluster of servers.

00:37:25.029 --> 00:37:29.220
So there is a lot of knobs. I didn't cover
these here. There is a lot of great documentation

00:37:29.220 --> 00:37:32.110
that we have on our site that you can look
into.

00:37:32.110 --> 00:37:35.520
&gt;&gt;&gt; Can we extend the PageSpeed module with
additional filters?

00:37:35.520 --> 00:37:39.710
&gt;&gt;Ilya Grigorik: Can you say that again, sorry?
&gt;&gt;&gt; Can we extend the module with additional

00:37:39.710 --> 00:37:44.420
filters, if you want to write out custom filters
to do some optimizations?

00:37:44.420 --> 00:37:48.099
&gt;&gt;Ilya Grigorik: Oh, sure, yeah. It is an
open source project. Actually, the guy standing

00:37:48.099 --> 00:37:53.309
behind you is the guy to talk to.
You can contribute new filters. We would love

00:37:53.309 --> 00:38:00.109
your participation. If you want to, we have
a very active mod PageSpeed discussion group.

00:38:00.109 --> 00:38:02.350
Just ping us there and we are happy to talk
about it.

00:38:02.350 --> 00:38:06.240
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; Hi. So a lot of applications these days

00:38:06.240 --> 00:38:11.060
are written using clientside templating frameworks
like Ember, Angular, Backbone. How does this

00:38:11.060 --> 00:38:15.720
play with serving up static templates and
any of the --

00:38:15.720 --> 00:38:19.599
&gt;&gt;Ilya Grigorik: So, the short answer is I
don't think we have a good answer for that

00:38:19.599 --> 00:38:25.800
today. We are basically -- we rely on being
able to analyze your HTML, your markup, plus

00:38:25.800 --> 00:38:32.029
the JavaScript and CSS assets. We discover
those in part through analyzing your HTML.

00:38:32.029 --> 00:38:34.559
So there may not be as much that we can do
there.

00:38:34.559 --> 00:38:40.290
You can configure the server as I mentioned
earlier to do transparent rewriting of images

00:38:40.290 --> 00:38:44.079
and a few other things.
But I think that's an area that we can definitely

00:38:44.079 --> 00:38:51.010
do more in, in the future.
&gt;&gt;&gt; Hi. I'm Josh,(saying name). I work on

00:38:51.010 --> 00:38:56.900
the PageSpeed optimization project. I wanted
to point out that actually just to this point

00:38:56.900 --> 00:39:02.830
and the one made earlier, if you have -- if
you are loading assets via JavaScript, we

00:39:02.830 --> 00:39:07.660
do a pretty good job of optimizing them.
What we don't know is the sizing context because

00:39:07.660 --> 00:39:12.630
we just get to -- we get a request for a JPEG
file and we optimize that based on whatever

00:39:12.630 --> 00:39:17.130
the user agent is. We don't know how big it
was supposed to -- what slot it was supposed

00:39:17.130 --> 00:39:20.480
to go in. And we can't change its cache lifetime
if we can't change its URL.

00:39:20.480 --> 00:39:25.390
&gt;&gt;Ilya Grigorik: Yep.
&gt;&gt;&gt; But the on-the-fly transcoding that you

00:39:25.390 --> 00:39:32.050
get for reducing image size and bandwidth
for Android browsers that uses that flow.

00:39:32.050 --> 00:39:36.579
&gt;&gt;Ilya Grigorik: One note to that. As you
guys probably have noticed, we have a performance

00:39:36.579 --> 00:39:44.780
area in the Chrome booth section. And we have
a big contingent from the PageSpeed family

00:39:44.780 --> 00:39:48.220
of products hanging out there. If you guys
want to talk to us about specific questions,

00:39:48.220 --> 00:39:51.640
how to implement stuff or just have ideas,
please drop by.

00:39:51.640 --> 00:39:56.940
&gt;&gt;&gt; Yeah. That's just about Java. You showed
us how to implement that on that page using

00:39:56.940 --> 00:40:04.960
Python. Do you have any examples in Java?
And you showed us the URL to get to the beta.

00:40:04.960 --> 00:40:08.660
If you could share with us these slides or
go back to the URL?

00:40:08.660 --> 00:40:12.740
&gt;&gt;Ilya Grigorik: I will take the last one
first. So if you just use your favorite search

00:40:12.740 --> 00:40:17.880
engine and look for PageSpeed service, you
will land directly on the link that you need.

00:40:17.880 --> 00:40:21.450
That's the simplest way to get there. And
then the other one was -- question was Java

00:40:21.450 --> 00:40:24.859
versus Python examples.
&gt;&gt;&gt; Yeah, you showed us the Python example

00:40:24.859 --> 00:40:29.660
and how to do that on yaml file.
&gt;&gt;Ilya Grigorik: Oh, sure. Yeah, the great

00:40:29.660 --> 00:40:36.280
thing about PageSpeed service is, it is completely
agnostic of the runtime that you are using.

00:40:36.280 --> 00:40:40.160
There is no difference between Java, Python,
and all the rest.

00:40:40.160 --> 00:40:45.170
If you go to the Google AppEngine documentation
and just search for PageSpeed, you will have

00:40:45.170 --> 00:40:48.650
the specific commands that you need in there.
&gt;&gt;&gt; Awesome. Thank you.

00:40:48.650 --> 00:40:52.670
&gt;&gt;Ilya Grigorik: Yep.
&gt;&gt;&gt; Thank you. Hi. I have been using PageSpeed

00:40:52.670 --> 00:40:57.329
service for a while and it is pretty impressive.
And I have one question, is that you mentioned

00:40:57.329 --> 00:41:02.279
you deployed several servers and words to
get -- to make the optimization.

00:41:02.279 --> 00:41:06.470
&gt;&gt;Ilya Grigorik: Yeah.
&gt;&gt;&gt; So we know in order to make the optimization,

00:41:06.470 --> 00:41:12.640
you need to make several subsequent -- subrequests
of the first requests. So I was wondering,

00:41:12.640 --> 00:41:20.390
can you share a little bit about your global
deployment and the method you used to determine

00:41:20.390 --> 00:41:25.829
the closest server for optimization.
&gt;&gt;Ilya Grigorik: So, thankfully, we actually

00:41:25.829 --> 00:41:29.599
on PageSpeed service don't necessarily need
to do anything. This is part of the global

00:41:29.599 --> 00:41:34.910
Google caching policy, right? Whenever you
issue a request to Google Search, we try to

00:41:34.910 --> 00:41:38.500
determine what is the closest location. We
can do that through DNS, through I.P. lookups.

00:41:38.500 --> 00:41:42.150
There is a variety of different methods. And
we just leverage all of that infrastructure

00:41:42.150 --> 00:41:45.109
at PageSpeed.
So, basically, your site is getting deployed

00:41:45.109 --> 00:41:49.450
on the same infrastructure that is powering
Google Search and other things, all right?

00:41:49.450 --> 00:41:55.460
So picking the closest server to the user
is just part of the magic, if you will. It

00:41:55.460 --> 00:41:59.140
is not something you need to configure at
all or worry about within your application.

00:41:59.140 --> 00:42:01.869
&gt;&gt;&gt; Thank you.
&gt;&gt;Ilya Grigorik: Yep.

00:42:01.869 --> 00:42:07.590
&gt;&gt;&gt; Are there any optimizations that are device-dependent?
So, for instance, having images that would

00:42:07.590 --> 00:42:10.839
be more optimized for mobile devices versus
browsers?

00:42:10.839 --> 00:42:17.549
&gt;&gt;Ilya Grigorik: The answer is absolutely
yes. The best one is the WebP example I shared.

00:42:17.549 --> 00:42:22.170
Only certain user agents are able to use it.
Another example would be leveraging local

00:42:22.170 --> 00:42:27.530
storage. So not all clients are able to leverage
local search, and we actually have a filter

00:42:27.530 --> 00:42:30.519
that can use local storage as a cache for
your assets.

00:42:30.519 --> 00:42:33.890
And we will deploy those optimizations conditionally.
And Josh is going to --

00:42:33.890 --> 00:42:39.609
&gt;&gt;&gt; Yeah, you can also say for small screens
compress more aggressively than for large

00:42:39.609 --> 00:42:41.400
screens.
&gt;&gt;Ilya Grigorik: Yep, yep.

00:42:41.400 --> 00:42:45.890
&gt;&gt;&gt; So kind of a follow-up on that, both for
the service as well as for something like

00:42:45.890 --> 00:42:50.849
mod PageSpeed, how is the universe of user
agents that are being identified to optimize

00:42:50.849 --> 00:42:54.799
for being managed and the frequency with which
it gets updated?

00:42:54.799 --> 00:43:00.920
&gt;&gt;Ilya Grigorik: So we -- Right. So we test
the stuff very extensively. All the code is

00:43:00.920 --> 00:43:05.230
open source.
Josh, do you want to share any details? I

00:43:05.230 --> 00:43:10.740
think -- so one thing I didn't mention, I
had in those slides, we have two sets of filters,

00:43:10.740 --> 00:43:17.940
COR and optional filters. COR filters are
the safe filters. They should be -- can be

00:43:17.940 --> 00:43:23.950
applied to any site without any risk or minimal
risk on the site in terms of modifying the

00:43:23.950 --> 00:43:26.710
look and feel.
And then there's an extended list of other

00:43:26.710 --> 00:43:31.619
optimizations which we can do on a per-user-agent
basis and the rest.

00:43:31.619 --> 00:43:38.119
&gt;&gt;&gt; So in the open source world, we have to
kind of cut releases and ship product. So

00:43:38.119 --> 00:43:45.000
we have -- we take kind of a white-listing
view of what we can do for different browsers.

00:43:45.000 --> 00:43:49.869
So if you are using mod PageSpeed from last
month and this month there is a new device

00:43:49.869 --> 00:43:54.019
that can support WebP, we won't know about
it.

00:43:54.019 --> 00:43:58.760
&gt;&gt;Ilya Grigorik: Back in November of last
year, we shipped the 1.0 of mod PageSpeed.

00:43:58.760 --> 00:44:03.160
And when we did that switch, we are shipping
two channels. There is a beta channel, and

00:44:03.160 --> 00:44:07.029
there is a stable channel, very similar to
Chrome.

00:44:07.029 --> 00:44:10.560
If you want to be on the edge and try all
the latest optimizations that's where you

00:44:10.560 --> 00:44:15.901
would be. If you are a little bit more nervous
about how this will work across all the devices,

00:44:15.901 --> 00:44:19.750
you should stick with the stable channel.
&gt;&gt;&gt; Another question is, all this is awesome

00:44:19.750 --> 00:44:25.260
to have it happen Automagically. When it does
that, does it also output reports so you can

00:44:25.260 --> 00:44:29.490
go back to your developers and say: Hey, you
should code better and this is how.

00:44:29.490 --> 00:44:33.589
&gt;&gt;Ilya Grigorik: That's PageSpeed insights.
We are effectively taking that same engine,

00:44:33.589 --> 00:44:35.940
or the same rules and just automating all
of that for you.

00:44:35.940 --> 00:44:38.780
&gt;&gt;&gt; Does it output of what it's actually done
so you can go back without having to run it

00:44:38.780 --> 00:44:42.920
through insights on its own? Do you get some
logging of, Hey, we did these concatenations

00:44:42.920 --> 00:44:45.800
aside from the image optimization.
&gt;&gt;Ilya Grigorik: That's interesting. I don't

00:44:45.800 --> 00:44:50.109
think we actually -- we do have a statistics
screen where we can go and kind of gather

00:44:50.109 --> 00:44:54.890
some data about what is a server doing. How
is it doing to tune its performance? We don't

00:44:54.890 --> 00:45:00.140
have an audit log today to say, like, these
are the explanations we have performed.

00:45:00.140 --> 00:45:04.720
&gt;&gt;&gt; Okay. Thank you.
&gt;&gt;&gt; I realize we are wrapping up. I will go

00:45:04.720 --> 00:45:10.470
quick. Is there any danger zones, things you
should not use -- not do -- not -- if you

00:45:10.470 --> 00:45:13.609
are using this, you should probably not use
PageSpeed on your server if, we are using

00:45:13.609 --> 00:45:17.940
open source Apache and Nginx models?
&gt;&gt;Ilya Grigorik: Sorry, can you --

00:45:17.940 --> 00:45:25.809
&gt;&gt;&gt; Talking too fast. If I'm doing X, then
is there something that I -- should I not

00:45:25.809 --> 00:45:31.819
in this case use PageSpeed?
&gt;&gt;Ilya Grigorik: Oh, I see. No. So coming

00:45:31.819 --> 00:45:37.430
back to COR filters, the safe filters, we
try to be careful about what kind of optimizations,

00:45:37.430 --> 00:45:40.750
rewriting, we do to your markup, JavaScript
and CSS.

00:45:40.750 --> 00:45:44.880
I would actually say once you have PageSpeed
in place, you can undo a lot of the stuff

00:45:44.880 --> 00:45:50.430
that you're doing. So it probably makes sense
just from simplifying your workflow, not having

00:45:50.430 --> 00:45:55.570
to work about a bunch of things.
If you stick with the COR filters, you should

00:45:55.570 --> 00:46:00.940
be pretty safe. But please test first.
One thing I didn't mention and I should have,

00:46:00.940 --> 00:46:10.130
a really great tip, if you go to webpagetest.org/compare,
you can type in your site and it will run

00:46:10.130 --> 00:46:15.400
it through PageSpeed service and it will give
you a side-by-side comparison.

00:46:15.400 --> 00:46:22.120
If you enabled this thing, what would you
get? So in the -- in our documentation, we

00:46:22.120 --> 00:46:27.920
provide a lot of toggles to selectively enable
specific filters. Like, you can pass us a

00:46:27.920 --> 00:46:31.579
query parameter string to say, I'm curious
what is going to happen if I enable image

00:46:31.579 --> 00:46:36.910
lazy loading. And you can do that on a per-request
basis such that as a developer, you can test

00:46:36.910 --> 00:46:41.220
one of these optimizations and then decide
whether you want to make that part of your

00:46:41.220 --> 00:46:47.570
COR configuration.
All right. Thanks, guys. If you have more

00:46:47.570 --> 00:46:51.930
questions, as I mentioned, please come by
our Chrome area and ask us.

00:46:51.930 --> 00:46:52.520
[ Applause ]

