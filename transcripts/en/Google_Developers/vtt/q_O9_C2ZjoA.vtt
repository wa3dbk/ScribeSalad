WEBVTT
Kind: captions
Language: en

00:00:00.445 --> 00:00:01.870
PAUL IRISH: Well, hello.

00:00:01.870 --> 00:00:04.290
My name is Paul Irish, and I
wanted to share some things

00:00:04.290 --> 00:00:08.803
with you about performance,
specifically HTML5, CSS3,

00:00:08.803 --> 00:00:12.370
DOM-type stuff about
performance, things happening

00:00:12.370 --> 00:00:15.900
in the front end, the browser,
things that could be slow and

00:00:15.900 --> 00:00:16.920
could be faster.

00:00:16.920 --> 00:00:20.595
And so we're going to talk about
these kind of things.

00:00:20.595 --> 00:00:23.310
First we're going to talk
about reflows, hardware

00:00:23.310 --> 00:00:27.040
accelerated CSS, animation, web
workers, benchmarking, and

00:00:27.040 --> 00:00:28.490
a little bit about
build scripts.

00:00:28.490 --> 00:00:29.864
Sound good?

00:00:29.864 --> 00:00:30.780
Great.

00:00:30.780 --> 00:00:38.120
OK reflows, let's just
look at this diagram.

00:00:38.120 --> 00:00:40.200
This is a diagram put together
by Stoyan Stefanov.

00:00:42.970 --> 00:00:44.490
When we're talking about
reflows, we're talking about

00:00:44.490 --> 00:00:45.560
the render tree.

00:00:45.560 --> 00:00:46.680
That's the really
important part.

00:00:46.680 --> 00:00:49.960
And the render tree
is made from--

00:00:49.960 --> 00:00:51.530
well, it comes from two
different things.

00:00:51.530 --> 00:00:53.660
So we have the DOM tree.

00:00:53.660 --> 00:00:58.290
The DOM tree is the result after
you tokenize and parse

00:00:58.290 --> 00:00:59.950
your HTML markup.

00:00:59.950 --> 00:01:00.920
It gets parsed into the DOM.

00:01:00.920 --> 00:01:03.340
And that's what you see in
Chrome Developer Tools or

00:01:03.340 --> 00:01:05.310
Firebug, all the elements,
right?

00:01:05.310 --> 00:01:06.070
Of course.

00:01:06.070 --> 00:01:08.050
At the same time, we have
styles coming in.

00:01:08.050 --> 00:01:09.660
And so we have styles coming
in from the style

00:01:09.660 --> 00:01:10.920
sheets and so on.

00:01:10.920 --> 00:01:14.490
And when those two combine,
we get the render tree.

00:01:14.490 --> 00:01:17.010
And the difference between the
DOM tree and the render tree

00:01:17.010 --> 00:01:20.370
is that the render tree--

00:01:20.370 --> 00:01:23.190
let's say that we have an
element that is display:none.

00:01:23.190 --> 00:01:24.880
Not present in the
render tree.

00:01:24.880 --> 00:01:26.680
So it's in the DOM tree, but
it's not in the render tree

00:01:26.680 --> 00:01:28.130
because we don't see it.

00:01:28.130 --> 00:01:29.300
It's just not even there.

00:01:29.300 --> 00:01:34.670
Or if we manipulate the window
size or change the font size,

00:01:34.670 --> 00:01:38.155
the full-page zoom, that, of
course, changes the render

00:01:38.155 --> 00:01:41.885
tree most of the time, whereas
the DOM probably is staying

00:01:41.885 --> 00:01:43.280
the exact same.

00:01:43.280 --> 00:01:45.435
So the render tree is what
you see, and the DOM

00:01:45.435 --> 00:01:48.050
is underneath it.

00:01:48.050 --> 00:01:54.070
A reflow is a change that
necessitates a recalculation

00:01:54.070 --> 00:01:55.510
of the render tree.

00:01:55.510 --> 00:01:58.720
And it might recalculate just
the very bottom of it.

00:01:58.720 --> 00:02:01.651
But it might recalculate
the entire thing.

00:02:01.651 --> 00:02:04.880
And reflows can be cheap.

00:02:04.880 --> 00:02:06.870
But at the same time, they
can be expensive.

00:02:06.870 --> 00:02:11.790
Specifically on mobile devices
or old IE, they can be quite

00:02:11.790 --> 00:02:14.780
expensive, and you don't
want to do a reflow if

00:02:14.780 --> 00:02:15.530
you don't have to.

00:02:15.530 --> 00:02:17.100
And there's ways
to avoid them.

00:02:17.100 --> 00:02:20.598
So first, well, let
me show you this.

00:02:23.810 --> 00:02:25.195
This right here--

00:02:25.195 --> 00:02:26.760
ah, this is so cool.

00:02:26.760 --> 00:02:33.420
This is a debug version
of Firefox, I believe.

00:02:33.420 --> 00:02:38.180
And it's actually laying out
the mozilla.org homepage,

00:02:38.180 --> 00:02:40.310
calculating the layout and the
position of absolutely

00:02:40.310 --> 00:02:42.220
everything.

00:02:42.220 --> 00:02:44.740
This is awesome.

00:02:44.740 --> 00:02:46.560
It figured out where
it all goes.

00:02:46.560 --> 00:02:48.680
And then once it's all done and
the browser's figured out

00:02:48.680 --> 00:02:50.660
it, there we go.

00:02:50.660 --> 00:02:51.525
Pretty cool.

00:02:51.525 --> 00:02:54.390
But let me show you this
one part in here.

00:02:54.390 --> 00:02:57.320
It's right about here--

00:02:57.320 --> 00:02:58.410
finish off the footer.

00:02:58.410 --> 00:03:01.530
And then all of a sudden,
something happens.

00:03:01.530 --> 00:03:03.220
And then it has to recalculate
the whole

00:03:03.220 --> 00:03:04.750
thing all over again.

00:03:04.750 --> 00:03:08.060
And I don't know why
that happened, but

00:03:08.060 --> 00:03:09.540
it didn't need to.

00:03:09.540 --> 00:03:12.420
And we were basically
done at this point.

00:03:12.420 --> 00:03:15.260
And now we have to wait another
30% of our time so

00:03:15.260 --> 00:03:17.860
that it can recalculate the
layout of absolutely

00:03:17.860 --> 00:03:20.270
everything when it should
have been done.

00:03:20.270 --> 00:03:23.280
And so this is the kind of thing
that we want to avoid.

00:03:23.280 --> 00:03:27.520
We don't want to have a full
page reflow that invalidates

00:03:27.520 --> 00:03:29.380
the entire render tree.

00:03:29.380 --> 00:03:33.070
We want to get that finalized
render tree out to the user as

00:03:33.070 --> 00:03:38.670
fast as possible so that they
can interact with your DOM.

00:03:38.670 --> 00:03:41.980
So what causes reflows?

00:03:41.980 --> 00:03:42.900
A lot of people have wondered.

00:03:42.900 --> 00:03:46.470
And a lot of people have
thought, well, checking the

00:03:46.470 --> 00:03:50.540
element.offsetWidth is
normally the trick.

00:03:50.540 --> 00:03:54.490
But Tony G. On the Chrome
team dug into this and

00:03:54.490 --> 00:03:55.710
tried to answer it.

00:03:55.710 --> 00:04:02.320
So Tony dug in, just opened up
Google Code Search and looked

00:04:02.320 --> 00:04:06.780
for Update Layout, Ignore
Pending Style Sheets--

00:04:06.780 --> 00:04:12.800
and this is essentially what
does a reflow in WebKit--

00:04:12.800 --> 00:04:17.800
and found all these items, and
then just listed them out.

00:04:17.800 --> 00:04:19.690
So what we get is this.

00:04:19.690 --> 00:04:22.770
These are all the properties
and methods that

00:04:22.770 --> 00:04:24.990
will cause a reflow.

00:04:24.990 --> 00:04:28.780
And so the offsetWidth, which
is kind of the one that most

00:04:28.780 --> 00:04:32.350
people know, that's
certainly here.

00:04:32.350 --> 00:04:34.110
But there's a lot
of other ones.

00:04:34.110 --> 00:04:37.780
And interestingly, innerText
appears to cause a reflow

00:04:37.780 --> 00:04:39.966
whereas innerHTML does not.

00:04:39.966 --> 00:04:43.060
I'm not exactly sure
about that.

00:04:43.060 --> 00:04:47.070
scrollTo on the window does.

00:04:47.070 --> 00:04:50.830
So these are all the things
that by calling, you would

00:04:50.830 --> 00:04:52.210
trigger a reflow.

00:04:52.210 --> 00:04:54.220
But what are the kind of
typical operations

00:04:54.220 --> 00:04:56.000
that would do it?

00:04:56.000 --> 00:04:59.500
Of course, manipulating the DOM
tree is definitely going

00:04:59.500 --> 00:05:01.945
to cause a reflow.

00:05:01.945 --> 00:05:04.070
Yeah, definitely.

00:05:04.070 --> 00:05:09.250
If you hide a DOM node with
display:none, that will

00:05:09.250 --> 00:05:09.830
manipulate the render tree.

00:05:09.830 --> 00:05:11.140
It will cause a reflow.

00:05:11.140 --> 00:05:14.790
But then any changes to
that element once it's

00:05:14.790 --> 00:05:17.180
display:noned won't.

00:05:17.180 --> 00:05:22.830
Whereas over with
visibility:hidden, if you just

00:05:22.830 --> 00:05:25.850
take an element,
visibility:hidden it, there's

00:05:25.850 --> 00:05:28.200
no recalculation of the page.

00:05:28.200 --> 00:05:30.200
The geometry of the page
stays the same.

00:05:30.200 --> 00:05:31.410
So actually there's no reflow.

00:05:31.410 --> 00:05:36.102
We just repaint that one little
box and keep going.

00:05:36.102 --> 00:05:38.210
If we're animating anything
across the page, of course

00:05:38.210 --> 00:05:39.540
we're doing reflows.

00:05:39.540 --> 00:05:44.260
It depends on maybe you could
overflow:hidden it, a

00:05:44.260 --> 00:05:48.070
container, so that it's kind of
encapsulated a little bit.

00:05:48.070 --> 00:05:51.400
Adding new styles, and then any
sort of user interaction

00:05:51.400 --> 00:05:54.460
like resizing the window,
changing the font size, even

00:05:54.460 --> 00:05:58.720
scrolling causes reflows.

00:05:58.720 --> 00:06:02.940
So here's a little example about
a small optimization

00:06:02.940 --> 00:06:06.970
that you could do to avoid
causing excess reflows.

00:06:06.970 --> 00:06:10.270
So what we're doing, this is
just some simple little jQuery

00:06:10.270 --> 00:06:11.280
code, right?

00:06:11.280 --> 00:06:13.220
We are grabbing an element, and
we're just grabbing the

00:06:13.220 --> 00:06:15.320
left style property off of it.

00:06:15.320 --> 00:06:17.270
And then we're going to take
that left and apply it to

00:06:17.270 --> 00:06:18.220
something else.

00:06:18.220 --> 00:06:20.760
And then we have to do that
to another one as well.

00:06:20.760 --> 00:06:25.750
So we get it here, set it,
get it here, and set it.

00:06:25.750 --> 00:06:28.810
The problem here is that
actually checking our style

00:06:28.810 --> 00:06:32.197
property is going to trigger
a recalculation of

00:06:32.197 --> 00:06:34.450
the styles in a reflow.

00:06:34.450 --> 00:06:37.420
And because we set something
here, it has to

00:06:37.420 --> 00:06:38.700
do it all over again.

00:06:38.700 --> 00:06:43.240
So a way to avoid this is we
can just bunch our gets

00:06:43.240 --> 00:06:46.960
together and then our
sets together.

00:06:46.960 --> 00:06:47.440
I'll show you.

00:06:47.440 --> 00:06:52.000
This is kind of what it looks
like over in the Chrome Dev

00:06:52.000 --> 00:06:55.550
Tools Timeline view.

00:06:55.550 --> 00:06:56.780
So here we are.

00:06:56.780 --> 00:06:57.940
We have Recalculate
Style and Layout.

00:06:57.940 --> 00:06:59.570
And these kind of go together.

00:06:59.570 --> 00:07:02.090
Recalculate Style is essentially
the prerequisite

00:07:02.090 --> 00:07:03.990
for a reflow.

00:07:03.990 --> 00:07:05.970
In WebKit and in other
browsers, a

00:07:05.970 --> 00:07:08.090
reflow is called a layout.

00:07:08.090 --> 00:07:10.740
Mozilla uses the term
"reflow." It's just

00:07:10.740 --> 00:07:12.890
terminology really.

00:07:12.890 --> 00:07:16.710
What you'll see here is that in
that first example, we kind

00:07:16.710 --> 00:07:19.550
of do this thing twice before
we're able to paint out what

00:07:19.550 --> 00:07:20.720
the changes are.

00:07:20.720 --> 00:07:23.420
Whereas in the second one when
we bunch them together, we can

00:07:23.420 --> 00:07:26.270
get away with just doing
a single reflow

00:07:26.270 --> 00:07:27.670
before we're all set.

00:07:27.670 --> 00:07:29.030
And then we can paint it out.

00:07:29.030 --> 00:07:31.830
And I will point out the scale
looks a little weird here.

00:07:31.830 --> 00:07:35.060
But we finished the second time
at about 3 milliseconds.

00:07:35.060 --> 00:07:39.770
Whereas the first time we
finished maybe about 4 to 4

00:07:39.770 --> 00:07:41.520
and a 1/2 milliseconds.

00:07:41.520 --> 00:07:45.340
So the third one, in addition
to having less reflows, is

00:07:45.340 --> 00:07:46.590
actually indeed faster.

00:07:49.900 --> 00:07:53.020
So there's a few strategies
for avoiding reflows.

00:07:53.020 --> 00:07:55.020
The first is batching your
DOM changes together

00:07:55.020 --> 00:07:57.700
like we just did.

00:07:57.700 --> 00:08:00.520
Other ways we can do it is you
can clone the existing

00:08:00.520 --> 00:08:06.490
element, work off DOM with
that element, and then--

00:08:06.490 --> 00:08:09.130
because any manipulations while
it's off DOM are not

00:08:09.130 --> 00:08:10.260
going to cause a reflow.

00:08:10.260 --> 00:08:12.360
And then once you're done
manipulating it, you can

00:08:12.360 --> 00:08:14.850
replace that one that was
already there and check the

00:08:14.850 --> 00:08:17.110
new one in.

00:08:17.110 --> 00:08:19.930
If you hide anything with
display:none, it

00:08:19.930 --> 00:08:21.770
will cause a reflow.

00:08:21.770 --> 00:08:24.620
But if you then manipulate it,
all those manipulations while

00:08:24.620 --> 00:08:29.595
it's display:none will not cause
reflows, except in IE.

00:08:37.460 --> 00:08:40.830
However, you can take
an element.

00:08:40.830 --> 00:08:42.940
Instead of doing display:none,
you can just take it off DOM,

00:08:42.940 --> 00:08:45.530
hold it in documentFragment,
do your manipulations in

00:08:45.530 --> 00:08:51.060
documentFragment, and then put
it back in when you're done.

00:08:51.060 --> 00:08:56.710
You only get the reflow when
you are manipulating the

00:08:56.710 --> 00:08:57.285
actual DOM.

00:08:57.285 --> 00:08:58.620
And when things are off
DOM, you're fine.

00:08:58.620 --> 00:09:02.970
So that one you're fine in
IE and everywhere else.

00:09:02.970 --> 00:09:03.400
Cool?

00:09:03.400 --> 00:09:07.460
OK, there's a few more resources
I would like you to

00:09:07.460 --> 00:09:09.350
just check out if you're
into this stuff.

00:09:09.350 --> 00:09:11.400
Stoyan Stefanov has done
a lot of research

00:09:11.400 --> 00:09:13.770
on reflows and repaints.

00:09:13.770 --> 00:09:16.140
and so he's got some
great stuff here.

00:09:16.140 --> 00:09:21.420
BrowserScope has a few tests to
see what triggers reflows.

00:09:21.420 --> 00:09:23.600
Like we were just seeing,
there's a lot of small details

00:09:23.600 --> 00:09:25.910
that are different
across browsers.

00:09:25.910 --> 00:09:30.030
David Baron had a really great
Google Tech Talk about browser

00:09:30.030 --> 00:09:34.320
internals and specifically
aiming that talk at web

00:09:34.320 --> 00:09:35.620
developers.

00:09:35.620 --> 00:09:38.166
And so this is, I think, an
hour-long talk that you

00:09:38.166 --> 00:09:39.070
should check out.

00:09:39.070 --> 00:09:44.195
And WebKit, about five years
ago, did a five-part series

00:09:44.195 --> 00:09:45.730
about how rendering works.

00:09:45.730 --> 00:09:47.020
And it's so cool.

00:09:47.020 --> 00:09:48.210
It's from five years ago.

00:09:48.210 --> 00:09:49.970
But it's totally
relevant today.

00:09:49.970 --> 00:09:53.160
I definitely recommend
checking that out.

00:09:53.160 --> 00:09:54.980
OK, I think we're done
with reflow.

00:09:54.980 --> 00:09:56.950
Let's move on.

00:09:56.950 --> 00:10:00.140
Hardware accelerated
CSS, yeah.

00:10:00.140 --> 00:10:02.410
All right, getting into
some sexy here.

00:10:02.410 --> 00:10:06.890
So we're just going to skip
right into the demo.

00:10:06.890 --> 00:10:11.130
This is Isotope by
David DeSandro.

00:10:11.130 --> 00:10:15.530
Let's see, I'm going to change
the sort a little bit.

00:10:15.530 --> 00:10:17.560
And then I'm going to insert
some new elements.

00:10:20.820 --> 00:10:22.010
Click around here.

00:10:22.010 --> 00:10:22.735
Yeah, like this.

00:10:22.735 --> 00:10:25.000
This is good.

00:10:25.000 --> 00:10:29.490
Even resize the window, and that
responds really nicely.

00:10:29.490 --> 00:10:35.420
So what's actually happening
here is that we're actually

00:10:35.420 --> 00:10:37.940
using CSS transitions and CSS

00:10:37.940 --> 00:10:40.440
transforms to do these changes.

00:10:40.440 --> 00:10:42.830
Now, normally you might think
you're going to manipulate the

00:10:42.830 --> 00:10:44.380
position of where things go.

00:10:44.380 --> 00:10:46.280
And you'll probably be like,
oh, it'll be absolutely

00:10:46.280 --> 00:10:47.330
positioned.

00:10:47.330 --> 00:10:49.730
And then I'll just manipulate
left and top and tell it where

00:10:49.730 --> 00:10:51.160
it's going to go now.

00:10:51.160 --> 00:10:53.560
The trick here is that
we're actually using

00:10:53.560 --> 00:10:55.610
2D transforms translate.

00:10:55.610 --> 00:10:57.760
So we're using
webkit-transform:translate,

00:10:57.760 --> 00:11:02.050
and then we're just changing
the x and y of translate.

00:11:02.050 --> 00:11:08.380
Then we're also using
a CSS transition.

00:11:08.380 --> 00:11:14.300
And as a result, we're able to
get all these operations

00:11:14.300 --> 00:11:18.630
hardware accelerated, which
means super-high frame rates,

00:11:18.630 --> 00:11:20.780
really high-fidelity animations,
and they look

00:11:20.780 --> 00:11:22.070
basically as good as they can.

00:11:22.070 --> 00:11:24.910
You're writing it in a
declarative way so that the

00:11:24.910 --> 00:11:27.340
browser can be like, oh,
yeah, I got this.

00:11:27.340 --> 00:11:27.920
Let me take this.

00:11:27.920 --> 00:11:30.625
I'm going to take this down to
my friend the GPU and optimize

00:11:30.625 --> 00:11:31.480
this for you.

00:11:31.480 --> 00:11:34.880
And so it's going to
look really good.

00:11:34.880 --> 00:11:37.990
The cool thing here in Isotope
is that David wrote it in a

00:11:37.990 --> 00:11:41.420
way that it can detect support
for transforms and

00:11:41.420 --> 00:11:42.190
transitions.

00:11:42.190 --> 00:11:44.280
And if there's not support,
then it'll go back to a

00:11:44.280 --> 00:11:47.240
jQuery-based animation style.

00:11:47.240 --> 00:11:49.700
So if your browser is new and
good, we're going to do the

00:11:49.700 --> 00:11:50.570
right thing.

00:11:50.570 --> 00:11:55.230
And if it's a bit older, it'll
still look OK, but not as high

00:11:55.230 --> 00:11:57.920
fidelity as possible.

00:11:57.920 --> 00:12:02.190
So this is kind of the power
of animations of

00:12:02.190 --> 00:12:03.440
hardware-accelerated CSS.

00:12:06.270 --> 00:12:11.620
Now, those were 2D transforms,
and everything was just moving

00:12:11.620 --> 00:12:13.260
around on a 2D plane.

00:12:13.260 --> 00:12:18.700
And normally, 2D transforms and
operations on the 2D plane

00:12:18.700 --> 00:12:22.070
don't get hardware-accelerated
by browsers and by WebKit

00:12:22.070 --> 00:12:24.450
specifically.

00:12:24.450 --> 00:12:25.690
But there's a trick.

00:12:25.690 --> 00:12:28.380
And there's a trick to make
the browser do it.

00:12:28.380 --> 00:12:32.012
Let me show this clip
from Remy Sharp.

00:12:32.012 --> 00:12:32.350
[VIDEO PLAYBACK]

00:12:32.350 --> 00:12:37.350
-OK what I'm about to show
you is a CSS animation.

00:12:37.350 --> 00:12:41.360
And it's engaged using
JavaScript and just the normal

00:12:41.360 --> 00:12:42.850
touch gestures.

00:12:42.850 --> 00:12:46.940
But the first effect I'm going
to show you now is one without

00:12:46.940 --> 00:12:48.950
a 3D transform.

00:12:48.950 --> 00:12:53.010
So this is just doing a scale
and nothing else.

00:12:53.010 --> 00:12:54.445
And you see it's just
a little bit jumpy.

00:12:54.445 --> 00:12:57.870
That's the actual animation
jumping.

00:12:57.870 --> 00:13:01.550
And if I show you the same
version but just with the

00:13:01.550 --> 00:13:05.060
translate3d set on the element
that I'm zooming, you can see

00:13:05.060 --> 00:13:06.750
it's completely smooth.

00:13:06.750 --> 00:13:09.070
And all I've done is
said the image--

00:13:09.070 --> 00:13:12.000
so the image element that I'm
pinching and zooming on, I've

00:13:12.000 --> 00:13:14.725
just added a CSS property
to say translate 3D.

00:13:14.725 --> 00:13:15.410
[END VIDEO PLAYBACK]

00:13:15.410 --> 00:13:19.410
Yeah, so that's it.

00:13:19.410 --> 00:13:21.440
It's kind of a total hack.

00:13:21.440 --> 00:13:26.220
You can use either WebKit
transform, translateZ(0) or do

00:13:26.220 --> 00:13:27.160
translate3d.

00:13:27.160 --> 00:13:29.930
Depending on your use case, one
will probably make more

00:13:29.930 --> 00:13:31.180
sense for you.

00:13:33.170 --> 00:13:36.450
And all of a sudden, the
browser's like, oh, cool.

00:13:36.450 --> 00:13:39.990
Let's throw this on the GPU.

00:13:39.990 --> 00:13:43.280
And as a result, we can get
much higher-fidelity

00:13:43.280 --> 00:13:46.535
manipulation on the 2D
plane, just like

00:13:46.535 --> 00:13:47.265
we saw in this video.

00:13:47.265 --> 00:13:49.860
It's pretty cool.

00:13:49.860 --> 00:13:53.460
There's a few really good ways
when you're working with this

00:13:53.460 --> 00:13:55.530
kind of stuff to debug it
a little bit better.

00:13:55.530 --> 00:14:01.360
Over in Safari, there's a
development flag to turn on

00:14:01.360 --> 00:14:02.010
some colors.

00:14:02.010 --> 00:14:04.450
This actually stands
for core animation.

00:14:04.450 --> 00:14:09.956
I'm going to load this up over
the iPhone simulator.

00:14:09.956 --> 00:14:12.090
And I'm actually going
to load this page.

00:14:12.090 --> 00:14:16.950
This is a tutorial on HTML5Rocks
by Malte Ubl.

00:14:16.950 --> 00:14:19.520
And we're going to show
this little demo here.

00:14:19.520 --> 00:14:22.220
And what we're actually doing is
we're detecting support for

00:14:22.220 --> 00:14:23.630
CSS transitions and
transforms.

00:14:23.630 --> 00:14:27.810
And if we have support, we're
just going to use a transform

00:14:27.810 --> 00:14:28.670
along with the transition.

00:14:28.670 --> 00:14:30.200
Otherwise, we use
jQuery animate.

00:14:30.200 --> 00:14:34.210
So here in Chrome, we're using
a transition transform.

00:14:34.210 --> 00:14:37.250
And you see that moves
across the screen.

00:14:37.250 --> 00:14:42.050
I'm going to show this in
the iPhone simulator.

00:14:42.050 --> 00:14:46.090
You can see the OS
is accelerated.

00:14:48.730 --> 00:14:51.160
Scroll down, here we go.

00:14:51.160 --> 00:14:52.455
So I'm just going to click.

00:14:52.455 --> 00:14:53.760
And you'll see-- yeah.

00:14:58.275 --> 00:15:02.320
And the trick here is that
we actually use that

00:15:02.320 --> 00:15:04.210
translateZ(0)--

00:15:04.210 --> 00:15:07.400
we call it the silver
bullet here--

00:15:07.400 --> 00:15:13.288
trick to make that hardware
acceleration happen.

00:15:15.980 --> 00:15:19.990
Over in Chrome, we have a
somewhat similar thing.

00:15:19.990 --> 00:15:22.480
Over in about:flags, we
have this setting.

00:15:22.480 --> 00:15:24.340
And let me bring this up.

00:15:24.340 --> 00:15:27.550
In about:flags, there's a bunch
of really crazy stuff.

00:15:27.550 --> 00:15:29.775
I recommend you dig into
this some time.

00:15:29.775 --> 00:15:32.760
We have composited render
layer borders.

00:15:32.760 --> 00:15:36.100
And well, let me just show
you what it does.

00:15:36.100 --> 00:15:39.980
Here's this presentation that
we've been looking at but with

00:15:39.980 --> 00:15:43.370
this setting turned on.

00:15:43.370 --> 00:15:47.030
And you can see we get borders
around of all the layers that

00:15:47.030 --> 00:15:49.580
are composited.

00:15:49.580 --> 00:15:52.450
Pretty cool.

00:15:52.450 --> 00:15:55.430
So this helps a lot to just
verify that yes, this actually

00:15:55.430 --> 00:15:58.690
is being composited
on the GPU.

00:15:58.690 --> 00:16:02.360
And then also in this 3D case,
we have a nice little debug

00:16:02.360 --> 00:16:04.750
view of what's going on.

00:16:04.750 --> 00:16:08.320
I will point out that this
used to happen as a

00:16:08.320 --> 00:16:10.000
command line flag.

00:16:10.000 --> 00:16:12.300
So it didn't used to be nice and
handy in this about:flags.

00:16:12.300 --> 00:16:16.040
But yes, it used to have to run
the Chrome executable with

00:16:16.040 --> 00:16:17.060
a command line flag.

00:16:17.060 --> 00:16:20.670
And this page over on Peter
Beverloo's site maintains a

00:16:20.670 --> 00:16:25.440
list of all the active command
line switches or flags.

00:16:25.440 --> 00:16:27.700
And so I recommend you
checking this out.

00:16:27.700 --> 00:16:31.190
One of the ones in here
is a show-paint-rects.

00:16:31.190 --> 00:16:34.590
And so this actually draws
little borders whenever a

00:16:34.590 --> 00:16:38.840
section of the DOM
gets repainted.

00:16:38.840 --> 00:16:40.980
Why that's interesting is
because you want to know--

00:16:40.980 --> 00:16:42.790
kind of when we were talking
about reflows, you want to

00:16:42.790 --> 00:16:46.100
know exactly how much of the
DOM is being invalidated or

00:16:46.100 --> 00:16:48.040
the render tree is
being invalidated

00:16:48.040 --> 00:16:49.140
when there's a change.

00:16:49.140 --> 00:16:52.030
And so with show-paint-rects,
you can see that when you make

00:16:52.030 --> 00:16:55.730
a change, only the part that
needs to be recalculated and

00:16:55.730 --> 00:16:58.580
repainted is being changed
rather than a much larger

00:16:58.580 --> 00:17:00.670
chunk, which would be
kind of unexpected.

00:17:00.670 --> 00:17:05.950
So show-paint-rects is another
very helpful flag to use when

00:17:05.950 --> 00:17:08.690
you're debugging some of this
advanced rendering stuff.

00:17:19.220 --> 00:17:24.990
This tutorial has a number of
other recommendations around

00:17:24.990 --> 00:17:29.450
graphics optimizations that
you can make and also digs

00:17:29.450 --> 00:17:30.850
into JavaScript profiling.

00:17:30.850 --> 00:17:33.800
So dig into that a little bit
more if you're looking to eek

00:17:33.800 --> 00:17:36.410
out some better performance of
your HTML5 app and these

00:17:36.410 --> 00:17:39.850
recommendations are not
good enough for you.

00:17:39.850 --> 00:17:42.780
But next we're going to dig into
requestAnimationFrame.

00:17:42.780 --> 00:17:48.510
So requestAnimationFrame
basically came about because

00:17:48.510 --> 00:17:53.080
browsers were like, hey, we
know that you're doing

00:17:53.080 --> 00:17:54.650
animation in the browser.

00:17:54.650 --> 00:17:57.580
And we know that you're just
abusing setTimeout and

00:17:57.580 --> 00:18:00.100
setInterval loops to do it.

00:18:00.100 --> 00:18:03.882
And that's not cool.

00:18:03.882 --> 00:18:05.380
It's not really cool.

00:18:05.380 --> 00:18:05.930
Because you know what?

00:18:05.930 --> 00:18:10.160
A browser can optimize animation
better than you

00:18:10.160 --> 00:18:14.080
writing a setInterval loop, just
trying to peg the CPU as

00:18:14.080 --> 00:18:15.980
fast as it will go.

00:18:15.980 --> 00:18:17.490
Browser is smarter.

00:18:17.490 --> 00:18:22.120
So one of the things that it can
do is it can batch things

00:18:22.120 --> 00:18:24.450
into a single reflow
and repaint cycle.

00:18:24.450 --> 00:18:29.215
So let's say that you had a
JavaScript-based animation.

00:18:29.215 --> 00:18:31.180
You had an absolute position
element, and you're updating

00:18:31.180 --> 00:18:34.450
the left and top or something
like that.

00:18:34.450 --> 00:18:36.750
The browser can now synchronize
that along with

00:18:36.750 --> 00:18:38.950
the concurrently running
CSS transition.

00:18:38.950 --> 00:18:42.060
Or if you had some SVG SMIL
animation running at the same

00:18:42.060 --> 00:18:44.575
time, it can kind of make sure
that those are all going at

00:18:44.575 --> 00:18:47.130
the same time.

00:18:47.130 --> 00:18:51.430
It's going to optimize it for 60
frames per second, which is

00:18:51.430 --> 00:18:54.160
the refresh rate of
most displays.

00:18:54.160 --> 00:18:56.130
And so you're going to get the
best frame rate possible.

00:18:56.130 --> 00:19:01.470
60 Hertz is kind of the perfect
target for everything

00:19:01.470 --> 00:19:03.340
that you want going
on in the browser.

00:19:03.340 --> 00:19:07.470
And the really cool thing is
that you're really friendly to

00:19:07.470 --> 00:19:11.280
your users' batteries.

00:19:11.280 --> 00:19:17.280
Because what happens is that if
the tab is not visible, it

00:19:17.280 --> 00:19:18.530
gets skipped.

00:19:18.530 --> 00:19:21.280
So let me load this
up right here.

00:19:21.280 --> 00:19:23.610
This is a--

00:19:23.610 --> 00:19:24.860
whoa!

00:19:31.765 --> 00:19:33.140
Yeah, OK, here we go.

00:19:33.140 --> 00:19:36.540
So we got this WebGL demo.

00:19:36.540 --> 00:19:41.380
And you see here we got a lot
of action over on the GPU.

00:19:41.380 --> 00:19:44.890
And this is the JavaScript
running inside this page.

00:19:44.890 --> 00:19:48.150
It's pretty heavy.

00:19:48.150 --> 00:19:49.790
Gonna move this around.

00:19:49.790 --> 00:19:51.420
Now I'm just going to switch
to another tab.

00:19:54.030 --> 00:19:55.280
You see that instantly
dropped.

00:20:00.360 --> 00:20:01.890
Because the
requestAnimationFrame is being

00:20:01.890 --> 00:20:05.155
used, the browser is like,
hey, you're not even

00:20:05.155 --> 00:20:06.060
viewing this tab.

00:20:06.060 --> 00:20:10.140
We don't need to be wasting the
browser, the CPU, the GPU

00:20:10.140 --> 00:20:13.330
in order to make this happen
because we know that they're

00:20:13.330 --> 00:20:13.960
not looking at it.

00:20:13.960 --> 00:20:19.870
Whereas if this field demo had
been using a timer loop, it'd

00:20:19.870 --> 00:20:20.260
still be going.

00:20:20.260 --> 00:20:23.310
It would still be eating
down my battery here.

00:20:23.310 --> 00:20:26.780
So I bring that back up.

00:20:26.780 --> 00:20:36.740
And our use of the
CPU returns.

00:20:36.740 --> 00:20:39.690
So if you're doing any
sort of animation,

00:20:39.690 --> 00:20:40.810
use this if you can.

00:20:40.810 --> 00:20:43.000
This actually just
landed in jQuery.

00:20:43.000 --> 00:20:45.050
So this is going to
be in jQuery 1.6.

00:20:45.050 --> 00:20:46.800
And it's also in Grit.

00:20:46.800 --> 00:20:51.610
And it's in a few other
libraries at this point.

00:20:51.610 --> 00:20:53.010
So I definitely recommend it.

00:20:53.010 --> 00:20:56.380
This is available in both
Chrome and also in

00:20:56.380 --> 00:20:59.380
Firefox, Firefox 4.

00:20:59.380 --> 00:21:06.450
Over on my blog, we have a
nice little shim layer to

00:21:06.450 --> 00:21:07.010
handle this.

00:21:07.010 --> 00:21:09.690
We basically feature detect
to see if the

00:21:09.690 --> 00:21:10.900
native support is present.

00:21:10.900 --> 00:21:14.280
And if not, we're going to use
a setTimeout loop that

00:21:14.280 --> 00:21:16.510
optimizes for 60 frames
per second.

00:21:16.510 --> 00:21:19.400
And that's how you use it.

00:21:22.170 --> 00:21:23.380
Cool.

00:21:23.380 --> 00:21:26.360
Web Workers, the idea here--

00:21:26.360 --> 00:21:28.090
and I don't want to cover
this too much.

00:21:28.090 --> 00:21:30.560
The idea with Web Workers that
you're probably familiar with

00:21:30.560 --> 00:21:35.190
is we want to move heavy
computation, expensive tasks

00:21:35.190 --> 00:21:37.110
outside of the UI thread.

00:21:37.110 --> 00:21:39.180
Pretty much all JavaScript
runs in the UI thread.

00:21:39.180 --> 00:21:42.390
And if something is taking a
long time, the user can't

00:21:42.390 --> 00:21:43.180
interact with the page.

00:21:43.180 --> 00:21:44.780
The page becomes
non-responsive.

00:21:44.780 --> 00:21:49.080
And in the case of Chrome, we
get a sad, freezing cold tab.

00:21:49.080 --> 00:21:50.940
He's so cold.

00:21:50.940 --> 00:21:51.910
And we don't want that.

00:21:51.910 --> 00:21:54.105
No, that's bad.

00:21:54.105 --> 00:21:55.030
And we want to avoid that.

00:21:55.030 --> 00:21:57.020
And without Web Workers,
we can.

00:22:00.290 --> 00:22:00.800
I'm going to show this.

00:22:00.800 --> 00:22:02.960
This is a little bit more
advanced use of Web Worker.

00:22:02.960 --> 00:22:05.780
But I think it's really cool.

00:22:05.780 --> 00:22:09.970
First, normally the way that
you instantiate a brand-new

00:22:09.970 --> 00:22:12.950
Web Worker is you would
be like, new Worker,

00:22:12.950 --> 00:22:16.980
myworker.js, there.

00:22:16.980 --> 00:22:19.750
This is where the code
is going now.

00:22:19.750 --> 00:22:21.340
You pass it a file name.

00:22:21.340 --> 00:22:23.020
And then it goes and
gets that file.

00:22:23.020 --> 00:22:24.310
And then it uses that file.

00:22:24.310 --> 00:22:26.380
And that's your worker.

00:22:26.380 --> 00:22:28.710
It has its limitations.

00:22:28.710 --> 00:22:32.050
This here is an example
of creating a

00:22:32.050 --> 00:22:34.300
worker on the fly, basically.

00:22:34.300 --> 00:22:36.550
So here we have-- oops--

00:22:36.550 --> 00:22:39.210
our worker code, and it's
a script of type worker.

00:22:39.210 --> 00:22:41.950
So this is going to get skipped
by the browser.

00:22:41.950 --> 00:22:45.130
So we're just kind of using it
to hold some text right now.

00:22:45.130 --> 00:22:47.650
And then down here on our
script, we're going to

00:22:47.650 --> 00:22:48.860
use the file API.

00:22:48.860 --> 00:22:51.190
And we're going to use
BlobBuilder, create a new

00:22:51.190 --> 00:22:52.230
BlobBuilder.

00:22:52.230 --> 00:22:55.820
Then we're going to grab the
text of this script node,

00:22:55.820 --> 00:22:57.490
throw that into the blob.

00:22:57.490 --> 00:23:00.220
And then when we create our
worker, we're going to use

00:23:00.220 --> 00:23:04.940
URL.createobject URL with the
blob, and check that in.

00:23:04.940 --> 00:23:07.870
Essentially, we create a file
on the fly and then

00:23:07.870 --> 00:23:09.500
instantiate the worker
with that.

00:23:09.500 --> 00:23:11.840
And so now we have the advantage
of having a little

00:23:11.840 --> 00:23:14.490
bit more control over the worker
in case we want to

00:23:14.490 --> 00:23:16.780
change it or something
like that.

00:23:16.780 --> 00:23:19.260
And then also we avoid
an HTTP run trip.

00:23:19.260 --> 00:23:24.600
So from a network layer,
we're a little bit more

00:23:24.600 --> 00:23:25.850
optimized as well.

00:23:25.850 --> 00:23:29.020
So that is just kind of a cool
example of where you can go

00:23:29.020 --> 00:23:32.470
with workers combined
with the file API.

00:23:32.470 --> 00:23:35.480
Some places where you might
want to use workers, text

00:23:35.480 --> 00:23:38.460
formatting of a long document,
syntax highlighting maybe,

00:23:38.460 --> 00:23:42.460
maybe not, depends
on your use case.

00:23:42.460 --> 00:23:46.600
If you're doing heavy image
processing or dealing with

00:23:46.600 --> 00:23:50.520
large arrays, also the audio
API, for instance, the WebKit

00:23:50.520 --> 00:23:55.630
Web Audio API or the Mozilla
Audio Data API, depending on

00:23:55.630 --> 00:23:57.540
kind of the analysis that you're
running, a worker might

00:23:57.540 --> 00:23:58.640
make sense.

00:23:58.640 --> 00:24:01.100
Also, the FileSystem API, which
is available in Chrome,

00:24:01.100 --> 00:24:04.390
has had support for workers
for a while now.

00:24:04.390 --> 00:24:05.180
And this is really good.

00:24:05.180 --> 00:24:07.450
You might be dealing with large
binary data, and you

00:24:07.450 --> 00:24:09.170
don't want that holding up
the UI thread at all.

00:24:09.170 --> 00:24:12.300
You want to just let that
happen as it does.

00:24:12.300 --> 00:24:15.130
And so letting Web Workers
handle the interaction with

00:24:15.130 --> 00:24:18.440
the file system is the right
way to go there.

00:24:18.440 --> 00:24:20.760
Cool.

00:24:20.760 --> 00:24:24.282
Want to touch on JSPERF
real quick.

00:24:24.282 --> 00:24:25.245
Yeah, this is real cool.

00:24:25.245 --> 00:24:30.100
So JSPERF, if you don't
know, is a site

00:24:30.100 --> 00:24:31.900
for performance tests.

00:24:31.900 --> 00:24:33.620
And so we have a few things
going on here.

00:24:33.620 --> 00:24:36.580
We have a nice human
readable URL.

00:24:36.580 --> 00:24:41.030
And oftentimes, with a URL like
join-concat, this is now

00:24:41.030 --> 00:24:44.930
the definitive join versus
concat string

00:24:44.930 --> 00:24:46.400
concatenation test.

00:24:46.400 --> 00:24:48.670
And there's revisions as well.

00:24:48.670 --> 00:24:52.000
So within the page we have our
variations of the code that we

00:24:52.000 --> 00:24:52.870
want to test.

00:24:52.870 --> 00:24:56.840
So this is the age-old
concatenation with plus equals

00:24:56.840 --> 00:24:59.340
or array.join, which
is faster.

00:24:59.340 --> 00:25:03.440
And I believe it's IE 6 and 7
are faster with the array

00:25:03.440 --> 00:25:06.330
join, and absolutely everyone
else is faster with a

00:25:06.330 --> 00:25:10.140
straight-up concatenation
augmented in a string.

00:25:10.140 --> 00:25:15.170
So don't use a array.join
anymore.

00:25:15.170 --> 00:25:19.340
But the nice thing here is that
we can run the test and

00:25:19.340 --> 00:25:21.890
get our results and figure
out kind of what it is.

00:25:21.890 --> 00:25:25.340
And so the site is used
by a lot of people.

00:25:25.340 --> 00:25:27.950
In fact, jQuery has been
using it for the

00:25:27.950 --> 00:25:30.540
library development recently.

00:25:30.540 --> 00:25:32.200
So let's say there's
a few different

00:25:32.200 --> 00:25:34.510
variations of DOM traversal.

00:25:34.510 --> 00:25:37.570
The nice thing here is that we
can do our tests with a few

00:25:37.570 --> 00:25:40.760
variations, kind of see what's
going on, and then the results

00:25:40.760 --> 00:25:44.490
get reported to BrowserScope,
which kind of handles what

00:25:44.490 --> 00:25:47.330
user agent it's coming from,
what are the numbers, and kind

00:25:47.330 --> 00:25:50.890
of give us a really
comprehensive table of what

00:25:50.890 --> 00:25:53.760
the story is across all browsers
and where is each

00:25:53.760 --> 00:25:56.400
thing faster.

00:25:56.400 --> 00:25:58.390
And so I'm running it here.

00:25:58.390 --> 00:26:00.440
This is WebKit Nightly.

00:26:00.440 --> 00:26:03.590
And we see, well, in this case,
we have these traversal,

00:26:03.590 --> 00:26:06.090
and we have some different
results.

00:26:09.200 --> 00:26:11.690
So JSPERF is really good.

00:26:11.690 --> 00:26:15.700
I like it a lot because it's
kind of like the clearinghouse

00:26:15.700 --> 00:26:18.870
of performance best practices.

00:26:18.870 --> 00:26:22.200
People will say, oh, well, you
should use triple equals

00:26:22.200 --> 00:26:26.040
instead of double equals
because it's faster.

00:26:26.040 --> 00:26:28.280
And now we can actually find
out, hey, are they right?

00:26:28.280 --> 00:26:31.220
And are they right across
all browsers or not?

00:26:31.220 --> 00:26:35.760
It's powered by benchmark.js,
which is a very finely tuned

00:26:35.760 --> 00:26:39.145
and calibrated benchmarking
script that works not only in

00:26:39.145 --> 00:26:43.300
the browser but in Node and
Narwhal and Ringo and all

00:26:43.300 --> 00:26:45.830
these different environments
and is definitely the right

00:26:45.830 --> 00:26:49.000
way to be benchmarking different
variations of code.

00:26:52.360 --> 00:26:55.720
So a quick touch on the
HTML5 Boilerplate.

00:26:55.720 --> 00:26:59.040
It's a project that
I work with.

00:26:59.040 --> 00:27:03.090
And recently, we put
out a build tool.

00:27:03.090 --> 00:27:05.515
The build script is just
an Ant script.

00:27:05.515 --> 00:27:08.290
But the cool thing is that when
you use it alongside one

00:27:08.290 --> 00:27:10.160
of the web server
configurations, like for

00:27:10.160 --> 00:27:15.830
Apache or Nginx, you're
basically going to get a 90%

00:27:15.830 --> 00:27:21.840
on your score for Google
PageSpeed or YSlow.

00:27:21.840 --> 00:27:23.860
There's all these things
that you've heard.

00:27:23.860 --> 00:27:25.470
And you're supposed to be
doing like combining and

00:27:25.470 --> 00:27:27.270
minifying your JavaScript,
your CSS, your image

00:27:27.270 --> 00:27:29.430
optimization.

00:27:29.430 --> 00:27:30.620
And the script does
all these things.

00:27:30.620 --> 00:27:33.050
It also does HTML
minification.

00:27:33.050 --> 00:27:36.220
It revs your file names so that
we can cachebust when

00:27:36.220 --> 00:27:37.350
there's a new version.

00:27:37.350 --> 00:27:40.080
And then we upgrade the web
server configuration to use

00:27:40.080 --> 00:27:43.630
far Future and Expires headers
because now we have unique

00:27:43.630 --> 00:27:46.060
file names.

00:27:46.060 --> 00:27:48.410
So it does all these
things for you.

00:27:48.410 --> 00:27:55.360
And we can basically take what
was a C and B grade website

00:27:55.360 --> 00:27:59.180
and bring it up to some
much higher scores.

00:27:59.180 --> 00:28:04.900
So I definitely recommend you
dig into that if you'd like to

00:28:04.900 --> 00:28:08.600
not have to repeat all these
performance optimizations

00:28:08.600 --> 00:28:10.060
every time you make a site.

00:28:10.060 --> 00:28:14.520
And let a script handle
it for you.

00:28:14.520 --> 00:28:17.216
All right, I guess
that's it for me.

00:28:17.216 --> 00:28:21.180
If you have any questions, you
can leave a comment or hit me

00:28:21.180 --> 00:28:22.200
up on Twitter.

00:28:22.200 --> 00:28:26.500
I'd also recommend to check
out html5rocks.com.

00:28:26.500 --> 00:28:29.190
We have a lot of tutorials on
there of really good stuff.

00:28:29.190 --> 00:28:31.710
And we have a lot that are
focused on performance and a

00:28:31.710 --> 00:28:34.340
lot of the things that I've been
talking about here, so

00:28:34.340 --> 00:28:36.870
plenty more to read
and learn there.

00:28:36.870 --> 00:28:38.130
So I guess that's it.

00:28:38.130 --> 00:28:39.380
Thank you very much
for watching.

