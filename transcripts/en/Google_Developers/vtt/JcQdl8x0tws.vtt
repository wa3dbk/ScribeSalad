WEBVTT
Kind: captions
Language: en

00:00:30.360 --> 00:00:32.759
PETE LEPAGE: Welcome, everybody,
to another edition

00:00:32.759 --> 00:00:36.080
of our "Chrome Apps Office
Hours." We've got a really

00:00:36.080 --> 00:00:39.870
great show today with a special
guest joining us from

00:00:39.870 --> 00:00:40.890
Mountain View.

00:00:40.890 --> 00:00:43.980
John McCutchan is going to be
talking about using Native

00:00:43.980 --> 00:00:48.840
Client and Acceleration Modules
within Chrome Apps.

00:00:48.840 --> 00:00:51.560
So really allowing you to take
a whole bunch of the stuff

00:00:51.560 --> 00:00:54.510
that you're used to being able
to do with Native Client and

00:00:54.510 --> 00:00:56.860
put that into a Chrome app.

00:00:56.860 --> 00:00:58.810
So, with that, John, I'll
turn it over to you.

00:00:58.810 --> 00:01:01.800
I'll let you introduce yourself
and talk about Chrome

00:01:01.800 --> 00:01:03.736
Apps a little bit.

00:01:03.736 --> 00:01:04.769
JOHN MCCUTCHAN: Hey, everyone.

00:01:04.769 --> 00:01:08.350
I'm John McCutchan, and I work
on the Native Client team as a

00:01:08.350 --> 00:01:10.230
developer programs engineer.

00:01:10.230 --> 00:01:12.640
And today I'm going to talk
about how you can really

00:01:12.640 --> 00:01:16.490
accelerate the performance
inside your Chrome Apps.

00:01:16.490 --> 00:01:20.960
So what are Chrome
Packaged Apps?

00:01:20.960 --> 00:01:24.120
I've taken this text snippet
here straight off of the

00:01:24.120 --> 00:01:25.640
Chrome Apps developer website.

00:01:25.640 --> 00:01:28.280
And it says that "Chrome apps
deliver an experience as

00:01:28.280 --> 00:01:31.830
capable as a native app but
as safe as a web page.

00:01:31.830 --> 00:01:35.680
They're built with open web
technologies, like HTML5,

00:01:35.680 --> 00:01:37.910
JavaScript, and CSS.

00:01:37.910 --> 00:01:42.180
But they look and behave
like native apps.

00:01:42.180 --> 00:01:44.320
And they also have native-like
capabilities." And in the

00:01:44.320 --> 00:01:47.060
lower right hand corner of the
slide, you can see a screen

00:01:47.060 --> 00:01:50.860
shot of a Chrome Packaged App,
which is launching from the

00:01:50.860 --> 00:01:55.390
Start menu, and looks and feels
just like a native app.

00:01:55.390 --> 00:01:59.440
But the question remains is,
how do they perform?

00:01:59.440 --> 00:02:02.380
Do they offer native
performance, which you come to

00:02:02.380 --> 00:02:05.580
expect if something is
a native application?

00:02:05.580 --> 00:02:07.820
Let's quickly run through
and see how some

00:02:07.820 --> 00:02:09.374
common algorithms perform.

00:02:11.970 --> 00:02:14.200
So right here we're looking
at a graph showing the

00:02:14.200 --> 00:02:19.250
performance of C++ Bullet
Physics engine, which is a 3D

00:02:19.250 --> 00:02:23.720
physics engine which has been
used in many AAA video games.

00:02:23.720 --> 00:02:26.850
Compared to the JavaScript
performance of the same

00:02:26.850 --> 00:02:29.180
library, that would--

00:02:29.180 --> 00:02:32.960
you can't really see the native
C++ performance on this

00:02:32.960 --> 00:02:35.380
graph because it's just
so much faster.

00:02:35.380 --> 00:02:37.930
But let me zoom in.

00:02:37.930 --> 00:02:42.390
So you can start to see a
clearer picture here.

00:02:42.390 --> 00:02:45.690
We're seeing something that
looks like maybe 10 or 100

00:02:45.690 --> 00:02:49.070
times slower performance from
the JavaScript side

00:02:49.070 --> 00:02:51.050
than the C++ side.

00:02:51.050 --> 00:02:54.500
And if we switch over and we
look at GZIP decompression

00:02:54.500 --> 00:02:56.190
timings, again, we see
the same story.

00:02:58.850 --> 00:03:01.900
Native performance is remarkably
fast compared to

00:03:01.900 --> 00:03:05.120
the JavaScript equivalent.

00:03:05.120 --> 00:03:10.820
And again, we see that with the
GZIP compression timings.

00:03:10.820 --> 00:03:13.740
What's interesting here is that
it's remarkable to me

00:03:13.740 --> 00:03:15.850
that you can do this
in JavaScript.

00:03:15.850 --> 00:03:18.820
But you can still do it so
much faster outside of

00:03:18.820 --> 00:03:20.250
JavaScript.

00:03:20.250 --> 00:03:23.770
So how do these Chrome Packaged
Apps perform?

00:03:23.770 --> 00:03:26.740
Well, JavaScript applications
are, on average, in order of

00:03:26.740 --> 00:03:29.620
magnitude, slower than
native applications.

00:03:29.620 --> 00:03:33.860
So while Chrome Apps are going
to give us these native feel

00:03:33.860 --> 00:03:37.390
and functionality applications,
they just can't

00:03:37.390 --> 00:03:41.240
overcome the performance gap
between JavaScript and C++

00:03:41.240 --> 00:03:43.660
without some help.

00:03:43.660 --> 00:03:46.210
So what if we could have the
best of both worlds?

00:03:46.210 --> 00:03:48.630
A world where we have native
performance where we really

00:03:48.630 --> 00:03:52.440
need it, but we get to write
the majority of the

00:03:52.440 --> 00:03:53.930
application in JavaScript.

00:03:53.930 --> 00:03:55.830
That's exactly what Native
Client Acceleration

00:03:55.830 --> 00:03:57.540
Modules give you.

00:03:57.540 --> 00:03:59.410
You have 90% of your application
written in

00:03:59.410 --> 00:04:00.440
JavaScript.

00:04:00.440 --> 00:04:03.150
This allows your development
to be really flexible.

00:04:03.150 --> 00:04:05.250
You can do your UI
in JavaScript.

00:04:05.250 --> 00:04:06.690
Very fast iteration times.

00:04:06.690 --> 00:04:09.770
It's a great developer
experience.

00:04:09.770 --> 00:04:14.200
Well, the remaining 10%, the 10%
of your application where

00:04:14.200 --> 00:04:18.160
performance really matters, can
be written in C++, often

00:04:18.160 --> 00:04:20.540
using off-the-shelf libraries
that are already written for

00:04:20.540 --> 00:04:25.320
you that you just have to go
and expose to JavaScript.

00:04:25.320 --> 00:04:26.660
C++ gives you performance.

00:04:26.660 --> 00:04:28.790
You can reuse existing code.

00:04:28.790 --> 00:04:32.880
And these modules are reusable
across many applications.

00:04:32.880 --> 00:04:35.450
You can imagine how many
applications could benefit

00:04:35.450 --> 00:04:39.890
from fast decompression or
compression algorithms.

00:04:39.890 --> 00:04:42.500
So Native Client Acceleration
Modules combined with Chrome

00:04:42.500 --> 00:04:46.430
Apps gives you 90% of Chrome App
but the native performance

00:04:46.430 --> 00:04:49.710
where you really need it.

00:04:49.710 --> 00:04:52.220
So what are Native Client
Acceleration Modules?

00:04:52.220 --> 00:04:56.350
Simply put, they expose C++
libraries to the web.

00:04:56.350 --> 00:04:58.510
They're Native Client programs
that are designed to

00:04:58.510 --> 00:04:59.930
communicate with JavaScript.

00:04:59.930 --> 00:05:01.730
They have no user interface
at all.

00:05:01.730 --> 00:05:03.910
They are effectively
libraries.

00:05:03.910 --> 00:05:06.335
And they're a combination
of C++ and JavaScript.

00:05:08.990 --> 00:05:12.410
So for those of you don't know,
what is Native Client?

00:05:12.410 --> 00:05:15.560
Well, it's a secure
C/C++ runtime and

00:05:15.560 --> 00:05:17.840
toolchain for the web.

00:05:17.840 --> 00:05:23.260
It runs existing C/C++
and C# code natively.

00:05:23.260 --> 00:05:24.430
It's completely secure.

00:05:24.430 --> 00:05:25.660
It's sandboxed.

00:05:25.660 --> 00:05:26.860
It's safe.

00:05:26.860 --> 00:05:29.750
And it's available within
Chrome today.

00:05:29.750 --> 00:05:33.350
What I'm hoping a lot of the
Chrome App developers don't

00:05:33.350 --> 00:05:36.320
already know is that you can
actually use Native Client in

00:05:36.320 --> 00:05:39.960
combination with your
Chrome Apps.

00:05:39.960 --> 00:05:42.920
And Native Client interacts with
Chrome through a Pepper

00:05:42.920 --> 00:05:46.930
API, which exposes all sorts of
functionality, like OpenGL,

00:05:46.930 --> 00:05:50.680
Gamepad support, Mouse Lock,
Full Screen, et cetera.

00:05:50.680 --> 00:05:54.070
PETE LEPAGE: For folks who don't
know, what is Pepper?

00:05:54.070 --> 00:05:57.920
JOHN MCCUTCHAN: Pepper is a
plug-in interface to Chrome.

00:05:57.920 --> 00:06:04.530
And it exposes functionality to
plug-ins that Chrome hosts.

00:06:04.530 --> 00:06:09.500
So Chrome hosts an OpenGL,
a Gamepad library, some

00:06:09.500 --> 00:06:12.070
functionality to go
full screen and

00:06:12.070 --> 00:06:13.360
come out of full screen.

00:06:13.360 --> 00:06:15.350
And plug-ins can access that.

00:06:15.350 --> 00:06:19.860
Native Client Modules are
effectively sitting on top of

00:06:19.860 --> 00:06:21.490
the Pepper plug-in interface.

00:06:21.490 --> 00:06:24.110
So that's how they implement
their functionality that

00:06:24.110 --> 00:06:26.290
depends on Chrome.

00:06:26.290 --> 00:06:26.920
PETE LEPAGE: OK, cool.

00:06:26.920 --> 00:06:29.830
So you've got Native Client
that interacts with the

00:06:29.830 --> 00:06:33.740
Pepper, so that way it's an easy
way for developers to get

00:06:33.740 --> 00:06:34.850
access to these things?

00:06:34.850 --> 00:06:36.730
JOHN MCCUTCHAN: Yes, yes.

00:06:36.730 --> 00:06:38.095
It's very secure, very safe.

00:06:40.810 --> 00:06:43.460
So if you wanted to develop a
Native Client application,

00:06:43.460 --> 00:06:45.330
what's the workflow
look like, then?

00:06:45.330 --> 00:06:46.990
You take your C++ code.

00:06:46.990 --> 00:06:49.210
You run it through the Native
Client compiler,

00:06:49.210 --> 00:06:51.100
which is just GCC.

00:06:51.100 --> 00:06:54.040
And the output of that is a
Native Client EXE and a

00:06:54.040 --> 00:06:55.270
manifest file.

00:06:55.270 --> 00:06:58.260
The manifest file describes some
dependencies that your

00:06:58.260 --> 00:07:02.160
application has and any
other requirements.

00:07:02.160 --> 00:07:04.650
And then you just insert
an embed tag into your

00:07:04.650 --> 00:07:06.690
HTML, and that's it.

00:07:06.690 --> 00:07:12.870
You go from a fully functional
C++ program that is running

00:07:12.870 --> 00:07:16.140
securely at native performance
inside of Chrome.

00:07:16.140 --> 00:07:19.920
It accesses things like OpenGL
through the Pepper API.

00:07:19.920 --> 00:07:24.130
So you can see a screen shot
here of AirMech, which is a

00:07:24.130 --> 00:07:25.380
fully C++ game.

00:07:28.790 --> 00:07:30.490
So what are Native Client
Acceleration Modules?

00:07:30.490 --> 00:07:32.830
Because what I'm not really
suggesting here is that you

00:07:32.830 --> 00:07:36.170
write an entire Chrome
app in C++.

00:07:36.170 --> 00:07:39.780
What I'm saying is that you
extract the useful performance

00:07:39.780 --> 00:07:45.570
pieces of C++ and expose that
to JavaScript so that your

00:07:45.570 --> 00:07:48.310
Chrome application can offload
some of the really

00:07:48.310 --> 00:07:52.410
performance-intensive
work to C++.

00:07:52.410 --> 00:07:55.360
So the high-level view
looks like this.

00:07:55.360 --> 00:07:57.600
On the left, we have the
Chrome application.

00:07:57.600 --> 00:08:01.180
Then we have a Native Client
Acceleration Module JavaScript

00:08:01.180 --> 00:08:05.270
layer, which exposes the API
to the Chrome application,

00:08:05.270 --> 00:08:07.840
some kind of message-passing
magic.

00:08:07.840 --> 00:08:13.140
And then on the C++ side, a
Native Client Module that

00:08:13.140 --> 00:08:16.080
knows how to communicate with
the JavaScript pair on the

00:08:16.080 --> 00:08:18.660
other side.

00:08:18.660 --> 00:08:20.040
PETE LEPAGE: Now, John, I assume
you're going to tell us

00:08:20.040 --> 00:08:23.800
where that magic comes from,
and that I don't have to go

00:08:23.800 --> 00:08:25.150
figure that out myself.

00:08:25.150 --> 00:08:27.540
JOHN MCCUTCHAN: Yes, yes.

00:08:27.540 --> 00:08:29.710
Later on in the talk, I'm going
to talk about a library

00:08:29.710 --> 00:08:31.680
that I've written that makes
this really easy.

00:08:31.680 --> 00:08:34.220
So you just have to handle
the messages.

00:08:34.220 --> 00:08:37.130
And all the plumbing is
taken care of for you.

00:08:37.130 --> 00:08:38.380
So I want to switch gears.

00:08:38.380 --> 00:08:40.059
PETE LEPAGE: We can just get
everything back and forth.

00:08:40.059 --> 00:08:41.090
Sorry.

00:08:41.090 --> 00:08:41.500
JOHN MCCUTCHAN: No, no.

00:08:41.500 --> 00:08:44.200
Please feel free to
interrupt me.

00:08:44.200 --> 00:08:46.410
So I want to switch gears and
show a demo off here.

00:08:46.410 --> 00:08:49.260
What I'm going to show is
Bullet Physics, which is

00:08:49.260 --> 00:08:52.440
running in C++, combined
with a front end as

00:08:52.440 --> 00:08:54.220
it's written in three.js.

00:08:54.220 --> 00:08:56.240
All of this is sitting inside
of a Chrome app.

00:08:58.920 --> 00:09:00.320
So here I am.

00:09:00.320 --> 00:09:03.100
Everything being drawn here
has been expressed in

00:09:03.100 --> 00:09:06.470
JavaScript or HTML.

00:09:06.470 --> 00:09:10.150
And if I start up the
simulation, you can see here

00:09:10.150 --> 00:09:12.160
that I've got a Jenga pile.

00:09:12.160 --> 00:09:16.140
Let me switch to
maybe 10 rows.

00:09:16.140 --> 00:09:18.710
I can pick up an object
and start playing with

00:09:18.710 --> 00:09:19.960
it and move it around.

00:09:23.220 --> 00:09:24.210
Let me move the screen.

00:09:24.210 --> 00:09:26.850
You can see that there's a
simulation time counter.

00:09:26.850 --> 00:09:31.170
And this is just reporting how
long it takes the C++ code to

00:09:31.170 --> 00:09:33.400
update the physics simulation.

00:09:33.400 --> 00:09:36.960
And right now we're looking at
about 100, 150 microseconds.

00:09:36.960 --> 00:09:41.460
If I switch over to 400 cubes,
that's going to go up.

00:09:41.460 --> 00:09:43.660
It's approaching three
to four milliseconds.

00:09:43.660 --> 00:09:47.600
Now keep in mind that the same
program executing in

00:09:47.600 --> 00:09:49.800
JavaScript is an order
of magnitude slower.

00:09:52.350 --> 00:09:56.100
So we've been able to couple
high-performance C++ physics

00:09:56.100 --> 00:09:58.790
simulations with an interactive
JavaScript

00:09:58.790 --> 00:10:01.760
application sitting inside
of a Chrome app.

00:10:01.760 --> 00:10:05.300
Interactive to the point where
I can grab objects, zoom in

00:10:05.300 --> 00:10:07.070
and zoom out, pick them
up, move them

00:10:07.070 --> 00:10:09.170
around, play with them.

00:10:09.170 --> 00:10:11.760
It's all running at 60 hertz,
something that's just not

00:10:11.760 --> 00:10:14.540
possible in an application
entirely written in

00:10:14.540 --> 00:10:15.790
JavaScript.

00:10:18.690 --> 00:10:21.870
I have a blog post on my
website, which we'll link to

00:10:21.870 --> 00:10:24.730
after the show, which actually
describes a file format where

00:10:24.730 --> 00:10:27.960
you can write your own scenes
and then load them into the

00:10:27.960 --> 00:10:29.380
application.

00:10:29.380 --> 00:10:31.215
So it's kind of a fun little
physics playground.

00:10:41.560 --> 00:10:45.850
So let's play a game.

00:10:45.850 --> 00:10:47.940
What part of that was written
in JavaScript?

00:10:47.940 --> 00:10:50.630
And what part of that
was written in C++?

00:10:50.630 --> 00:10:53.950
So the main loop, JavaScript.

00:10:53.950 --> 00:10:56.050
Rendering, JavaScript.

00:10:56.050 --> 00:11:01.150
Object selection, determining
the rigid body that's under my

00:11:01.150 --> 00:11:03.980
mouse cursor, JavaScript.

00:11:03.980 --> 00:11:06.820
Physics simulation, C++.

00:11:06.820 --> 00:11:08.390
And scene loading is
a combination of

00:11:08.390 --> 00:11:09.940
JavaScript and C++.

00:11:09.940 --> 00:11:12.710
The JavaScript side is
responsible for parsing the

00:11:12.710 --> 00:11:16.400
input file and structuring it
in such a way that the C++

00:11:16.400 --> 00:11:20.540
program expects,
but that's it.

00:11:20.540 --> 00:11:21.470
So it's kind of interesting.

00:11:21.470 --> 00:11:24.730
We get this hyper fast
physics simulation.

00:11:24.730 --> 00:11:27.520
But most of our application
was written in JavaScript.

00:11:27.520 --> 00:11:31.550
So it's very fun to
play around with.

00:11:31.550 --> 00:11:34.500
So how does this demo work
at a really high level?

00:11:34.500 --> 00:11:39.650
Well, in the blue boxes we have
messages that are passed.

00:11:39.650 --> 00:11:42.000
And the arrows are expressing
which direction they're going

00:11:42.000 --> 00:11:46.390
in, with the C++ module
being on the right.

00:11:46.390 --> 00:11:51.703
So at the initialization phase,
a load scene message is

00:11:51.703 --> 00:11:54.370
sent to C++, which describes
the scene, describes the

00:11:54.370 --> 00:11:57.480
initial state of the rigid
bodies, and their shapes, and

00:11:57.480 --> 00:11:57.980
things like that.

00:11:57.980 --> 00:12:00.910
And that gets sent over to the
C++ module, which then

00:12:00.910 --> 00:12:05.950
actually loads the scene into
the Bullet Physics simulation.

00:12:05.950 --> 00:12:09.210
Then at a regular interval, the
JavaScript code sends a

00:12:09.210 --> 00:12:12.560
message over to C++ that says,
run the physics simulation,

00:12:12.560 --> 00:12:16.260
update where the objects are,
and report back to me when

00:12:16.260 --> 00:12:17.020
you're done.

00:12:17.020 --> 00:12:18.830
So these are running in
parallel, actually.

00:12:18.830 --> 00:12:21.870
While the physics simulation is
executing, Chrome and your

00:12:21.870 --> 00:12:24.780
JavaScript application are
off doing something else.

00:12:24.780 --> 00:12:28.610
It's running a separate thread,
taking advantage of

00:12:28.610 --> 00:12:31.800
the many cores that
we all have.

00:12:31.800 --> 00:12:33.830
PETE LEPAGE: That's a real big
advantage, too, because you're

00:12:33.830 --> 00:12:37.460
not necessarily going to block
the UI thread in order to do

00:12:37.460 --> 00:12:39.890
any of that processing, which
sometimes happens with

00:12:39.890 --> 00:12:43.020
applications when you're doing
complex JavaScript.

00:12:43.020 --> 00:12:45.130
JOHN MCCUTCHAN: Yeah, I mean
that's why we have web

00:12:45.130 --> 00:12:45.800
workers, right?

00:12:45.800 --> 00:12:49.110
Web workers allow you to offload
this heavy work in a

00:12:49.110 --> 00:12:51.760
way that doesn't block
the UI thread.

00:12:51.760 --> 00:12:54.600
Native Client Acceleration
models work in the same way.

00:12:54.600 --> 00:12:57.720
You could think of them
as almost like a web

00:12:57.720 --> 00:12:58.630
worker, in a way.

00:12:58.630 --> 00:13:01.420
But it just happens to be
running C++ code and not

00:13:01.420 --> 00:13:02.510
JavaScript.

00:13:02.510 --> 00:13:04.550
But just like with
web workers.

00:13:04.550 --> 00:13:07.040
You communicate through
message passing.

00:13:07.040 --> 00:13:09.580
You communicate with a Native
Client Acceleration model

00:13:09.580 --> 00:13:12.520
through message passing.

00:13:12.520 --> 00:13:16.320
So after this step simulation
event is delivered, the

00:13:16.320 --> 00:13:19.490
physics simulation thread wakes
up, runs its processing,

00:13:19.490 --> 00:13:23.930
and then spits back out a
Float32Array containing the

00:13:23.930 --> 00:13:26.150
positions and orientations
of all the rigid

00:13:26.150 --> 00:13:28.590
bodies in the scene.

00:13:28.590 --> 00:13:31.640
The JavaScript code takes that
array and parses it and

00:13:31.640 --> 00:13:34.480
updates the rendering position
of all objects.

00:13:34.480 --> 00:13:41.130
And this just loops, as any
interactive application does.

00:13:41.130 --> 00:13:42.870
So what if you wanted to build
your own Native Client

00:13:42.870 --> 00:13:44.760
Acceleration Module?

00:13:44.760 --> 00:13:46.910
I'm going to leave some of the
details out of this, but this

00:13:46.910 --> 00:13:50.630
is going to paint the high level
picture and give you a

00:13:50.630 --> 00:13:53.190
lot of pointers to where
to look if you want to

00:13:53.190 --> 00:13:54.910
really get into it.

00:13:54.910 --> 00:13:57.100
So building a Native Client
Acceleration Module consists

00:13:57.100 --> 00:13:58.590
of three main components.

00:13:58.590 --> 00:14:02.020
The first is you have to write
your C++ glue layer that takes

00:14:02.020 --> 00:14:05.810
the messages and passes them
to the C++ code that you

00:14:05.810 --> 00:14:08.890
already have written or you've
downloaded off the web.

00:14:08.890 --> 00:14:12.880
You have to write a twin of that
on the JavaScript side,

00:14:12.880 --> 00:14:16.810
which receives messages from C++
and also packages messages

00:14:16.810 --> 00:14:19.600
up to send to C++.

00:14:19.600 --> 00:14:21.950
And then you have to determine
what messages you want to send

00:14:21.950 --> 00:14:25.220
between the two worlds and what
data should be included

00:14:25.220 --> 00:14:26.470
in each one.

00:14:28.590 --> 00:14:31.380
So to make this really easy,
I've created a pair of

00:14:31.380 --> 00:14:33.620
libraries called Native Client

00:14:33.620 --> 00:14:36.280
Acceleration Module Base library.

00:14:36.280 --> 00:14:38.860
It's a C++ library and a
JavaScript library that makes

00:14:38.860 --> 00:14:41.700
creating acceleration modules
incredibly easy.

00:14:41.700 --> 00:14:42.860
You just have to write the code

00:14:42.860 --> 00:14:44.330
that responds to messages.

00:14:44.330 --> 00:14:47.270
You don't have to worry about
how do messages get across?

00:14:47.270 --> 00:14:49.980
How do I queue them up?

00:14:49.980 --> 00:14:52.440
All you have to do is just
implement a call back that

00:14:52.440 --> 00:14:54.130
says, hey, I got this
type of message.

00:14:54.130 --> 00:14:55.510
What should I do?

00:14:55.510 --> 00:14:58.090
You implement that little bit
of logic, and the rest is

00:14:58.090 --> 00:15:00.160
taken care for you in the
most performant way.

00:15:04.420 --> 00:15:07.060
So let's talk about the
structure of the messages.

00:15:07.060 --> 00:15:09.340
So messages are split
into a header and

00:15:09.340 --> 00:15:10.680
then optional frames.

00:15:10.680 --> 00:15:15.060
The header is just a JSON
object, which has a command

00:15:15.060 --> 00:15:19.490
name, a request ID, which is
just the unique ID of this

00:15:19.490 --> 00:15:23.300
specific request, and then a
frames count, which is either

00:15:23.300 --> 00:15:27.700
0 if there's no auxiliary
frames, or some positive

00:15:27.700 --> 00:15:30.230
integer expressing the frames.

00:15:30.230 --> 00:15:32.400
You can see the structure
of the message on

00:15:32.400 --> 00:15:33.860
the right hand side.

00:15:33.860 --> 00:15:36.980
The JSON message header
is always present.

00:15:36.980 --> 00:15:38.120
And that's in red.

00:15:38.120 --> 00:15:40.560
The frames in blue
are optional.

00:15:40.560 --> 00:15:43.410
And these frames are interpreted
entirely by your

00:15:43.410 --> 00:15:44.430
message handler.

00:15:44.430 --> 00:15:49.840
They're just a bag of either
strings or raw

00:15:49.840 --> 00:15:53.460
bytes in a byte array.

00:15:53.460 --> 00:15:55.670
The Native Client Source Model
base library doesn't know

00:15:55.670 --> 00:15:56.820
what's in these at all.

00:15:56.820 --> 00:15:59.110
It just knows how to collect
them and aggregate them into

00:15:59.110 --> 00:16:00.360
the larger meta message.

00:16:04.090 --> 00:16:07.840
So coming back to the Bullet
Physics demo, this is the

00:16:07.840 --> 00:16:09.350
messages that we've defined.

00:16:09.350 --> 00:16:13.330
So JavaScript can send a load
scene message to C++.

00:16:13.330 --> 00:16:16.450
It can send a step scene
message to C++.

00:16:16.450 --> 00:16:20.690
And it can also send a pick
up or drop object message.

00:16:20.690 --> 00:16:23.740
You saw that I was picking the
objects, and I said that the

00:16:23.740 --> 00:16:25.760
selection was being done
in JavaScript,

00:16:25.760 --> 00:16:28.150
which is entirely true.

00:16:28.150 --> 00:16:31.130
The JavaScript code figures out
what's under your mouse

00:16:31.130 --> 00:16:34.510
cursor and then sends that index
over to the C++ world

00:16:34.510 --> 00:16:38.110
and says, physics simulation,
grab that object, and pretend

00:16:38.110 --> 00:16:40.010
that I'm holding it.

00:16:40.010 --> 00:16:44.360
Inside the step scene message
is the position of my mouse

00:16:44.360 --> 00:16:45.900
cursor at the time.

00:16:45.900 --> 00:16:49.130
So that's how I'm able to
interactively play with the

00:16:49.130 --> 00:16:53.660
physics object while the
scene is simulating.

00:16:53.660 --> 00:16:56.270
Finally, there's one message
that comes from C++ to

00:16:56.270 --> 00:16:57.170
JavaScript.

00:16:57.170 --> 00:17:00.490
And that's the scene update
message, which includes the

00:17:00.490 --> 00:17:02.170
updated position and
orientation of

00:17:02.170 --> 00:17:03.420
all the rigid bodies.

00:17:06.650 --> 00:17:10.369
On the C++ side, a Native Client
Acceleration Module

00:17:10.369 --> 00:17:11.740
based library requires that you

00:17:11.740 --> 00:17:13.359
implement just three functions.

00:17:13.359 --> 00:17:17.079
One is an initialization
routine, which just includes

00:17:17.079 --> 00:17:18.410
all your module start
up stuff.

00:17:18.410 --> 00:17:20.690
This is just going to be called
automatically when your

00:17:20.690 --> 00:17:23.510
Acceleration Module is
first initialized.

00:17:23.510 --> 00:17:26.589
There is a heartbeat method
which you can implement, which

00:17:26.589 --> 00:17:28.470
just gets called at 60 hertz.

00:17:28.470 --> 00:17:31.150
So if you have to do anything
regularly inside of your

00:17:31.150 --> 00:17:34.850
acceleration module, this is
where you put that logic.

00:17:34.850 --> 00:17:37.750
And then finally, the handle
message callback, which is

00:17:37.750 --> 00:17:41.430
called whenever a message is
delivered from JavaScript.

00:17:41.430 --> 00:17:46.160
And this is where you put your
application-specific logic,

00:17:46.160 --> 00:17:48.320
which is like, hey, I just
got a step scene message.

00:17:48.320 --> 00:17:51.370
Let me go and trigger the
physics simulation thread and

00:17:51.370 --> 00:17:53.320
let it run.

00:17:53.320 --> 00:17:56.170
You don't have to worry about
packaging up messages or

00:17:56.170 --> 00:17:57.280
parsing them in any way.

00:17:57.280 --> 00:17:58.530
You just have to implement
the logic.

00:18:01.020 --> 00:18:04.040
On the JavaScript side,
it's really natural.

00:18:04.040 --> 00:18:06.230
If you want to respond to
something like, hey, the scene

00:18:06.230 --> 00:18:08.780
was updated, you just go
Add Event Listener.

00:18:08.780 --> 00:18:11.730
Or when you're done, you could
go Remove Event Listener.

00:18:11.730 --> 00:18:14.100
So from the JavaScript
programmer's prospective, this

00:18:14.100 --> 00:18:14.885
feels very natural.

00:18:14.885 --> 00:18:18.290
An Acceleration Module is just
some element that you can add

00:18:18.290 --> 00:18:19.440
an event listener to.

00:18:19.440 --> 00:18:21.330
And the events are the
messages coming

00:18:21.330 --> 00:18:23.750
from the C++ module.

00:18:23.750 --> 00:18:26.090
And if you want to send a
message to C++, there's a

00:18:26.090 --> 00:18:29.400
single method, Send Message,
which just takes the command

00:18:29.400 --> 00:18:32.450
name and some frames.

00:18:32.450 --> 00:18:33.490
It's very straightforward.

00:18:33.490 --> 00:18:37.320
I'm calling out in grey to scene
NaClAM.js At the end of

00:18:37.320 --> 00:18:40.310
the talk, there will be a link
to the GitHub repository,

00:18:40.310 --> 00:18:42.930
which includes this library.

00:18:42.930 --> 00:18:44.890
And you can dig in from there.

00:18:47.680 --> 00:18:52.050
So wrapping up, NaCl
acceleration models bring

00:18:52.050 --> 00:18:54.660
native performance to web
applications and Chrome

00:18:54.660 --> 00:18:56.260
applications.

00:18:56.260 --> 00:18:59.840
It's really straightforward to
use if you're a web developer.

00:18:59.840 --> 00:19:03.480
And, like I said, you get 90%
of your application as a

00:19:03.480 --> 00:19:07.190
Chrome app written in JavaScript
and HTML5.

00:19:07.190 --> 00:19:09.970
And that last 10% where the
performance really matters,

00:19:09.970 --> 00:19:12.310
you get from C++.

00:19:12.310 --> 00:19:15.680
And you get native performance,
in order of

00:19:15.680 --> 00:19:19.180
magnitude faster than what's
possible through JavaScript.

00:19:19.180 --> 00:19:21.840
So hopefully you're really
interested in this.

00:19:21.840 --> 00:19:22.800
You want to get involved.

00:19:22.800 --> 00:19:25.440
So the first step to building
a Native Client Acceleration

00:19:25.440 --> 00:19:29.080
Module is to go and grab the
Native Client SDK from

00:19:29.080 --> 00:19:31.100
gonacl.com.

00:19:31.100 --> 00:19:33.500
You can try out the Bullet
Physics demo by going to the

00:19:33.500 --> 00:19:34.770
link on the slide.

00:19:34.770 --> 00:19:37.850
And you can join the Native
Client discussion thread by

00:19:37.850 --> 00:19:40.020
going to the final link
on the slide.

00:19:43.610 --> 00:19:46.370
After you've gotten the SDK
running, you can go and grab

00:19:46.370 --> 00:19:49.170
the NaClAMBase framework
from the GitHub

00:19:49.170 --> 00:19:50.890
repository on the slide.

00:19:50.890 --> 00:19:53.230
And this includes the complete
source code to the Bullet

00:19:53.230 --> 00:19:55.300
Physics demo that
I demonstrated.

00:19:55.300 --> 00:19:57.940
So you can build that yourself
and play around with it and

00:19:57.940 --> 00:19:58.970
add new features.

00:19:58.970 --> 00:20:00.720
It's a great place to start.

00:20:03.360 --> 00:20:07.070
So included inside the base
repository are three example

00:20:07.070 --> 00:20:08.550
Native Client Acceleration
Modules--

00:20:08.550 --> 00:20:11.530
the Bullet Physics one; an image
processing one, which

00:20:11.530 --> 00:20:16.570
takes a set of pixels from a
canvas object, does something

00:20:16.570 --> 00:20:18.780
with it, and then sends it back
over to JavaScript and it

00:20:18.780 --> 00:20:21.560
gets displayed again; and
then a Zlib compress

00:20:21.560 --> 00:20:23.770
and decompress module.

00:20:23.770 --> 00:20:27.730
These are just example modules
that you may use as a jumping

00:20:27.730 --> 00:20:30.430
off point or just as a template
to create your own

00:20:30.430 --> 00:20:33.730
and expose new libraries that
I haven't exposed yet.

00:20:36.570 --> 00:20:38.820
So Chrome Apps plus Native
Client Acceleration Modules

00:20:38.820 --> 00:20:42.620
give you native performance
where it counts, which is

00:20:42.620 --> 00:20:45.040
really exciting, because Chrome
Apps already offer

00:20:45.040 --> 00:20:49.050
native feeling and native
functionality with them.

00:20:49.050 --> 00:20:51.760
But it's just missing that
final piece, which is

00:20:51.760 --> 00:20:53.140
performance.

00:20:53.140 --> 00:20:55.120
Luckily, though, most
applications only need

00:20:55.120 --> 00:20:57.510
performance in a very small
chunk of their code.

00:20:57.510 --> 00:20:58.900
And this is where Native
Client Acceleration

00:20:58.900 --> 00:21:00.970
Modules come in.

00:21:00.970 --> 00:21:03.890
Again, 90% of your application
is written

00:21:03.890 --> 00:21:05.710
increase in Chrome Apps.

00:21:05.710 --> 00:21:07.270
The last little bit
is written in C++.

00:21:10.570 --> 00:21:11.820
So time for questions.

00:21:11.820 --> 00:21:13.390
But make sure you follow
me on Twitter.

00:21:13.390 --> 00:21:15.520
You can check out my blog
or read my code.

00:21:15.520 --> 00:21:18.000
And if there's a Native Client
Acceleration Module that you

00:21:18.000 --> 00:21:21.210
really want exposed, and maybe
you're not the greatest C++

00:21:21.210 --> 00:21:23.400
programmer, hit me up on G+.

00:21:23.400 --> 00:21:27.800
And if it's a good idea, I'll
be happy to do it for you.

00:21:27.800 --> 00:21:28.220
PETE LEPAGE: Cool.

00:21:28.220 --> 00:21:29.140
Well, thanks, John.

00:21:29.140 --> 00:21:31.240
That's some pretty neat stuff.

00:21:31.240 --> 00:21:34.790
And I think not only is it good
for things where you're

00:21:34.790 --> 00:21:36.830
just really trying to
improve performance.

00:21:36.830 --> 00:21:40.170
But it's really good for when
you've got to do stuff that's

00:21:40.170 --> 00:21:43.910
maybe complex or you've already
got libraries written

00:21:43.910 --> 00:21:47.150
in other languages, where you
just want to be able to reuse

00:21:47.150 --> 00:21:49.210
that across applications.

00:21:49.210 --> 00:21:52.180
One company I was talking to
a couple of weeks ago was

00:21:52.180 --> 00:21:54.770
saying, look, we have this
really great sync library that

00:21:54.770 --> 00:21:58.530
we use in our native
apps for mobile.

00:21:58.530 --> 00:22:01.720
And we really want to be able to
use that sync library to be

00:22:01.720 --> 00:22:06.050
able to sync data between the
client and the application.

00:22:06.050 --> 00:22:10.550
This is a perfect solution for
them to be able to do that.

00:22:10.550 --> 00:22:10.900
JOHN MCCUTCHAN: Yeah.

00:22:10.900 --> 00:22:11.560
Absolutely.

00:22:11.560 --> 00:22:14.490
I think you really hit the nail
on the head when you said

00:22:14.490 --> 00:22:16.900
you have this existing
code base.

00:22:16.900 --> 00:22:19.630
A lot of applications that are
interested in coming to the

00:22:19.630 --> 00:22:23.290
web, they already have a large
part of their application

00:22:23.290 --> 00:22:25.750
written in C++ or some
other language.

00:22:25.750 --> 00:22:28.640
And so the only thing that you
have to add on here is this

00:22:28.640 --> 00:22:30.934
message-passing logic.

00:22:30.934 --> 00:22:32.260
PETE LEPAGE: Yep.

00:22:32.260 --> 00:22:32.900
Cool.

00:22:32.900 --> 00:22:34.940
Well, why don't we take some of
the questions that people

00:22:34.940 --> 00:22:37.670
have posted to our Google
Moderator, and I'll have a

00:22:37.670 --> 00:22:39.790
look at some of the YouTube
questions as well.

00:22:39.790 --> 00:22:45.080
But Max West wants to know, "can
NaCl Acceleration Modules

00:22:45.080 --> 00:22:48.820
be used to encrypt streaming
files, like media, audio,

00:22:48.820 --> 00:22:50.220
video, and that kind
of thing?"

00:22:50.220 --> 00:22:51.470
JOHN MCCUTCHAN: Absolutely.

00:22:53.500 --> 00:22:55.830
And there's another talk which
we'll link to afterwards which

00:22:55.830 --> 00:23:00.320
includes a measurement of the
latency in the throughput of

00:23:00.320 --> 00:23:01.330
transmitting data.

00:23:01.330 --> 00:23:05.220
And the throughput right now
is about 400 megabytes per

00:23:05.220 --> 00:23:07.130
second on my machine.

00:23:07.130 --> 00:23:09.480
So that's round trip.

00:23:09.480 --> 00:23:12.790
So that's from JavaScript into
Native Client Acceleration

00:23:12.790 --> 00:23:15.700
Module and then back into
JavaScript at 400 megabytes

00:23:15.700 --> 00:23:17.400
per second.

00:23:17.400 --> 00:23:20.090
PETE LEPAGE: That's
pretty serious.

00:23:20.090 --> 00:23:22.250
I'm trying to think what
you'd need for video.

00:23:22.250 --> 00:23:25.730
But I'd be willing to bet that's
probably pretty close,

00:23:25.730 --> 00:23:26.800
if not good enough.

00:23:26.800 --> 00:23:30.570
JOHN MCCUTCHAN: Back of the
envelope, I think you can do a

00:23:30.570 --> 00:23:38.300
1024 uncompressed image with 32
bits per pixel at 60 hertz.

00:23:38.300 --> 00:23:41.020
And that's about 260 megs.

00:23:41.020 --> 00:23:43.660
So you still some
room left over.

00:23:43.660 --> 00:23:45.450
And of course, when you're
dealing with video, it's

00:23:45.450 --> 00:23:47.460
already compressed.

00:23:47.460 --> 00:23:47.830
PETE LEPAGE: Right.

00:23:47.830 --> 00:23:49.550
Yeah, that's true.

00:23:49.550 --> 00:23:50.370
All right.

00:23:50.370 --> 00:23:53.970
Next, Rob from Missoula wants
to know, "is it possible to

00:23:53.970 --> 00:23:57.910
compile existing libraries
written in C# or Java to be

00:23:57.910 --> 00:24:02.390
used in NaCl in a Chrome app?"
And I know you touched on C#

00:24:02.390 --> 00:24:03.790
and said that the
answer was yes.

00:24:03.790 --> 00:24:05.310
But what about Java?

00:24:05.310 --> 00:24:07.880
JOHN MCCUTCHAN: I don't know
if that's possible today.

00:24:07.880 --> 00:24:13.360
But C# absolutely does work.

00:24:13.360 --> 00:24:15.770
PETE LEPAGE: So you said to
compile the stuff, people need

00:24:15.770 --> 00:24:17.330
to grab their GCC compiler.

00:24:17.330 --> 00:24:21.180
Where can they find
the great--

00:24:21.180 --> 00:24:22.450
I just want to go
through this.

00:24:22.450 --> 00:24:26.220
Are the docs up on the Chrome
Developer website?

00:24:26.220 --> 00:24:27.870
JOHN MCCUTCHAN: So for Native
Client, you want to go to

00:24:27.870 --> 00:24:29.050
gonacl.com.

00:24:29.050 --> 00:24:31.110
And that's going to explain
everything you need to know

00:24:31.110 --> 00:24:33.350
about developing with
Native Client.

00:24:33.350 --> 00:24:35.960
And right now, for Native Client
Acceleration Modules,

00:24:35.960 --> 00:24:39.670
the best place is to hit up the
GitHub repository, which

00:24:39.670 --> 00:24:42.400
has a lot of example code.

00:24:42.400 --> 00:24:45.730
We're going to be working to add
some stuff to the Chrome

00:24:45.730 --> 00:24:47.490
Apps documentation.

00:24:47.490 --> 00:24:48.700
PETE LEPAGE: And that's
on the GitHub

00:24:48.700 --> 00:24:50.300
repository that you posted?

00:24:50.300 --> 00:24:53.100
Or is that in the Google Chrome
GitHub repository?

00:24:53.100 --> 00:24:55.450
JOHN MCCUTCHAN: That's in my
own GitHub repository.

00:24:55.450 --> 00:24:58.390
And we'll post a link after
the show as well.

00:24:58.390 --> 00:24:58.960
PETE LEPAGE: OK.

00:24:58.960 --> 00:25:03.000
We'll get a post up on our
Chrome Developers page that

00:25:03.000 --> 00:25:06.010
you can go and have a look at.

00:25:06.010 --> 00:25:09.000
GT from India wants to know
whether the media source

00:25:09.000 --> 00:25:12.200
extension APIs are going to be
supported with Chrome for

00:25:12.200 --> 00:25:14.360
Android beta or the latest?

00:25:14.360 --> 00:25:17.500
We're not really focusing on
some of the Chrome for Android

00:25:17.500 --> 00:25:19.550
stuff today.

00:25:19.550 --> 00:25:23.470
But that's something that I
believe we want to support.

00:25:23.470 --> 00:25:26.710
But I don't want to give you a
complete answer right now, GT,

00:25:26.710 --> 00:25:30.260
because I'm not actually 100%
sure on the answer there.

00:25:30.260 --> 00:25:33.320
And then, John, last one for
you, and then we'll sign off.

00:25:33.320 --> 00:25:37.580
But "when will we be able to
have multiple OpenGL contacts

00:25:37.580 --> 00:25:41.260
in NaCl and use them off
the main thread?"

00:25:41.260 --> 00:25:42.910
JOHN MCCUTCHAN: So calling
off of the main

00:25:42.910 --> 00:25:44.160
thread is coming soon.

00:25:46.430 --> 00:25:50.360
I'm not entirely sure on
the specific Chrome

00:25:50.360 --> 00:25:52.580
and NaCl SDK release.

00:25:52.580 --> 00:25:56.320
But it's coming really soon with
the ability to make all

00:25:56.320 --> 00:25:59.310
sorts of Pepper calls off
of the main thread.

00:25:59.310 --> 00:26:03.450
With respect to multiple OpenGL
contacts, I am not sure

00:26:03.450 --> 00:26:06.570
when that is coming,

00:26:06.570 --> 00:26:06.870
PETE LEPAGE: All right.

00:26:06.870 --> 00:26:08.410
Well, cool.

00:26:08.410 --> 00:26:09.530
Thanks for those answers.

00:26:09.530 --> 00:26:10.690
And thanks for a really
interesting

00:26:10.690 --> 00:26:12.510
presentation today.

00:26:12.510 --> 00:26:16.740
I didn't realize how this could
solve a lot of problems

00:26:16.740 --> 00:26:20.970
for people who already have
existing code bases, or maybe

00:26:20.970 --> 00:26:24.050
who are looking for places where
they just want to get

00:26:24.050 --> 00:26:26.920
that a little bit of extra
performance that they can't

00:26:26.920 --> 00:26:32.290
get because JavaScript V8 is
fast but maybe isn't quite

00:26:32.290 --> 00:26:34.840
where they need it to be in
order to do some rather

00:26:34.840 --> 00:26:37.050
complex calculations.

00:26:37.050 --> 00:26:38.240
Thanks for joining us.

00:26:38.240 --> 00:26:40.730
And thanks to everybody for
watching this week.

00:26:40.730 --> 00:26:43.630
We'll be back next week.

00:26:43.630 --> 00:26:45.240
I'll be live from
Mountain View.

00:26:45.240 --> 00:26:47.900
And we'll have Paul
Kinlan joining me.

00:26:47.900 --> 00:26:50.970
We're going to do just a fun--

00:26:50.970 --> 00:26:53.080
we're not going to plan
a topic for next week.

00:26:53.080 --> 00:26:54.370
We want to take your
questions.

00:26:54.370 --> 00:26:58.970
We want to open it up
to you to just chat.

00:26:58.970 --> 00:27:00.320
We're going to show off
some really cool

00:27:00.320 --> 00:27:01.960
demos, some neat stuff.

00:27:01.960 --> 00:27:05.220
I think I've got one up my
sleeve that hopefully I'll be

00:27:05.220 --> 00:27:08.050
able to get some stuff done
before then so that you guys

00:27:08.050 --> 00:27:10.720
can go and check out some
really cool stuff.

00:27:10.720 --> 00:27:12.120
Thanks for joining us, John.

00:27:12.120 --> 00:27:13.100
Thank you very much.

00:27:13.100 --> 00:27:14.750
And Louis, thanks
for producing.

00:27:14.750 --> 00:27:15.180
JOHN MCCUTCHAN: Thanks,
everyone.

00:27:15.180 --> 00:27:17.020
PETE LEPAGE: And have a
great week, everybody.

00:27:17.020 --> 00:27:18.270
Thank you.

