WEBVTT
Kind: captions
Language: en

00:00:01.740 --> 00:00:03.610
PAUL KINLAN: Hi, everyone.

00:00:03.610 --> 00:00:04.760
Welcome to our talk.

00:00:04.760 --> 00:00:05.940
There's a lot of
people in here.

00:00:05.940 --> 00:00:08.197
We didn't actually expect this
many people, did we?

00:00:08.197 --> 00:00:09.510
No.

00:00:09.510 --> 00:00:10.650
So hello everyone.

00:00:10.650 --> 00:00:15.224
Welcome to Mobile HTML, the
Future of Your Sites.

00:00:15.224 --> 00:00:17.530
PETER BEVERLOO: My name is--

00:00:17.530 --> 00:00:18.802
PAUL KINLAN: You on?

00:00:18.802 --> 00:00:19.258
PETER BEVERLOO: No.

00:00:19.258 --> 00:00:22.450
I think it's not.

00:00:22.450 --> 00:00:24.450
My name is Peter Beverloo.

00:00:24.450 --> 00:00:26.535
I'm a software engineer
at Google.

00:00:26.535 --> 00:00:28.275
I work with Chrome
for Android.

00:00:28.275 --> 00:00:32.470
And I mostly specialize in--

00:00:32.470 --> 00:00:33.720
PAUL KINLAN: Yay.

00:00:44.250 --> 00:00:44.420
PETER BEVERLOO: Hello?

00:00:44.420 --> 00:00:45.390
Yeah, this sounds better.

00:00:45.390 --> 00:00:48.060
PAUL KINLAN: Yay.

00:00:48.060 --> 00:00:50.410
[APPLAUSE]

00:00:50.410 --> 00:00:51.950
PETER BEVERLOO: So my name
is Peter Beverloo.

00:00:51.950 --> 00:00:53.450
I'm a software engineer
at Google.

00:00:53.450 --> 00:00:55.180
I work on the Chrome
for Android team.

00:00:55.180 --> 00:00:56.820
And I mostly specialize
in pushing the

00:00:56.820 --> 00:00:58.950
web platform forwards.

00:00:58.950 --> 00:01:00.180
PAUL KINLAN: I'm Paul Kinlan, a

00:01:00.180 --> 00:01:02.115
developer advocate on Chrome.

00:01:02.115 --> 00:01:03.610
I specialize in the
mobile web.

00:01:03.610 --> 00:01:07.076
And you can catch me at all
these normal places.

00:01:07.076 --> 00:01:08.360
So should we get started?

00:01:08.360 --> 00:01:09.515
PETER BEVERLOO: Sounds good.

00:01:09.515 --> 00:01:10.850
PAUL KINLAN: We should
get into it.

00:01:10.850 --> 00:01:13.500
So it's always good to start
with a survey, and kind of

00:01:13.500 --> 00:01:16.820
understand how everyone in this
room deals with mobile.

00:01:16.820 --> 00:01:19.620
So I want everyone to put your
hand up if you have a

00:01:19.620 --> 00:01:21.232
smartphone.

00:01:21.232 --> 00:01:23.110
Pretty sure that's--

00:01:23.110 --> 00:01:24.420
yeah, keep it up, keep it up.

00:01:24.420 --> 00:01:26.050
You've got to keep it up.

00:01:26.050 --> 00:01:26.450
Right.

00:01:26.450 --> 00:01:28.330
So who has a 24 inch
smartphone?

00:01:31.490 --> 00:01:33.640
One person has got a 24 inch?

00:01:33.640 --> 00:01:33.880
How big?

00:01:33.880 --> 00:01:34.810
Come on, show it please.

00:01:34.810 --> 00:01:36.060
Have you got it?

00:01:39.900 --> 00:01:42.660
I actually, the reason why I'm
kind of looking dumbfounded is

00:01:42.660 --> 00:01:44.530
because I actually realized
I'd forgotten to enter the

00:01:44.530 --> 00:01:47.090
number of the person
I'm calling.

00:01:47.090 --> 00:01:52.040
So who has a dual
24 inch screen?

00:01:52.040 --> 00:01:53.886
OK.

00:01:53.886 --> 00:01:55.380
I've actually designed
all these slides

00:01:55.380 --> 00:01:56.960
for a 24 inch screen.

00:01:56.960 --> 00:01:58.690
PETER BEVERLOO: It's a little
bit of a bummer.

00:01:58.690 --> 00:02:00.170
PAUL KINLAN: Man.

00:02:00.170 --> 00:02:03.542
So who loves typing
on a phone?

00:02:03.542 --> 00:02:05.005
OK, no one.

00:02:05.005 --> 00:02:06.550
That's cool.

00:02:06.550 --> 00:02:09.800
Who has a gigabit ethernet
connected phone?

00:02:09.800 --> 00:02:10.539
No?

00:02:10.539 --> 00:02:13.456
Who's got like a
5G, a 4G phone?

00:02:13.456 --> 00:02:15.560
A couple of people are getting
really fast phones now.

00:02:15.560 --> 00:02:18.310
It's kind of interesting.

00:02:18.310 --> 00:02:20.850
And who uses their phone
as their primary

00:02:20.850 --> 00:02:23.590
desktop type of device?

00:02:23.590 --> 00:02:25.050
You know, this is a kind of
interesting one, this one.

00:02:25.050 --> 00:02:28.020
Because if you're kind of
working out and about and not

00:02:28.020 --> 00:02:30.500
a developer, this actually is
going to be one of those

00:02:30.500 --> 00:02:31.680
things that happens in
the near future.

00:02:31.680 --> 00:02:34.690
Where your primary machine
actually is your phone.

00:02:34.690 --> 00:02:37.280
So I know I'm being a bit kind
of like facetious with the

00:02:37.280 --> 00:02:38.620
photos and all this
type of stuff.

00:02:38.620 --> 00:02:40.980
But what we're trying to say is
that mobile is different.

00:02:40.980 --> 00:02:42.240
And the way that we're building
our sites and

00:02:42.240 --> 00:02:44.690
application at the moment, we're
still not targeting this

00:02:44.690 --> 00:02:47.470
mobile web, which is, if you
look at India, for instance,

00:02:47.470 --> 00:02:50.290
like 60% of the traffic
is mobile based.

00:02:50.290 --> 00:02:52.290
And we're still not building
applications and sites that

00:02:52.290 --> 00:02:53.480
cater for that.

00:02:53.480 --> 00:02:55.490
PETER BEVERLOO: So probably the
most obvious difference

00:02:55.490 --> 00:02:58.150
between desktop machines and
mobile devices is that the

00:02:58.150 --> 00:02:59.660
screen is significantly
smaller.

00:02:59.660 --> 00:03:03.730
So as developers, we've got
less space to play with.

00:03:03.730 --> 00:03:04.000
PAUL KINLAN: Yeah.

00:03:04.000 --> 00:03:05.250
And I use the mobile, right?

00:03:05.250 --> 00:03:07.520
I know the word is mobile when
we're talking about mobile web

00:03:07.520 --> 00:03:07.970
development.

00:03:07.970 --> 00:03:09.810
But our users are
out and about.

00:03:09.810 --> 00:03:12.660
And can we take advantage of the
fact that they might be in

00:03:12.660 --> 00:03:14.450
a shopping mall, they might be
on the street, they might be

00:03:14.450 --> 00:03:15.895
driving down the road.

00:03:15.895 --> 00:03:17.760
They might actually have this
thing where they don't have a

00:03:17.760 --> 00:03:18.760
great internet connection.

00:03:18.760 --> 00:03:21.070
And can we build applications
and sites which are

00:03:21.070 --> 00:03:22.810
responsive to this?

00:03:22.810 --> 00:03:24.590
PETER BEVERLOO: And even though
you are the kind of

00:03:24.590 --> 00:03:27.660
person who likes writing an
essay on a mobile phone, I

00:03:27.660 --> 00:03:30.920
absolutely hate typing
on these devices.

00:03:30.920 --> 00:03:33.450
PAUL KINLAN: And most of our
sites also, or most of our

00:03:33.450 --> 00:03:35.460
apps, at least, or devices
have unique hardware

00:03:35.460 --> 00:03:36.480
capabilities.

00:03:36.480 --> 00:03:39.650
Everyone phone has a GPS
receiver, a camera, and a

00:03:39.650 --> 00:03:41.910
whole host of other kind of
really interesting features

00:03:41.910 --> 00:03:44.940
that we just don't get
on the desktop web.

00:03:44.940 --> 00:03:48.220
And what can we do to take
advantage of that today?

00:03:48.220 --> 00:03:49.980
PETER BEVERLOO: And then of
course, everything is slower

00:03:49.980 --> 00:03:50.830
on a mobile device.

00:03:50.830 --> 00:03:53.000
It's not just the screen
which is slower.

00:03:53.000 --> 00:03:55.400
But because the whole device is
slower, we actually don't

00:03:55.400 --> 00:03:58.630
have the space available to
put in a big ass GPU so to

00:03:58.630 --> 00:04:02.480
speak on a desktop machine.

00:04:02.480 --> 00:04:05.330
So in this presentation today,
we're going to talk a little

00:04:05.330 --> 00:04:08.130
bit about features which are
available on the web today

00:04:08.130 --> 00:04:12.020
which are being developed, and a
few features which are still

00:04:12.020 --> 00:04:13.790
being under development
by the [INAUDIBLE]

00:04:13.790 --> 00:04:14.900
institutes.

00:04:14.900 --> 00:04:17.390
But which are still quite
interesting to talk about, and

00:04:17.390 --> 00:04:21.550
we expect them to be available
in the near future.

00:04:21.550 --> 00:04:26.820
Then we're going to look at six
decent mobile browsers,

00:04:26.820 --> 00:04:30.230
notably Opera for Android,
the beta expression.

00:04:30.230 --> 00:04:32.990
And these icons will be
displayed on most of the

00:04:32.990 --> 00:04:35.130
slides, most of the
feature slides.

00:04:35.130 --> 00:04:37.430
And if the logo is colored, then
the feature is available.

00:04:37.430 --> 00:04:43.070
If it's grey and kind of light,
then clearly it's not.

00:04:43.070 --> 00:04:45.200
So the screens on a mobile
device are smaller.

00:04:45.200 --> 00:04:46.830
And this has a number
of constraints

00:04:46.830 --> 00:04:48.060
which have put us--

00:04:48.060 --> 00:04:50.010
well, not just on
us developers.

00:04:50.010 --> 00:04:52.470
But it has constraints on
the end user, as well.

00:04:52.470 --> 00:04:56.330
We're used to developing sites
from a desktop perspective.

00:04:56.330 --> 00:04:58.910
And we've got all this screen
estate to play with.

00:04:58.910 --> 00:05:01.390
And on a mobile device,
clearly, we

00:05:01.390 --> 00:05:03.360
need to be more careful.

00:05:03.360 --> 00:05:06.420
So the first thing to keep in
mind is that a browser by

00:05:06.420 --> 00:05:10.830
default, mobile browser by
default, will assume that the

00:05:10.830 --> 00:05:14.370
website you're visiting
is a desktop website.

00:05:14.370 --> 00:05:16.830
This means that it will assume
that the width of the web page

00:05:16.830 --> 00:05:19.620
will be equal to 980 pixels.

00:05:19.620 --> 00:05:21.810
This kind of varies
per browser.

00:05:21.810 --> 00:05:24.980
But for Chrome for Android,
it's 980 pixels.

00:05:24.980 --> 00:05:27.620
The browser does this because
desktop websites have been

00:05:27.620 --> 00:05:29.450
made with a decent
width in mind.

00:05:29.450 --> 00:05:31.700
And if you suddenly decrease
the width of the page to be

00:05:31.700 --> 00:05:34.440
much smaller than it originally
was, then the

00:05:34.440 --> 00:05:37.860
website can completely
look distorted.

00:05:37.860 --> 00:05:39.100
Text becomes unreadable.

00:05:39.100 --> 00:05:41.870
And functionality becomes
unavailable.

00:05:41.870 --> 00:05:44.670
So that's kind of an act we have
to do in order to make

00:05:44.670 --> 00:05:47.200
the mobile web usable for
the vast majority

00:05:47.200 --> 00:05:49.950
of the website today.

00:05:49.950 --> 00:05:51.750
Of course, when you're
developing a mobile website,

00:05:51.750 --> 00:05:53.620
this is not what you want.

00:05:53.620 --> 00:05:56.520
You want a website to have the
width of the screen itself, so

00:05:56.520 --> 00:05:58.460
you don't have horizontal
scrolling.

00:05:58.460 --> 00:06:00.520
And the first thing you
should do is add a

00:06:00.520 --> 00:06:02.185
meta viewport element.

00:06:02.185 --> 00:06:04.980
The third example shows the
complete entry which you

00:06:04.980 --> 00:06:06.860
should add to the pages.

00:06:06.860 --> 00:06:07.890
It's actually quite simple.

00:06:07.890 --> 00:06:10.510
You specify that the width of
your viewport should be equal

00:06:10.510 --> 00:06:11.830
to the width of the device.

00:06:11.830 --> 00:06:14.690
And you say that the initial
scales should be equal to one,

00:06:14.690 --> 00:06:16.900
so that the user doesn't have
to zoom in before they can

00:06:16.900 --> 00:06:19.000
read your content.

00:06:19.000 --> 00:06:21.920
Now, editing a meta deck can
be a little bit awkward.

00:06:21.920 --> 00:06:24.360
And especially if you want to
have several meta decks,

00:06:24.360 --> 00:06:27.510
because your viewport has to
be slightly different for a

00:06:27.510 --> 00:06:30.060
mobile phone or a
tablet device.

00:06:30.060 --> 00:06:33.210
Then you probably have to resort
to either server side

00:06:33.210 --> 00:06:35.027
detection of the device
or to JavaScript to

00:06:35.027 --> 00:06:36.730
change it on the fly.

00:06:36.730 --> 00:06:38.420
And that's just not cool.

00:06:38.420 --> 00:06:40.470
So a feature which is currently
being developed is

00:06:40.470 --> 00:06:42.480
called CSS Device Adaptation.

00:06:42.480 --> 00:06:46.140
And this adds the Add Viewport
rule to CSS.

00:06:46.140 --> 00:06:49.240
That viewport rule exposes
exactly the same information

00:06:49.240 --> 00:06:50.800
as the meta element.

00:06:50.800 --> 00:06:53.370
But it also allows you to change
that information using

00:06:53.370 --> 00:06:56.760
the declaratives index, which
you're used to from CSS.

00:06:56.760 --> 00:06:58.980
After all, the viewport
itself, it's more

00:06:58.980 --> 00:07:00.770
presentational than
it is based on the

00:07:00.770 --> 00:07:02.390
semantics of your page.

00:07:02.390 --> 00:07:05.430
So it should be better
in CSS anyway.

00:07:05.430 --> 00:07:08.550
Now, when you combine this with
Media Queries, which is a

00:07:08.550 --> 00:07:11.850
cool trick allowing you to
have different sets of

00:07:11.850 --> 00:07:15.150
styling, basic constraints after
the device user is using

00:07:15.150 --> 00:07:17.640
to look at your website.

00:07:17.640 --> 00:07:20.140
You can actually use Media
Queries to have several Add

00:07:20.140 --> 00:07:23.120
Viewport rules based on, for
example, the width of the

00:07:23.120 --> 00:07:26.360
device which is being used.

00:07:26.360 --> 00:07:29.190
Let's look a little bit more
about these Media Queries.

00:07:29.190 --> 00:07:30.880
They are kind of
an old feature.

00:07:30.880 --> 00:07:33.810
Most of you will probably
already have used them in one

00:07:33.810 --> 00:07:35.060
way or another.

00:07:35.060 --> 00:07:39.460
But especially for mobile,
they're quite important.

00:07:39.460 --> 00:07:42.750
Now the most basic example
probably is to have different

00:07:42.750 --> 00:07:44.250
styling rules based
on the width and

00:07:44.250 --> 00:07:45.900
the height of a device.

00:07:45.900 --> 00:07:47.775
And you can have as many
constraints in

00:07:47.775 --> 00:07:48.930
there as you want.

00:07:48.930 --> 00:07:51.700
So you can have different
styling rules for tablets and

00:07:51.700 --> 00:07:54.020
phones in its most basic uses.

00:07:54.020 --> 00:07:57.160
You can select based on the
aspect ratio of a device.

00:07:57.160 --> 00:08:02.130
In a television era, we all
remember the change from

00:08:02.130 --> 00:08:05.120
normal 4 by 3 televisions
to 16 by 9 widescreen

00:08:05.120 --> 00:08:06.370
televisions.

00:08:08.720 --> 00:08:11.960
You still have an old TV.

00:08:11.960 --> 00:08:15.010
And because of that, we want
to do this by black bars on

00:08:15.010 --> 00:08:16.110
the television itself.

00:08:16.110 --> 00:08:18.460
Now, if you have video content
on your page, you actually

00:08:18.460 --> 00:08:20.650
might want to do exactly
the same.

00:08:20.650 --> 00:08:23.460
And probably, the most
interesting one for today's

00:08:23.460 --> 00:08:26.730
mobile devices is the resolution
directive.

00:08:26.730 --> 00:08:28.920
The resolution directive allows
you to select based on

00:08:28.920 --> 00:08:31.180
the pixel density
of the device.

00:08:31.180 --> 00:08:33.610
You may already notice, using
the proprietary, WebKit

00:08:33.610 --> 00:08:35.870
defines pixel ratio.

00:08:35.870 --> 00:08:38.169
And based on that, you can have
different-- well, a good

00:08:38.169 --> 00:08:40.659
use case for that could be to
have different images for high

00:08:40.659 --> 00:08:44.390
resolution images such as Apple
retina screens, or the

00:08:44.390 --> 00:08:47.690
newer Galaxy Nexus devices,
or for example, the

00:08:47.690 --> 00:08:48.940
Galaxy Nexus S4.

00:08:50.680 --> 00:08:53.900
A small note about the
resolution Media Query.

00:08:53.900 --> 00:08:56.600
While it's upcoming, it's not
yet completely available in

00:08:56.600 --> 00:08:57.710
all browsers.

00:08:57.710 --> 00:09:01.230
But this index is way less
awkward than the old WebKit

00:09:01.230 --> 00:09:04.120
device pixel ratio.

00:09:04.120 --> 00:09:07.550
Now, all of these can probably
be used on desktop as well.

00:09:07.550 --> 00:09:11.030
And this presentation, after
all, is about mobile.

00:09:11.030 --> 00:09:13.470
So one directive which is
especially interesting for

00:09:13.470 --> 00:09:17.310
mobile devices is the
orientation Media Query.

00:09:17.310 --> 00:09:19.410
This allows you to have
different styling of the page

00:09:19.410 --> 00:09:22.165
based on how the user is holding
the device, which can

00:09:22.165 --> 00:09:24.380
change while they're watching
your website.

00:09:27.700 --> 00:09:30.100
Of course, selecting based
on the viewport itself is

00:09:30.100 --> 00:09:31.140
interesting.

00:09:31.140 --> 00:09:34.300
But it would also be nice if you
can size elements or fonts

00:09:34.300 --> 00:09:36.890
based on the width, the height
of the viewport.

00:09:36.890 --> 00:09:38.640
Because of that, four
new units are being

00:09:38.640 --> 00:09:40.460
introduced to CSS.

00:09:40.460 --> 00:09:41.720
They're called the
viewport units.

00:09:41.720 --> 00:09:44.300
There's VW for the width
of the viewports.

00:09:44.300 --> 00:09:46.860
There's VH for the height
of the viewports.

00:09:46.860 --> 00:09:50.300
And then VMIN and VMAX which
respectively map to the

00:09:50.300 --> 00:09:52.920
smallest and the largest
value of the two.

00:09:52.920 --> 00:09:55.150
They work a little bit
like percentages.

00:09:55.150 --> 00:09:58.700
So 100 VW will be equal
to the complete

00:09:58.700 --> 00:09:59.950
width of the viewports.

00:10:04.140 --> 00:10:05.910
Now, the viewport itself
is smaller.

00:10:05.910 --> 00:10:07.280
We know about that.

00:10:07.280 --> 00:10:11.470
And on a desktop machine, we
probably do have two 24 inch

00:10:11.470 --> 00:10:13.520
monitors, at least we do.

00:10:13.520 --> 00:10:15.700
But you'll at least have one.

00:10:15.700 --> 00:10:19.490
And it's quite likely that
content on websites is being

00:10:19.490 --> 00:10:23.300
displayed next to each other, or
often in multiple columns.

00:10:23.300 --> 00:10:25.630
Just because all this screen
estate is available.

00:10:25.630 --> 00:10:28.935
And it's really a shame if
you let it go to waste.

00:10:28.935 --> 00:10:31.420
On a mobile device, this
is quite different.

00:10:31.420 --> 00:10:32.720
You have a lot less space.

00:10:32.720 --> 00:10:35.500
And content which can be
displayed next to each other

00:10:35.500 --> 00:10:37.590
might actually be more
convenient if you display it

00:10:37.590 --> 00:10:39.970
on top of each other
on a mobile device.

00:10:39.970 --> 00:10:42.590
And the CSS Flexible Box
Module allows you to do

00:10:42.590 --> 00:10:43.785
exactly this.

00:10:43.785 --> 00:10:49.050
It allows you to reorder the
content on the fly, reorder it

00:10:49.050 --> 00:10:53.070
based on putting an element
above the other using CSS, or

00:10:53.070 --> 00:10:55.750
even changing the entire
flow of your content.

00:10:55.750 --> 00:10:58.300
Now, one thing to keep in mind
is that the syntax of the

00:10:58.300 --> 00:11:01.010
Flexible Box Module
changed recently.

00:11:01.010 --> 00:11:04.260
And it's a little bit awkward,
but you may have to support

00:11:04.260 --> 00:11:07.190
both the old and the new syntax
until enough browsers

00:11:07.190 --> 00:11:10.330
hit the new syntax.

00:11:10.330 --> 00:11:12.855
And we all know fixed
position elements.

00:11:12.855 --> 00:11:14.450
They stick around on
your viewport.

00:11:14.450 --> 00:11:17.110
Could be useful for like
a navigation bar.

00:11:17.110 --> 00:11:20.160
But fixed position elements
have got a little brother

00:11:20.160 --> 00:11:22.860
called sticky position
elements.

00:11:22.860 --> 00:11:26.350
These behave like inline inflow
elements, just as if

00:11:26.350 --> 00:11:29.210
they're relatively positioned,
unless the parent element

00:11:29.210 --> 00:11:31.050
partially moves out of view.

00:11:31.050 --> 00:11:33.510
In that case, the browser will
make sure that the sticky

00:11:33.510 --> 00:11:37.160
positioned element kind of
sticks around in a few parts,

00:11:37.160 --> 00:11:40.650
which is quite a cool feature
which is really useful for, as

00:11:40.650 --> 00:11:44.990
an example, the address book
showed on the slide.

00:11:44.990 --> 00:11:45.420
PAUL KINLAN: Cool.

00:11:45.420 --> 00:11:48.010
So we said earlier on that
users are mobile.

00:11:48.010 --> 00:11:49.990
And we're trying to talk about
the idea that they might not

00:11:49.990 --> 00:11:51.190
always have an Internet
connection.

00:11:51.190 --> 00:11:54.220
They might be in a place where
maybe they're on a train for

00:11:54.220 --> 00:11:56.130
instance, where they go
through a tunnel.

00:11:56.130 --> 00:11:57.750
And the Internet connection
dies.

00:11:57.750 --> 00:12:00.220
And on the mobile web, just
generally that experience is

00:12:00.220 --> 00:12:01.390
pretty bad.

00:12:01.390 --> 00:12:02.800
So we're going to look at
a couple of different

00:12:02.800 --> 00:12:06.460
technologies that you can use
today pretty much across all

00:12:06.460 --> 00:12:09.360
of the mobile web to actually
accommodate the fact that your

00:12:09.360 --> 00:12:11.170
users are mobile.

00:12:11.170 --> 00:12:12.425
Now, I want to do
a little survey.

00:12:12.425 --> 00:12:15.850
Who knows the Geolocation API?

00:12:15.850 --> 00:12:16.980
OK, not actually--

00:12:16.980 --> 00:12:18.430
I was expecting more people.

00:12:18.430 --> 00:12:21.160
So anyway, the Geolocation API,
it's been around on the

00:12:21.160 --> 00:12:23.080
web for quite a long time now.

00:12:23.080 --> 00:12:25.580
And it's really good for
specializing content, for

00:12:25.580 --> 00:12:28.450
instance, on new sites where
you'll say, where is the user?

00:12:28.450 --> 00:12:29.450
Oh, they're based in the UK.

00:12:29.450 --> 00:12:31.610
We're going to give them
UK based news.

00:12:31.610 --> 00:12:35.325
Now, users, developers in
fact, always used to use

00:12:35.325 --> 00:12:36.930
reverse IP look up.

00:12:36.930 --> 00:12:38.930
On mobile, that's not as
applicable anymore.

00:12:38.930 --> 00:12:41.260
And especially if you want to
get fine grained control of

00:12:41.260 --> 00:12:43.810
where the user is and understand
where they are, you

00:12:43.810 --> 00:12:45.995
need an API like the
Geolocation API.

00:12:45.995 --> 00:12:47.490
And it's a pretty simple API.

00:12:47.490 --> 00:12:48.750
You get Chrome composition.

00:12:48.750 --> 00:12:51.050
And after a short time, it will
basically tell you the

00:12:51.050 --> 00:12:52.630
users' code and location.

00:12:52.630 --> 00:12:54.860
There's actually an accuracy
level, as well.

00:12:54.860 --> 00:12:57.210
And kind of what Android does
as well at the moment is it

00:12:57.210 --> 00:12:59.810
will give you that location
pretty quickly, but it's not

00:12:59.810 --> 00:13:00.600
hugely accurate.

00:13:00.600 --> 00:13:03.530
It might be within, say, 100
meters of where the user is.

00:13:03.530 --> 00:13:05.450
If you want to get a more
accurate look on the user,

00:13:05.450 --> 00:13:08.680
there's another API called Watch
Position, which actually

00:13:08.680 --> 00:13:10.100
it does exactly what it says.

00:13:10.100 --> 00:13:13.240
It watches the user's position
whilst they're on that page.

00:13:13.240 --> 00:13:15.090
And it could be used for
situations where you're trying

00:13:15.090 --> 00:13:17.110
to track the user when they're
walking down the street.

00:13:17.110 --> 00:13:18.950
And you can update a map.

00:13:18.950 --> 00:13:21.910
Or it could just be used
to get a final lock on

00:13:21.910 --> 00:13:23.050
where the user is.

00:13:23.050 --> 00:13:26.260
So you for instance could say,
well, the first request is

00:13:26.260 --> 00:13:27.180
within 100 meters.

00:13:27.180 --> 00:13:28.770
And then after a couple
of seconds--

00:13:28.770 --> 00:13:29.940
and you'll probably
see from this demo

00:13:29.940 --> 00:13:32.280
if it actually works--

00:13:32.280 --> 00:13:33.650
the accuracy level changes.

00:13:33.650 --> 00:13:35.790
So it goes from say an
accuracy level of 11

00:13:35.790 --> 00:13:37.640
to 10 to 9 to 8.

00:13:37.640 --> 00:13:39.980
And as it gets more accurate,
your position gets more and

00:13:39.980 --> 00:13:42.470
more close to where
the user is.

00:13:42.470 --> 00:13:44.660
PETER BEVERLOO: So if you saw
the keynote yesterday morning,

00:13:44.660 --> 00:13:47.170
in the Android parts, they
introduced a new version of

00:13:47.170 --> 00:13:48.770
the Google Play surfaces.

00:13:48.770 --> 00:13:53.030
And this has a feature called
the User Location Profiler.

00:13:53.030 --> 00:13:55.290
And the User Location Profiler
will actually mean that the

00:13:55.290 --> 00:13:58.270
phone has a guessed position
of where the user is.

00:13:58.270 --> 00:14:01.850
So Get Current Position will be
able to more quickly return

00:14:01.850 --> 00:14:05.770
a more accurate position if you
use this new version of

00:14:05.770 --> 00:14:08.970
the Android place of this.

00:14:08.970 --> 00:14:09.750
PAUL KINLAN: So you know
where the user is.

00:14:09.750 --> 00:14:11.620
And you're trying to not
necessarily track them but

00:14:11.620 --> 00:14:13.350
understand where they are
so you can adapt your

00:14:13.350 --> 00:14:14.750
application.

00:14:14.750 --> 00:14:17.140
Device Orientation is another
feature that is available

00:14:17.140 --> 00:14:19.210
pretty much across most
of the mobile web.

00:14:19.210 --> 00:14:21.580
And device orientation, it's
a pretty simple API.

00:14:21.580 --> 00:14:23.890
We saw the CSS before where you
could understand whether

00:14:23.890 --> 00:14:26.390
the user was in portrait
or landscape mode.

00:14:26.390 --> 00:14:28.800
The orientation events basically
fire whenever the

00:14:28.800 --> 00:14:30.130
user moves their phone.

00:14:30.130 --> 00:14:31.870
So if they're holding the
phone this way, you can

00:14:31.870 --> 00:14:33.660
understand the angle, the
pitch, which is the beta

00:14:33.660 --> 00:14:36.040
properly of how they're
holding their phone.

00:14:36.040 --> 00:14:38.990
And you can also understand with
a relatively decent level

00:14:38.990 --> 00:14:40.990
of accuracy their compass
location, which

00:14:40.990 --> 00:14:42.020
is the alpha property.

00:14:42.020 --> 00:14:44.540
And I think technically
it's called your.

00:14:44.540 --> 00:14:46.820
It's pretty well supported
across the mobile web.

00:14:46.820 --> 00:14:48.150
And you can use it today.

00:14:48.150 --> 00:14:50.390
It's been around for about at
least a year and a half.

00:14:50.390 --> 00:14:51.950
So we know where the user is.

00:14:51.950 --> 00:14:54.490
And we're trying to help you
build applications which are

00:14:54.490 --> 00:14:57.160
responsible to how they're
holding their phone.

00:14:57.160 --> 00:14:59.800
The biggest problem that we face
in the mobile web with

00:14:59.800 --> 00:15:02.570
regards to users on the
move is offline.

00:15:02.570 --> 00:15:04.120
Now offline is super
important.

00:15:04.120 --> 00:15:05.610
And if you're an application
developer, a native

00:15:05.610 --> 00:15:08.320
application developer, you've
already got offline supported.

00:15:08.320 --> 00:15:10.590
You build your applications to
work offline straight away.

00:15:10.590 --> 00:15:12.830
And then integrate online
functionality in.

00:15:12.830 --> 00:15:15.310
We as web developers, like,
everything is always online.

00:15:15.310 --> 00:15:16.120
We go to a URL.

00:15:16.120 --> 00:15:17.310
We always get it.

00:15:17.310 --> 00:15:19.450
And it actually is pretty hard
to integrate offline

00:15:19.450 --> 00:15:21.660
functionality into
our applications.

00:15:21.660 --> 00:15:23.840
The first thing that we can do
though is we can look and

00:15:23.840 --> 00:15:27.290
understand when the user is
either online or offline.

00:15:27.290 --> 00:15:29.300
Now it's not entirely
accurate.

00:15:29.300 --> 00:15:30.960
And you can understand exactly
when they're offline.

00:15:30.960 --> 00:15:33.360
Because they have no network
connection, basically.

00:15:33.360 --> 00:15:34.860
But the online state
is a little bit

00:15:34.860 --> 00:15:35.940
more awkward, right?

00:15:35.940 --> 00:15:37.140
You could be online.

00:15:37.140 --> 00:15:39.860
You could be on a local network,
a Wi-Fi connection

00:15:39.860 --> 00:15:41.580
but have no Internet
connection.

00:15:41.580 --> 00:15:44.430
So the online event really just
basically means that you

00:15:44.430 --> 00:15:45.760
have a connection
to a network.

00:15:45.760 --> 00:15:47.870
It might not be a connection
to the Internet.

00:15:47.870 --> 00:15:49.810
And there's a property that you
can want to see whether

00:15:49.810 --> 00:15:51.210
you are online or not.

00:15:51.210 --> 00:15:53.470
And this is great for when you
are building an application,

00:15:53.470 --> 00:15:55.560
and the users going to
submit the form.

00:15:55.560 --> 00:15:56.830
You can just basically
say, hey, you

00:15:56.830 --> 00:15:57.930
can't submit this form.

00:15:57.930 --> 00:15:58.550
You're offline.

00:15:58.550 --> 00:16:01.390
So you can provide a nice little
bit of feedback there.

00:16:01.390 --> 00:16:02.560
You go one step further.

00:16:02.560 --> 00:16:05.850
You understand when the user
is online or offline.

00:16:05.850 --> 00:16:07.130
They go to the URL bar.

00:16:07.130 --> 00:16:08.220
They press Refresh.

00:16:08.220 --> 00:16:10.610
And then they get this really
horrible gateway error or a

00:16:10.610 --> 00:16:13.910
Chrome error that says like,
hey, no Internet connection.

00:16:13.910 --> 00:16:15.030
You can't do anything.

00:16:15.030 --> 00:16:16.270
That's a really bad
experience.

00:16:16.270 --> 00:16:17.600
And that's one of the things
that's holding

00:16:17.600 --> 00:16:19.070
the mobile web back.

00:16:19.070 --> 00:16:22.530
Well, this application, or
Application Cache, this API

00:16:22.530 --> 00:16:24.850
has been around for quite
a long time now.

00:16:24.850 --> 00:16:26.100
And a lot of people
don't like it.

00:16:26.100 --> 00:16:27.460
It's got a bit of a bad press.

00:16:27.460 --> 00:16:29.640
But if you're building an
application which is like a

00:16:29.640 --> 00:16:33.160
single page application, this
API will help you easily make

00:16:33.160 --> 00:16:34.880
your application work offline.

00:16:34.880 --> 00:16:37.470
And it does so by basically
listing a whole series of

00:16:37.470 --> 00:16:39.540
files which encompass
your application.

00:16:39.540 --> 00:16:41.530
It's called the application
manifest.

00:16:41.530 --> 00:16:43.930
And in your HTML, you point
to the manifest using the

00:16:43.930 --> 00:16:44.735
manifest attribute.

00:16:44.735 --> 00:16:48.060
And the browser will then go
off, make sure all the assets

00:16:48.060 --> 00:16:49.240
are available for offline use.

00:16:49.240 --> 00:16:51.720
So when you press Refresh,
you'll still be able to get

00:16:51.720 --> 00:16:52.810
your application.

00:16:52.810 --> 00:16:55.660
And I must warn you, there's a
whole lot of photos of my face

00:16:55.660 --> 00:16:58.280
entirely through this
presentation.

00:16:58.280 --> 00:16:59.580
I guess it's the only one
we had rights to.

00:16:59.580 --> 00:17:03.010
And he didn't want me to
do anything with his.

00:17:03.010 --> 00:17:04.780
So anyway, so that's the
Application Cache.

00:17:04.780 --> 00:17:07.050
There are a couple of
little caveats.

00:17:07.050 --> 00:17:09.740
If you update any of your
assets, and then you expect

00:17:09.740 --> 00:17:11.329
the user to be able to
get them, they won't.

00:17:11.329 --> 00:17:12.770
They need to update the
manifest, or you need to

00:17:12.770 --> 00:17:15.329
update the manifest for them
to go and get that data.

00:17:15.329 --> 00:17:17.410
And if you cache the manifest
itself, you're just into a

00:17:17.410 --> 00:17:18.750
whole heap of pain.

00:17:18.750 --> 00:17:20.420
Because you'll never be able
to update the manifest,

00:17:20.420 --> 00:17:21.850
because everyone will always
have the manifest--

00:17:21.850 --> 00:17:23.630
oh, it's a nightmare.

00:17:23.630 --> 00:17:25.869
Anyway, we have storage
APIs, right?

00:17:25.869 --> 00:17:27.700
We have this idea that
our applications are

00:17:27.700 --> 00:17:29.040
going to work offline.

00:17:29.040 --> 00:17:31.150
And for them to work offline, we
need to make sure our data

00:17:31.150 --> 00:17:32.190
is offline.

00:17:32.190 --> 00:17:34.610
And you know, we're not actually
in a great position,

00:17:34.610 --> 00:17:37.030
are we, on the mobile
web at the moment?

00:17:37.030 --> 00:17:38.060
We have local storage.

00:17:38.060 --> 00:17:41.120
Local storage, key value pair
system-- you can blobs of data

00:17:41.120 --> 00:17:44.020
and strings of data and get
them out and fire a key.

00:17:44.020 --> 00:17:45.070
And it's ubiquitous.

00:17:45.070 --> 00:17:47.550
It's on every single
platform available.

00:17:47.550 --> 00:17:49.930
However, you can't really do
any rich, powerful querying

00:17:49.930 --> 00:17:51.320
semantics with it.

00:17:51.320 --> 00:17:52.850
We have two other APIs, Web SQL

00:17:52.850 --> 00:17:55.590
Database and Indexed Database.

00:17:55.590 --> 00:17:57.040
Web SQL, it's kind of cool.

00:17:57.040 --> 00:17:57.815
Everyone knows SQL.

00:17:57.815 --> 00:17:59.984
Hands up if you know SQL?

00:17:59.984 --> 00:18:00.432
See.

00:18:00.432 --> 00:18:02.290
Are there any browser
vendors in here who

00:18:02.290 --> 00:18:04.650
said, Web SQL's rubbish?

00:18:04.650 --> 00:18:06.780
Everyone said it's cool.

00:18:06.780 --> 00:18:09.180
So anyway, so Web SQL,
everyone knows SQL.

00:18:09.180 --> 00:18:11.830
It's got rich querying
semantics.

00:18:11.830 --> 00:18:13.420
However, it's not broadly
supported.

00:18:13.420 --> 00:18:15.110
It's not yet--

00:18:15.110 --> 00:18:16.720
it's in iOS, Android,
and Chrome.

00:18:16.720 --> 00:18:19.100
But it's not in Firefox.

00:18:19.100 --> 00:18:19.820
And it's not in Internet
Explorer.

00:18:19.820 --> 00:18:21.090
And it's no plans
to be in there.

00:18:21.090 --> 00:18:22.790
It's a deprecated API.

00:18:22.790 --> 00:18:24.090
We have Indexed Database.

00:18:24.090 --> 00:18:25.640
index Database is the way
that we're going to

00:18:25.640 --> 00:18:26.870
store data in the web.

00:18:26.870 --> 00:18:29.995
But it's not really
broadly supported.

00:18:29.995 --> 00:18:31.440
It's not on iOS.

00:18:31.440 --> 00:18:33.520
It's not on Android,
I think Chrome and

00:18:33.520 --> 00:18:35.010
the rest of the browsers.

00:18:35.010 --> 00:18:37.140
So what are you going to
do as a developer?

00:18:37.140 --> 00:18:40.220
Well, the only sane solution
that we've got is to use

00:18:40.220 --> 00:18:41.800
abstractions and use shims.

00:18:41.800 --> 00:18:43.180
There are a couple of
shims out there.

00:18:43.180 --> 00:18:45.110
Lawn Chair has been around
for a long, long time.

00:18:45.110 --> 00:18:48.090
And it's basically a key value
pair system with some query

00:18:48.090 --> 00:18:51.230
semantics, where you can plug
in your own custom providers

00:18:51.230 --> 00:18:53.400
to say, hey, I want to
use Web SQL database.

00:18:53.400 --> 00:18:55.200
Or hey, I'm going to use
Indexed Database.

00:18:55.200 --> 00:18:57.500
And then there's two others,
asyncStorage, which is similar

00:18:57.500 --> 00:19:00.000
to Lawn Chair, and then the
Indexed Database shim.

00:19:00.000 --> 00:19:02.590
And the Indexed Database shim
basically says, you know what?

00:19:02.590 --> 00:19:05.190
We're going to use the Indexed
Database API if it's there.

00:19:05.190 --> 00:19:07.540
If it's not there, we're just
going to fall back to Web SQL.

00:19:07.540 --> 00:19:09.990
And if you have that method,
where you can fall back from

00:19:09.990 --> 00:19:12.920
Indexed Database to Web SQL, you
can cover pretty much all

00:19:12.920 --> 00:19:15.110
the mobile web for
storing offline.

00:19:17.980 --> 00:19:20.000
PETER BEVERLOO: So input on
a mobile device is harder.

00:19:20.000 --> 00:19:20.670
We notice.

00:19:20.670 --> 00:19:22.590
We don't write essays
on a mobile device.

00:19:22.590 --> 00:19:24.760
And for the major share, they're
actually used for

00:19:24.760 --> 00:19:27.590
consumption of data rather
than producing data.

00:19:27.590 --> 00:19:30.360
Now, this shows when you have
a form on your website, even

00:19:30.360 --> 00:19:32.620
if it's just a login form
or a form where a user

00:19:32.620 --> 00:19:33.810
has to enter a number.

00:19:33.810 --> 00:19:35.280
It's just awkward to enter it.

00:19:35.280 --> 00:19:38.280
Especially on a mobile device
like a phone, you look at this

00:19:38.280 --> 00:19:42.910
on screen keyboards, and it's
just basically awkward to use.

00:19:42.910 --> 00:19:44.570
I often click on the
wrong letter.

00:19:44.570 --> 00:19:47.350
And I've learned to rely on the
auto correction feature,

00:19:47.350 --> 00:19:50.070
or even on the suggestions,
which can be displayed above

00:19:50.070 --> 00:19:54.310
the keyboard itself, which is
something Android does.

00:19:54.310 --> 00:19:57.970
Now, you've probably heard this
a million times already.

00:19:57.970 --> 00:20:00.250
Use semantical input types.

00:20:00.250 --> 00:20:01.050
It's quite simple.

00:20:01.050 --> 00:20:04.360
Instead of using input type as
text, you use input type with

00:20:04.360 --> 00:20:06.920
a more specialized type.

00:20:06.920 --> 00:20:09.960
A good example of this is using
input types number.

00:20:09.960 --> 00:20:12.160
If you want the user to enter
a number, which could be a

00:20:12.160 --> 00:20:15.090
telephone number or a price or
anything else, you really

00:20:15.090 --> 00:20:18.310
don't want to have them go
through the hassle of seeing

00:20:18.310 --> 00:20:21.150
letters, chapters on their
keyboards, having to click on

00:20:21.150 --> 00:20:23.980
shift, and then finding really
small buttons of the numbers.

00:20:23.980 --> 00:20:26.520
Well, the phone has a perfectly
optimized keyboard

00:20:26.520 --> 00:20:28.940
just showing numbers.

00:20:28.940 --> 00:20:33.880
Now, a more extreme example
probably is data time input.

00:20:33.880 --> 00:20:36.760
I'm from the UK, as is Paul.

00:20:36.760 --> 00:20:40.480
And date and time, I believe
here you write month first and

00:20:40.480 --> 00:20:42.250
then the day and
then the year.

00:20:42.250 --> 00:20:43.160
For us, it's different.

00:20:43.160 --> 00:20:44.620
From other countries, it's
different again.

00:20:44.620 --> 00:20:46.398
PAUL KINLAN: I believe the UK
has the correct format.

00:20:50.390 --> 00:20:51.810
PETER BEVERLOO: D is, that's
just to separate the

00:20:51.810 --> 00:20:54.730
components of a date,
or D is slashes.

00:20:54.730 --> 00:20:55.990
And really, it's just awkward.

00:20:55.990 --> 00:20:59.130
And it's not just difficult for
the end user using your

00:20:59.130 --> 00:21:00.580
website, but it's
also difficult

00:21:00.580 --> 00:21:01.900
for you as a developer.

00:21:01.900 --> 00:21:04.650
Because users give all these
days in random input types.

00:21:04.650 --> 00:21:06.750
And you have to write
complicated procedures in your

00:21:06.750 --> 00:21:08.750
back end to handle
all of them.

00:21:08.750 --> 00:21:11.710
Now if you would just change
that input type as text to

00:21:11.710 --> 00:21:15.220
input type as date or even input
type data and local.

00:21:15.220 --> 00:21:17.170
Then the phone will be
able to do something

00:21:17.170 --> 00:21:19.050
really smart and simple.

00:21:19.050 --> 00:21:20.290
It's actually a no brainer.

00:21:20.290 --> 00:21:23.030
It will show you a date
and time picker.

00:21:23.030 --> 00:21:25.880
And by a date and time picker,
that makes it infinitely

00:21:25.880 --> 00:21:30.160
easier to enter a data or time
for a site, and will give you

00:21:30.160 --> 00:21:32.860
as a developer a more consistent
result when a user

00:21:32.860 --> 00:21:35.780
submits that form
to the website.

00:21:35.780 --> 00:21:40.510
Now, this doesn't just
result in more

00:21:40.510 --> 00:21:42.210
convenience for the user.

00:21:42.210 --> 00:21:45.080
Another additional benefit you
get from this is validation,

00:21:45.080 --> 00:21:48.180
client side validation of
the input type itself.

00:21:48.180 --> 00:21:52.720
But if a user somehow manages to
enter rubbish, the browser

00:21:52.720 --> 00:21:55.420
will show a dialogue about, I
don't know what you're doing.

00:21:55.420 --> 00:21:58.230
But this is not quite what the
website will be expecting.

00:21:58.230 --> 00:21:59.910
You want to correct this.

00:21:59.910 --> 00:22:02.980
And you can use attributes,
that's just min and max, to

00:22:02.980 --> 00:22:07.690
actually impose a range based on
which number or which date

00:22:07.690 --> 00:22:11.010
can be entered by
the end user.

00:22:11.010 --> 00:22:13.665
Now, when I use my desktop
computer, I have this small

00:22:13.665 --> 00:22:15.620
device next to me, a mouse.

00:22:15.620 --> 00:22:18.620
And this gives me a cursor on
the screen itself, which is

00:22:18.620 --> 00:22:20.210
incredibly accurate.

00:22:20.210 --> 00:22:21.730
It's really convenient to use.

00:22:21.730 --> 00:22:24.200
It allows me to select any
element or any position on my

00:22:24.200 --> 00:22:26.950
screen with really
high accuracy,

00:22:26.950 --> 00:22:29.530
Now, I don't know about you
guys, but in comparison to

00:22:29.530 --> 00:22:32.420
that mouse pointer,
my finger is fat.

00:22:32.420 --> 00:22:33.510
It's really fat.

00:22:33.510 --> 00:22:37.400
It's inaccurate and it becomes
infinitely harder to click on

00:22:37.400 --> 00:22:39.780
exactly the point on the
screen where I want.

00:22:39.780 --> 00:22:41.930
And this has forced browsers
to implement alternative

00:22:41.930 --> 00:22:46.370
solutions such as Chrome's
disambiguation pop up, which

00:22:46.370 --> 00:22:49.470
basically zooms in on part of
the page, allowing you to

00:22:49.470 --> 00:22:50.990
clarify what you mean.

00:22:50.990 --> 00:22:54.300
Or for Safari, to have a number
of heuristics available

00:22:54.300 --> 00:22:57.170
to think what you might want
to have clicked on.

00:22:57.170 --> 00:22:59.440
Now, you can optimize
for this.

00:22:59.440 --> 00:23:01.405
There are three primary
events available.

00:23:01.405 --> 00:23:03.930
And that's Start, which will
be called when you put a

00:23:03.930 --> 00:23:06.780
finger on the screen, On Touch
Move, when you actually move

00:23:06.780 --> 00:23:10.700
on a screen, and On Touch End,
when you remove the finger

00:23:10.700 --> 00:23:12.180
from the screen again.

00:23:12.180 --> 00:23:15.060
And this allows you to optimize
your application for

00:23:15.060 --> 00:23:16.080
touch inputs.

00:23:16.080 --> 00:23:19.360
And maybe have a slightly bigger
error margins, because

00:23:19.360 --> 00:23:21.200
it's more inaccurate.

00:23:21.200 --> 00:23:23.390
Or have a different UI,
different handling all

00:23:23.390 --> 00:23:26.910
together based on what a user
does with their fingers.

00:23:26.910 --> 00:23:29.750
Now, there's one thing
to keep in mind here.

00:23:29.750 --> 00:23:32.940
There is a small click delay
imposed by the browser.

00:23:32.940 --> 00:23:36.190
When you tap on the screen
itself and remove your finger

00:23:36.190 --> 00:23:37.440
again, that's a tap.

00:23:37.440 --> 00:23:40.710
But there is this gesture
available in Chrome called

00:23:40.710 --> 00:23:42.200
double tap to zoom.

00:23:42.200 --> 00:23:45.290
Now, if you double tap on the
screen, it will zoom in to

00:23:45.290 --> 00:23:45.880
that element.

00:23:45.880 --> 00:23:48.360
And the page will not receive
a click element.

00:23:48.360 --> 00:23:51.010
The browser needs a little bit
of time to actually figure out

00:23:51.010 --> 00:23:53.460
whether you want to tap
once or tap twice.

00:23:53.460 --> 00:23:56.240
And before it knows that,
it will wait.

00:23:56.240 --> 00:23:59.622
And after that wait, it will
send to click event.

00:23:59.622 --> 00:24:03.590
Now, 300 milliseconds is quite
a long time if you want to

00:24:03.590 --> 00:24:06.420
have a responsive
user interface.

00:24:06.420 --> 00:24:08.410
It's a number of frames.

00:24:08.410 --> 00:24:10.380
It's actually 20 frames.

00:24:10.380 --> 00:24:12.690
That's quite a lot.

00:24:12.690 --> 00:24:18.270
So you should be really careful
with, well, you can

00:24:18.270 --> 00:24:21.430
avoid it if you set a viewport
rule on your page.

00:24:21.430 --> 00:24:24.350
And the next feature, Pointer
Events, also provides a

00:24:24.350 --> 00:24:26.500
solution to this.

00:24:26.500 --> 00:24:28.740
Pointer Events is a
specification which is still

00:24:28.740 --> 00:24:32.150
in development, which unifies
certain concepts.

00:24:32.150 --> 00:24:35.610
It unifies a concept of a mouse
pointer and touch inputs

00:24:35.610 --> 00:24:38.950
and, for example, a stylus into
the concept of a pointer,

00:24:38.950 --> 00:24:41.220
which really could be anything,
without losing too

00:24:41.220 --> 00:24:46.200
much of the pointer specific
information or constraints.

00:24:46.200 --> 00:24:49.720
The JavaScript imperative event
API is quite similar to

00:24:49.720 --> 00:24:51.490
what we're used to from
mouse events.

00:24:51.490 --> 00:24:54.690
Instead of mouse in the name,
you'll have pointer.

00:24:54.690 --> 00:24:57.970
And it will allow you to
create a flow in your

00:24:57.970 --> 00:25:00.750
application to handle both touch
inputs and mouse input

00:25:00.750 --> 00:25:03.050
using the same code.

00:25:03.050 --> 00:25:06.350
Now, this specification also
comes with a simple CSS

00:25:06.350 --> 00:25:08.100
property called .action.

00:25:08.100 --> 00:25:11.420
And if you specify .action as
none on any element, you will

00:25:11.420 --> 00:25:13.965
actually tell the browser that
if the user taps on exactly

00:25:13.965 --> 00:25:17.760
that element, that the
browser shouldn't

00:25:17.760 --> 00:25:19.350
do any default action.

00:25:19.350 --> 00:25:22.680
And thereby, the double click to
zoom just here won't work.

00:25:22.680 --> 00:25:24.870
And because it won't work, the
browser doesn't have to wait

00:25:24.870 --> 00:25:26.180
300 milliseconds.

00:25:26.180 --> 00:25:28.340
And can immediately forward
to defend that click

00:25:28.340 --> 00:25:30.580
event to the browser.

00:25:30.580 --> 00:25:33.540
Quite related but not
specifically part of the

00:25:33.540 --> 00:25:37.040
Pointer Event specification
are the pointer directives

00:25:37.040 --> 00:25:39.130
available from Media Queries.

00:25:39.130 --> 00:25:42.070
And by specifying point of
course for fingers or pointer

00:25:42.070 --> 00:25:44.970
find from mouse pointers, you
can actually have different

00:25:44.970 --> 00:25:47.360
sets of styling based on whether
the device the user is

00:25:47.360 --> 00:25:49.980
viewing your websites
with is capable of a

00:25:49.980 --> 00:25:51.230
certain kind of input.

00:25:53.560 --> 00:25:55.080
Pixel supports both.

00:25:55.080 --> 00:25:57.280
So there is a little bit
of trickery you have to

00:25:57.280 --> 00:25:58.930
keep in mind here.

00:25:58.930 --> 00:25:59.740
PAUL KINLAN: One quick point.

00:25:59.740 --> 00:26:03.140
Are we actually implementing
this in Chrome?

00:26:03.140 --> 00:26:04.860
PETER BEVERLOO: There was an
intent to implement which we

00:26:04.860 --> 00:26:06.790
received from Microsoft.

00:26:06.790 --> 00:26:07.480
PAUL KINLAN: But that
doesn't mean we're

00:26:07.480 --> 00:26:09.130
implementing it just yet.

00:26:09.130 --> 00:26:09.860
PETER BEVERLOO: We're
implementing parts of it.

00:26:09.860 --> 00:26:10.260
PAUL KINLAN: Oh.

00:26:10.260 --> 00:26:10.660
OK.

00:26:10.660 --> 00:26:11.460
Cool.

00:26:11.460 --> 00:26:14.610
So each of our devices has
unique capabilities such as

00:26:14.610 --> 00:26:17.790
GPS, a location which we saw
earlier for the Geolocation

00:26:17.790 --> 00:26:20.940
API, and cameras, and a whole
host of other things.

00:26:20.940 --> 00:26:22.800
What can we take advantage
of on the web today?

00:26:22.800 --> 00:26:25.160
And what is pretty ubiquitous?

00:26:25.160 --> 00:26:27.910
Well, like two years ago, we
also spoke about this.

00:26:27.910 --> 00:26:29.150
And no one seems
to be using it.

00:26:29.150 --> 00:26:31.980
But you can actually take
pictures used from the user's

00:26:31.980 --> 00:26:36.150
phone using the simple input
type equals file, and put the

00:26:36.150 --> 00:26:38.030
capture attribute at
the top there.

00:26:38.030 --> 00:26:40.440
And what that essentially
indicates to the browser or

00:26:40.440 --> 00:26:43.500
the user agent is that you
should be able to pick whether

00:26:43.500 --> 00:26:45.060
you're going to take a
picture or something

00:26:45.060 --> 00:26:46.340
from the user's gallery.

00:26:46.340 --> 00:26:48.240
And I've actually set up
my Android device here.

00:26:48.240 --> 00:26:49.260
Like I said, I'm vain.

00:26:49.260 --> 00:26:51.320
So there's obviously lots
of pictures of me.

00:26:51.320 --> 00:26:53.790
My Android device, you have to
automatically use the camera.

00:26:53.790 --> 00:26:54.970
But it's really cool,
this API.

00:26:54.970 --> 00:26:57.010
Because it's like a
normal input type.

00:26:57.010 --> 00:26:59.270
If there's no support for the
camera there, it'll just let

00:26:59.270 --> 00:27:01.125
you pick just from
the gallery.

00:27:01.125 --> 00:27:04.040
Now, the really cool, cool
thing about this is that

00:27:04.040 --> 00:27:06.270
because it's a dom element,
there's an on change event

00:27:06.270 --> 00:27:09.150
which happens which allows you
to get access to the raw data

00:27:09.150 --> 00:27:11.380
that was delivered from the
file system into your

00:27:11.380 --> 00:27:11.695
application.

00:27:11.695 --> 00:27:14.200
And then you can manipulate it
however you want using the

00:27:14.200 --> 00:27:17.090
file reader and file
writer APIs.

00:27:17.090 --> 00:27:19.160
The logical extension to this,
and the thing that we found

00:27:19.160 --> 00:27:21.540
from native applications at
least anyway, is that

00:27:21.540 --> 00:27:23.710
developers don't really want
to have their applications,

00:27:23.710 --> 00:27:26.145
and users don't want them
either, to have to go out from

00:27:26.145 --> 00:27:28.590
one application and jump into
another application just to

00:27:28.590 --> 00:27:29.060
take a picture.

00:27:29.060 --> 00:27:32.010
They want this nice, seamless,
integrated experience.

00:27:32.010 --> 00:27:35.300
Well, part of the WebRTC
specification is getUserMedia.

00:27:35.300 --> 00:27:38.580
And getUserMedia delivers you
basically video and audio

00:27:38.580 --> 00:27:40.410
streams from the
user's webcam.

00:27:40.410 --> 00:27:42.045
Now, the really nice thing about
this is you're sitting

00:27:42.045 --> 00:27:43.210
there going, it's the
video stream.

00:27:43.210 --> 00:27:44.910
It's not really a picture.

00:27:44.910 --> 00:27:46.090
Well, the code's not in here.

00:27:46.090 --> 00:27:48.810
And it's inside the demo, but
you'll basically be able to

00:27:48.810 --> 00:27:52.400
take a picture from the video
stream by just attaching it to

00:27:52.400 --> 00:27:53.150
a canvas element.

00:27:53.150 --> 00:27:54.700
And you can take it
out from there.

00:27:54.700 --> 00:27:57.740
So you have integrated access
to the user's web cam inside

00:27:57.740 --> 00:28:00.810
their phone just by using
this simple API.

00:28:00.810 --> 00:28:02.090
It's kind of in Chrome.

00:28:02.090 --> 00:28:03.350
It's actually in Chrome 5.

00:28:03.350 --> 00:28:05.380
So hopefully it will be
enabled pretty soon.

00:28:05.380 --> 00:28:07.490
But it's actually supported
across Firefox and other

00:28:07.490 --> 00:28:08.190
browsers, as well.

00:28:08.190 --> 00:28:09.370
So it's getting there.

00:28:09.370 --> 00:28:09.780
It's pretty nice.

00:28:09.780 --> 00:28:12.760
You can always fall back
to the other API.

00:28:12.760 --> 00:28:14.390
The other one is Android
Intents.

00:28:14.390 --> 00:28:16.525
If you're building an
application for Android, you

00:28:16.525 --> 00:28:19.340
normally know the Android
Intents system pretty well.

00:28:19.340 --> 00:28:21.660
Now, what you normally do is
you can communicate between

00:28:21.660 --> 00:28:24.600
apps by asking for an action
that says, I need an app that

00:28:24.600 --> 00:28:25.965
supports sharing.

00:28:25.965 --> 00:28:27.390
And that's cool.

00:28:27.390 --> 00:28:29.960
Now, the common thing is we
don't really have that on the

00:28:29.960 --> 00:28:31.340
web anymore.

00:28:31.340 --> 00:28:34.460
But we have this idea of,
well, my Android device

00:28:34.460 --> 00:28:35.550
supports intents.

00:28:35.550 --> 00:28:37.190
Can I invoke an intent
from the web?

00:28:37.190 --> 00:28:37.870
Well, you can.

00:28:37.870 --> 00:28:39.820
And it's supported in
the Android browser

00:28:39.820 --> 00:28:40.620
and the Chrome browser.

00:28:40.620 --> 00:28:43.580
And it allows us to open
applications from our site.

00:28:43.580 --> 00:28:45.550
So if you've built a native
application, you can just

00:28:45.550 --> 00:28:48.930
basically encode a special
URI, which is the intent

00:28:48.930 --> 00:28:51.790
call-on sequence, make sure your
application supports the

00:28:51.790 --> 00:28:54.070
browsable category, which
basically means, my

00:28:54.070 --> 00:28:56.820
application's allowed to be
opened by the browser.

00:28:56.820 --> 00:28:59.350
And any link that has this
scheme will be able to open up

00:28:59.350 --> 00:29:02.660
an application directly inside
the user's machine or inside

00:29:02.660 --> 00:29:03.470
their device.

00:29:03.470 --> 00:29:05.480
The really cool thing for me on
this side of things is the

00:29:05.480 --> 00:29:06.780
application isn't installed.

00:29:06.780 --> 00:29:09.670
Because you have to include
the package name of your

00:29:09.670 --> 00:29:10.200
application.

00:29:10.200 --> 00:29:12.980
You can actually direct the
user automatically to the

00:29:12.980 --> 00:29:13.830
Android store.

00:29:13.830 --> 00:29:16.720
And that's a pretty cool, pretty
powerful API to have

00:29:16.720 --> 00:29:18.570
when you want to get the user
to install your native

00:29:18.570 --> 00:29:21.260
application as well, by the
site of your web based

00:29:21.260 --> 00:29:22.170
application.

00:29:22.170 --> 00:29:23.970
And this demo is just
the QR code app.

00:29:23.970 --> 00:29:25.460
It's not just a normal camera.

00:29:25.460 --> 00:29:27.805
It's an application that
obviously uses the camera, but

00:29:27.805 --> 00:29:29.670
is dedicated to taking
QR codes.

00:29:29.670 --> 00:29:32.080
And we've integrated with that
with just that one line of

00:29:32.080 --> 00:29:36.000
code inside the Android
browser in Chrome.

00:29:36.000 --> 00:29:38.160
Now one of the cool things about
native applications is

00:29:38.160 --> 00:29:40.320
that your application
like basically takes

00:29:40.320 --> 00:29:41.510
up the entire screen.

00:29:41.510 --> 00:29:42.900
You don't have this horrible,
well it's not

00:29:42.900 --> 00:29:45.040
horrible URL bar.

00:29:45.040 --> 00:29:46.260
That's the wrong thing to say.

00:29:46.260 --> 00:29:48.810
It's like this awkward little
URL bar for your applications,

00:29:48.810 --> 00:29:50.775
normally with a forward and
backwards button and a refresh

00:29:50.775 --> 00:29:51.950
and all this type of stuff.

00:29:51.950 --> 00:29:54.680
Your application or game takes
up the entire screen.

00:29:54.680 --> 00:29:56.140
Well, this is coming
to Chrome as well.

00:29:56.140 --> 00:29:58.840
But basically, we have the
actual WebKit request full

00:29:58.840 --> 00:30:01.920
screen API implemented in
Chrome, which allows you to

00:30:01.920 --> 00:30:04.320
take any DOM element and
make it full screen.

00:30:04.320 --> 00:30:06.470
And this demo here, I've got
the ability to take the

00:30:06.470 --> 00:30:08.900
document, the entire page, or a
single element, which is an

00:30:08.900 --> 00:30:10.520
image, and make it
full screen.

00:30:10.520 --> 00:30:12.560
And there's an API which
actually cancels that out.

00:30:12.560 --> 00:30:15.090
So you can actually back
it up pretty easy.

00:30:15.090 --> 00:30:16.850
The other thing you'll notice
on the Chrome browser for

00:30:16.850 --> 00:30:19.930
Android is that we don't
actually yet support Scroll2,

00:30:19.930 --> 00:30:23.030
which is an iOS idiom basically
where you can push

00:30:23.030 --> 00:30:24.430
the address bar out the way.

00:30:24.430 --> 00:30:26.560
We don't support it yet, we
will do soon in some later

00:30:26.560 --> 00:30:27.100
builds, at least.

00:30:27.100 --> 00:30:28.160
That's right, isn't it?

00:30:28.160 --> 00:30:30.070
Yeah, we will definitely
support it.

00:30:30.070 --> 00:30:31.860
Which means that if you've got
an application which tries to

00:30:31.860 --> 00:30:32.930
push it out the way,
it'll work.

00:30:32.930 --> 00:30:34.980
And you'll have the same
experience inside the Chrome

00:30:34.980 --> 00:30:36.230
for Android browser.

00:30:38.850 --> 00:30:42.440
PETER BEVERLOO: So a biggest
mobile device is much smaller

00:30:42.440 --> 00:30:43.780
just in its physical size.

00:30:43.780 --> 00:30:47.200
And we can't put in all these
fancy GPUs and big components

00:30:47.200 --> 00:30:49.540
which are actually quite fast.

00:30:49.540 --> 00:30:51.420
There are a number
of limitations.

00:30:51.420 --> 00:30:53.400
Now, if you've been to the
Chrome stand upstairs, we

00:30:53.400 --> 00:30:56.230
categorize these limitations
in three categories.

00:30:56.230 --> 00:30:58.960
Firstly, computational
limitations.

00:30:58.960 --> 00:31:01.500
For example, in JavaScript,
execution speed.

00:31:01.500 --> 00:31:04.610
Rendering limitations in fast
scrolling or displaying your

00:31:04.610 --> 00:31:06.080
website in a quick way.

00:31:06.080 --> 00:31:08.380
But both of these have been
covered by a number of other

00:31:08.380 --> 00:31:09.930
presentations already.

00:31:09.930 --> 00:31:13.580
And you can definitely go back
to YouTube after Google I/O

00:31:13.580 --> 00:31:15.610
and watch these presentations.

00:31:15.610 --> 00:31:19.250
We want to look at two APIs
which are quite relevant to

00:31:19.250 --> 00:31:21.630
the network aspect
of limitations.

00:31:21.630 --> 00:31:24.620
Because the user can be on
the move at all times.

00:31:24.620 --> 00:31:26.150
Let's look at what happens
when a user

00:31:26.150 --> 00:31:27.520
navigates to a new page.

00:31:27.520 --> 00:31:30.010
Now, this could be because
they enter a URL in their

00:31:30.010 --> 00:31:30.780
address bar.

00:31:30.780 --> 00:31:33.880
Or this could be because
they click on a link.

00:31:33.880 --> 00:31:35.800
When a navigation
start, the first

00:31:35.800 --> 00:31:37.425
part will be the network.

00:31:37.425 --> 00:31:39.680
During this network phase, the
browser will have to figure

00:31:39.680 --> 00:31:41.640
out the DNS of your
web server.

00:31:41.640 --> 00:31:44.990
So it will have to change to a
domain name and an IP address.

00:31:44.990 --> 00:31:47.870
It will have to say hello
to the server.

00:31:47.870 --> 00:31:49.330
Basically, I want resources.

00:31:49.330 --> 00:31:50.640
Are you ready for me?

00:31:50.640 --> 00:31:52.200
And this takes some time.

00:31:52.200 --> 00:31:54.660
Now after this, it will start
loading the page.

00:31:54.660 --> 00:31:57.380
It will start sending messages
to the server about exactly

00:31:57.380 --> 00:31:59.250
which resources it wants.

00:31:59.250 --> 00:32:01.530
Unless of course, it finds
a redirection.

00:32:01.530 --> 00:32:06.470
When it does so, it restarts
the navigation based on

00:32:06.470 --> 00:32:09.590
exactly the URL, which is
one to redirect to.

00:32:09.590 --> 00:32:12.230
And that's valuable time
which is lost.

00:32:12.230 --> 00:32:15.450
And after it's loading and it
got the code of the research

00:32:15.450 --> 00:32:18.120
itself, it will start
to process the data.

00:32:18.120 --> 00:32:20.430
And for an HTML file, this
could, for example, means that

00:32:20.430 --> 00:32:22.490
it starts to build a dom.

00:32:22.490 --> 00:32:23.840
Now, there are a number
of things which

00:32:23.840 --> 00:32:25.050
could be slow here.

00:32:25.050 --> 00:32:27.460
And the only way to really
be sure of what

00:32:27.460 --> 00:32:30.180
is slow is to measure.

00:32:30.180 --> 00:32:33.930
So the Navigation Timing API
exposes a lot of data on all

00:32:33.930 --> 00:32:38.730
these items which allow you to,
with great accuracy, see

00:32:38.730 --> 00:32:42.860
what parts of loading the page
are taking out a lot of time.

00:32:42.860 --> 00:32:45.690
And this is actually reflected
in dev tools, as well.

00:32:45.690 --> 00:32:49.020
You can open dev tools in any
page, and it allows you to see

00:32:49.020 --> 00:32:52.650
the same in the Timeline
panel.

00:32:52.650 --> 00:32:56.220
Now, when I create a website,
it's not just a page of HTML

00:32:56.220 --> 00:32:58.350
which I will be delivering
to my users.

00:32:58.350 --> 00:32:59.200
I will have images.

00:32:59.200 --> 00:33:01.270
I will have style sheets.

00:33:01.270 --> 00:33:06.130
I'll probably have JavaScript
files as well, in some cases.

00:33:06.130 --> 00:33:10.865
And the resource timing API is
quite complementary to the

00:33:10.865 --> 00:33:14.050
Navigation Timing API, except
that it contains information

00:33:14.050 --> 00:33:16.805
about the timing of several
resources being load by the

00:33:16.805 --> 00:33:19.480
page instead of just
the page itself.

00:33:19.480 --> 00:33:22.390
This gets you much more high
fidelity information about

00:33:22.390 --> 00:33:23.770
each resource.

00:33:23.770 --> 00:33:27.260
And it will allow you to quickly
identify scripts or

00:33:27.260 --> 00:33:29.310
just allows you to file switcher
blocking the loading

00:33:29.310 --> 00:33:30.560
of your page.

00:33:33.390 --> 00:33:34.870
PAUL KINLAN: So we've seen some
amazing pictures of my

00:33:34.870 --> 00:33:37.010
face throughout this entire
presentation.

00:33:37.010 --> 00:33:38.530
And I really do apologize
for that.

00:33:38.530 --> 00:33:42.020
But I want to kind of highlight
some of the newer

00:33:42.020 --> 00:33:43.560
features that are coming
to the web platform.

00:33:43.560 --> 00:33:45.770
We've seen a lot of things
which, basically we've tried

00:33:45.770 --> 00:33:48.900
to say that the web platform on
mobile is just as competent

00:33:48.900 --> 00:33:50.240
as the desktop platform.

00:33:50.240 --> 00:33:52.140
But there are a couple of areas
where we've been kind of

00:33:52.140 --> 00:33:52.940
a little bit behind.

00:33:52.940 --> 00:33:54.820
And we're going to show you
some of these, which are

00:33:54.820 --> 00:33:57.870
experiment with features that
are available inside Chrome.

00:33:57.870 --> 00:34:01.430
The first is obviously the
extension to getUserMedia

00:34:01.430 --> 00:34:03.040
called WebRTC.

00:34:03.040 --> 00:34:05.000
Now, a lot of people have heard
about this in the sense

00:34:05.000 --> 00:34:08.743
that you can take one video
stream, audio stream, and pass

00:34:08.743 --> 00:34:12.020
it directly to another phone or
another device or another

00:34:12.020 --> 00:34:14.329
desktop machine without
having to proxy it

00:34:14.329 --> 00:34:15.650
through your own service.

00:34:15.650 --> 00:34:16.100
That's cool.

00:34:16.100 --> 00:34:17.389
That's like the peer
connection stuff.

00:34:17.389 --> 00:34:19.870
That's always, well, that's been
on the desktop side of

00:34:19.870 --> 00:34:21.120
things for a little while.

00:34:21.120 --> 00:34:23.420
One area that we don't really
talk about but it's actually

00:34:23.420 --> 00:34:25.139
landed in Chrome and
a couple of other

00:34:25.139 --> 00:34:26.810
browsers is the data channel.

00:34:26.810 --> 00:34:29.320
And the data channel allows you
to send data directly from

00:34:29.320 --> 00:34:31.110
one application to another.

00:34:31.110 --> 00:34:33.449
And there's a talk tomorrow by
Sam Dutton which is going to

00:34:33.449 --> 00:34:36.030
cover a lot of this area
around WebRTC.

00:34:36.030 --> 00:34:37.449
We can't do it justice today.

00:34:37.449 --> 00:34:38.830
But it is coming.

00:34:38.830 --> 00:34:41.150
And you can try it inside Chrome
flags today, inside

00:34:41.150 --> 00:34:42.480
Chrome already.

00:34:42.480 --> 00:34:45.040
If you're a developer, my
recommendation is, I don't

00:34:45.040 --> 00:34:48.420
really like the API that much,
but WebRTC to IO and EasyRTC.

00:34:48.420 --> 00:34:51.219
These APIs, these abstractions
on top of it, they work really

00:34:51.219 --> 00:34:53.750
well, and allow you to build
these type of applications in

00:34:53.750 --> 00:34:55.760
just a couple of
lines of code.

00:34:55.760 --> 00:34:56.949
The next is Web Audio.

00:34:56.949 --> 00:34:58.780
Games developers have been
wanting this for ages.

00:34:58.780 --> 00:35:02.110
Because they want to build real
time kind of low latency

00:35:02.110 --> 00:35:03.950
audio into their platform.

00:35:03.950 --> 00:35:06.110
And I'm not going to go into too
much again because it's a

00:35:06.110 --> 00:35:07.790
very long and complex subject.

00:35:07.790 --> 00:35:10.400
But it gives you near real
time access to the audio

00:35:10.400 --> 00:35:12.820
streams and the audio data that
you can manipulate inside

00:35:12.820 --> 00:35:13.900
the JavaScript.

00:35:13.900 --> 00:35:16.360
And this is coming to
the mobile platform.

00:35:16.360 --> 00:35:17.940
Right now, it's only
available on--

00:35:17.940 --> 00:35:20.410
I need to get this right-- on
devices supporting the neon

00:35:20.410 --> 00:35:23.160
chipset, which just kind of
luckily happens to be a large

00:35:23.160 --> 00:35:25.010
number of devices
at the moment.

00:35:25.010 --> 00:35:26.730
And that's one of the reasons
why we're still keeping it

00:35:26.730 --> 00:35:28.420
behind the flags as well,
because it's not broadly

00:35:28.420 --> 00:35:29.400
available just yet.

00:35:29.400 --> 00:35:31.570
And it still needs some
time to bake.

00:35:31.570 --> 00:35:32.420
And WebGL.

00:35:32.420 --> 00:35:34.450
This is a demo by the guys
that play Canvas.

00:35:34.450 --> 00:35:36.770
They built it in about
a day or so.

00:35:36.770 --> 00:35:39.060
But essentially, there's WebGL
support inside Opera, I

00:35:39.060 --> 00:35:42.280
believe, and Firefox, which
allows you to build these 3D

00:35:42.280 --> 00:35:44.730
rich interactive games.

00:35:44.730 --> 00:35:48.140
And if you combine that with
WebRTC and Web Audio, you can

00:35:48.140 --> 00:35:51.400
build these really kind of
cool collaborative games.

00:35:51.400 --> 00:35:54.090
You name it, you can build
it, and it'd be cool.

00:35:54.090 --> 00:35:57.760
So we are nearly finished
now, aren't we?

00:35:57.760 --> 00:35:58.330
Pretty cool.

00:35:58.330 --> 00:35:59.600
We're running close on time.

00:35:59.600 --> 00:36:00.800
I want to ask one question.

00:36:00.800 --> 00:36:01.800
Do you want to ask it?

00:36:01.800 --> 00:36:04.170
PETER BEVERLOO: So is the
mobile web awesome yet?

00:36:04.170 --> 00:36:06.620
PAUL KINLAN: Is it awesome?

00:36:06.620 --> 00:36:08.055
Who said no?

00:36:08.055 --> 00:36:09.550
Oh.

00:36:09.550 --> 00:36:12.060
This is supposed to be a rally
call to yes, it is.

00:36:12.060 --> 00:36:13.990
So we can?

00:36:16.780 --> 00:36:18.990
PETER BEVERLOO: We can adapt to
the various screen sizes of

00:36:18.990 --> 00:36:20.130
mobile devices.

00:36:20.130 --> 00:36:22.820
We know that screen sizes of
mobile devices are smaller.

00:36:22.820 --> 00:36:24.180
They have limitations.

00:36:24.180 --> 00:36:26.310
But there's plenty of features
available for us to

00:36:26.310 --> 00:36:29.170
restructure content based on
that, or to work around these

00:36:29.170 --> 00:36:33.190
constraints to bring a proper
user experience to your users.

00:36:33.190 --> 00:36:34.160
PAUL KINLAN: We can accommodate
users on the

00:36:34.160 --> 00:36:37.570
move-- the Geolocation API,
the offline access APIs.

00:36:37.570 --> 00:36:40.700
We can build applications that
are responsive to users being

00:36:40.700 --> 00:36:42.410
on the move.

00:36:42.410 --> 00:36:44.690
PETER BEVERLOO: We can
speed up inputs.

00:36:44.690 --> 00:36:47.060
It's awkward, but we can
make it as easy for

00:36:47.060 --> 00:36:50.510
the user as is possible.

00:36:50.510 --> 00:36:51.060
PAUL KINLAN: And we
can integrate with

00:36:51.060 --> 00:36:52.080
all the device features.

00:36:52.080 --> 00:36:53.420
You have access to the camera.

00:36:53.420 --> 00:36:57.180
You have access to GPS and a
whole lot of other features on

00:36:57.180 --> 00:36:58.350
the mobile web today that are

00:36:58.350 --> 00:37:00.970
ubiquitous across the platform.

00:37:00.970 --> 00:37:02.650
PETER BEVERLOO: We can measure
exactly where in our

00:37:02.650 --> 00:37:04.390
applications the pain
points are.

00:37:04.390 --> 00:37:07.000
Now, I know that we just
looked at some network

00:37:07.000 --> 00:37:09.250
specifications related
to the network.

00:37:09.250 --> 00:37:11.350
But there's a lot we can
do to actually figure

00:37:11.350 --> 00:37:13.070
out why it's slow.

00:37:13.070 --> 00:37:14.730
PAUL KINLAN: And we can look
forward to WebRTC,

00:37:14.730 --> 00:37:16.330
Web Audio, and WebGL.

00:37:16.330 --> 00:37:19.340
So I think in summary, we
believe that web on the mobile

00:37:19.340 --> 00:37:21.460
web is absolutely awesome.

00:37:21.460 --> 00:37:22.280
Thank you very much.

00:37:22.280 --> 00:37:23.530
PETER BEVERLOO: Thank you.

00:37:28.860 --> 00:37:30.700
PAUL KINLAN: I'm going
to say, we do have

00:37:30.700 --> 00:37:31.570
three minutes for questions.

00:37:31.570 --> 00:37:34.880
It's probably best if we take
them off stage or outside.

00:37:34.880 --> 00:37:36.840
Me and Peter will be
available for any

00:37:36.840 --> 00:37:38.410
questions that you do have.

00:37:38.410 --> 00:37:39.660
Thank you.

