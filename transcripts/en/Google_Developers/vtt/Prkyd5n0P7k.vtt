WEBVTT
Kind: captions
Language: en

00:00:00.429 --> 00:00:05.069
&gt;&gt;Colton McAnlis: I'm here today. This is
fantastic. Hello, everyone!

00:00:05.069 --> 00:00:10.140
Try that again.
Oh, this is Google I/O. Hello everyone!

00:00:10.140 --> 00:00:12.300
&gt;&gt;&gt; Hello!
&gt;&gt;Colton McAnlis: There it is.

00:00:12.300 --> 00:00:16.680
Now, I don't know if you guys know this, hopefully
you do, this session is being live recorded

00:00:16.680 --> 00:00:20.369
and broadcasted on the intertubes right now.
Hopefully we won't clog them up with all of

00:00:20.369 --> 00:00:25.030
our awesomeness.
A couple of months ago I said, Hey, I want

00:00:25.030 --> 00:00:29.970
to talk about this HTML5 game and to demo
it, and actually I want to have some skydivers

00:00:29.970 --> 00:00:33.550
jump down, come in and give a talk. And they
were like, Sorry, we can't do that. We did

00:00:33.550 --> 00:00:39.510
that for the keynote. Next year we'll do skydiving.
Anyway, my name is Colt McAnlis and I'm a

00:00:39.510 --> 00:00:44.600
developer advocate here working at Google,
focusing on Chrome games.

00:00:44.600 --> 00:00:50.430
And today is really cool because for you guys
this is Google I/O and you get a lot of information,

00:00:50.430 --> 00:00:56.219
but for us Googlers this is a holiday, this
is a magical event for us because all year

00:00:56.219 --> 00:01:01.640
long we toil and we struggle and we write
tons of code and throw tons of code away and

00:01:01.640 --> 00:01:07.860
we spend all of our time making products that
we can't talk to any of you about. Except

00:01:07.860 --> 00:01:11.360
today.
And today is a fantastic day because I get

00:01:11.360 --> 00:01:15.979
to talk about a project myself and a core
group of people have been working on, and

00:01:15.979 --> 00:01:20.490
that's a game called GRITS. And GRITS, first
off it has robots, pretty cool. Everybody

00:01:20.490 --> 00:01:22.210
love robots.
Hands up for robots.

00:01:22.210 --> 00:01:25.990
[Applause]
Love this. Yes, I think there should be more

00:01:25.990 --> 00:01:29.400
robots on the internet. That's my personal
opinion.

00:01:29.400 --> 00:01:33.880
Let's talk about where GRITS started.
GRITS is player versus player game entirely

00:01:33.880 --> 00:01:37.200
written in HTML5.
A couple of months ago I gave a great talk

00:01:37.200 --> 00:01:40.860
-- I thought it was a great talk. I didn't
get promoted afterwards, but it still went

00:01:40.860 --> 00:01:46.229
over quite well, best practices in developing
an HTML5 game. The talk effectively highlighted

00:01:46.229 --> 00:01:50.780
issues that game developers were running into
in developing HTML5 and kind of how to overcome

00:01:50.780 --> 00:01:53.229
them.
Someone came up to me and said "This is a

00:01:53.229 --> 00:01:58.210
great talk. Where's the source code?"
Dang it! You got me.

00:01:58.210 --> 00:02:01.700
We just talked about ideas.
So at that point we decided, Hey, let's actually

00:02:01.700 --> 00:02:06.439
write a full player versus player game in
HTML5, open source it and bring the results

00:02:06.439 --> 00:02:10.099
to Google I/O. And that's what we're here
talking about today.

00:02:10.099 --> 00:02:14.769
So in order to make sure that a bunch of Googlers
didn't run off into the distance and do something

00:02:14.769 --> 00:02:19.030
crazy, our managers made us specify some bounding
parameters on what kind of video game we were

00:02:19.030 --> 00:02:21.480
going to make.
So we wanted to make sure it was multiplayer

00:02:21.480 --> 00:02:25.819
only. We're gonna be a small group with a
small a lot of time. We didn't have artists,

00:02:25.819 --> 00:02:30.549
we don't have designers, we don't have the
ability to create a 56-hour expression of

00:02:30.549 --> 00:02:36.809
our inner angst by you riding a horse and
slaying a dragon. Let's make it multiplayer

00:02:36.809 --> 00:02:41.299
only where robots shoot robots in the face.
Super easy, right?

00:02:41.299 --> 00:02:46.900
Second, let's leverage Google technologies.
As you guys have been hearing today already

00:02:46.900 --> 00:02:51.279
-- because you're here at Google I/O you are
probably already very aware that Google provides

00:02:51.279 --> 00:02:56.189
a suite of powerful technologies. And a lot
of game developers out there actually don't

00:02:56.189 --> 00:02:59.730
know how to use a lot of the Google technologies
and translate it into the game development

00:02:59.730 --> 00:03:03.099
process.
So for GRITS what we wanted to do was highlight

00:03:03.099 --> 00:03:07.260
those technologies and provide a source code
on how to properly use them so that we can

00:03:07.260 --> 00:03:11.950
actually say, Hey, here's a game that actually
works and it's using app engine. Here's the

00:03:11.950 --> 00:03:16.199
source code. Or Hey, here's how to use wallet
the right way. Here's the source code.

00:03:16.199 --> 00:03:20.840
Second, we wanted to contract our art and
sound. Google is a big company, but we're

00:03:20.840 --> 00:03:24.879
predominantly engineer heavy. We don't have
a lot of 3D artists and designers sitting

00:03:24.879 --> 00:03:29.059
around. So we actually we tapped a great company
called Fuzzy Cube Software to do all the art

00:03:29.059 --> 00:03:32.189
for our games. Give it up for those guys.
[ Applause ]

00:03:32.189 --> 00:03:38.089
&gt;&gt;Colton McAnlis: It was like we came in and
we were like, Hey, we need a ton of art in

00:03:38.089 --> 00:03:41.400
like six days.
And they were like, Okay.

00:03:41.400 --> 00:03:46.549
And finally -- and this was one my manager
actually made me put on the slide was our

00:03:46.549 --> 00:03:50.359
intent was not to make this product commercially
viable. This was intended to be a source code

00:03:50.359 --> 00:03:55.209
repo that everyone in this room can go grab
and start making player versus player HTML5

00:03:55.209 --> 00:03:59.040
games. We're not trying to take on all the
big names of the industry out there. We're

00:03:59.040 --> 00:04:02.319
really trying to prove that this is something
we can do.

00:04:02.319 --> 00:04:08.359
In order to do this, I actually tapped game
developers who work at Google. So these are

00:04:08.359 --> 00:04:12.989
developers who used to be in the industry,
shipped games on console and PC who now work

00:04:12.989 --> 00:04:16.070
at Google.
In addition to that, we also grabbed a couple

00:04:16.070 --> 00:04:21.229
of people who were experts in the subject
area we needed so that we can actually get

00:04:21.229 --> 00:04:26.550
a full-fledged team.
Consider GRITS a view of traditional game

00:04:26.550 --> 00:04:30.539
developers looking at HTML5 as a viable platform.
And hopefully the discussion that we're going

00:04:30.539 --> 00:04:34.840
to have today is going to highlight some of
the things from that particular perspective.

00:04:34.840 --> 00:04:39.650
Again, we wanted to bring our results here.
We thought this was the proper platform. And

00:04:39.650 --> 00:04:44.530
from the start to finish we only had 120 days.
I'm sure everyone in here has heard of Google's

00:04:44.530 --> 00:04:49.840
20% projects hopefully? That basically means
we're only allowed to work on this one day

00:04:49.840 --> 00:04:54.280
a week. So really for the 120 days we only
got one day a week. But with that short amount

00:04:54.280 --> 00:04:59.530
of time what we found was the APIs and the
technology available in HTML5 allowed us to

00:04:59.530 --> 00:05:02.960
do some amazing things.
So let's talk about what we actually were

00:05:02.960 --> 00:05:08.009
able to do. I'm going to cut to a video because
I've been having internet trouble all day.

00:05:08.009 --> 00:05:17.030
Let's see if I can do this.
So what you're looking at here sort of the

00:05:17.030 --> 00:05:20.819
log-in screen. We allow players to use Quick
Game or log-in.

00:05:20.819 --> 00:05:24.979
We have full G+ integration so when we log
in you actually see my friends list and my

00:05:24.979 --> 00:05:29.000
Circles there on the side. You actually see
my name and my portrait and we've got that

00:05:29.000 --> 00:05:32.430
nice little share button which allows you
to share the game to the live stream and tell

00:05:32.430 --> 00:05:35.440
people what a great thing you're doing. Now,
you notice I actually misspelled GRITS so

00:05:35.440 --> 00:05:37.870
I decided not to share that one. It's a little
embarrassing.

00:05:37.870 --> 00:05:42.051
For the game we support keyboard layout or
mouse so that you can actually play it on

00:05:42.051 --> 00:05:46.849
your laptop or on your desktop.
When you run into the game you configure your

00:05:46.849 --> 00:05:51.669
robot first. This is sort of phase one of
a longer strategy here. You can pick primary,

00:05:51.669 --> 00:05:57.539
secondary or tertiary weapons like chainsaw,
land mines, shotgun. I think I have the energy

00:05:57.539 --> 00:06:00.039
sword here.
Energy sword is the bomb. If you're playing

00:06:00.039 --> 00:06:04.129
the game always choose the energy sword. It's
plus 10 uber awesome.

00:06:04.129 --> 00:06:11.419
We have a little bit of a lag on the delay.
It's not that choppy live, but basically it's

00:06:11.419 --> 00:06:15.289
robots shooting each other. Right? Everyone
loves that, right? This is why we get up in

00:06:15.289 --> 00:06:19.789
the morning to see robots shooting each other.
Effectively you see a little bit of the jittering

00:06:19.789 --> 00:06:25.379
here. That's due to latency, networking correction.
We've got energy items that you can pick up.

00:06:25.379 --> 00:06:30.160
We've got help bars, names. You can actually
see the anonymous players running around in

00:06:30.160 --> 00:06:34.909
the universe. You can see the bullets bouncing.
Energy shield, awesome. +1 on the energy field.

00:06:34.909 --> 00:06:38.760
Like sometimes you wish the +1 button were
bigger so you could hit it so hard it would

00:06:38.760 --> 00:06:41.810
put a dent in wall. Right, when you find something
cool? Nobody else? No one?

00:06:41.810 --> 00:06:43.509
[Laughter]
&gt;&gt;Colton McAnlis: You're at a Google conference

00:06:43.509 --> 00:06:46.560
and you don't applaud for a bigger +1 button?
[ Applause ]

00:06:46.560 --> 00:06:53.719
&gt;&gt;Colton McAnlis: Okay. There you go. In the
back, give that guy a T-shirt.

00:06:53.719 --> 00:06:57.460
But this is more of the game play running
around. Of course I died at the end.

00:06:57.460 --> 00:07:02.999
Now, that little QR code at the top there,
we'll talk a little more about that in a minute.

00:07:02.999 --> 00:07:06.539
So that is the demo.
So what we're going to talk about today is

00:07:06.539 --> 00:07:10.320
how we built this product, how we put it together
so that you can walk out of here understanding

00:07:10.320 --> 00:07:14.479
how you actually make player versus player
games with HTML5 and then you can go off and

00:07:14.479 --> 00:07:17.680
make awesomeness on your own because that's
what I/O is all about, right?

00:07:17.680 --> 00:07:22.499
So let's start at the top. The player part
of player versus player is the most important.

00:07:22.499 --> 00:07:26.219
So in a traditional game developer sense,
when you want to get a bunch of computers

00:07:26.219 --> 00:07:30.530
simulating a game together the easiest way
to do it is to allow each game to actually

00:07:30.530 --> 00:07:35.270
simulate the state on its own and then transfer
the state to all the other machines.

00:07:35.270 --> 00:07:40.129
This model is actually called a peer-to-peer
networking, so each game actually independently

00:07:40.129 --> 00:07:45.120
computes all the physics, math, position of
rockets, explosions, power-ups, sends it to

00:07:45.120 --> 00:07:48.389
all the other clients which receives it and
says, Okay, this is your game state.

00:07:48.389 --> 00:07:54.620
Now, in the early '90s this was the predominant
way that games did multiplayer networking,

00:07:54.620 --> 00:07:58.510
and we've thankfully moved away from that
for a couple of reasons. Number one is this

00:07:58.510 --> 00:08:03.650
methodology is actually really prone to lag
or high latency. So what will happen is in

00:08:03.650 --> 00:08:08.279
a player versus player or a peer-to-peer network,
if any single player actually starts to slow

00:08:08.279 --> 00:08:13.370
down or their connection is bad or the machine
slows down, you miss a whole load of data

00:08:13.370 --> 00:08:17.159
that has to be synced between all the other
machines. And the only real resolution to

00:08:17.159 --> 00:08:21.320
that is actually to halt the other players
in the simulation or slow them down as well.

00:08:21.320 --> 00:08:25.410
So if any of you played some classic first-person
shooter games from the '90s you would get

00:08:25.410 --> 00:08:29.000
that disconnected icon in the corner, like,
Hey, wait, we're waiting for someone to tell

00:08:29.000 --> 00:08:31.379
us what's going on.
Another problem with the peer-to-peer networking

00:08:31.379 --> 00:08:35.469
model is it was massively prone to cheating.
So what would happen is a single player could

00:08:35.469 --> 00:08:40.139
say Hey, I just picked up the rune of Antioch
and I'm now invincible for the next 12 days,

00:08:40.139 --> 00:08:44.639
and all the other players would have to abide
by that information because that's the way

00:08:44.639 --> 00:08:48.399
peer to peer worked.
Thankfully again we've moved from this.

00:08:48.399 --> 00:08:51.920
What we use today, and this is what GRITS
is actually built on, is the technology called

00:08:51.920 --> 00:08:55.870
the authoritative server. So instead of the
clients actually calculating the game state

00:08:55.870 --> 00:09:00.420
themself, we actually allow a centralized
server to calculate all the game state and

00:09:00.420 --> 00:09:05.560
then send the results down to the clients.
At this point this means the clients are nothing

00:09:05.560 --> 00:09:10.350
more than dumb terminals. All they do is take
an input, send it to the server, receive game

00:09:10.350 --> 00:09:14.639
state and render the results of what the server
tells them to do.

00:09:14.639 --> 00:09:19.089
This is a lot better. First off, it fixes
our cheating problem because the server is

00:09:19.089 --> 00:09:22.920
authoritative. It tells you who has the rune
of Antioch and whether or not it's [indiscernible]

00:09:22.920 --> 00:09:29.040
and whether or not there's a DPS sell at the
end of it, but that's a separate discussion.

00:09:29.040 --> 00:09:30.040
Gamers!
[Laughter]

00:09:30.040 --> 00:09:33.980
&gt;&gt;Colton McAnlis: Secondly, it also fixes
the lag problem, right? If any single individual

00:09:33.980 --> 00:09:38.310
actually drops out of the network or experiences
bad latency, what happens is we don't have

00:09:38.310 --> 00:09:42.449
to slow down the other players in the simulation,
we just have to let that guy go do its thing

00:09:42.449 --> 00:09:48.149
and the server assumes that it hasn't received
any new input. This actually creates a better

00:09:48.149 --> 00:09:51.440
quality of game play for the rest of the people
in the simulation.

00:09:51.440 --> 00:09:55.279
This is actually pretty much the architecture
that most multiplayer games are built on today.

00:09:55.279 --> 00:10:02.070
This includes all your RPG's, MMO's, FPS's.
Most RTS games, real time strategy games,

00:10:02.070 --> 00:10:05.899
today are actually built on the peer-to-peer
network technology simply because there's

00:10:05.899 --> 00:10:09.540
so much data to actually simulate, and then
they get around the cheating issue with some

00:10:09.540 --> 00:10:14.899
other craziness that is way beyond this talk.
Because we have an authoritative server we

00:10:14.899 --> 00:10:19.660
run into a very specific problem, and that
problem is server compute latency. So let's

00:10:19.660 --> 00:10:23.399
say you're running on the client and you actually
say, Hey, I want to move my robot forward.

00:10:23.399 --> 00:10:27.990
That input is actually sent up to the server.
The server will take some time to compute

00:10:27.990 --> 00:10:32.650
the new state and then the state is then transferred
back down to the client where the client receives

00:10:32.650 --> 00:10:37.751
it, updates its information and then hopefully
displays it to the user.

00:10:37.751 --> 00:10:43.170
The problem with this is that the time between
input move and update state from the server

00:10:43.170 --> 00:10:47.840
is going to always be longer than it takes
for the client to actually render the next

00:10:47.840 --> 00:10:51.149
frame, or at least you hope that you're rendering
it at 60 frames per second and you're not

00:10:51.149 --> 00:10:54.500
getting packets that fast.
The result of this is that you actually get

00:10:54.500 --> 00:10:58.750
really choppy animation. So we've got our
robot on the bottom here and if we just only

00:10:58.750 --> 00:11:02.560
update his position when the server tells
us to, he will pop into position A and then

00:11:02.560 --> 00:11:07.560
pop into position B, if my clicker works.
See, the clicker, it's awesome.

00:11:07.560 --> 00:11:19.300
Now to compete -- uh, blublublublublu. Will
she write blublublublublu if I say that again?

00:11:19.300 --> 00:11:21.220
Yes!
[Laughter]

00:11:21.220 --> 00:11:29.360
&gt;&gt;Colton McAnlis: I found a new toy!
I want to actually do the rest of the talk

00:11:29.360 --> 00:11:31.079
like this.
[Laughter]

00:11:31.079 --> 00:11:36.260
&gt;&gt;Colton McAnlis: Sorry, I'm messing with
the people typing.

00:11:36.260 --> 00:11:40.541
Anyhow, GRITS computes this with something
we actually call clientside protection, which

00:11:40.541 --> 00:11:44.330
means that while the server is actually computing
the game state the client will compute the

00:11:44.330 --> 00:11:49.260
same game state in parallel. What this means
is that after the user issues the move command,

00:11:49.260 --> 00:11:53.009
that is sent off to the server and the server
will compute the state, but the client will

00:11:53.009 --> 00:11:57.990
also compute the state. This actually allows
us to do a smooth animation between the next

00:11:57.990 --> 00:12:04.019
position so that the user actually doesn't
see this lag created by sending packets to

00:12:04.019 --> 00:12:06.680
the server.
And that was supposed to be animated, but

00:12:06.680 --> 00:12:09.509
something happened and so the arrows mean
animation.

00:12:09.509 --> 00:12:16.459
Use your imagination. You guys are smart.
I think. She wrote it, cool.

00:12:16.459 --> 00:12:21.760
The cool thing is that's on the internet live
right now. Someone is like "He's insulting

00:12:21.760 --> 00:12:24.529
the audience!"
So anyhow, that's the basics of how player

00:12:24.529 --> 00:12:27.420
versus player games work.
Now, let's talk about the things that GRITS

00:12:27.420 --> 00:12:32.000
does specifically because GRITS of course
is an HTML5 game. So what you just saw is

00:12:32.000 --> 00:12:36.050
applicable to C++ games and everything else
in the wild. GRITS being HTML5 had to do a

00:12:36.050 --> 00:12:43.370
lot of things different. Let's dive into that
a bit.

00:12:43.370 --> 00:12:47.449
So let's talk about our architecture. First
off, our client's information, which consists

00:12:47.449 --> 00:12:53.180
basically of our HTML data, our JavaScript,
our sound files in OGG, everything else, this

00:12:53.180 --> 00:12:57.740
is actually served on top of App Engine. We
actually serve all the content. Our domain

00:12:57.740 --> 00:13:03.630
is at appengine.com domain. And we actually
store and communicate to App Engine, also

00:13:03.630 --> 00:13:07.210
store the database information. So the number
of kills you get, the number of credits you

00:13:07.210 --> 00:13:12.100
have, how many times you use the energy sword
of awesomeness to frag some other dude, that's

00:13:12.100 --> 00:13:16.690
all stored on the server. Actually, if you
look at the code you will see traces of information

00:13:16.690 --> 00:13:20.460
about how to do unlockable items. One of the
first updates in the patches that we want

00:13:20.460 --> 00:13:25.690
to do is show you how to do unlockable items
using Wallet and credit applications. You

00:13:25.690 --> 00:13:30.320
guys can just grab that code and put it into
your games, making more awesome games.

00:13:30.320 --> 00:13:34.110
The client will also communicate to Google+
as well as Google Analytics. You saw in the

00:13:34.110 --> 00:13:38.459
video that Google+ we grab your friends information,
we can actually link to the page, we can post

00:13:38.459 --> 00:13:42.399
to your stream.
The Analytics one is actually really cool.

00:13:42.399 --> 00:13:47.839
So for those of you in here who aren't game
developers, there's the concept of being able

00:13:47.839 --> 00:13:52.589
to track what your users are doing at pretty
much every second of a game. So what we actually

00:13:52.589 --> 00:13:57.700
do in GRITS is when a player dies we actually
log that data to Google Analytics. We actually

00:13:57.700 --> 00:14:02.040
fire off a custom event and that's stored
in the Analytic system. Then what we can do

00:14:02.040 --> 00:14:06.199
is come back and say, Hey, show me the map
and show me where all the deaths have occurred

00:14:06.199 --> 00:14:10.470
in the past 72 hours. The cool thing about
it is that it allows our designers to take

00:14:10.470 --> 00:14:14.069
a look at the map and go Hey, you know, there's
a choke point right here. There's probably

00:14:14.069 --> 00:14:17.610
way too many deaths. I'd like to change the
map a little bit and move things around.

00:14:17.610 --> 00:14:22.070
It also tells us things like how many people
actually use the energy sword and whether

00:14:22.070 --> 00:14:25.570
or not we should get rid of it entirely.
And we drive all this data collection through

00:14:25.570 --> 00:14:30.440
Google Analytics, so it's not just for webmasters
trying to figure out if half the traffic is

00:14:30.440 --> 00:14:35.070
coming from Asia or it's coming from slashdot.
We can actually use these custom events to

00:14:35.070 --> 00:14:38.839
get real information about what our players
are actually doing in our game and provide

00:14:38.839 --> 00:14:47.000
a tight feedback loop to make adjustments,
real time. We use node.js. Node.js fans?

00:14:47.000 --> 00:14:48.000
[ APPLAUSE ]

00:14:48.000 --> 00:14:52.670
&gt;&gt;Colton McAnlis: When I was taking notes,
I was like I need to write a talk, there's

00:14:52.670 --> 00:14:58.500
probably going to be robot fans and node.js
fans. Check. We -- our back end actually runs

00:14:58.500 --> 00:15:04.160
node.js out in the cloud running on a compute
server, and our client communicates to our

00:15:04.160 --> 00:15:08.839
game instance, our node.js instance, using
socket IO through websockets, and there's

00:15:08.839 --> 00:15:13.420
a cool fact of the matter that, you know,
Web sockets are actually sort of a TCP variant

00:15:13.420 --> 00:15:18.879
with a much safer UI. Much safer API. Now,
the client will also do some other interesting

00:15:18.879 --> 00:15:23.339
communications. You'll notice that when I
clicked quick game, or wanted to join a game,

00:15:23.339 --> 00:15:27.589
the client and the server actually communicate
to match maker. Now, this is actually one

00:15:27.589 --> 00:15:31.130
of sort of the advents in the last fifteen
years of game development process is the fact

00:15:31.130 --> 00:15:35.899
that people realize that if there's a 12-year-old
kid sitting in some area where he doesn't

00:15:35.899 --> 00:15:39.629
have to go to school all day, and can just
sit there and play games all day, you hop

00:15:39.629 --> 00:15:42.759
on for a match, and you're matched with him,
he's going to destroy you, and every time,

00:15:42.759 --> 00:15:46.470
and that's not cool for you, because he's
like, "ha, ha, I'm only 12," and you're like,

00:15:46.470 --> 00:15:51.819
"Hey, dude, i got a job, lay off me." He's
like, "you smell". Or at least that's what

00:15:51.819 --> 00:15:56.550
my last weekend was like. Anyhow, what match
makers do is they effectively attempt to try

00:15:56.550 --> 00:16:01.680
to match players of unique skills, put them
together in buckets, find an open game this

00:16:01.680 --> 00:16:06.050
massive conversational back end that figures
out how to slot people and combine them in

00:16:06.050 --> 00:16:09.980
ways that make their experience in the game
a lot better. So we actually have a match

00:16:09.980 --> 00:16:14.209
maker running for GRITS that runs entirely
on app engine, and the cool thing is we're

00:16:14.209 --> 00:16:18.170
not going to talk about this today, but you
all need to go to the talk by Fred Sauer called

00:16:18.170 --> 00:16:21.850
"Gaming in the Cloud", and I think actually
that time is incorrect. I think it got moved

00:16:21.850 --> 00:16:25.759
again. But anyhow, go to gaming in the cloud.
He's going to talk about all of the app engine

00:16:25.759 --> 00:16:31.240
side of GRITS including that interesting QR
code. One of the things Fred did was actually

00:16:31.240 --> 00:16:36.589
write an Android controller for GRITS, and
so if you actually scan that QR code with

00:16:36.589 --> 00:16:40.620
your Android phone, you can actually play
the entire game using your Android device,

00:16:40.620 --> 00:16:45.550
connected to your PC. We use this as sort
of a controller. Definitely check out his

00:16:45.550 --> 00:16:49.889
talk, he's a cool guy.
At the core of our simulation is a fantastic

00:16:49.889 --> 00:16:55.670
library called box2d.JS. And what you're looking
at here is sort of a mockup of a top-down

00:16:55.670 --> 00:16:59.720
setup. Box2d. So, rather when you look at
this, you see a game, right?

00:16:59.720 --> 00:17:04.600
But in reality, it's comprised of a lot of
box2d primitives. In green here we have the

00:17:04.600 --> 00:17:07.720
physics objects represents collision. You
know, you can't shoot through these things,

00:17:07.720 --> 00:17:12.850
you can't walk through these things. The red
squares here actually represent in-game objects.

00:17:12.850 --> 00:17:18.570
These are tele-porters. Box2d has a fantastic
call back system in that as you intersect

00:17:18.570 --> 00:17:22.050
with two items or as a collision occurs, we
get a nice little call back and we can respond

00:17:22.050 --> 00:17:25.800
to it properly, which means for us writing
GRITS, we actually can be pretty lazy about

00:17:25.800 --> 00:17:29.200
what kind of code we write. We actually don't
have to write interesting simulation loops

00:17:29.200 --> 00:17:32.700
or anything. The only code we really write
is how to spawn an object and what to do when

00:17:32.700 --> 00:17:36.820
it hits another object, so when a user touches
a tele-porter object, we know that a user

00:17:36.820 --> 00:17:41.970
is touching a tele-porter and then can make
the appropriate change to tele-port him to

00:17:41.970 --> 00:17:47.630
whatever position he's at or into, you know,
zulu alpha 90 which is a cool place, you should

00:17:47.630 --> 00:17:52.890
check it out. We also use a great concept
that Box2D provides which is the collision

00:17:52.890 --> 00:17:59.280
filtering system, so any time we actually
launch projectiles or objects or spawn a new

00:17:59.280 --> 00:18:02.980
member into the game, they're assigned a team,
so what you're looking at right there is their

00:18:02.980 --> 00:18:07.620
red player actually -- or the player there
is actually on the red team, firing projectiles

00:18:07.620 --> 00:18:11.590
that are attached to the red team, and of
course subsequently we have the blue team.

00:18:11.590 --> 00:18:15.910
This allows us to actually say, hey, don't
do friendly fire, right? So if you got a team,

00:18:15.910 --> 00:18:18.550
all of red team, you don't want to get shot
in the back of the head by your teammate.

00:18:18.550 --> 00:18:23.200
Box2d handles all this for us. All we have
to do when we spawn a projectile is specify

00:18:23.200 --> 00:18:27.650
don't intersect with anybody else who's got
the team red flag. Again, completely hands

00:18:27.650 --> 00:18:31.580
off on our part. We're so super lazy when
writing this project. Box2D did all the heavy

00:18:31.580 --> 00:18:37.580
lifting for us. The explosion up there is
actually the same process, again, projectile

00:18:37.580 --> 00:18:41.450
intersected with the wall and we computed
what those two objects were, and then decided

00:18:41.450 --> 00:18:46.190
that the proper result was to actually spawn
an instance of an explosion. Again, Box2D

00:18:46.190 --> 00:18:52.850
is awesome. Use it. Now, one of the issues
that we ran into while having Box2D as well

00:18:52.850 --> 00:18:59.870
as clientside prediction is prediction adjustment,
so what happens is, as the client says I would

00:18:59.870 --> 00:19:04.050
like to move forward, the client can go off
and move forward, well, the problem is positioning

00:19:04.050 --> 00:19:08.660
is actually driven by Box2D, which means that
the server can actually disagree with where

00:19:08.660 --> 00:19:12.160
you're supposed to be at. So the client thinks
he should be there, while the server says

00:19:12.160 --> 00:19:15.220
actually you should be along this spector
over here for some whatever reason; they're

00:19:15.220 --> 00:19:18.920
you're running into a wall or a demon is chasing
you. I don't know why there would be a demon

00:19:18.920 --> 00:19:23.580
chasing a robot, that would be weird, just
go with it. So what we do is something called

00:19:23.580 --> 00:19:29.280
prediction adjustment where over time we'll
actually modify the forward vector of our

00:19:29.280 --> 00:19:34.630
moving robots slightly toward what the server
has told us we should be at, so what happens

00:19:34.630 --> 00:19:40.100
is after a couple of frames, we correct our
position just enough where the player actually

00:19:40.100 --> 00:19:45.910
doesn't see that they're getting discrepancy
between the client server. This actually allows

00:19:45.910 --> 00:19:49.280
us to hide a lot of the latency that you would
normally see from the client and the server

00:19:49.280 --> 00:19:53.760
-- the authoritative server communication
process. Now, if the client and the server

00:19:53.760 --> 00:19:58.560
position differ by some extremely large value,
we'll just snap, because at that point, you

00:19:58.560 --> 00:20:01.620
know, it's like, oh, we're fifteen frames
away, and it would take too long and it doesn't

00:20:01.620 --> 00:20:05.770
look good. So we do have sort of a catch-all
in case we get too far ahead. Now one of the

00:20:05.770 --> 00:20:09.870
other things . This was -- we actually found
this like last week, so I'm glad we fixed

00:20:09.870 --> 00:20:15.950
the bug before my talk -- yay -- is our third
server actually has to drive the client in

00:20:15.950 --> 00:20:20.310
more ways than we were originally predicting.
So let's say you're running the client here,

00:20:20.310 --> 00:20:26.620
and you choose to fire a missile, I think
that's the proper pronunciation, and the client

00:20:26.620 --> 00:20:30.450
says, hey, this missile has intersected with
this object. Well, again, remember the client

00:20:30.450 --> 00:20:34.280
is computing games data parallel, so the client
actually says, hey, this guy is there. Well,

00:20:34.280 --> 00:20:39.430
the server says, no, he's actually over here.
So now we have a mismatch. The client has

00:20:39.430 --> 00:20:43.860
said a collision has occurred, the server
says no, you're wrong, and so what we do in

00:20:43.860 --> 00:20:48.040
this situation is we actually say, I'm sorry,
client, we're not listening to you, right,

00:20:48.040 --> 00:20:52.200
because to a player if they saw collision,
they would expect to see health go down or

00:20:52.200 --> 00:20:57.510
some sort of validation that they're doing
the right thing in killing their fellow robots,

00:20:57.510 --> 00:21:00.950
but instead what we do is we ignore the collision
and actually let the bullet pass through.

00:21:00.950 --> 00:21:04.690
This is really important from a game player
perspective. There's been a lot of research

00:21:04.690 --> 00:21:09.690
over the past ten years about doing multiplayer
prediction and adjustment analysis and what

00:21:09.690 --> 00:21:14.510
players actually can perceive as the problem
versus actually being the problem, and actually,

00:21:14.510 --> 00:21:19.740
saying, hey, we're going to ignore clientside
prediction is hands down is the perceptive

00:21:19.740 --> 00:21:23.290
correct solution from all the game players.
If you're writing games, make sure you do

00:21:23.290 --> 00:21:29.680
it this way. Or not. It's up to you. You can
write games. You're smart. Let's talk about

00:21:29.680 --> 00:21:36.460
networking. One of the things that we did
specifically, how many of you have actually

00:21:36.460 --> 00:21:42.200
written like TCP networking code in C++?
A lot of hands. I'm proud of this room.

00:21:42.200 --> 00:21:46.360
This is an awesome room. We should like fight
the other rooms and prove how awesome we are.

00:21:46.360 --> 00:21:51.810
I think we'd win. Anyhow, so in C++ what you
usually end up with is some sort of structure

00:21:51.810 --> 00:21:57.180
that you define like this, a flag for what
kind of packet it is, 32 bits for the data,

00:21:57.180 --> 00:22:01.440
again let's say a float, a direction packet,
and then this would be communicated between

00:22:01.440 --> 00:22:04.710
client server, because sooner or later in
C++ this is usually in a header file, and

00:22:04.710 --> 00:22:09.930
you would cut a server build versus a -- let's
say you have a Junior programmer that comes

00:22:09.930 --> 00:22:15.860
in says, I didn't want to listen to you anyway,
I'm going to push a client build without updating

00:22:15.860 --> 00:22:20.920
the server. Now everything is broken, right,
we no longer have the same package structure,

00:22:20.920 --> 00:22:25.710
all the data is getting out of line and this
is a massive problem. GRITS solves this with

00:22:25.710 --> 00:22:30.660
a really unique solution that I felt was super
important to talk about. What we actually

00:22:30.660 --> 00:22:34.770
define is rather than defining the structures
themselves that are then copied between client

00:22:34.770 --> 00:22:39.030
server in builds that we cut, we actually
define a proto structure, so what you're seeing

00:22:39.030 --> 00:22:42.560
right here is the input structure. We say
who it's actually from and what direction

00:22:42.560 --> 00:22:47.380
you're going, specified as strengths. We're
sort of proto defining what this class should

00:22:47.380 --> 00:22:53.330
be, or instructor, or whatever it is in JavaScript.
I'm not a JavaScript guy. What the server

00:22:53.330 --> 00:22:57.820
actually does, is when it instance boots up,
it actually parses this JavaScript file, reads

00:22:57.820 --> 00:23:02.280
this proto data and actually runs code generation
on it, so rather than actually generating

00:23:02.280 --> 00:23:07.490
the structures, we actually generate a whole
suite of functions, an API set that allows

00:23:07.490 --> 00:23:12.180
the client and the server -- well, the server
specifically to actually use that as an API,

00:23:12.180 --> 00:23:18.590
push data in and the APIs will properly pack
the bytes in an efficient manner into what

00:23:18.590 --> 00:23:23.320
the structure would be. Now here is where
the cool part of JavaScript comes into play.

00:23:23.320 --> 00:23:29.080
We actually pass this code generated set of
APIs down to the client, and then on the client

00:23:29.080 --> 00:23:34.350
we just call an eval function, so this means
that our client and server will always be

00:23:34.350 --> 00:23:38.700
in sync when communicating with each other.
There is no possible way that they can actually

00:23:38.700 --> 00:23:42.301
get out of sync, because as a client connects
to its server, it actually receives all of

00:23:42.301 --> 00:23:45.850
the information on how it's supposed to communicate
through this API packet.

00:23:45.850 --> 00:23:49.470
This is actually really cool. It's one of
the few things that I love about JavaScript

00:23:49.470 --> 00:23:55.800
that you can't do in C++ for game development,
right? Actually say, here, use this. Now,

00:23:55.800 --> 00:23:59.630
once you're writing this code, especially
with multiplayer games, you end up shooting

00:23:59.630 --> 00:24:04.380
a lot of bullets, sooner or later you're going
to just sit there and hit buttons, kind of

00:24:04.380 --> 00:24:06.640
like that button master, playing a street
fighter game. It's like, you're not hitting

00:24:06.640 --> 00:24:10.770
any buttons but you're still beating me, I
hate you and you're 12. Yay. What we actually

00:24:10.770 --> 00:24:16.120
found was in our original implementation,
that in a about a second -- in about a second

00:24:16.120 --> 00:24:21.330
of game play with a full 8 player session,
we'd send about 6.2 megabytes of data, and

00:24:21.330 --> 00:24:26.400
that is position information, directional
information, index data, you know, what state

00:24:26.400 --> 00:24:31.400
is, rotation, all this other stuff. So we
needed to address this really quickly, because

00:24:31.400 --> 00:24:36.260
I'm sure again everyone here is at Google
I/O, your internet developers, you understand

00:24:36.260 --> 00:24:42.670
this graph, is that if I've got 240 millisecond
window and I've got really fat packets, the

00:24:42.670 --> 00:24:47.710
number of packets, or rather the information
update from the server that I get is limited,

00:24:47.710 --> 00:24:52.430
so in that 240 milliseconds, I can only get
so much data from the server to tell me about

00:24:52.430 --> 00:24:56.900
the game state. I can only update my information
so fast. Instead what you want to do is create

00:24:56.900 --> 00:25:01.480
smaller packets, more concise information,
so we can receive more of them in that short

00:25:01.480 --> 00:25:05.900
window so we can update the game state quicker,
because again, since the server is doing the

00:25:05.900 --> 00:25:11.250
entire computation, we need to ensure that
we receive the updates as fast as possible

00:25:11.250 --> 00:25:16.990
so the client can stay in sync. Now, one of
the ways we do this -- clicking -- is actually

00:25:16.990 --> 00:25:20.980
using packet grouping. So usually when you
send a packet down the wire there's multiple

00:25:20.980 --> 00:25:25.700
levels of technology stack, and each level
that your packet runs into usually adds a

00:25:25.700 --> 00:25:30.770
little bit of overhead, right? So socket IO
will add some bits to it, the ttp layer will

00:25:30.770 --> 00:25:34.510
add some bits to it, maybe the operating system
will add some bits to it. Well, what happens

00:25:34.510 --> 00:25:38.010
is you actually end up with a lot of data
that you don't need, right? And for these

00:25:38.010 --> 00:25:42.640
individual packets, this actually adds up
to a bit, a significant amount. So what we

00:25:42.640 --> 00:25:48.920
do is we actually have a heuristic set that
defines the ability to group all of our packets

00:25:48.920 --> 00:25:53.340
based upon memory size. So what we say, is,
hey, we're going to cue up our packets until,

00:25:53.340 --> 00:25:57.250
you know, a time limit has elapsed, so if
we only get one packet, and let's say a second

00:25:57.250 --> 00:26:01.160
has elapsed, we just go ahead and send that
on. Or we'll cue up all of our packets until

00:26:01.160 --> 00:26:05.520
it reaches like a megabyte, and then we'll
send that down the line. What this does, it

00:26:05.520 --> 00:26:10.250
actually reduces all of the additional overhead
that's added by each of these layers. This

00:26:10.250 --> 00:26:14.120
is really a critical thing for us because
we send a lot of data.

00:26:14.120 --> 00:26:19.100
One of the other things we do, or another
set of things we do, is actually duplicate

00:26:19.100 --> 00:26:27.790
packet reduction, so we do this in two ways:
The first is that we understand that the people

00:26:27.790 --> 00:26:31.770
writing the game are not thinking about the
networking layer as they're writing the game,

00:26:31.770 --> 00:26:33.790
right?
So as we're going through update loop, as

00:26:33.790 --> 00:26:36.780
all the items are updating themselves, sooner
or later you're going to have someone come

00:26:36.780 --> 00:26:40.910
along and assign a variable to A, and then
20 loops later it's going to assign it to

00:26:40.910 --> 00:26:43.820
C, and then some time is going to go by and
then you're going to assign it to B. What

00:26:43.820 --> 00:26:47.810
we do in this situation is we actually track
these state data and updates over time, and

00:26:47.810 --> 00:26:52.100
we only send the latest update, so what will
happen is we'll say, hey, if the variable

00:26:52.100 --> 00:26:55.920
has already been set and we're setting it
to something different, forget the other state,

00:26:55.920 --> 00:26:59.620
don't put it in our packet grouping. Right?
This keeps the client from doing redundant

00:26:59.620 --> 00:27:05.721
state updates, in otherwise C, A and then
finally B, which it doesn't need to do. Another

00:27:05.721 --> 00:27:10.410
thing we do with our staple tracking is we
actually analyze whether or not the state

00:27:10.410 --> 00:27:15.440
that we're about to update a packet for is
identical to the state that already exists,

00:27:15.440 --> 00:27:19.510
so if a line of code comes along and says
let's set the position to A, and the position

00:27:19.510 --> 00:27:24.121
is already A, then the server won't actually
update that data, won't send it to the client

00:27:24.121 --> 00:27:30.510
at all. Now, with the packet grouping, as
well as the duplicate packet deduping -- Dr.

00:27:30.510 --> 00:27:36.310
Seuss rhyme. I should write a book. We actually
modify our situation quite significantly.

00:27:36.310 --> 00:27:41.960
We end up going from about 6.2 megabytes per
second to about 1.3, which is a lot better

00:27:41.960 --> 00:27:46.730
in our situation. So these are like three
super easy things that had really nothing

00:27:46.730 --> 00:27:52.420
to do with the technology but had a lot to
do with our analysis of how our game was molesting

00:27:52.420 --> 00:28:00.350
the networking stack and sending packets around.
So let's talk about rendering. HTML5 is awesome.

00:28:00.350 --> 00:28:03.809
I always thought this was a great quote that
no one really laughs at, but "world domination

00:28:03.809 --> 00:28:07.530
often starts as a misunderstood napkin doodle."
Like I don't know if you guys walk into a

00:28:07.530 --> 00:28:12.510
bar and see some weird doodle that looks like
a dinosaur attacking Manhattan; I've got an

00:28:12.510 --> 00:28:19.060
idea. At least in my mind, that's how it works.
So again, let's go back to our mockup screen

00:28:19.060 --> 00:28:22.240
here, again you've got a bunch of things,
you've got a bunch of pretty pixels that are

00:28:22.240 --> 00:28:26.860
being displayed. In reality this is broken
down is that this is actually our background

00:28:26.860 --> 00:28:31.020
layer. Our background layer is a bunch of
64 by 64 pixel sprites that an artist has

00:28:31.020 --> 00:28:35.270
placed together on a large sheet. And we actually
render that data. On top of that, we actually

00:28:35.270 --> 00:28:40.330
render our player Avatars which are animated
sprite sheets, and then all of our projectiles

00:28:40.330 --> 00:28:44.590
and explosions are also animated sprite sheets
that are blended using a different composite

00:28:44.590 --> 00:28:52.600
layer. In order to do this, and stay performance,
we actually heavily use the concept of atlasing.

00:28:52.600 --> 00:28:56.970
Now, in the games industry we call it atlasing.
I know in the HTML5 world or Web development

00:28:56.970 --> 00:29:01.410
you call this sprite sheets, right? Nods.
I don't see a nod. Everyone asleep already?

00:29:01.410 --> 00:29:07.160
Cool. That dude game me a thumb's up. Get
him a T-shirt too. Thumb's up for T-Shirt.

00:29:07.160 --> 00:29:11.160
Anyhow, we actually atlas everything. In fact,
you're seeing, and what you're looking at

00:29:11.160 --> 00:29:15.131
here are the only three atlases we actually
use in the game. That's it. Everything, every

00:29:15.131 --> 00:29:18.960
piece of art, all of our menu data, all of
our in-game sprites are packed into these

00:29:18.960 --> 00:29:25.850
three textures, and here's why. With one Atlas
request, let's say that you have got a 4k-by-4k

00:29:25.850 --> 00:29:31.751
texture, about 100k of information total,
your total transfer time as measured by the

00:29:31.751 --> 00:29:36.210
Chrome developer tools is about 240 milliseconds,
so this is nice, right? We have got a 4k-by-4k

00:29:36.210 --> 00:29:42.060
texture, it comes down the line pretty quickly,
really fast, get it into the canvas render,

00:29:42.060 --> 00:29:46.410
and we are doing good.
Now, if you were to say chop that 4k-by-4k

00:29:46.410 --> 00:29:54.310
texture up into say 4096 individual requests,
each one is about 10k each at about 64 pixels

00:29:54.310 --> 00:30:01.000
by 64 pixels, what you end up with is about
4.3 seconds of total load time. And the reason

00:30:01.000 --> 00:30:07.130
for this is kind of two to threefold. Firstly
is that any given client connection to a server

00:30:07.130 --> 00:30:11.950
can have -- only have so many open connections,
so if you have got 4,000 connections sitting

00:30:11.950 --> 00:30:15.760
around waiting to happen and your browser
has only allowed six at a time, basically

00:30:15.760 --> 00:30:19.850
everything gets stacked. What you are looking
at in the Chrome tools here is that transparent

00:30:19.850 --> 00:30:24.330
line, the long bar there, is actually Chrome
being blocked by the server saying "I'm sorry

00:30:24.330 --> 00:30:28.660
you can't get this file yet because we're
still waiting on something else to complete."

00:30:28.660 --> 00:30:34.090
So with all of these loose assets being requested,
you slow down your load time significantly.

00:30:34.090 --> 00:30:38.850
Now, you will also notice at the end of the
line is the little opaque circle. That opaque

00:30:38.850 --> 00:30:43.650
circle actually represents the time once we've
actually received the file to decompress it,

00:30:43.650 --> 00:30:46.870
get it on the screen, do all of the other
stuff, which is really fast process. We lose

00:30:46.870 --> 00:30:51.570
almost, you know, we lose four seconds just
in waiting around for Chrome to do more connections.

00:30:51.570 --> 00:30:55.330
So in reality using Atlases saves your load
time significantly, which again a lot of Web

00:30:55.330 --> 00:30:59.540
developers are starting to notice this, so
stop using the leaf assets, stop doing it,

00:30:59.540 --> 00:31:05.220
or the robots will get you.
Now when our artists made our original map,

00:31:05.220 --> 00:31:08.670
they actually came to us with a small set.
They said, "Hey, we are going to use these

00:31:08.670 --> 00:31:10.810
64-by-64 tiles, and we're going to draw them
everywhere."

00:31:10.810 --> 00:31:13.370
We said, "That's fine."
When you look at the screen, you should really

00:31:13.370 --> 00:31:16.520
look at it like this. Which is sort of how
the rendering engine looks at it, a bunch

00:31:16.520 --> 00:31:20.740
of little tiles that are rendered on the canvas.
Well, the issue we ran into was that each

00:31:20.740 --> 00:31:24.880
one of those was actually a separate draw
call. And for each draw call you have sort

00:31:24.880 --> 00:31:29.060
of an implicit API overhead that's involved
in the draw call. Now you'll see that there's

00:31:29.060 --> 00:31:33.100
actually some nice blends here, we've got
a green background, we've got some of the

00:31:33.100 --> 00:31:36.920
tiles, we've got some more of the little hexagons
that are blending on top of it, and then we've

00:31:36.920 --> 00:31:42.170
got a dent in the universe, and then a little
thing there. That's like five to seven draws

00:31:42.170 --> 00:31:46.500
per quadrant there. Now, this adds up over
time because artists want to make really pretty

00:31:46.500 --> 00:31:51.480
art. That's usually accomplished by compositing
layers of art on top of itself to create this

00:31:51.480 --> 00:31:54.670
really rich environment. Well, again, this
doesn't work for us, right? If you've got

00:31:54.670 --> 00:31:59.100
a high-res monitor, and a lot of screen space,
this is going to be a lot of draws and a lot

00:31:59.100 --> 00:32:02.530
of machines can't handle this. So what we
did to counteract this is actually used the

00:32:02.530 --> 00:32:07.350
concept of off DOM canvas, where rather than
rendering each of these small tiles at run

00:32:07.350 --> 00:32:11.900
time, we created a canvas object that's not
attached to the DOM and actually render each

00:32:11.900 --> 00:32:17.490
of these tiles into that canvas, and then
later on we can simply do one draw call, offsetting

00:32:17.490 --> 00:32:22.220
that large canvas wherever our ViewPort happens
to be. This actually was a huge savings for

00:32:22.220 --> 00:32:25.120
us.
On some of our Linux machines this actually

00:32:25.120 --> 00:32:30.390
took our frame rate from two frames a second
back up to 60. Just this one change. It was

00:32:30.390 --> 00:32:34.740
about 10 minutes of code to get us that frame
rate back, which was fantastic.

00:32:34.740 --> 00:32:37.900
Of course, then the artist came back, said,
"Oh, by the way I've got a bigger map for

00:32:37.900 --> 00:32:41.160
you," and then we ran into a different problem.
[Laughter]

00:32:41.160 --> 00:32:47.590
Which was now that we had a 24k by 24k pixel
map. [Laughter]. And we were doing one draw

00:32:47.590 --> 00:32:54.440
call every frame for this massive pile of
pixels. And that put us back at two frames

00:32:54.440 --> 00:32:59.210
a second. So all of my work was for naught.
To counteract this, we had to do something

00:32:59.210 --> 00:33:02.340
different. So let's say we have got our little
ViewPort there in pink because hot pink is

00:33:02.340 --> 00:33:08.861
the cool thing to do on the internet. Cool
thing to do on the internet. [Laughter]. Cool

00:33:08.861 --> 00:33:11.510
thing to do on the internet. Cool thing to
do -- oh, man [Laughter].

00:33:11.510 --> 00:33:15.490
&gt;&gt;Colt McAnlis: Sorry, when you find a toy,
you've just got to play with it.

00:33:15.490 --> 00:33:20.050
Anyhow, what I actually do is I actually create
-- in order to combat the fact that this one

00:33:20.050 --> 00:33:24.020
draw call actually puts too many pixels on
the screen, because the canvas actually just

00:33:24.020 --> 00:33:29.030
does a dumb draw. Right? It doesn't say this
pixel of this subtexture is or is not in your

00:33:29.030 --> 00:33:32.430
ViewPort. It just blips the whole thing to
the screen, and lets the GPU figure out the

00:33:32.430 --> 00:33:37.140
-- for hardware accelerated -- let's the GPU
figure out the details there. So what I actually

00:33:37.140 --> 00:33:40.910
do to combat this, is we actually chunked
up our environment. So when you are actually

00:33:40.910 --> 00:33:46.700
playing in the large maps in GRITS, we actually
chunk it up into 1024-by-1024 tiles, this

00:33:46.700 --> 00:33:51.250
heuristic of 1024 versus 24 or 28 or anything
else, was actually sort of just done by trial

00:33:51.250 --> 00:33:55.660
and error. We effectively said this looks
good on this Linux box, this Linux box is

00:33:55.660 --> 00:34:00.750
not powered. So what this allows us to do
is we were doing one draw call for the little

00:34:00.750 --> 00:34:07.270
pink box. We actually do two draw calls now,
but it's significantly less pixels that the

00:34:07.270 --> 00:34:10.960
disband process has to actually deal with
or more importantly that the GPU has to deal

00:34:10.960 --> 00:34:18.580
with, with rendering, clipping, figuring everything
else out. Now, let's talk about the tools.

00:34:18.580 --> 00:34:24.690
So when you are writing games -- actually
taking a step back, let's take a step back.

00:34:24.690 --> 00:34:28.030
So as a traditional game developer, I was
a game developer for about 10 years in the

00:34:28.030 --> 00:34:31.220
industry, worked a lot of really cool places
doing really cool things. One of the most

00:34:31.220 --> 00:34:36.210
important things that I worked on consistently
was creating really good tools that allowed

00:34:36.210 --> 00:34:41.909
designers and artists to create amazing content
that really caused people to buy our games.

00:34:41.909 --> 00:34:47.770
Now, in my opinion, one of the biggest drawbacks
to HTML5 as a viable gaming technology is

00:34:47.770 --> 00:34:53.869
the lack of good tools to allow content creators
to create great content. Now I'm not talking

00:34:53.869 --> 00:34:57.460
about the language here. I'm talking about
the ability to create content in a way that

00:34:57.460 --> 00:35:02.470
content creators can reflect with.
So what we did with GRITS was we didn't try

00:35:02.470 --> 00:35:07.500
to reinvent the wheel. Rather than trying
to create HTML5 specific tools, we went back

00:35:07.500 --> 00:35:11.920
to the basics and used tools from standard
C++ game development and just made sure that

00:35:11.920 --> 00:35:18.230
the data was read in by HTML5 properly. It
started with a great tool called Tiled. Tiled

00:35:18.230 --> 00:35:24.920
is a free open sourceish map editor on the
internet, and using QT as a primary UI engine,

00:35:24.920 --> 00:35:30.020
so that means that it runs across platform.
Now Tiled does some really cool stuff. What

00:35:30.020 --> 00:35:34.690
you are looking at here is actually our Atlas
of our map sprites and then of course our

00:35:34.690 --> 00:35:39.180
map next to it, you can actually go in and
fill in your sprites, use cool brushes, and

00:35:39.180 --> 00:35:42.930
use a blend effect and, you know, fill things
together.

00:35:42.930 --> 00:35:47.789
Tiled also allows us to create collision objects
or just objects in general, then we can flag

00:35:47.789 --> 00:35:51.599
them with collision values. So what you are
actually looking here is a the polygon tool

00:35:51.599 --> 00:35:56.589
actually specifying out that, hey, this is
some object in the environment. You can see

00:35:56.589 --> 00:36:00.230
on the side of the map over there, this is
actually the collision layer. Right? So when

00:36:00.230 --> 00:36:04.480
the game reads it in, it says anything in
the collision layer we make an actual physics

00:36:04.480 --> 00:36:08.299
object that you can't shoot through or run
through or teleport on top of or use the rune

00:36:08.299 --> 00:36:18.619
of Antioch to destroy it. Really critical.
This comes crucial into play when we do things

00:36:18.619 --> 00:36:23.869
like teleporters or quad damage or picking
up energy capsules, because what it allows

00:36:23.869 --> 00:36:28.430
us to do is put a little box on the map and
say, "Hey, this is a spawn item, this is a

00:36:28.430 --> 00:36:32.780
help box," right? So we can actually specify
all of that stuff inside of tiles, we don't

00:36:32.780 --> 00:36:35.930
have to write custom code for this.
In fact, the designer and the artist can use

00:36:35.930 --> 00:36:41.349
this tool exclusively, then it just spits
out a nice JSON file, which Tiled does, by

00:36:41.349 --> 00:36:45.410
the way, that we read into our game. And the
client and the server both read this information

00:36:45.410 --> 00:36:49.519
so we know where collision objects are, we
know where teleporters are and more importantly

00:36:49.519 --> 00:36:52.830
we know where quad damage is, because if you
don't have quad damage you are losing the

00:36:52.830 --> 00:37:00.300
game, pro tip tweet that. Pro tip.
The next tool we actually use is a great tool

00:37:00.300 --> 00:37:06.520
called Texture Packer. Texture Packer is probably
one of -- one of the most advanced tools that

00:37:06.520 --> 00:37:10.160
I have seen for actually taking a whole bunch
of small textures and then packing them into

00:37:10.160 --> 00:37:12.710
a big Atlas and then passing that data off
to you.

00:37:12.710 --> 00:37:15.380
Now what you are looking at on the screen
here is all of our assets are actually listed

00:37:15.380 --> 00:37:18.590
on the side over there. So the artist literally
grabbed them all and dragged them in the tool.

00:37:18.590 --> 00:37:21.869
What you see in the middle window is the result
of Texture Packer putting it all in.

00:37:21.869 --> 00:37:26.029
Now one of the real cool things that texture
packer does, is it will actually analyze the

00:37:26.029 --> 00:37:32.440
true boundaries of an image. Let's say that
you make a 64-by-64 texture, put like a 5-by-5

00:37:32.440 --> 00:37:36.470
little sprite right in the middle of it. Texture
Packer will actually analyze that image and

00:37:36.470 --> 00:37:42.359
realize that the true content bounds are actually
5-by-5 and it will actually crop it and only

00:37:42.359 --> 00:37:47.200
put the 5-by-5 image in the map. Then it will
spit out a JSON file with the original bounding

00:37:47.200 --> 00:37:52.269
values. So by using Texture Packer, you are
actually optimizing the number of pixels used

00:37:52.269 --> 00:37:57.559
by your artists. Sometimes artists don't make
the best optimized art work.

00:37:57.559 --> 00:38:01.720
[Laughter].
&gt;&gt;Colton McAnlis: Maybe. This is also really

00:38:01.720 --> 00:38:07.829
cool, too, actually we had to break up our
end game assets versus our start menu assets.

00:38:07.829 --> 00:38:11.960
That's why we actually have three Atlases,
right? This is actually all of our menu data.

00:38:11.960 --> 00:38:16.519
It's in a separate Atlas so that we can load
it to do all of our rendering in HTML or in

00:38:16.519 --> 00:38:19.940
the DOM, so all of our menu stuff is done
in the DOM, all of the game play is done on

00:38:19.940 --> 00:38:25.180
the canvas. So we can actually load this Atlas
ahead of time. Use CSS, use sprites, transition,

00:38:25.180 --> 00:38:29.750
I think you guys saw impress.js, moving the
menus around in there. And that's all loaded

00:38:29.750 --> 00:38:33.480
before you get into the game. So once we get
in the game, we can load the other two Atlases.

00:38:33.480 --> 00:38:38.619
So we reduce load time. Reduce pixel latency.
And really it's all given to us by these two

00:38:38.619 --> 00:38:44.779
simple tools.
So -- so the lessons, let's talk about what

00:38:44.779 --> 00:38:50.420
we actually learned in this process.
So first off, can you do player versus player

00:38:50.420 --> 00:38:53.009
in HTML5?
Absolutely. Someone say mission accomplished.

00:38:53.009 --> 00:38:57.140
I would plant a flag or hang a banner or something
like that, but they wouldn't let me put pyrotechnics

00:38:57.140 --> 00:39:01.430
on the stage. I did ask, after they turned
down the skydiving thing, I was like well

00:39:01.430 --> 00:39:04.029
what about pyrotechnics. It was like stop
talking. I was like, okay.

00:39:04.029 --> 00:39:08.079
Anyhow, you can actually do player versus
player in HTML5, it's a fantastic ability.

00:39:08.079 --> 00:39:12.450
We've got canvas rendering, we've got hardware
accelerated rendering, we've got WebSockets,

00:39:12.450 --> 00:39:16.030
we have the ability to manipulate the bytes
that are sent over the line, which is probably

00:39:16.030 --> 00:39:20.510
the most crucial thing in bandwidth reduction,
in latency optimization. Really it's there,

00:39:20.510 --> 00:39:29.029
we can do it. From a game developer perspective,
the HTML5 APIs were not built for games. HTML5

00:39:29.029 --> 00:39:33.829
was built for a Web to transfer data and do
rich content, but they weren't built for games.

00:39:33.829 --> 00:39:38.670
The good news is that they're starting to
change. As you probably already have seen,

00:39:38.670 --> 00:39:43.809
Chrome has been very proactive in adding APIs
for game development. We've added full-screen

00:39:43.809 --> 00:39:50.250
support. Mouse lock support. We've added game
pad support, which usually when you say why

00:39:50.250 --> 00:39:54.000
is Chrome putting in a game pad, am I going
to use a controller to navigate my FaceBook

00:39:54.000 --> 00:39:56.299
page?
No, this is because we are putting in games.

00:39:56.299 --> 00:40:01.160
We are being very proactive about understanding
the games more than any other technology pushed

00:40:01.160 --> 00:40:06.170
the boundaries, pushed the envelope, and trying
to be a -- a modern browser, Chrome is very

00:40:06.170 --> 00:40:11.799
aggressive about this.
For a player versus player game, bandwidth

00:40:11.799 --> 00:40:15.010
reduction is crucial. In fact it's the only
thing that you really need to worry about

00:40:15.010 --> 00:40:19.720
the world. Hiding the latency from the user,
reducing the number of bits on the line, this

00:40:19.720 --> 00:40:24.150
is a full-time job. Again, we only had 120
days. We had some really great results out

00:40:24.150 --> 00:40:28.740
of that, you should probably spend a lot more
time optimizing that system if you are putting

00:40:28.740 --> 00:40:32.720
out a commercial product that you're going
to use.

00:40:32.720 --> 00:40:37.819
Also, this sort of piggyback in it is that
the client side prediction algorithm, and

00:40:37.819 --> 00:40:42.549
I encourage you to go Google this, there's
tons of papers out there by tons of first

00:40:42.549 --> 00:40:47.230
person shooters and MMO RPGs and any of the
game developer conferences out there saying

00:40:47.230 --> 00:40:51.849
"Hey, we solved it this way". I highly recommend
that you take a look at the GRITS source code,

00:40:51.849 --> 00:40:55.670
see what we are doing, compare that against
what the industry is doing and figure out

00:40:55.670 --> 00:40:59.670
a proper technique to use for your game, right?
What we provide should be considered a boilerplate

00:40:59.670 --> 00:41:04.490
and starting base, then you need to move into
more advanced versions after that. WebSockets

00:41:04.490 --> 00:41:08.750
work really well. In fact I would say probably
we had no problems with WebSockets once we

00:41:08.750 --> 00:41:15.009
moved to socket I/O. We used it, sent packets,
received packets, it was fantastic and easy

00:41:15.009 --> 00:41:18.830
to use.
As I said before, canvas, we did all of our

00:41:18.830 --> 00:41:24.130
rendering in canvas. A hardware accelerated
canvas in Chrome is really fast and powerful.

00:41:24.130 --> 00:41:29.019
We didn't want to write a full WebGL version,
we didn't have time to worry about atlasing,

00:41:29.019 --> 00:41:34.029
or UV sets, and whether or not we were rendering
middle of polygon, versus edge of polygon,

00:41:34.029 --> 00:41:38.140
and what's the GPU doing and out of process
-- no. Hardware accelerated canvas shielded

00:41:38.140 --> 00:41:41.490
us from all of that information and gives
us the same performance, which is great. If

00:41:41.490 --> 00:41:47.569
you are writing a 2D game in Chrome, consider
canvas first, and then if you run into performance

00:41:47.569 --> 00:41:50.060
problems, optimize it until you absolutely
have to go over to GL for it.

00:41:50.060 --> 00:41:56.230
Now if you are doing 3D, you can't do canvas
in 3 d easily. Definitely take advantage of

00:41:56.230 --> 00:42:00.039
off DOM canvas to accelerate any large bitmap
stuff, right? If you have a lot of static

00:42:00.039 --> 00:42:03.481
data being rendered per frame, make sure that
you do that, but definitely make sure that

00:42:03.481 --> 00:42:06.480
you segment it because the artist will keep
generating content that's going to make it

00:42:06.480 --> 00:42:11.309
harder and harder for your frame rate to be
what you need it at. Again, use atlasing,

00:42:11.309 --> 00:42:17.130
right? Going from 270 milliseconds for the
load time to 4.6 seconds is crazy. Right?

00:42:17.130 --> 00:42:21.140
Especially if you are doing this stuff on
mobile, right? We are usually on mobile, if

00:42:21.140 --> 00:42:24.570
my site takes more than a second to load,
I have already thrown the phone across the

00:42:24.570 --> 00:42:26.609
room and started drinking heavily.
[Laughter]

00:42:26.609 --> 00:42:32.460
&gt;&gt;Colton McAnlis: That's my Saturday night.
Doesn't have to be your Saturday night. Utilizing

00:42:32.460 --> 00:42:37.220
the HTML5, utilizing the DOM to do all of
our UI was a huge win. Coming from traditional

00:42:37.220 --> 00:42:40.440
game development, we have a ton of packages
and middle ware out there that we spend a

00:42:40.440 --> 00:42:47.480
lot of time trying to bend C++ into the will
of our UI system. The fact that HTML5 comes

00:42:47.480 --> 00:42:52.660
with the DOM, the most advanced sophisticated
UI system in the world, Galaxy, I'm going

00:42:52.660 --> 00:42:56.869
to say Galaxy because I think that it's that
cool. That was a huge win. To ignore that

00:42:56.869 --> 00:43:01.509
or try to reproduce all of that stuff inside
of canvas, don't even try it, it's not even

00:43:01.509 --> 00:43:08.720
worth it. So the game is live right now. Actually
been live for two weeks. Game's live. Gritsgame.appspot.com.

00:43:08.720 --> 00:43:13.430
You can go play right now, hopefully the servers
are up, maybe they're not, I don't know, we'll

00:43:13.430 --> 00:43:22.369
find out soon. The code is live. Code.google.com/p/GRITSgame.
Go get the code. Start hacking on it. Please.

00:43:22.369 --> 00:43:25.890
We would love to hear what you're breaking
and how you're breaking it.

00:43:25.890 --> 00:43:30.309
We had a great question a couple weeks ago
from an internal Googler who said, "Hey, do

00:43:30.309 --> 00:43:38.980
you mind if we write an AI system that cheats?"
I said, "Please do and then send me the patch."

00:43:38.980 --> 00:43:45.059
More importantly, go to the Chrome Sandbox.
Check out a game called Strike Fortress. What

00:43:45.059 --> 00:43:49.190
I have done with GRITS, what our team has
done is a small subset of what you can do

00:43:49.190 --> 00:43:57.490
in 120 days. EA, electronic arts, has had
a team working on a pure 3D HTML5 game, working

00:43:57.490 --> 00:44:02.369
on it for a lot longer than we have, in the
Chrome Sandbox live right now that you can

00:44:02.369 --> 00:44:07.829
play. The coolest part is you can actually
go up and scan the QR code, start influencing

00:44:07.829 --> 00:44:12.151
the game with your phone. So while two people
are standing there actually playing, we are

00:44:12.151 --> 00:44:17.210
utilizing the full power of the Web by letting
other developers actually drop bombs on people

00:44:17.210 --> 00:44:21.290
on the phone.
It's a fantastic product. The guys have been

00:44:21.290 --> 00:44:25.789
doing an amazing job. Please, leave the session,
walk right over there and play it and tell

00:44:25.789 --> 00:44:30.280
them that I sent you because I get a T-shirt
every time you do. I run out of clothes really

00:44:30.280 --> 00:44:34.320
fast. It's happens.
So with that, hey, thank you all so much for

00:44:34.320 --> 00:44:38.339
attending this talk. I'm excited to see what
HTML5 is doing with gaming. I'm excited to

00:44:38.339 --> 00:44:41.490
see the room this packed. We've got people
sitting on the floor. Hi, I see you. T-shirt

00:44:41.490 --> 00:44:45.789
for those guys.
My name is Colt McAnlis. This is how you get

00:44:45.789 --> 00:44:50.549
ahold of me. Thank you so much for the talk.
We'll open it up for some questions now.

00:44:50.549 --> 00:44:57.960
[ Applause ]
&gt;&gt;Colton McAnlis: Please feel free to use

00:44:57.960 --> 00:45:01.509
the microphone. And before we do that, hey,
a big round of applause for the typy person.

00:45:01.509 --> 00:45:09.559
[ Applause ]
&gt;&gt;Colton McAnlis: Yes, you're awesome. You're

00:45:09.559 --> 00:45:12.410
awesome with the typing. I'm a huge fan.
Questions.

00:45:12.410 --> 00:45:17.680
&gt;&gt;&gt; Yes. What do you see the overlap with
this and play-in? And also, how did you do

00:45:17.680 --> 00:45:22.579
the server side application? Did you use the
same JavaScript code to validate the state?

00:45:22.579 --> 00:45:26.029
&gt;&gt;Colton McAnlis: That's a great question.
A two-part question there, which you're cheating,

00:45:26.029 --> 00:45:29.049
you're only allowed one.
Two-part question there. How does this overlap

00:45:29.049 --> 00:45:33.509
with things like play-in and the second part
is how do we actually do our sharing or our

00:45:33.509 --> 00:45:38.180
computation of state on the server side.
The first one is play-in is a fantastic tool

00:45:38.180 --> 00:45:43.730
framework that works more with Java to my
understanding of it to produce a sort of nice

00:45:43.730 --> 00:45:48.390
games middleware setup.
GRITS is not considered an engine and should

00:45:48.390 --> 00:45:54.019
not be used in that vocabulary. GRITS is boilerplate
code. This is a setup and a bunch of things

00:45:54.019 --> 00:45:58.190
that are not intended for you to use as an
entirety, but a bunch of little small capsules

00:45:58.190 --> 00:46:01.839
that you can consume individually and then
take the knowledge from that and build off

00:46:01.839 --> 00:46:04.830
of it. We're by no means creating a larger
ecosystem here. We're just trying to give

00:46:04.830 --> 00:46:09.970
you guys sort of pebbles to feed the empire.
The second question was how we're actually

00:46:09.970 --> 00:46:15.579
splitting our code client server. We have
two metrics for that. First off, we have an

00:46:15.579 --> 00:46:20.050
is server variable that is only defined on
the server side through NodeJS. So in our

00:46:20.050 --> 00:46:24.019
shared code that's actually included in the
client's as well, we can actually say if it's

00:46:24.019 --> 00:46:29.049
a server run this loop or run this set of
code. If it's not the server, exclude it.

00:46:29.049 --> 00:46:35.500
Now, for some side classes we actually have
-- for instance, if you want to load graphics

00:46:35.500 --> 00:46:39.339
or do drawing, it doesn't make sense to have
any of that code sitting on the server side.

00:46:39.339 --> 00:46:42.829
So in those situations we actually split the
code. We actually have a server folder and

00:46:42.829 --> 00:46:47.619
a client folder, and those are actually separate
modules that use object-oriented programming

00:46:47.619 --> 00:46:52.481
to inherit from the server side classes.
So fantastic question. For a lot more of that

00:46:52.481 --> 00:46:55.970
I really encourage you to dig deep in the
source code. Check it out.

00:46:55.970 --> 00:46:59.690
I believe you're next, sir.
&gt;&gt;&gt; Quick one about the source code. Has it

00:46:59.690 --> 00:47:04.029
been tested across different browser as well
or has it been optimized for Chrome? And are

00:47:04.029 --> 00:47:09.279
the assets as far as peer posture as well,
like the tile tools and the original graphics?

00:47:09.279 --> 00:47:12.920
&gt;&gt;Colton McAnlis: Absolutely. So the questions
were have we tested the source code across

00:47:12.920 --> 00:47:17.200
multiple browsers and are the assets available
in the source code? We haven't had a time

00:47:17.200 --> 00:47:22.049
to actually test the code in other browsers.
Right now I just kind of hack out and say

00:47:22.049 --> 00:47:25.970
sorry, this is optimized for Chrome. I can't
fix the other issues.

00:47:25.970 --> 00:47:30.619
The good news is that the assets for the game
in their atlased form are provided in the

00:47:30.619 --> 00:47:35.499
source code under the license we provide.
We don't provide the PSD's or the originals

00:47:35.499 --> 00:47:39.810
because of some weird thing, but it's all
there. And we provide the JSON files, too.

00:47:39.810 --> 00:47:43.391
So you can actually scrape the JSON, scrape
the alias and generate all the loose asset

00:47:43.391 --> 00:47:46.349
if you would like that.
Thank you. You were next, sir.

00:47:46.349 --> 00:47:49.410
&gt;&gt;&gt; Yeah, two questions.
&gt;&gt;Colton McAnlis: All you guys are cheating.

00:47:49.410 --> 00:47:53.960
You're only supposed to have one.
&gt;&gt;&gt; Not a real question. Why is it called

00:47:53.960 --> 00:47:58.710
GRITS? And then how did you do any kind of
like automated testing for your game?

00:47:58.710 --> 00:48:03.869
&gt;&gt;Colton McAnlis: Okay. Why is it called GRITS?
I'm a fan of grits, that's all there is to

00:48:03.869 --> 00:48:06.090
it.
There's only -- let me put it this way, as

00:48:06.090 --> 00:48:10.999
a Google employee you see a lot of projects
come through with secret code names and stuff

00:48:10.999 --> 00:48:15.119
like that. And when you have a chance to name
one you kind of pick something kooky so someone

00:48:15.119 --> 00:48:19.500
else didn't already steal it. Like you would
hate to have named your project Glass and

00:48:19.500 --> 00:48:24.430
then have a dude skydive in and say "Here's
some Glass!"

00:48:24.430 --> 00:48:29.239
So GRITS just kind of showed up one day. It's
not an acronym or anything.

00:48:29.239 --> 00:48:34.059
And the second question was automated testing.
We had some basic stuff to sort test load

00:48:34.059 --> 00:48:39.650
balancing for App Engine, which Fred will
talk about in his talk a little later. How

00:48:39.650 --> 00:48:44.690
to properly scale that sort of things forward.
We didn't do any testing on the client side

00:48:44.690 --> 00:48:49.400
code and we didn't have a lot of time in our
window to test the server side code.

00:48:49.400 --> 00:48:53.140
So other than sort of mandatory play test
for all six of our team members everyday,

00:48:53.140 --> 00:48:55.950
we didn't get a chance to get much of a big
harness put together. That's kind of our fault

00:48:55.950 --> 00:48:58.369
on our thing that we definitely would like
to see fixed.

00:48:58.369 --> 00:49:02.890
We're over here now.
&gt;&gt;&gt; Hi. You talked about some prototype language

00:49:02.890 --> 00:49:06.760
that allowed you to create both the client
and server side JavaScript, and I was wondering

00:49:06.760 --> 00:49:11.560
if you could speak more about that or where
I can find out more information about that?

00:49:11.560 --> 00:49:16.660
&gt;&gt;Colton McAnlis: Uh, okay. Yeah, so the question
was prototype languages that allow you to

00:49:16.660 --> 00:49:19.819
generate both client and severer. Oh, so you're
talking about the code generation that we

00:49:19.819 --> 00:49:25.069
do? Yes. So look at our source code. That's
actually the place. It's not actually a prototype

00:49:25.069 --> 00:49:29.470
language. We actually define a structure in
JavaScript and then use JavaScript to scrape

00:49:29.470 --> 00:49:34.590
that JavaScript and then omit JavaScript.
So we use JavaScript to code gen and then

00:49:34.590 --> 00:49:37.690
move that file around.
&gt;&gt;&gt; So it's not a third-party library?

00:49:37.690 --> 00:49:40.900
&gt;&gt;Colton McAnlis: Nope. It's all in our code
base. In fact, the file you're looking for

00:49:40.900 --> 00:49:47.109
in the source code is server/proto.js, the
exact file. You will find our definition and

00:49:47.109 --> 00:49:52.119
then proto i is I think the one that actually
does the scraping of the code generation after

00:49:52.119 --> 00:49:53.799
that.
Over here.

00:49:53.799 --> 00:49:59.970
&gt;&gt;&gt; So since Web socket is TCP only, did you
guys have any kind of evaluation of TCP versus

00:49:59.970 --> 00:50:05.849
UDP and like how that behaves when you have
real network conditions and packet loss and

00:50:05.849 --> 00:50:09.730
things like that?
&gt;&gt;Colton McAnlis: The question is did we get

00:50:09.730 --> 00:50:14.250
a chance to evaluate TCP versus UDP versus
packet loss in real network conditions and

00:50:14.250 --> 00:50:17.380
stuff like that?
I would love to have somebody do that testing

00:50:17.380 --> 00:50:19.529
for us and let us know where it's falling
out.

00:50:19.529 --> 00:50:23.549
UDP wasn't really an option that we're able
to dive into a lot. We have Web sockets that

00:50:23.549 --> 00:50:27.079
are available. There's very rich containers
and wrappers for that.

00:50:27.079 --> 00:50:30.810
So again, in standard C++ development you
run into a brick wall of like, Hey, there's

00:50:30.810 --> 00:50:34.109
really no good library for UDP. You have to
reinvent the wheel every time.

00:50:34.109 --> 00:50:39.900
The fact that the JavaScript developer ecosystem
is very vibrant with people putting out open

00:50:39.900 --> 00:50:44.579
source libraries, it didn't make sense for
us to just reinvent the wheel there. It made

00:50:44.579 --> 00:50:47.480
more sense to use things like Socket I/O and
take advantage of that stuff.

00:50:47.480 --> 00:50:51.660
I will say that the guy who wrote all of our
networking code, Craig Tiller, absolutely

00:50:51.660 --> 00:50:56.099
genius. He's from the games industry where
all he's done for his entire career is optimize

00:50:56.099 --> 00:51:00.980
server side code and bandwidth and latency
hiding and everything. Definitely contact

00:51:00.980 --> 00:51:06.480
him. He's that first portrait right there.
Very beautiful man. Contact him. Craig, if

00:51:06.480 --> 00:51:08.720
you're watching...
Yes, sir?

00:51:08.720 --> 00:51:14.280
&gt;&gt;&gt; So how did you host your NodeJS?
&gt;&gt;Colton McAnlis: Next question.

00:51:14.280 --> 00:51:20.799
[Laughter]
&gt;&gt;Colton McAnlis: I like that. That was nice.

00:51:20.799 --> 00:51:26.130
Going once... going twice... The live internet
feed, everyone is like refresh.

00:51:26.130 --> 00:51:28.809
[Laughter]
&gt;&gt;Colton McAnlis: Hey, thank you guys so much

00:51:28.809 --> 00:51:33.720
again for your time. I really appreciate it.
Go check out the EA game. I'm Colt McAnlis.

00:51:33.720 --> 00:51:34.970
Send me an email.

