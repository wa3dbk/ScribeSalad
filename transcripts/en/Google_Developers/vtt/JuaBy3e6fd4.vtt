WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.370
AMY UNRUH: Hi, my name
is Amy Unruh.

00:00:02.370 --> 00:00:05.230
KIM CAMERON: And my name
is Kim Cameron.

00:00:05.230 --> 00:00:07.015
And I am addicted to robots.

00:00:09.720 --> 00:00:12.280
So when I first heard about the
idea of the internet of

00:00:12.280 --> 00:00:15.290
things, that we can have all
sorts of interconnected

00:00:15.290 --> 00:00:19.390
machines that talk and do things
for humans, I thought,

00:00:19.390 --> 00:00:23.100
this is totally awesome.

00:00:23.100 --> 00:00:26.040
Finally I can have a robot
butler that brings me things.

00:00:26.040 --> 00:00:29.220
Maybe it wipes off my forehead,
I don't know why.

00:00:29.220 --> 00:00:31.250
But I'm just going to say the
elephant in the room here.

00:00:31.250 --> 00:00:33.410
I know someone else
is thinking this.

00:00:33.410 --> 00:00:36.040
Think about a bunch of
interconnected machines.

00:00:36.040 --> 00:00:37.290
They're doing stuff for us.

00:00:37.290 --> 00:00:38.470
They're intelligent.

00:00:38.470 --> 00:00:42.490
There is one additional thing
that comes to mind.

00:00:42.490 --> 00:00:43.580
Nobody wants this.

00:00:43.580 --> 00:00:45.660
No one wants robot overlords.

00:00:45.660 --> 00:00:47.220
Why are we even talking
about robots?

00:00:47.220 --> 00:00:50.210
You're here to hear about data
sensing lab project that we

00:00:50.210 --> 00:00:52.230
did at Moscone.

00:00:52.230 --> 00:00:55.760
We wanted to build an internet
of things app that helped us

00:00:55.760 --> 00:00:58.000
see more about what's going
on than what you

00:00:58.000 --> 00:00:59.880
normally could see.

00:00:59.880 --> 00:01:02.840
We didn't want to create
a robot army.

00:01:02.840 --> 00:01:06.740
We wanted to create an army of
sensor motes that we could put

00:01:06.740 --> 00:01:10.030
up around the conference and get
all sorts of data in, show

00:01:10.030 --> 00:01:11.860
it to you in really cool ways.

00:01:11.860 --> 00:01:14.420
And, again, to show us things
that we couldn't normally see.

00:01:20.380 --> 00:01:22.910
Slides are malfunctioning
like a robot.

00:01:22.910 --> 00:01:25.815
So we wanted our app to do
cool stuff like this.

00:01:25.815 --> 00:01:28.760
This is a chart of
noise yesterday.

00:01:28.760 --> 00:01:32.952
As you can see during the party,
Billy Idol, huge noise.

00:01:32.952 --> 00:01:35.190
And our app is going to do a lot
of other stuff than this.

00:01:35.190 --> 00:01:37.940
But before we get into that,
let's talk about how the

00:01:37.940 --> 00:01:40.040
project got started.

00:01:40.040 --> 00:01:42.630
So back in February our
colleague, Michael Manoochehri

00:01:42.630 --> 00:01:44.550
was at Strata.

00:01:44.550 --> 00:01:47.700
And he was intrigued by a
project by the O'Reilly data

00:01:47.700 --> 00:01:49.620
sensing lab team.

00:01:49.620 --> 00:01:51.950
The setup was fairly similar
to what we're doing here.

00:01:51.950 --> 00:01:53.640
There were about 50 motes.

00:01:53.640 --> 00:01:55.370
They were set up across
the conference.

00:01:55.370 --> 00:01:57.590
They gathered a bunch of
environmental data.

00:01:57.590 --> 00:02:00.040
And based on that we were shown
visualizations about

00:02:00.040 --> 00:02:01.690
what was going on.

00:02:01.690 --> 00:02:03.610
And Michael thought,
this is great.

00:02:03.610 --> 00:02:05.880
Why not bigger?

00:02:05.880 --> 00:02:10.470
So we took 500 Arduino boards
for our project.

00:02:10.470 --> 00:02:14.140
And to each of these boards we
added a custom sensor shield

00:02:14.140 --> 00:02:19.240
which was added by Kipp Bradford
or kippkitts, and

00:02:19.240 --> 00:02:23.580
Alasdair Allen of Babilim
Light Industries.

00:02:23.580 --> 00:02:24.520
Yes.

00:02:24.520 --> 00:02:27.560
And each of these shields has
a bunch of sensors on it.

00:02:27.560 --> 00:02:30.800
Noise, light, humidity,
some other built ins.

00:02:30.800 --> 00:02:35.200
As well as three optional
sensors for air quality.

00:02:35.200 --> 00:02:38.570
Also RF, which we have
tuned to GSM.

00:02:38.570 --> 00:02:39.740
As well as motions.

00:02:39.740 --> 00:02:41.705
So you might have seen
these mats around.

00:02:41.705 --> 00:02:43.600
We even had one in the car.

00:02:43.600 --> 00:02:46.380
And that was registering when
people were stepping on them

00:02:46.380 --> 00:02:47.630
and stepping off.

00:02:52.580 --> 00:02:55.900
And the shield and the Arduino
boards put together make up a

00:02:55.900 --> 00:02:58.800
mote, which is essentially a
node in a sensory network.

00:02:58.800 --> 00:02:59.980
I'm sure you've seen
them around.

00:02:59.980 --> 00:03:03.630
They have little blinky lights,
cute signs, all that.

00:03:03.630 --> 00:03:06.290
We put them up all over Moscone
on all of the floors,

00:03:06.290 --> 00:03:08.810
including in some interesting
spaces such as I

00:03:08.810 --> 00:03:10.070
mentioned in the car.

00:03:10.070 --> 00:03:12.330
There were a few in that blimp
that was circling around the

00:03:12.330 --> 00:03:13.770
second floor.

00:03:13.770 --> 00:03:15.520
We wanted to get readings
all over the place.

00:03:15.520 --> 00:03:18.980
In fact, I believe there was
a mote in that really noisy

00:03:18.980 --> 00:03:22.420
architect game last night.

00:03:22.420 --> 00:03:24.240
The next problem was how
would these motes

00:03:24.240 --> 00:03:25.720
talk to each other?

00:03:25.720 --> 00:03:27.260
So some of you might
be thinking, OK

00:03:27.260 --> 00:03:29.020
set up a Wi-Fi network.

00:03:29.020 --> 00:03:32.160
And the issue with that is we
would have to set up wireless

00:03:32.160 --> 00:03:35.570
routers everywhere for the range
to work for the motes.

00:03:35.570 --> 00:03:38.170
Instead we put up
a mesh network.

00:03:38.170 --> 00:03:40.880
So the idea behind the mesh
network is, let's say that

00:03:40.880 --> 00:03:42.920
there's a node that's close
to its gateway.

00:03:42.920 --> 00:03:44.650
It needs to get its
information there.

00:03:44.650 --> 00:03:45.390
That's fine.

00:03:45.390 --> 00:03:46.330
It sends the information.

00:03:46.330 --> 00:03:47.990
The gateway is right next by.

00:03:47.990 --> 00:03:49.355
But what about motes
that are farther

00:03:49.355 --> 00:03:51.330
away, at farther range?

00:03:51.330 --> 00:03:54.150
They can just talk to the nearby
mote which then hops

00:03:54.150 --> 00:03:55.850
the message along through
the motes until

00:03:55.850 --> 00:03:57.340
it gets to the gateway.

00:03:57.340 --> 00:04:01.290
This allows for a much
greater range.

00:04:01.290 --> 00:04:03.570
So we have an XP radio on
each of the shields.

00:04:03.570 --> 00:04:05.830
And it's communicating over a
ZigBee protocol which some of

00:04:05.830 --> 00:04:08.990
you might be familiar with.

00:04:08.990 --> 00:04:12.250
This network was set up by our
partners Digi International.

00:04:12.250 --> 00:04:14.730
They also worked on the
Strata project.

00:04:14.730 --> 00:04:18.350
And they have a product called
Device Cloud by Etherios.

00:04:18.350 --> 00:04:23.970
So what's happening is each
sensor mote is sending its

00:04:23.970 --> 00:04:27.310
readings every 20 seconds to the
gateways which are going

00:04:27.310 --> 00:04:28.940
to device cloud by Etherios.

00:04:28.940 --> 00:04:31.930
They even do just a little bit
like add a time stamp then

00:04:31.930 --> 00:04:34.550
they send it to us.

00:04:34.550 --> 00:04:37.890
So on our end we needed to
create a software solution to

00:04:37.890 --> 00:04:39.430
manage this.

00:04:39.430 --> 00:04:40.470
This is a challenging problem.

00:04:40.470 --> 00:04:42.630
How do you even get
started with this?

00:04:42.630 --> 00:04:44.590
We knew it had to be scalable.

00:04:44.590 --> 00:04:47.320
We didn't want to focus much on
the infrastructure which is

00:04:47.320 --> 00:04:49.730
why we wanted to try out
the cloud platform.

00:04:49.730 --> 00:04:52.850
And luckily, the woman who coded
most of this project is

00:04:52.850 --> 00:04:54.720
standing next to
me, Amy Unruh.

00:04:54.720 --> 00:04:57.356
So Amy, how do we get started
with this challenge?

00:04:57.356 --> 00:04:58.675
AMY UNRUH: Well Kim.

00:04:58.675 --> 00:05:00.000
KIM CAMERON: Oh I apologize.

00:05:00.000 --> 00:05:00.880
I missed some slides.

00:05:00.880 --> 00:05:02.465
So--

00:05:02.465 --> 00:05:04.060
AMY UNRUH: The suspense.

00:05:04.060 --> 00:05:05.330
KIM CAMERON: The suspense.

00:05:05.330 --> 00:05:05.980
I apologize.

00:05:05.980 --> 00:05:08.625
So I just wanted to show you
a few visualizations

00:05:08.625 --> 00:05:11.610
before we moved on.

00:05:11.610 --> 00:05:18.295
And, ooh I don't know what's
happening there.

00:05:18.295 --> 00:05:19.545
Now I've lost--

00:05:25.880 --> 00:05:26.170
all right.

00:05:26.170 --> 00:05:27.420
I'm just going to
look up here.

00:05:29.960 --> 00:05:32.490
Or maybe I can--

00:05:32.490 --> 00:05:34.940
here we go.

00:05:34.940 --> 00:05:41.890
So this is a live visual of
temperature readings on the

00:05:41.890 --> 00:05:43.250
second floor.

00:05:43.250 --> 00:05:44.820
So as you can see, these
two rooms are

00:05:44.820 --> 00:05:46.810
apparently very popular.

00:05:46.810 --> 00:05:49.650
As well as, this is like
the cloud sandbox area.

00:05:49.650 --> 00:05:50.830
All the other sandbox areas.

00:05:50.830 --> 00:05:53.540
And I'm not sure what's over
here, but it's also very high

00:05:53.540 --> 00:05:54.790
temperature.

00:05:59.480 --> 00:06:02.728
I apologize for my ineptness
at getting out of this.

00:06:09.140 --> 00:06:11.180
As well, this is an interesting
correlation that

00:06:11.180 --> 00:06:13.760
was done by our friends
at Tableau.

00:06:13.760 --> 00:06:15.085
They have a really
cool connector

00:06:15.085 --> 00:06:16.890
that hooks up to BigQuery.

00:06:16.890 --> 00:06:18.990
And it shows really neat
visualizations.

00:06:18.990 --> 00:06:22.600
So this is a chart of air
quality versus steps on that

00:06:22.600 --> 00:06:23.940
motion pad.

00:06:23.940 --> 00:06:26.920
So as you can see with the green
above and below, the

00:06:26.920 --> 00:06:30.340
number of steps to indicate
drop in air quality, which

00:06:30.340 --> 00:06:32.800
means there's a bunch of us
smelly nerds walking around.

00:06:32.800 --> 00:06:34.805
And that's ruining
the air quality.

00:06:37.420 --> 00:06:38.960
So now we'll get to Amy Unruh.

00:06:38.960 --> 00:06:40.030
I apologize for the delay.

00:06:40.030 --> 00:06:42.732
To talk about the software
solution.

00:06:42.732 --> 00:06:45.660
AMY UNRUH: So the first thing
that we needed to think about

00:06:45.660 --> 00:06:50.550
was how to get this barrage
of data into the system.

00:06:50.550 --> 00:06:54.500
So the sensors are feeding us
data at a really high rate.

00:06:54.500 --> 00:06:57.590
We need to suck into
our system.

00:06:57.590 --> 00:07:00.070
We don't want our app
to fall over.

00:07:00.070 --> 00:07:01.500
We don't want it to lose data.

00:07:01.500 --> 00:07:03.690
And we need to get it to some
place where it's persistent.

00:07:03.690 --> 00:07:04.940
Where it's safe.

00:07:08.340 --> 00:07:13.420
This whole framework that we're
building to ingest the

00:07:13.420 --> 00:07:15.680
data we've been calling
the pipeline.

00:07:15.680 --> 00:07:19.550
And as Kim said, we use the
cloud platform for this.

00:07:19.550 --> 00:07:23.750
And, in fact, we use multiple
pieces of the cloud platform.

00:07:23.750 --> 00:07:28.670
Did any of you get a chance to
see the great all of the ships

00:07:28.670 --> 00:07:30.725
of the world talk
earlier today?

00:07:30.725 --> 00:07:32.360
Yeah, that was fantastic.

00:07:32.360 --> 00:07:36.360
And they also had what I would
consider a platform.

00:07:36.360 --> 00:07:37.790
Ours this is a little
different.

00:07:37.790 --> 00:07:39.780
They're serving slightly
different needs.

00:07:39.780 --> 00:07:44.350
But this is, they're somewhat
similar patterns.

00:07:44.350 --> 00:07:48.290
Foundations for sucking a lot
of data into a system really

00:07:48.290 --> 00:07:51.570
quickly so you can start to do
interesting things with it.

00:07:51.570 --> 00:07:54.080
So let's look at how
we did this.

00:07:54.080 --> 00:07:59.150
The first step, just
ingesting the data,

00:07:59.150 --> 00:08:00.750
bringing it safely in.

00:08:00.750 --> 00:08:02.580
We're using App Engine
for this.

00:08:02.580 --> 00:08:05.270
App Engine is part of
the cloud platform.

00:08:05.270 --> 00:08:09.240
It's designed for simplicity and
for letting you deploy a

00:08:09.240 --> 00:08:11.950
web apps at Google scale.

00:08:11.950 --> 00:08:15.100
And we are using, in particular,
three features of

00:08:15.100 --> 00:08:17.210
App Engine to do this.

00:08:17.210 --> 00:08:20.080
First of all, it scalability.

00:08:20.080 --> 00:08:21.950
App Engine auto scales
for you.

00:08:21.950 --> 00:08:27.240
So as more and more sensor motes
come online our app is

00:08:27.240 --> 00:08:28.770
going to scale up
to handle that.

00:08:28.770 --> 00:08:31.660
We don't need to pay attention
to that or do anything.

00:08:31.660 --> 00:08:34.030
And we don't need to do
any provisioning.

00:08:34.030 --> 00:08:35.980
And, in fact, we watched
this happen over

00:08:35.980 --> 00:08:37.799
the past day or two.

00:08:37.799 --> 00:08:39.380
It worked really well.

00:08:39.380 --> 00:08:41.740
The second thing that we're
doing is, as we ingest the

00:08:41.740 --> 00:08:47.330
data we're processing in the
background using task queues,

00:08:47.330 --> 00:08:49.770
App Engine task queues.

00:08:49.770 --> 00:08:52.170
This might be one of my favorite
App Engine features.

00:08:52.170 --> 00:08:55.370
Essentially task queues
let you run processes

00:08:55.370 --> 00:09:00.060
asynchronously to the request
response cycle of the app.

00:09:00.060 --> 00:09:03.850
And so as data comes flooding in
we're bundling it off to an

00:09:03.850 --> 00:09:07.350
army of task queue tasks to
actually do the processing.

00:09:07.350 --> 00:09:10.850
And that lets our app stay
really responsive and really

00:09:10.850 --> 00:09:12.460
high throughput.

00:09:12.460 --> 00:09:16.180
And then, finally, we're using
the App Enginge Cloud

00:09:16.180 --> 00:09:21.870
Datastore to store this data as
it comes into the system.

00:09:21.870 --> 00:09:27.840
The cloud data store is managed
really robust, highly

00:09:27.840 --> 00:09:31.710
scalable, distributed
new SQL Datastore.

00:09:31.710 --> 00:09:32.970
It's perfect for this.

00:09:32.970 --> 00:09:36.150
We can throw a large amount of
data at it really quickly.

00:09:36.150 --> 00:09:37.780
It doesn't even blink.

00:09:37.780 --> 00:09:42.980
And it can get really large and
we can still get data out

00:09:42.980 --> 00:09:44.530
very quickly.

00:09:44.530 --> 00:09:46.310
So we're using the data
store for our

00:09:46.310 --> 00:09:49.500
initial data ingestion.

00:09:49.500 --> 00:09:51.015
So what happens next, Kim?

00:09:51.015 --> 00:09:53.390
KIM CAMERON: So I'm glad
you asked, Amy.

00:09:53.390 --> 00:09:56.770
We next need to get our
data into BigQuery.

00:09:56.770 --> 00:09:59.450
AMY UNRUH: So actually we just
got our data into the

00:09:59.450 --> 00:10:01.620
Datastore, so why do
we need to do that?

00:10:01.620 --> 00:10:02.970
KIM CAMERON: I am
glad you asked.

00:10:02.970 --> 00:10:08.290
So BigQuery lets you query
huge, huge data sets in a

00:10:08.290 --> 00:10:09.360
matter of seconds.

00:10:09.360 --> 00:10:12.460
And it also supports something
that we're going to be using

00:10:12.460 --> 00:10:13.790
our visualizations.

00:10:13.790 --> 00:10:15.150
And that's aggregate queries.

00:10:15.150 --> 00:10:16.890
BigQuery is also good at
things like regular

00:10:16.890 --> 00:10:19.340
expressions and other
complex queries.

00:10:19.340 --> 00:10:21.640
So we know we want to get the
data into BigQuery so we can

00:10:21.640 --> 00:10:23.990
use it for these
visualizations.

00:10:23.990 --> 00:10:26.920
So to do this we have two
things to consider.

00:10:26.920 --> 00:10:29.725
First, we need to do some stuff
with our data before we

00:10:29.725 --> 00:10:30.740
move it in.

00:10:30.740 --> 00:10:34.140
Specifically we transform the
data to put it into a schema

00:10:34.140 --> 00:10:36.070
that BigQuery expects.

00:10:36.070 --> 00:10:38.340
Second, we're going to
join some data in

00:10:38.340 --> 00:10:39.440
with our sensor data.

00:10:39.440 --> 00:10:41.440
So we have mote data
that we're also

00:10:41.440 --> 00:10:42.730
storing in data store.

00:10:42.730 --> 00:10:45.620
It has information about the
motes like its location, its

00:10:45.620 --> 00:10:47.510
name, other information.

00:10:47.510 --> 00:10:49.960
So we join all that together
in App Engine first.

00:10:49.960 --> 00:10:54.060
And now we have the data that we
want to move into BigQuery.

00:10:54.060 --> 00:10:55.200
So where are we going
to put it?

00:10:55.200 --> 00:10:59.800
We're going to move it
into cloud storage.

00:10:59.800 --> 00:11:02.320
This is the recommended way that
we suggest you move your

00:11:02.320 --> 00:11:03.280
data into BigQuery.

00:11:03.280 --> 00:11:05.380
You could have also sent
a post request and

00:11:05.380 --> 00:11:06.810
attached the data.

00:11:06.810 --> 00:11:09.930
The advantage of staging it on
Google Cloud Storage first is

00:11:09.930 --> 00:11:11.700
that for one it's quick.

00:11:11.700 --> 00:11:14.060
For two, you have a copy
of your data there now.

00:11:14.060 --> 00:11:16.550
Let's say you wanted to share
the data set, you have it on

00:11:16.550 --> 00:11:17.900
cloud storage ready to go.

00:11:17.900 --> 00:11:20.460
Ready to link people to.

00:11:20.460 --> 00:11:23.230
So we need to move our data to
cloud storage, but there's

00:11:23.230 --> 00:11:26.350
something else that we need to
consider, and that's how

00:11:26.350 --> 00:11:29.110
frequently do we move the
data to BigQuery?

00:11:29.110 --> 00:11:31.500
Because there's quotas on the
amount of loads you can do per

00:11:31.500 --> 00:11:34.280
day, we don't want to just shove
data at it every single

00:11:34.280 --> 00:11:35.620
time we get a reading.

00:11:35.620 --> 00:11:38.700
So we want to be careful and
batch up the data and move it

00:11:38.700 --> 00:11:40.520
when it's appropriate.

00:11:40.520 --> 00:11:44.370
So how we're accomplishing this
is we're using another

00:11:44.370 --> 00:11:46.610
kind of App Engine task queue.

00:11:46.610 --> 00:11:48.190
Tasks on the task queue.

00:11:48.190 --> 00:11:50.160
Which run not as frequently.

00:11:50.160 --> 00:11:51.430
They check the data store.

00:11:51.430 --> 00:11:54.162
They see, is there enough
unprocessed data here to

00:11:54.162 --> 00:11:57.560
warrant doing a load, and if so
it's going to move the data

00:11:57.560 --> 00:11:59.420
into cloud storage.

00:11:59.420 --> 00:12:02.100
All right, so now the data is in
cloud storage ready to go.

00:12:02.100 --> 00:12:05.080
Someone has to push the button
to actually move the data from

00:12:05.080 --> 00:12:07.380
cloud storage into BigQuery.

00:12:07.380 --> 00:12:08.490
Amy, who is that going to be?

00:12:08.490 --> 00:12:10.070
It's not me.

00:12:10.070 --> 00:12:12.990
AMY UNRUH: That's going to be
a Compute Engine instance.

00:12:12.990 --> 00:12:18.050
And as you guys probably know,
Compute Engine lets you run

00:12:18.050 --> 00:12:21.870
really flexible, fast, virtual
machines in the cloud.

00:12:21.870 --> 00:12:25.960
So we're going to use Compute
Engine to pull this data in.

00:12:25.960 --> 00:12:31.530
And it's going to instruct
BigQuery to do these low jobs.

00:12:31.530 --> 00:12:33.650
Tell BigQuery to get the
data from cloud storage

00:12:33.650 --> 00:12:34.410
and to load it in.

00:12:34.410 --> 00:12:36.340
KIM CAMERON: So now
I'm confused, Amy.

00:12:36.340 --> 00:12:38.840
Because since our data is in App
Engine, why don't we just

00:12:38.840 --> 00:12:41.270
have App Engine move the
data into BigQuery?

00:12:41.270 --> 00:12:42.950
AMY UNRUH: So that's
a good question.

00:12:42.950 --> 00:12:45.410
In fact, you could do
this very easily in

00:12:45.410 --> 00:12:46.760
App Engine, as well.

00:12:46.760 --> 00:12:49.450
There's an API that
accomplishes this.

00:12:49.450 --> 00:12:51.250
It's really easy to use.

00:12:51.250 --> 00:12:53.690
And the reason that we're
using Compute Engine is

00:12:53.690 --> 00:12:56.990
because we're already using it
for other parts of our system.

00:12:56.990 --> 00:12:59.490
We already have instances
launched.

00:12:59.490 --> 00:13:04.310
And this is a really long
running, kind of boring, batch

00:13:04.310 --> 00:13:05.130
script that's running.

00:13:05.130 --> 00:13:07.500
So it's really appropriate
just to run it on Compute

00:13:07.500 --> 00:13:08.710
Engine and forget about it.

00:13:08.710 --> 00:13:09.990
KIM CAMERON: OK, so
that's great.

00:13:09.990 --> 00:13:12.960
So how does compute know when
it should move the data from

00:13:12.960 --> 00:13:14.450
cloud storage to BigQuery?

00:13:14.450 --> 00:13:18.000
AMY UNRUH: So this is actually
really interesting design

00:13:18.000 --> 00:13:19.160
pattern that we're using here.

00:13:19.160 --> 00:13:22.690
And if you saw the all the ships
of the world talk you

00:13:22.690 --> 00:13:25.280
might have caught this being
used with them as well.

00:13:25.280 --> 00:13:26.490
We're using pool queues.

00:13:26.490 --> 00:13:28.450
App engine pull queues.

00:13:28.450 --> 00:13:31.940
So pull queues have
a REST API.

00:13:31.940 --> 00:13:35.900
And they essentially let you
place messages, one process

00:13:35.900 --> 00:13:38.950
can place a bunch of messages
on this pool queue.

00:13:38.950 --> 00:13:41.910
And other processes can pull
off the messages and do

00:13:41.910 --> 00:13:43.850
something with that
information.

00:13:43.850 --> 00:13:47.540
So as App Engine batches all
of its data into cloud

00:13:47.540 --> 00:13:53.520
storage, it's creating messages
on this pool cue that

00:13:53.520 --> 00:13:55.620
give information about the
files that it's created.

00:13:55.620 --> 00:13:59.140
And then Compute Engine, this
long running script, is going

00:13:59.140 --> 00:14:02.740
pool many hundreds of those
messages off in batch.

00:14:02.740 --> 00:14:06.020
So we're magnifying our
batch processing here.

00:14:06.020 --> 00:14:11.780
And really quickly construct a
load job that goes off and

00:14:11.780 --> 00:14:13.460
tells BigQuery to load
all these files.

00:14:13.460 --> 00:14:16.440
So it's really efficient.

00:14:16.440 --> 00:14:21.740
OK, so what we've described
here is this pipeline, the

00:14:21.740 --> 00:14:23.670
foundation of our system.

00:14:23.670 --> 00:14:27.270
It's how where ingesting lots of
data at a high rate and how

00:14:27.270 --> 00:14:30.100
we're storing putting it where
we want it to be in two

00:14:30.100 --> 00:14:32.210
different persistent stores.

00:14:32.210 --> 00:14:37.060
And this was actually pretty
straightforward to build.

00:14:37.060 --> 00:14:40.760
It certainly wasn't trivial,
but it was pretty

00:14:40.760 --> 00:14:41.590
straightforward.

00:14:41.590 --> 00:14:44.330
And we built it, just a few of
us developers in a short

00:14:44.330 --> 00:14:45.690
period of time.

00:14:45.690 --> 00:14:49.180
And this is actually
pretty cool.

00:14:49.180 --> 00:14:52.940
Because this can be a hard
problem, especially at scale.

00:14:52.940 --> 00:14:56.890
And the reason it was so
straightforward is because all

00:14:56.890 --> 00:14:59.390
of the pieces of the cloud
platform that we were using

00:14:59.390 --> 00:15:03.420
are so robust and scalable in
their own right and talk so

00:15:03.420 --> 00:15:04.590
easily to each other.

00:15:04.590 --> 00:15:07.460
So that it was a really
cool result.

00:15:07.460 --> 00:15:10.550
So now we have this foundation,
this pipeline.

00:15:10.550 --> 00:15:12.960
And we can start to do all sorts
of really fun things

00:15:12.960 --> 00:15:16.790
with the data that
we're collecting.

00:15:16.790 --> 00:15:19.480
KIM CAMERON: So now we can get
to those cool visualizations

00:15:19.480 --> 00:15:21.190
we are looking at
earlier today.

00:15:21.190 --> 00:15:24.310
And we have a few to show you.

00:15:24.310 --> 00:15:27.090
So first off, we're doing
visualizations based on both

00:15:27.090 --> 00:15:27.960
of our data stores.

00:15:27.960 --> 00:15:31.190
We're using both data store
and we're using BigQuery.

00:15:31.190 --> 00:15:32.770
And, again, it depends
on what type of

00:15:32.770 --> 00:15:34.770
visualizations we want to do.

00:15:34.770 --> 00:15:42.970
So in this example, this is
going to be another live demo.

00:15:42.970 --> 00:15:45.840
And this one is, it's a little
bit hard to see there.

00:15:45.840 --> 00:15:48.400
But these are the pressure
mats that are

00:15:48.400 --> 00:15:49.860
on the first floor.

00:15:49.860 --> 00:15:51.800
So if you look in this area
here, these are the

00:15:51.800 --> 00:15:52.295
escalators.

00:15:52.295 --> 00:15:53.750
AMY UNRUH: They're
counting steps.

00:15:53.750 --> 00:15:56.270
KIM CAMERON: And you can also
see there's a lot of traffic

00:15:56.270 --> 00:15:58.460
here by both sets of doors.

00:15:58.460 --> 00:16:01.390
And I don't know what this
is, but it's curious.

00:16:01.390 --> 00:16:04.510
So this one is getting data
from data storage.

00:16:04.510 --> 00:16:07.730
Just getting the last x values
very quick to do there.

00:16:07.730 --> 00:16:08.860
We don't need to
use any sort of

00:16:08.860 --> 00:16:11.020
complicated aggregate queries.

00:16:11.020 --> 00:16:12.520
And we have a lot of
things like this.

00:16:12.520 --> 00:16:15.080
You can look at recent
light readings, noise

00:16:15.080 --> 00:16:16.330
readings stuff like that.

00:16:24.370 --> 00:16:25.170
So now here's the

00:16:25.170 --> 00:16:27.710
visualization that uses BigQuery.

00:16:27.710 --> 00:16:30.430
This is the 40 noisiest
minutes at

00:16:30.430 --> 00:16:31.840
Google I/O thus far.

00:16:31.840 --> 00:16:34.475
This is from yesterday, and so
you'll notice there's a spike.

00:16:34.475 --> 00:16:36.860
It's around the same
time as the party.

00:16:36.860 --> 00:16:39.080
So this is pretty similar to
the other visualizations,

00:16:39.080 --> 00:16:40.860
really noisy going on there.

00:16:40.860 --> 00:16:42.680
And this one is using
an aggregate query.

00:16:42.680 --> 00:16:44.170
So this is the BigQuery
query we're

00:16:44.170 --> 00:16:47.170
running to get this result.

00:16:47.170 --> 00:16:49.040
As you can see, we're using the
average function which is

00:16:49.040 --> 00:16:50.070
an aggregate.

00:16:50.070 --> 00:16:53.460
And it's just checking the most
recent 40 loudest rooms

00:16:53.460 --> 00:16:56.070
based on average.

00:16:56.070 --> 00:16:57.905
So let's run a query live.

00:17:02.060 --> 00:17:03.310
And you can see the results.

00:17:06.640 --> 00:17:10.410
So, as a note, we have made the
BigQuery data set public.

00:17:10.410 --> 00:17:12.410
Any of you can have access
to that now.

00:17:12.410 --> 00:17:14.599
We have a resources slide at the
end that has a link to the

00:17:14.599 --> 00:17:15.520
data sensing lab.

00:17:15.520 --> 00:17:17.680
You can also check out the
kiosks for the link.

00:17:17.680 --> 00:17:19.960
And it gives you instructions
on where to get the data set

00:17:19.960 --> 00:17:21.010
and how to find it.

00:17:21.010 --> 00:17:22.400
AMY UNRUH: Which is
incidentally still

00:17:22.400 --> 00:17:23.829
growing as we speak.

00:17:23.829 --> 00:17:24.520
KIM CAMERON: Yes.

00:17:24.520 --> 00:17:27.550
So, we are going to do--

00:17:27.550 --> 00:17:27.900
I apologize.

00:17:27.900 --> 00:17:30.540
It's not showing up on
my laptop, so I am

00:17:30.540 --> 00:17:31.790
doing it this way.

00:17:35.690 --> 00:17:37.530
AMY UNRUH: Query history
as well.

00:17:37.530 --> 00:17:37.850
KIM CAMERON: Sorry?

00:17:37.850 --> 00:17:38.520
AMY UNRUH: Query history.

00:17:38.520 --> 00:17:39.770
Either way.

00:17:45.110 --> 00:17:46.270
So view the query history.

00:17:46.270 --> 00:17:47.758
KIM CAMERON: It's hard
to see on here.

00:17:54.206 --> 00:17:55.456
OK.

00:18:05.118 --> 00:18:07.260
It's the pregnant
pause moment.

00:18:07.260 --> 00:18:08.080
There we go!

00:18:08.080 --> 00:18:08.395
Hooray!

00:18:08.395 --> 00:18:09.402
AMY UNRUH: I thought we
were going to have

00:18:09.402 --> 00:18:11.370
to sing show tunes.

00:18:11.370 --> 00:18:12.170
KIM CAMERON: All right.

00:18:12.170 --> 00:18:14.210
So this is the results
of BigQuery.

00:18:14.210 --> 00:18:17.980
You can see the rooms and other
information about it.

00:18:17.980 --> 00:18:21.715
And just for fun let's also look
at one for temperature.

00:18:35.820 --> 00:18:37.190
If I can find it.

00:18:37.190 --> 00:18:38.440
Here we go.

00:18:47.950 --> 00:18:50.150
So Android East, hottest room.

00:18:50.150 --> 00:18:51.680
Room 12, not sure
what that is.

00:18:51.680 --> 00:18:53.160
Keynote West.

00:18:53.160 --> 00:18:54.580
Pixel, I guess that's when
you were all picking

00:18:54.580 --> 00:18:55.770
up your free pixels.

00:18:55.770 --> 00:18:58.890
So interesting information.

00:18:58.890 --> 00:19:00.896
And so for these we really
needed to use BigQuery due to

00:19:00.896 --> 00:19:03.320
the aggregates.

00:19:03.320 --> 00:19:06.130
Now, in addition to these
visualizations, we wanted to

00:19:06.130 --> 00:19:09.100
be able to do things like
maybe find correlations

00:19:09.100 --> 00:19:11.080
between data or at
least facilitate

00:19:11.080 --> 00:19:12.410
that for the future.

00:19:12.410 --> 00:19:13.675
This is a really hard problem.

00:19:13.675 --> 00:19:15.420
And we had to figure out
how to set this up.

00:19:15.420 --> 00:19:18.506
So Amy, how did we get
started with this?

00:19:18.506 --> 00:19:20.970
AMY UNRUH: So one thing
that we're doing--

00:19:20.970 --> 00:19:24.510
So, again, basically want to
start surfacing interesting

00:19:24.510 --> 00:19:27.160
patterns and mining all this
data and in addition to the

00:19:27.160 --> 00:19:28.810
visualizations that
we're doing.

00:19:28.810 --> 00:19:31.970
So one thing we're doing is
we're actually monitoring for

00:19:31.970 --> 00:19:35.680
particular things that we know
we want to look for.

00:19:35.680 --> 00:19:40.050
And one simple example of this
is we want to watch for motes

00:19:40.050 --> 00:19:42.320
as they go on and offline.

00:19:42.320 --> 00:19:44.450
So we expected there would be
a lot of reasons that they

00:19:44.450 --> 00:19:46.400
would do this.

00:19:46.400 --> 00:19:48.440
People unplugging them to
use their cell phones.

00:19:48.440 --> 00:19:49.940
Kicking them.

00:19:49.940 --> 00:19:51.190
Those motes are pretty cute.

00:19:51.190 --> 00:19:53.770
And we thought those motes, some
of them might just take a

00:19:53.770 --> 00:19:56.780
bit of a walk.

00:19:56.780 --> 00:20:00.270
So we're running background
tasks to detect when they go

00:20:00.270 --> 00:20:01.210
on and offline.

00:20:01.210 --> 00:20:03.220
And we're mapping that.

00:20:03.220 --> 00:20:10.520
And see if I can bring
up a live version.

00:20:10.520 --> 00:20:12.990
Sort of disturbingly,
there's, whoops.

00:20:19.240 --> 00:20:19.720
Yeah.

00:20:19.720 --> 00:20:21.220
Why don't you do it
while I talk?

00:20:21.220 --> 00:20:22.252
KIM CAMERON: I don't
know the link

00:20:22.252 --> 00:20:24.280
AMY UNRUH: Just click
on missing.

00:20:24.280 --> 00:20:28.890
Sort of disturbingly, there's a
lot more missing motes today

00:20:28.890 --> 00:20:31.720
than there were yesterday,
for some reason.

00:20:31.720 --> 00:20:32.300
It's all right.

00:20:32.300 --> 00:20:34.330
We'll just look at
the screen shot.

00:20:34.330 --> 00:20:38.210
This should be showing up on
your kiosks as well scattered

00:20:38.210 --> 00:20:39.500
around Moscone.

00:20:39.500 --> 00:20:43.280
There were a lot more when I
checked an hour or so ago than

00:20:43.280 --> 00:20:46.020
there were yesterday.

00:20:46.020 --> 00:20:48.750
So there's all sorts of
monitoring tasks that we want

00:20:48.750 --> 00:20:49.410
to do like this.

00:20:49.410 --> 00:20:53.020
We've set up, again with the
task queues, the App Engine

00:20:53.020 --> 00:20:55.800
task queues, we've set up
a framework to do this.

00:20:55.800 --> 00:20:59.300
Where we can specify, define the
kinds of things we want to

00:20:59.300 --> 00:21:02.270
monitor and how frequently
we want to look for them.

00:21:02.270 --> 00:21:03.940
And we just set them loose.

00:21:03.940 --> 00:21:05.620
Again, running in
the background.

00:21:05.620 --> 00:21:08.010
And App Engine will scale
these up for us.

00:21:08.010 --> 00:21:12.140
So we can look for a whole lot
of things really scalable as

00:21:12.140 --> 00:21:14.150
this flood of data comes in.

00:21:14.150 --> 00:21:15.870
So that's one thing
we're doing.

00:21:15.870 --> 00:21:22.050
But more broadly, we need to
start mining this data.

00:21:22.050 --> 00:21:24.530
Looking for interesting
patterns.

00:21:24.530 --> 00:21:29.000
And as any data scientist in
the audience will know,

00:21:29.000 --> 00:21:34.710
there's just a whole arsenal
out there of libraries and

00:21:34.710 --> 00:21:37.870
packages that help you do
this kind of thing.

00:21:37.870 --> 00:21:41.200
For example, [INAUDIBLE],
all sorts of things.

00:21:41.200 --> 00:21:45.140
So we've got all this data, now
we can start feeding it to

00:21:45.140 --> 00:21:47.055
some of these great
analysis packages.

00:21:47.055 --> 00:21:49.010
KIM CAMERON: And I assume we're
going to be doing this

00:21:49.010 --> 00:21:50.000
on App Engine.

00:21:50.000 --> 00:21:53.520
AMY UNRUH: Well, I'm sorry
to break it to you, Kim.

00:21:53.520 --> 00:21:55.050
Many of these packages actually

00:21:55.050 --> 00:21:56.770
don't run on App Engine.

00:21:56.770 --> 00:22:01.120
The reason relates to how App
Engine packages or sandboxes

00:22:01.120 --> 00:22:02.680
some of its services.

00:22:02.680 --> 00:22:05.880
However, all of these
packages run really

00:22:05.880 --> 00:22:08.470
well on Compute Engine.

00:22:08.470 --> 00:22:11.370
And so that's where we're
going to do it.

00:22:11.370 --> 00:22:16.520
And there is something that was
just announced yesterday

00:22:16.520 --> 00:22:18.130
that many of you might
have caught.

00:22:18.130 --> 00:22:21.850
That just really facilitates
this and is

00:22:21.850 --> 00:22:23.000
really pretty exciting.

00:22:23.000 --> 00:22:25.120
And that is the announcement
of the

00:22:25.120 --> 00:22:26.840
Google Cloud data store.

00:22:26.840 --> 00:22:30.900
This is essentially an API that
processes outside App

00:22:30.900 --> 00:22:36.670
Engine can use to access
App Engines data store.

00:22:36.670 --> 00:22:39.790
And so this means that as
we're running all this

00:22:39.790 --> 00:22:45.220
analysis on Compute Engine or on
other processes we can tap

00:22:45.220 --> 00:22:49.140
directly into App Engine
app data stores.

00:22:49.140 --> 00:22:51.470
And grab the data directly.

00:22:51.470 --> 00:22:53.290
We don't have to do any
shuttling around.

00:22:53.290 --> 00:22:56.800
We can post the results back
into App Engine's data store.

00:22:56.800 --> 00:23:01.450
And, in fact, we don't
necessarily even really need

00:23:01.450 --> 00:23:02.740
to use App Engine at all.

00:23:02.740 --> 00:23:04.890
Although, of course, we're
using it for this system.

00:23:04.890 --> 00:23:06.760
So this is really cool.

00:23:06.760 --> 00:23:12.560
This makes this kind of analysis
really easy to do.

00:23:12.560 --> 00:23:17.710
And just as a quick example,
let me show you a little

00:23:17.710 --> 00:23:22.750
script I wrote to grab,
this is Python.

00:23:22.750 --> 00:23:25.180
And I don't expect you to look
at it in gory detail.

00:23:25.180 --> 00:23:28.250
But what this script
does is it's

00:23:28.250 --> 00:23:29.780
running in Compute Engine.

00:23:29.780 --> 00:23:32.970
It's grabbing some of our sensor
data that we've been

00:23:32.970 --> 00:23:37.070
storing, directly from
our apps data store.

00:23:37.070 --> 00:23:39.070
It's doing some transformations
on it.

00:23:39.070 --> 00:23:43.400
It's going to create
some CSV files.

00:23:43.400 --> 00:23:46.890
So if you look at this code, I
won't spend too much time on

00:23:46.890 --> 00:23:49.700
it, but anyone who's done a
little bit of App Engine

00:23:49.700 --> 00:23:52.570
programming will recognize
the structure of it.

00:23:52.570 --> 00:23:54.020
It's the same structure
in terms of

00:23:54.020 --> 00:23:55.180
talking to the data store.

00:23:55.180 --> 00:23:56.790
We're formulating a query.

00:23:56.790 --> 00:23:57.990
We're adding some filters.

00:23:57.990 --> 00:24:00.580
We're specifying the order that
we want the results back.

00:24:00.580 --> 00:24:01.920
And then we're submitting
the query.

00:24:01.920 --> 00:24:03.060
It's really fast.

00:24:03.060 --> 00:24:04.760
It works really well.

00:24:04.760 --> 00:24:08.200
And so then we, in this
particular case, with this

00:24:08.200 --> 00:24:11.310
script, we generate
a CSV file.

00:24:11.310 --> 00:24:14.020
And this is just a snippet of
it just to show you the

00:24:14.020 --> 00:24:15.950
structure in this
particular case.

00:24:15.950 --> 00:24:19.470
And once we have something like
this, for example, we can

00:24:19.470 --> 00:24:22.590
run analysis on it using R.

00:24:22.590 --> 00:24:28.370
So this is just one little
example to give you

00:24:28.370 --> 00:24:29.080
the flavor of it.

00:24:29.080 --> 00:24:35.400
In this case, we're looking
for correlations between

00:24:35.400 --> 00:24:38.940
streams of different sensors
on the same mote.

00:24:38.940 --> 00:24:39.960
So one particular mote.

00:24:39.960 --> 00:24:42.710
And we're saying, are we finding
correlations between

00:24:42.710 --> 00:24:45.010
sensor stream A and
sensor stream B.

00:24:45.010 --> 00:24:49.140
And so, for example, in this
case this mote had both

00:24:49.140 --> 00:24:51.010
humidity and temperature
sensors.

00:24:51.010 --> 00:24:55.380
And we're finding that there's a
strong negative correlation,

00:24:55.380 --> 00:24:56.490
apparently.

00:24:56.490 --> 00:24:59.270
I saw this on more than one
mote, between humidity and

00:24:59.270 --> 00:25:00.440
temperature.

00:25:00.440 --> 00:25:03.610
So this kind of thing.

00:25:03.610 --> 00:25:08.150
So to reiterate, this
is really exciting.

00:25:08.150 --> 00:25:14.310
The fact that we can run these
analysis jobs directly from

00:25:14.310 --> 00:25:18.080
Compute Engine tapping into the
Google Cloud data storage.

00:25:18.080 --> 00:25:20.950
This really opened up a whole
new world of analysis.

00:25:20.950 --> 00:25:23.200
And we have lots more that we're
going to do with this.

00:25:23.200 --> 00:25:25.440
KIM CAMERON: So Amy, it sounds
like our apps going really

00:25:25.440 --> 00:25:26.760
well so far.

00:25:26.760 --> 00:25:28.030
How about performance?

00:25:28.030 --> 00:25:29.710
We had to have done some
stuff to make the app

00:25:29.710 --> 00:25:31.450
perform much better.

00:25:31.450 --> 00:25:32.570
What did we do?

00:25:32.570 --> 00:25:35.260
AMY UNRUH: Actually our
app was perfect.

00:25:35.260 --> 00:25:36.840
We didn't have to do
any performance.

00:25:36.840 --> 00:25:38.112
[LAUGHTER]

00:25:38.112 --> 00:25:41.050
AMY UNRUH: You guys know that
can't possibly be the case.

00:25:41.050 --> 00:25:44.110
Yeah, so, in fact, we had to
do a lot of performance

00:25:44.110 --> 00:25:45.210
optimizations.

00:25:45.210 --> 00:25:49.080
So one thing that I won't really
go into here, but was

00:25:49.080 --> 00:25:51.380
really crucial for
it, was caching.

00:25:51.380 --> 00:25:54.810
So we put in a really strong
caching layer.

00:25:54.810 --> 00:25:59.020
And for that we used App
Engine's Memcache service and

00:25:59.020 --> 00:26:00.020
it worked great.

00:26:00.020 --> 00:26:04.140
So that's why our app is running
as smoothly as it is.

00:26:04.140 --> 00:26:06.820
But one thing I wanted to
particularly call out is as

00:26:06.820 --> 00:26:13.720
being kind of an interesting way
of improving performance,

00:26:13.720 --> 00:26:14.850
is something new.

00:26:14.850 --> 00:26:18.180
It's an App Engine feature
called App Engine Servers.

00:26:18.180 --> 00:26:20.120
And it's in limited preview.

00:26:20.120 --> 00:26:23.190
Which means that you have
to sign up to use it.

00:26:23.190 --> 00:26:25.470
So if you're interested in the
resource slide at the end,

00:26:25.470 --> 00:26:27.840
we've put a sign up link.

00:26:27.840 --> 00:26:35.880
So with App Engine servers you
define logical instance

00:26:35.880 --> 00:26:40.580
configurations, essentially
server groups, multiple server

00:26:40.580 --> 00:26:43.060
groups for your App
Engine app.

00:26:43.060 --> 00:26:47.230
And then you can define how
your incoming requests are

00:26:47.230 --> 00:26:52.170
routed to one particular server
group or another.

00:26:52.170 --> 00:26:56.500
So you're essentially
partitioning your app.

00:26:56.500 --> 00:27:00.520
Different classes of request can
get handled by different

00:27:00.520 --> 00:27:01.600
server groups.

00:27:01.600 --> 00:27:05.620
An App Engine is going to
consider the scheduling and

00:27:05.620 --> 00:27:08.880
scaling of each server
group separately.

00:27:08.880 --> 00:27:13.930
So if you, as many apps do, have
incoming requests with

00:27:13.930 --> 00:27:15.700
lots of variability.

00:27:15.700 --> 00:27:17.180
Some really high latency
requests,

00:27:17.180 --> 00:27:19.390
some low latency requests.

00:27:19.390 --> 00:27:20.970
Maybe a lot of number
crunching.

00:27:20.970 --> 00:27:27.150
If you can partition the
handling of hose requests, App

00:27:27.150 --> 00:27:31.560
Engine can manage the app
really efficiently.

00:27:31.560 --> 00:27:35.220
And so in our particular case,
we had three different classes

00:27:35.220 --> 00:27:37.880
of activities that we're
doing in our app.

00:27:37.880 --> 00:27:41.470
So one is the data ingestion
which needs to be really rapid

00:27:41.470 --> 00:27:44.420
and very quick.

00:27:44.420 --> 00:27:49.110
Then we're doing a lot of data
processing of various types,

00:27:49.110 --> 00:27:50.920
all sort of slow, slower

00:27:50.920 --> 00:27:52.440
compared to the data ingestion.

00:27:52.440 --> 00:27:54.850
And then we're handling
the visualization.

00:27:54.850 --> 00:27:57.710
All of the client requests
to see the neat

00:27:57.710 --> 00:27:58.840
stuff that we're building.

00:27:58.840 --> 00:28:02.790
And so we really saw
improvements in our app by

00:28:02.790 --> 00:28:04.880
dividing these different
activities in two different

00:28:04.880 --> 00:28:08.090
server groups.

00:28:08.090 --> 00:28:11.590
KIM CAMERON: So, like with any
software development process,

00:28:11.590 --> 00:28:14.000
we did run some challenges
along the way.

00:28:14.000 --> 00:28:17.580
And I'm going to tell you just
about a few of them right now.

00:28:17.580 --> 00:28:20.470
So, first of all, entering
the mote data.

00:28:20.470 --> 00:28:22.510
We needed the mote data entered
so we could join it

00:28:22.510 --> 00:28:23.870
with our sensor data.

00:28:23.870 --> 00:28:25.730
And then we can move it into
BigQuery, do all the stuff

00:28:25.730 --> 00:28:27.260
we've talked about already.

00:28:27.260 --> 00:28:28.700
So that was a manual process.

00:28:28.700 --> 00:28:32.010
And one challenge is we had to
build an admin panel to help

00:28:32.010 --> 00:28:35.040
the hardware guys move all the
mote data in manually.

00:28:35.040 --> 00:28:38.150
And, of course, humans are not
robots so they make mistakes.

00:28:38.150 --> 00:28:40.780
And so occasionally we had to
deal with issues like there

00:28:40.780 --> 00:28:42.140
would be a mislabeled mote.

00:28:42.140 --> 00:28:44.460
And so then we'd suddenly get
a reading from some strange

00:28:44.460 --> 00:28:46.070
mote we didn't recognize.

00:28:46.070 --> 00:28:48.890
And we had to have a way to
really look for those issues

00:28:48.890 --> 00:28:50.390
and fix them.

00:28:50.390 --> 00:28:53.860
I'd say the biggest challenge
we had was prioritization.

00:28:53.860 --> 00:28:56.430
We started this app only about
a month ago and with very

00:28:56.430 --> 00:28:58.260
limited developer resources.

00:28:58.260 --> 00:29:00.690
So we had to choose carefully
the things we wanted to do to

00:29:00.690 --> 00:29:02.250
build this foundation.

00:29:02.250 --> 00:29:04.160
We had to focus on the
pipeline and the

00:29:04.160 --> 00:29:06.380
visualizations, primarily.

00:29:06.380 --> 00:29:09.410
And really the takeaway from
this is we've just gotten

00:29:09.410 --> 00:29:10.540
started on this.

00:29:10.540 --> 00:29:12.280
We hope that you'll
follow the blog.

00:29:12.280 --> 00:29:15.340
We want to put installations
of this up in the future.

00:29:15.340 --> 00:29:17.360
And we also plan on
open-sourcing this code at

00:29:17.360 --> 00:29:19.432
some point after I/O so you
guys can look at it

00:29:19.432 --> 00:29:20.460
and work on it too.

00:29:20.460 --> 00:29:23.860
As well as having access to
the data set and BigQuery.

00:29:23.860 --> 00:29:27.970
So I guess what I would end with
is, use these patterns.

00:29:27.970 --> 00:29:29.730
Use these practices.

00:29:29.730 --> 00:29:32.100
Go out and build your own
internet of things apps that

00:29:32.100 --> 00:29:34.560
help change the world
and how you see it.

00:29:34.560 --> 00:29:36.750
Just please, for all of
our sakes, do not

00:29:36.750 --> 00:29:39.120
build a robot army.

00:29:39.120 --> 00:29:40.290
Thank you.

00:29:40.290 --> 00:29:48.450
[APPLAUSE]

00:29:48.450 --> 00:29:55.650
KIM CAMERON: So, oops, so we
have time for about 10 minutes

00:29:55.650 --> 00:29:57.040
of questions.

00:29:57.040 --> 00:29:59.780
And we have mics in both of
the aisles for anyone who

00:29:59.780 --> 00:30:01.864
would like to come up and ask.

00:30:05.736 --> 00:30:09.130
I apologize I'm not able
to make the slides big.

00:30:13.930 --> 00:30:14.890
Which side?

00:30:14.890 --> 00:30:15.526
How about you?

00:30:15.526 --> 00:30:18.220
AUDIENCE: Yes.

00:30:18.220 --> 00:30:20.850
I noticed that there were
somewhere around 500 motes out

00:30:20.850 --> 00:30:23.180
on the floor.

00:30:23.180 --> 00:30:26.510
How does this problem change
if you increase that number

00:30:26.510 --> 00:30:29.850
to, for example, let's
say, 5,000 or

00:30:29.850 --> 00:30:32.290
let's say 500,000 motes.

00:30:32.290 --> 00:30:35.110
Or even, let's say 50 million.

00:30:35.110 --> 00:30:36.180
Maybe 50 million is a
little bit too much.

00:30:36.180 --> 00:30:42.540
But a very, very large amount,
for example, in a cable

00:30:42.540 --> 00:30:46.710
network or something where
there's maybe not with motes,

00:30:46.710 --> 00:30:49.440
but with different devices.

00:30:49.440 --> 00:30:53.830
AMY UNRUH: So what we're seeing,
what we're seeing

00:30:53.830 --> 00:30:56.650
right now is that App Engine is
not even really breaking a

00:30:56.650 --> 00:30:58.780
sweat drawing in this data.

00:30:58.780 --> 00:31:01.890
And so we have every reason to
believe that will scale up

00:31:01.890 --> 00:31:04.410
very gracefully to much
larger installations.

00:31:07.450 --> 00:31:07.800
Yeah.

00:31:07.800 --> 00:31:10.980
I couldn't speak to millions
and millions of motes, but

00:31:10.980 --> 00:31:14.430
certainly we could have an order
of magnitude more motes

00:31:14.430 --> 00:31:16.770
and I wouldn't expect
any problem at all.

00:31:16.770 --> 00:31:18.145
AUDIENCE: With the same--

00:31:18.145 --> 00:31:19.395
AMY UNRUH: With the same
configuration.

00:31:22.635 --> 00:31:24.720
AUDIENCE: I actually have a
hardware question for you.

00:31:24.720 --> 00:31:26.970
And I've been looking forward
to this ever since I saw the

00:31:26.970 --> 00:31:28.150
mote sitting around
everywhere.

00:31:28.150 --> 00:31:29.796
No I'm not one of the ones that
took one, although I was

00:31:29.796 --> 00:31:31.530
really tempted, I'll
have to admit.

00:31:31.530 --> 00:31:36.510
But I'm actually working on a
project doing some sensing of

00:31:36.510 --> 00:31:39.150
growing conditions in the
tropical regions.

00:31:39.150 --> 00:31:43.780
And so when I saw XP motes and
you have all the right sensors

00:31:43.780 --> 00:31:44.410
on there and everything.

00:31:44.410 --> 00:31:46.790
So you said those are
custom shields?

00:31:46.790 --> 00:31:48.700
Are they going to be available
somewhere?

00:31:48.700 --> 00:31:52.400
KIM CAMERON: So the fellows
that made the shields,

00:31:52.400 --> 00:31:53.590
actually they're in
the audience here.

00:31:53.590 --> 00:31:56.460
So there around for questions
afterwards as well.

00:31:56.460 --> 00:31:57.820
There's Alasdair right there.

00:31:57.820 --> 00:31:59.170
I don't know if Kipp's here.

00:31:59.170 --> 00:32:01.250
And they are playing an
open sourcing the

00:32:01.250 --> 00:32:02.140
board at some point.

00:32:02.140 --> 00:32:04.640
So you can get more information
about that at

00:32:04.640 --> 00:32:07.980
their website which is
datasensinglab.com.

00:32:07.980 --> 00:32:10.060
Of you can feel free to chat
with Alasdair afterwards.

00:32:10.060 --> 00:32:10.640
AUDIENCE: OK.

00:32:10.640 --> 00:32:12.928
Thanks.

00:32:12.928 --> 00:32:14.870
AUDIENCE: Hello.

00:32:14.870 --> 00:32:17.660
Well I see that you started
with cloud storage then to

00:32:17.660 --> 00:32:23.100
BigQuery then converting those
files to a CSV file to complex

00:32:23.100 --> 00:32:24.970
event processing or something
like that.

00:32:24.970 --> 00:32:28.480
Is there a way to avoid all that
process of porting data

00:32:28.480 --> 00:32:30.470
from one structure to another?

00:32:30.470 --> 00:32:32.350
For example, if I do incremental
updates, probably

00:32:32.350 --> 00:32:33.772
that's going to be a pain.

00:32:33.772 --> 00:32:37.180
KIM CAMERON: Yeah so BigQuery
right now supports two schema.

00:32:37.180 --> 00:32:39.690
So one is CSV format
and one is JSON.

00:32:39.690 --> 00:32:42.210
So I think in the future it
might be great if there were

00:32:42.210 --> 00:32:42.900
more schemas.

00:32:42.900 --> 00:32:45.650
For now it would have to
be one of those two.

00:32:45.650 --> 00:32:48.670
So if you're starting a project
from scratch you could

00:32:48.670 --> 00:32:50.660
think about, well is there a
way I can structure my data

00:32:50.660 --> 00:32:53.380
that way naturally
so it's easier?

00:32:53.380 --> 00:32:54.755
That is a limitation
right now.

00:32:54.755 --> 00:32:56.390
AUDIENCE: Thank you.

00:32:56.390 --> 00:32:59.900
AUDIENCE: I'm curious what the
500 motes you showed in the

00:32:59.900 --> 00:33:02.960
use of mesh networks
how it was at that

00:33:02.960 --> 00:33:05.300
mesh data got collected.

00:33:05.300 --> 00:33:10.971
Was there some point that
brought it onto the internet?

00:33:10.971 --> 00:33:13.460
KIM CAMERON: So I'm not sure
of the answer to that.

00:33:13.460 --> 00:33:15.460
We focus mostly on the
software side.

00:33:15.460 --> 00:33:19.080
And Digi were the masters of
setting up the mesh network.

00:33:19.080 --> 00:33:20.260
So they would be able
to answer that

00:33:20.260 --> 00:33:21.870
question better than me.

00:33:21.870 --> 00:33:24.750
And they will be at the cloud
sandbox later on to help

00:33:24.750 --> 00:33:26.226
answer that question.

00:33:26.226 --> 00:33:28.630
AUDIENCE: Thank you.

00:33:28.630 --> 00:33:31.400
KIM CAMERON: Hi, I have
a simple question.

00:33:31.400 --> 00:33:36.022
How did you decide where to
place each of every sensor?

00:33:36.022 --> 00:33:39.860
AMY UNRUH: Yeah Alasdair could
answer that question.

00:33:39.860 --> 00:33:43.350
He can tell you it was time
consuming and he probably lost

00:33:43.350 --> 00:33:45.540
lots of his hair doing it.

00:33:45.540 --> 00:33:48.160
KIM CAMERON: I think that is one
of the ongoing challenges.

00:33:48.160 --> 00:33:49.850
How do you know how many
motes to put and

00:33:49.850 --> 00:33:50.500
where do you put them.

00:33:50.500 --> 00:33:52.980
And how dense do you
pack them in?

00:33:52.980 --> 00:33:56.380
And these are things that sort
of learning lesson and

00:33:56.380 --> 00:33:58.056
hopefully we improve
in the future.

00:33:58.056 --> 00:34:01.820
AMY UNRUH: But in a sense we
place them knowing ahead of

00:34:01.820 --> 00:34:03.190
time where we thought
interesting things

00:34:03.190 --> 00:34:04.930
would be going on.

00:34:04.930 --> 00:34:08.450
And that was certainly
a part of it.

00:34:08.450 --> 00:34:11.630
AUDIENCE: So with these large
data sets like this, did you

00:34:11.630 --> 00:34:14.960
give any thought to testing
whether the

00:34:14.960 --> 00:34:18.170
results were correct?

00:34:18.170 --> 00:34:23.270
AMY UNRUH: In this sense of
whether we have dirty data,

00:34:23.270 --> 00:34:24.770
missing data?

00:34:24.770 --> 00:34:29.920
AUDIENCE: Your calculations
were incorrect or you had

00:34:29.920 --> 00:34:34.909
somehow overran some of
the data or didn't get

00:34:34.909 --> 00:34:36.639
all that was there.

00:34:36.639 --> 00:34:43.076
Sure there's, there's not
that much at risk.

00:34:43.076 --> 00:34:44.540
AMY UNRUH: It's a really
interesting question.

00:34:44.540 --> 00:34:46.650
There are several levels of
that question, of course.

00:34:46.650 --> 00:34:52.179
And one is just a question of
how well calibrated are the

00:34:52.179 --> 00:34:53.350
motes with each other.

00:34:53.350 --> 00:34:57.470
And we believe that, we haven't
done much of this yet,

00:34:57.470 --> 00:35:00.720
but a lot of the correlation
analysis that we're planning

00:35:00.720 --> 00:35:05.140
on doing should help flesh
that out a little bit.

00:35:05.140 --> 00:35:09.350
And then we anticipate that we
will have gaps in our data.

00:35:09.350 --> 00:35:13.510
For example, motes are going on
and offline all the time.

00:35:13.510 --> 00:35:17.360
Sometimes one of the sensors
on a mote doesn't report.

00:35:17.360 --> 00:35:19.530
Sometimes our motes
get mislabeled.

00:35:19.530 --> 00:35:23.370
And so any analysis we do will
have to deal with that.

00:35:23.370 --> 00:35:26.960
Whether it be to be tolerant
of that, or to

00:35:26.960 --> 00:35:28.260
try to clean it up.

00:35:28.260 --> 00:35:31.820
AUDIENCE: But you're assuming
that once the data is in the

00:35:31.820 --> 00:35:36.390
mote everything else is
going to be correct.

00:35:36.390 --> 00:35:38.605
AMY UNRUH: You mean once we've
collected the data?

00:35:38.605 --> 00:35:39.040
AUDIENCE: Yeah.

00:35:39.040 --> 00:35:40.870
Right.

00:35:40.870 --> 00:35:41.440
AMY UNRUH: No.

00:35:41.440 --> 00:35:45.230
We anticipate doing all sorts
of analysis that requires a

00:35:45.230 --> 00:35:48.210
data cleaning stage
of some sort.

00:35:48.210 --> 00:35:53.310
It really is dirty
data, in a sense.

00:35:53.310 --> 00:35:55.360
There's lots of gaps.

00:35:55.360 --> 00:35:57.760
There's lots of things that
were a bit mislabeled.

00:35:57.760 --> 00:36:01.180
And because we have so much
of it we ought to be able

00:36:01.180 --> 00:36:02.210
to pick that out.

00:36:02.210 --> 00:36:03.186
AUDIENCE: Right.

00:36:03.186 --> 00:36:03.674
OK.

00:36:03.674 --> 00:36:05.626
All right Thank you.

00:36:05.626 --> 00:36:07.256
KIM CAMERON: Hello.

00:36:07.256 --> 00:36:10.690
AUDIENCE: So one of things about
Google I/O, I've been

00:36:10.690 --> 00:36:13.330
coming for a long time and our
Wi-Fi network here has been

00:36:13.330 --> 00:36:14.520
pretty bad.

00:36:14.520 --> 00:36:16.260
And this year, I think,
is about the worst.

00:36:16.260 --> 00:36:19.620
And so how do you know that you
can deploy 500 motes in

00:36:19.620 --> 00:36:23.370
this incredibly challenging
environment without

00:36:23.370 --> 00:36:25.640
exacerbating the problems we
already have with Wi-Fi?

00:36:29.490 --> 00:36:31.080
KIM CAMERON: Yes, let's
get Alasdair up here.

00:36:33.930 --> 00:36:37.260
ALASDAIR: So I think ZigBee mesh
is actually in between

00:36:37.260 --> 00:36:38.440
the Wi-Fi channels.

00:36:38.440 --> 00:36:39.510
AUDIENCE: They're all
2.4 megahertz

00:36:39.510 --> 00:36:41.410
channels, then they overlap.

00:36:41.410 --> 00:36:43.920
ALASDAIR: No, well,
not exactly.

00:36:43.920 --> 00:36:46.690
They're 2.4 gigahertz channels,
but the actual

00:36:46.690 --> 00:36:49.580
ZigBee channels are between
the Wi-Fi channels.

00:36:49.580 --> 00:36:52.280
So they're in that the bottoms
of the Gaussians.

00:36:52.280 --> 00:36:54.220
On top of that, we actually
filtered out some of the

00:36:54.220 --> 00:36:55.830
ZigBee channels that
were overlapping

00:36:55.830 --> 00:36:56.760
with the Wi-Fi channels.

00:36:56.760 --> 00:36:59.990
So we optimized it to
preferentially not interfere

00:36:59.990 --> 00:37:02.430
with the Wi-Fi.

00:37:02.430 --> 00:37:05.450
AUDIENCE: So are you measuring,
the Wi-Fi has been

00:37:05.450 --> 00:37:06.330
really bad this year.

00:37:06.330 --> 00:37:07.170
Are you measuring something--

00:37:07.170 --> 00:37:09.100
ALASDAIR: Well actually I think
the Wi-Fi is really good

00:37:09.100 --> 00:37:10.430
for a conference of the size.

00:37:10.430 --> 00:37:12.540
I've seen much worse.

00:37:12.540 --> 00:37:15.785
But we are actually looking for
packet loss and other sort

00:37:15.785 --> 00:37:17.680
of packet collision
type stuff.

00:37:17.680 --> 00:37:19.280
And we're going to look at
that data and analyze it

00:37:19.280 --> 00:37:21.410
afterwards and see what's
happening, basically.

00:37:21.410 --> 00:37:26.110
But I would lay large amounts
of money that anything to do

00:37:26.110 --> 00:37:29.350
with Wi-Fi is not our network.

00:37:29.350 --> 00:37:29.990
Hand on heart.

00:37:29.990 --> 00:37:30.445
I swear.

00:37:30.445 --> 00:37:30.671
AUDIENCE: OK.

00:37:30.671 --> 00:37:31.355
All right.

00:37:31.355 --> 00:37:33.630
Thanks.

00:37:33.630 --> 00:37:37.330
AUDIENCE: Hi, I know that is a
totally different project, but

00:37:37.330 --> 00:37:40.400
I'd like to know if you have
any comment about HP Sense.

00:37:40.400 --> 00:37:43.892
They have a similar project
about collecting data.

00:37:43.892 --> 00:37:46.200
KIM CAMERON: I'm personally not
familiar with the project.

00:37:46.200 --> 00:37:46.870
Amy are you?

00:37:46.870 --> 00:37:47.740
AMY UNRUH: I'm sorry
what was the name?

00:37:47.740 --> 00:37:49.320
AUDIENCE: HP Sense.

00:37:49.320 --> 00:37:52.060
I mean, the Hewlett Packard,
they have the--

00:37:52.060 --> 00:37:54.760
AMY UNRUH: Yeah.

00:37:54.760 --> 00:37:57.180
I'm only familiar with
it a very high level.

00:37:57.180 --> 00:37:59.880
So I probably can't comment.

00:37:59.880 --> 00:38:04.710
It is certainly has similar
high level goal.

00:38:04.710 --> 00:38:08.560
Although one thing I would add
is because we're cloud

00:38:08.560 --> 00:38:12.700
platform Devereaux, we
particularly wanted to build

00:38:12.700 --> 00:38:15.770
this system on top of the
Google Cloud platform.

00:38:15.770 --> 00:38:17.690
So that was this part of
our motivation for

00:38:17.690 --> 00:38:18.940
doing it how we did.

00:38:22.851 --> 00:38:25.560
AUDIENCE: Will BigQuery data
be available as part of

00:38:25.560 --> 00:38:30.240
samples of the BigQuery, like
other sample tables?

00:38:30.240 --> 00:38:32.910
AMY UNRUH: Yes, we're
making that the

00:38:32.910 --> 00:38:34.210
BigQuery data set public.

00:38:34.210 --> 00:38:35.690
It is already public.

00:38:35.690 --> 00:38:37.365
And if you go to the--

00:38:37.365 --> 00:38:40.030
KIM CAMERON: Yeah, so, and I
apologize for the slide not

00:38:40.030 --> 00:38:41.040
being full screen.

00:38:41.040 --> 00:38:44.350
But if go to the kiosk you can
have access to the website and

00:38:44.350 --> 00:38:46.310
you can even mess around
with it there.

00:38:46.310 --> 00:38:48.500
And there's instructions on
the home page of that they

00:38:48.500 --> 00:38:51.105
tell you where the data set
is, what is called.

00:38:51.105 --> 00:38:52.220
There's a screen shot.

00:38:52.220 --> 00:38:53.890
It's very easy to find.

00:38:53.890 --> 00:38:54.540
You can access it now.

00:38:54.540 --> 00:38:55.260
AUDIENCE: Great, thank you.

00:38:55.260 --> 00:38:58.290
AMY UNRUH: At a later point
we'll open source the code

00:38:58.290 --> 00:38:59.160
that we did.

00:38:59.160 --> 00:39:02.520
That probably is a couple
months down the road.

00:39:02.520 --> 00:39:05.610
AUDIENCE: How did you place all
the mounts on the indoor

00:39:05.610 --> 00:39:06.728
map kind of thing?

00:39:06.728 --> 00:39:10.620
Like how did you position
the locations?

00:39:10.620 --> 00:39:14.945
Are those real-time updating
if the position changes?

00:39:14.945 --> 00:39:16.606
KIM CAMERON: Yeah, so the
question was regarding how do

00:39:16.606 --> 00:39:18.730
we replace the motes
on the map.

00:39:18.730 --> 00:39:21.750
And, correct me if I'm wrong,
Alistair, but I believe that

00:39:21.750 --> 00:39:23.380
they had to do this manually.

00:39:23.380 --> 00:39:25.850
So when they'd place a mote,
they would actually--

00:39:25.850 --> 00:39:27.970
AMY UNRUH: Well I'm not
entirely manually.

00:39:27.970 --> 00:39:31.110
We actually wrote a user
interface to facilitate that

00:39:31.110 --> 00:39:31.890
for them a little bit.

00:39:31.890 --> 00:39:34.090
So in fact, we used
the Maps API.

00:39:34.090 --> 00:39:36.390
And they could drag
motes around.

00:39:36.390 --> 00:39:38.100
And that helped quite a bit.

00:39:38.100 --> 00:39:43.170
But there still was some hand
typing in of some long strings

00:39:43.170 --> 00:39:45.490
of names and things like that.

00:39:45.490 --> 00:39:47.190
AUDIENCE: OK.

00:39:47.190 --> 00:39:48.513
KIM CAMERON: All right,
we have time

00:39:48.513 --> 00:39:49.210
for one more question.

00:39:49.210 --> 00:39:49.570
Yes.

00:39:49.570 --> 00:39:50.480
AUDIENCE: Thank you.

00:39:50.480 --> 00:39:53.690
When you are loading data up to
BigQuery, are you able to

00:39:53.690 --> 00:39:55.620
append to the existing
data sets.

00:39:55.620 --> 00:39:57.372
Do you have to replace them?

00:39:57.372 --> 00:39:59.450
KIM CAMERON: I'm not sure
what we're doing in

00:39:59.450 --> 00:40:00.660
this specific case.

00:40:00.660 --> 00:40:01.740
You can append data.

00:40:01.740 --> 00:40:02.490
AMY UNRUH: We are appending.

00:40:02.490 --> 00:40:04.320
It's just one, big table.

00:40:04.320 --> 00:40:07.190
And by BigQuery standards.

00:40:07.190 --> 00:40:08.460
This is many, many megs.

00:40:08.460 --> 00:40:10.960
By BigQuery standards
it is really not

00:40:10.960 --> 00:40:12.310
breaking a sweat at all.

00:40:12.310 --> 00:40:15.460
This could be many, many
gigabytes and it

00:40:15.460 --> 00:40:16.940
would still be happy.

00:40:16.940 --> 00:40:20.030
So for the entire course of this
conference it's all just

00:40:20.030 --> 00:40:22.550
going into one big table.

00:40:22.550 --> 00:40:23.930
KIM CAMERON: Thank
you, everyone.

