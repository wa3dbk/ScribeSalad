WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:02:35.690
[MUSIC PLAYING]

00:02:35.690 --> 00:02:36.620
RICK VISCOMI: Hello, world.

00:02:36.620 --> 00:02:38.390
Welcome to Google
Developers Live.

00:02:38.390 --> 00:02:40.710
My name is Rick Viscomi, and I'm
going to be presenting on

00:02:40.710 --> 00:02:42.950
waterfall antipatterns.

00:02:42.950 --> 00:02:47.010
So to kick it off, waterfall
antipatterns has to do with

00:02:47.010 --> 00:02:47.880
web performance.

00:02:47.880 --> 00:02:51.810
And measuring web performance
is kind of a tricky subject,

00:02:51.810 --> 00:02:53.600
because it comes in two parts.

00:02:53.600 --> 00:02:57.270
Number one is getting your
company to care about web

00:02:57.270 --> 00:02:57.850
performance.

00:02:57.850 --> 00:03:02.670
And I think we're in the--

00:03:02.670 --> 00:03:04.930
we're lucky, right now,
because companies are

00:03:04.930 --> 00:03:07.160
recognizing that web performance
is directly

00:03:07.160 --> 00:03:10.950
related to all the metrics that
they care about, like

00:03:10.950 --> 00:03:16.740
returning visitors, ad
conversions, things like this.

00:03:16.740 --> 00:03:19.670
When a company decides to care
about web performance, they

00:03:19.670 --> 00:03:23.860
ask their engineers to fire
up a tool and measure the

00:03:23.860 --> 00:03:26.280
performance, so they know
how fast they are.

00:03:26.280 --> 00:03:29.110
And we're lucky to have a
tool called WebPagetest.

00:03:29.110 --> 00:03:33.600
And this tool was created by
Patrick Meenan at AOL, and he

00:03:33.600 --> 00:03:35.460
now works at Google.

00:03:35.460 --> 00:03:39.570
So this is a tool that would
synthetically measure the

00:03:39.570 --> 00:03:41.230
performance of a website.

00:03:41.230 --> 00:03:43.955
And here in red, I've
highlighted some areas that

00:03:43.955 --> 00:03:46.670
you should focus on before you
run your test, to make sure

00:03:46.670 --> 00:03:49.960
that you have all the
information needed to get an

00:03:49.960 --> 00:03:52.960
informed decision about how
your performance is.

00:03:52.960 --> 00:03:54.820
So the first thing I'll point
out is that the number of

00:03:54.820 --> 00:03:56.940
tests to run is set to nine.

00:03:56.940 --> 00:03:59.750
You might notice on the left
it says, up to 10.

00:03:59.750 --> 00:04:02.440
But we've chosen an odd number
here, and I'll show

00:04:02.440 --> 00:04:04.610
you why in a second.

00:04:04.610 --> 00:04:07.950
Also, right below that, Repeat
View is set to both first view

00:04:07.950 --> 00:04:09.620
and repeat view.

00:04:09.620 --> 00:04:13.030
And this is so that we can hit
the page once with a clear

00:04:13.030 --> 00:04:17.140
cache, and then hit it again
just to see how well we are

00:04:17.140 --> 00:04:19.110
caching our resources.

00:04:19.110 --> 00:04:21.060
And up and to the right, we
see that the Video tab is

00:04:21.060 --> 00:04:22.510
highlighted.

00:04:22.510 --> 00:04:25.320
Capturing video is important
so that we can get what's

00:04:25.320 --> 00:04:28.360
known as perceived performance
metrics.

00:04:28.360 --> 00:04:31.690
Capturing a video is basically
taking snapshots every tenth

00:04:31.690 --> 00:04:33.390
of a second of the web page.

00:04:33.390 --> 00:04:38.730
And using these snapshots, we
could see just like a live

00:04:38.730 --> 00:04:41.610
playback of how the
page is loading.

00:04:41.610 --> 00:04:45.650
And this could tell us the
sequencing of where things are

00:04:45.650 --> 00:04:49.700
loading in on the page, and how
quickly that compares to

00:04:49.700 --> 00:04:53.670
other websites and other test
runs of the same page.

00:04:53.670 --> 00:04:57.540
So one thing to note is that I
mentioned that WebPagetest is

00:04:57.540 --> 00:04:59.520
a synthetic tool.

00:04:59.520 --> 00:05:02.530
There are two categories of
performance monitoring and

00:05:02.530 --> 00:05:04.860
measurement, and that's
RUM, Real User

00:05:04.860 --> 00:05:07.400
Monitoring, and synthetic.

00:05:07.400 --> 00:05:09.990
Real user monitoring measures
the performance experience of

00:05:09.990 --> 00:05:12.240
the actual users
of a web page.

00:05:12.240 --> 00:05:14.240
There's lots of variability
here.

00:05:14.240 --> 00:05:16.570
Users are coming from all
around the world.

00:05:16.570 --> 00:05:19.520
Many different browsers, many
different connection speeds.

00:05:19.520 --> 00:05:22.710
And they basically count for
many, if not all of the edge

00:05:22.710 --> 00:05:26.130
cases of how many people could
be hitting your site, and

00:05:26.130 --> 00:05:27.750
under what conditions.

00:05:27.750 --> 00:05:29.650
Synthetic testing is
almost like clean

00:05:29.650 --> 00:05:31.680
room laboratory testing.

00:05:31.680 --> 00:05:34.780
As you can see, WebPagetest lets
you control almost all

00:05:34.780 --> 00:05:36.580
the variables, the connection
speed, the

00:05:36.580 --> 00:05:38.550
location, the browser.

00:05:38.550 --> 00:05:42.160
And there's very little
variation between the tests,

00:05:42.160 --> 00:05:44.620
if you want it to be so.

00:05:44.620 --> 00:05:46.930
So they sort of answer two
different questions.

00:05:46.930 --> 00:05:50.280
With RUM, it's answering the
question, how fast is my page?

00:05:50.280 --> 00:05:53.130
And for synthetic, it's
answering the question, how

00:05:53.130 --> 00:05:54.870
can I make my page faster?

00:05:54.870 --> 00:05:57.570
And so today, we're going to
focus on synthetic, and how we

00:05:57.570 --> 00:06:00.540
can use WebPagetest, and
specifically, waterfall chart

00:06:00.540 --> 00:06:03.890
to make our pages faster.

00:06:03.890 --> 00:06:08.780
So I mentioned that nine runs
is better than 10 runs.

00:06:08.780 --> 00:06:12.110
And I'll explain that with a
little bit of mathematics.

00:06:12.110 --> 00:06:15.340
So when you have nine runs,
it's an odd number.

00:06:15.340 --> 00:06:18.070
And so when you take the median
of nine runs, you're

00:06:18.070 --> 00:06:21.460
left with the fifth
one in the series.

00:06:21.460 --> 00:06:24.280
As opposed to 10 runs, you're
left with five and six in the

00:06:24.280 --> 00:06:26.770
middle, and you're left with
some sort of decision about

00:06:26.770 --> 00:06:27.570
which one to take.

00:06:27.570 --> 00:06:30.230
So when you have nine runs,
you're always going to have

00:06:30.230 --> 00:06:33.580
one test run to pick, and
there's no ambiguity.

00:06:33.580 --> 00:06:38.520
So that's just a demonstration
of nine versus 10, and nine is

00:06:38.520 --> 00:06:39.770
recommended.

00:06:41.840 --> 00:06:44.110
So moving on, this is the
waterfall that you'll actually

00:06:44.110 --> 00:06:46.110
see when you run a test.

00:06:46.110 --> 00:06:50.000
And it's shrunken down here, to
give us a high level view

00:06:50.000 --> 00:06:52.080
of what's going on.

00:06:52.080 --> 00:06:57.080
When we run our test, and we see
this waterfall, at first

00:06:57.080 --> 00:06:59.820
we're sort of wondering,
what is going on here?

00:06:59.820 --> 00:07:03.480
We're wondering, what are
we supposed to look for?

00:07:03.480 --> 00:07:05.500
You might notice, oh, at the
top of the page, it says it

00:07:05.500 --> 00:07:06.790
ran in 15 seconds.

00:07:06.790 --> 00:07:07.490
That's great.

00:07:07.490 --> 00:07:08.230
We have a number.

00:07:08.230 --> 00:07:12.600
But what does that number
actually mean, and what can we

00:07:12.600 --> 00:07:14.530
derive from that 15 seconds?

00:07:14.530 --> 00:07:19.890
The truth is that 15 seconds
is one particular load time

00:07:19.890 --> 00:07:21.330
for this one particular test.

00:07:21.330 --> 00:07:23.460
It's not representative
of all your users.

00:07:23.460 --> 00:07:26.680
That's the difference between
RUM and synthetic.

00:07:26.680 --> 00:07:30.230
And the other thing to note is
that this specific test felt

00:07:30.230 --> 00:07:32.860
like 15 seconds, but when I
loaded on my own, in my own

00:07:32.860 --> 00:07:35.110
browser, it feels like
three seconds.

00:07:35.110 --> 00:07:38.160
So that difference has to
do with this clean room

00:07:38.160 --> 00:07:40.400
laboratory testing environment
on WebPagetest.

00:07:40.400 --> 00:07:45.370
It clears all the caches, and
in your own private browser,

00:07:45.370 --> 00:07:47.550
it contains a lot of information
about your

00:07:47.550 --> 00:07:48.950
previous history.

00:07:48.950 --> 00:07:51.610
So something to note here
is that time is not very

00:07:51.610 --> 00:07:53.800
important, which might
sound strange.

00:07:53.800 --> 00:07:55.400
But time is not very important,
because it's not

00:07:55.400 --> 00:07:57.790
representative of
all your users.

00:07:57.790 --> 00:07:59.760
Time is important when you
compare it against other

00:07:59.760 --> 00:08:03.250
WebPagetest results.

00:08:03.250 --> 00:08:07.510
Also, timing could also be
thrown off by anomalies over

00:08:07.510 --> 00:08:08.110
the network.

00:08:08.110 --> 00:08:10.970
And this is why we run nine
tests, so that you can choose

00:08:10.970 --> 00:08:14.345
a median run that will sort of
smooth over the differences.

00:08:17.330 --> 00:08:21.140
So when we look at a waterfall
from this high level, one

00:08:21.140 --> 00:08:23.840
technique that I've learned to
use is by looking at something

00:08:23.840 --> 00:08:25.570
called waterfall slope.

00:08:25.570 --> 00:08:27.680
And slope is the rate at
which requests are

00:08:27.680 --> 00:08:29.200
being made over time.

00:08:29.200 --> 00:08:32.669
So we have the requests running
down the page from top

00:08:32.669 --> 00:08:36.280
to bottom, and from left to
right is the time axis,

00:08:36.280 --> 00:08:38.260
starting at 0 in the top left.

00:08:38.260 --> 00:08:42.159
And so what we want to see
is a vertical line

00:08:42.159 --> 00:08:43.190
going straight down.

00:08:43.190 --> 00:08:45.770
Think of this like Niagara
Falls, just flowing straight

00:08:45.770 --> 00:08:47.240
down, quickly.

00:08:47.240 --> 00:08:49.750
So that means that we're doing
more in less time.

00:08:49.750 --> 00:08:53.550
We are able to get more requests
out in a shorter

00:08:53.550 --> 00:08:54.750
amount of time.

00:08:54.750 --> 00:08:57.510
These horizontal lines, like
the one second to last, is

00:08:57.510 --> 00:08:58.320
pretty bad.

00:08:58.320 --> 00:09:01.540
That means that we're doing
less in more time.

00:09:01.540 --> 00:09:04.720
This is an indicator that we
could be more efficiently

00:09:04.720 --> 00:09:11.530
using our bandwidth to get more
content over the network.

00:09:11.530 --> 00:09:13.750
So waterfall slope isn't really
something that's talked

00:09:13.750 --> 00:09:16.040
about a lot.

00:09:16.040 --> 00:09:19.770
And what I really like about
slope is that it's something

00:09:19.770 --> 00:09:21.580
that could be quantified.

00:09:21.580 --> 00:09:25.890
You could measure the slope of
a waterfall, and compare it

00:09:25.890 --> 00:09:27.050
against other pages.

00:09:27.050 --> 00:09:29.910
So this is one way to
quantitatively compare

00:09:29.910 --> 00:09:33.270
waterfalls, other than the
standard way of just

00:09:33.270 --> 00:09:35.470
qualitatively looking at them
side by side and wondering

00:09:35.470 --> 00:09:37.700
what's different.

00:09:37.700 --> 00:09:41.560
So these horizontal lines can
be made up of all of these

00:09:41.560 --> 00:09:42.490
little antipatterns.

00:09:42.490 --> 00:09:45.920
And these arrows are showing
you each antipattern.

00:09:45.920 --> 00:09:47.775
And right now, it looks
like a mess.

00:09:47.775 --> 00:09:49.090
They're sort of scattered
around.

00:09:49.090 --> 00:09:51.940
And they are, there's
a lot going on here.

00:09:51.940 --> 00:09:54.230
And hopefully, at the end of
this talk, you'll be able to

00:09:54.230 --> 00:09:57.180
spot them and pick them out.

00:09:57.180 --> 00:10:00.270
So this is the high level
view of a waterfall.

00:10:00.270 --> 00:10:03.610
Let's dig down and look at
the anatomy of a request.

00:10:03.610 --> 00:10:06.390
And starting all the way at the
left, we see that there's

00:10:06.390 --> 00:10:07.530
a little padlock icon.

00:10:07.530 --> 00:10:09.850
And this is to show us that
this is a secure request.

00:10:09.850 --> 00:10:12.170
Not all requests are secure.

00:10:12.170 --> 00:10:15.410
And it usually will go along
with this purple

00:10:15.410 --> 00:10:17.080
bar towards the right.

00:10:17.080 --> 00:10:19.470
So if you see a padlock, that's
indicating that the

00:10:19.470 --> 00:10:22.700
request was made over SSL.

00:10:22.700 --> 00:10:23.790
Next is the number two.

00:10:23.790 --> 00:10:26.310
This is to indicate that this
was the second request to

00:10:26.310 --> 00:10:31.090
occur, followed by a center
truncated domain name and

00:10:31.090 --> 00:10:32.630
resource name.

00:10:32.630 --> 00:10:35.510
So we see that the domain here
is fb static, and the

00:10:35.510 --> 00:10:39.250
resources is a bunch of numbers
and letters .css.

00:10:39.250 --> 00:10:42.480
This is helpful, just at a
glance, to see what type of

00:10:42.480 --> 00:10:47.270
request this is, and for
what resource it is.

00:10:47.270 --> 00:10:52.710
The next thing is a solid black
line, followed by some

00:10:52.710 --> 00:10:53.380
gray lines.

00:10:53.380 --> 00:10:57.020
And the spacing between that
solid black line and the first

00:10:57.020 --> 00:10:59.670
colored bar is what's known
as the start offset.

00:10:59.670 --> 00:11:03.300
This is the amount of time that
has passed since the page

00:11:03.300 --> 00:11:06.700
has started to load to the
time that the request was

00:11:06.700 --> 00:11:08.690
first made.

00:11:08.690 --> 00:11:12.620
And we come now to the DNS
lookup, that teal bar, which

00:11:12.620 --> 00:11:17.000
is basically the resolution
of example.com to its

00:11:17.000 --> 00:11:20.180
machine-readable IP address.

00:11:20.180 --> 00:11:22.950
DNS lookup looks short
and innocent here.

00:11:22.950 --> 00:11:28.600
But it could actually trip you
up, in that if example.com is

00:11:28.600 --> 00:11:33.490
trying to be resolved to its
IP, there could be a server

00:11:33.490 --> 00:11:34.890
that doesn't know
the IP address.

00:11:34.890 --> 00:11:36.780
And that server has to
ask another server

00:11:36.780 --> 00:11:38.180
later on in the chain.

00:11:38.180 --> 00:11:44.060
And so this lookup chain can
be unpredictably long.

00:11:44.060 --> 00:11:48.220
And so a best practice is to
always minimize the number of

00:11:48.220 --> 00:11:52.290
unique domains that you use,
to minimize this penalty of

00:11:52.290 --> 00:11:53.510
DNS lookup.

00:11:53.510 --> 00:11:56.560
Although it looks short
and fast here, that's

00:11:56.560 --> 00:11:59.200
not always the case.

00:11:59.200 --> 00:12:00.920
Moving on to initial
connection, this

00:12:00.920 --> 00:12:02.400
is the orange bar.

00:12:02.400 --> 00:12:05.190
And initial connection
is the TCP setup.

00:12:05.190 --> 00:12:09.310
And after you've established
your connection, after you've

00:12:09.310 --> 00:12:13.400
established the address of the
server, the client or the

00:12:13.400 --> 00:12:15.370
browser needs to establish
a connection.

00:12:15.370 --> 00:12:20.610
And this also looks short and
fast, but it might not always

00:12:20.610 --> 00:12:22.310
be the case.

00:12:22.310 --> 00:12:24.540
There's a thing called
TCP slow start.

00:12:24.540 --> 00:12:28.600
So not every connection
will be as fast.

00:12:28.600 --> 00:12:31.020
And this also is incurred
every time that a new

00:12:31.020 --> 00:12:32.550
connection needs to be opened.

00:12:32.550 --> 00:12:34.760
There's a technique that we'll
see later to reuse

00:12:34.760 --> 00:12:37.170
connections.

00:12:37.170 --> 00:12:38.600
Next is SSL negotiation.

00:12:38.600 --> 00:12:41.760
Again, this goes hand in hand
with that padlock icon.

00:12:41.760 --> 00:12:45.670
And SSL negotiation is
ensuring that you can

00:12:45.670 --> 00:12:47.610
communicate securely
with the server.

00:12:47.610 --> 00:12:51.850
So just a back step, we've
established the address of the

00:12:51.850 --> 00:12:53.880
server, we've made a connection
to that server, and

00:12:53.880 --> 00:12:56.480
now client and server are
going to come up with an

00:12:56.480 --> 00:12:59.590
agreement about a secure channel
of communication.

00:12:59.590 --> 00:13:03.590
And all of this is happening
before the server has even

00:13:03.590 --> 00:13:05.960
done anything with what we're
trying to request.

00:13:05.960 --> 00:13:08.960
None of this so far has had
anything to do with CSS.

00:13:08.960 --> 00:13:12.030
And so that's what TTFB, or
Time To First Byte, does.

00:13:12.030 --> 00:13:15.700
So the server finally receives
those request headers for the

00:13:15.700 --> 00:13:19.460
CSS resource, and it does some
back end processing to get

00:13:19.460 --> 00:13:22.040
that ready for delivery.

00:13:22.040 --> 00:13:24.660
And the width of this green
bar is showing you the

00:13:24.660 --> 00:13:27.460
duration of time that
the server takes to

00:13:27.460 --> 00:13:29.200
process this request.

00:13:29.200 --> 00:13:32.160
And as with every bar that we're
going to see here, it

00:13:32.160 --> 00:13:35.280
should be as small
as possible.

00:13:35.280 --> 00:13:37.390
Moving on, this blue content
download bar is

00:13:37.390 --> 00:13:40.470
showing us the time.

00:13:40.470 --> 00:13:43.790
The leftmost line on this blue
chart, this blue bar, is

00:13:43.790 --> 00:13:47.290
showing you the time that the
server has started to send

00:13:47.290 --> 00:13:49.240
some information back
to the browser.

00:13:49.240 --> 00:13:51.800
And the width is time it
takes to load all of

00:13:51.800 --> 00:13:53.570
the information back.

00:13:53.570 --> 00:13:56.220
And of course, we want this to
be as small as possible.

00:13:56.220 --> 00:14:01.370
So we could try to minimize the
size of the CSS resource,

00:14:01.370 --> 00:14:06.450
to ensure that it's sent more
quickly, or we could have our

00:14:06.450 --> 00:14:08.950
user on a faster network, so you
can send more information

00:14:08.950 --> 00:14:11.540
in less time.

00:14:11.540 --> 00:14:12.540
We can't control that.

00:14:12.540 --> 00:14:17.220
But what we can control is
the size of the resource.

00:14:17.220 --> 00:14:21.150
The last thing here is the
number 1,247 ms. This is

00:14:21.150 --> 00:14:23.790
basically one and a
quarter second to

00:14:23.790 --> 00:14:25.490
process the entire request.

00:14:25.490 --> 00:14:28.670
And that's the leftmost edge
of the teal bar to the

00:14:28.670 --> 00:14:31.560
rightmost edge of
that blue bar.

00:14:31.560 --> 00:14:36.040
Some other things of importance
to note is that

00:14:36.040 --> 00:14:37.710
some colors might be missing.

00:14:37.710 --> 00:14:40.760
You're not always loading
things over SSL.

00:14:40.760 --> 00:14:45.340
You're not always setting
up that TCP connection.

00:14:45.340 --> 00:14:47.190
And the other thing is that it's
not always contiguous.

00:14:47.190 --> 00:14:49.990
Here, you see all colors
next to each other.

00:14:49.990 --> 00:14:53.070
But you might see DNS lookup
and initial connection

00:14:53.070 --> 00:14:55.660
separated from time to first
byte and content download.

00:14:55.660 --> 00:14:57.000
It looks a little strange
at first.

00:14:57.000 --> 00:14:58.530
You might wonder if
something broke.

00:14:58.530 --> 00:14:59.290
It's totally OK.

00:14:59.290 --> 00:15:00.890
It's actually a good thing.

00:15:00.890 --> 00:15:02.970
This means that you're
pre-fetching, or

00:15:02.970 --> 00:15:06.470
pre-connecting to the server.

00:15:06.470 --> 00:15:09.960
This is more typical in newer
browsers, and it's something

00:15:09.960 --> 00:15:15.820
that you can control using HTML
meta tags in the head.

00:15:18.800 --> 00:15:22.150
OK, so for every request,
there is a response.

00:15:22.150 --> 00:15:27.080
And sometimes, those responses
are to say that what you

00:15:27.080 --> 00:15:29.160
wanted was not actually in
the location at which you

00:15:29.160 --> 00:15:30.500
requested it.

00:15:30.500 --> 00:15:34.090
And in this example,
we're loading

00:15:34.090 --> 00:15:37.500
facebook.com over HTTP.

00:15:37.500 --> 00:15:41.120
And facebook.com has
a 302 redirect.

00:15:41.120 --> 00:15:43.840
302 is found.

00:15:43.840 --> 00:15:46.010
Found is basically saying,
it moved temporarily.

00:15:46.010 --> 00:15:49.370
You can continue to use
this resource URI.

00:15:49.370 --> 00:15:52.800
And after facebook.com
redirects to https

00:15:52.800 --> 00:15:57.190
facebook.com, it does another
TCP connection.

00:15:57.190 --> 00:15:59.790
It does SSL negotiation now,
because we're on a secure

00:15:59.790 --> 00:16:03.200
request, and then there's some
time to first byte back end

00:16:03.200 --> 00:16:04.750
processing time.

00:16:04.750 --> 00:16:08.550
And finally, after one and a
half seconds, it does a 301

00:16:08.550 --> 00:16:12.410
Moved Permanently redirect to
https://www.facebook.com.

00:16:12.410 --> 00:16:14.290
I'm not trying to pick
on Facebook.

00:16:14.290 --> 00:16:17.870
This is just a really good
example of redirects, and the

00:16:17.870 --> 00:16:19.340
penalty it can incur.

00:16:19.340 --> 00:16:22.670
So we see that, after all is
said and done, the start

00:16:22.670 --> 00:16:27.910
offset for the third request
is about two seconds.

00:16:27.910 --> 00:16:31.550
So is Facebook wrong to do
this type of redirect?

00:16:31.550 --> 00:16:31.900
No.

00:16:31.900 --> 00:16:34.030
This is probably a deliberate
move to funnel

00:16:34.030 --> 00:16:37.380
people to https www.

00:16:37.380 --> 00:16:41.230
And in fact, this screen shot
was taken a few months ago,

00:16:41.230 --> 00:16:45.820
and they've since improved it so
that request one does a 301

00:16:45.820 --> 00:16:48.290
directly to request three,
which is very good.

00:16:48.290 --> 00:16:51.460
And so in that case, instead
of loading at two seconds,

00:16:51.460 --> 00:16:53.740
request three, in theory, should
load at half a second,

00:16:53.740 --> 00:16:56.220
which is a great improvement.

00:16:56.220 --> 00:16:59.550
And that 301 Moved Permanently,
just as a side

00:16:59.550 --> 00:17:04.160
note, is just saying that you
should cache this redirect,

00:17:04.160 --> 00:17:06.310
because you should not
make this request

00:17:06.310 --> 00:17:07.079
again in the future.

00:17:07.079 --> 00:17:11.430
So as long as that's in cache,
hitting facebook.com over http

00:17:11.430 --> 00:17:16.260
should redirect on the client
side to https www.

00:17:16.260 --> 00:17:20.280
And that's an efficiency
on the client side.

00:17:20.280 --> 00:17:20.730
Moving on.

00:17:20.730 --> 00:17:23.030
Some other types of responses
have to do

00:17:23.030 --> 00:17:24.730
with caching, again.

00:17:24.730 --> 00:17:27.050
In this case, we're looking
at Not Modified.

00:17:27.050 --> 00:17:28.400
And this is made on what's
known as the

00:17:28.400 --> 00:17:30.130
Conditional GET request.

00:17:30.130 --> 00:17:34.320
This happens when there's some
information that the client

00:17:34.320 --> 00:17:37.110
knows about the resource, but it
doesn't know if it's still

00:17:37.110 --> 00:17:39.010
fresh, or if it should
continue to

00:17:39.010 --> 00:17:40.680
use it from the cache.

00:17:40.680 --> 00:17:46.090
And so this is typically done
when the resource is missing,

00:17:46.090 --> 00:17:49.120
and expires, or a cache-control
max-age header.

00:17:49.120 --> 00:17:52.730
And these headers tell the
client to keep the resource in

00:17:52.730 --> 00:17:55.900
cache for a certain
amount of time.

00:17:55.900 --> 00:17:58.780
And when the client lacks
this information, it

00:17:58.780 --> 00:17:59.750
has to ask the server.

00:17:59.750 --> 00:18:05.010
And so we see in the chart to
the left the time to first

00:18:05.010 --> 00:18:07.530
byte, but no blue content
download.

00:18:07.530 --> 00:18:10.040
So there is no content download
because the 304

00:18:10.040 --> 00:18:13.200
response is telling the client
to continue to use

00:18:13.200 --> 00:18:14.940
what it has in cache.

00:18:14.940 --> 00:18:16.170
Caching is a great thing.

00:18:16.170 --> 00:18:18.520
It should continue to be used.

00:18:18.520 --> 00:18:22.080
But so why could this be
a bad antipattern?

00:18:22.080 --> 00:18:26.800
So if the client has it in
cache, it should continue to

00:18:26.800 --> 00:18:30.540
use it in cache, and it should
know how long it's fresh.

00:18:30.540 --> 00:18:31.990
When it doesn't have that
information, it

00:18:31.990 --> 00:18:33.760
has to ask the server.

00:18:33.760 --> 00:18:37.900
And so when it's all said and
done, these green lines add

00:18:37.900 --> 00:18:40.600
up, and it comes out to
be about 10 seconds.

00:18:40.600 --> 00:18:43.350
So instead of instantly using
what it has in cache, it has

00:18:43.350 --> 00:18:46.200
to wait another 10 seconds.

00:18:46.200 --> 00:18:49.330
And there's a lot
going on here.

00:18:49.330 --> 00:18:52.490
There are many, many requests
having to be made.

00:18:52.490 --> 00:18:55.450
So what we can do in this second
bullet point is to say

00:18:55.450 --> 00:18:58.180
that we should cache static
content with a long TTL, or

00:18:58.180 --> 00:19:00.500
Time To Live.

00:19:00.500 --> 00:19:03.970
But we could do that with a
cache-control max-age header.

00:19:03.970 --> 00:19:05.310
And this pretty big number.

00:19:05.310 --> 00:19:10.860
31,536, is the number of
seconds in a year.

00:19:10.860 --> 00:19:17.220
So one year is the longest
time to indicate that a

00:19:17.220 --> 00:19:20.090
resource should be cached
indefinitely.

00:19:20.090 --> 00:19:23.390
In theory, you could say, I want
this to be cached for 10

00:19:23.390 --> 00:19:24.040
years, or something.

00:19:24.040 --> 00:19:27.770
But that actually violates
the written spec.

00:19:27.770 --> 00:19:30.980
So when cache-control is used
in conjunction with

00:19:30.980 --> 00:19:33.520
last-modified, we have two
bits of information.

00:19:33.520 --> 00:19:37.120
We know the last time that this
resource was touched, and

00:19:37.120 --> 00:19:38.730
that happens to be
today's date.

00:19:38.730 --> 00:19:41.560
And we know that it should
continue to be served from

00:19:41.560 --> 00:19:43.680
cache for the next year.

00:19:43.680 --> 00:19:47.020
And some people sort of get
nervous when they see this

00:19:47.020 --> 00:19:50.560
type of information being sent
to the client, because they

00:19:50.560 --> 00:19:54.030
might think, well, if it's going
to be cached for a year,

00:19:54.030 --> 00:19:56.260
what if I want to make
a change tomorrow?

00:19:56.260 --> 00:19:59.390
And how will I ensure that they
don't just have the old,

00:19:59.390 --> 00:20:00.240
outdated information?

00:20:00.240 --> 00:20:03.570
This could be serious, if you're
serving, like making a

00:20:03.570 --> 00:20:04.410
security patch.

00:20:04.410 --> 00:20:08.130
So there's a technique known
as cache-busting.

00:20:08.130 --> 00:20:10.450
And there are a couple
ways to do it.

00:20:10.450 --> 00:20:13.360
One is to append a query string
parameter at the end of

00:20:13.360 --> 00:20:14.400
the resource.

00:20:14.400 --> 00:20:17.593
And the other suggested way
here is to just change the

00:20:17.593 --> 00:20:19.330
file name itself.

00:20:19.330 --> 00:20:23.730
In this example, instead of
serving style.css, we have

00:20:23.730 --> 00:20:26.110
style underscore and then
some date stamp.

00:20:26.110 --> 00:20:29.650
And we can change that date
stamp to whatever we want.

00:20:29.650 --> 00:20:33.600
Most commonly, it's the date
that the file was modified.

00:20:33.600 --> 00:20:37.750
And so tomorrow, we might
set this to 2013 06 14.

00:20:37.750 --> 00:20:41.200
And so what happens when
there is a new

00:20:41.200 --> 00:20:44.070
resource being requested?

00:20:44.070 --> 00:20:45.850
It totally ignores
what's in cache.

00:20:45.850 --> 00:20:50.170
So if the cache is full, it
might see this new resource

00:20:50.170 --> 00:20:53.940
being come in, and then eject
the old one, thus making room

00:20:53.940 --> 00:20:55.910
for this new resource.

00:20:55.910 --> 00:20:57.730
So caching is very important.

00:20:57.730 --> 00:21:00.910
It's said, sometimes, that the
fastest request is the one you

00:21:00.910 --> 00:21:02.530
never even have to make
in the first place.

00:21:02.530 --> 00:21:06.550
So by leveraging caching, and
doing so effectively, you're

00:21:06.550 --> 00:21:09.640
tremendously speeding up the
client-side experience on

00:21:09.640 --> 00:21:12.080
subsequent repeat views.

00:21:12.080 --> 00:21:15.690
Caching does not help them so
much when they're hitting your

00:21:15.690 --> 00:21:16.940
website for the first time.

00:21:19.300 --> 00:21:21.300
So the other type of response
is an error.

00:21:21.300 --> 00:21:24.390
And I think we're all familiar
with what a 404 Not Found

00:21:24.390 --> 00:21:26.070
error message is.

00:21:26.070 --> 00:21:27.260
So I won't spend a
lot of time here.

00:21:27.260 --> 00:21:34.700
But this waterfall gives us an
opportunity to sort of think

00:21:34.700 --> 00:21:36.700
about what might have
gone wrong here.

00:21:36.700 --> 00:21:41.380
It's interesting, 45, 46, and
47, are for resources named

00:21:41.380 --> 00:21:45.420
menu two, three, and four, and
48 through 50 are for an

00:21:45.420 --> 00:21:47.940
undefined resource.

00:21:47.940 --> 00:21:50.360
So we might wonder what
happened here.

00:21:50.360 --> 00:21:54.880
And I laugh, because in my
mind, when I saw this

00:21:54.880 --> 00:21:56.670
waterfall, I thought maybe
they were in some type of

00:21:56.670 --> 00:22:00.020
JavaScript loop, and they ran
outside the edge of their

00:22:00.020 --> 00:22:03.170
array, and they had no more
resources to fetch.

00:22:03.170 --> 00:22:07.260
So it's sort of funny to see it
like this, but it is a bad

00:22:07.260 --> 00:22:10.030
pattern, because it's holding
up everything after it.

00:22:10.030 --> 00:22:11.960
We can see the delay
that this incurs.

00:22:11.960 --> 00:22:13.810
It takes half a second
each, with

00:22:13.810 --> 00:22:15.430
maybe a second in between.

00:22:15.430 --> 00:22:18.500
These gray lines, these gray
vertical lines, are probably

00:22:18.500 --> 00:22:20.350
one second indicators.

00:22:20.350 --> 00:22:25.600
And so requests 51 and below
are being held up by these

00:22:25.600 --> 00:22:27.750
404-ing responses.

00:22:27.750 --> 00:22:31.890
So it's important to spot
these red lines.

00:22:31.890 --> 00:22:34.560
That's why they stand out so
much in your waterfall.

00:22:34.560 --> 00:22:36.730
And take care of that as
soon as you could.

00:22:39.630 --> 00:22:44.480
The other type of response or
message you might see in a

00:22:44.480 --> 00:22:47.490
waterfall is for request
cancelled.

00:22:47.490 --> 00:22:50.150
And this is kind of a strange
thing, because it says it

00:22:50.150 --> 00:22:51.480
takes 0 milliseconds.

00:22:51.480 --> 00:22:55.060
And we're trained to think that
the smaller the duration

00:22:55.060 --> 00:22:58.550
the better, but 0 is actually
not all that good.

00:22:58.550 --> 00:22:59.960
This is a strange waterfall.

00:22:59.960 --> 00:23:05.480
This was actually created on
the fly using the waterfall

00:23:05.480 --> 00:23:07.960
customization feature
of WebPagetest.

00:23:07.960 --> 00:23:11.210
And so note that the request
numbers are out of

00:23:11.210 --> 00:23:12.460
order on the left.

00:23:12.460 --> 00:23:18.280
And so it goes from 51, 2 and
3, to 84, 86, and 87.

00:23:18.280 --> 00:23:22.280
And request 51 was made
at about three

00:23:22.280 --> 00:23:23.830
and a quarter seconds.

00:23:23.830 --> 00:23:29.020
And looking closely, request 84
happens a couple of seconds

00:23:29.020 --> 00:23:31.080
later for the same
exact resource.

00:23:31.080 --> 00:23:34.870
It's kind of hard to tell, but
these are all three different

00:23:34.870 --> 00:23:36.230
image formats.

00:23:36.230 --> 00:23:41.870
So the gif image was requested
at 51, and again on 84.

00:23:41.870 --> 00:23:44.970
And this is the same resource,
being requested twice.

00:23:44.970 --> 00:23:47.470
And the thing that's strange,
you might look at your code

00:23:47.470 --> 00:23:49.650
and try to assure yourself,
well, I'm

00:23:49.650 --> 00:23:50.450
only calling it once.

00:23:50.450 --> 00:23:53.850
Why is it showing up twice
in the waterfall?

00:23:53.850 --> 00:23:56.770
So the reason why is that it's
being canceled the first time.

00:23:56.770 --> 00:24:00.940
It attempted to load this
resource at an earlier time,

00:24:00.940 --> 00:24:03.730
and it failed for some reason,
and then it tried again, this

00:24:03.730 --> 00:24:05.740
time successfully, later on.

00:24:05.740 --> 00:24:11.490
And the second half of the
slide is showing you the

00:24:11.490 --> 00:24:12.660
reason why this happens.

00:24:12.660 --> 00:24:15.820
And it occurs because of
something known as the

00:24:15.820 --> 00:24:20.060
lookahead pre-parser, where it
tries to look ahead in your

00:24:20.060 --> 00:24:23.590
code, and guess what you're
going to need next.

00:24:23.590 --> 00:24:25.890
And it will try to load that as
early as possible for it,

00:24:25.890 --> 00:24:28.630
which is a great feature.

00:24:28.630 --> 00:24:31.440
Although, there are some things
you could do in your

00:24:31.440 --> 00:24:35.090
code to trip it up and cause
it to not work so well.

00:24:35.090 --> 00:24:40.000
And these lines in red are
showing you where it could get

00:24:40.000 --> 00:24:40.620
tripped up.

00:24:40.620 --> 00:24:46.420
So the first line is the meta
tag for the http-equivalent of

00:24:46.420 --> 00:24:47.860
the character set.

00:24:47.860 --> 00:24:51.840
And character set is important
because it tells the rendering

00:24:51.840 --> 00:24:56.060
document how to interpret the
data that's being presented.

00:24:56.060 --> 00:25:00.420
A common character set,
for example, is UTF-8.

00:25:00.420 --> 00:25:03.080
The next meta tag is the
X-UA compatible.

00:25:03.080 --> 00:25:05.590
This is to tell the browser
to render in a

00:25:05.590 --> 00:25:07.570
different user agent.

00:25:07.570 --> 00:25:10.440
So for example, you might
want IE9 to behave

00:25:10.440 --> 00:25:12.910
like IE8, and so on.

00:25:12.910 --> 00:25:14.950
Next is the base tag.

00:25:14.950 --> 00:25:16.710
I hadn't known about the
base tag previously.

00:25:16.710 --> 00:25:17.640
I've never used it.

00:25:17.640 --> 00:25:19.510
So in looking it up,
I was surprised to

00:25:19.510 --> 00:25:21.200
find what it does.

00:25:21.200 --> 00:25:29.210
And the base tag pretty much
supplants the host on which

00:25:29.210 --> 00:25:31.150
relative paths are
being served.

00:25:31.150 --> 00:25:34.020
So if you're on example.com,
and you want to load a

00:25:34.020 --> 00:25:41.280
resource slash example.php,
base will allow you to

00:25:41.280 --> 00:25:43.500
supplant that host name
with example2.com.

00:25:43.500 --> 00:25:48.970
So you could maintain relative
paths, but only change the

00:25:48.970 --> 00:25:51.150
code in one place.

00:25:51.150 --> 00:25:53.840
And base sort of reminds me
of the with statement in

00:25:53.840 --> 00:25:56.930
JavaScript, if anybody's
familiar.

00:25:56.930 --> 00:26:00.560
The with statement lets you
supplant the context of a

00:26:00.560 --> 00:26:02.030
JavaScript object.

00:26:02.030 --> 00:26:04.090
And there's a saying that
the with statement

00:26:04.090 --> 00:26:04.970
is considered harmful.

00:26:04.970 --> 00:26:06.600
And I'll extend that
to the base tag.

00:26:06.600 --> 00:26:09.320
The base tag is considered
harmful, for the reason that

00:26:09.320 --> 00:26:12.100
it can cause these
cancel requests.

00:26:12.100 --> 00:26:16.020
It's not used too often, but
when it is, improperly, it can

00:26:16.020 --> 00:26:18.080
slow down your website.

00:26:18.080 --> 00:26:20.940
So the reason why these things
are contributing to this

00:26:20.940 --> 00:26:24.870
antipattern is because when
they're out of order, the

00:26:24.870 --> 00:26:28.290
rendering agent will make
false assumptions.

00:26:28.290 --> 00:26:32.460
So, for example, taking
character set.

00:26:32.460 --> 00:26:35.090
If the character set is defined
later on in the

00:26:35.090 --> 00:26:39.560
document, for example, the
bottom of your HTML head, it

00:26:39.560 --> 00:26:41.400
will have to make an assumption
as it processes the

00:26:41.400 --> 00:26:43.630
document that it's a particular
character set.

00:26:43.630 --> 00:26:47.380
It might not agree with what
you set it to be later.

00:26:47.380 --> 00:26:50.420
So it'll start making requests
under a certain assumption of

00:26:50.420 --> 00:26:51.440
character set.

00:26:51.440 --> 00:26:54.740
And as soon as it comes across
this meta tag saying that it's

00:26:54.740 --> 00:26:56.690
something else entirely, it
will have to cancel, and

00:26:56.690 --> 00:27:00.060
basically throw out those
previous requests.

00:27:00.060 --> 00:27:02.150
And then there is a note at
the bottom that this is

00:27:02.150 --> 00:27:04.160
Internet Explorer specific.

00:27:04.160 --> 00:27:06.800
I've seen this especially in
Internet Explorer 7, which

00:27:06.800 --> 00:27:08.330
hopefully we're not testing
too much in.

00:27:08.330 --> 00:27:11.660
But if we are, this is why you
might see this pattern.

00:27:11.660 --> 00:27:13.840
And I will share these slides,
and I encourage you

00:27:13.840 --> 00:27:14.540
to click this link.

00:27:14.540 --> 00:27:18.840
It has a great article on the
Microsoft blog about all of

00:27:18.840 --> 00:27:22.290
this, and why this happens.

00:27:22.290 --> 00:27:26.490
Moving on now to navigation
timing.

00:27:26.490 --> 00:27:29.890
When you are using a more modern
browser, you might see

00:27:29.890 --> 00:27:33.650
some extra colors in your
waterfall chart.

00:27:33.650 --> 00:27:36.650
Almost all browsers that I
know of will have this

00:27:36.650 --> 00:27:40.150
vertical green and
dark blue line.

00:27:40.150 --> 00:27:42.540
The green line is Start Render,
the blue line is

00:27:42.540 --> 00:27:43.870
Document Complete.

00:27:43.870 --> 00:27:48.230
But we also have this purple,
and light blue bars.

00:27:48.230 --> 00:27:53.980
And unlike the green lines,
these actually have a width

00:27:53.980 --> 00:27:55.500
associated with them.

00:27:55.500 --> 00:27:59.190
And so starting from left to
right, this purple bar,

00:27:59.190 --> 00:28:02.790
domContentLoaded, is pretty
much equivalent to

00:28:02.790 --> 00:28:03.600
document.ready.

00:28:03.600 --> 00:28:08.130
So if you're familiar with
jQuery, you might have a ready

00:28:08.130 --> 00:28:08.820
event handler.

00:28:08.820 --> 00:28:12.860
So this will pretty much be
fired whenever the document is

00:28:12.860 --> 00:28:14.930
ready to be--

00:28:14.930 --> 00:28:19.660
or the document object model
is done being processed.

00:28:19.660 --> 00:28:23.110
And the width of this line is
representative of the amount

00:28:23.110 --> 00:28:24.970
of time you're spending in
that event handler in

00:28:24.970 --> 00:28:26.360
JavaScript.

00:28:26.360 --> 00:28:29.010
And the common theme today is
everything should be as narrow

00:28:29.010 --> 00:28:29.570
as possible.

00:28:29.570 --> 00:28:35.470
So a bar that is about 1.6
seconds wide is pretty bad.

00:28:35.470 --> 00:28:40.230
And keeping in mind that the
browser is single threaded,

00:28:40.230 --> 00:28:43.300
your JavaScript is going to be
taking up time that the user

00:28:43.300 --> 00:28:44.690
could be interacting
with the page.

00:28:44.690 --> 00:28:45.940
So that's one reason.

00:28:45.940 --> 00:28:49.430
The other reason is that this
purple bar comes, in this

00:28:49.430 --> 00:28:51.170
case, immediately before
the green line.

00:28:51.170 --> 00:28:53.760
The green line is Start
Render, or the first

00:28:53.760 --> 00:28:55.230
paint of the page.

00:28:55.230 --> 00:28:59.690
And first paint means this is
the time that something was

00:28:59.690 --> 00:29:01.210
finally displayed
on the screen.

00:29:01.210 --> 00:29:05.160
So the green line occurs at
about 2.8 seconds here.

00:29:05.160 --> 00:29:08.670
So that literally means the user
had a blank white page up

00:29:08.670 --> 00:29:11.760
until this point, when something
was displayed.

00:29:11.760 --> 00:29:17.190
And so thinking about these two
events next to each other,

00:29:17.190 --> 00:29:20.570
we want to display something
to the page as soon as

00:29:20.570 --> 00:29:24.560
possible, and then we could
do our script processing.

00:29:24.560 --> 00:29:30.240
So by having purple before
green, that's further delaying

00:29:30.240 --> 00:29:33.160
this Start Render event.

00:29:33.160 --> 00:29:36.860
And moving on to this light
blue loadEvent, this is

00:29:36.860 --> 00:29:40.320
equivalent to the onload event
handler in your JavaScript.

00:29:40.320 --> 00:29:44.360
This is more commonly a lot
shorter than the purple.

00:29:44.360 --> 00:29:48.480
Onload event handling is useful
if you want to preload

00:29:48.480 --> 00:29:52.940
some resources later on the
page below the fold, or

00:29:52.940 --> 00:29:58.070
triggering other types of
nonessential things, maybe

00:29:58.070 --> 00:30:02.180
telling an ad to kick in, or
sending back some data to a

00:30:02.180 --> 00:30:05.320
web performance beacon.

00:30:05.320 --> 00:30:08.480
Finally, Document Complete is
roughly equivalent to the

00:30:08.480 --> 00:30:09.730
loadEventStart.

00:30:11.500 --> 00:30:14.970
And typically this occurs after
the load event handler.

00:30:14.970 --> 00:30:19.090
But just keep in mind that it's
the loadEventStart is the

00:30:19.090 --> 00:30:21.030
associated event here.

00:30:21.030 --> 00:30:27.180
So using all these terminologies
of timing

00:30:27.180 --> 00:30:32.760
events, we might sort of get
confused about what they mean

00:30:32.760 --> 00:30:34.360
and how they relate
to each other.

00:30:34.360 --> 00:30:39.940
So this is the chart made by
the working group of the

00:30:39.940 --> 00:30:41.750
navigation timing API.

00:30:41.750 --> 00:30:46.460
And this shows us the ordering
of events in this API.

00:30:46.460 --> 00:30:49.460
And this is all available to
you in newer browsers.

00:30:49.460 --> 00:30:51.740
But when I saw this, I
kind of got a little

00:30:51.740 --> 00:30:52.950
lost in all the details.

00:30:52.950 --> 00:30:56.630
So one thing that I found
helpful was to just mute out

00:30:56.630 --> 00:30:59.690
everything that's not directly
relevant to WebPagetest.

00:30:59.690 --> 00:31:02.400
And we're left with
all of this.

00:31:02.400 --> 00:31:04.970
But even still, I wasn't really
satisfied, so I did

00:31:04.970 --> 00:31:08.730
some color coding, and we
arrived at this chart, which I

00:31:08.730 --> 00:31:10.340
found to be really helpful.

00:31:10.340 --> 00:31:15.760
The colors correspond to the
previous slide, and we can see

00:31:15.760 --> 00:31:18.760
directly how these colorings
are related back to the

00:31:18.760 --> 00:31:22.330
navigation timing API.

00:31:22.330 --> 00:31:26.080
domContentLoaded is occupied
with this entire purple bar.

00:31:26.080 --> 00:31:29.460
That light blue bar is occupied
in that entire

00:31:29.460 --> 00:31:30.980
loadEvent handler.

00:31:30.980 --> 00:31:34.920
And then we're left with these
green and blue lines.

00:31:34.920 --> 00:31:39.040
So working from right to left,
this blue line is immediately

00:31:39.040 --> 00:31:40.820
after loadEventStart.

00:31:40.820 --> 00:31:43.060
But this green line is sort of
floating around in the middle

00:31:43.060 --> 00:31:44.130
of the processing bar.

00:31:44.130 --> 00:31:48.870
And green, first paint, is
not directly tied to any

00:31:48.870 --> 00:31:50.180
performance event.

00:31:50.180 --> 00:31:56.320
We can't really qualitatively
measure the time of the first

00:31:56.320 --> 00:31:57.900
paint just by looking
at the data.

00:31:57.900 --> 00:32:01.110
It has more to do with the
visuals on the page.

00:32:01.110 --> 00:32:04.400
And so this is an example of
one perceived performance

00:32:04.400 --> 00:32:10.520
metric, or a metric in which
the user is the one

00:32:10.520 --> 00:32:14.700
experiencing this type of event,
rather than an event

00:32:14.700 --> 00:32:17.070
being fired off in an amount
of milliseconds.

00:32:17.070 --> 00:32:19.180
This is sort of the feeling
that a user gets when

00:32:19.180 --> 00:32:20.170
something happens.

00:32:20.170 --> 00:32:22.342
And so that's why it's floating
around in the middle.

00:32:25.000 --> 00:32:29.020
OK, so moving on to some other
patterns of-- instead of

00:32:29.020 --> 00:32:32.980
requests and their responses as
one unit, now we're going

00:32:32.980 --> 00:32:36.300
to look at requests, how they
interact with each other, and

00:32:36.300 --> 00:32:39.630
could potentially negatively
affect performance.

00:32:39.630 --> 00:32:41.870
So this is an antipattern
known as request

00:32:41.870 --> 00:32:45.140
serialization, also known as
the stair step pattern.

00:32:45.140 --> 00:32:49.940
And for reference, I included
this red slope line to left,

00:32:49.940 --> 00:32:52.250
just to show you the direction
that we're going.

00:32:52.250 --> 00:32:54.380
It's down and to the
right, and it's at

00:32:54.380 --> 00:32:57.140
an OK type of slope.

00:32:57.140 --> 00:33:00.080
It's not totally vertical, it's
not totally horizontal.

00:33:00.080 --> 00:33:03.060
But the fact that it extends
outward in that manner is an

00:33:03.060 --> 00:33:07.000
indicator that this
is an antipattern.

00:33:07.000 --> 00:33:10.680
So serialization occurs
in this way when

00:33:10.680 --> 00:33:11.870
there are many requests.

00:33:11.870 --> 00:33:14.710
You're trying to get a lot
out, and get a lot of

00:33:14.710 --> 00:33:15.750
information back.

00:33:15.750 --> 00:33:19.210
But the problem is that there
are few connections, typically

00:33:19.210 --> 00:33:21.050
between two and six.

00:33:21.050 --> 00:33:25.540
And a connection is basically
like lanes on a highway.

00:33:25.540 --> 00:33:33.230
You can fit only so many cars
horizontally before traffic

00:33:33.230 --> 00:33:36.270
starts to pile up behind, like
bumper to bumper traffic.

00:33:36.270 --> 00:33:39.390
So this is an example of bumper
to bumper traffic where

00:33:39.390 --> 00:33:42.930
one request cannot even be
started until another one has

00:33:42.930 --> 00:33:44.630
come back with a response.

00:33:44.630 --> 00:33:47.170
And looking closely at this
waterfall, we can see that

00:33:47.170 --> 00:33:51.610
these requests overlap each
other three at a time.

00:33:51.610 --> 00:33:53.990
And that's not say that this
is in a browser that only

00:33:53.990 --> 00:33:56.030
allows three concurrent
connections.

00:33:56.030 --> 00:33:59.000
It's actually the case that
there was a very large image

00:33:59.000 --> 00:34:02.720
being loaded above these
requests, and that is further

00:34:02.720 --> 00:34:04.840
holding up the number
of connections

00:34:04.840 --> 00:34:07.200
that could be reused.

00:34:07.200 --> 00:34:10.429
So when we look at something
like this, there are a few

00:34:10.429 --> 00:34:12.889
best practices that we might
think of about how to solve

00:34:12.889 --> 00:34:14.980
this problem.

00:34:14.980 --> 00:34:17.920
For images, we might think to,
well, instead of having 12

00:34:17.920 --> 00:34:20.380
images, maybe we should combine
them all into one, and

00:34:20.380 --> 00:34:23.650
have a sprite.

00:34:23.650 --> 00:34:26.600
Another idea is to shard
the domains.

00:34:26.600 --> 00:34:29.969
So that connection is per
domain, or that connection

00:34:29.969 --> 00:34:31.239
limitation is per domain.

00:34:31.239 --> 00:34:34.730
So if we're allowed six
concurrent connections on

00:34:34.730 --> 00:34:39.510
example.com, maybe we want
example2.com, or a sub-domain

00:34:39.510 --> 00:34:41.960
like img.example.com.

00:34:41.960 --> 00:34:47.440
And so in this way, we could, in
theory, split up and get 12

00:34:47.440 --> 00:34:49.139
concurrent connections.

00:34:49.139 --> 00:34:50.659
Or that's like a 12-lane
highway, as

00:34:50.659 --> 00:34:51.840
opposed to a six-lane.

00:34:51.840 --> 00:34:54.790
In theory, that should let
us go twice as fast.

00:34:54.790 --> 00:34:57.340
But that's not always
the case.

00:34:57.340 --> 00:35:02.450
You incur something called
a DNS lookup penalty.

00:35:02.450 --> 00:35:09.500
So if you have many new domains
needing to be getting

00:35:09.500 --> 00:35:12.530
their IP addresses resolved,
similar to that very first

00:35:12.530 --> 00:35:17.040
teal bar we looked at, that has
its own pile up effect.

00:35:17.040 --> 00:35:20.780
And it's actually a slow down
of performance gains.

00:35:20.780 --> 00:35:23.890
So it's not always a direct win,
just to shard domains.

00:35:23.890 --> 00:35:26.490
And I have a note at the bottom,
just to think about

00:35:26.490 --> 00:35:32.300
HTTP 2.0, or the speedy
protocol.

00:35:32.300 --> 00:35:38.080
And so the note here is that
it's not always a best

00:35:38.080 --> 00:35:39.930
practice to shard domains.

00:35:39.930 --> 00:35:41.520
Today it might be
a good thing.

00:35:41.520 --> 00:35:43.110
But that doesn't mean tomorrow,
when we have the

00:35:43.110 --> 00:35:46.440
newer protocols, that it's
still going to work.

00:35:46.440 --> 00:35:49.080
And I'll leave it as an example
to the viewer to look

00:35:49.080 --> 00:35:53.350
up exactly why it's
called pipelining.

00:35:53.350 --> 00:35:57.150
And so the server could handle
many, many requests, like all

00:35:57.150 --> 00:35:59.320
12 or so of these at once.

00:35:59.320 --> 00:36:03.360
And it could, in theory, handle
this without a stair

00:36:03.360 --> 00:36:04.240
step pattern.

00:36:04.240 --> 00:36:06.040
So just keep in mind that
although today it is a

00:36:06.040 --> 00:36:08.100
problem, it might
not be tomorrow.

00:36:08.100 --> 00:36:11.890
And then you're left with the
problem of how do you actually

00:36:11.890 --> 00:36:14.180
handle it for the browsers that
don't support this new

00:36:14.180 --> 00:36:18.410
protocol today, and try to
get maximal speed up for

00:36:18.410 --> 00:36:19.660
tomorrow's browsers.

00:36:22.580 --> 00:36:28.030
So this is not necessarily
waterfall, per se.

00:36:28.030 --> 00:36:29.880
This is known as the
connection view.

00:36:29.880 --> 00:36:32.790
And this is still showing you
the serialization problem.

00:36:32.790 --> 00:36:35.450
It's the same pattern, just
in a different view.

00:36:35.450 --> 00:36:38.600
And there's a little bit of a
color coding difference here,

00:36:38.600 --> 00:36:43.770
and I've noted that using this
line that says CSS JavaScript,

00:36:43.770 --> 00:36:45.330
images, and Flash.

00:36:45.330 --> 00:36:50.170
And although it's great that we
are loading everything one

00:36:50.170 --> 00:36:53.410
after another, we're doing it
as soon as possible, it's

00:36:53.410 --> 00:36:55.650
still not ideal.

00:36:55.650 --> 00:36:58.400
The connection view is great
because it shows us how we're

00:36:58.400 --> 00:36:59.710
reusing our connections.

00:36:59.710 --> 00:37:05.240
Reusing a connection is a great
performance win, because

00:37:05.240 --> 00:37:09.600
all the way at the left, we
see these six orange bars.

00:37:09.600 --> 00:37:11.340
And that is the TCP
connection.

00:37:11.340 --> 00:37:14.640
Don't confuse that with this
orange JavaScript line.

00:37:14.640 --> 00:37:17.210
It's the same as that first
slide, with the teal and the

00:37:17.210 --> 00:37:21.090
orange DNS lookup and the
initial connection.

00:37:21.090 --> 00:37:27.690
So we have www1.macys.com
as our domain.

00:37:27.690 --> 00:37:31.790
And request four is the first
request to this domain, and so

00:37:31.790 --> 00:37:35.330
we have that DNS
lookup penalty.

00:37:35.330 --> 00:37:40.120
The subsequent five requests
are able to reuse this DNS

00:37:40.120 --> 00:37:43.180
lookup, so that you don't see
that teal lookup on every

00:37:43.180 --> 00:37:46.120
other request, or on every
other connection.

00:37:46.120 --> 00:37:48.910
But what we do have is this
orange connection opening for

00:37:48.910 --> 00:37:50.740
all six of these.

00:37:50.740 --> 00:37:53.570
The good news is that it's not
occurring for every subsequent

00:37:53.570 --> 00:37:57.460
request, but it is occurring
for every connection.

00:37:57.460 --> 00:38:04.900
So it's a very compact type
of pattern, here.

00:38:04.900 --> 00:38:06.500
And so we might think that
that's a good thing.

00:38:06.500 --> 00:38:09.860
But looking at this in terms
of colors, it's kind of

00:38:09.860 --> 00:38:14.510
helpful to see this middle mark,
where the purple images

00:38:14.510 --> 00:38:17.800
are back to back with the
orange JavaScript.

00:38:17.800 --> 00:38:21.590
And I think that's a good place
to make a cut here, and

00:38:21.590 --> 00:38:24.560
say, well, if we were to shard
these domains, and maybe have

00:38:24.560 --> 00:38:29.470
www2.macys.com, where we load
the images and the flash, in

00:38:29.470 --> 00:38:34.830
theory, we could have
a speed up of 2x.

00:38:34.830 --> 00:38:39.810
Again it's not a rule that you
can follow every single time,

00:38:39.810 --> 00:38:42.600
that if you split the domains
by a factor of 2, it's going

00:38:42.600 --> 00:38:43.940
to be twice as fast.

00:38:43.940 --> 00:38:47.370
But in theory, this is an
example of how sharding a

00:38:47.370 --> 00:38:50.310
domain could affect this
connection view.

00:38:52.910 --> 00:38:57.340
So bringing the two together, we
see connection view and the

00:38:57.340 --> 00:38:59.090
waterfall next to each other.

00:38:59.090 --> 00:39:03.750
And under one condition, they
are actually almost the same.

00:39:03.750 --> 00:39:06.380
There's one connection
for each request, and

00:39:06.380 --> 00:39:07.110
that's a bad thing.

00:39:07.110 --> 00:39:09.980
And this is because we're not
reusing our connections, or

00:39:09.980 --> 00:39:11.780
the connections are closed.

00:39:11.780 --> 00:39:14.690
And you'll notice that for each
of these requests, we see

00:39:14.690 --> 00:39:19.970
this orange initial connection
being incurred.

00:39:19.970 --> 00:39:24.940
And this TCP overhead is
directly affecting the

00:39:24.940 --> 00:39:27.740
duration of the request.

00:39:27.740 --> 00:39:31.640
So for looking at the first
one here, it takes 177

00:39:31.640 --> 00:39:35.630
milliseconds to get all the
information we need.

00:39:35.630 --> 00:39:39.860
But it looks like most of that
is being taken up in TCP

00:39:39.860 --> 00:39:41.470
connection.

00:39:41.470 --> 00:39:45.430
And as we go down, roughly 30
to 50% of these requests are

00:39:45.430 --> 00:39:49.030
taking their time in this
connection phase.

00:39:49.030 --> 00:39:51.040
And so you might think
of it as a little

00:39:51.040 --> 00:39:52.010
sliver on the chart.

00:39:52.010 --> 00:39:55.840
It might only take tens of
milliseconds, or hundreds of

00:39:55.840 --> 00:39:56.390
milliseconds.

00:39:56.390 --> 00:40:00.980
But it does add up, and it turns
out that 50% of the time

00:40:00.980 --> 00:40:04.940
taken here is just in this
connection phase.

00:40:04.940 --> 00:40:09.350
Again, this red line on the left
is indicating that it is

00:40:09.350 --> 00:40:12.660
pushing out this waterfall, and
it's making it harder and

00:40:12.660 --> 00:40:16.110
harder to get things done in
a short amount of time.

00:40:16.110 --> 00:40:19.230
Luckily, there is an
easy fix here.

00:40:19.230 --> 00:40:22.930
On the server side, in your
server configuration file, you

00:40:22.930 --> 00:40:25.600
can do something, for example,
like an Apache.

00:40:25.600 --> 00:40:27.060
You can enable Keep-Alive.

00:40:27.060 --> 00:40:29.890
This is, literally, the line of
code that you need to solve

00:40:29.890 --> 00:40:30.410
this problem.

00:40:30.410 --> 00:40:33.700
It's a one-liner, under most
general circumstances, and

00:40:33.700 --> 00:40:36.580
it's a very quick
and easy win.

00:40:36.580 --> 00:40:41.520
There is pretty much no
reason not to do this.

00:40:41.520 --> 00:40:44.890
The next pattern is something
that I had to create

00:40:44.890 --> 00:40:47.710
artificially just to exacerbate
the problem.

00:40:47.710 --> 00:40:49.870
And this is the problem
of network silence.

00:40:49.870 --> 00:40:53.740
And this is introducing two more
charts having to do with

00:40:53.740 --> 00:40:58.080
the waterfall, and it's the CPU
utilization chart, and the

00:40:58.080 --> 00:40:59.780
bandwidth utilization chart.

00:40:59.780 --> 00:41:05.810
And network silence can be found
by looking at these two

00:41:05.810 --> 00:41:09.400
charts, where bandwidth
utilization is very low, CPU

00:41:09.400 --> 00:41:11.610
utilization is very high.

00:41:11.610 --> 00:41:14.150
And so we might look at this
and wonder, what could

00:41:14.150 --> 00:41:16.580
possibly be going wrong?

00:41:16.580 --> 00:41:19.840
And it turns out that it
could be a factor--

00:41:19.840 --> 00:41:21.540
multiple factors here.

00:41:21.540 --> 00:41:26.510
One of them is that you can
have expensive DOM layouts

00:41:26.510 --> 00:41:27.490
being done.

00:41:27.490 --> 00:41:31.620
That could be in HTML table,
that's resizing dynamically,

00:41:31.620 --> 00:41:34.410
and there's lots of pushing
and pulling going

00:41:34.410 --> 00:41:35.230
on inside the table.

00:41:35.230 --> 00:41:37.900
And so with that document, with
the browser might do is

00:41:37.900 --> 00:41:42.960
hold off on any type of
processing until it knows that

00:41:42.960 --> 00:41:47.550
it could display that
table all at once.

00:41:47.550 --> 00:41:50.820
And the other thing here is
that you could have some

00:41:50.820 --> 00:41:51.380
JavaScript.

00:41:51.380 --> 00:41:54.480
As I mentioned earlier, the
browser is single-threaded.

00:41:54.480 --> 00:41:58.820
So if you have JavaScript that's
running in a long loop,

00:41:58.820 --> 00:42:01.840
that could push out these other
requests that happen.

00:42:01.840 --> 00:42:05.120
And so I did come up with this
contrived example here.

00:42:05.120 --> 00:42:08.350
And I'll try to pull
this up for you.

00:42:08.350 --> 00:42:09.600
Sorry.

00:42:15.310 --> 00:42:18.580
So we see here, I'm loading a
page, and nothing happened.

00:42:18.580 --> 00:42:20.810
And all of the sudden, we
get this picture back.

00:42:20.810 --> 00:42:23.770
And that delay was the
network silence.

00:42:23.770 --> 00:42:28.670
We tried to make this page load
as soon as possible, but

00:42:28.670 --> 00:42:31.730
we were not able to do it
because of some JavaScript.

00:42:31.730 --> 00:42:33.840
So if I could just view
the source here.

00:42:38.680 --> 00:42:43.480
Control-Shift-S. There we are.

00:42:43.480 --> 00:42:45.730
View page source.

00:42:45.730 --> 00:42:48.370
So when I wrote this code, I
was literally going back to

00:42:48.370 --> 00:42:51.530
all the worst practices
of web development.

00:42:51.530 --> 00:42:55.030
I had a script in the head that
was doing some busy work

00:42:55.030 --> 00:42:57.620
for literally five seconds,
pushing values to

00:42:57.620 --> 00:42:59.410
an arbitrary array.

00:42:59.410 --> 00:43:03.190
And then I used, which made me
cringe, document.write to

00:43:03.190 --> 00:43:04.690
write an image out.

00:43:04.690 --> 00:43:07.120
And the reason why I had to
use document.write in this

00:43:07.120 --> 00:43:12.260
case was because this preloading
done would go and

00:43:12.260 --> 00:43:17.700
find the image tag, and try to
preload the image during the

00:43:17.700 --> 00:43:19.070
busy While loop up here.

00:43:19.070 --> 00:43:23.170
So by using document.write,
that's obscuring the image

00:43:23.170 --> 00:43:25.030
that we want to load later.

00:43:25.030 --> 00:43:27.350
So this is a very bad pattern,
but I'm using it here just to

00:43:27.350 --> 00:43:31.460
show you the effect
on the waterfall.

00:43:31.460 --> 00:43:36.840
And so you might see a
big gap in between

00:43:36.840 --> 00:43:38.220
one request and another.

00:43:38.220 --> 00:43:41.760
And so this is having to do with
your code in particular.

00:43:41.760 --> 00:43:47.630
So when you see a big gap like
this, one hint is to look at

00:43:47.630 --> 00:43:52.130
the request happening previous
to that gap.

00:43:52.130 --> 00:43:56.360
In this case, silence.html is
the only request to occur

00:43:56.360 --> 00:43:58.730
before that gap, so we know to
look somewhere in that code.

00:43:58.730 --> 00:44:02.500
And as we just did, we saw the
culprits, which was using

00:44:02.500 --> 00:44:04.430
document.write and
a long-loading

00:44:04.430 --> 00:44:07.040
script in the head.

00:44:07.040 --> 00:44:08.700
It's possible that this could
be in the middle of your

00:44:08.700 --> 00:44:11.050
waterfall, and it'll be a little
harder to track down,

00:44:11.050 --> 00:44:13.020
but it's just something
to keep in mind.

00:44:16.600 --> 00:44:20.600
So in summary, we looked at
waterfall slope, and how just

00:44:20.600 --> 00:44:24.340
following the left edge of all
these requests could give us a

00:44:24.340 --> 00:44:27.970
high level idea of the
performance of our page.

00:44:27.970 --> 00:44:31.020
We looked at the individual
request components from DNS

00:44:31.020 --> 00:44:33.890
lookup to content download.

00:44:33.890 --> 00:44:36.900
We looked at three different
HTTP responses, the redirects,

00:44:36.900 --> 00:44:39.366
the conditional GETs,
and the errors.

00:44:39.366 --> 00:44:42.650
We looked at the page load
events, and all those colors,

00:44:42.650 --> 00:44:44.880
and how that relates the
navigation timing API.

00:44:44.880 --> 00:44:47.770
We looked at request
concurrency, and how that can

00:44:47.770 --> 00:44:51.670
contribute to the stair step
pattern, and finally, network

00:44:51.670 --> 00:44:52.390
utilization.

00:44:52.390 --> 00:44:55.730
So we want to do as much with
the network when it's

00:44:55.730 --> 00:44:57.970
available as we could.

00:44:57.970 --> 00:45:01.230
And so putting this all
together, I put together a few

00:45:01.230 --> 00:45:06.700
slides of real waterfalls, and
some really bad things that I

00:45:06.700 --> 00:45:08.330
found with them.

00:45:08.330 --> 00:45:11.290
This is also introducing the
grades at the top of the

00:45:11.290 --> 00:45:15.880
WebPagetest results, A through
F, and X or check mark if

00:45:15.880 --> 00:45:18.120
you're using a CDN
effectively.

00:45:18.120 --> 00:45:22.430
And in this particular case,
there are 46 requests, and

00:45:22.430 --> 00:45:24.280
only five of them
are successful.

00:45:24.280 --> 00:45:26.560
And we could see that from this
high level view by all

00:45:26.560 --> 00:45:28.920
the red occurring on
the waterfall.

00:45:28.920 --> 00:45:31.520
Also, if we were to draw that
waterfall slope line, it would

00:45:31.520 --> 00:45:35.320
be horizontal for most of the
time, it turns out 20 seconds,

00:45:35.320 --> 00:45:38.490
and all of the sudden it'll
become vertical again.

00:45:38.490 --> 00:45:41.530
And this is due to a long time
to first byte in the initial

00:45:41.530 --> 00:45:44.760
HTML request.

00:45:44.760 --> 00:45:49.930
And that brings up a good point
of when you see a really

00:45:49.930 --> 00:45:53.600
long green bar for time to first
byte, that's usually

00:45:53.600 --> 00:45:58.210
indicative of a back end
performance problem.

00:45:58.210 --> 00:46:01.730
WebPagetest is a front end
performance testing tool, and

00:46:01.730 --> 00:46:03.700
it's great at showing you where
you can improve your

00:46:03.700 --> 00:46:06.260
front end performance.

00:46:06.260 --> 00:46:07.730
But it's not so great
at back end.

00:46:07.730 --> 00:46:08.590
And that's on purpose.

00:46:08.590 --> 00:46:10.520
It's very focused on
front performance.

00:46:10.520 --> 00:46:13.930
So when used in conjunction
with back end performance

00:46:13.930 --> 00:46:17.690
testing tools, it's very, very
effective at giving you a full

00:46:17.690 --> 00:46:19.520
picture of what's going on.

00:46:19.520 --> 00:46:21.840
So although we just have a very
long 20 second green bar,

00:46:21.840 --> 00:46:23.780
it's not telling us a lot about
why it's happening.

00:46:23.780 --> 00:46:28.030
But it is showing up in our
front end waterfall, so it is

00:46:28.030 --> 00:46:31.260
hinting us to look
at the back end.

00:46:31.260 --> 00:46:35.000
Also, to note, 30% gzip
savings are possible.

00:46:35.000 --> 00:46:37.505
This is why we get a D grade
in our compress transfer.

00:46:41.150 --> 00:46:44.230
Next, this is a very, very tall
waterfall, so it's kind

00:46:44.230 --> 00:46:45.330
of hard to see what's
going on.

00:46:45.330 --> 00:46:48.050
There are 443 requests.

00:46:48.050 --> 00:46:50.330
Most of the grades at the
top are kind of decent.

00:46:50.330 --> 00:46:53.640
There is an F for time
to first byte, or

00:46:53.640 --> 00:46:54.800
our first byte time.

00:46:54.800 --> 00:46:58.300
There are 8,000 DOM elements
here, so that's telling me

00:46:58.300 --> 00:47:00.280
that there's a lot going
on this page.

00:47:00.280 --> 00:47:04.800
We could see some of that low
network utilization because of

00:47:04.800 --> 00:47:07.860
expensive DOM layouts,
and things like this.

00:47:07.860 --> 00:47:11.150
There's 1.6 megabytes of
JavaScript, which was

00:47:11.150 --> 00:47:14.390
surprising to see, because I
don't know what you can even

00:47:14.390 --> 00:47:16.860
load that's 1.6 megs
of JavaScript.

00:47:16.860 --> 00:47:20.850
Must be uncompressed and
unminified code.

00:47:20.850 --> 00:47:23.280
And the funny thing is that,
even from this high level

00:47:23.280 --> 00:47:26.260
view, you can still see the
JavaScript from here.

00:47:26.260 --> 00:47:28.380
It's almost like the Great Wall
of China from space, even

00:47:28.380 --> 00:47:29.840
though it's not true.

00:47:29.840 --> 00:47:34.680
So with 443 requests, naturally,
we have 75 unique

00:47:34.680 --> 00:47:36.100
domains, which is a lot.

00:47:36.100 --> 00:47:39.570
And going back to that point
about DNS lookup, for each of

00:47:39.570 --> 00:47:42.870
those 75 unique domains, that's
incurring that DNS

00:47:42.870 --> 00:47:44.120
lookup time.

00:47:44.120 --> 00:47:46.870
And maybe one of those is having
a bad day, and it takes

00:47:46.870 --> 00:47:48.890
a long time to resolve
the IP address.

00:47:48.890 --> 00:47:51.560
So always, always try
to minimize the

00:47:51.560 --> 00:47:52.840
number of unique domains.

00:47:52.840 --> 00:47:58.860
Try to reuse domains as best
as you could, also reusing

00:47:58.860 --> 00:48:01.190
your connections.

00:48:01.190 --> 00:48:05.360
So before I switch to the next
slide, I'll say that this one

00:48:05.360 --> 00:48:09.170
has pretty good grades, but
a really ugly waterfall.

00:48:09.170 --> 00:48:12.010
This one has the worst possible
grades, all F's and

00:48:12.010 --> 00:48:15.050
an X, and the waterfall
is not as bad.

00:48:15.050 --> 00:48:17.410
It's not as big, but there's
still a lot that we

00:48:17.410 --> 00:48:18.660
can point out here.

00:48:18.660 --> 00:48:22.370
There's two megabytes overall
for the page weight.

00:48:22.370 --> 00:48:25.630
It takes 26 seconds
to load the page.

00:48:25.630 --> 00:48:29.360
And when we load this page
again, on the repeat view, it

00:48:29.360 --> 00:48:31.300
still takes 17 seconds.

00:48:31.300 --> 00:48:36.040
I didn't mention repeat views as
much, but this last F grade

00:48:36.040 --> 00:48:38.430
cache static content is telling
us how well or how

00:48:38.430 --> 00:48:40.980
effective our caching
policies are.

00:48:40.980 --> 00:48:44.660
Even with the caching policies
in place, and even with the

00:48:44.660 --> 00:48:48.230
browser heuristics to try
to work around some

00:48:48.230 --> 00:48:50.210
inefficiencies in your
caching headers, it's

00:48:50.210 --> 00:48:53.070
still taking 17 seconds.

00:48:53.070 --> 00:48:56.390
So the reason why I put these
next to each other for

00:48:56.390 --> 00:49:00.070
comparison is that the grades
that WebPagetest gives you,

00:49:00.070 --> 00:49:04.280
all F's and an X, should be an
indicator that there's a lot

00:49:04.280 --> 00:49:06.310
that you need to fix here.

00:49:06.310 --> 00:49:08.390
But when I go back to the other
waterfall with better

00:49:08.390 --> 00:49:12.490
grades, I'm kind of hesitant
to say which one is worse.

00:49:12.490 --> 00:49:14.710
I might say that this one is
worse, because there are many

00:49:14.710 --> 00:49:17.780
more requests, many more
domains, a much more

00:49:17.780 --> 00:49:21.430
complicated DOM, and
so on and so forth.

00:49:21.430 --> 00:49:24.420
So take it with a grain of
salt that WebPagetest is

00:49:24.420 --> 00:49:28.400
telling you that you might have
done OK, or might have

00:49:28.400 --> 00:49:29.970
even done very well.

00:49:29.970 --> 00:49:32.230
But there's still room for
improvement, even if

00:49:32.230 --> 00:49:34.960
you have all A's.

00:49:34.960 --> 00:49:38.320
Another thing to note is that
since these screen shots were

00:49:38.320 --> 00:49:40.650
taken, WebPagetest did
have an update.

00:49:40.650 --> 00:49:42.220
I think this was in
the past week.

00:49:42.220 --> 00:49:46.130
And I did have a chance to find,
it surprisingly did not

00:49:46.130 --> 00:49:50.210
take very long, the worst
possible grade, now with six

00:49:50.210 --> 00:49:53.010
F's and an X. And the
new grade here is

00:49:53.010 --> 00:49:55.700
for agressive jpegs.

00:49:55.700 --> 00:49:56.920
I'll let you look into that.

00:49:56.920 --> 00:50:00.430
So this is a pretty short
waterfall, maybe

00:50:00.430 --> 00:50:02.730
30 requests in total.

00:50:02.730 --> 00:50:05.810
But it's getting the worst
possible grade.

00:50:05.810 --> 00:50:08.460
So something to keep
in mind is the

00:50:08.460 --> 00:50:09.760
waterfall is a great tool.

00:50:09.760 --> 00:50:11.700
It's telling you a lot.

00:50:11.700 --> 00:50:15.090
It's a little overwhelming at
first, but when you learn to

00:50:15.090 --> 00:50:20.090
break things down and look at
requests as individual units,

00:50:20.090 --> 00:50:23.870
and break that further down into
all of these different

00:50:23.870 --> 00:50:26.880
stages of request, you'll learn
how to interpret the

00:50:26.880 --> 00:50:30.710
waterfall, and the reasons why
your website might not be as

00:50:30.710 --> 00:50:32.830
fast as you want it.

00:50:32.830 --> 00:50:35.270
So that's all that I have.

00:50:35.270 --> 00:50:38.270
There's some further reading,
if you choose to do so.

00:50:38.270 --> 00:50:42.330
If you're interested in all this
network information, I

00:50:42.330 --> 00:50:45.360
highly recommend Ilya Grigorik's
book, "High

00:50:45.360 --> 00:50:48.850
Performance Browser Networking."
It's available at

00:50:48.850 --> 00:50:53.020
O'Reilly, and there's also
a free preview online.

00:50:53.020 --> 00:50:56.100
The WebPagetest documentation
is very thorough.

00:50:56.100 --> 00:50:57.330
It's very good.

00:50:57.330 --> 00:51:00.660
You can install WebPagetest
locally, on your own machine,

00:51:00.660 --> 00:51:02.770
behind your corporate firewall,
and test your

00:51:02.770 --> 00:51:05.360
performance from a private
environment.

00:51:05.360 --> 00:51:07.410
And the documentation
is invaluable to

00:51:07.410 --> 00:51:08.930
help you with that.

00:51:08.930 --> 00:51:13.940
Google has a Make the Web Faster
team, and they focus on

00:51:13.940 --> 00:51:15.390
not just improving Google
properties,

00:51:15.390 --> 00:51:16.350
but the web in general.

00:51:16.350 --> 00:51:19.440
And there's many different
initiatives there to improve

00:51:19.440 --> 00:51:20.390
the web as a whole.

00:51:20.390 --> 00:51:22.380
And also, the "Planet
Performance"

00:51:22.380 --> 00:51:23.690
blog aggregator site.

00:51:23.690 --> 00:51:26.850
There are many people that are
talking about web performance,

00:51:26.850 --> 00:51:29.440
and it's impossible to give
you a link to all of them.

00:51:29.440 --> 00:51:31.820
But this aggregator is
a great resource.

00:51:31.820 --> 00:51:32.550
Check it every day.

00:51:32.550 --> 00:51:35.140
There's tons of new stuff
happening, and I highly

00:51:35.140 --> 00:51:36.620
recommend it.

00:51:36.620 --> 00:51:39.060
So with that, thank you.

00:51:39.060 --> 00:51:41.910
I don't believe that we have any
questions, but if you wish

00:51:41.910 --> 00:51:44.680
to reach out to me, here's
my contact information.

00:51:44.680 --> 00:51:46.340
I'm on Google+, Twitter.

00:51:46.340 --> 00:51:47.330
You can email me here.

00:51:47.330 --> 00:51:49.100
My website is jrvis.com.

00:51:49.100 --> 00:51:50.950
And a plug for [AUDIO OUT]

00:51:50.950 --> 00:51:53.120
I'm giving a hands-on web
performance optimization

00:51:53.120 --> 00:51:55.740
workshop, with my co-presenters
Sergey

00:51:55.740 --> 00:51:57.720
Chernyshev And Andy Davies.

00:51:57.720 --> 00:52:01.120
They're prominent figures in the
web performance world, and

00:52:01.120 --> 00:52:03.340
I'm very excited to be
speaking with them.

00:52:03.340 --> 00:52:06.550
And this is on Tuesday, June 18,
and it's in Santa Clara.

00:52:06.550 --> 00:52:09.130
So with that, thank you for
tuning in, and take care.

