WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:00.830
ILYA GRIGORIK: [INAUDIBLE].

00:00:00.830 --> 00:00:02.120
STEPHEN KONIG: Are we ready?

00:00:02.120 --> 00:00:03.470
OK, good morning, everybody.

00:00:03.470 --> 00:00:04.470
AUDIENCE: Morning.

00:00:04.470 --> 00:00:06.120
STEPHEN KONIG: Thank
you for joining us.

00:00:06.120 --> 00:00:09.130
We're here to talk to you guys
today about WebP, which is an

00:00:09.130 --> 00:00:12.760
image format we developed which
will allow us to deploy

00:00:12.760 --> 00:00:15.160
beautiful, faster, and smaller
images on the web.

00:00:15.160 --> 00:00:16.040
My name is Stephen Konig.

00:00:16.040 --> 00:00:17.950
I'm a product manager
here at Google

00:00:17.950 --> 00:00:19.640
working on the WebP team.

00:00:19.640 --> 00:00:20.990
ILYA GRIGORIK: And my name
is Ilya Grigorik.

00:00:20.990 --> 00:00:24.210
I'm a developer advocate on the
Make the Web Fast team at

00:00:24.210 --> 00:00:26.680
Google, where we work on WebP.

00:00:26.680 --> 00:00:29.730
So first of all, I guess to kick
it off-- why are we here?

00:00:29.730 --> 00:00:32.299
Why do we care about images,
image formats?

00:00:32.299 --> 00:00:35.150
And the answer is simply that
most of the bytes that we

00:00:35.150 --> 00:00:36.740
transfer in our applications,
in our web

00:00:36.740 --> 00:00:38.120
pages, are in fact images.

00:00:38.120 --> 00:00:41.260
If you look at the stats for a
desktop site, over 60% of the

00:00:41.260 --> 00:00:43.280
bytes that we transfer
are in images.

00:00:43.280 --> 00:00:45.270
So this is in addition
to HTML, CSS,

00:00:45.270 --> 00:00:46.270
and everything else.

00:00:46.270 --> 00:00:47.810
And on mobile, it's
even larger.

00:00:47.810 --> 00:00:48.710
So it's 70%.

00:00:48.710 --> 00:00:53.390
So optimizing images is
oftentimes the number one

00:00:53.390 --> 00:00:55.230
performance optimization
that you can do.

00:00:55.230 --> 00:00:57.780
And in fact, if you look at
stats, there's a great project

00:00:57.780 --> 00:00:59.420
called HTTP Archive.

00:00:59.420 --> 00:01:03.130
What HTTP Archive does is it
crawls over 300,000 sites on

00:01:03.130 --> 00:01:06.440
the web, top sites on the web,
and basically tracks how the

00:01:06.440 --> 00:01:07.460
pages are constructed.

00:01:07.460 --> 00:01:11.070
So it doesn't care about the
content of the pages, simply

00:01:11.070 --> 00:01:11.870
how they're constructed.

00:01:11.870 --> 00:01:13.640
So how much CSS are
we downloading?

00:01:13.640 --> 00:01:15.570
How many images are
we downloading?

00:01:15.570 --> 00:01:16.100
And the rest.

00:01:16.100 --> 00:01:19.650
And what you can see here is
that first of all, the trend

00:01:19.650 --> 00:01:20.860
is pretty clear.

00:01:20.860 --> 00:01:23.530
We are building more ambitious
and more complex applications.

00:01:23.530 --> 00:01:24.510
The size is growing.

00:01:24.510 --> 00:01:27.460
So in fact, on desktop, an
average site today is over 1

00:01:27.460 --> 00:01:30.170
megabyte in size, almost
200 kilobytes.

00:01:30.170 --> 00:01:31.970
And on mobile, it's a
little bit smaller.

00:01:31.970 --> 00:01:32.550
So that's good.

00:01:32.550 --> 00:01:35.046
It means that we're optimizing
for mobile experience and for

00:01:35.046 --> 00:01:35.740
mobile networks.

00:01:35.740 --> 00:01:37.540
But nonetheless,
700 kilobytes.

00:01:37.540 --> 00:01:38.860
But then you look at images.

00:01:38.860 --> 00:01:41.980
And you'll notice that most of
the requests are for images,

00:01:41.980 --> 00:01:44.260
both on desktop and on mobile.

00:01:44.260 --> 00:01:47.020
And the majority of the
bytes are in images.

00:01:47.020 --> 00:01:48.260
So this is why WebP matters.

00:01:48.260 --> 00:01:52.140
And of course, you heard Linus
at the keynote talking about

00:01:52.140 --> 00:01:55.680
WebP and how it can save
bytes for users.

00:01:55.680 --> 00:01:58.440
And saving bytes is also
important because bytes are

00:01:58.440 --> 00:02:00.320
literally expensive for
a lot of people.

00:02:00.320 --> 00:02:03.290
You can be charged up
to $1 per megabyte.

00:02:03.290 --> 00:02:05.797
If you've ever roamed with your
mobile data plan, you

00:02:05.797 --> 00:02:08.259
know how expensive
that can get.

00:02:08.259 --> 00:02:09.820
And it also affects
performance.

00:02:09.820 --> 00:02:11.280
So that's trend number one.

00:02:11.280 --> 00:02:14.010
We're building more ambitious
applications, transferring

00:02:14.010 --> 00:02:14.930
more bytes.

00:02:14.930 --> 00:02:17.590
Then, of course, you guys have
all been enjoying the

00:02:17.590 --> 00:02:21.490
beautiful Pixel screens,
right, HiDPI images.

00:02:21.490 --> 00:02:25.140
This is another trend that is
making this problem in some

00:02:25.140 --> 00:02:28.180
sense a lot worse for us, or
much harder, I should say.

00:02:28.180 --> 00:02:32.910
So the Chromebook Pixel
has 240 DPI.

00:02:32.910 --> 00:02:35.530
And what that means is we're
basically packing more

00:02:35.530 --> 00:02:37.710
physical pixels into
the screen.

00:02:37.710 --> 00:02:40.160
So to get these high-resolution
images, we

00:02:40.160 --> 00:02:42.040
also need to deliver more
pixels to get a

00:02:42.040 --> 00:02:43.190
high-resolution image.

00:02:43.190 --> 00:02:44.380
There's no magic here.

00:02:44.380 --> 00:02:46.380
You can't ship a low-resolution
image to a

00:02:46.380 --> 00:02:50.510
Chromebook Pixel and expect it
to display nice sharp edges

00:02:50.510 --> 00:02:51.200
across everything.

00:02:51.200 --> 00:02:52.920
We literally need to
ship more pixels.

00:02:52.920 --> 00:02:55.370
So if we're not careful, we're
just going to inflate all of

00:02:55.370 --> 00:02:57.410
the images by 4x because
we're shipping

00:02:57.410 --> 00:02:59.040
four times more pixels.

00:02:59.040 --> 00:03:01.250
Now hopefully, that's not
what we're going to do.

00:03:01.250 --> 00:03:04.610
And that's why WebP is here.

00:03:04.610 --> 00:03:08.060
So first and foremost, WebP
is about improving data

00:03:08.060 --> 00:03:09.000
compression.

00:03:09.000 --> 00:03:12.590
We want to make sure that we
build a faster web and a more

00:03:12.590 --> 00:03:13.800
beautiful web.

00:03:13.800 --> 00:03:14.610
But also--

00:03:14.610 --> 00:03:17.160
and we'll talk about this in
detail-- we want to make it

00:03:17.160 --> 00:03:19.700
simpler to deploy the beautiful
web, which is to

00:03:19.700 --> 00:03:22.590
say, today, we have a variety
of formats which we need to

00:03:22.590 --> 00:03:23.390
balance between.

00:03:23.390 --> 00:03:25.120
It's like, oh, you want
to do an animation.

00:03:25.120 --> 00:03:26.800
You need to use a GIF file.

00:03:26.800 --> 00:03:28.180
You want to have a
transparency--

00:03:28.180 --> 00:03:29.430
well, you've got to use a PNG.

00:03:29.430 --> 00:03:30.950
But then you can't animate it.

00:03:30.950 --> 00:03:33.470
And then if you want to have
lossy versus lossless

00:03:33.470 --> 00:03:36.790
compression, you kind of have
this annoying tree of options.

00:03:36.790 --> 00:03:40.280
And with WebP, we can actually
do all that and give you

00:03:40.280 --> 00:03:41.030
better compression.

00:03:41.030 --> 00:03:44.350
So it's kind of one format that
can achieve all of these

00:03:44.350 --> 00:03:45.866
great features.

00:03:45.866 --> 00:03:47.200
STEPHEN KONIG: So let's talk a
little bit about the history

00:03:47.200 --> 00:03:49.340
of WebP and where
it came from.

00:03:49.340 --> 00:03:53.240
You may have heard of our WebM
video and audio formats that

00:03:53.240 --> 00:03:55.050
we launched a couple
years ago.

00:03:55.050 --> 00:03:58.970
The video portion of WebM uses
VP8 as the video codec.

00:03:58.970 --> 00:04:01.530
And as part of the development
of VP8, someone actually

00:04:01.530 --> 00:04:05.670
noticed that hey, if I take a
key frame from a video stream,

00:04:05.670 --> 00:04:06.930
it offers really great
compression.

00:04:06.930 --> 00:04:08.700
And this would actually
be a really good basis

00:04:08.700 --> 00:04:09.920
for an image format.

00:04:09.920 --> 00:04:12.360
And so essentially, that's
how WebP got started.

00:04:12.360 --> 00:04:14.760
It was a sort of aha moment
from one of the

00:04:14.760 --> 00:04:16.320
engineers on our team.

00:04:16.320 --> 00:04:19.410
And so we adopted that
methodology as the basis for

00:04:19.410 --> 00:04:20.459
the WebP image format.

00:04:20.459 --> 00:04:23.390
So essentially, a WebP image
is nothing more than a key

00:04:23.390 --> 00:04:26.100
frame from a VP8 video stream.

00:04:26.100 --> 00:04:28.300
But it offers much better
compression than alternate

00:04:28.300 --> 00:04:30.260
technologies, as we'll see.

00:04:30.260 --> 00:04:32.510
Both WebP and WebM
are open-source,

00:04:32.510 --> 00:04:33.490
royalty-free formats.

00:04:33.490 --> 00:04:35.270
So you're free to deploy
them, use them.

00:04:35.270 --> 00:04:38.280
There's no fees you have to pay,
no licenses you have to

00:04:38.280 --> 00:04:39.450
sign up for.

00:04:39.450 --> 00:04:41.395
It's all ready to go
out of the box.

00:04:44.020 --> 00:04:46.390
So a little bit more in terms of
the timeline of how we got

00:04:46.390 --> 00:04:47.460
to where we are today.

00:04:47.460 --> 00:04:50.840
We did the initial release back
in 2010, which initially

00:04:50.840 --> 00:04:52.770
just supported lossy
compression, so basically an

00:04:52.770 --> 00:04:54.560
alternative for JPEG.

00:04:54.560 --> 00:04:57.620
In 2012, we followed that up
with support for both lossless

00:04:57.620 --> 00:05:00.870
and transparency, or alpha
channel support.

00:05:00.870 --> 00:05:02.600
So at that point, we became
an alternative

00:05:02.600 --> 00:05:03.790
potentially for PNG.

00:05:03.790 --> 00:05:06.480
And interestingly, one of the
things that we did here is we

00:05:06.480 --> 00:05:08.710
separated out transparency
from lossless.

00:05:08.710 --> 00:05:10.700
Because today, if you want to
have transparency, you have no

00:05:10.700 --> 00:05:12.290
choice really but use PNG.

00:05:12.290 --> 00:05:13.890
But that forces you to
also use lossless.

00:05:13.890 --> 00:05:15.990
And in some cases, you might
want transparency with lossy,

00:05:15.990 --> 00:05:18.050
which is something you
can't actually do.

00:05:18.050 --> 00:05:20.780
But you can with WebP, and
we'll talk about that.

00:05:20.780 --> 00:05:24.630
And then earlier this year, back
in April, we launched our

00:05:24.630 --> 00:05:26.780
most recent release, which
added support for color

00:05:26.780 --> 00:05:28.960
profile, animation,
and metadata.

00:05:28.960 --> 00:05:31.260
So really at this point, we have
a full set of features

00:05:31.260 --> 00:05:33.860
that allow us to be an
alternative replacement for

00:05:33.860 --> 00:05:38.290
both GIFs, PNGs, as
well as JPEGs.

00:05:38.290 --> 00:05:39.060
But we're not done yet.

00:05:39.060 --> 00:05:40.100
There's more work we're doing.

00:05:40.100 --> 00:05:43.040
And we're continuing to work
on improving the format.

00:05:43.040 --> 00:05:44.780
Top of the list are performance
optimizations.

00:05:44.780 --> 00:05:47.020
We'll talk about performance
in a little bit.

00:05:47.020 --> 00:05:49.590
And I think we offer a really
good performance for the

00:05:49.590 --> 00:05:50.880
features we provide today.

00:05:50.880 --> 00:05:52.370
But there's always room for
improvement, and we're going

00:05:52.370 --> 00:05:54.270
to continue to focus on that.

00:05:54.270 --> 00:05:57.070
And similarly, better support
for mobile on ARM devices--

00:05:57.070 --> 00:05:58.700
that's really sort of
code optimizations.

00:05:58.700 --> 00:06:01.360
We support a wide variety of
mobile devices in terms of

00:06:01.360 --> 00:06:03.060
Android and iOS today.

00:06:03.060 --> 00:06:05.430
But there's more work we can do
to make that even faster.

00:06:05.430 --> 00:06:07.580
And then looking ahead, some
of the other things we're

00:06:07.580 --> 00:06:09.720
thinking about are how can we
support higher color depth

00:06:09.720 --> 00:06:12.230
images, so more than eight
bits of color.

00:06:12.230 --> 00:06:14.720
How could we do things like add
layer support to support

00:06:14.720 --> 00:06:16.150
3D types of images?

00:06:16.150 --> 00:06:18.560
And even doing things like
progressive rendering.

00:06:18.560 --> 00:06:19.640
And I'm sure there'll
be other things.

00:06:19.640 --> 00:06:22.680
As the format becomes more
widely adopted and used, we

00:06:22.680 --> 00:06:23.990
expect there's going
to be feedback.

00:06:23.990 --> 00:06:25.840
And we'll take that into
consideration as well.

00:06:25.840 --> 00:06:27.620
ILYA GRIGORIK: So you heard
it here first--

00:06:27.620 --> 00:06:30.910
HiDPI, 3D progressive
rendering with WebP.

00:06:30.910 --> 00:06:32.110
STEPHEN KONIG: Exactly.

00:06:32.110 --> 00:06:33.990
Probably by Friday,
I'm guessing.

00:06:37.260 --> 00:06:40.280
So let's talk a little bit about
performance and how WebP

00:06:40.280 --> 00:06:42.690
actually does in the wild.

00:06:42.690 --> 00:06:44.590
So the first thing I wanted to
talk about is sort of let's do

00:06:44.590 --> 00:06:47.710
a little bit of a comparison
of WebP versus JPEG.

00:06:47.710 --> 00:06:49.940
And as Ilya mentioned, one of
the challenges we have on the

00:06:49.940 --> 00:06:54.280
web today is just the
predominance of images as a

00:06:54.280 --> 00:06:56.870
driver for how many bytes we're
sending down the wire

00:06:56.870 --> 00:06:59.140
and thus how fast our
pages render.

00:06:59.140 --> 00:07:01.670
So in the old world, in the
past, the only way you could

00:07:01.670 --> 00:07:04.160
really solve this problem was
to reduce your image quality

00:07:04.160 --> 00:07:05.850
if you're dealing with
JPEG images.

00:07:05.850 --> 00:07:07.820
So you have two examples
of JPEGs up there.

00:07:07.820 --> 00:07:09.580
The one on the top
is quality 80.

00:07:09.580 --> 00:07:11.790
The one on the bottom
is quality 10.

00:07:11.790 --> 00:07:14.970
And you might hopefully be able
to see that with quality

00:07:14.970 --> 00:07:16.660
10, you're getting very

00:07:16.660 --> 00:07:18.160
noticeable compression artifacts.

00:07:18.160 --> 00:07:20.490
The image looks very
visibly degraded.

00:07:20.490 --> 00:07:23.110
But the advantage is you're
going from a 1.3 megabyte

00:07:23.110 --> 00:07:25.260
image to a 200 K image.

00:07:25.260 --> 00:07:27.180
So if you were in a world where
you were like, I have to

00:07:27.180 --> 00:07:29.490
reduce the size of my images
because it's taking up too

00:07:29.490 --> 00:07:31.585
many bytes on my page, this
was literally only

00:07:31.585 --> 00:07:32.295
the option you had.

00:07:32.295 --> 00:07:34.260
But you had to trade off
visual quality in

00:07:34.260 --> 00:07:35.310
order to get it.

00:07:35.310 --> 00:07:37.350
And we think that's the
wrong tradeoff.

00:07:37.350 --> 00:07:40.070
WebP offers much better
compression than JPEG across

00:07:40.070 --> 00:07:40.910
all quality levels.

00:07:40.910 --> 00:07:42.920
So you're able to get the same
sort of benefit without

00:07:42.920 --> 00:07:45.060
reducing your image quality.

00:07:45.060 --> 00:07:48.220
And an illustration of that is
this chart, which shows you--

00:07:48.220 --> 00:07:51.630
for a number of images which
we did a sample on--

00:07:51.630 --> 00:07:55.680
for visual quality 20 all the
way up to 90, the file size

00:07:55.680 --> 00:07:56.990
for JPEG versus WebP.

00:07:56.990 --> 00:07:58.830
WebP is the one in
green below.

00:07:58.830 --> 00:08:01.980
And what you see is that for
all image quality levels,

00:08:01.980 --> 00:08:03.800
quality settings, WebP
is significantly

00:08:03.800 --> 00:08:05.130
smaller than JPEG.

00:08:05.130 --> 00:08:09.480
The one thing I'll note is
you'll see on the JPEG slide,

00:08:09.480 --> 00:08:11.900
right around quality 75, you'll
notice that the file

00:08:11.900 --> 00:08:14.380
size sort of grows exponentially
with JPEG.

00:08:14.380 --> 00:08:18.015
So it does pretty good, mostly
linear from below 75.

00:08:18.015 --> 00:08:22.070
But after that, image sizes get
pretty big pretty quickly.

00:08:22.070 --> 00:08:24.640
With WebP, you have a much
more linear progression.

00:08:24.640 --> 00:08:27.810
And so ironically, as you look
at higher quality images,

00:08:27.810 --> 00:08:29.910
which are important for the
reasons we just mentioned,

00:08:29.910 --> 00:08:31.680
WebP's benefit actually grows.

00:08:31.680 --> 00:08:35.100
So while on average, WebP is
about 30% smaller then JPEG,

00:08:35.100 --> 00:08:36.750
when you look at higher
quality images, the

00:08:36.750 --> 00:08:37.740
effect is even more.

00:08:37.740 --> 00:08:41.380
And so that's something
to keep in mind.

00:08:41.380 --> 00:08:44.570
So let's talk a little bit
about WebP versus PNG.

00:08:44.570 --> 00:08:47.280
So there are cases, obviously,
where you can't tolerate

00:08:47.280 --> 00:08:48.410
compression artifacts at all.

00:08:48.410 --> 00:08:50.130
So you're in a sort
of lossless mode.

00:08:50.130 --> 00:08:52.030
Or as I talked about earlier,
maybe you need to have

00:08:52.030 --> 00:08:53.500
transparency.

00:08:53.500 --> 00:08:57.050
And again, WebP is another great
alternative here because

00:08:57.050 --> 00:09:01.470
on average, we get about a 30%
file size reduction over PNG.

00:09:01.470 --> 00:09:04.540
But again, as I mentioned, one
of the features WebP has is

00:09:04.540 --> 00:09:08.250
that it allows you to have
lossy images with

00:09:08.250 --> 00:09:10.230
transparency, which is something
you can't really do

00:09:10.230 --> 00:09:12.630
today with PNG.

00:09:12.630 --> 00:09:15.030
So in cases where you have an
image that you're able to

00:09:15.030 --> 00:09:17.350
tolerate a little bit of
compression and artifacts--

00:09:17.350 --> 00:09:19.800
maybe you want a, say, quality
90, quality 80 type of image.

00:09:19.800 --> 00:09:21.260
But you need transparency.

00:09:21.260 --> 00:09:24.590
You can encode that in WebP
versus PNG and save even more.

00:09:24.590 --> 00:09:26.550
So in this chart, what you're
looking at is a series about

00:09:26.550 --> 00:09:30.350
1,000 PNGs that we compressed
both with WebP lossless, which

00:09:30.350 --> 00:09:30.940
is the purple.

00:09:30.940 --> 00:09:33.090
So that's again no
loss whatsoever.

00:09:33.090 --> 00:09:35.350
And then we recompressed them
again with lossy, but

00:09:35.350 --> 00:09:36.895
preserving the transparency.

00:09:36.895 --> 00:09:38.970
And what you see is that for
the vast, vast majority of

00:09:38.970 --> 00:09:41.680
images, we're significantly
smaller than the PNGs.

00:09:41.680 --> 00:09:42.960
And there's a couple of extreme

00:09:42.960 --> 00:09:45.070
examples at both tails.

00:09:45.070 --> 00:09:48.050
But obviously, the average
and median is

00:09:48.050 --> 00:09:49.520
strongly in favor of WebP.

00:09:49.520 --> 00:09:51.290
ILYA GRIGORIK: So I think a
very common use case is to

00:09:51.290 --> 00:09:54.470
have a lot of small PNGs for
things like icons, which need

00:09:54.470 --> 00:09:55.220
an alpha channel.

00:09:55.220 --> 00:09:56.240
And they're also very small.

00:09:56.240 --> 00:10:00.450
And that's where you can get up
to 80% or higher savings in

00:10:00.450 --> 00:10:02.475
terms of bytes, which is huge.

00:10:02.475 --> 00:10:03.725
STEPHEN KONIG: Yup, exactly.

00:10:07.560 --> 00:10:11.120
So the nice thing about WebP is
it allows you to be in this

00:10:11.120 --> 00:10:13.130
world in which you can really
stop caring about what image

00:10:13.130 --> 00:10:14.260
format you need to use.

00:10:14.260 --> 00:10:16.820
Today, you're in this mode of,
well, if I need animation, I

00:10:16.820 --> 00:10:17.650
have to use GIFs.

00:10:17.650 --> 00:10:19.930
And if I need lossless or
I need transparency,

00:10:19.930 --> 00:10:20.980
I have to use PNG.

00:10:20.980 --> 00:10:22.760
And if it's not one of
those things, I can

00:10:22.760 --> 00:10:24.590
probably use JPEG.

00:10:24.590 --> 00:10:27.280
But as a web developer, it
forces you to think through

00:10:27.280 --> 00:10:29.020
which image format
you have to use.

00:10:29.020 --> 00:10:30.810
With WebP, you don't have
to do that anymore.

00:10:30.810 --> 00:10:33.020
Literally, you can use every
image as WebP, because it

00:10:33.020 --> 00:10:34.230
supports all of those
features.

00:10:34.230 --> 00:10:36.410
And we think that's a great
benefit to web developers.

00:10:39.340 --> 00:10:42.110
So let's talk a little bit about
performance from the

00:10:42.110 --> 00:10:43.300
encoding and decoding side.

00:10:43.300 --> 00:10:45.900
So this is all great.

00:10:45.900 --> 00:10:47.970
WebP's a lot smaller, offers
great features.

00:10:47.970 --> 00:10:48.880
Where's the catch?

00:10:48.880 --> 00:10:50.990
Well, lunch isn't free,
despite the fact

00:10:50.990 --> 00:10:51.830
that we keep trying.

00:10:51.830 --> 00:10:53.410
We're not quite there yet.

00:10:53.410 --> 00:10:56.490
So you should know that WebP
is more expensive to encode

00:10:56.490 --> 00:10:57.000
and decode.

00:10:57.000 --> 00:10:59.020
But there are some reasons
I think why--

00:10:59.020 --> 00:11:02.200
sort of take these numbers
in context.

00:11:02.200 --> 00:11:04.870
On the encoding side, it takes
about 5 to 10 times longer to

00:11:04.870 --> 00:11:08.070
encode a WebP image than a
JPEG, which sounds pretty

00:11:08.070 --> 00:11:09.010
significant.

00:11:09.010 --> 00:11:10.770
But when you realize that
encoding is typically done

00:11:10.770 --> 00:11:11.550
only once--

00:11:11.550 --> 00:11:13.910
in the vast majority of cases,
you're dealing with a static

00:11:13.910 --> 00:11:14.950
image corpus.

00:11:14.950 --> 00:11:16.810
And you're encoding those
images one time.

00:11:16.810 --> 00:11:19.010
And you're doing it not in
your serving pipeline.

00:11:19.010 --> 00:11:20.430
You're doing that offline.

00:11:20.430 --> 00:11:23.020
And so if it takes an extra
couple CPU cycles to encode

00:11:23.020 --> 00:11:25.670
your WebP images, that really
shouldn't be something that

00:11:25.670 --> 00:11:27.900
would be a barrier
to WebP adoption.

00:11:27.900 --> 00:11:30.070
On the decoding side,
we're more

00:11:30.070 --> 00:11:31.110
computationally intensive.

00:11:31.110 --> 00:11:33.290
So yes, it takes more time
to decode a WebP image.

00:11:33.290 --> 00:11:35.960
And on average, we're about
1.3 times slower than a

00:11:35.960 --> 00:11:37.780
comparable JPEG.

00:11:37.780 --> 00:11:39.650
What we've seen, though, is that
in the vast majority of

00:11:39.650 --> 00:11:44.280
cases, unless you have a very
specific use case, the amount

00:11:44.280 --> 00:11:47.220
of time you're saving just by
virtue of the fewer bytes

00:11:47.220 --> 00:11:49.530
you're sending more than
makes up for the

00:11:49.530 --> 00:11:51.140
increased decode time.

00:11:51.140 --> 00:11:54.800
So that's something
to bear in mind.

00:11:54.800 --> 00:11:58.470
With that said, high encoding
costs can be a limitation in

00:11:58.470 --> 00:11:59.400
some use cases.

00:11:59.400 --> 00:12:02.590
And I'll give you one example
from Google as we've been

00:12:02.590 --> 00:12:04.530
trying to deploy WebP.

00:12:04.530 --> 00:12:07.880
So if you think about Maps,
map tiles are actually

00:12:07.880 --> 00:12:11.140
dynamically generated PNGs
that are based on the

00:12:11.140 --> 00:12:13.030
underlying raster data.

00:12:13.030 --> 00:12:16.310
When we actually tried to deploy
WebP instead of PNGs,

00:12:16.310 --> 00:12:20.220
what we found is that the
increasing encoding time,

00:12:20.220 --> 00:12:23.140
because those images are
generated dynamically, sort of

00:12:23.140 --> 00:12:25.530
negated a lot of the benefit
from the smaller file size.

00:12:25.530 --> 00:12:28.430
But that's a pretty special
case because there are no

00:12:28.430 --> 00:12:29.260
static map tiles.

00:12:29.260 --> 00:12:31.830
They're all generated at runtime
based on your request.

00:12:31.830 --> 00:12:34.930
So in that case, in that
particular instance, encoding

00:12:34.930 --> 00:12:36.340
is actually in the
serving pipeline.

00:12:36.340 --> 00:12:38.060
And so if you have a situation
like that, you should be

00:12:38.060 --> 00:12:38.950
mindful of these stats.

00:12:38.950 --> 00:12:41.000
But again, as I said, that's
really the exception.

00:12:41.000 --> 00:12:44.640
The vast majority of
cases are static.

00:12:44.640 --> 00:12:47.340
And then we talked a little bit
about bandwidth savings.

00:12:47.340 --> 00:12:51.630
But in addition to just raw time
to send fewer bytes, you

00:12:51.630 --> 00:12:53.730
have to be aware that a lot of
users, especially on mobile,

00:12:53.730 --> 00:12:55.210
actually have to pay for
their bandwidth.

00:12:55.210 --> 00:12:57.730
Either they're on metered plans
or capped plans, or

00:12:57.730 --> 00:12:58.690
they're roaming.

00:12:58.690 --> 00:13:01.210
And in some cases, it's
literally $1 per megabyte.

00:13:01.210 --> 00:13:03.880
So not only are you saving users
time and making your

00:13:03.880 --> 00:13:05.610
site faster for them and
giving them a better

00:13:05.610 --> 00:13:07.960
experience, you can literally
save them money.

00:13:07.960 --> 00:13:09.840
And so that's an important
consideration to

00:13:09.840 --> 00:13:11.020
keep in mind, as well.

00:13:11.020 --> 00:13:13.280
ILYA GRIGORIK: So the other
thing I'll add is we have the

00:13:13.280 --> 00:13:15.560
chicken and the egg problem
here with performance.

00:13:15.560 --> 00:13:19.310
Of course, there is also a
growing support for hardware--

00:13:19.310 --> 00:13:23.630
or sorry, hardware support is
improving for WebP and WebM.

00:13:23.630 --> 00:13:26.780
So we have WebM, which is
driving this trend, as well.

00:13:26.780 --> 00:13:31.010
So performance will get better
as more hardware deploys

00:13:31.010 --> 00:13:32.260
native support for it.

00:13:35.510 --> 00:13:38.060
So a good example of
this is actually--

00:13:38.060 --> 00:13:41.340
there's this tradeoff between
CPU and bandwidth.

00:13:41.340 --> 00:13:43.610
And one of the concerns, a valid
concern that a lot of

00:13:43.610 --> 00:13:45.060
people have is, great.

00:13:45.060 --> 00:13:47.300
So we're going to ship
these bytes faster.

00:13:47.300 --> 00:13:49.380
But if we take more time on
the client to decode the

00:13:49.380 --> 00:13:53.030
images, is that going to negate
all of the benefits?

00:13:53.030 --> 00:13:55.640
And the eBay team actually
just recently

00:13:55.640 --> 00:13:56.990
had this great study--

00:13:56.990 --> 00:13:58.965
I encourage you guys to
check out their blog.

00:13:58.965 --> 00:14:00.820
It's an eBay tech blog--

00:14:00.820 --> 00:14:02.820
where they compare a number of
different image formats.

00:14:02.820 --> 00:14:04.890
And they set up a test case
where they have an image

00:14:04.890 --> 00:14:06.940
gallery with 30 different
images.

00:14:06.940 --> 00:14:09.270
And they compared JPEG
versus WebP.

00:14:09.270 --> 00:14:11.090
And what you're seeing here
is a film strip which is

00:14:11.090 --> 00:14:13.880
basically 100-millisecond
increments, so 0.5

00:14:13.880 --> 00:14:15.590
seconds, 0.6, 0.7.

00:14:15.590 --> 00:14:17.530
And you're seeing the rendering
performance.

00:14:17.530 --> 00:14:19.240
So on the top, we have WebP.

00:14:19.240 --> 00:14:21.610
And even though it takes more
time to decode the WebP

00:14:21.610 --> 00:14:24.270
images, because we can ship
them faster, we can decode

00:14:24.270 --> 00:14:24.810
them faster.

00:14:24.810 --> 00:14:26.540
And we can display them
on the screen.

00:14:26.540 --> 00:14:27.840
So in this case, we're actually

00:14:27.840 --> 00:14:29.590
winning in both respects.

00:14:29.590 --> 00:14:32.100
We're getting better
visual performance.

00:14:32.100 --> 00:14:33.650
We're shipping fewer bytes.

00:14:33.650 --> 00:14:38.090
The user's paying less for
the bytes transferred.

00:14:38.090 --> 00:14:39.990
And we're paying less
for the bytes

00:14:39.990 --> 00:14:41.070
transferred from our server.

00:14:41.070 --> 00:14:42.990
So it's a win all around.

00:14:42.990 --> 00:14:46.140
And on this gallery, we were
able to compress it from 750

00:14:46.140 --> 00:14:48.490
kilobytes down to 474.

00:14:48.490 --> 00:14:51.060
So a really cool case study,
and I think it illustrates

00:14:51.060 --> 00:14:55.450
that a lot of our web apps can
benefit a lot from WebP.

00:14:55.450 --> 00:14:56.760
So we talked about
performance.

00:14:56.760 --> 00:14:59.680
Let's dive a little bit deeper
into tooling, into how do we

00:14:59.680 --> 00:15:03.340
actually create these files
and how do we serve them.

00:15:03.340 --> 00:15:06.740
So long story short, there
are plugins and

00:15:06.740 --> 00:15:07.980
converters that we provide.

00:15:07.980 --> 00:15:11.990
You can go to our site,
download the binary.

00:15:11.990 --> 00:15:14.700
And you have a cwebp and
a dwebp, which is an

00:15:14.700 --> 00:15:15.950
encoder and a decoder.

00:15:15.950 --> 00:15:17.400
And you can convert any image.

00:15:17.400 --> 00:15:19.880
We give you a lot of different
knobs-- if anything, there's

00:15:19.880 --> 00:15:20.990
too many knobs--

00:15:20.990 --> 00:15:23.410
to tweak the quality
and levels and

00:15:23.410 --> 00:15:24.540
all the other stuff.

00:15:24.540 --> 00:15:26.040
That's kind of the manual
way to do it.

00:15:26.040 --> 00:15:28.700
You can also get plugins
for all of the

00:15:28.700 --> 00:15:30.590
popular image editors.

00:15:30.590 --> 00:15:33.900
The Wikipedia page actually is
a great resource to start, if

00:15:33.900 --> 00:15:36.000
you want to get started
with WebP.

00:15:36.000 --> 00:15:39.630
They have a great matrix of all
the different tools out

00:15:39.630 --> 00:15:41.350
there and how to get
WebP support.

00:15:41.350 --> 00:15:44.310
And with time, as more people
adopt it, of course, this will

00:15:44.310 --> 00:15:45.310
also improve.

00:15:45.310 --> 00:15:47.610
And I'll also call out
a couple of tools

00:15:47.610 --> 00:15:49.390
like language bindings.

00:15:49.390 --> 00:15:52.730
So there are great libraries for
virtually every language

00:15:52.730 --> 00:15:53.620
runtime available.

00:15:53.620 --> 00:15:56.525
So you can do these
optimizations at build time or

00:15:56.525 --> 00:15:57.510
at runtime.

00:15:57.510 --> 00:15:59.750
And there's some other tools
which we'll demo

00:15:59.750 --> 00:16:01.350
a little bit later.

00:16:01.350 --> 00:16:04.260
In terms of the actual adoption
and support today, of

00:16:04.260 --> 00:16:06.160
course, Chrome supports WebP.

00:16:06.160 --> 00:16:08.310
Opera also supports WebP
and has been supporting

00:16:08.310 --> 00:16:09.710
WebP for a long time.

00:16:09.710 --> 00:16:13.250
We also ship native libraries,
or we make the native library

00:16:13.250 --> 00:16:14.470
available for iOS.

00:16:14.470 --> 00:16:16.910
And it's also supported
natively by Android.

00:16:16.910 --> 00:16:20.140
So you can deploy both on native
apps and on the web.

00:16:20.140 --> 00:16:24.980
There are ways to basically
polyfill support for WebP on

00:16:24.980 --> 00:16:25.700
other browsers.

00:16:25.700 --> 00:16:29.320
So you can actually have a
JavaScript decoder for WebP.

00:16:29.320 --> 00:16:31.280
I'm not saying that's
necessarily a great idea, but

00:16:31.280 --> 00:16:32.800
you could do it if
you wanted to.

00:16:32.800 --> 00:16:36.350
And we'll show you a couple of
examples of how to do perhaps

00:16:36.350 --> 00:16:37.990
a better deployment strategy.

00:16:37.990 --> 00:16:40.430
And of course, we're also
working with the Firefox team

00:16:40.430 --> 00:16:42.170
to get WebP supported.

00:16:42.170 --> 00:16:45.770
And fingers crossed, I hope
we will see it this year--

00:16:45.770 --> 00:16:48.730
sometime later this year.

00:16:48.730 --> 00:16:51.060
So let's start deploying
WebP on the web.

00:16:51.060 --> 00:16:53.040
Great-- we've motivated
the use case.

00:16:53.040 --> 00:16:54.530
We know that we should
be optimizing images.

00:16:54.530 --> 00:16:56.040
How do I even get started?

00:16:56.040 --> 00:16:58.920
And in a nutshell, there are a
couple different approaches.

00:16:58.920 --> 00:17:02.100
You can use server detection, or
server-side detection, and

00:17:02.100 --> 00:17:03.310
client detection.

00:17:03.310 --> 00:17:05.380
And we'll talk through
both paths.

00:17:05.380 --> 00:17:07.040
But one thing I'll point
out is they're

00:17:07.040 --> 00:17:08.910
not mutually exclusive.

00:17:08.910 --> 00:17:12.349
You can and probably should use
both, depending on your

00:17:12.349 --> 00:17:14.710
application.

00:17:14.710 --> 00:17:18.190
So the client-side detection
is an easy case.

00:17:18.190 --> 00:17:19.920
Basically, you just
want to test--

00:17:19.920 --> 00:17:21.630
the client loads some
JavaScript.

00:17:21.630 --> 00:17:25.089
And you want to find out if
the client supports WebP.

00:17:25.089 --> 00:17:27.329
Because then you can dynamically
inject the image

00:17:27.329 --> 00:17:29.460
tags and fetch the appropriate
asset.

00:17:29.460 --> 00:17:33.030
So you can have both a JPEG
and a WebP on your server.

00:17:33.030 --> 00:17:37.750
And for example, Modernizr
provides a one-line test

00:17:37.750 --> 00:17:39.970
function that you can run
to determine if a

00:17:39.970 --> 00:17:40.820
client supports it.

00:17:40.820 --> 00:17:43.200
If you actually unroll, and
you look at the underlying

00:17:43.200 --> 00:17:45.580
implementation, it's basically
three lines of

00:17:45.580 --> 00:17:46.540
JavaScript in there.

00:17:46.540 --> 00:17:47.740
They just inject an image tag.

00:17:47.740 --> 00:17:49.480
And they add an on load element
to make sure that the

00:17:49.480 --> 00:17:51.020
image is decoded properly.

00:17:51.020 --> 00:17:53.170
So you don't need Modernizr
to do this.

00:17:53.170 --> 00:17:55.340
You can just inline this
code directly.

00:17:55.340 --> 00:17:58.230
And I mentioned the JavaScript
decoder.

00:17:58.230 --> 00:17:59.870
You can use that as well.

00:17:59.870 --> 00:18:01.310
So in fact, if you only
want to serve

00:18:01.310 --> 00:18:03.360
WebPs, you can do that.

00:18:03.360 --> 00:18:07.290
It would just serve the
JavaScript decoder, and then

00:18:07.290 --> 00:18:10.200
your images would
load just fine.

00:18:10.200 --> 00:18:11.150
So that's client-side.

00:18:11.150 --> 00:18:13.970
Server-side is a little bit, I
think, more interesting and

00:18:13.970 --> 00:18:16.110
more scalable for a lot
of applications.

00:18:16.110 --> 00:18:20.570
So the way this works is when
the client makes a request for

00:18:20.570 --> 00:18:25.540
an image, it sends an Accept
header, which advertises which

00:18:25.540 --> 00:18:26.960
file types it supports.

00:18:26.960 --> 00:18:29.910
So this is very similar to, for
example, a compression.

00:18:29.910 --> 00:18:32.640
So gzip negotiation, where the
client advertises their

00:18:32.640 --> 00:18:35.430
support of gzip, and then the
server returns a response

00:18:35.430 --> 00:18:36.430
which is compressed.

00:18:36.430 --> 00:18:38.730
Similarly here, the
client advertises,

00:18:38.730 --> 00:18:40.150
hey, I support WebP.

00:18:40.150 --> 00:18:43.350
And then the server can select
the appropriate asset, in this

00:18:43.350 --> 00:18:44.730
case, a WebP file.

00:18:44.730 --> 00:18:50.520
So Opera provides the Accept
header, which advertises WebP.

00:18:50.520 --> 00:18:52.710
And we just recently landed
support in Chrome

00:18:52.710 --> 00:18:53.400
for that, as well.

00:18:53.400 --> 00:18:54.460
So it's currently in Canary.

00:18:54.460 --> 00:18:58.580
And it will be making it to
Stable soon, once we go

00:18:58.580 --> 00:18:59.890
through the release cycles.

00:18:59.890 --> 00:19:02.070
So with that, basically, your
server can just look at the

00:19:02.070 --> 00:19:04.200
Accept header and serve the
appropriate one, such that

00:19:04.200 --> 00:19:09.370
when, for example, an IE user
comes, they won't advertise

00:19:09.370 --> 00:19:11.140
WebP, for obvious reasons.

00:19:11.140 --> 00:19:13.060
And you can just serve
a PNG file.

00:19:13.060 --> 00:19:15.000
And this logic is handled
by the server.

00:19:15.000 --> 00:19:17.280
So you don't have to modify
your application.

00:19:17.280 --> 00:19:19.790
This is the best part.

00:19:19.790 --> 00:19:21.200
And I'll show you some
examples later

00:19:21.200 --> 00:19:23.210
in an actual demo.

00:19:23.210 --> 00:19:24.720
A slightly different
approach--

00:19:24.720 --> 00:19:27.000
and this is actually very
popular with a lot of web

00:19:27.000 --> 00:19:28.500
optimization products today--

00:19:28.500 --> 00:19:30.820
is to rely on user-agent
sniffing.

00:19:30.820 --> 00:19:33.490
So the reason this exists today
is because we didn't

00:19:33.490 --> 00:19:34.930
have the Accept header.

00:19:34.930 --> 00:19:36.020
So we're fixing this problem.

00:19:36.020 --> 00:19:38.170
We're making it much better
and easier to deploy.

00:19:38.170 --> 00:19:40.940
But you will find applications
or approaches that will use

00:19:40.940 --> 00:19:43.690
this strategy, where they will
check the user agent and say,

00:19:43.690 --> 00:19:46.100
hey, I know that Chrome
supports WebP.

00:19:46.100 --> 00:19:52.480
Hence I will serve the HTML
markup, which has WebP files

00:19:52.480 --> 00:19:55.340
embedded in it, or references
to WebP files.

00:19:55.340 --> 00:20:00.670
Whereas for Internet Explorer, I
will serve the JPEG version.

00:20:00.670 --> 00:20:04.130
So then there's a couple of
other quirks that you need to

00:20:04.130 --> 00:20:06.050
worry about-- for example,
caching.

00:20:06.050 --> 00:20:09.010
If now we're generating multiple
versions of the HTML,

00:20:09.010 --> 00:20:11.660
one with WebPs and one with
JPEGs, how do we make sure

00:20:11.660 --> 00:20:15.430
that the IE user agent doesn't
get the WebP assets?

00:20:15.430 --> 00:20:18.730
This is why we're marking this
document as private, which is

00:20:18.730 --> 00:20:21.270
to say, the client
can cache it, but

00:20:21.270 --> 00:20:22.970
intermediate servers can't.

00:20:22.970 --> 00:20:26.810
So some intermediate proxy
can't cache it.

00:20:26.810 --> 00:20:31.780
So those are the kind of
do-it-yourself approaches.

00:20:31.780 --> 00:20:34.185
The good news is we actually
provide tools that will do all

00:20:34.185 --> 00:20:35.470
of this work for you.

00:20:35.470 --> 00:20:39.000
So we have a PageSpeed product--
or family of

00:20:39.000 --> 00:20:40.870
products, I should say-- which
are both open source.

00:20:40.870 --> 00:20:43.320
We have modules available
for Apache and nginx.

00:20:43.320 --> 00:20:45.260
And we also have a Google
hosted version, which is

00:20:45.260 --> 00:20:46.350
PageSpeed Service.

00:20:46.350 --> 00:20:48.870
So let me show you guys
an example of

00:20:48.870 --> 00:20:50.460
this actually in action.

00:20:50.460 --> 00:20:52.020
So I have--

00:20:52.020 --> 00:20:54.590
I'll make this a little
bit smaller.

00:20:54.590 --> 00:20:56.350
On my blog, I have
a little gallery

00:20:56.350 --> 00:20:58.460
of my favorite photos--

00:20:58.460 --> 00:21:03.000
beautiful images, or at least
I think they are.

00:21:03.000 --> 00:21:04.940
And you can see here
that I have

00:21:04.940 --> 00:21:06.840
Tokyo, Oxford, and Aurora.

00:21:06.840 --> 00:21:08.860
And they're about 3 megs.

00:21:08.860 --> 00:21:10.350
Now, I'm serving them as PNGs.

00:21:10.350 --> 00:21:14.670
That's just how I happened to
have saved them on my server.

00:21:14.670 --> 00:21:16.750
3 megs is probably
a little high.

00:21:16.750 --> 00:21:18.080
So I think we can do better.

00:21:18.080 --> 00:21:19.650
So I'm also running
PageSpeed Service.

00:21:19.650 --> 00:21:22.620
And the way PageSpeed Service
works is I have my origin

00:21:22.620 --> 00:21:26.950
server, where all
my markup lives.

00:21:26.950 --> 00:21:30.870
But my WWW domain is actually
routed through Google servers,

00:21:30.870 --> 00:21:32.980
such that when you visit my
site, you actually hit a

00:21:32.980 --> 00:21:35.110
Google server, which then
fetches my content.

00:21:35.110 --> 00:21:38.180
It optimizes it and serves
the optimized assets.

00:21:38.180 --> 00:21:39.760
So let me show you
the dashboard

00:21:39.760 --> 00:21:41.700
for PageSpeed Service.

00:21:41.700 --> 00:21:44.670
We have the overview here.

00:21:44.670 --> 00:21:46.800
So this is my server,
Google servers.

00:21:46.800 --> 00:21:52.680
And then the visitor is hitting
the Google servers.

00:21:52.680 --> 00:21:54.280
And all of the magic
happens here.

00:21:54.280 --> 00:21:56.320
So we provide a number of
optimization for things like

00:21:56.320 --> 00:21:59.300
let us optimize your CSS, your
JavaScript, and all the rest.

00:21:59.300 --> 00:22:02.590
And optimizing images, for the
reasons that we mentioned

00:22:02.590 --> 00:22:04.270
previously, is a
big part of it.

00:22:04.270 --> 00:22:06.610
So in here, you can see that I
can enable a whole bunch of

00:22:06.610 --> 00:22:09.130
checkboxes for things like
resizing images on the server.

00:22:09.130 --> 00:22:10.870
So I'm just going to
click that on.

00:22:10.870 --> 00:22:14.130
And I'm going to also convert
PNGs to JPEGs.

00:22:14.130 --> 00:22:17.030
Or I'm going to allow it
to try to convert.

00:22:17.030 --> 00:22:18.200
It won't necessarily do it.

00:22:18.200 --> 00:22:21.770
It will try to make sure that
we get better compression.

00:22:21.770 --> 00:22:25.140
And let's apply that
to the site.

00:22:25.140 --> 00:22:26.260
And let's go back.

00:22:26.260 --> 00:22:28.060
And we will refresh this page.

00:22:28.060 --> 00:22:29.870
And we will actually refresh
it twice, because the way

00:22:29.870 --> 00:22:33.250
PageSpeed Service works is it
optimizes these images on

00:22:33.250 --> 00:22:35.730
demand and in the background
such that on the second

00:22:35.730 --> 00:22:38.270
request, you can see that the
file names have changed.

00:22:38.270 --> 00:22:40.440
And they are now coming
through as JPEGs.

00:22:40.440 --> 00:22:42.480
So what we have done is we have
optimized these images in

00:22:42.480 --> 00:22:42.760
the background.

00:22:42.760 --> 00:22:45.250
We've determined that
JPEGs are a better

00:22:45.250 --> 00:22:46.520
version of this file.

00:22:46.520 --> 00:22:48.500
So we went from multiple
megabytes

00:22:48.500 --> 00:22:50.210
to hundreds of kilobytes.

00:22:50.210 --> 00:22:52.600
So now the page is
468 kilobytes.

00:22:52.600 --> 00:22:53.850
So this is done automatically.

00:22:53.850 --> 00:22:56.420
I didn't modify my
app in any way.

00:22:56.420 --> 00:23:00.560
And similarly, I can go
into the API console.

00:23:00.560 --> 00:23:02.340
And I'm just going
to enable it all.

00:23:02.340 --> 00:23:05.570
So I'm going to recompress JPEGs
and allow it to compress

00:23:05.570 --> 00:23:09.130
it to WebP as well.

00:23:09.130 --> 00:23:11.230
So once again, Apply to Live.

00:23:11.230 --> 00:23:14.310
And we'll reload the page
a few more times.

00:23:14.310 --> 00:23:17.960
And it's going to now try both
JPEG and WebP and pick the

00:23:17.960 --> 00:23:19.930
best format for these images.

00:23:19.930 --> 00:23:22.170
And you can see that it actually
determined that WebP

00:23:22.170 --> 00:23:23.300
is the best format.

00:23:23.300 --> 00:23:25.900
It detected that I'm
running Chrome.

00:23:25.900 --> 00:23:28.240
And now it's serving these
images, which went from a

00:23:28.240 --> 00:23:30.580
megabyte plus to 80 kilobytes.

00:23:30.580 --> 00:23:34.230
So in total, the file size of
this page is 328 kilobytes.

00:23:34.230 --> 00:23:37.540
So we've just decreased the
size of this page by 10x

00:23:37.540 --> 00:23:40.440
without actually touching the
page itself, which, of course,

00:23:40.440 --> 00:23:40.990
is beautiful.

00:23:40.990 --> 00:23:44.540
And notice that this
was all images.

00:23:44.540 --> 00:23:47.130
So you can use PageSpeed
Service, which is

00:23:47.130 --> 00:23:48.690
what you saw here.

00:23:48.690 --> 00:23:52.160
Or you can use one of our
open-source modules like

00:23:52.160 --> 00:23:55.850
Apache or the nginx module
to do this for you.

00:23:55.850 --> 00:23:56.750
STEPHEN KONIG: So let's talk
a little bit about

00:23:56.750 --> 00:23:57.895
interoperability.

00:23:57.895 --> 00:23:59.760
I think it's fair to say we live
in a world in which WebP

00:23:59.760 --> 00:24:00.890
isn't ubiquitous yet.

00:24:00.890 --> 00:24:01.690
We hope we'll get there.

00:24:01.690 --> 00:24:03.310
We're confident we'll
get there.

00:24:03.310 --> 00:24:06.270
But just like previous formats
before us, like PNG, there's

00:24:06.270 --> 00:24:10.880
this sort of uncanny valley of
time where you have mixed

00:24:10.880 --> 00:24:12.520
support across the web.

00:24:12.520 --> 00:24:14.720
And you have to deal
with that today.

00:24:14.720 --> 00:24:16.120
In fact, some of you
may have seen--

00:24:16.120 --> 00:24:18.190
a couple weeks ago, Facebook
actually did a field trial

00:24:18.190 --> 00:24:21.800
where they actually started
serving user photos as WebP

00:24:21.800 --> 00:24:23.880
instead of as JPEGs.

00:24:23.880 --> 00:24:25.550
It generated a slight
bit of controversy.

00:24:25.550 --> 00:24:28.060
Actually, I think overall, from
what we know, they're

00:24:28.060 --> 00:24:30.250
very pleased with the
results they saw.

00:24:30.250 --> 00:24:32.220
But it did highlight some
interoperability challenges

00:24:32.220 --> 00:24:34.470
that you have to be aware of and
for which we think there

00:24:34.470 --> 00:24:35.700
are some good solutions.

00:24:35.700 --> 00:24:37.640
That said, this is a
short-term problem.

00:24:37.640 --> 00:24:40.360
And just like PNG eventually
got ubiquitous support, we

00:24:40.360 --> 00:24:41.910
feel confident WebP
will as well.

00:24:41.910 --> 00:24:43.010
And a lot of these issues
will go away.

00:24:43.010 --> 00:24:44.470
But in the short term,
these are some

00:24:44.470 --> 00:24:45.490
things to be aware of.

00:24:45.490 --> 00:24:46.930
So link sharing is one.

00:24:46.930 --> 00:24:49.040
So I look at my beautiful
site.

00:24:49.040 --> 00:24:50.230
I see this awesome
image in WebP.

00:24:50.230 --> 00:24:51.500
I'm running Chrome or Opera.

00:24:51.500 --> 00:24:52.400
It looks beautiful.

00:24:52.400 --> 00:24:54.610
I right-click, copy
link to image.

00:24:54.610 --> 00:24:56.020
I paste it in an email
to my wife.

00:24:56.020 --> 00:24:57.650
And I say, honey, this
is really cool.

00:24:57.650 --> 00:24:58.900
You should check it out.

00:24:58.900 --> 00:25:00.460
She happens to be
running Firefox.

00:25:00.460 --> 00:25:03.295
And she clicks the link,
and sad face.

00:25:03.295 --> 00:25:06.150
Because it can't decode
a WebP image.

00:25:06.150 --> 00:25:08.670
So a good way to solve this
problem is the Accept header

00:25:08.670 --> 00:25:10.770
negotiation that we talked
about earlier.

00:25:10.770 --> 00:25:12.830
Because in that case, what the
server will see when it gets

00:25:12.830 --> 00:25:16.340
the request, even if it has a
.webp attachment to it, it

00:25:16.340 --> 00:25:19.700
won't see the image/webp
in the Accept header.

00:25:19.700 --> 00:25:22.160
It will know it's not safe to
return WebP to that client.

00:25:22.160 --> 00:25:24.250
And in that case, you can
actually return a JPEG.

00:25:24.250 --> 00:25:26.510
It doesn't matter what
the extension is.

00:25:26.510 --> 00:25:29.700
You can serve the right image
format based on Accept header.

00:25:29.700 --> 00:25:31.450
Similarly, there's an
issue with Save As.

00:25:31.450 --> 00:25:33.310
Right click an image,
Save As to disk.

00:25:33.310 --> 00:25:35.920
And then I email it to somebody,
or I happen to just

00:25:35.920 --> 00:25:38.050
double-click it from
my File Explorer.

00:25:38.050 --> 00:25:40.760
And oops, I don't have an image
viewer that's capable of

00:25:40.760 --> 00:25:41.240
rendering that.

00:25:41.240 --> 00:25:43.970
Or the person I send it to
doesn't have one, either.

00:25:43.970 --> 00:25:46.440
So there's a couple of ways to
fix that, one of which we've

00:25:46.440 --> 00:25:47.250
already taken care of.

00:25:47.250 --> 00:25:49.530
So starting with M28, Chrome is
actually a file handler on

00:25:49.530 --> 00:25:50.610
all platforms for WebP.

00:25:50.610 --> 00:25:52.250
So if the user has Chrome,
they'll at least be able to

00:25:52.250 --> 00:25:54.020
open a WebP file.

00:25:54.020 --> 00:25:56.090
But another sort of approach
to this is to provide an

00:25:56.090 --> 00:25:59.620
explicit download option link
and have that always serve a

00:25:59.620 --> 00:26:02.870
common format such
as a JPEG or PNG.

00:26:02.870 --> 00:26:04.810
There's some user experience
benefits to that as well.

00:26:04.810 --> 00:26:06.950
Because the image that the user
sees on the screen might

00:26:06.950 --> 00:26:08.170
not be the one that
you want to have

00:26:08.170 --> 00:26:09.440
them ability to download.

00:26:09.440 --> 00:26:11.490
For example, they might want to
download a full-resolution

00:26:11.490 --> 00:26:13.920
version of the image versus
something that's scaled down.

00:26:13.920 --> 00:26:15.230
So there's some other
reasons why that

00:26:15.230 --> 00:26:16.480
approach might make sense.

00:26:18.870 --> 00:26:21.650
Let's look at a few case studies
in the wild and see

00:26:21.650 --> 00:26:25.530
some of the benefits we've
gotten from WebP.

00:26:25.530 --> 00:26:28.640
So earlier this year, we posted
a blog post about some

00:26:28.640 --> 00:26:29.820
work we did on the
Chrome Web Store.

00:26:29.820 --> 00:26:31.390
So for those of you who aren't
familiar with it, Chrome Web

00:26:31.390 --> 00:26:32.500
Store is a great site.

00:26:32.500 --> 00:26:34.520
Lets you browse tons of add-ons,
extensions, and

00:26:34.520 --> 00:26:36.230
applications for Chrome.

00:26:36.230 --> 00:26:37.740
But it's a very image-heavy
site--

00:26:37.740 --> 00:26:41.180
tons of promotional tiles, big
tiles, little tiles, tiles

00:26:41.180 --> 00:26:41.970
rotating in and out.

00:26:41.970 --> 00:26:45.360
It's a gorgeous site, but it's
definitely very image-heavy.

00:26:45.360 --> 00:26:47.780
So we went through a process
of converting all of those

00:26:47.780 --> 00:26:49.520
images to WebP and
serving them to

00:26:49.520 --> 00:26:50.780
Chrome and Opera users.

00:26:50.780 --> 00:26:53.200
When we did that, we got an
average 30% reduction in image

00:26:53.200 --> 00:26:55.210
size across all the images
on the site.

00:26:55.210 --> 00:26:56.910
But more importantly,
we reduced page

00:26:56.910 --> 00:26:58.970
load time by a third.

00:26:58.970 --> 00:27:00.500
And that was pretty
significant.

00:27:00.500 --> 00:27:02.590
And it really, at the end of the
day, turned out to be not

00:27:02.590 --> 00:27:04.170
a tremendous amount of work.

00:27:04.170 --> 00:27:07.410
Really, we just request-- we
have a server that serves

00:27:07.410 --> 00:27:08.070
image assets.

00:27:08.070 --> 00:27:09.390
It's capable of doing
transcoding.

00:27:09.390 --> 00:27:11.710
And then we just tell it, hey,
if the user is Chrome or

00:27:11.710 --> 00:27:13.120
Opera, serve WebP.

00:27:13.120 --> 00:27:17.590
And magically, things start
getting faster very easy.

00:27:17.590 --> 00:27:19.275
And one example is
the calendar tile

00:27:19.275 --> 00:27:20.180
that you see here--

00:27:20.180 --> 00:27:22.210
two versions of the same tile.

00:27:22.210 --> 00:27:26.630
One is 32 and one is 8.3 K. So
tremendous difference with

00:27:26.630 --> 00:27:28.530
very little plumbing work
that was needed

00:27:28.530 --> 00:27:31.430
to get that to happen.

00:27:31.430 --> 00:27:34.110
And we're in the process of
deploying WebP across all

00:27:34.110 --> 00:27:35.460
Google sites that
serve images.

00:27:35.460 --> 00:27:36.780
So some of these are
supported today.

00:27:36.780 --> 00:27:39.100
Others you will see support
rolling out across

00:27:39.100 --> 00:27:39.710
the rest of the year.

00:27:39.710 --> 00:27:41.610
Some of them are in various
stages of experimental and

00:27:41.610 --> 00:27:42.740
field trial.

00:27:42.740 --> 00:27:46.650
But literally across the gamut
of sites across Google, we are

00:27:46.650 --> 00:27:48.070
in the process of doing
all this transition.

00:27:48.070 --> 00:27:49.890
And we'll be doing that
throughout the

00:27:49.890 --> 00:27:50.410
course of the year.

00:27:50.410 --> 00:27:53.570
We'll talk about one more
of them in a moment.

00:27:53.570 --> 00:27:55.550
ILYA GRIGORIK: So we're
definitely dogfooding a lot of

00:27:55.550 --> 00:27:58.410
the WebP deployment
strategies today.

00:27:58.410 --> 00:28:01.030
And one great example is
actually data compression.

00:28:01.030 --> 00:28:04.560
So once again, if you saw the
keynotes, Linus actually

00:28:04.560 --> 00:28:06.350
talked about this, where
we now have a

00:28:06.350 --> 00:28:07.900
new feature in Chrome.

00:28:07.900 --> 00:28:09.120
And if you haven't tried
it, we definitely

00:28:09.120 --> 00:28:09.880
encourage you to.

00:28:09.880 --> 00:28:12.980
If you go to the Apps Store and
download Chrome Beta, you

00:28:12.980 --> 00:28:14.980
can go into your settings.

00:28:14.980 --> 00:28:16.570
There's a new tab called
Bandwidth Management.

00:28:16.570 --> 00:28:18.990
It can basically enable Chrome
data compression.

00:28:18.990 --> 00:28:22.460
So the way that works is when
you make a request, we will

00:28:22.460 --> 00:28:24.910
actually route the request to
a Google server, which will

00:28:24.910 --> 00:28:28.230
then fetch the content and all
the associated images,

00:28:28.230 --> 00:28:30.720
compress it, minify it, optimize
it, and then deliver

00:28:30.720 --> 00:28:34.210
the optimized version to your
site or to your phone, rather.

00:28:34.210 --> 00:28:37.960
And we find that we get, on
average, 50% data reduction

00:28:37.960 --> 00:28:38.740
when we do that.

00:28:38.740 --> 00:28:40.820
So this is a huge benefit
to the user.

00:28:40.820 --> 00:28:42.390
And guess what?

00:28:42.390 --> 00:28:45.100
Images are once again the
number one optimization.

00:28:45.100 --> 00:28:47.410
So in fact, one of the big
optimizations that we do in

00:28:47.410 --> 00:28:53.720
Flywheel or data compression is
just re-encoding literally

00:28:53.720 --> 00:28:55.360
every single image to WebP.

00:28:55.360 --> 00:28:57.180
We just transcode everything
to WebP.

00:28:57.180 --> 00:29:03.230
And that helps reduce the
data usage quite a bit.

00:29:03.230 --> 00:29:04.510
This is a great site.

00:29:04.510 --> 00:29:06.190
I love to share this site.

00:29:06.190 --> 00:29:09.010
Let's actually look at
a demo to appreciate

00:29:09.010 --> 00:29:11.900
it in all its glory.

00:29:11.900 --> 00:29:14.830
So this is a beautiful animation
built by Oakley.

00:29:14.830 --> 00:29:16.550
So as I'm scrolling
down, we have this

00:29:16.550 --> 00:29:17.810
beautiful parallax effect.

00:29:17.810 --> 00:29:20.480
We have animations coming
in and out.

00:29:20.480 --> 00:29:24.150
This is using HTML5, lots
of images, nothing

00:29:24.150 --> 00:29:25.900
special under the hood.

00:29:25.900 --> 00:29:29.710
But the one trick to
this page is--

00:29:29.710 --> 00:29:31.910
let's just reload it here.

00:29:31.910 --> 00:29:35.450
This is where we definitely
need a good connection.

00:29:38.820 --> 00:29:39.020
Let's see.

00:29:39.020 --> 00:29:40.250
100%--

00:29:40.250 --> 00:29:42.080
here we come.

00:29:42.080 --> 00:29:46.330
86 megabytes of images to
deliver this great experience.

00:29:46.330 --> 00:29:48.220
So the way the site is built--

00:29:48.220 --> 00:29:49.470
and it's a beautiful
experience.

00:29:49.470 --> 00:29:50.600
I love it--

00:29:50.600 --> 00:29:54.820
is it's delivering a lot of PNGs
with transparencies in

00:29:54.820 --> 00:29:55.510
the background.

00:29:55.510 --> 00:29:59.340
And so as you move, these are
basically layers that are

00:29:59.340 --> 00:30:03.270
being positioned right
within the browser.

00:30:03.270 --> 00:30:06.240
So 86 megs is quite heavy.

00:30:06.240 --> 00:30:09.100
So as just an experiment, we
said, look, WebP can probably

00:30:09.100 --> 00:30:10.620
do a bit better,
especially with

00:30:10.620 --> 00:30:12.380
transparency, as you guys heard.

00:30:12.380 --> 00:30:15.800
So we can take the 86 meg,
without any modifications to

00:30:15.800 --> 00:30:19.280
the site, and convert
it to 28 megs.

00:30:19.280 --> 00:30:21.070
So let's be clear.

00:30:21.070 --> 00:30:24.860
28 megs is still massive
for a web page.

00:30:24.860 --> 00:30:28.930
But it's 60 or 58 megabytes
less, which is

00:30:28.930 --> 00:30:32.620
pretty good, I think.

00:30:32.620 --> 00:30:37.250
And so some cool tools or some
tips for getting started.

00:30:37.250 --> 00:30:40.050
And if you just want to
experiment with WebP, there's

00:30:40.050 --> 00:30:40.860
a great service.

00:30:40.860 --> 00:30:43.350
It's a free service called
IMG2WebP.net.

00:30:43.350 --> 00:30:44.590
You can just go there.

00:30:44.590 --> 00:30:47.990
You can drag in an image, any
image off your local file

00:30:47.990 --> 00:30:49.700
system, and just play
with the settings.

00:30:49.700 --> 00:30:51.580
And you have a bunch
of sliders.

00:30:51.580 --> 00:30:53.200
And you can see the
output without

00:30:53.200 --> 00:30:54.750
installing any other tools.

00:30:54.750 --> 00:30:56.960
So this is not something that
you want to use to convert all

00:30:56.960 --> 00:30:58.330
of your images to
WebP, but it's a

00:30:58.330 --> 00:30:59.950
great way to get started.

00:30:59.950 --> 00:31:02.600
If you're on Windows, there's
a great new tool that was

00:31:02.600 --> 00:31:05.080
released just a couple of weeks
ago where you can punch

00:31:05.080 --> 00:31:08.310
in the name of the site or
just the URL of the site.

00:31:08.310 --> 00:31:09.990
It'll download your site.

00:31:09.990 --> 00:31:12.860
And it'll recompress all the
images with WebP and basically

00:31:12.860 --> 00:31:17.020
give you a report card saying,
if you converted to WebP with

00:31:17.020 --> 00:31:21.490
these settings, then you would
save this amount of bytes.

00:31:21.490 --> 00:31:23.520
And you can actually change and
tweak the settings, which

00:31:23.520 --> 00:31:24.210
is the cool part.

00:31:24.210 --> 00:31:26.790
So you can change your
compression quality levels and

00:31:26.790 --> 00:31:27.480
all the rest.

00:31:27.480 --> 00:31:28.660
STEPHEN KONIG: And it lets
you see your site

00:31:28.660 --> 00:31:30.220
with WebP as well.

00:31:30.220 --> 00:31:32.020
So you can actually do a little
side by side visual

00:31:32.020 --> 00:31:32.530
comparison.

00:31:32.530 --> 00:31:34.080
ILYA GRIGORIK: So
awesome tool.

00:31:34.080 --> 00:31:34.860
Definitely check it out.

00:31:34.860 --> 00:31:37.690
And then finally, if you're
ready to start converting your

00:31:37.690 --> 00:31:41.900
images, as Stephen mentioned,
you can do that at deploy time

00:31:41.900 --> 00:31:42.960
or at build time.

00:31:42.960 --> 00:31:46.360
There's a number of great
plugins for things like Grunt

00:31:46.360 --> 00:31:50.480
and other build tools which can
run at build time and just

00:31:50.480 --> 00:31:51.910
convert all of your images
and make them

00:31:51.910 --> 00:31:53.160
available on the server.

00:31:56.730 --> 00:31:57.360
STEPHEN KONIG: So let's
talk a little bit

00:31:57.360 --> 00:31:59.122
about WebP on mobile.

00:31:59.122 --> 00:32:02.074
Full screen.

00:32:02.074 --> 00:32:04.230
Oh, I want to go
to full screen.

00:32:07.230 --> 00:32:09.150
So we talked a lot about
deploying it on sort of the

00:32:09.150 --> 00:32:09.860
desktop web.

00:32:09.860 --> 00:32:12.010
The good news is there are great
ways to deploy this on

00:32:12.010 --> 00:32:14.080
the mobile web as well, on our
mobile devices for native

00:32:14.080 --> 00:32:14.850
applications.

00:32:14.850 --> 00:32:16.000
We'll talk a little
bit about that.

00:32:16.000 --> 00:32:17.220
One case study--

00:32:17.220 --> 00:32:20.040
so the Google+ app, today on
Android, and actually for

00:32:20.040 --> 00:32:23.840
about the last month or so, has
been serving WebP images.

00:32:23.840 --> 00:32:25.340
So you probably haven't
noticed.

00:32:25.340 --> 00:32:30.550
And that's actually the point,
that you're getting faster

00:32:30.550 --> 00:32:34.040
performance and faster loads
for the same quality image,

00:32:34.040 --> 00:32:35.120
and you didn't have
to do anything.

00:32:35.120 --> 00:32:36.370
And that's the whole idea.

00:32:36.370 --> 00:32:39.880
But starting about a month and a
half ago, we've been serving

00:32:39.880 --> 00:32:43.180
WebP images to users of
the G+ app on Android.

00:32:43.180 --> 00:32:45.500
On average, we've been actually
seeing about a 50%

00:32:45.500 --> 00:32:47.810
reduction in image
sizes with WebP.

00:32:47.810 --> 00:32:49.610
And the reason for that is WebP
actually does a pretty

00:32:49.610 --> 00:32:52.990
good job with user-generated
photos as opposed to other

00:32:52.990 --> 00:32:55.310
types of images, especially
with photos.

00:32:55.310 --> 00:32:58.030
So that's why we're able to
get even more than typical

00:32:58.030 --> 00:32:59.030
kinds of savings.

00:32:59.030 --> 00:33:01.100
We're literally, as a result
of that change, saving many

00:33:01.100 --> 00:33:02.970
terabytes of bandwidth
per day.

00:33:02.970 --> 00:33:05.640
And literally also because of
the cost factor-- we're saving

00:33:05.640 --> 00:33:06.730
our users money.

00:33:06.730 --> 00:33:09.250
So it's cheaper to use this app
now than it was before.

00:33:09.250 --> 00:33:12.580
And I think that's a
pretty cool win.

00:33:12.580 --> 00:33:14.300
So how would you deploy
this on Android?

00:33:14.300 --> 00:33:16.210
So the code you see here is
actually using the native

00:33:16.210 --> 00:33:19.270
library, which is supported on
all versions of Android.

00:33:19.270 --> 00:33:23.330
So WebP support is baked in at
the OS level, starting with

00:33:23.330 --> 00:33:24.680
ICS and above.

00:33:24.680 --> 00:33:27.150
But if you want to be able to
target versions of Android

00:33:27.150 --> 00:33:28.250
prior to that, you
can use a native

00:33:28.250 --> 00:33:29.300
library that we provide.

00:33:29.300 --> 00:33:30.030
So it's pretty simple.

00:33:30.030 --> 00:33:31.280
Basically, you get
a WebP image.

00:33:31.280 --> 00:33:32.140
You decode it as a bitmap.

00:33:32.140 --> 00:33:33.460
And then you render it.

00:33:33.460 --> 00:33:34.960
So I'll let you guys read
through all the code.

00:33:34.960 --> 00:33:37.180
But that's pretty much
the process-- pretty

00:33:37.180 --> 00:33:37.435
straightforward.

00:33:37.435 --> 00:33:38.930
ILYA GRIGORIK: I think the
point here is that it's

00:33:38.930 --> 00:33:40.760
actually no different from
any other image.

00:33:40.760 --> 00:33:42.470
STEPHEN KONIG: Exactly.

00:33:42.470 --> 00:33:44.190
And same sort of
story on iOS--

00:33:44.190 --> 00:33:46.140
we provide a library that you
can use if you're building

00:33:46.140 --> 00:33:47.150
native apps for iOS.

00:33:47.150 --> 00:33:48.690
Pretty much the same thing--
grab the image from the

00:33:48.690 --> 00:33:51.180
server, decode it, stick it into
a byte array, render it,

00:33:51.180 --> 00:33:52.140
and you're done.

00:33:52.140 --> 00:33:57.330
So it's pretty straightforward
to deploy and use.

00:33:57.330 --> 00:33:58.550
ILYA GRIGORIK: So as a recap--

00:33:58.550 --> 00:34:00.380
I think we've covered a
lot of ground here.

00:34:00.380 --> 00:34:03.050
For deploying WebP, you can
use it on native apps.

00:34:03.050 --> 00:34:04.980
That's very easy
to get started.

00:34:04.980 --> 00:34:06.220
We have iOS solutions.

00:34:06.220 --> 00:34:07.850
We have Android solutions.

00:34:07.850 --> 00:34:11.610
You can go far back with the
backport as well on Android.

00:34:11.610 --> 00:34:13.340
And on the web, we have server

00:34:13.340 --> 00:34:14.960
detection, client-side detection.

00:34:14.960 --> 00:34:17.020
We looked at a couple different
strategies.

00:34:17.020 --> 00:34:20.030
And personally, I think actually
the automation part

00:34:20.030 --> 00:34:22.670
of deploying WebP is the easiest
way to get started.

00:34:22.670 --> 00:34:24.250
So PageSpeed is one way.

00:34:24.250 --> 00:34:27.350
There are other providers that
will convert these images and

00:34:27.350 --> 00:34:29.060
serve them dynamically
for you.

00:34:29.060 --> 00:34:32.190
Just recently, we actually had
an interesting experiment

00:34:32.190 --> 00:34:34.949
deploy with a company called CDN
Connect, which does image

00:34:34.949 --> 00:34:35.800
optimization.

00:34:35.800 --> 00:34:38.400
What they allow you to do is
just upload any image that you

00:34:38.400 --> 00:34:40.210
want into their CDN.

00:34:40.210 --> 00:34:41.639
They will do all of
the optimization.

00:34:41.639 --> 00:34:43.159
They'll handle the Accept
negotiation.

00:34:43.159 --> 00:34:45.400
You guys don't even have
to think about it.

00:34:45.400 --> 00:34:47.940
And the user gets the
optimized assets.

00:34:47.940 --> 00:34:51.230
So hopefully, this motivated
why you should

00:34:51.230 --> 00:34:52.590
take a look at WebP.

00:34:52.590 --> 00:34:57.090
And hopefully you'll deploy
them in your applications.

00:34:57.090 --> 00:34:58.780
And if you guys have any
questions, please

00:34:58.780 --> 00:34:59.730
grab one of the mics.

00:34:59.730 --> 00:35:01.144
And we'll be happy
to answer them.

00:35:01.144 --> 00:35:09.856
[APPLAUSE]

00:35:09.856 --> 00:35:10.340
AUDIENCE: Hi.

00:35:10.340 --> 00:35:13.061
You guys talked about
encoding--

00:35:13.061 --> 00:35:17.080
or you showed example of
decoding on Android and iOS.

00:35:17.080 --> 00:35:20.610
I was just wondering if it's
likely or realistic to encode

00:35:20.610 --> 00:35:24.440
on Android or iOS in the process
of an application

00:35:24.440 --> 00:35:26.960
where you'd be taking a picture
and then want to send

00:35:26.960 --> 00:35:29.680
it to a web service and
encode it first.

00:35:29.680 --> 00:35:31.460
Can you talk about that?

00:35:31.460 --> 00:35:34.430
STEPHEN KONIG: Yeah, I think you
could certainly do that.

00:35:34.430 --> 00:35:36.800
The libraries we provide today
are focused on decode because

00:35:36.800 --> 00:35:38.350
that's the predominant case.

00:35:38.350 --> 00:35:41.910
But literally, they're nothing
more than a port of the full

00:35:41.910 --> 00:35:44.080
library that you find
on our site.

00:35:44.080 --> 00:35:45.830
So I think we could certainly
look at that.

00:35:45.830 --> 00:35:48.445
Or it's something I think you
could do today, just porting

00:35:48.445 --> 00:35:49.850
that code for the encoder.

00:35:52.840 --> 00:35:54.490
AUDIENCE: I have a question
about using the Accept header

00:35:54.490 --> 00:35:56.500
to serve the right
image format.

00:35:56.500 --> 00:35:59.160
Right now on our site, all
image links are complete

00:35:59.160 --> 00:36:01.650
permalinks that gives you the
same data no matter where you

00:36:01.650 --> 00:36:04.370
are or when you are, which is
really nice for a CDN, which

00:36:04.370 --> 00:36:05.920
just uses the URL
as a cache key.

00:36:05.920 --> 00:36:10.140
And also any caching proxy
between our user and our CDN

00:36:10.140 --> 00:36:12.830
can cache based on
just the URL.

00:36:12.830 --> 00:36:16.820
So I'm wondering what sort of
CDN support do you see for

00:36:16.820 --> 00:36:19.110
using that Accept header as
part of the cache key.

00:36:19.110 --> 00:36:22.010
And also how that affects
downstream caching proxies--

00:36:22.010 --> 00:36:23.430
are they able to distinguish
that?

00:36:23.430 --> 00:36:26.210
Or do we just have to tell them
that the downstream proxy

00:36:26.210 --> 00:36:27.610
can't cache it?

00:36:27.610 --> 00:36:30.520
ILYA GRIGORIK: So the other part
I didn't cover around the

00:36:30.520 --> 00:36:32.960
Accept header is the
Vary Accept.

00:36:32.960 --> 00:36:36.820
So when you provide a different
image based on

00:36:36.820 --> 00:36:39.300
Accept header, you also have
to basically indicate to

00:36:39.300 --> 00:36:43.410
upstream proxies to say, this
image is different based on

00:36:43.410 --> 00:36:44.450
certain parameters.

00:36:44.450 --> 00:36:46.640
So that's why you specify
Vary Accept.

00:36:46.640 --> 00:36:48.830
And we actually have a good
tutorial that I've written up

00:36:48.830 --> 00:36:52.620
recently for how to make this
work with nginx and Apache and

00:36:52.620 --> 00:36:53.530
other servers.

00:36:53.530 --> 00:36:55.580
And working with CDN's--

00:36:55.580 --> 00:36:57.330
I've talked to Akamai
and others.

00:36:57.330 --> 00:37:00.833
They're in the process of
deploying support for Accept.

00:37:00.833 --> 00:37:04.080
AUDIENCE: And in terms of
proxies that you see users

00:37:04.080 --> 00:37:06.850
have, do you find that the level
of support for being

00:37:06.850 --> 00:37:09.610
able to identify that properly
is high enough that you'd be

00:37:09.610 --> 00:37:10.850
willing to send that
to your users?

00:37:10.850 --> 00:37:11.615
Or do you see a lot of errors?

00:37:11.615 --> 00:37:13.710
ILYA GRIGORIK: So the default
behavior for a lot of proxies

00:37:13.710 --> 00:37:17.510
today is if they see anything
but Accept in coding, is to

00:37:17.510 --> 00:37:19.240
not cache it.

00:37:19.240 --> 00:37:22.320
So that means that it'll
just bypass that cache.

00:37:22.320 --> 00:37:24.380
So it won't break your site,
which I think is a more

00:37:24.380 --> 00:37:25.790
important part.

00:37:25.790 --> 00:37:26.210
AUDIENCE: OK.

00:37:26.210 --> 00:37:27.730
Thanks.

00:37:27.730 --> 00:37:28.270
AUDIENCE: Yes, hi.

00:37:28.270 --> 00:37:32.140
How do you see WebP being used
in medical radiology?

00:37:32.140 --> 00:37:32.690
STEPHEN KONIG: In--

00:37:32.690 --> 00:37:33.330
sorry, which?

00:37:33.330 --> 00:37:35.230
AUDIENCE: In radiology.

00:37:35.230 --> 00:37:35.720
STEPHEN KONIG: Good question.

00:37:35.720 --> 00:37:38.570
I'm not sure.

00:37:38.570 --> 00:37:40.300
We think there's lots
of applications.

00:37:40.300 --> 00:37:43.740
We've been heavily focused
on the web for

00:37:43.740 --> 00:37:44.680
sort of obvious reasons.

00:37:44.680 --> 00:37:47.140
But having said that, I think
there are a lot of additional

00:37:47.140 --> 00:37:50.030
types of applications where
WebP makes a lot of sense.

00:37:50.030 --> 00:37:53.520
In the cases where storage is a
primary concern, WebP is an

00:37:53.520 --> 00:37:54.470
obvious choice.

00:37:54.470 --> 00:37:57.750
We can get you the same image
with no loss of visual quality

00:37:57.750 --> 00:38:02.400
or purely lossless if you want
for 30 to 50% less bytes.

00:38:02.400 --> 00:38:04.140
So we haven't been focused
on those kinds of

00:38:04.140 --> 00:38:05.510
applications just yet.

00:38:05.510 --> 00:38:08.270
But I would expect that as we
make more progress in getting

00:38:08.270 --> 00:38:10.970
it deployed across the web,
it makes a lot of sense.

00:38:10.970 --> 00:38:13.930
It would make sense for camera
and device makers to store

00:38:13.930 --> 00:38:15.500
these images as WebP natively.

00:38:15.500 --> 00:38:17.820
Literally, you're going to get a
third more images on your SD

00:38:17.820 --> 00:38:18.940
card by using WebP.

00:38:18.940 --> 00:38:21.920
But the reality is they're not
going to do that until there's

00:38:21.920 --> 00:38:25.800
better support in sites across
the web for uploading WebP.

00:38:25.800 --> 00:38:28.110
So we have to get there first
before we can move on to the

00:38:28.110 --> 00:38:28.860
second tier.

00:38:28.860 --> 00:38:33.230
But I think applications like
that make a lot of sense.

00:38:33.230 --> 00:38:33.570
AUDIENCE: Hi.

00:38:33.570 --> 00:38:36.020
I'm curious about photographs
in particular.

00:38:36.020 --> 00:38:39.570
Typically, they come off of the
camera in a JPEG format.

00:38:39.570 --> 00:38:42.290
Re-encoding it-- would you
want to use the lossless

00:38:42.290 --> 00:38:45.690
re-encoding so as to avoid
introducing new artifacts?

00:38:45.690 --> 00:38:49.120
If so, what kind of savings
do you get there?

00:38:49.120 --> 00:38:51.090
And so on and so forth.

00:38:51.090 --> 00:38:52.390
STEPHEN KONIG: You can
certainly do that.

00:38:52.390 --> 00:38:55.030
Even if you take a JPEG and
recompress it as a lossless

00:38:55.030 --> 00:38:57.040
WebP, you're still going to
get byte savings over the

00:38:57.040 --> 00:38:58.100
original source.

00:38:58.100 --> 00:39:00.310
So that definitely still
makes a lot of sense.

00:39:00.310 --> 00:39:02.390
It depends a little bit on the
quality setting that's coming

00:39:02.390 --> 00:39:02.970
out of the camera.

00:39:02.970 --> 00:39:05.800
If the quality is high,
recompressing into a lossy

00:39:05.800 --> 00:39:08.670
WebP, you're really not going to
get anything significant in

00:39:08.670 --> 00:39:10.630
terms of additional compression
artifacts.

00:39:10.630 --> 00:39:12.500
But it is something that--
as you're thinking about

00:39:12.500 --> 00:39:13.890
deploying this-- and one of
the things that we do

00:39:13.890 --> 00:39:16.320
internally is we do a
visual comparison.

00:39:16.320 --> 00:39:19.180
We take like a couple hundred
to 1,000 images.

00:39:19.180 --> 00:39:21.890
And we'll recompress
them as WebPs.

00:39:21.890 --> 00:39:24.090
And we'll compare them against
the original JPEGs and do

00:39:24.090 --> 00:39:25.105
basically an eyeball
comparison.

00:39:25.105 --> 00:39:27.330
And I think that's important
because depending on the

00:39:27.330 --> 00:39:29.436
nature of the images you have on
your site, you may want to

00:39:29.436 --> 00:39:32.830
tweak the quality settings
to get the right mix.

00:39:32.830 --> 00:39:35.170
The other thing I would say on
that, too, is that sometimes

00:39:35.170 --> 00:39:37.780
the issue is about improving
quality with keeping the file

00:39:37.780 --> 00:39:38.590
size constant.

00:39:38.590 --> 00:39:42.410
We see that, too, in some
cases, where the site is

00:39:42.410 --> 00:39:44.520
actually more interested in
saying, you know, gosh, those

00:39:44.520 --> 00:39:46.210
thumbnails we served today
are really crappy.

00:39:46.210 --> 00:39:47.600
They look terrible.

00:39:47.600 --> 00:39:49.570
But we can't afford to increase
the JPEG quality

00:39:49.570 --> 00:39:51.300
because it would cost
more bytes and

00:39:51.300 --> 00:39:52.490
make the page slower.

00:39:52.490 --> 00:39:54.590
WebP is actually a great way
to solve that problem, too.

00:39:54.590 --> 00:39:57.760
So there's lots of different
ways you can use WebP.

00:39:57.760 --> 00:40:00.470
So at the end of the day, it
just becomes a case where you

00:40:00.470 --> 00:40:02.860
have to compare them and get
to the level that you're

00:40:02.860 --> 00:40:04.960
comfortable with based on what
your corpus looks like.

00:40:04.960 --> 00:40:05.275
AUDIENCE: Great.

00:40:05.275 --> 00:40:05.590
Thanks.

00:40:05.590 --> 00:40:07.280
ILYA GRIGORIK: Maybe I'll just
add one more thing, which is

00:40:07.280 --> 00:40:09.830
in our encoder tool, when you
look at different quality

00:40:09.830 --> 00:40:13.280
levels, so you can actually say
75, 80 and others, we also

00:40:13.280 --> 00:40:14.860
have a couple of profiles
built in.

00:40:14.860 --> 00:40:17.060
There's a photo profile
and a few others.

00:40:17.060 --> 00:40:19.210
So I still encourage you to play
with them and kind of get

00:40:19.210 --> 00:40:20.370
a feel for how it looks.

00:40:20.370 --> 00:40:23.940
But there's some presets
in there.

00:40:23.940 --> 00:40:26.160
AUDIENCE: Hi, I've got
three questions.

00:40:26.160 --> 00:40:33.280
The first one is, is there a way
to do soft tiling and sub

00:40:33.280 --> 00:40:35.560
resolution image decoding?

00:40:35.560 --> 00:40:36.920
The first question.

00:40:36.920 --> 00:40:43.150
The second one is, is the key
frames used in VP9 the same

00:40:43.150 --> 00:40:45.680
decoder that WebP is based on?

00:40:45.680 --> 00:40:47.020
And the last question--

00:40:47.020 --> 00:40:49.490
is there any vector instruction
supporting iOS,

00:40:49.490 --> 00:40:52.980
for the iOS library?

00:40:52.980 --> 00:40:54.190
STEPHEN KONIG: So your last
question, I don't know.

00:40:54.190 --> 00:40:56.120
I'll have to follow up
on that for you.

00:40:56.120 --> 00:40:58.610
In terms of VP9, no.

00:40:58.610 --> 00:41:01.430
So the WebP is based
on a VP8 key frame.

00:41:01.430 --> 00:41:03.830
We've looked at, does it make
sense to transition to VP9?

00:41:03.830 --> 00:41:07.070
And for a variety of reasons
that I can get into offline,

00:41:07.070 --> 00:41:08.290
we feel like it doesn't.

00:41:08.290 --> 00:41:12.450
So we're going to be staying
on the VP8 frame for that.

00:41:12.450 --> 00:41:13.040
And I apologize.

00:41:13.040 --> 00:41:14.040
I've forgotten your
first question.

00:41:14.040 --> 00:41:16.760
But we can follow up offline.

00:41:16.760 --> 00:41:17.190
AUDIENCE: OK, yeah.

00:41:17.190 --> 00:41:22.560
It's to do with like 16 K by
16 K texture maps or tiles.

00:41:22.560 --> 00:41:24.670
Can you generate a
thumbnail without

00:41:24.670 --> 00:41:26.520
decoding the entire image?

00:41:26.520 --> 00:41:29.100
That's sub resolution
image decoding.

00:41:29.100 --> 00:41:31.590
And the last one was soft tiling
to grab a region of

00:41:31.590 --> 00:41:33.720
that 16 K without decoding
the entire thing.

00:41:33.720 --> 00:41:35.060
STEPHEN KONIG: We're looking
at techniques like that.

00:41:35.060 --> 00:41:36.400
We don't have direct support
for it today.

00:41:36.400 --> 00:41:37.650
But those are things
we are looking at.

00:41:40.500 --> 00:41:43.520
AUDIENCE: You guys mentioned
that encoding is 5 to 10 times

00:41:43.520 --> 00:41:47.430
slower compared to JPEG.

00:41:47.430 --> 00:41:49.590
Is there anything
on the horizon

00:41:49.590 --> 00:41:52.410
where that would improve?

00:41:52.410 --> 00:41:54.560
STEPHEN KONIG: So I mentioned
performance optimizations is

00:41:54.560 --> 00:41:55.500
one of the things we're
working on.

00:41:55.500 --> 00:41:59.230
And encoding performance is
probably the top of that list.

00:41:59.230 --> 00:42:02.630
I would say, just in general,
the reason WebP is smaller is

00:42:02.630 --> 00:42:05.160
because we spend more CPU
cycles to compress.

00:42:05.160 --> 00:42:06.970
And we use more sophisticated
algorithms.

00:42:06.970 --> 00:42:09.340
So we will never
get one to one.

00:42:09.340 --> 00:42:11.820
That's just not going
to happen.

00:42:11.820 --> 00:42:13.890
What we're shooting for, our
goal, is somewhere around 2 to

00:42:13.890 --> 00:42:16.040
3x, is where we hope to be.

00:42:18.920 --> 00:42:22.960
AUDIENCE: I'd like to mix like
JPEG and WebP files in the

00:42:22.960 --> 00:42:24.710
cache on Android.

00:42:24.710 --> 00:42:30.510
Does the WebP native library can
detect that this is a WebP

00:42:30.510 --> 00:42:34.970
image and this is a JPEG image
and decode that too?

00:42:34.970 --> 00:42:38.570
Does it do redirect to JPEG and
PNG bitmap decompression?

00:42:38.570 --> 00:42:39.760
ILYA GRIGORIK: I don't think
the WebP library

00:42:39.760 --> 00:42:40.820
will do that for you.

00:42:40.820 --> 00:42:43.530
But there are great tools
available where you can just

00:42:43.530 --> 00:42:45.670
read the header of the file,
of any file, and basically

00:42:45.670 --> 00:42:48.720
determine the file type and then
just pick the right path

00:42:48.720 --> 00:42:49.420
in your code.

00:42:49.420 --> 00:42:50.910
AUDIENCE: So I have
to do it manually.

00:42:50.910 --> 00:42:52.160
ILYA GRIGORIK: Correct.

00:42:54.280 --> 00:42:56.160
AUDIENCE: Does the backport
library support all versions

00:42:56.160 --> 00:42:57.140
of Android?

00:42:57.140 --> 00:43:01.240
STEPHEN KONIG: I believe
everything Froyo and above.

00:43:01.240 --> 00:43:03.770
AUDIENCE: Can you provide some
insight on how WebP behaves

00:43:03.770 --> 00:43:09.060
with images that are a
combination of PNG image and

00:43:09.060 --> 00:43:10.210
JPEG image--

00:43:10.210 --> 00:43:12.260
would be great.

00:43:12.260 --> 00:43:15.800
So for example, a screenshot
or something like that.

00:43:15.800 --> 00:43:18.700
STEPHEN KONIG: So I'm not sure
what your question is.

00:43:18.700 --> 00:43:20.680
Can you elaborate
a little bit?

00:43:20.680 --> 00:43:24.390
AUDIENCE: It seems like WebP
is able to behave great on

00:43:24.390 --> 00:43:28.090
photos or to replace PNG.

00:43:28.090 --> 00:43:31.120
What if the image is a
combination of both?

00:43:31.120 --> 00:43:32.760
STEPHEN KONIG: I see.

00:43:32.760 --> 00:43:35.260
So in general, what you saw,
for example, on G+, is that

00:43:35.260 --> 00:43:38.680
WebP does fantastically well
in cases of photos,

00:43:38.680 --> 00:43:40.560
traditional photos you
see from cameras.

00:43:40.560 --> 00:43:42.550
It does really well on just
about everything.

00:43:42.550 --> 00:43:45.730
It just does even better
on things like photos.

00:43:45.730 --> 00:43:47.490
So if you look back in
the slides, I had a

00:43:47.490 --> 00:43:48.880
chart of 1,000 PNGs.

00:43:48.880 --> 00:43:50.180
And they were different
types of PNGs.

00:43:50.180 --> 00:43:52.030
Some of them were photos.

00:43:52.030 --> 00:43:55.720
Some of them are animated,
just drawings.

00:43:55.720 --> 00:43:57.420
Some of them are screenshots.

00:43:57.420 --> 00:44:02.850
And 98 and 1/2, 99% of those
images are smaller in WebP

00:44:02.850 --> 00:44:04.570
than they are in PNG.

00:44:04.570 --> 00:44:07.200
There's a little bit of a thing
at the end where the PNG

00:44:07.200 --> 00:44:08.620
is smaller.

00:44:08.620 --> 00:44:11.750
Those actually are cases where
the image itself is like four

00:44:11.750 --> 00:44:13.750
by four, something
really tiny.

00:44:13.750 --> 00:44:15.970
And what you find out is that
the container for WebP

00:44:15.970 --> 00:44:17.650
actually is bigger than
the image size.

00:44:17.650 --> 00:44:20.840
And so it winds up being bigger
than the original one.

00:44:20.840 --> 00:44:22.470
So if your images are a lot like
that, then I would tell

00:44:22.470 --> 00:44:25.020
you, stick with PNGs.

00:44:25.020 --> 00:44:27.640
The other case that we see that
I highlighted is cases

00:44:27.640 --> 00:44:30.280
where if you're generating
images as part of

00:44:30.280 --> 00:44:31.500
your serving pipeline--

00:44:31.500 --> 00:44:33.930
so you have something that
you're then creating an image

00:44:33.930 --> 00:44:36.940
from, and that's being generated
dynamically.

00:44:36.940 --> 00:44:39.230
It's not so much a visual
quality issue there as more of

00:44:39.230 --> 00:44:40.020
a performance issue.

00:44:40.020 --> 00:44:41.570
Because it takes longer
to encode that

00:44:41.570 --> 00:44:42.730
as WebP versus PNG.

00:44:42.730 --> 00:44:47.070
So that's another case where PNG
would be a better choice.

00:44:47.070 --> 00:44:49.340
But in general, I would just say
what I said earlier, which

00:44:49.340 --> 00:44:51.900
is at the end of the day, you
have to do a visual comparison

00:44:51.900 --> 00:44:53.820
to make sure you're comfortable
and to make sure

00:44:53.820 --> 00:44:56.960
also all the knobs and buttons
and things that we provide to

00:44:56.960 --> 00:44:59.720
let you control those settings
for WebP are where you want

00:44:59.720 --> 00:45:01.870
them to be.

00:45:01.870 --> 00:45:04.120
ILYA GRIGORIK: Right, so maybe
one more thing that I'll add

00:45:04.120 --> 00:45:06.550
is if you guys have any
follow-up questions later

00:45:06.550 --> 00:45:10.550
about WebP, we do have the
WebP-discuss Google group.

00:45:10.550 --> 00:45:11.860
All of our engineers
monitor it.

00:45:11.860 --> 00:45:12.510
We monitor it.

00:45:12.510 --> 00:45:15.660
So if at any point you guys are
experimenting with it or

00:45:15.660 --> 00:45:18.270
have questions about WebP,
please post there.

00:45:18.270 --> 00:45:20.920
And otherwise, thank
you for coming up.

00:45:20.920 --> 00:45:21.520
STEPHEN KONIG: Thanks.

00:45:21.520 --> 00:45:25.557
[APPLAUSE]

