WEBVTT
Kind: captions
Language: en

00:00:00.492 --> 00:00:05.904
[MUSIC PLAYING]

00:00:16.740 --> 00:00:17.430
JOHN MCCUTCHAN: Hey, everyone.

00:00:17.430 --> 00:00:19.400
I'm John McCutchan, and welcome
to the Break Point.

00:00:19.400 --> 00:00:20.530
And I'm here with Loreena Lee.

00:00:20.530 --> 00:00:23.100
LOREENA LEE: Hi, I'm
Loreena Lee.

00:00:23.100 --> 00:00:24.590
JOHN MCCUTCHAN: So what
do you do at Google?

00:00:24.590 --> 00:00:27.020
LOREENA LEE: I actually work
on Gmail, and I'm focused

00:00:27.020 --> 00:00:31.220
primarily on performance, so
making it faster as well as

00:00:31.220 --> 00:00:33.110
making sure we're using the
right amount of memory.

00:00:33.110 --> 00:00:34.470
JOHN MCCUTCHAN: Nice,
well that's good.

00:00:34.470 --> 00:00:37.440
Good thing you're here, because
we're here today to

00:00:37.440 --> 00:00:39.880
talk about understanding the
way memory works inside

00:00:39.880 --> 00:00:43.160
JavaScript and how to profile
your usage of memory inside

00:00:43.160 --> 00:00:45.330
Chrome dev tools.

00:00:45.330 --> 00:00:49.490
So I'm going to spend a little
bit of time talking about the

00:00:49.490 --> 00:00:54.440
conceptual material for how
JavaScript manages memory.

00:00:54.440 --> 00:00:57.940
And then Loreena is going to
show us a really cool demo of

00:00:57.940 --> 00:01:00.990
using Chrome dev tools.

00:01:00.990 --> 00:01:05.400
So JavaScript variables can
be of four primary types--

00:01:05.400 --> 00:01:08.460
the boolean type, which just
true or false canonical

00:01:08.460 --> 00:01:13.530
values, the number type, which
is any double precision

00:01:13.530 --> 00:01:17.270
floating point number, the
string, which is a UTF-16

00:01:17.270 --> 00:01:20.650
encoded character array,
or an object, which

00:01:20.650 --> 00:01:21.695
is a key value map.

00:01:21.695 --> 00:01:23.360
For those of you familiar
with JavaScript, this

00:01:23.360 --> 00:01:24.400
is very basic stuff.

00:01:24.400 --> 00:01:27.830
But we're just going to start
from scratch and build up.

00:01:27.830 --> 00:01:31.390
So objects are built around
key value mapping.

00:01:31.390 --> 00:01:33.850
So the key goes in the
square brackets.

00:01:33.850 --> 00:01:34.960
And this is always a string.

00:01:34.960 --> 00:01:37.500
No matter what you put in
it, it's going to be

00:01:37.500 --> 00:01:38.870
coerced into a string.

00:01:38.870 --> 00:01:42.830
And then use that as the
look up into the table.

00:01:42.830 --> 00:01:47.240
And then for value, you can
store any JavaScript object

00:01:47.240 --> 00:01:50.330
inside of the value.

00:01:50.330 --> 00:01:54.810
So a key fundamental concept
of memory and JavaScript is

00:01:54.810 --> 00:01:56.250
the object graph.

00:01:56.250 --> 00:02:00.360
So we're looking at a whole
bunch of circles and lines on

00:02:00.360 --> 00:02:01.800
this slide.

00:02:01.800 --> 00:02:04.440
But let's start from the left
at the blue circle.

00:02:04.440 --> 00:02:08.120
This is the root object inside
the memory management system.

00:02:08.120 --> 00:02:10.630
This is not something that you
can explicitly manipulate or

00:02:10.630 --> 00:02:13.850
do anything with, but this is
just where every object that

00:02:13.850 --> 00:02:16.280
you create descends from.

00:02:16.280 --> 00:02:17.640
And so this is called
the root.

00:02:17.640 --> 00:02:21.050
And from the root, it references
global variables

00:02:21.050 --> 00:02:26.470
and other global state that's
available to the browser.

00:02:26.470 --> 00:02:28.640
The red objects are
object variables.

00:02:28.640 --> 00:02:31.030
So these can reference
other variables.

00:02:31.030 --> 00:02:34.900
And the green circles are
scalar variables, like a

00:02:34.900 --> 00:02:38.830
boolean or a number that can't
reference anything else.

00:02:38.830 --> 00:02:42.190
And you can see the green note
at the end there, on the upper

00:02:42.190 --> 00:02:46.120
right part of the screen with
the yellow arrow, this is the

00:02:46.120 --> 00:02:49.680
terminating node in this part
of the object graph.

00:02:54.270 --> 00:02:56.660
So objects have a concept
of a retaining tree.

00:02:56.660 --> 00:03:01.620
And this is the paths along the
graph that are keeping the

00:03:01.620 --> 00:03:03.910
object from being classified
as memory.

00:03:03.910 --> 00:03:06.560
So on the slide right now,
you can see a green node.

00:03:06.560 --> 00:03:07.980
And let's look at the
retaining tree

00:03:07.980 --> 00:03:09.890
for this green node.

00:03:09.890 --> 00:03:13.190
So the retaining tree is
this yellow node here--

00:03:13.190 --> 00:03:15.310
the root node--

00:03:15.310 --> 00:03:19.570
as well as this other path from
the root to the other

00:03:19.570 --> 00:03:20.440
yellow node as well.

00:03:20.440 --> 00:03:23.340
So the object actually has two
paths that are keeping it

00:03:23.340 --> 00:03:24.740
pinned into memory.

00:03:24.740 --> 00:03:27.260
If both of these paths are
terminated, then the object

00:03:27.260 --> 00:03:28.860
becomes garbage and eventually
is collected.

00:03:33.990 --> 00:03:35.810
Objects have two sizes.

00:03:35.810 --> 00:03:38.310
They have a shallow size, which
is just the size of the

00:03:38.310 --> 00:03:39.690
actual object.

00:03:39.690 --> 00:03:42.570
And this is usually a very
small constant value.

00:03:42.570 --> 00:03:46.590
I think on my system, an
object is 36 bytes.

00:03:46.590 --> 00:03:50.520
All of the variables that the
object references are

00:03:50.520 --> 00:03:51.740
accumulated together.

00:03:51.740 --> 00:03:54.170
The sizes of those objects are
accumulated, and this is the

00:03:54.170 --> 00:03:55.740
retained size of an object.

00:03:55.740 --> 00:03:58.440
This is the amount of memory
that could be freed if this

00:03:58.440 --> 00:04:02.260
object was turned
into garbage.

00:04:02.260 --> 00:04:05.240
LOREENA LEE: If you go back to
the previous slide, we can see

00:04:05.240 --> 00:04:11.280
the retained side of the root
node would be basically the

00:04:11.280 --> 00:04:13.940
whole graph except for those
two disconnected

00:04:13.940 --> 00:04:14.724
nodes in the middle.

00:04:14.724 --> 00:04:16.910
JOHN MCCUTCHAN: Yes,
which are garbage.

00:04:16.910 --> 00:04:20.190
So from the root node, the
retain sizes is the size of

00:04:20.190 --> 00:04:23.020
everything that's
still reachable.

00:04:27.750 --> 00:04:29.150
So what exactly is garbage?

00:04:29.150 --> 00:04:32.110
Well, the definition of garbage
is any variable and

00:04:32.110 --> 00:04:36.290
all variables which cannot be
reached from the root node.

00:04:36.290 --> 00:04:39.850
So in this diagram here, I've
highlighted the two nodes

00:04:39.850 --> 00:04:40.640
which are garbage.

00:04:40.640 --> 00:04:43.860
The red node is referencing in
the green node, but there is

00:04:43.860 --> 00:04:49.030
no path from the blue root node
to that red node, making

00:04:49.030 --> 00:04:50.885
both the red and the green
node into garbage.

00:04:54.420 --> 00:04:56.960
So garbage collection happens
in two phases.

00:04:56.960 --> 00:05:02.810
First, the graph is scanned,
and all garbage is found.

00:05:02.810 --> 00:05:05.090
So we already know the garbage
in this graph was the red and

00:05:05.090 --> 00:05:06.030
the green node.

00:05:06.030 --> 00:05:10.000
And then this memory is returned
to the system during

00:05:10.000 --> 00:05:11.250
the collection phase.

00:05:14.500 --> 00:05:16.650
So it's important when
optimizing for performance and

00:05:16.650 --> 00:05:18.950
memory usage to understand
the cost model

00:05:18.950 --> 00:05:20.740
for allocating memory.

00:05:20.740 --> 00:05:23.190
So every time that your
JavaScript application calls

00:05:23.190 --> 00:05:26.710
new, it reserves memory from
something called the young

00:05:26.710 --> 00:05:27.860
memory pool.

00:05:27.860 --> 00:05:31.700
So memory is split into young
objects and old objects.

00:05:31.700 --> 00:05:35.110
The v8 internally decides when
to promote an object from the

00:05:35.110 --> 00:05:37.410
young memory pool to the
old memory pool.

00:05:37.410 --> 00:05:39.445
You don't have any control over
that, but when you call

00:05:39.445 --> 00:05:42.230
new, you're going to be scooping
up memory from the

00:05:42.230 --> 00:05:44.160
young memory pool, which
is very cheap.

00:05:44.160 --> 00:05:49.090
It's actually incredibly fast
until the on memory pool runs

00:05:49.090 --> 00:05:50.010
out of memory.

00:05:50.010 --> 00:05:53.850
And at that point, the young
memory pool is scanned, and

00:05:53.850 --> 00:05:55.950
all of the garbage is collected,
freeing memory,

00:05:55.950 --> 00:05:58.890
making it possible to allocate
new objects.

00:05:58.890 --> 00:06:00.740
And this could take
milliseconds.

00:06:00.740 --> 00:06:03.420
So for interactive applications,
you really want

00:06:03.420 --> 00:06:07.690
to be careful about how you
allocate objects and what the

00:06:07.690 --> 00:06:11.490
patterns are, and how long you
hold onto them, particularly

00:06:11.490 --> 00:06:12.450
for a game.

00:06:12.450 --> 00:06:15.470
You pretty much need to be able
to do a frame with zero

00:06:15.470 --> 00:06:18.900
allocations, because inside
of a frame, you have 16

00:06:18.900 --> 00:06:21.630
milliseconds to compute the
state of the world, render it,

00:06:21.630 --> 00:06:24.800
and take input handling,
play sound.

00:06:24.800 --> 00:06:29.330
If half of that time is taken up
by garbage collection, the

00:06:29.330 --> 00:06:30.730
game's not going to
be very much fun.

00:06:35.120 --> 00:06:40.860
So in summary, all variables
that you have in JavaScript

00:06:40.860 --> 00:06:42.680
are part of the object graph.

00:06:42.680 --> 00:06:46.530
And the only inner nodes
in an object graph

00:06:46.530 --> 00:06:47.990
are JavaScript objects.

00:06:47.990 --> 00:06:50.540
They're the only type of
variable that can reference

00:06:50.540 --> 00:06:52.180
other variables.

00:06:52.180 --> 00:06:53.730
And objects have two sizes--

00:06:53.730 --> 00:06:56.460
the shallow size, which is
just the size of this the

00:06:56.460 --> 00:06:59.640
object itself and then the
retained size, which is the

00:06:59.640 --> 00:07:02.040
size of the object itself
plus all of its

00:07:02.040 --> 00:07:05.600
descendants shallow sizes.

00:07:05.600 --> 00:07:08.560
So all variables that cannot be
reached from the root are

00:07:08.560 --> 00:07:09.760
classified as garbage.

00:07:09.760 --> 00:07:13.810
And when v8 decides it's an
appropriate time, it will do a

00:07:13.810 --> 00:07:16.780
garbage collection phase,
freeing up memory and

00:07:16.780 --> 00:07:20.100
collecting all the garbage and
giving it back to the system.

00:07:20.100 --> 00:07:22.840
So allocations are really cheap
until the young memory

00:07:22.840 --> 00:07:24.760
pool runs out of memory.

00:07:24.760 --> 00:07:27.220
At that point, a garbage
collection is forced, it's not

00:07:27.220 --> 00:07:29.550
just done at an opportune
time.

00:07:29.550 --> 00:07:31.030
So you have to watch out
for that in interactive

00:07:31.030 --> 00:07:32.280
applications.

00:07:34.680 --> 00:07:36.910
So Loreena, do you want
to give us your demo?

00:07:36.910 --> 00:07:38.820
LOREENA LEE: Sure, so just a
little bit of basics about the

00:07:38.820 --> 00:07:39.600
Chrome dev tools.

00:07:39.600 --> 00:07:42.340
So we'll talk about how you
can use the dev tools to

00:07:42.340 --> 00:07:46.020
profile what's in your heap at
any given time, and then also

00:07:46.020 --> 00:07:48.990
to find situations where you may
be leaving around memory

00:07:48.990 --> 00:07:52.940
allocated that you don't
need anymore.

00:07:52.940 --> 00:07:55.000
So in general, the garbage
collector should be cleaning

00:07:55.000 --> 00:07:55.940
up after you.

00:07:55.940 --> 00:07:57.920
But there are certain
situations, which we'll see in

00:07:57.920 --> 00:08:00.500
a little bit, where
things may not get

00:08:00.500 --> 00:08:03.340
cleaned up as expected.

00:08:03.340 --> 00:08:07.270
So a little bit of his
background on the dev tools.

00:08:07.270 --> 00:08:08.450
We can use these now.

00:08:08.450 --> 00:08:10.600
There are multiple tabs, and
we're going to go through this

00:08:10.600 --> 00:08:11.400
in an example.

00:08:11.400 --> 00:08:15.090
But first, you want to if you
have a suspicious action, so

00:08:15.090 --> 00:08:19.280
you see that your memory is
growing, or you think that

00:08:19.280 --> 00:08:21.120
your application is slowing
down for some reason or

00:08:21.120 --> 00:08:23.500
another, and you think that
memory might be the situation,

00:08:23.500 --> 00:08:28.130
you can use the Timeline tab to
perform the action and see

00:08:28.130 --> 00:08:29.070
what's happening to memory.

00:08:29.070 --> 00:08:30.890
So we can see if it's
growing over time.

00:08:30.890 --> 00:08:33.919
And if so, then we can say,
OK, now we need to dig a

00:08:33.919 --> 00:08:37.090
little bit deeper and see what's
happening in the heap.

00:08:37.090 --> 00:08:39.960
So we can use that to capture
a heap snapshot, which will

00:08:39.960 --> 00:08:42.620
show you all the objects that
are in the graph that John

00:08:42.620 --> 00:08:44.470
just talked about.

00:08:44.470 --> 00:08:47.850
It does not capture scalar
values, which were the green

00:08:47.850 --> 00:08:48.560
nodes-- green nodes?

00:08:48.560 --> 00:08:48.720
JOHN MCCUTCHAN: Yes.

00:08:48.720 --> 00:08:51.610
LOREENA LEE: Green nodes in
the graph that we saw.

00:08:51.610 --> 00:08:54.350
But it does show you
all the JavaScript

00:08:54.350 --> 00:08:56.390
objects that are allocated.

00:08:56.390 --> 00:08:58.230
There are four views
of a snapshot.

00:08:58.230 --> 00:08:59.990
And you'll see these in
the demo as well.

00:08:59.990 --> 00:09:02.220
There's the summary view, which
shows you everything in

00:09:02.220 --> 00:09:07.750
the heap, and you can apply a
filter on the entire graph to

00:09:07.750 --> 00:09:09.080
show only certain things.

00:09:09.080 --> 00:09:10.530
And I'll talk about that
in a little bit

00:09:10.530 --> 00:09:12.570
in the demo as well.

00:09:12.570 --> 00:09:14.370
And then there's a comparison
view, where you can view the

00:09:14.370 --> 00:09:15.980
differences between two
heap snapshots.

00:09:15.980 --> 00:09:18.540
So you take one snapshot and
then take another one and see

00:09:18.540 --> 00:09:19.780
what happens to memories.

00:09:19.780 --> 00:09:21.210
Did more things get allocated?

00:09:21.210 --> 00:09:22.890
Did a bunch of stuff
get collected?

00:09:22.890 --> 00:09:24.700
What's going on there?

00:09:24.700 --> 00:09:28.120
There's a containment view,
which is a bird's eye view of

00:09:28.120 --> 00:09:30.620
the app's overall object
structure.

00:09:30.620 --> 00:09:34.410
So John mentioned a little
bit about memory

00:09:34.410 --> 00:09:38.080
versus retained memory.

00:09:38.080 --> 00:09:41.250
And so in the containment view,
you can see more easily

00:09:41.250 --> 00:09:43.950
what the retained memory is.

00:09:43.950 --> 00:09:45.660
And the DOMinator's also
has a different

00:09:45.660 --> 00:09:46.610
view of the same summary.

00:09:46.610 --> 00:09:48.360
JOHN MCCUTCHAN: Yeah, so the
summary and the comparison

00:09:48.360 --> 00:09:51.570
view are sorted and organized
around the objects

00:09:51.570 --> 00:09:55.320
constructor, whereas the
containment view is organized

00:09:55.320 --> 00:09:56.370
starting at the root.

00:09:56.370 --> 00:09:59.950
So it captures the structure
of the object graph.

00:10:03.220 --> 00:10:05.540
LOREENA LEE: OK, so we're not
going to cover the container

00:10:05.540 --> 00:10:08.380
and DOMinator's view too
much in this demo.

00:10:08.380 --> 00:10:11.790
But there's some really great
documentation online at

00:10:11.790 --> 00:10:15.120
developers.google.com, where
you can see some nice demos

00:10:15.120 --> 00:10:17.410
that show you exactly
what you can see by

00:10:17.410 --> 00:10:20.740
these two other views.

00:10:20.740 --> 00:10:23.110
So we talked about comparison
view and how sometimes you can

00:10:23.110 --> 00:10:24.370
take two snapshots
to find leaks.

00:10:24.370 --> 00:10:26.160
But we're going to talk
about a case where two

00:10:26.160 --> 00:10:27.410
is not quite enough.

00:10:30.940 --> 00:10:33.760
Some other good tips to know,
though, are, you should always

00:10:33.760 --> 00:10:36.750
do these experiments in
an incognito window.

00:10:36.750 --> 00:10:38.870
You want to make sure that
you're in a clean room

00:10:38.870 --> 00:10:39.500
environment.

00:10:39.500 --> 00:10:42.230
You don't have your extensions
that may be interacting with

00:10:42.230 --> 00:10:44.620
your app in a way that you
don't understand or

00:10:44.620 --> 00:10:45.580
you don't even know.

00:10:45.580 --> 00:10:47.470
So something these third party
extensions do all sorts of

00:10:47.470 --> 00:10:49.610
crazy things to memory, and
you want to make sure that

00:10:49.610 --> 00:10:51.615
those aren't influencing
your results at all.

00:10:51.615 --> 00:10:54.010
JOHN MCCUTCHAN: Yeah, just to
repeat that, any browser

00:10:54.010 --> 00:10:57.860
extension that is loaded will be
part of the heap snapshot.

00:10:57.860 --> 00:10:59.900
So you're not just looking
at your code.

00:10:59.900 --> 00:11:02.930
You're also looking at any
extension that happens to be

00:11:02.930 --> 00:11:04.190
loaded at the same time.

00:11:04.190 --> 00:11:06.850
So an incognito windows is a
quick way to avoid loading

00:11:06.850 --> 00:11:08.100
your extensions.

00:11:10.250 --> 00:11:11.880
LOREENA LEE: And then you want
to get your bearings.

00:11:11.880 --> 00:11:16.230
So on the heap profile page,
you'll see that when we show

00:11:16.230 --> 00:11:18.350
the heap, there's a lot
of stuff in the heap.

00:11:18.350 --> 00:11:21.030
Basically, anything in
parentheses you should just

00:11:21.030 --> 00:11:22.580
filter out of your brain
for a little bit.

00:11:22.580 --> 00:11:24.000
You can just ignore them.

00:11:24.000 --> 00:11:26.500
A lot of the things are also
going to be dimmed, and those

00:11:26.500 --> 00:11:29.070
are system allocations
that we can't really

00:11:29.070 --> 00:11:29.890
control from your app.

00:11:29.890 --> 00:11:32.040
So those also should
be ignored.

00:11:32.040 --> 00:11:34.010
And then the other thing to note
is, when you click that

00:11:34.010 --> 00:11:38.190
heap snapshot button, a full
garbage collection right

00:11:38.190 --> 00:11:40.330
before you click it before
the heap is profiled.

00:11:40.330 --> 00:11:44.160
So you can assume that anything
that v8 decided that

00:11:44.160 --> 00:11:47.350
it should GC should already
be cleaned up.

00:11:47.350 --> 00:11:52.520
So let's move on to the demo.

00:11:52.520 --> 00:11:54.040
Let's see.

00:11:54.040 --> 00:11:55.290
Where are we?

00:11:57.010 --> 00:12:00.700
So we have this quick
little demo.

00:12:00.700 --> 00:12:03.450
It really doesn't
do a whole lot.

00:12:03.450 --> 00:12:04.800
There's one button.

00:12:04.800 --> 00:12:07.170
And when I click it, it will
start filling up a cache.

00:12:07.170 --> 00:12:12.910
So I have a cache of five items
that, whenever I click

00:12:12.910 --> 00:12:15.440
it, it fills in the
cache of five.

00:12:15.440 --> 00:12:16.520
So the size is five.

00:12:16.520 --> 00:12:18.597
JOHN MCCUTCHAN: So what happens
to the entries that

00:12:18.597 --> 00:12:20.190
are already in the cache?

00:12:20.190 --> 00:12:21.590
LOREENA LEE: When I first
click it, there's

00:12:21.590 --> 00:12:22.970
nothing in the cache.

00:12:22.970 --> 00:12:27.720
So what we want to do is, in
theory, when we flush the

00:12:27.720 --> 00:12:30.260
cache-- so by filling
it with new stuff--

00:12:30.260 --> 00:12:33.220
in theory, all the things that
were in the cache before

00:12:33.220 --> 00:12:34.070
should be evicted.

00:12:34.070 --> 00:12:37.230
And in theory, we think that
they should be collected.

00:12:37.230 --> 00:12:38.850
Let's find out what happens.

00:12:38.850 --> 00:12:42.560
So let's go ahead and refresh
just so we know that we're

00:12:42.560 --> 00:12:44.150
loading everything from
a clean state.

00:12:48.520 --> 00:12:49.060
Let's go back to the timeline.

00:12:49.060 --> 00:12:50.220
I mentioned this earlier.

00:12:50.220 --> 00:12:51.630
JOHN MCCUTCHAN: Yeah, that
would be great, actually.

00:12:51.630 --> 00:12:53.190
LOREENA LEE: So we can
go to the timeline.

00:12:53.190 --> 00:12:56.710
Let's say that we think that
this is causing a memory leak.

00:12:56.710 --> 00:12:58.900
So we're going to go onto
the memory here.

00:12:58.900 --> 00:13:02.690
And we're going to click Record,
which is this gray

00:13:02.690 --> 00:13:03.590
circle at the bottom.

00:13:03.590 --> 00:13:04.640
JOHN MCCUTCHAN: It
will be red.

00:13:04.640 --> 00:13:05.810
LOREENA LEE: And now it's red.

00:13:05.810 --> 00:13:08.290
So we're going to go ahead and
say, let's do some work.

00:13:08.290 --> 00:13:11.490
And we'll just do it a few
times, click it a few times.

00:13:11.490 --> 00:13:13.070
And then there's this little
button here that looks

00:13:13.070 --> 00:13:14.270
like a trash can.

00:13:14.270 --> 00:13:16.880
And that will force a
garbage collection.

00:13:16.880 --> 00:13:21.260
So let's just force it and
say, OK, maybe it now can

00:13:21.260 --> 00:13:23.430
clean up whatever it was
that I left behind.

00:13:23.430 --> 00:13:26.340
So hopefully, all those things
that I added to the cache that

00:13:26.340 --> 00:13:28.580
had been flushed out, pushed
out of the cache should be

00:13:28.580 --> 00:13:29.160
cleaned up.

00:13:29.160 --> 00:13:30.990
And we'll go and do
some more work.

00:13:30.990 --> 00:13:34.600
So you can see that at the top,
the memory is growing.

00:13:34.600 --> 00:13:36.750
So you see in blue there
that there's some new

00:13:36.750 --> 00:13:37.780
memory being allocated.

00:13:37.780 --> 00:13:40.840
And when I click the garbage
can, it seemed to have dropped

00:13:40.840 --> 00:13:43.800
a little bit but not quite
to the baseline.

00:13:43.800 --> 00:13:46.270
So let's go ahead
and stop this.

00:13:46.270 --> 00:13:52.060
And if I go and click anywhere
on the top here, I can look at

00:13:52.060 --> 00:13:53.900
a specific part of the graph.

00:13:53.900 --> 00:13:59.940
And I can widen this window here
to view whatever portion

00:13:59.940 --> 00:14:01.400
of the graph I want to see.

00:14:01.400 --> 00:14:03.700
So down below, you see this
green line that kind of looks

00:14:03.700 --> 00:14:05.090
like a stair step.

00:14:05.090 --> 00:14:08.040
And each time I push the button,
that is the number of

00:14:08.040 --> 00:14:09.520
DOM nodes that are allocated.

00:14:09.520 --> 00:14:11.600
So you can see that
it goes up.

00:14:11.600 --> 00:14:13.410
JOHN MCCUTCHAN: So it looks like
we're leaking DOM nodes.

00:14:13.410 --> 00:14:14.140
LOREENA LEE: Well, it
looks like we're

00:14:14.140 --> 00:14:15.110
allocating DOM nodes.

00:14:15.110 --> 00:14:17.170
We aren't necessarily
leaking them yet.

00:14:17.170 --> 00:14:18.650
So we don't know.

00:14:18.650 --> 00:14:20.420
The garbage collector may
not have kicked in yet.

00:14:20.420 --> 00:14:23.850
And so they wouldn't
get collected.

00:14:23.850 --> 00:14:24.210
JOHN MCCUTCHAN: Oh,
that's right.

00:14:24.210 --> 00:14:26.870
We're not looking at the part
of the graph after you

00:14:26.870 --> 00:14:27.980
clicked, garbage.

00:14:27.980 --> 00:14:29.732
LOREENA LEE: Exactly.

00:14:29.732 --> 00:14:33.030
Let's bring it out over a little
bit wider so we can see

00:14:33.030 --> 00:14:34.180
what's going on.

00:14:34.180 --> 00:14:37.640
And right around where the dip
is in the blue line is when I

00:14:37.640 --> 00:14:39.150
click the garbage button.

00:14:39.150 --> 00:14:41.360
And we don't see
it going down.

00:14:41.360 --> 00:14:43.240
So that is the problem.

00:14:43.240 --> 00:14:45.810
And if we widen it even more,
where I clicked a little bit

00:14:45.810 --> 00:14:50.600
more, you can see there's more
stair steps up when I click

00:14:50.600 --> 00:14:51.380
the button.

00:14:51.380 --> 00:14:52.830
So we're pretty sure
we have a leak.

00:14:52.830 --> 00:14:54.780
JOHN MCCUTCHAN: This looks
pretty suspicious.

00:14:54.780 --> 00:14:56.970
LOREENA LEE: And on the left,
there's the DOM node count.

00:14:56.970 --> 00:15:00.890
So it'll tell you what the range
in DOM nodes allocated

00:15:00.890 --> 00:15:02.470
for the range that you're
looking at.

00:15:02.470 --> 00:15:04.430
So from here, we
started at 15.

00:15:04.430 --> 00:15:05.370
And now we've got 92.

00:15:05.370 --> 00:15:07.250
So that number never
went down.

00:15:07.250 --> 00:15:12.740
We see that the green line
pretty much never goes down.

00:15:12.740 --> 00:15:16.280
So now we can go back
to the profile page.

00:15:16.280 --> 00:15:19.140
And let's refresh again, so we
can flush the cache, start

00:15:19.140 --> 00:15:20.980
with a clean slate.

00:15:20.980 --> 00:15:23.090
And now we're going to
take a heap snapshot.

00:15:23.090 --> 00:15:26.610
So take a heap snapshot,
and click Start.

00:15:26.610 --> 00:15:28.380
So it's super fast,
because this is a

00:15:28.380 --> 00:15:29.590
pretty lightweight thing.

00:15:29.590 --> 00:15:31.640
So this is our first snapshot.

00:15:31.640 --> 00:15:34.280
JOHN MCCUTCHAN: So I see a lot
of things in parentheses right

00:15:34.280 --> 00:15:35.370
up at the top.

00:15:35.370 --> 00:15:36.780
LOREENA LEE: So we're going to
go ahead and ignore those.

00:15:36.780 --> 00:15:40.160
These are compiled code, system
arrays, things that we

00:15:40.160 --> 00:15:41.250
really can't control.

00:15:41.250 --> 00:15:43.920
So go ahead and ignore
those for now.

00:15:43.920 --> 00:15:47.200
And we'll just scroll
down a little bit.

00:15:47.200 --> 00:15:50.090
And you can see that we've
got all sorts of

00:15:50.090 --> 00:15:51.230
stuff in our heap.

00:15:51.230 --> 00:15:54.100
JOHN MCCUTCHAN: So everything in
this table is sorted by the

00:15:54.100 --> 00:15:55.890
constructor call.

00:15:55.890 --> 00:16:01.210
So it's not the variable name
or the path that you could

00:16:01.210 --> 00:16:02.560
follow to get to the variable.

00:16:02.560 --> 00:16:06.390
It is the constructor.

00:16:06.390 --> 00:16:08.300
LOREENA LEE: So at the top,
it says, class filter.

00:16:08.300 --> 00:16:09.860
So if you wanted to search
for a certain thing--

00:16:09.860 --> 00:16:13.600
I know that we have our caches
of objects called stuff.

00:16:13.600 --> 00:16:15.320
So if I type in, stuff here--

00:16:15.320 --> 00:16:16.310
JOHN MCCUTCHAN: Very
descriptive.

00:16:16.310 --> 00:16:17.820
LOREENA LEE: Well, there's
nothing here, because we

00:16:17.820 --> 00:16:19.820
haven't allocated
anything yet.

00:16:19.820 --> 00:16:21.730
So that's expected.

00:16:21.730 --> 00:16:23.680
So let's clear this out.

00:16:23.680 --> 00:16:25.940
And let's do some more work--

00:16:25.940 --> 00:16:27.820
or do some work, we haven't
done any yet.

00:16:27.820 --> 00:16:32.330
And we're going to click and
collect another snapshot.

00:16:32.330 --> 00:16:34.900
So if we click on this snapshot
now, you can see that

00:16:34.900 --> 00:16:39.820
we've got a 1.3 megabyte heap,
whereas before we had a 1.2.

00:16:39.820 --> 00:16:41.750
So now we get to those different
views we talked

00:16:41.750 --> 00:16:43.020
about earlier.

00:16:43.020 --> 00:16:45.440
So right at the bottom here,
it says, summary.

00:16:45.440 --> 00:16:47.610
And right now, we're looking at
a summary view, and we're

00:16:47.610 --> 00:16:49.000
showing all objects
in the view.

00:16:49.000 --> 00:16:54.130
And so that's why we see this
long, long list of things.

00:16:54.130 --> 00:16:56.090
So let's go to Comparison
View.

00:16:56.090 --> 00:16:57.880
Let's say we want to know,
what's the difference between

00:16:57.880 --> 00:17:01.760
snapshot two and snapshot one
when we click that button?

00:17:01.760 --> 00:17:03.700
And so it says we're in
Comparison View, and we're

00:17:03.700 --> 00:17:05.670
comparing with snapshot one.

00:17:05.670 --> 00:17:07.770
And so these are the
differences.

00:17:07.770 --> 00:17:10.430
And it's a much shorter list,
because we filtered out now.

00:17:10.430 --> 00:17:12.099
JOHN MCCUTCHAN: We really
culled a lot of it.

00:17:12.099 --> 00:17:18.270
LOREENA LEE: So these are
now showing us only the

00:17:18.270 --> 00:17:20.329
differences between
one and two.

00:17:20.329 --> 00:17:22.530
So you see we have this,
stuff object.

00:17:22.530 --> 00:17:25.670
And I told you that the cache
was a five item cache.

00:17:25.670 --> 00:17:27.950
And so there are five items.

00:17:27.950 --> 00:17:31.960
And way over here, you can
see, if we highlight the

00:17:31.960 --> 00:17:35.820
stuff, the delta between
snapshot two and snapshot one

00:17:35.820 --> 00:17:36.560
is plus five.

00:17:36.560 --> 00:17:38.920
So there's five new objects of
stuff, which is exactly what

00:17:38.920 --> 00:17:40.440
we expected.

00:17:40.440 --> 00:17:44.750
JOHN MCCUTCHAN: So this column
here is the number of objects

00:17:44.750 --> 00:17:46.890
that were created of that type,
this is the number that

00:17:46.890 --> 00:17:49.400
were deleted, and then this is
just the sum of the two.

00:17:49.400 --> 00:17:50.650
LOREENA LEE: Correct.

00:17:52.800 --> 00:17:53.760
So this is expected.

00:17:53.760 --> 00:17:55.080
We have a cache of size five.

00:17:55.080 --> 00:17:56.130
We push the button.

00:17:56.130 --> 00:17:57.320
We filled the cache.

00:17:57.320 --> 00:17:59.810
So this is what we were saying
earlier is that OK, well,

00:17:59.810 --> 00:18:00.840
there's no leak here.

00:18:00.840 --> 00:18:02.100
We expected to see five.

00:18:02.100 --> 00:18:03.140
There's five.

00:18:03.140 --> 00:18:05.300
So now we need a third one.

00:18:05.300 --> 00:18:06.570
So let's try that again.

00:18:06.570 --> 00:18:09.640
Let's do some work
and go ahead and

00:18:09.640 --> 00:18:10.890
collect a third snapshot.

00:18:13.350 --> 00:18:14.420
Memory is going up.

00:18:14.420 --> 00:18:16.800
We are at 1.4 now.

00:18:16.800 --> 00:18:25.650
And if we diff with the second
one again, we'll see that

00:18:25.650 --> 00:18:26.994
there are--

00:18:26.994 --> 00:18:29.630
oops, there we go--

00:18:29.630 --> 00:18:31.330
JOHN MCCUTCHAN: Another
five stuff for--

00:18:31.330 --> 00:18:31.980
LOREENA LEE: And that's fine.

00:18:31.980 --> 00:18:32.800
We allocated five.

00:18:32.800 --> 00:18:34.310
But we didn't delete anything.

00:18:34.310 --> 00:18:35.780
So, hmm.

00:18:35.780 --> 00:18:40.360
So if we look back in the
Summary View here, we'll see

00:18:40.360 --> 00:18:45.260
that there are now 10 objects
of type stuff.

00:18:45.260 --> 00:18:46.780
JOHN MCCUTCHAN: And this matches
what we saw in the

00:18:46.780 --> 00:18:50.310
timeline graph, where we were
never seeing anything go down.

00:18:50.310 --> 00:18:53.550
It just kept going up on
a fixed size, seeing

00:18:53.550 --> 00:18:55.170
the stair step in.

00:18:55.170 --> 00:18:58.450
LOREENA LEE: So another thing
that's great to see now is

00:18:58.450 --> 00:19:02.480
that we can go into the
Summary View again.

00:19:02.480 --> 00:19:05.950
And we can say, show me the
objects that were allocated

00:19:05.950 --> 00:19:08.160
before snapshot one.

00:19:08.160 --> 00:19:09.670
And that will show you that.

00:19:09.670 --> 00:19:12.400
And there shouldn't be any
stuff in this, because we

00:19:12.400 --> 00:19:14.290
hadn't filled any cache.

00:19:14.290 --> 00:19:17.120
But now you can say, show
me the objects that were

00:19:17.120 --> 00:19:19.490
allocated between snapshots
one and two.

00:19:19.490 --> 00:19:21.020
JOHN MCCUTCHAN: So we should
see five stuff.

00:19:21.020 --> 00:19:23.150
LOREENA LEE: So we should see
five things that were

00:19:23.150 --> 00:19:25.290
allocated between snapshots
one and two.

00:19:25.290 --> 00:19:27.630
And those things we expect have
been flushed out of the

00:19:27.630 --> 00:19:30.300
cache by the time that we
did the third snapshot.

00:19:30.300 --> 00:19:32.660
And so if they're still hanging
around in the heap in

00:19:32.660 --> 00:19:35.070
snapshot three, that's probably
our problem here.

00:19:35.070 --> 00:19:36.800
JOHN MCCUTCHAN: One thing we
should notice here is that

00:19:36.800 --> 00:19:40.090
when we're looking for the
summary of objects allocated

00:19:40.090 --> 00:19:44.210
between snapshots one and two,
you can tack on the sentence

00:19:44.210 --> 00:19:47.130
that are still alive
at snapshot three.

00:19:47.130 --> 00:19:52.180
So from the moment in time that
snapshot three was taken,

00:19:52.180 --> 00:19:54.470
these are objects that were
allocated between one and two

00:19:54.470 --> 00:19:56.650
that are still alive.

00:19:56.650 --> 00:19:59.010
So we should not see any
stuff here, if we

00:19:59.010 --> 00:19:59.860
weren't leaking memory.

00:19:59.860 --> 00:20:02.100
LOREENA LEE: Correct, exactly.

00:20:02.100 --> 00:20:03.560
So we are leaking memory.

00:20:03.560 --> 00:20:06.350
And we do see that there are
five objects that were

00:20:06.350 --> 00:20:10.130
allocated between subjects one
and two that are still alive

00:20:10.130 --> 00:20:11.910
in snapshot three.

00:20:11.910 --> 00:20:15.500
So if we go ahead and expand
this, you can see here that

00:20:15.500 --> 00:20:18.210
the stuff, we can click
on one of these.

00:20:18.210 --> 00:20:20.230
And on the bottom, you'll
see the retaining path.

00:20:20.230 --> 00:20:22.990
And it'll tell you that it's
being retained by the object

00:20:22.990 --> 00:20:27.880
data, which is in this
HTML div element.

00:20:27.880 --> 00:20:30.900
And this helps you figure out
where you're going to go and

00:20:30.900 --> 00:20:31.370
fix the problem.

00:20:31.370 --> 00:20:34.700
So you can tell exactly where
this is retained from who's

00:20:34.700 --> 00:20:36.260
holding on to the
handle from it.

00:20:36.260 --> 00:20:38.950
JOHN MCCUTCHAN: So remember the
retaining path is the path

00:20:38.950 --> 00:20:42.550
from a garbage collector
root to the variable

00:20:42.550 --> 00:20:45.180
that's being held.

00:20:45.180 --> 00:20:49.780
LOREENA LEE: So the other thing
to note is, here, none

00:20:49.780 --> 00:20:51.320
of these stuffs have
a background

00:20:51.320 --> 00:20:53.220
that is colored yellow.

00:20:53.220 --> 00:20:59.190
And if we look at the Summary
View with everything that's in

00:20:59.190 --> 00:21:02.240
snapshot three, we can
look at stuff.

00:21:02.240 --> 00:21:06.530
And we should see that half of
them are yellow and half of

00:21:06.530 --> 00:21:07.060
them are not.

00:21:07.060 --> 00:21:08.310
JOHN MCCUTCHAN: So why
are they yellow?

00:21:08.310 --> 00:21:09.830
LOREENA LEE: So the yellow
background indicates that

00:21:09.830 --> 00:21:13.460
there's a JavaScript handle
on this object.

00:21:13.460 --> 00:21:17.620
So there's a way to reach this
object through the JavaScript.

00:21:17.620 --> 00:21:19.870
And if it's not colored yellow,
there's very likely

00:21:19.870 --> 00:21:23.030
not to be a JavaScript handle,
which means you're going to

00:21:23.030 --> 00:21:24.360
have a hard time
cleaning it up.

00:21:24.360 --> 00:21:25.980
You've probably lost its
reference to it.

00:21:25.980 --> 00:21:29.350
It's still on the DOM tree, but
you lost your JavaScript

00:21:29.350 --> 00:21:29.930
reference to it.

00:21:29.930 --> 00:21:32.670
JOHN MCCUTCHAN: So you could
regain a reference to this by

00:21:32.670 --> 00:21:32.790
walking the dog.

00:21:32.790 --> 00:21:33.720
LOREENA LEE: By walking the--

00:21:33.720 --> 00:21:38.060
right, so it's not like it was
in the previous slides where

00:21:38.060 --> 00:21:40.970
we showed you that they were
true garbage that had zero

00:21:40.970 --> 00:21:43.240
path to the root
from the root.

00:21:43.240 --> 00:21:44.850
So it does have a path from the
root, but there's no way

00:21:44.850 --> 00:21:46.150
to access it from JavaScript.

00:21:46.150 --> 00:21:49.570
So this is why this is a
JavaScript memory leak and not

00:21:49.570 --> 00:21:52.420
necessarily a garbage
collectible leak.

00:21:52.420 --> 00:21:54.120
JOHN MCCUTCHAN: So the
yellow indicates

00:21:54.120 --> 00:21:55.140
that there is a path.

00:21:55.140 --> 00:21:58.580
And white indicates
that there is not.

00:21:58.580 --> 00:22:00.775
LOREENA LEE: And not
a JavaScript path.

00:22:00.775 --> 00:22:05.050
And if it were true garbage like
we had seen in the graphs

00:22:05.050 --> 00:22:08.390
that John presented earlier,
it would be with a red

00:22:08.390 --> 00:22:09.140
background.

00:22:09.140 --> 00:22:12.090
And those are things that
are in the [INAUDIBLE]

00:22:12.090 --> 00:22:12.630
DOM tree.

00:22:12.630 --> 00:22:14.680
They cannot be reached from
the root of the DOM node.

00:22:14.680 --> 00:22:16.420
But they're being retained
by something.

00:22:16.420 --> 00:22:18.840
So a lot of times
in those cases--

00:22:18.840 --> 00:22:23.190
and there's some good examples
of this on the dev website

00:22:23.190 --> 00:22:24.970
that have them highlighted
in red.

00:22:24.970 --> 00:22:27.310
And those are things that are
being retained for some reason

00:22:27.310 --> 00:22:29.240
or another.

00:22:29.240 --> 00:22:29.400
but.

00:22:29.400 --> 00:22:31.650
They're not reachable from
the root of the DOM tree.

00:22:31.650 --> 00:22:33.950
And so in those cases, you
should be able to open the

00:22:33.950 --> 00:22:34.740
retaining path.

00:22:34.740 --> 00:22:36.910
And you should see something
highlighted in yellow, which

00:22:36.910 --> 00:22:39.030
says you have a JavaScript
reference to this thing.

00:22:39.030 --> 00:22:40.920
But it's not in the
DOM tree at all.

00:22:40.920 --> 00:22:42.320
And that should help you.

00:22:42.320 --> 00:22:43.530
JOHN MCCUTCHAN: So these
are detached DOM nodes.

00:22:43.530 --> 00:22:45.560
LOREENA LEE: Right.

00:22:45.560 --> 00:22:48.230
And there's a great example of
that online as well so that we

00:22:48.230 --> 00:22:49.330
can go through that.

00:22:49.330 --> 00:22:51.730
So I think that's pretty
much the demo.

00:22:51.730 --> 00:22:53.820
So we can recap it.

00:22:53.820 --> 00:22:57.280
Let's go back to the
slides and recap.

00:23:01.850 --> 00:23:03.580
So we presented when Comparison

00:23:03.580 --> 00:23:04.700
View just isn't enough.

00:23:04.700 --> 00:23:07.750
And we showed that not all
memory leaks result in

00:23:07.750 --> 00:23:09.830
detached DOM tree nodes.

00:23:09.830 --> 00:23:12.150
There are things like
unintentional unbounded array

00:23:12.150 --> 00:23:13.830
growths, so you add things
to an array to

00:23:13.830 --> 00:23:14.680
be processed later.

00:23:14.680 --> 00:23:16.620
And you forget that you need to
clean it up at some point.

00:23:16.620 --> 00:23:19.080
So either you process it and
you never dumped it.

00:23:19.080 --> 00:23:21.240
So these kinds of things can
be caught with this three

00:23:21.240 --> 00:23:25.310
snapshot technique that
I just presented.

00:23:25.310 --> 00:23:26.210
And there's one other case.

00:23:26.210 --> 00:23:28.220
That's lingering event handlers
retaining DOM nodes

00:23:28.220 --> 00:23:29.620
that are otherwise detached.

00:23:29.620 --> 00:23:33.440
And that can be seen in the
scenario that I just

00:23:33.440 --> 00:23:35.930
explained, where you would have
something in red with a

00:23:35.930 --> 00:23:39.830
retaining path that has some
yellow nodes in it.

00:23:39.830 --> 00:23:42.350
And so that's when you would
want to bring out your three

00:23:42.350 --> 00:23:43.210
snapshot technique.

00:23:43.210 --> 00:23:47.050
JOHN MCCUTCHAN: So these are
some closure function that is

00:23:47.050 --> 00:23:49.510
attached as an event list
node to DOM node that

00:23:49.510 --> 00:23:50.370
is out of the DOM.

00:23:50.370 --> 00:23:51.980
LOREENA LEE: Correct.

00:23:51.980 --> 00:23:54.260
And this is just a graphical
representation of

00:23:54.260 --> 00:23:56.100
what we just did.

00:23:56.100 --> 00:23:58.720
But it's much better to see
that in the dev tools

00:23:58.720 --> 00:24:00.870
themselves.

00:24:00.870 --> 00:24:02.440
So hopefully this was helpful.

00:24:02.440 --> 00:24:03.360
JOHN MCCUTCHAN: Yeah,
I think so.

00:24:03.360 --> 00:24:05.142
I learned a lot.

00:24:05.142 --> 00:24:07.350
LOREENA LEE: Sounds good.

00:24:07.350 --> 00:24:10.330
JOHN MCCUTCHAN: So I think we
have a little bit of time.

00:24:10.330 --> 00:24:13.500
So here's a little quiz,
the tale of the

00:24:13.500 --> 00:24:15.340
missing object key.

00:24:15.340 --> 00:24:17.650
So if we look at the source code
on the slides here, you

00:24:17.650 --> 00:24:20.990
see a new object
is constructed.

00:24:20.990 --> 00:24:22.844
It's empty.

00:24:22.844 --> 00:24:26.750
A key called, double was added
and assigned to double value.

00:24:26.750 --> 00:24:30.290
A key called, integer was added
and assigned an integer.

00:24:30.290 --> 00:24:32.850
Then when you look at the
object, you can see the key

00:24:32.850 --> 00:24:34.260
double and integer are there.

00:24:34.260 --> 00:24:36.340
And the two values are there.

00:24:36.340 --> 00:24:39.830
So if you were to then take a
heap snapshot and look at the

00:24:39.830 --> 00:24:43.740
heap snapshot and find the
object, o, inside the

00:24:43.740 --> 00:24:47.770
containment view, you'll notice
that the integer key is

00:24:47.770 --> 00:24:49.160
missing from the
heap snapshot.

00:24:49.160 --> 00:24:52.030
That seems a little weird,
because we just confirmed that

00:24:52.030 --> 00:24:55.740
it is inside o, and it
is in fact inside o.

00:24:55.740 --> 00:25:02.600
But what's going on here is that
v8 has some tricks in how

00:25:02.600 --> 00:25:04.250
it stores integers.

00:25:04.250 --> 00:25:08.350
If the number fits into a signed
31-bit integer, then

00:25:08.350 --> 00:25:11.660
it's actually stitched into the
object graph structure and

00:25:11.660 --> 00:25:14.720
not actually part of the object
graph, which is kind of

00:25:14.720 --> 00:25:15.100
interesting.

00:25:15.100 --> 00:25:16.260
So look out for that.

00:25:16.260 --> 00:25:18.340
There's also cases
where a property

00:25:18.340 --> 00:25:20.150
is backed by a getter.

00:25:20.150 --> 00:25:26.410
And so when you do a heap
snapshot, the heap snapshot

00:25:26.410 --> 00:25:28.540
can't call the getter because
it might alter the program

00:25:28.540 --> 00:25:32.150
state or might be incredibly
expensive to call the getters,

00:25:32.150 --> 00:25:34.600
because there could be many
thousands of these objects

00:25:34.600 --> 00:25:35.930
with these getters.

00:25:35.930 --> 00:25:36.940
It avoids doing that.

00:25:36.940 --> 00:25:40.050
So you might see when you take a
heap snapshot that some keys

00:25:40.050 --> 00:25:41.640
are missing.

00:25:41.640 --> 00:25:42.890
But they're still there.

00:25:45.830 --> 00:25:46.940
LOREENA LEE: Good things
to be careful.

00:25:46.940 --> 00:25:48.350
JOHN MCCUTCHAN: So thanks a lot
for joining us, Loreena.

00:25:48.350 --> 00:25:48.690
LOREENA LEE: No problem.

00:25:48.690 --> 00:25:49.210
Thank you.

00:25:49.210 --> 00:25:50.692
Thanks for having me.

00:25:50.692 --> 00:25:51.120
JOHN MCCUTCHAN: Bye.

00:25:51.120 --> 00:25:52.370
LOREENA LEE: Bye, everyone.

