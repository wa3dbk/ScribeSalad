WEBVTT
Kind: captions
Language: en

00:00:06.000 --> 00:00:07.790
STEVE THAIR: We started off
with the offline panel.

00:00:07.790 --> 00:00:10.840
Now we're moving into a
networked world, where we are

00:00:10.840 --> 00:00:13.190
connected to a network even
though obviously we discussed

00:00:13.190 --> 00:00:16.860
a lot of network connected stuff
in the earlier session.

00:00:16.860 --> 00:00:19.850
I'm going to introduce the
panel very quickly.

00:00:19.850 --> 00:00:24.570
From the end, we have Ilya
Grigorik from Google.

00:00:24.570 --> 00:00:28.120
If any of you have been to
Velocity have seen Ilya

00:00:28.120 --> 00:00:30.950
present, he's going to give us
a little opening talk for 10

00:00:30.950 --> 00:00:33.110
minutes just to set the scene.

00:00:33.110 --> 00:00:35.960
So he shares an office with
Steve Souders, I think.

00:00:35.960 --> 00:00:38.425
There you go.

00:00:38.425 --> 00:00:42.470
Next to him, we have Andy
Davies, who's a local boy.

00:00:42.470 --> 00:00:43.290
So we're from Bristol.

00:00:43.290 --> 00:00:45.930
I don't know, where are you
from originally, Andy?

00:00:45.930 --> 00:00:47.280
ANDY DAVIES: Wales.

00:00:47.280 --> 00:00:48.530
I'm Welsh.

00:00:50.230 --> 00:00:51.480
STEVE THAIR: [INAUDIBLE].

00:00:53.420 --> 00:00:54.620
He's from Wales.

00:00:54.620 --> 00:00:58.000
Occasionally, they win a rugby
game but not lately.

00:00:58.000 --> 00:01:01.650
Next to him, we have John
Cleveley from the BBC.

00:01:01.650 --> 00:01:04.560
He was responsible for migrating
BBC News to a

00:01:04.560 --> 00:01:07.150
dynamic platform, been building
features mobile

00:01:07.150 --> 00:01:10.020
first, using responsive design
all the way up to the desktop.

00:01:10.020 --> 00:01:13.750
Yeah, I think Andrew wrote
that piece of thing.

00:01:13.750 --> 00:01:16.060
And last but not least,
we have Jackson.

00:01:16.060 --> 00:01:17.720
And Jackson's presented at our
London web performance user

00:01:17.720 --> 00:01:19.760
group and Velocity, and
stuff like that.

00:01:19.760 --> 00:01:22.190
He's described here as a
veteran troublemaker at

00:01:22.190 --> 00:01:22.580
Facebook London.

00:01:22.580 --> 00:01:23.460
I think it's supposed to be

00:01:23.460 --> 00:01:25.350
troubleshooter at
Facebook London.

00:01:25.350 --> 00:01:26.040
No?

00:01:26.040 --> 00:01:26.210
Troublemaker?

00:01:26.210 --> 00:01:27.430
OK.

00:01:27.430 --> 00:01:30.240
Works on tools and mobile, help
build mobile Timeline and

00:01:30.240 --> 00:01:31.700
App Center.

00:01:31.700 --> 00:01:33.340
Saying you had anything
to do with Timeline

00:01:33.340 --> 00:01:35.780
is extremely brave.

00:01:35.780 --> 00:01:36.040
Cool.

00:01:36.040 --> 00:01:39.710
So basically, we're just going
to kick off with Ilya giving

00:01:39.710 --> 00:01:40.960
some opening remarks.

00:01:46.100 --> 00:01:47.350
ILYA GRIGORIK: I'm not sure if
this microphone is working.

00:01:47.350 --> 00:01:48.334
No?

00:01:48.334 --> 00:01:49.318
Yes?

00:01:49.318 --> 00:01:49.810
STEVE THAIR: That one's not.

00:01:49.810 --> 00:01:50.800
Just use the [INAUDIBLE].

00:01:50.800 --> 00:01:52.970
ILYA GRIGORIK: This one works.

00:01:52.970 --> 00:01:54.400
That works.

00:01:54.400 --> 00:01:56.250
Now what's the magic trick
to get this thing?

00:01:56.250 --> 00:01:57.494
There.

00:01:57.494 --> 00:01:58.970
STEVE THAIR: We wave
to the nice man.

00:01:58.970 --> 00:02:00.642
ILYA GRIGORIK: OK.

00:02:00.642 --> 00:02:01.892
Hello.

00:02:03.820 --> 00:02:05.070
Waiting, waiting, waiting.

00:02:14.260 --> 00:02:16.230
Warming up.

00:02:16.230 --> 00:02:17.210
STEVE THAIR: Tell a joke.

00:02:17.210 --> 00:02:17.720
ILYA GRIGORIK: All right.

00:02:17.720 --> 00:02:20.400
Well, no jokes here.

00:02:20.400 --> 00:02:21.520
It's all serious stuff.

00:02:21.520 --> 00:02:22.770
It's all network performance.

00:02:26.030 --> 00:02:26.900
JACKSON GABBARD: The
crowd looks lovely.

00:02:26.900 --> 00:02:29.120
You look great today.

00:02:29.120 --> 00:02:31.240
ILYA GRIGORIK: But seriously,
I'm not

00:02:31.240 --> 00:02:33.270
going to take 10 minutes.

00:02:33.270 --> 00:02:37.870
It's far more interesting to
talk about on the panel to

00:02:37.870 --> 00:02:39.460
answer-- there's a lot
of questions in the

00:02:39.460 --> 00:02:41.040
Moderator as well.

00:02:41.040 --> 00:02:43.550
So I'm just going to kick
off with a couple of--

00:02:43.550 --> 00:02:45.700
let me see, wrong screen.

00:02:48.410 --> 00:02:49.660
That is weird.

00:02:52.630 --> 00:02:53.880
Can you guys see that?

00:03:01.090 --> 00:03:01.430
All right.

00:03:01.430 --> 00:03:04.080
There we go.

00:03:04.080 --> 00:03:07.480
So one thing that I've
discovered as I've been

00:03:07.480 --> 00:03:09.930
working on network performance
stuff is, I've been becoming

00:03:09.930 --> 00:03:13.260
grumpier and grumpier, in the
sense that people keep asking,

00:03:13.260 --> 00:03:15.980
hey, we should put more
stuff on pages.

00:03:15.980 --> 00:03:17.280
I want to put more images,
more video.

00:03:17.280 --> 00:03:19.800
I'm like, no, no, don't do
that, because that hurts

00:03:19.800 --> 00:03:20.650
performance.

00:03:20.650 --> 00:03:21.960
Everything you do hurts
performance.

00:03:21.960 --> 00:03:24.430
So the fewer things you put
on your page, the better.

00:03:24.430 --> 00:03:27.240
So because of that, I've started
actually migrating my

00:03:27.240 --> 00:03:30.290
HTML presentations to Bash just
to illustrate the point

00:03:30.290 --> 00:03:32.540
that go as low level
as you can.

00:03:32.540 --> 00:03:36.260
So this is actually running in
Chrome VSSH but in Bash.

00:03:36.260 --> 00:03:37.850
So it's awesome.

00:03:37.850 --> 00:03:39.840
Anyway, moving on.

00:03:39.840 --> 00:03:42.970
So a lot of the network stuff
is not the sexy stuff.

00:03:42.970 --> 00:03:44.650
We can talk about all the
awesome things that we're

00:03:44.650 --> 00:03:47.120
building, all the new
CSS animations.

00:03:47.120 --> 00:03:48.832
And then you start talking about
performance and it's

00:03:48.832 --> 00:03:50.940
like, yeah, that TCP thing.

00:03:50.940 --> 00:03:52.670
Ugh.

00:03:52.670 --> 00:03:56.150
So a few things, I have like
four high-level things that I

00:03:56.150 --> 00:03:59.480
want to seed the discussion
a little bit.

00:03:59.480 --> 00:04:00.140
Cache primitives.

00:04:00.140 --> 00:04:02.480
So we heard a lot about
caching and offline.

00:04:02.480 --> 00:04:05.660
And I'm really excited for the
stuff that's happening in the

00:04:05.660 --> 00:04:06.440
offline panel.

00:04:06.440 --> 00:04:09.720
I think that's a big,
big improvement.

00:04:09.720 --> 00:04:11.840
It'll obviously take some
time to get there.

00:04:11.840 --> 00:04:13.770
The local storage stuff
is really interesting.

00:04:13.770 --> 00:04:16.899
I'll just add maybe one more
comment to the earlier

00:04:16.899 --> 00:04:18.060
discussion.

00:04:18.060 --> 00:04:19.339
I don't think it's
a solved problem.

00:04:19.339 --> 00:04:22.640
The fact that it's a sync or
async API I think, is maybe

00:04:22.640 --> 00:04:26.490
slightly the wrong question to
ask, because for example, if

00:04:26.490 --> 00:04:28.700
you look at local storage
performance on Windows, it's

00:04:28.700 --> 00:04:30.180
actually really good.

00:04:30.180 --> 00:04:31.270
Why is that?

00:04:31.270 --> 00:04:35.450
Because they have SuperFetch,
which is a platform feature

00:04:35.450 --> 00:04:38.480
within Windows which pre-loads
all the data

00:04:38.480 --> 00:04:39.610
independent of the app.

00:04:39.610 --> 00:04:42.140
So this is not an IE feature.

00:04:42.140 --> 00:04:44.860
IE doesn't have these latency
delays that Chrome does.

00:04:44.860 --> 00:04:45.860
In fact, Chrome is
like the worst

00:04:45.860 --> 00:04:47.580
performer in local storage.

00:04:47.580 --> 00:04:49.430
It's something that
we've got to fix.

00:04:49.430 --> 00:04:53.460
So I don't think it's as
simple as we maybe

00:04:53.460 --> 00:04:54.180
make it out to be.

00:04:54.180 --> 00:04:55.730
Just having an async
API doesn't

00:04:55.730 --> 00:04:56.780
necessarily solve the problems.

00:04:56.780 --> 00:04:58.890
I think there's an 80% solution
even for something

00:04:58.890 --> 00:05:00.940
like local storage.

00:05:00.940 --> 00:05:04.750
The fact that this new
controller script is actually

00:05:04.750 --> 00:05:09.570
interacting with the browser's
cache, I think is awesome.

00:05:09.570 --> 00:05:11.870
Unlike the previous versions,
which it's

00:05:11.870 --> 00:05:12.950
either all or nothing.

00:05:12.950 --> 00:05:14.790
You don't have a fallback.

00:05:14.790 --> 00:05:17.430
So I think this is
all great stuff.

00:05:17.430 --> 00:05:20.380
But moving on, something that
I've been spending a lot of

00:05:20.380 --> 00:05:23.050
time thinking about
and fighting with

00:05:23.050 --> 00:05:24.650
is user-agent sniffing.

00:05:24.650 --> 00:05:27.540
I think we can all agree that
this thing is just dead.

00:05:27.540 --> 00:05:28.595
We all have to use it.

00:05:28.595 --> 00:05:29.720
It's unfortunate.

00:05:29.720 --> 00:05:30.550
It sucks.

00:05:30.550 --> 00:05:31.900
You have to pay for
these databases.

00:05:31.900 --> 00:05:33.610
You have to get a new
serving path.

00:05:33.610 --> 00:05:36.560
It is a disaster, no matter
which way you look at it.

00:05:36.560 --> 00:05:38.290
And not only that, but it
doesn't actually give you the

00:05:38.290 --> 00:05:41.910
answers that you're looking
for, which is the best

00:05:41.910 --> 00:05:43.330
combination of all
those things.

00:05:43.330 --> 00:05:45.060
So I do have a proposal
out there.

00:05:45.060 --> 00:05:47.870
We actually have a prototype
that's in progress in Chrome

00:05:47.870 --> 00:05:50.700
for this thing called Client
Hints, which is the world's

00:05:50.700 --> 00:05:53.320
dumbest idea, which is if you're
looking for a DPI, why

00:05:53.320 --> 00:05:57.710
don't we just send it to you
in an HTTP request header?

00:05:57.710 --> 00:05:59.260
That's really all it
boils down to.

00:05:59.260 --> 00:06:01.030
So if you're curious,
take a look.

00:06:01.030 --> 00:06:02.180
I'd love to get your feedback.

00:06:02.180 --> 00:06:05.480
But I think this would actually
help quite a bit with

00:06:05.480 --> 00:06:10.480
a lot of problems in the
responsive design world.

00:06:10.480 --> 00:06:14.190
And speaking of responsive
design, if you talk about

00:06:14.190 --> 00:06:17.480
network performance and web
pages, 60% of all the bytes

00:06:17.480 --> 00:06:20.440
that we ship today are images,
which is huge.

00:06:20.440 --> 00:06:24.460
So if nothing else, if there's
one area we can really focus

00:06:24.460 --> 00:06:28.020
on and fix and improve, it seems
like images would be it.

00:06:28.020 --> 00:06:30.790
And unfortunately, if you look
at what's happened in the

00:06:30.790 --> 00:06:35.190
image space, nothing
has happened.

00:06:35.190 --> 00:06:38.230
We have PNG, JPEG, and
GIF, and that's it.

00:06:38.230 --> 00:06:42.900
And it's not obvious why we
don't have another 10 formats.

00:06:42.900 --> 00:06:46.210
I don't know if 10 is needed,
but at least another couple.

00:06:46.210 --> 00:06:49.790
We have WebP that we have
proposed at Google.

00:06:49.790 --> 00:06:51.550
And WebP gives you a lot
of improvements.

00:06:51.550 --> 00:06:54.010
But I don't think WebP
is the end all.

00:06:54.010 --> 00:06:55.950
I'd hope to see more
image formats.

00:06:55.950 --> 00:06:58.730
And it's not obvious why we're
just stuck with these three.

00:06:58.730 --> 00:07:02.610
Then you look at products like
Opera Turbo, Silk, PageSpeed.

00:07:02.610 --> 00:07:05.360
Opera Turbo is an incredibly
popular browser in a lot of

00:07:05.360 --> 00:07:09.370
countries where bandwidth
is at a premium.

00:07:09.370 --> 00:07:12.850
Like 90% of all of the
improvements that all these

00:07:12.850 --> 00:07:14.585
proxies get is they
just re-encode all

00:07:14.585 --> 00:07:16.280
the images with WebP.

00:07:16.280 --> 00:07:18.550
That's literally all they do,
just blindly transcode

00:07:18.550 --> 00:07:19.810
everything to WebP.

00:07:19.810 --> 00:07:23.110
So that alone is like, why don't
we do that for the rest

00:07:23.110 --> 00:07:24.370
of all the pages?

00:07:24.370 --> 00:07:29.620
So we could decrease the size
of our pages by 50% by just

00:07:29.620 --> 00:07:33.830
re-encoding all the images,
which seems like

00:07:33.830 --> 00:07:34.950
a pretty nice thing.

00:07:34.950 --> 00:07:36.780
And speaking of re-encoding
images, one

00:07:36.780 --> 00:07:37.740
thing that I've realized--

00:07:37.740 --> 00:07:43.130
I've done a lot of studies now
looking at WordPress sites and

00:07:43.130 --> 00:07:47.230
a whole number of
other content--

00:07:47.230 --> 00:07:51.420
it turns out we, as humans, suck
at picking image formats.

00:07:51.420 --> 00:07:52.920
We are either lazy.

00:07:52.920 --> 00:07:55.360
We are either too busy.

00:07:55.360 --> 00:07:56.560
We pick the wrong formats.

00:07:56.560 --> 00:08:01.370
So we save things as PNGs,
which should be JPEGs.

00:08:01.370 --> 00:08:04.930
We save things as JPEGs,
which should be PNGs.

00:08:04.930 --> 00:08:06.360
It's just a disaster.

00:08:06.360 --> 00:08:09.160
And there's a lot of image
optimization solutions out

00:08:09.160 --> 00:08:12.070
there that exist that you
actually can pay for, which

00:08:12.070 --> 00:08:13.580
will say, hey, we'll optimize
your images.

00:08:13.580 --> 00:08:15.370
If you give us a PNG,
we'll strip the

00:08:15.370 --> 00:08:16.310
metadata and all the rest.

00:08:16.310 --> 00:08:17.140
It's like, cool.

00:08:17.140 --> 00:08:20.360
You're going to strip
100 bytes out of my

00:08:20.360 --> 00:08:22.100
150 kilobyte image.

00:08:22.100 --> 00:08:24.090
I'm like, that's still a win.

00:08:24.090 --> 00:08:26.330
But the truth is, you should
have been saving that as a

00:08:26.330 --> 00:08:29.050
JPEG, which would have
been a 15k file.

00:08:29.050 --> 00:08:31.580
And we're not doing
that transcoding,

00:08:31.580 --> 00:08:35.049
because it's much harder.

00:08:35.049 --> 00:08:36.860
I think that's something
that we need to fix.

00:08:36.860 --> 00:08:39.710
And this problem only gets much,
much harder when you

00:08:39.710 --> 00:08:43.980
look at the responsive area,
where now you have different

00:08:43.980 --> 00:08:44.510
break points.

00:08:44.510 --> 00:08:47.130
You have different
device widths.

00:08:47.130 --> 00:08:51.130
I recently ran a study looking
at how frequently do we

00:08:51.130 --> 00:08:54.250
re-scale images on a client or
downscale images on a client.

00:08:54.250 --> 00:08:57.660
And it turns out that about 20%
of all the large images

00:08:57.660 --> 00:08:58.930
are getting downscaled
in the client.

00:08:58.930 --> 00:09:01.480
So we're shipping extra bytes,
which was getting compressed.

00:09:01.480 --> 00:09:04.600
This is just wasted bandwidth.

00:09:04.600 --> 00:09:06.940
I think we need server help.

00:09:06.940 --> 00:09:08.410
We need a client-side
solution, which

00:09:08.410 --> 00:09:10.590
we don't have today.

00:09:10.590 --> 00:09:15.530
There's a lot of room for better
server integration to

00:09:15.530 --> 00:09:18.520
help us with this problem,
because it only gets worse.

00:09:18.520 --> 00:09:20.100
You have five different
viewports.

00:09:20.100 --> 00:09:23.940
You have high DPI, non-high DPI,
now you have 10 variants.

00:09:23.940 --> 00:09:27.730
Add some art direction use
cases, and now you're like,

00:09:27.730 --> 00:09:30.300
you started with an image tag,
which was beautiful, one line.

00:09:30.300 --> 00:09:32.660
Then you look at your picture
tag, and it's like 40 lines.

00:09:32.660 --> 00:09:34.610
And you're like, I am
not writing that.

00:09:34.610 --> 00:09:36.750
I'm sorry.

00:09:36.750 --> 00:09:38.540
At least that's for me.

00:09:38.540 --> 00:09:40.090
Another crowd favorite--

00:09:40.090 --> 00:09:41.050
net info API.

00:09:41.050 --> 00:09:45.330
So let me just talk about
this one for a second.

00:09:45.330 --> 00:09:48.710
So bandwidth estimation--

00:09:48.710 --> 00:09:50.530
should we have bandwidth
estimation in a browser?

00:09:50.530 --> 00:09:52.760
And the answer is no--

00:09:55.980 --> 00:09:56.410
ever.

00:09:56.410 --> 00:09:57.000
Yes.

00:09:57.000 --> 00:09:57.380
Right.

00:09:57.380 --> 00:09:59.090
So why is that?

00:09:59.090 --> 00:10:00.660
It's worth actually
thinking about it.

00:10:00.660 --> 00:10:02.630
And usually there's
a good counter

00:10:02.630 --> 00:10:03.490
argument to that as well.

00:10:03.490 --> 00:10:05.410
We have that.

00:10:05.410 --> 00:10:07.250
We have that for video.

00:10:07.250 --> 00:10:13.710
And the insight there is when we
do do server adaptation for

00:10:13.710 --> 00:10:17.650
video, but the way that works
is we stream you a five

00:10:17.650 --> 00:10:19.230
[? to ?] second chunk
of video.

00:10:19.230 --> 00:10:20.910
Then we see how you
downloaded it.

00:10:20.910 --> 00:10:22.900
And then we adjust.

00:10:22.900 --> 00:10:25.690
So it's adaptive streaming,
not predictive streaming.

00:10:25.690 --> 00:10:28.750
If you look at the actual
bandwidth throughput,

00:10:28.750 --> 00:10:31.850
especially on mobile, your
mobile carrier can adjust your

00:10:31.850 --> 00:10:35.150
bandwidth on one millisecond
granularity.

00:10:35.150 --> 00:10:40.630
Me moving a phone from here on
my desk to here can double or

00:10:40.630 --> 00:10:43.020
take my bandwidth by half.

00:10:43.020 --> 00:10:45.980
There's such high amounts of
variability that we can

00:10:45.980 --> 00:10:49.180
predict bandwidth, or we have
stable bandwidth on the order

00:10:49.180 --> 00:10:50.210
of milliseconds--

00:10:50.210 --> 00:10:52.880
maybe at most, second.

00:10:52.880 --> 00:10:55.420
It's completely unpredictable,
anything beyond that.

00:10:55.420 --> 00:11:00.260
So you sending a request for a
GIF file and then fetching

00:11:00.260 --> 00:11:02.800
that and saying, ooh, one
megabyte per second.

00:11:02.800 --> 00:11:05.190
And then making a decision
is completely useless.

00:11:05.190 --> 00:11:08.490
So maybe if we switch all of our
internet back to circuit

00:11:08.490 --> 00:11:11.120
switch networks, then we can
have this conversation.

00:11:11.120 --> 00:11:15.320
But I don't think that's
going to happen.

00:11:15.320 --> 00:11:17.350
And then the last one, which I
think is something that we

00:11:17.350 --> 00:11:20.930
haven't actually talked about,
is radio and mobile.

00:11:20.930 --> 00:11:24.140
So mobile is obviously a big,
big topic for networking.

00:11:24.140 --> 00:11:28.170
And battery life is something
that I don't think we, as web

00:11:28.170 --> 00:11:31.170
developers, have actually
thought about at all.

00:11:31.170 --> 00:11:33.570
Battery life is actually, turns
out, very important for

00:11:33.570 --> 00:11:35.650
native apps, because people
rank these apps.

00:11:35.650 --> 00:11:37.340
You run this thing, and your
battery's dead, and you're

00:11:37.340 --> 00:11:38.790
like, this app sucks.

00:11:38.790 --> 00:11:40.860
For web pages, we haven't
thought about it.

00:11:40.860 --> 00:11:44.030
But in reality, they
are just as costly.

00:11:44.030 --> 00:11:47.540
I can point you to pages where
if you sit there reading your

00:11:47.540 --> 00:11:49.450
news, for example, on some
sites which are using

00:11:49.450 --> 00:11:55.670
real-time analytics, every
five seconds they send a

00:11:55.670 --> 00:11:58.400
real-time beacon for a real-time
analytics app.

00:11:58.400 --> 00:12:00.170
You're just draining
your battery.

00:12:00.170 --> 00:12:01.960
It's killing your battery.

00:12:01.960 --> 00:12:05.980
The radio is the second most
expensive thing you have in

00:12:05.980 --> 00:12:07.290
your phone in terms of power.

00:12:07.290 --> 00:12:08.330
The first one is the screen.

00:12:08.330 --> 00:12:10.760
The second one is the radio.

00:12:10.760 --> 00:12:12.610
And they're actually
about the same--

00:12:12.610 --> 00:12:14.420
the same order of magnitude.

00:12:14.420 --> 00:12:17.530
So turning off your radio
is incredibly important.

00:12:17.530 --> 00:12:20.650
There is big, big anti-patterns,
stuff like

00:12:20.650 --> 00:12:22.500
inefficiency of periodic
transfers.

00:12:22.500 --> 00:12:25.130
And I think this one's really
illustrative, because even if

00:12:25.130 --> 00:12:30.110
you look at the Android docs,
two years ago when we started

00:12:30.110 --> 00:12:33.620
building these native apps, we
said, hey, fetch just the

00:12:33.620 --> 00:12:35.360
stuff that you need.

00:12:35.360 --> 00:12:38.950
And then as the user needs it,
fetch the rest of the content,

00:12:38.950 --> 00:12:41.310
thinking that you don't
have enough bandwidth.

00:12:41.310 --> 00:12:43.800
And you should get the best
experience up and then

00:12:43.800 --> 00:12:45.330
progressively fill in.

00:12:45.330 --> 00:12:46.830
If you look at the docs
now, they tell you

00:12:46.830 --> 00:12:47.960
completely the opposite.

00:12:47.960 --> 00:12:49.740
They tell you download
everything.

00:12:49.740 --> 00:12:51.510
Burst everything you can
as fast as you can.

00:12:51.510 --> 00:12:52.480
And then turn off the radio.

00:12:52.480 --> 00:12:56.170
And please, please, please don't
turn it on ever again.

00:12:56.170 --> 00:12:58.780
So I don't think that message
has reached the

00:12:58.780 --> 00:12:59.870
web developer community.

00:12:59.870 --> 00:13:02.030
And it's actually pretty
interesting to think, I don't

00:13:02.030 --> 00:13:04.630
think we have an answer for
how exactly do we service

00:13:04.630 --> 00:13:06.500
battery and network
performance?

00:13:06.500 --> 00:13:07.790
What's that trade off?

00:13:07.790 --> 00:13:11.430
We don't have an intuition in
the browser for what is the

00:13:11.430 --> 00:13:12.370
cost of a page.

00:13:12.370 --> 00:13:14.960
I'd love to see a metric that's
says, you've drained x

00:13:14.960 --> 00:13:16.840
amount of your battery by
visiting this page.

00:13:16.840 --> 00:13:18.520
That would be kind of cool.

00:13:18.520 --> 00:13:21.130
And then the last one is
4G won't save you.

00:13:21.130 --> 00:13:24.270
I see a lot of conversations
about this, which is like, I

00:13:24.270 --> 00:13:27.470
heard LTE is going to
fix all things.

00:13:27.470 --> 00:13:30.440
I'm just going to
wait for that.

00:13:30.440 --> 00:13:31.830
Seems reasonable.

00:13:31.830 --> 00:13:34.610
And it seems reasonable
when you're here.

00:13:34.610 --> 00:13:37.210
You're in downtown London, then
you probably have really

00:13:37.210 --> 00:13:38.100
good coverage.

00:13:38.100 --> 00:13:39.830
The problem is when you actually
look at what the

00:13:39.830 --> 00:13:42.770
carriers are saying, they're
saying, look, we've invested a

00:13:42.770 --> 00:13:44.920
lot of money into 3G
and 2G networks.

00:13:44.920 --> 00:13:47.090
We have a lot of users on older
hardware that can't

00:13:47.090 --> 00:13:49.290
migrate to 4G overnight.

00:13:49.290 --> 00:13:52.820
3G and 2G networks will continue
to exist for at least

00:13:52.820 --> 00:13:55.400
another decade, at least
another decade.

00:13:55.400 --> 00:13:58.850
And you'll have to build apps
that will transition between

00:13:58.850 --> 00:14:01.560
4G, 3G, and 2G.

00:14:01.560 --> 00:14:04.180
And that's just the
reality of it.

00:14:04.180 --> 00:14:08.320
You can't design your apps
just targeting 4G.

00:14:08.320 --> 00:14:12.140
So those are the high-level
points.

00:14:12.140 --> 00:14:12.760
That's all I got.

00:14:12.760 --> 00:14:14.428
I think we'll go
into the panel.

00:14:20.902 --> 00:14:22.894
STEVE THAIR: I think
we're done here.

00:14:22.894 --> 00:14:23.890
That's pretty good.

00:14:23.890 --> 00:14:27.376
[APPLAUSE]

00:14:34.924 --> 00:14:36.680
STEVE THAIR: I'm going to try
to come out from behind the

00:14:36.680 --> 00:14:38.767
panel a bit so I can actually
see them instead

00:14:38.767 --> 00:14:39.780
of talking to them.

00:14:39.780 --> 00:14:40.960
Make sure you talk to them.

00:14:40.960 --> 00:14:42.030
Don't talk to me.

00:14:42.030 --> 00:14:43.690
Can everybody hear
me all right?

00:14:43.690 --> 00:14:44.600
Yeah?

00:14:44.600 --> 00:14:45.580
OK.

00:14:45.580 --> 00:14:47.570
So the first question we
actually have-- the highest

00:14:47.570 --> 00:14:49.920
ranked question on the list--
is, should we have continuous

00:14:49.920 --> 00:14:52.910
live feedback access to the
user's network speed, similar

00:14:52.910 --> 00:14:53.430
to [? navigate ?]

00:14:53.430 --> 00:14:53.820
[? or battery? ?]

00:14:53.820 --> 00:14:55.070
And the answer is?

00:14:55.070 --> 00:14:57.380
ALL: No.

00:14:57.380 --> 00:14:58.810
STEVE THAIR: You'd think
we rehearsed that.

00:14:58.810 --> 00:15:00.860
Awesome.

00:15:00.860 --> 00:15:02.860
There are actually a
few questions that

00:15:02.860 --> 00:15:05.410
were about that topic.

00:15:05.410 --> 00:15:07.185
Some people obviously
hadn't heard of net

00:15:07.185 --> 00:15:09.950
API, some people had.

00:15:09.950 --> 00:15:12.970
I don't even think it was worth
really asking any of

00:15:12.970 --> 00:15:14.325
those other questions.

00:15:14.325 --> 00:15:14.930
Just say no?

00:15:14.930 --> 00:15:17.125
ILYA GRIGORIK: Can we take
a step back, though?

00:15:17.125 --> 00:15:19.170
STEVE THAIR: OK.

00:15:19.170 --> 00:15:20.620
ILYA GRIGORIK: We can't have
bandwidth estimation.

00:15:20.620 --> 00:15:22.850
I can't tell you you have two
megabytes per second, three

00:15:22.850 --> 00:15:23.840
megabytes per second.

00:15:23.840 --> 00:15:26.980
It is useful to know which type
of network you are on,

00:15:26.980 --> 00:15:29.090
which is the level of
granularity that you should be

00:15:29.090 --> 00:15:30.360
working at.

00:15:30.360 --> 00:15:32.530
Knowing that you're on Wi-Fi
tells you certain things

00:15:32.530 --> 00:15:34.955
about, for example, the latency
characteristics of

00:15:34.955 --> 00:15:36.110
your connection.

00:15:36.110 --> 00:15:38.650
You're now going to have a weird
transition state where

00:15:38.650 --> 00:15:40.600
you have to wait for two seconds
before you actually

00:15:40.600 --> 00:15:42.330
get any packets on the wire.

00:15:42.330 --> 00:15:45.180
If you're on 4G, you
have pretty tight

00:15:45.180 --> 00:15:46.970
bounds on latency again.

00:15:46.970 --> 00:15:49.610
Knowing on 3G-- so basically
it gives you goal posts.

00:15:49.610 --> 00:15:52.160
Like, here's what the minimum,
here's what the maximum is.

00:15:52.160 --> 00:15:54.410
And that's about the level
that we need to operate.

00:15:54.410 --> 00:15:56.740
So the net info spec
actually had this--

00:15:56.740 --> 00:15:58.090
the earlier versions.

00:15:58.090 --> 00:16:02.090
It specifically said,
Wi-Fi 2G, 3G, 4G.

00:16:02.090 --> 00:16:06.190
I think we need to revert to
spec, like, 15 iterations, go

00:16:06.190 --> 00:16:08.324
back and implement that.

00:16:08.324 --> 00:16:11.357
JOHN CLEVELEY: Also, when I'm
at home in Suffolk in the

00:16:11.357 --> 00:16:13.800
middle of the country, my
Wi-Fi I get about a meg.

00:16:13.800 --> 00:16:16.312
I come into London with my
phone and I get about the

00:16:16.312 --> 00:16:17.880
same, even better sometimes.

00:16:17.880 --> 00:16:20.530
So it's like you've got to use
the information quite wisely

00:16:20.530 --> 00:16:22.300
in terms of not making
too many assumptions.

00:16:22.300 --> 00:16:25.610
But the latency thing is
definitely going to help make

00:16:25.610 --> 00:16:29.740
decisions between 3G
wireless and Wi-Fi.

00:16:29.740 --> 00:16:32.860
JACKSON GABBARD: It's always the
one-legged dog [INAUDIBLE]

00:16:32.860 --> 00:16:35.500
from the 4G, you get
intermittent one-bar

00:16:35.500 --> 00:16:35.880
connection.

00:16:35.880 --> 00:16:37.460
That's not as good as
the 3G connection.

00:16:37.460 --> 00:16:40.390
But yeah, even then it's
still fraught.

00:16:40.390 --> 00:16:41.783
[INAUDIBLE], it's not granular,

00:16:41.783 --> 00:16:43.755
immediately useful data.

00:16:43.755 --> 00:16:46.440
ANDY DAVIES: The original spec
got dumped for privacy

00:16:46.440 --> 00:16:47.360
reasons, didn't it?

00:16:47.360 --> 00:16:48.700
ILYA GRIGORIK: I think
the privacy reason

00:16:48.700 --> 00:16:50.190
is completely bogus.

00:16:50.190 --> 00:16:51.825
So let's just put
that to rest.

00:16:51.825 --> 00:16:54.290
AUDIENCE: One other factor,
could it tell you that the

00:16:54.290 --> 00:16:56.266
[INAUDIBLE] is roaming,
moving?

00:16:56.266 --> 00:16:59.100
AUDIENCE: Use the mic, please.

00:16:59.100 --> 00:17:01.790
STEVE THAIR: So the question
from Daryl was, could the spec

00:17:01.790 --> 00:17:04.800
just at least tell you whether
the person is actually moving,

00:17:04.800 --> 00:17:07.069
like if you're in a moving car
and a moving train, which has

00:17:07.069 --> 00:17:11.339
an impact, certainly
on 3G, anyway.

00:17:11.339 --> 00:17:13.552
ILYA GRIGORIK: I guess you could
enable GPS and look at

00:17:13.552 --> 00:17:15.460
the coordinates if
they're changing.

00:17:15.460 --> 00:17:17.780
But hold on, but I think there's
two different things--

00:17:17.780 --> 00:17:21.090
roaming and moving are
two different things.

00:17:21.090 --> 00:17:23.730
AUDIENCE: [INAUDIBLE]

00:17:23.730 --> 00:17:24.730
STEVE THAIR: Yes.

00:17:24.730 --> 00:17:28.310
He meant motion, as opposed
to paying 25 US dollars a

00:17:28.310 --> 00:17:31.280
megabyte through Verizon in
Gibraltar type roaming.

00:17:31.280 --> 00:17:32.990
ILYA GRIGORIK: Yeah.

00:17:32.990 --> 00:17:35.680
STEVE THAIR: That would probably
also be useful.

00:17:35.680 --> 00:17:36.500
ILYA GRIGORIK: So I don't
think that's a

00:17:36.500 --> 00:17:38.590
concern of net info.

00:17:38.590 --> 00:17:43.100
So if you are on the move, for
example, 4G performance is

00:17:43.100 --> 00:17:47.620
much, much better than 3G
performance if you are moving.

00:17:47.620 --> 00:17:52.150
I don't think that's something
that net info would service.

00:17:52.150 --> 00:17:56.950
STEVE THAIR: So one question
from me is that if net info is

00:17:56.950 --> 00:17:59.340
giving you an API that you
have to query in your

00:17:59.340 --> 00:18:02.230
JavaScript, and then you send
that message back, why is the

00:18:02.230 --> 00:18:05.660
browser not sending that message
to the server side in

00:18:05.660 --> 00:18:07.470
a header or an unsolicited
cookie?

00:18:07.470 --> 00:18:10.480
So from the point of view before
I've even served the

00:18:10.480 --> 00:18:15.310
request, I've got an idea of
what the connection type is.

00:18:15.310 --> 00:18:20.380
ANDY DAVIES: Well, that comes as
part of Ilya's Client Hints

00:18:20.380 --> 00:18:23.790
spec, which is also growing into
the same privacy concerns

00:18:23.790 --> 00:18:25.710
from some people.

00:18:25.710 --> 00:18:28.710
So the idea that whenever
somebody makes a request of

00:18:28.710 --> 00:18:31.170
your server, you expose their
screen size or how they

00:18:31.170 --> 00:18:34.450
connected, starts to give
you ways of actually

00:18:34.450 --> 00:18:35.440
fingerprinting browsers.

00:18:35.440 --> 00:18:36.940
And we can do it pretty
well anyway.

00:18:36.940 --> 00:18:38.550
So there are some privacy
concerns about it.

00:18:38.550 --> 00:18:41.370
ILYA GRIGORIK: So, once
again, privacy stuff--

00:18:41.370 --> 00:18:42.160
completely bogus.

00:18:42.160 --> 00:18:43.455
Because you just
look at your--

00:18:43.455 --> 00:18:44.662
no, no

00:18:44.662 --> 00:18:47.490
STEVE THAIR: Who do you
work for again?

00:18:47.490 --> 00:18:50.270
ILYA GRIGORIK: If you have the
IP address of your visitor,

00:18:50.270 --> 00:18:54.700
you can do reverse map to say,
hey, you're on T-Mobile.

00:18:54.700 --> 00:18:57.830
And you're coming from the
subnet, so you're probably on

00:18:57.830 --> 00:18:58.290
3G network.

00:18:58.290 --> 00:19:01.050
That is what the CDNs
are doing today.

00:19:01.050 --> 00:19:02.780
This is all the information
that we're exposing.

00:19:02.780 --> 00:19:05.330
So I think this actually
doesn't hold

00:19:05.330 --> 00:19:09.252
much water, this argument.

00:19:09.252 --> 00:19:11.712
AUDIENCE: I actually don't think
the privacy issue has

00:19:11.712 --> 00:19:14.740
been the main killing issue
of these features.

00:19:14.740 --> 00:19:17.730
That with the sending in
additional headers, the

00:19:17.730 --> 00:19:20.986
problem is, there are billions
of requests happening every

00:19:20.986 --> 00:19:22.115
day right now, right?

00:19:22.115 --> 00:19:26.440
If you add even, like, 20
bytes of data into each

00:19:26.440 --> 00:19:28.465
request, we're talking about
gigabytes and gigabytes of

00:19:28.465 --> 00:19:35.300
data being sent for absolutely
no reason in 99.999% of cases.

00:19:35.300 --> 00:19:37.390
So that's the main problem
about [INAUDIBLE].

00:19:37.390 --> 00:19:41.110
AUDIENCE: Mic, please.

00:19:41.110 --> 00:19:42.595
JACKSON GABBARD: I
agree with that.

00:19:42.595 --> 00:19:45.690
I think the crux of the issue is
less the network connection

00:19:45.690 --> 00:19:47.326
of [INAUDIBLE]

00:19:47.326 --> 00:19:48.720
the information that you can
glean about the network or the

00:19:48.720 --> 00:19:50.007
device that you're sending to.

00:19:50.007 --> 00:19:52.830
That's the thing that-- when
you're trying to get the

00:19:52.830 --> 00:19:54.930
biggest ones you can--
network request--

00:19:54.930 --> 00:19:57.434
knowing what the device
can handle ahead of

00:19:57.434 --> 00:19:59.200
time is pretty key.

00:19:59.200 --> 00:20:01.550
And I think sending each
request is not

00:20:01.550 --> 00:20:02.280
necessarily the right way.

00:20:02.280 --> 00:20:04.767
But it goes back to what you
said before about user-agent

00:20:04.767 --> 00:20:07.260
sniffing, like knowing
concretely on the server side

00:20:07.260 --> 00:20:08.240
what to send.

00:20:08.240 --> 00:20:09.711
It's also a really, really
hard problem.

00:20:09.711 --> 00:20:12.772
But I feel like that's the
trick, like that's the magic

00:20:12.772 --> 00:20:15.840
bullet in a lot of cases to
get good [INAUDIBLE].

00:20:15.840 --> 00:20:17.600
These are the things I know
I don't need to send down.

00:20:17.600 --> 00:20:20.530
And in the immediate [? query ?]
world, you send it

00:20:20.530 --> 00:20:23.308
off with the layout, send it
off with the JavaScript.

00:20:23.308 --> 00:20:25.600
In reality, you don't
need to do that.

00:20:25.600 --> 00:20:27.828
Like a [INAUDIBLE] device, you
just don't need to send stuff.

00:20:27.828 --> 00:20:28.772
And in some cases, you
don't even have

00:20:28.772 --> 00:20:29.598
JavaScript on the devices.

00:20:29.598 --> 00:20:32.076
You definitely don't need
JavaScript resources.

00:20:32.076 --> 00:20:35.490
But there's no sure-fire way.

00:20:35.490 --> 00:20:36.830
I'm curious, though about
user-agent sniffing.

00:20:36.830 --> 00:20:37.740
Because I know what we do.

00:20:37.740 --> 00:20:40.320
I'm curious what other
folks do for that.

00:20:40.320 --> 00:20:41.718
ILYA GRIGORIK: Everybody
does it.

00:20:41.718 --> 00:20:43.960
You have to.

00:20:43.960 --> 00:20:47.164
STEVE THAIR: But you don't
like to talk about it.

00:20:47.164 --> 00:20:49.160
AUDIENCE: I have one.

00:20:49.160 --> 00:20:49.623
About--

00:20:49.623 --> 00:20:51.224
AUDIENCE: Could you introduce
yourself quickly?

00:20:51.224 --> 00:20:52.138
[INAUDIBLE].

00:20:52.138 --> 00:20:54.880
AUDIENCE: Yes, thanks.

00:20:54.880 --> 00:20:57.900
You introduced me,
but thank you.

00:20:57.900 --> 00:21:00.540
Yes, I had a comment about the
spec and about the previous

00:21:00.540 --> 00:21:01.420
version of the spec.

00:21:01.420 --> 00:21:04.200
I think there was an argument
about privacy.

00:21:04.200 --> 00:21:08.700
But another thing was that many
people were claiming that

00:21:08.700 --> 00:21:12.430
the type of network is really
not enough information.

00:21:12.430 --> 00:21:16.070
It's not telling you enough
about the type of connection.

00:21:16.070 --> 00:21:18.280
You might be in a conference
like this on a Wi-Fi that is

00:21:18.280 --> 00:21:20.750
complete cluttered, and you
don't get any throughput.

00:21:20.750 --> 00:21:24.473
Or you might be actually on--

00:21:24.473 --> 00:21:26.058
STEVE THAIR: Or in a
[INAUDIBLE] station

00:21:26.058 --> 00:21:27.191
any day of the week.

00:21:27.191 --> 00:21:30.093
You'll have five bars of signal,
and you're on a 3G

00:21:30.093 --> 00:21:32.550
network, and it's completely
digested [INAUDIBLE].

00:21:32.550 --> 00:21:35.580
AUDIENCE: And the problem that
we have with the net info is

00:21:35.580 --> 00:21:39.830
that we're trying to find a way
to get this information

00:21:39.830 --> 00:21:42.240
without defeating the purpose,
like the [INAUDIBLE]

00:21:42.240 --> 00:21:45.200
problem, or measuring
bandwidth.

00:21:45.200 --> 00:21:47.490
It changes so quickly, and you
have to measure so often that

00:21:47.490 --> 00:21:49.640
you're going to be draining
the battery.

00:21:49.640 --> 00:21:51.690
You're going to be defeating
the purpose entirely.

00:21:51.690 --> 00:21:54.210
So that's a very hard
problem to solve.

00:21:54.210 --> 00:21:57.830
I would be happy to go back
to the connection type.

00:22:01.350 --> 00:22:05.310
There are many different use
cases, and we have to see

00:22:05.310 --> 00:22:06.850
which ones are more important.

00:22:06.850 --> 00:22:08.620
ILYA GRIGORIK: [INAUDIBLE]
some sort of notion of a

00:22:08.620 --> 00:22:10.670
connection quality.

00:22:10.670 --> 00:22:12.780
I don't know how to
define it exactly.

00:22:12.780 --> 00:22:16.930
But it's kind of that losing
your Wi-Fi signal, you have

00:22:16.930 --> 00:22:18.850
just enough to be connected
but not enough

00:22:18.850 --> 00:22:20.330
to do anything else.

00:22:20.330 --> 00:22:21.230
That is a good example.

00:22:21.230 --> 00:22:22.750
Or you'd keep timing out.

00:22:22.750 --> 00:22:24.320
But that needs to be
serviced by the

00:22:24.320 --> 00:22:26.840
operating system somehow.

00:22:26.840 --> 00:22:28.894
I don't think the browser should
be the one trying to

00:22:28.894 --> 00:22:31.690
claim this one.

00:22:31.690 --> 00:22:32.990
AUDIENCE: I work on a browser.

00:22:32.990 --> 00:22:34.490
I work occasionally on
Chrome for Android.

00:22:34.490 --> 00:22:36.205
And we've been talking a lot
about this particular issue

00:22:36.205 --> 00:22:37.600
and this particular API.

00:22:37.600 --> 00:22:41.310
And the thing we've come to
understand, as it relates to

00:22:41.310 --> 00:22:42.660
the last session, is--

00:22:42.660 --> 00:22:44.460
AUDIENCE: Step up to
the mic, guys.

00:22:48.520 --> 00:22:50.410
AUDIENCE: The thing we've come
to understand here is that the

00:22:50.410 --> 00:22:53.550
only meaningful data point is
the point at which you're

00:22:53.550 --> 00:22:55.370
actually requesting
a resource.

00:22:55.370 --> 00:22:57.210
That is the only time when you
can make any sort of a

00:22:57.210 --> 00:22:59.860
decision that's worth a damn
about whether or not you've

00:22:59.860 --> 00:23:02.340
got good quality, because
anything else is opening up a

00:23:02.340 --> 00:23:04.100
window, which your expectations

00:23:04.100 --> 00:23:05.250
might be violated in.

00:23:05.250 --> 00:23:08.020
So if I go and I ping
occasionally to a server, now

00:23:08.020 --> 00:23:10.970
I've got a window in which I'm
going to make assumptions

00:23:10.970 --> 00:23:12.560
about the quality of
the connection.

00:23:12.560 --> 00:23:15.670
And I'm likely to be
unfortunately shocked and

00:23:15.670 --> 00:23:17.820
surprised by the terrible
things that

00:23:17.820 --> 00:23:20.310
happened in the interim.

00:23:20.310 --> 00:23:22.220
Tying this to an actual request,
I think, is the only

00:23:22.220 --> 00:23:22.850
way to do it.

00:23:22.850 --> 00:23:25.081
And we don't have any other API
right now that does that.

00:23:25.081 --> 00:23:26.043
JACKSON GABBARD: I don't
even know if that's

00:23:26.043 --> 00:23:27.005
really the crux of it.

00:23:27.005 --> 00:23:29.169
I feel like the answer is
just to think about your

00:23:29.169 --> 00:23:31.260
application from the standpoint
of minimizing your

00:23:31.260 --> 00:23:35.038
risky network time and also
taking as many steps as you

00:23:35.038 --> 00:23:36.618
can to harden your application
against it--

00:23:36.618 --> 00:23:42.440
so not putting all your eggs in
one chunked HTTP request.

00:23:42.440 --> 00:23:47.646
Bring it up over multiple HTTP
connections when necessary.

00:23:47.646 --> 00:23:50.425
[INAUDIBLE] the steps to me,
arguing about whether or not

00:23:50.425 --> 00:23:53.190
we should or shouldn't detect
network connectivity state is

00:23:53.190 --> 00:23:57.040
like arguing about whether or
not the sky should be bright

00:23:57.040 --> 00:23:57.850
colored blue.

00:23:57.850 --> 00:23:58.850
We're not going to know.

00:23:58.850 --> 00:24:00.850
It's not going to be good
enough information.

00:24:00.850 --> 00:24:04.831
So what are the things that we
do that are reasonable to make

00:24:04.831 --> 00:24:07.520
the application decent
in spite of that?

00:24:07.520 --> 00:24:09.160
That's the part of this
discussion that I find

00:24:09.160 --> 00:24:10.140
interesting.

00:24:10.140 --> 00:24:10.690
STEVE THAIR: Can I actually--

00:24:10.690 --> 00:24:12.670
I was going to say, John, you've
got a practical example

00:24:12.670 --> 00:24:14.200
with the BBC apps.

00:24:14.200 --> 00:24:15.380
What are you guys doing?

00:24:15.380 --> 00:24:16.310
And do you care?

00:24:16.310 --> 00:24:18.370
And how are you dealing
with that issue?

00:24:18.370 --> 00:24:21.285
JOHN CLEVELEY: Yeah, we care a
lot about making sure that our

00:24:21.285 --> 00:24:24.847
site works really well on low
bandwidth, because we have a

00:24:24.847 --> 00:24:29.190
lot our users use the
World Service sites.

00:24:29.190 --> 00:24:32.860
So we basically are always
really anal about file size,

00:24:32.860 --> 00:24:35.640
looking at HTTP requests.

00:24:35.640 --> 00:24:39.810
And going back to working out
what connection you're on, I'm

00:24:39.810 --> 00:24:44.050
interested in what people
actually will use it for.

00:24:44.050 --> 00:24:48.090
You can imagine users going to
the site on broadband and then

00:24:48.090 --> 00:24:51.510
going on 4G on the phone and
getting completely different

00:24:51.510 --> 00:24:52.250
user experience.

00:24:52.250 --> 00:24:55.042
I'm interested in what
differences are we going to

00:24:55.042 --> 00:24:57.290
actually be able to do if you've
been detected at a

00:24:57.290 --> 00:24:58.720
higher bandwidth?

00:24:58.720 --> 00:25:01.220
And [INAUDIBLE] you got video
and images of the big things.

00:25:04.850 --> 00:25:07.220
We've kind of been really
efficient with

00:25:07.220 --> 00:25:08.860
our file sizes, basically.

00:25:08.860 --> 00:25:13.440
And as you said before, images
is the big thing.

00:25:13.440 --> 00:25:16.395
So even though we haven't got
responsive images as any sort

00:25:16.395 --> 00:25:20.350
of standard, basically, we're
using JavaScript to work out

00:25:20.350 --> 00:25:21.950
what's the container size.

00:25:21.950 --> 00:25:24.090
And then we've got a number
of recipes on the server

00:25:24.090 --> 00:25:26.310
producing a number of different
image sizes.

00:25:26.310 --> 00:25:28.560
And we grab an appropriate
image for

00:25:28.560 --> 00:25:31.550
that particular device.

00:25:31.550 --> 00:25:33.910
ILYA GRIGORIK: Do you do
that in real time?

00:25:33.910 --> 00:25:37.520
How do you generate
the different

00:25:37.520 --> 00:25:39.120
versions of the images?

00:25:39.120 --> 00:25:40.470
JOHN CLEVELEY: Yeah, they're
generated the first time then

00:25:40.470 --> 00:25:43.100
cached on server, and
then onto CDN.

00:25:43.100 --> 00:25:45.555
JACKSON GABBARD: In the
generated case, I'm sure you

00:25:45.555 --> 00:25:46.500
got multiple resolutions.

00:25:46.500 --> 00:25:49.605
Do you require the people who
are publishing the stories to

00:25:49.605 --> 00:25:50.380
upload to separate
resolutions?

00:25:50.380 --> 00:25:50.720
Or do you--

00:25:50.720 --> 00:25:51.100
JOHN CLEVELEY: No.

00:25:51.100 --> 00:25:54.680
So they'll create one raw
image, because they're

00:25:54.680 --> 00:25:55.930
journalists.

00:25:55.930 --> 00:25:57.330
[INAUDIBLE] are actually
users with Facebook.

00:25:57.330 --> 00:25:58.790
So that might be a little
bit different.

00:25:58.790 --> 00:26:00.670
So we make sure the journalists
are uploading the

00:26:00.670 --> 00:26:02.670
biggest size we can.

00:26:02.670 --> 00:26:05.500
And then we've got 20, say,
different image sizes that we

00:26:05.500 --> 00:26:07.000
would select from.

00:26:07.000 --> 00:26:09.393
STEVE THAIR: So you transcode
all of that effectively server

00:26:09.393 --> 00:26:10.640
side for the--

00:26:10.640 --> 00:26:11.490
JOHN CLEVELEY: Exactly.

00:26:11.490 --> 00:26:12.230
We resize it.

00:26:12.230 --> 00:26:14.125
STEVE THAIR: Selected process
that's doing that re-scanning.

00:26:14.125 --> 00:26:14.580
JOHN CLEVELEY: Exactly.

00:26:14.580 --> 00:26:18.140
It's just a URL that we hit, and
it will do it on run time.

00:26:18.140 --> 00:26:19.620
ANDY DAVIES: Do you do any of
the art direction stuff?

00:26:19.620 --> 00:26:19.880
JOHN CLEVELEY: Sorry?

00:26:19.880 --> 00:26:22.340
ANDY DAVIES: Do you do any
of the art direction

00:26:22.340 --> 00:26:23.490
transformations on the image?

00:26:23.490 --> 00:26:24.840
Or do you just crop them?

00:26:24.840 --> 00:26:27.790
JOHN CLEVELEY: No, it's
literally just re-sized.

00:26:27.790 --> 00:26:28.610
STEVE THAIR: We got a
question over here.

00:26:28.610 --> 00:26:30.760
AUDIENCE: Somebody said that the
connection quality would

00:26:30.760 --> 00:26:32.110
have to come from
the [? RS, ?]

00:26:32.110 --> 00:26:33.860
but I think it can come
from the browser.

00:26:33.860 --> 00:26:37.660
One thing we do when we're
monitoring a website is keep a

00:26:37.660 --> 00:26:39.900
track on the time to first
byte for each host we're

00:26:39.900 --> 00:26:40.720
talking to.

00:26:40.720 --> 00:26:44.290
And if we see that go up, we
fire off a network test.

00:26:44.290 --> 00:26:47.300
So the browser itself could
track and say, hey, this is my

00:26:47.300 --> 00:26:50.550
average time to first byte
from Facebook.com.

00:26:50.550 --> 00:26:51.490
And you can respond to that.

00:26:51.490 --> 00:26:52.890
ILYA GRIGORIK: But your time
to first byte in mobile

00:26:52.890 --> 00:26:55.710
networks will vary dramatically,
because you have

00:26:55.710 --> 00:26:57.700
different radio state
transitions.

00:26:57.700 --> 00:27:02.340
So for example, on 3G, you
can be anywhere from 200

00:27:02.340 --> 00:27:03.640
milliseconds to two seconds.

00:27:03.640 --> 00:27:04.620
Just because your rating--

00:27:04.620 --> 00:27:06.011
AUDIENCE: You can ask it
to give you standard

00:27:06.011 --> 00:27:06.700
deviation or min/max?

00:27:06.700 --> 00:27:06.880
ILYA GRIGORIK: No, no.

00:27:06.880 --> 00:27:08.180
But this is just your
first packet.

00:27:08.180 --> 00:27:09.060
This is your first packet.

00:27:09.060 --> 00:27:10.390
After that, you're
pretty good.

00:27:10.390 --> 00:27:13.290
It's 100 milliseconds
or less--

00:27:13.290 --> 00:27:13.620
50 milliseconds.

00:27:13.620 --> 00:27:16.110
AUDIENCE: You keep
measuring it.

00:27:16.110 --> 00:27:16.950
[INTERPOSING VOICES]

00:27:16.950 --> 00:27:19.120
ILYA GRIGORIK: No, but the
point is then you wait.

00:27:19.120 --> 00:27:21.340
Then you wait five seconds.

00:27:21.340 --> 00:27:23.220
And then you will once again
incur two seconds.

00:27:23.220 --> 00:27:25.400
I think the fundamental problem
that we have, is we

00:27:25.400 --> 00:27:28.070
have this mental model of
Wi-Fi networks or mobile

00:27:28.070 --> 00:27:31.050
networks being the same as
wired networks, which is

00:27:31.050 --> 00:27:32.620
fundamentally wrong.

00:27:32.620 --> 00:27:34.810
And because of that, we feel
like there's all this

00:27:34.810 --> 00:27:38.410
variability, all of this
randomness, all this latency.

00:27:38.410 --> 00:27:40.300
But once we actually understand
why these delays

00:27:40.300 --> 00:27:43.310
are there and you design for
them, hey, I know I'm on 3G

00:27:43.310 --> 00:27:44.390
network right now.

00:27:44.390 --> 00:27:46.790
Every once in a while, I'm going
to dispatch a request

00:27:46.790 --> 00:27:49.730
which will first block for
up to two seconds.

00:27:49.730 --> 00:27:52.060
And this may not be a problem if
it's just like a background

00:27:52.060 --> 00:27:53.880
update thing, because
who cares.

00:27:53.880 --> 00:27:57.540
But if this is an interactive
user clicking on something and

00:27:57.540 --> 00:28:00.500
you're on 3G, that's a UX
pattern that you should be

00:28:00.500 --> 00:28:03.410
aware of, because you probably
need a different feedback loop

00:28:03.410 --> 00:28:06.170
in your app to say, hey, this
could take a while.

00:28:06.170 --> 00:28:07.480
JOHN CLEVELEY: So you're saying
you'd have a different

00:28:07.480 --> 00:28:09.690
user experience depending
on what sort of

00:28:09.690 --> 00:28:10.720
network you're on?

00:28:10.720 --> 00:28:13.780
ILYA GRIGORIK: I'm just saying
you should design

00:28:13.780 --> 00:28:15.890
with this in mind.

00:28:15.890 --> 00:28:20.480
If you're on 3G, if you're on 4G
even, some actions, like if

00:28:20.480 --> 00:28:23.480
my phone has been idle for a
while, the first network

00:28:23.480 --> 00:28:26.320
interaction that you're going
to have will have a delay--

00:28:26.320 --> 00:28:29.270
anywhere from 100 milliseconds
to two seconds--

00:28:29.270 --> 00:28:31.500
before any packets
get dispatched.

00:28:31.500 --> 00:28:34.250
JOHN CLEVELEY: So going from a
mobile first approach, do you

00:28:34.250 --> 00:28:37.635
think we should use that
behavior as the standard for

00:28:37.635 --> 00:28:39.320
everybody in terms
of making sure?

00:28:39.320 --> 00:28:42.290
ILYA GRIGORIK: It's probably
a reasonable thing to do.

00:28:42.290 --> 00:28:43.720
AUDIENCE: Just one comment,
[INAUDIBLE].

00:28:48.250 --> 00:28:52.650
I'm basically my own firm.

00:28:52.650 --> 00:28:56.550
Just one comment regarding the
measurement of time to first

00:28:56.550 --> 00:29:01.050
byte, would resource timing,
especially if we could add

00:29:01.050 --> 00:29:04.240
byte size into resource timing,
we could measure

00:29:04.240 --> 00:29:14.050
continuously the end-to-end
bandwidth

00:29:14.050 --> 00:29:16.780
throughout the download.

00:29:16.780 --> 00:29:21.900
It's extremely complicated to
measure the bandwidth between

00:29:21.900 --> 00:29:29.610
the various resources, but we
can have a fuller picture of

00:29:29.610 --> 00:29:31.005
the download.

00:29:31.005 --> 00:29:32.284
ILYA GRIGORIK: Great, we're
going to have a

00:29:32.284 --> 00:29:34.180
fuller wrong picture.

00:29:34.180 --> 00:29:37.660
STEVE THAIR: I'm going to move
on from this topic, because I

00:29:37.660 --> 00:29:39.270
think we've done it to death.

00:29:39.270 --> 00:29:40.950
You either believe that
measuring the bandwidth is

00:29:40.950 --> 00:29:43.090
useful for you, or you may
believe that measuring the

00:29:43.090 --> 00:29:45.060
bandwidth is a complete and
utter waste of time.

00:29:45.060 --> 00:29:48.740
I think it really comes down to
if you're more for John's

00:29:48.740 --> 00:29:52.800
point question really is, why do
you want to know, and what

00:29:52.800 --> 00:29:54.410
are you going to do with
that information?

00:29:54.410 --> 00:29:56.440
You're not going to be switching
between four

00:29:56.440 --> 00:30:00.470
different viewport things of
this application or ways of

00:30:00.470 --> 00:30:03.420
displaying this application
on a millisecond basis.

00:30:03.420 --> 00:30:05.330
Who really cares?

00:30:05.330 --> 00:30:06.558
One quick point?

00:30:06.558 --> 00:30:08.470
AUDIENCE: Yeah, [INAUDIBLE],
Mozilla.

00:30:08.470 --> 00:30:12.854
I heard this fallacy about if
the viewport is big enough,

00:30:12.854 --> 00:30:15.070
then we [INAUDIBLE]
bigger picture.

00:30:15.070 --> 00:30:17.230
That actually says that if
the screen is bigger, my

00:30:17.230 --> 00:30:19.830
connection is faster, which
is not really true.

00:30:19.830 --> 00:30:22.178
So [INAUDIBLE]

00:30:22.178 --> 00:30:24.850
Retina displays and these kinds
of things, I can't be on

00:30:24.850 --> 00:30:27.038
a slow connection with my
Retina display machine.

00:30:27.038 --> 00:30:29.954
I still don't want the two-meg
background image.

00:30:29.954 --> 00:30:31.980
So the question is, in Flash,
we had adaptive

00:30:31.980 --> 00:30:33.090
streaming of videos.

00:30:33.090 --> 00:30:37.570
And why don't we get this
in the HTML5 world?

00:30:37.570 --> 00:30:40.390
What do you we need to do to get
this [INAUDIBLE], because

00:30:40.390 --> 00:30:43.822
right now one can start using
Flash for that kind of stuff.

00:30:43.822 --> 00:30:45.650
JACKSON GABBARD: [INAUDIBLE]

00:30:45.650 --> 00:30:47.112
I guess for me--

00:30:47.112 --> 00:30:48.690
AUDIENCE: Can you repeat
the essence of the

00:30:48.690 --> 00:30:50.518
comment with mics?

00:30:50.518 --> 00:30:52.430
JACKSON GABBARD: I don't
know if I can or not.

00:30:52.430 --> 00:30:54.820
It's complicated.

00:30:54.820 --> 00:31:01.461
So the essence was, device
screen size is no proxy for

00:31:01.461 --> 00:31:03.145
network activity.

00:31:03.145 --> 00:31:06.760
That's the measure that we take
against what [INAUDIBLE]

00:31:06.760 --> 00:31:08.950
and what switches
we send across.

00:31:08.950 --> 00:31:11.384
You mentioned the Flash
[INAUDIBLE]

00:31:11.384 --> 00:31:13.830
where you can get
a [INAUDIBLE].

00:31:13.830 --> 00:31:17.700
You need something along these
lines for the HTML

00:31:17.700 --> 00:31:18.170
[INAUDIBLE].

00:31:18.170 --> 00:31:22.830
Basically, you get the lower
quality image with low

00:31:22.830 --> 00:31:26.645
bandwidth case naturally
by [INAUDIBLE]

00:31:26.645 --> 00:31:28.530
that we don't have currently.

00:31:28.530 --> 00:31:29.510
Is that the essence?

00:31:29.510 --> 00:31:30.490
AUDIENCE: Yeah.

00:31:30.490 --> 00:31:31.960
JACKSON GABBARD: I forgot what
I was going to say about it.

00:31:31.960 --> 00:31:34.900
[LAUGHTER]

00:31:34.900 --> 00:31:36.990
STEVE THAIR: And the
answer is, yes.

00:31:36.990 --> 00:31:37.980
We need that.

00:31:37.980 --> 00:31:38.760
Very good.

00:31:38.760 --> 00:31:39.450
So I want to get on.

00:31:39.450 --> 00:31:41.270
There are some other questions
on other topics that I want to

00:31:41.270 --> 00:31:43.400
cover and get away
from net API.

00:31:43.400 --> 00:31:46.130
So one of the questions which
you started to talk about with

00:31:46.130 --> 00:31:48.230
you had different visions and
[? optimized ?] stuff, there's

00:31:48.230 --> 00:31:53.100
a couple of questions in here
that are basically around

00:31:53.100 --> 00:31:54.290
should I be compressing?

00:31:54.290 --> 00:31:57.040
Should I be using
minification?

00:31:57.040 --> 00:31:59.050
What things should I be
doing during my build

00:31:59.050 --> 00:32:02.590
cycle in order to--

00:32:02.590 --> 00:32:04.890
does minification really save
you all that much when it's

00:32:04.890 --> 00:32:06.570
going to be gzip compressed
anyway?

00:32:06.570 --> 00:32:08.770
JACKSON GABBARD: I have
a poll question here.

00:32:08.770 --> 00:32:09.630
How many people here--

00:32:09.630 --> 00:32:11.592
STEVE THAIR: How many
people here--

00:32:11.592 --> 00:32:12.406
JACKSON GABBARD: How many
people here have a build

00:32:12.406 --> 00:32:13.470
script for the they work on?

00:32:13.470 --> 00:32:14.330
STEVE THAIR: Have a build
script for the

00:32:14.330 --> 00:32:15.730
project they work on?

00:32:15.730 --> 00:32:16.020
JACKSON GABBARD: Holy shit.

00:32:16.020 --> 00:32:16.270
Wow.

00:32:16.270 --> 00:32:17.960
STEVE THAIR: That's like
pretty much everybody.

00:32:17.960 --> 00:32:18.882
Awesome.

00:32:18.882 --> 00:32:19.284
JACKSON GABBARD: Nice.

00:32:19.284 --> 00:32:19.686
I had no idea.

00:32:19.686 --> 00:32:20.490
This is awesome.

00:32:20.490 --> 00:32:23.420
STEVE THAIR: And how many of
those build scripts include

00:32:23.420 --> 00:32:26.590
performance optimizations?

00:32:26.590 --> 00:32:30.130
Now you're just showing off.

00:32:30.130 --> 00:32:31.415
That was about everybody
again.

00:32:34.060 --> 00:32:37.641
So who's doing minification?

00:32:37.641 --> 00:32:41.920
Who's doing image optimization
and resize on the fly?

00:32:41.920 --> 00:32:44.220
Oh, about a tenth of the
people who answered the

00:32:44.220 --> 00:32:45.480
previous question.

00:32:45.480 --> 00:32:46.840
What else would you
like to see?

00:32:46.840 --> 00:32:48.832
JACKSON GABBARD: [INAUDIBLE].

00:32:48.832 --> 00:32:50.370
STEVE THAIR: This is a question
for the panel.

00:32:50.370 --> 00:32:53.270
What else can people do in their
build cycle that you

00:32:53.270 --> 00:32:55.910
think is really going to help
their delivery, particular

00:32:55.910 --> 00:32:58.360
over high latency, low
bandwidth networks?

00:32:58.360 --> 00:33:01.340
JOHN CLEVELEY: I think the other
thing you can do is, for

00:33:01.340 --> 00:33:05.260
JavaScript, you can't power
everything into an all.js.

00:33:05.260 --> 00:33:08.320
You do get to the point where
it starts to get massive.

00:33:08.320 --> 00:33:11.640
And so if there are other pages
where actually it's a

00:33:11.640 --> 00:33:13.030
specific bit of [INAUDIBLE]

00:33:13.030 --> 00:33:15.470
that you can have in a different
package, then

00:33:15.470 --> 00:33:18.770
sometimes it's good to work
out what you can spit out.

00:33:18.770 --> 00:33:20.100
So the majority of
pages, you're

00:33:20.100 --> 00:33:21.725
still using this all.js.

00:33:21.725 --> 00:33:24.590
But on these other ones that you
can get away with spitting

00:33:24.590 --> 00:33:25.650
things out.

00:33:25.650 --> 00:33:28.230
So we use AMD to do that
kind of stuff.

00:33:28.230 --> 00:33:30.740
And there's probably all sorts
of different dependency type

00:33:30.740 --> 00:33:32.020
things that you can use.

00:33:32.020 --> 00:33:35.800
So it's not always about making
one massive file.

00:33:35.800 --> 00:33:37.380
Sometimes you need to be a
little bit clever about how

00:33:37.380 --> 00:33:38.980
you split stuff up,
bundle stuff.

00:33:38.980 --> 00:33:40.216
JACKSON GABBARD: Thank
you for that.

00:33:40.216 --> 00:33:43.670
So the approach that we take for
Facebook is that there's

00:33:43.670 --> 00:33:44.820
two levels.

00:33:44.820 --> 00:33:46.180
There's basically all
the important

00:33:46.180 --> 00:33:47.410
interactions that matter--

00:33:47.410 --> 00:33:52.390
clicking on links, loading
things by XHR.

00:33:52.390 --> 00:33:55.082
And then there's all the rich
features, all the really

00:33:55.082 --> 00:33:56.043
bulky, all that JS stuff.

00:33:56.043 --> 00:33:59.550
And so in the header page,
before the body, with all the

00:33:59.550 --> 00:34:03.560
[INAUDIBLE], we'll send out all
of the basics, the really

00:34:03.560 --> 00:34:05.947
tight, "do not put bytes in
here, you're wasting human

00:34:05.947 --> 00:34:08.180
lifetime" sort of stuff
in that [INAUDIBLE]

00:34:08.180 --> 00:34:09.120
JavaScript.

00:34:09.120 --> 00:34:12.196
And then the stuff you need
later, you'll get to it.

00:34:12.196 --> 00:34:14.670
Eventually you'll get those
features, and then the

00:34:14.670 --> 00:34:18.020
widgets, the flyouts, the
[? beepers on the site, ?]

00:34:18.020 --> 00:34:20.516
the core interactions that are
JavaScript enhanced, they'll

00:34:20.516 --> 00:34:21.055
be there immediately.

00:34:21.055 --> 00:34:22.010
It's the exact same approach.

00:34:22.010 --> 00:34:23.690
JOHN CLEVELEY: And it's just
downloading what the user's

00:34:23.690 --> 00:34:26.500
actually going to use as well
and using feature detection.

00:34:26.500 --> 00:34:28.980
So if you're doing video,
check that the user can

00:34:28.980 --> 00:34:31.980
actually play video before you
download your HTML5 player and

00:34:31.980 --> 00:34:32.985
things like that.

00:34:32.985 --> 00:34:35.989
So just looking after the guys
with the bad phones, because

00:34:35.989 --> 00:34:38.230
they're probably got bad
JavaScript as well and

00:34:38.230 --> 00:34:39.510
probably are on slow
connections--

00:34:39.510 --> 00:34:41.230
I'm making lots of
assumptions here.

00:34:41.230 --> 00:34:44.080
But you generally
get the idea.

00:34:44.080 --> 00:34:46.409
Basically it's just progressive
enhancement.

00:34:46.409 --> 00:34:47.719
That's the most basic level.

00:34:47.719 --> 00:34:49.620
ANDY DAVIES: But there also a
lot of people who are afraid

00:34:49.620 --> 00:34:51.489
of-- particularly in the
design community-- of

00:34:51.489 --> 00:34:52.989
server-side stuff.

00:34:52.989 --> 00:34:56.800
If you look at media queries,
the showcase site for

00:34:56.800 --> 00:34:59.290
responsive designs, and you look
at the configuration of

00:34:59.290 --> 00:35:03.930
some of these guys' servers,
there's basic things like,

00:35:03.930 --> 00:35:07.300
gzip compression missing,
keepalives missing, cache

00:35:07.300 --> 00:35:08.410
directives missing.

00:35:08.410 --> 00:35:12.560
There's a lot of basic stuff
that as a web industry, we're

00:35:12.560 --> 00:35:14.440
really bad at doing.

00:35:14.440 --> 00:35:16.060
ILYA GRIGORIK: It's actually
surprising.

00:35:16.060 --> 00:35:17.110
Maybe not in this room.

00:35:17.110 --> 00:35:20.900
I think in this room, most of us
here have the basics right.

00:35:20.900 --> 00:35:22.900
Turns out most of the rest of
the industry still has the

00:35:22.900 --> 00:35:24.410
basics wrong.

00:35:24.410 --> 00:35:26.410
That's a big problem.

00:35:26.410 --> 00:35:27.580
STEVE THAIR: I'm
an ops manager.

00:35:27.580 --> 00:35:28.650
I'm going to disagree
with that.

00:35:28.650 --> 00:35:30.210
Just because all the developers
in this room are

00:35:30.210 --> 00:35:32.610
doing everything right sure as
heck doesn't mean the ops guys

00:35:32.610 --> 00:35:34.710
who run the servers
are doing it.

00:35:34.710 --> 00:35:35.040
ILYA GRIGORIK: All right.

00:35:35.040 --> 00:35:37.040
Fair enough.

00:35:37.040 --> 00:35:38.920
So we talked about JavaScript.

00:35:38.920 --> 00:35:40.190
I'll come back to images.

00:35:40.190 --> 00:35:41.850
60% of the bytes--

00:35:41.850 --> 00:35:43.090
images.

00:35:43.090 --> 00:35:48.900
You probably have your PNG
optim, jpegtran or something

00:35:48.900 --> 00:35:51.260
built into your build script.

00:35:51.260 --> 00:35:54.370
Chances are, you're still
missing the opportunity to

00:35:54.370 --> 00:35:56.840
transcode it to a better
image format.

00:35:56.840 --> 00:36:00.830
I'm guessing half of your PNGs
are bed encoded as JPEGs and

00:36:00.830 --> 00:36:01.920
vice versa.

00:36:01.920 --> 00:36:04.360
This is a much harder problem to
solve, because it's likely

00:36:04.360 --> 00:36:07.355
that your PNG is hardcoded into
your app, which means you

00:36:07.355 --> 00:36:08.700
need to rewrite your code.

00:36:08.700 --> 00:36:11.110
But this is a huge, huge
opportunity that you should

00:36:11.110 --> 00:36:12.520
look at today.

00:36:12.520 --> 00:36:15.080
And you guys have a server-side
solution to do the

00:36:15.080 --> 00:36:16.110
image resizing.

00:36:16.110 --> 00:36:19.272
I think this is something that
more and more people need to

00:36:19.272 --> 00:36:22.820
deploy, because we just stick
images into a markup and

00:36:22.820 --> 00:36:24.300
resize them on a client.

00:36:24.300 --> 00:36:25.100
And that's a big problem.

00:36:25.100 --> 00:36:27.380
JACKSON GABBARD: The hard
problem, it's sort of an

00:36:27.380 --> 00:36:30.170
exponential nature, because if
you want to serve every single

00:36:30.170 --> 00:36:32.170
resolution, well, that's
a different image size.

00:36:32.170 --> 00:36:35.790
If you want a full width image
for every single resolution,

00:36:35.790 --> 00:36:38.405
that's a massive number
of resolutions.

00:36:38.405 --> 00:36:43.240
And so the coping mechanism we
use is to basically put it in

00:36:43.240 --> 00:36:43.885
four-ish categories.

00:36:43.885 --> 00:36:46.292
I think we have roughly
four sizes--

00:36:46.292 --> 00:36:51.052
very, very small, original
iPhone, high-end iPhone world,

00:36:51.052 --> 00:36:54.820
and then gigantic, tablet-y,
very high-resolution Android

00:36:54.820 --> 00:36:56.240
phone-y stuff.

00:36:56.240 --> 00:37:01.040
And then use careful CSS to let
it crop on the client in a

00:37:01.040 --> 00:37:02.216
way that's reasonable.

00:37:02.216 --> 00:37:06.160
And that way, you never quite
get exactly the right thing in

00:37:06.160 --> 00:37:09.667
all cases, but you end up having
to have not a mess, but

00:37:09.667 --> 00:37:10.917
not a server side storage.

00:37:16.270 --> 00:37:18.850
AUDIENCE: Yeah this is
[INAUDIBLE] from Mozilla.

00:37:18.850 --> 00:37:22.240
One thing we saw when we were
looking into doing WebP was

00:37:22.240 --> 00:37:26.770
that the reason it wasn't
commencing was we saw that

00:37:26.770 --> 00:37:28.775
people could just use better
JPEG compressors.

00:37:32.910 --> 00:37:36.220
When you're encoding to JPEG,
if you just use better

00:37:36.220 --> 00:37:38.490
parameters to your JPEG
compressor, you can actually

00:37:38.490 --> 00:37:43.170
win about the same order of
magnitude as this 30% that

00:37:43.170 --> 00:37:45.900
WebP currently proposed.

00:37:45.900 --> 00:37:49.490
It's quite possible that WebP
can do even better.

00:37:49.490 --> 00:37:55.130
But the order, the wins that
people were shooting for could

00:37:55.130 --> 00:37:58.650
be had in many cases with just
passing better parameters to

00:37:58.650 --> 00:37:59.320
your compressor.

00:37:59.320 --> 00:38:01.640
ILYA GRIGORIK: So I think
there's a couple

00:38:01.640 --> 00:38:03.250
of threads in there.

00:38:03.250 --> 00:38:06.280
You have quality level.

00:38:06.280 --> 00:38:10.100
And most of the time today, we
save our JPEGs either as 100,

00:38:10.100 --> 00:38:14.100
or if you're advanced, you'll
save it as an 85.

00:38:14.100 --> 00:38:16.930
We can go way down into the
tail and actually get very

00:38:16.930 --> 00:38:20.080
good visual performance at
a fraction of the cost.

00:38:20.080 --> 00:38:24.120
WebP does have about 30%, on
average, better compression at

00:38:24.120 --> 00:38:27.220
the same quality level, the
same perceptual level.

00:38:27.220 --> 00:38:29.900
It is definitely the case that
you can take all your JPEGs,

00:38:29.900 --> 00:38:32.290
save at a lower quality,
basically re-compress them,

00:38:32.290 --> 00:38:35.860
and get much better bytes
on the [? wire. ?]

00:38:35.860 --> 00:38:37.470
So that is definitely true.

00:38:37.470 --> 00:38:40.040
And I think that's an
under-appreciated area

00:38:40.040 --> 00:38:41.290
generally today.

00:38:44.120 --> 00:38:45.685
JOHN CLEVELEY: One thing as well
is, if you want to work

00:38:45.685 --> 00:38:48.170
it out from a UX perspective,
how many images you need to

00:38:48.170 --> 00:38:49.700
show [INAUDIBLE].

00:38:49.700 --> 00:38:53.700
You can fool around with
compression, but actually if

00:38:53.700 --> 00:38:55.930
you get to the desktop
BBC News site, we've

00:38:55.930 --> 00:38:57.320
got a lot of images.

00:38:57.320 --> 00:39:00.170
And so that's something we're
looking at to work on.

00:39:00.170 --> 00:39:02.690
In our mobile site,
we've only got 10.

00:39:02.690 --> 00:39:03.960
And that's just a massive win.

00:39:03.960 --> 00:39:08.360
And so it's working out just
trying to do less but do the

00:39:08.360 --> 00:39:09.570
stuff you do do really well.

00:39:09.570 --> 00:39:10.760
I think that that's the biggest

00:39:10.760 --> 00:39:12.310
thing for network stuff.

00:39:12.310 --> 00:39:14.240
STEVE THAIR: On the feature
phone, you drop the images

00:39:14.240 --> 00:39:16.005
altogether on the news
page, don't you?

00:39:16.005 --> 00:39:16.280
JOHN CLEVELEY: Yeah
that's right.

00:39:16.280 --> 00:39:19.820
So if you hit our site on a
feature phone, like a Nokia,

00:39:19.820 --> 00:39:21.770
you'd literally just get
the first image.

00:39:21.770 --> 00:39:23.980
And that gets replaced out with
a better quality image if

00:39:23.980 --> 00:39:25.100
you're on a wider screen.

00:39:25.100 --> 00:39:28.735
And then we post-load all the
other images with JavaScript.

00:39:28.735 --> 00:39:30.020
STEVE THAIR: We've got
a question from Colt.

00:39:30.020 --> 00:39:31.030
AUDIENCE: Yeah, quick
question--

00:39:31.030 --> 00:39:32.170
Colt McAnlis from Google.

00:39:32.170 --> 00:39:35.310
So can we actually talk about
how the fact that the smaller

00:39:35.310 --> 00:39:39.170
image compression formats we
have decreases our network hit

00:39:39.170 --> 00:39:41.210
and actually increases
our runtime hit.

00:39:41.210 --> 00:39:44.030
So all those JPEGs and PNGs have
to be decoded to a full

00:39:44.030 --> 00:39:46.910
resolution 32-bit and then
transferred to the GPU, which

00:39:46.910 --> 00:39:49.400
actually puts more pressure on
the GPU memory, causing more

00:39:49.400 --> 00:39:51.440
invalidations and actually
hurts your runtime

00:39:51.440 --> 00:39:52.400
performance.

00:39:52.400 --> 00:39:56.130
What are our thoughts
on fixing this?

00:39:56.130 --> 00:39:57.400
ILYA GRIGORIK: I don't think
there's a fix for it.

00:39:57.400 --> 00:39:58.650
It's a trade-off.

00:40:01.540 --> 00:40:05.210
How does WebP give you better
image compression?

00:40:05.210 --> 00:40:07.190
Well, we have more advanced
algorithms that

00:40:07.190 --> 00:40:08.630
take more CPU time.

00:40:08.630 --> 00:40:11.620
And vice versa, you need
more time to decode it.

00:40:11.620 --> 00:40:13.800
So this is an interesting
trade-off.

00:40:13.800 --> 00:40:16.570
It will take more time to decode
a WebP image than it

00:40:16.570 --> 00:40:18.690
does to decode a JPEG image.

00:40:18.690 --> 00:40:23.040
And you need to look at, maybe
if you were building a game

00:40:23.040 --> 00:40:26.900
and it's like you have a ton
of image [INAUDIBLE], maybe

00:40:26.900 --> 00:40:30.220
your CPU, especially on
a ARM processor, is

00:40:30.220 --> 00:40:32.340
your limiting factor.

00:40:32.340 --> 00:40:34.660
Maybe be at that point, you
make a decision to use

00:40:34.660 --> 00:40:35.720
something else.

00:40:35.720 --> 00:40:37.580
We recently did some studies--

00:40:37.580 --> 00:40:39.320
I don't think we've published
anything yet at this point,

00:40:39.320 --> 00:40:40.690
but I think we will.

00:40:40.690 --> 00:40:44.410
We looked at Image Search at
Google, where we moved

00:40:44.410 --> 00:40:47.200
everything to WebP and just
looked at, what are the wins,

00:40:47.200 --> 00:40:48.160
what are the losses?

00:40:48.160 --> 00:40:50.270
We do take more time
in the CPU.

00:40:50.270 --> 00:40:52.680
We take a lot less time
on the network.

00:40:52.680 --> 00:40:55.620
Then that trade-off is we're
still better off using WebP in

00:40:55.620 --> 00:40:56.930
that specific case.

00:40:56.930 --> 00:41:00.070
And this is your Image Search
page, which has like 20 or 30

00:41:00.070 --> 00:41:02.810
images at different
resolutions.

00:41:02.810 --> 00:41:05.000
So this is, I think,
a great point.

00:41:05.000 --> 00:41:06.910
It's something you need
to keep in mind.

00:41:06.910 --> 00:41:07.090
STEVE THAIR: OK.

00:41:07.090 --> 00:41:09.250
The I think we've done
images to death.

00:41:09.250 --> 00:41:10.730
We've got about 10
minutes left.

00:41:10.730 --> 00:41:14.590
I want to try to move on to two
semi-related topics that

00:41:14.590 --> 00:41:16.740
are very network specific.

00:41:16.740 --> 00:41:20.420
The first is some guy named Andy
Davies from Bristol asked

00:41:20.420 --> 00:41:22.820
the question, with the adoption
of multiplexed

00:41:22.820 --> 00:41:26.740
protocols like SPDY and HTTP2
and the prioritization of

00:41:26.740 --> 00:41:30.820
resource downloads by the
browser based upon the type,

00:41:30.820 --> 00:41:35.230
will data URIs become
an anti-pattern?

00:41:35.230 --> 00:41:37.120
That's one question.

00:41:37.120 --> 00:41:38.670
And then there was another
question that was basically

00:41:38.670 --> 00:41:41.320
about web sockets and
stuff like that.

00:41:41.320 --> 00:41:44.250
So I just want to move on
to talking about those.

00:41:44.250 --> 00:41:46.500
So does anybody want
to answer Andy's

00:41:46.500 --> 00:41:48.820
question other than Andy?

00:41:48.820 --> 00:41:51.280
Or you can answer your own
question if you want to, Andy.

00:41:51.280 --> 00:41:53.280
JACKSON GABBARD: I think it
echoes what you said earlier--

00:41:53.280 --> 00:41:54.790
the idea that the best request
is no request.

00:41:54.790 --> 00:41:55.670
So [INAUDIBLE]

00:41:55.670 --> 00:41:56.980
is pretty sweet for that.

00:41:56.980 --> 00:41:58.830
It's all there.

00:41:58.830 --> 00:42:01.670
If you're [INAUDIBLE] mobile
app, you can put all your data

00:42:01.670 --> 00:42:04.720
URLs into your CSS and you
have one CSS file.

00:42:04.720 --> 00:42:05.850
That's a win.

00:42:05.850 --> 00:42:09.790
I can't imagine a world where
going from no request to any

00:42:09.790 --> 00:42:11.040
request isn't a better
trade-off.

00:42:14.020 --> 00:42:16.150
ILYA GRIGORIK: Why do
we inline stuff?

00:42:16.150 --> 00:42:19.060
It's because we have limitations
in HTTP 1.1, which

00:42:19.060 --> 00:42:20.810
make small requests expense.

00:42:20.810 --> 00:42:22.320
It's the same reason
we sprite images.

00:42:22.320 --> 00:42:24.190
It's the same reason
we concatenate

00:42:24.190 --> 00:42:25.930
files, all of this stuff.

00:42:25.930 --> 00:42:30.040
With SPDY and HTTP2, that goes
away, because we can multiplex

00:42:30.040 --> 00:42:31.570
all the stuff in parallel.

00:42:31.570 --> 00:42:33.150
You can send all of your
requests at the same time.

00:42:33.150 --> 00:42:35.160
We don't need multiple
parallel connections.

00:42:35.160 --> 00:42:36.560
Yada, yada, yada.

00:42:36.560 --> 00:42:38.980
Then coming back to inlining,
inlining is a

00:42:38.980 --> 00:42:40.390
form of a server push.

00:42:43.100 --> 00:42:44.110
Here's the idea.

00:42:44.110 --> 00:42:47.630
In HTTP2, we have this proposal
to say, sometimes the

00:42:47.630 --> 00:42:50.200
server actually knows what
you're going to request before

00:42:50.200 --> 00:42:50.990
you request it.

00:42:50.990 --> 00:42:52.360
Like I'm sending you
the damn page.

00:42:52.360 --> 00:42:53.530
I know the resources on it.

00:42:53.530 --> 00:42:56.090
So why don't I just send
you the resources?

00:42:56.090 --> 00:42:57.850
Seems kind of obvious, right?

00:42:57.850 --> 00:43:00.680
So that's the idea behind
server push.

00:43:00.680 --> 00:43:03.750
And inlining is push, because
you're saying, look, I know

00:43:03.750 --> 00:43:04.960
you're going to ask
for this icon.

00:43:04.960 --> 00:43:07.680
So here, page 64 in the file.

00:43:07.680 --> 00:43:08.600
Forget it.

00:43:08.600 --> 00:43:09.670
Don't make the request.

00:43:09.670 --> 00:43:12.010
That's a trade-off
of HTTP 1.1.

00:43:12.010 --> 00:43:16.140
With 2, we can actually get away
from that and say, by the

00:43:16.140 --> 00:43:17.040
way, here's the file.

00:43:17.040 --> 00:43:17.940
And why is that a win?

00:43:17.940 --> 00:43:20.320
So let's say you have to have a
small icon or a big icon or

00:43:20.320 --> 00:43:22.690
whatnot, and you inline
into a page.

00:43:22.690 --> 00:43:25.890
Now you're inlining that thing
into every single page.

00:43:25.890 --> 00:43:27.290
It fits on multiple pages.

00:43:27.290 --> 00:43:30.970
So you're just bloating
the size of each page.

00:43:30.970 --> 00:43:33.840
Whereas with push, it can
actually be in your cache.

00:43:33.840 --> 00:43:35.860
So I think it is mostly
an anti-pattern.

00:43:35.860 --> 00:43:39.210
I'm sure there's one or two
use cases where there may

00:43:39.210 --> 00:43:41.970
still-- like, if it's only
used on one page, it's

00:43:41.970 --> 00:43:43.220
effectively the same.

00:43:46.540 --> 00:43:47.830
STEVE THAIR: There's another
question here which is about

00:43:47.830 --> 00:43:48.610
web sockets.

00:43:48.610 --> 00:43:51.605
It seems that abstractions like
Socket.IO and Pusher are

00:43:51.605 --> 00:43:53.750
the preferred way to
use web sockets.

00:43:53.750 --> 00:43:56.690
Is this a failing in the
specification process?

00:43:56.690 --> 00:43:59.340
Is it now the expectation that
new DOM APIs will be needed to

00:43:59.340 --> 00:44:00.860
be wrapped by libraries
or frameworks?

00:44:00.860 --> 00:44:03.850
So basically saying, does the
specification suck so bad

00:44:03.850 --> 00:44:07.568
you've got to use another layer
on top to make it work?

00:44:07.568 --> 00:44:08.818
AUDIENCE: [INAUDIBLE]?

00:44:13.024 --> 00:44:14.520
[LAUGHTER]

00:44:14.520 --> 00:44:15.570
STEVE THAIR: We'll take
that as a no.

00:44:15.570 --> 00:44:20.540
So, apart from the guy from
Pusher in the audience, who's

00:44:20.540 --> 00:44:22.910
using web sockets, and are they
using web sockets in a

00:44:22.910 --> 00:44:23.630
mobile device?

00:44:23.630 --> 00:44:25.970
Can I see a quick
show of hands?

00:44:25.970 --> 00:44:29.320
So that's about four,
five people maybe.

00:44:29.320 --> 00:44:33.980
Does anybody have any really bad
problems in a mobile world

00:44:33.980 --> 00:44:35.540
that they think that causes?

00:44:38.608 --> 00:44:41.850
AUDIENCE: [INAUDIBLE].

00:44:41.850 --> 00:44:44.830
STEVE THAIR: One replay was,
the network provider is

00:44:44.830 --> 00:44:46.490
blocking web sockets traffic.

00:44:46.490 --> 00:44:47.462
AUDIENCE: Some of them.

00:44:47.462 --> 00:44:47.948
Yeah.

00:44:47.948 --> 00:44:50.378
STEVE THAIR: OK.

00:44:50.378 --> 00:44:53.456
AUDIENCE: I haven't tested this,
but I've been told that

00:44:53.456 --> 00:44:58.568
a web socket can just drop out
on a mobile connection.

00:44:58.568 --> 00:45:01.953
I'm going to be listening
to the close events.

00:45:01.953 --> 00:45:05.264
But I suppose the question is
simply to ask if that was

00:45:05.264 --> 00:45:08.080
anything that anyone else
has come across.

00:45:08.080 --> 00:45:09.740
ILYA GRIGORIK: So this is--

00:45:09.740 --> 00:45:11.500
STEVE THAIR: Just repeat
the answer.

00:45:11.500 --> 00:45:14.440
ILYA GRIGORIK: So the question
was, or the comment is that

00:45:14.440 --> 00:45:17.300
sometimes website connections
just drop

00:45:17.300 --> 00:45:18.930
out on mobile networks.

00:45:18.930 --> 00:45:20.160
And this is a deployment
problem.

00:45:20.160 --> 00:45:21.090
So I think there's
two problems.

00:45:21.090 --> 00:45:23.770
First of all, web sockets did
go through a very elaborate

00:45:23.770 --> 00:45:27.350
process of many revisions
and specifications.

00:45:27.350 --> 00:45:29.970
Depending on which server you
use-- so I happen to have

00:45:29.970 --> 00:45:30.980
worked on one--

00:45:30.980 --> 00:45:32.890
it's the Ruby implementation,
the EM web socket.

00:45:32.890 --> 00:45:35.300
If you actually look at the
implementation, we have, like,

00:45:35.300 --> 00:45:37.260
15 implementations of
all the drafts.

00:45:37.260 --> 00:45:40.700
It's a total nightmare in terms
of negotiating, oh, this

00:45:40.700 --> 00:45:43.550
browser supports this
spec, et cetera.

00:45:43.550 --> 00:45:44.570
That was problem number one.

00:45:44.570 --> 00:45:47.720
So I think we did fail in the
specification process of that

00:45:47.720 --> 00:45:49.840
specific standard.

00:45:49.840 --> 00:45:53.160
The bigger problem today with
web sockets is you have to

00:45:53.160 --> 00:45:55.160
deploy over SSL.

00:45:55.160 --> 00:45:58.370
If you're deploying it on
mobile, you have to deploy it

00:45:58.370 --> 00:46:03.530
over SSL, because most of the
carriers have some proxies in

00:46:03.530 --> 00:46:07.690
between that try to optimize
traffic, whatever that means.

00:46:07.690 --> 00:46:10.060
And they look web sockets, and
they're like, look, this

00:46:10.060 --> 00:46:12.540
doesn't smell like HTTP.

00:46:12.540 --> 00:46:13.470
Close.

00:46:13.470 --> 00:46:16.710
Or even better, the blind
proxies, which don't even care

00:46:16.710 --> 00:46:17.140
what's in there.

00:46:17.140 --> 00:46:19.370
They're just substituting
bytes.

00:46:19.370 --> 00:46:22.970
And this is why without SSL,
20% of your connections on

00:46:22.970 --> 00:46:25.640
desktop will fail randomly.

00:46:25.640 --> 00:46:27.190
You have a proxy that doesn't
understand web

00:46:27.190 --> 00:46:29.300
sockets, end of story.

00:46:29.300 --> 00:46:32.160
On mobile, it just happens to
be the other way around.

00:46:32.160 --> 00:46:34.580
80% of your connections
will fail.

00:46:34.580 --> 00:46:36.270
So if you want, you
can reliably

00:46:36.270 --> 00:46:37.360
deploy web sockets today.

00:46:37.360 --> 00:46:38.750
It's HTTPS.

00:46:38.750 --> 00:46:43.480
And that's how anybody on mobile
deploys that at scale.

00:46:43.480 --> 00:46:44.730
STEVE THAIR: Great.

00:46:48.130 --> 00:46:49.850
AUDIENCE: [INAUDIBLE]
with Mozilla again.

00:46:49.850 --> 00:46:52.100
Isn't the big reason for library
use that a lot of

00:46:52.100 --> 00:46:54.522
browsers still don't support
web sockets, or a lot of

00:46:54.522 --> 00:46:57.320
browsers that people use still
don't support web sockets,

00:46:57.320 --> 00:46:58.750
which we can't really
get away from?

00:46:58.750 --> 00:47:01.310
ILYA GRIGORIK: So we need HTTP
fallbacks for browsers that

00:47:01.310 --> 00:47:03.720
don't support it.

00:47:03.720 --> 00:47:06.760
Hence the reason for Socket.IO
and all these other

00:47:06.760 --> 00:47:07.770
abstractions.

00:47:07.770 --> 00:47:10.890
And that's just an unfortunate
reality of not everybody is

00:47:10.890 --> 00:47:13.020
able to upgrade to an
evergreen browser.

00:47:13.020 --> 00:47:16.000
Some people are just stuck on
an old IE machine that they

00:47:16.000 --> 00:47:16.640
can't upgrade.

00:47:16.640 --> 00:47:18.688
And I don't know how
to fix that.

00:47:21.620 --> 00:47:22.000
AUDIENCE: Hi.

00:47:22.000 --> 00:47:25.112
ILYA GRIGORIK: [INAUDIBLE].

00:47:25.112 --> 00:47:26.400
STEVE THAIR: Got a question
right there.

00:47:26.400 --> 00:47:27.390
AUDIENCE: Yes.

00:47:27.390 --> 00:47:28.380
STEVE THAIR: Tell
us your name.

00:47:28.380 --> 00:47:29.560
AUDIENCE: Hi, my name
is [INAUDIBLE]

00:47:29.560 --> 00:47:31.720
from [INAUDIBLE].

00:47:31.720 --> 00:47:35.380
If I use a web socket for
mobile, does it drain the

00:47:35.380 --> 00:47:35.990
battery further.

00:47:35.990 --> 00:47:41.820
Or as long as it's an idle
connection, it doesn't drain?

00:47:41.820 --> 00:47:42.140
ILYA GRIGORIK: Yes and no.

00:47:42.140 --> 00:47:44.580
It depends on how you
use your web socket.

00:47:44.580 --> 00:47:47.850
If you're sending periodic
messages every five seconds,

00:47:47.850 --> 00:47:50.520
you'll keep your radio
active all the time.

00:47:50.520 --> 00:47:51.810
I think what a lot
of people confuse

00:47:51.810 --> 00:47:53.580
about is you can have--

00:47:53.580 --> 00:47:56.280
so your radio can be
off, but the TCP

00:47:56.280 --> 00:47:59.210
connection is still alive.

00:47:59.210 --> 00:48:00.750
I think a lot of people
confuse this.

00:48:00.750 --> 00:48:04.190
They think the moment my radio
turns off, I've lost my

00:48:04.190 --> 00:48:05.080
website connection.

00:48:05.080 --> 00:48:06.300
That is not the case.

00:48:06.300 --> 00:48:08.460
Your actual TCP connection
is still

00:48:08.460 --> 00:48:10.810
maintained by the carrier.

00:48:10.810 --> 00:48:13.560
And it's just the radio link
that goes missing.

00:48:13.560 --> 00:48:18.890
So I guess the best practice
for web socket traffic on

00:48:18.890 --> 00:48:21.630
mobile is, send as few requests

00:48:21.630 --> 00:48:22.780
or messages as possible.

00:48:22.780 --> 00:48:24.810
Or if you do, just
as with regular

00:48:24.810 --> 00:48:26.230
traffic, send it in bursts.

00:48:29.940 --> 00:48:32.520
STEVE THAIR: There were quite
a few questions on this list

00:48:32.520 --> 00:48:33.730
about radio stuff.

00:48:33.730 --> 00:48:37.592
I think Ilya covered it
in his introduction.

00:48:37.592 --> 00:48:39.520
[INAUDIBLE]

00:48:39.520 --> 00:48:40.545
AUDIENCE: Hello, yeah,
so I'm Phil.

00:48:40.545 --> 00:48:42.310
STEVE THAIR: Hold
on one second.

00:48:42.310 --> 00:48:44.884
So there were a few questions
there about battery use and

00:48:44.884 --> 00:48:45.646
this kind of stuff.

00:48:45.646 --> 00:48:48.202
I think Ilya covered it in his
introduction, that you've got

00:48:48.202 --> 00:48:48.862
to be aware of it.

00:48:48.862 --> 00:48:53.070
Just one question from me, as
a rule of thumb, do we have

00:48:53.070 --> 00:48:55.240
any idea of how quickly
the radios turn off?

00:48:55.240 --> 00:48:57.040
Is it once every five seconds,
once every 10 seconds?

00:48:57.040 --> 00:48:59.500
If I want to beacon analytic
stuff back,

00:48:59.500 --> 00:49:01.093
what's a rule of thumb?

00:49:01.093 --> 00:49:01.860
ANDY DAVIES: It's carrier
dependent.

00:49:01.860 --> 00:49:04.010
STEVE THAIR: It's carrier
dependent.

00:49:04.010 --> 00:49:05.260
JACKSON GABBARD: [INAUDIBLE].

00:49:10.423 --> 00:49:13.079
We got yelled at by some carrier
who was saying that

00:49:13.079 --> 00:49:15.400
we-- basically, a time out
from one of our logged in

00:49:15.400 --> 00:49:18.950
delivery services was
just underneath

00:49:18.950 --> 00:49:20.710
the radio time limit.

00:49:20.710 --> 00:49:26.680
We were always just keeping it
awake, over and over again.

00:49:26.680 --> 00:49:29.420
You have a lowered [? wait. ?]

00:49:29.420 --> 00:49:31.488
The radio [? wait ?] will
stay awake longer than

00:49:31.488 --> 00:49:31.760
you think it would.

00:49:31.760 --> 00:49:33.590
ILYA GRIGORIK: So its
network configured.

00:49:33.590 --> 00:49:36.700
There's a great case study
paper published by AT&amp;T--

00:49:36.700 --> 00:49:37.210
STEVE THAIR: Three
minutes left.

00:49:37.210 --> 00:49:39.030
ILYA GRIGORIK: Three minutes.

00:49:39.030 --> 00:49:39.540
AT&amp;T--

00:49:39.540 --> 00:49:40.885
I don't remember
the name of it.

00:49:40.885 --> 00:49:43.930
If you just search for AT&amp;T
radio performance, I think

00:49:43.930 --> 00:49:44.670
you'll find it.

00:49:44.670 --> 00:49:46.310
They have the Pandora
case study.

00:49:46.310 --> 00:49:47.360
Pandora app--

00:49:47.360 --> 00:49:48.480
you play the song.

00:49:48.480 --> 00:49:49.390
They did the right thing.

00:49:49.390 --> 00:49:51.520
They downloaded the whole
song up front.

00:49:51.520 --> 00:49:52.640
So they streamed the
whole thing.

00:49:52.640 --> 00:49:53.830
They turn off the radio.

00:49:53.830 --> 00:49:55.900
And then every 60 seconds,
they would send a beacon,

00:49:55.900 --> 00:49:58.100
which is just a measurement
beacon.

00:49:58.100 --> 00:50:00.680
And they measured it, and they
figured out that those beacons

00:50:00.680 --> 00:50:04.190
accounted for 0.2% percent of
the traffic and 40% of the

00:50:04.190 --> 00:50:06.850
battery use.

00:50:06.850 --> 00:50:07.700
They eliminated that.

00:50:07.700 --> 00:50:11.340
They doubled their battery
performance.

00:50:11.340 --> 00:50:12.380
AUDIENCE: Just a few points--

00:50:12.380 --> 00:50:13.680
I'm Phil Leggetter
from Pusher.

00:50:13.680 --> 00:50:14.710
So obviously we use
web sockets.

00:50:14.710 --> 00:50:16.360
So I handle most
of our support.

00:50:16.360 --> 00:50:19.985
So I just want to back up that
SSL connections when you're

00:50:19.985 --> 00:50:22.270
using web sockets, definite.

00:50:22.270 --> 00:50:24.470
In terms of the web sockets
dropping, I think that's

00:50:24.470 --> 00:50:27.850
because most of the browsers
don't implement ping pong from

00:50:27.850 --> 00:50:29.270
the specification.

00:50:29.270 --> 00:50:32.210
So we've added that as
our protocol layer.

00:50:32.210 --> 00:50:34.930
So we are sending messages
when maybe we

00:50:34.930 --> 00:50:36.300
shouldn't have to.

00:50:36.300 --> 00:50:38.010
But obviously, there
would be a message

00:50:38.010 --> 00:50:39.110
natively from the browser.

00:50:39.110 --> 00:50:43.220
So again, if you're using web
sockets in a browser, have a

00:50:43.220 --> 00:50:46.250
ping pong time out.

00:50:46.250 --> 00:50:47.820
And we haven't had a lot
of problems with that.

00:50:47.820 --> 00:50:49.760
We've obviously got HTTP
fallback as well,

00:50:49.760 --> 00:50:51.010
because we need it.

00:50:54.680 --> 00:50:57.990
AUDIENCE: With regards to a
radio power state, would it be

00:50:57.990 --> 00:51:01.250
worth for the developer to
have a means to tell the

00:51:01.250 --> 00:51:05.040
browser, here is the request,
and send it only whenever you

00:51:05.040 --> 00:51:07.540
have the radio in full power.

00:51:07.540 --> 00:51:11.040
If it's an idle state, don't
wake it up just to send this,

00:51:11.040 --> 00:51:12.510
because it's not urgent.

00:51:12.510 --> 00:51:14.730
This is something I would
like to see, personally.

00:51:14.730 --> 00:51:18.220
STEVE THAIR: Military style
microburst, basically.

00:51:18.220 --> 00:51:20.830
AUDIENCE: And avoiding excessive
signaling traffic,

00:51:20.830 --> 00:51:24.770
which is what happens when
you switch radio states.

00:51:24.770 --> 00:51:26.690
It's in the best interest
of everyone not to

00:51:26.690 --> 00:51:27.940
clutter mobile networks.

00:51:30.790 --> 00:51:32.280
ILYA GRIGORIK: So the
answer is yes.

00:51:32.280 --> 00:51:34.980
And this is actually something
that we discussed at the W3C

00:51:34.980 --> 00:51:39.490
Performance Group meeting that
we had back in November.

00:51:39.490 --> 00:51:41.980
There's this new proposal that
we're going to start working

00:51:41.980 --> 00:51:45.270
on in, I think, around
May of this year--

00:51:45.270 --> 00:51:46.370
it's our timeline--

00:51:46.370 --> 00:51:47.560
called the beacon API.

00:51:47.560 --> 00:51:49.920
And the idea being that,
it's exactly that.

00:51:49.920 --> 00:51:54.400
I want to send a request, like
an analytics request, that I

00:51:54.400 --> 00:51:56.320
don't need to dispatch
right now.

00:51:56.320 --> 00:51:58.770
Dispatch it any time you want.

00:51:58.770 --> 00:52:00.630
In fact, even if you lose
it, maybe it's not

00:52:00.630 --> 00:52:02.430
the end of the world.

00:52:02.430 --> 00:52:04.180
But just don't wake
up my battery.

00:52:04.180 --> 00:52:09.350
So it's almost like the async
keyword on an XHR to say,

00:52:09.350 --> 00:52:10.900
sometime, make this happen.

00:52:13.530 --> 00:52:18.890
STEVE THAIR: That's basically
the time up

00:52:18.890 --> 00:52:19.750
for the network panel.

00:52:19.750 --> 00:52:22.800
So I'd like to thank Jackson,
John, Andy, and Ilya.

