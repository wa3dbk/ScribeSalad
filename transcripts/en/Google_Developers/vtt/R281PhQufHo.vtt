WEBVTT
Kind: captions
Language: en

00:00:05.030 --> 00:00:05.480
COLT MCANLIS: Hey, everybody.

00:00:05.480 --> 00:00:06.120
Thanks for coming.

00:00:06.120 --> 00:00:07.420
My name is Colt McAnlis.

00:00:07.420 --> 00:00:10.620
And I'm a developer advocate at
Google focusing on Native

00:00:10.620 --> 00:00:12.300
Client and gaming.

00:00:12.300 --> 00:00:13.640
And what we're going to
talk about today is

00:00:13.640 --> 00:00:14.940
getting your port on.

00:00:14.940 --> 00:00:17.240
Specifically, porting your
game to Native Client

00:00:17.240 --> 00:00:19.280
as of Pepper 18.

00:00:19.280 --> 00:00:21.820
So a quick show of hands,
who's already

00:00:21.820 --> 00:00:22.750
touched Native Client?

00:00:22.750 --> 00:00:24.776
Have you compiled the
application before?

00:00:24.776 --> 00:00:25.180
OK.

00:00:25.180 --> 00:00:25.740
Cool.

00:00:25.740 --> 00:00:26.480
Put your hands down.

00:00:26.480 --> 00:00:28.370
For those you, how many people
have no idea what

00:00:28.370 --> 00:00:29.170
Native Client is?

00:00:29.170 --> 00:00:31.220
Or they've heard about it and
want to learn more, and that's

00:00:31.220 --> 00:00:32.670
why you're here?

00:00:32.670 --> 00:00:32.900
OK.

00:00:32.900 --> 00:00:33.300
Cool.

00:00:33.300 --> 00:00:33.890
That's good.

00:00:33.890 --> 00:00:35.280
That allows me to kind
of gauge how

00:00:35.280 --> 00:00:36.650
deep I dive into stuff.

00:00:36.650 --> 00:00:41.150
So Pepper 18 is the active SDK
build, as of right now.

00:00:41.150 --> 00:00:45.150
If you go to gonacl.com, you'll
be able to get our SDK

00:00:45.150 --> 00:00:46.980
and see all the documentation
that we're talking about

00:00:46.980 --> 00:00:51.100
today, as well as some other
amazing opportunities there.

00:00:51.100 --> 00:00:53.360
So let's get started.

00:00:53.360 --> 00:00:54.290
So it works.

00:00:54.290 --> 00:00:57.250
Native Client allows
you to run C and C

00:00:57.250 --> 00:00:58.410
code in a web page.

00:00:58.410 --> 00:00:59.990
Now this has been around
as a feature set

00:00:59.990 --> 00:01:01.190
for a long time now.

00:01:01.190 --> 00:01:03.140
But the most important thing,
and probably the coolest one

00:01:03.140 --> 00:01:06.610
about Native Client, is that
no plug-in is required.

00:01:06.610 --> 00:01:08.340
Now this is the kicker, right?

00:01:08.340 --> 00:01:11.040
I've got some statistical
information sitting in a vault

00:01:11.040 --> 00:01:13.940
somewhere that shows that, for
some games, they lose up to

00:01:13.940 --> 00:01:17.780
90% of the users that wanted
to play the game as soon as

00:01:17.780 --> 00:01:19.740
they are prompted to
install a plug-in.

00:01:19.740 --> 00:01:20.360
90%.

00:01:20.360 --> 00:01:23.050
Now if you're an indie in this
crowd, and you've got a

00:01:23.050 --> 00:01:25.720
mortgage and a wife and a
mother-in-law who thinks

00:01:25.720 --> 00:01:28.290
you're a bum because you're
a game developer and not a

00:01:28.290 --> 00:01:31.700
stockbroker, or something, 90%
of those developers wanted to

00:01:31.700 --> 00:01:32.500
give you money.

00:01:32.500 --> 00:01:33.800
And they couldn't because
you asked them

00:01:33.800 --> 00:01:34.850
to install a plug-in.

00:01:34.850 --> 00:01:36.830
So the goal here is
if no plug-in is

00:01:36.830 --> 00:01:38.650
required, that's fantastic.

00:01:38.650 --> 00:01:41.540
And if you're one of the
programmers who has worked in

00:01:41.540 --> 00:01:43.970
the games industry for the past
30 years, chances are

00:01:43.970 --> 00:01:47.470
you've got 30 years of C code
sitting around and 30 years of

00:01:47.470 --> 00:01:51.120
experience in C code sitting
around that can now migrate to

00:01:51.120 --> 00:01:53.180
the web, which is
amazing, right?

00:01:53.180 --> 00:01:55.470
Developers spend billions of
dollars cultivating this

00:01:55.470 --> 00:01:56.310
technology.

00:01:56.310 --> 00:01:58.290
And to get to the web right
now, they have to throw it

00:01:58.290 --> 00:02:00.270
away and rewrite it in some
other scripting language.

00:02:00.270 --> 00:02:03.320
But if you can use the direct
code, this is fantastic.

00:02:03.320 --> 00:02:05.890
It allows you to leverage your
existing technology to move

00:02:05.890 --> 00:02:08.110
into this new marketplace.

00:02:08.110 --> 00:02:12.550
So here's the gist. It all
starts with your C code.

00:02:12.550 --> 00:02:15.870
Native Client provides, in the
SDK, a version of a GCC and a

00:02:15.870 --> 00:02:20.800
G compiler that produces safe,
portable x86 code.

00:02:20.800 --> 00:02:22.960
This is provided in the
form of NEXEs, or

00:02:22.960 --> 00:02:24.580
Native Client exe.

00:02:24.580 --> 00:02:26.980
In addition to this, we'll
produce one for 32-bit and

00:02:26.980 --> 00:02:30.690
64-bit architectures, as well
as an NMF file, or a Native

00:02:30.690 --> 00:02:32.240
Client manifest file.

00:02:32.240 --> 00:02:35.990
The manifest effectively lists
which architecture goes to

00:02:35.990 --> 00:02:38.240
what file path for
what executable.

00:02:38.240 --> 00:02:40.320
So it says if you're running
a 32-bit, point to this

00:02:40.320 --> 00:02:40.595
executable.

00:02:40.595 --> 00:02:43.760
If you're running 64-bit,
run to that executable.

00:02:43.760 --> 00:02:47.380
You embed this information in an
HTML file using this small,

00:02:47.380 --> 00:02:48.290
little tag right here.

00:02:48.290 --> 00:02:49.610
So you make an embed element.

00:02:49.610 --> 00:02:50.270
You name it.

00:02:50.270 --> 00:02:50.880
You give it a height.

00:02:50.880 --> 00:02:53.060
You define your manifest.
You point to the

00:02:53.060 --> 00:02:54.020
manifest, not to the NEXEs.

00:02:54.020 --> 00:02:56.200
Because, remember, the
manifest defines

00:02:56.200 --> 00:02:57.460
what NEXE to use.

00:02:57.460 --> 00:02:59.970
And then you set an application
type right there.

00:02:59.970 --> 00:03:01.570
Once you do this, you've gone
through this process.

00:03:01.570 --> 00:03:02.580
You've compiled it.

00:03:02.580 --> 00:03:04.060
You've embedded it in a page.

00:03:04.060 --> 00:03:05.700
And then you load the
page up and boom!

00:03:05.700 --> 00:03:09.500
You see some amazing graphics on
the screen, stuff that you

00:03:09.500 --> 00:03:10.870
traditionally don't
see in a web game.

00:03:10.870 --> 00:03:14.660
This is actually a screen shot
from an Xbox 360 title running

00:03:14.660 --> 00:03:17.200
in Native Client that was ported
in about three months.

00:03:17.200 --> 00:03:20.010
That's amazing technology to see
post processing and full

00:03:20.010 --> 00:03:23.190
screen blend and skin animation
and color tint and

00:03:23.190 --> 00:03:25.040
all this just great stuff
there that you

00:03:25.040 --> 00:03:27.760
have access to now.

00:03:27.760 --> 00:03:28.880
So let's talk about the
first steps, your

00:03:28.880 --> 00:03:31.370
GCC and your G compiler.

00:03:31.370 --> 00:03:34.930
So to use these-- if anyone
here is a Linux developer,

00:03:34.930 --> 00:03:37.640
then you're very intimately
familiar with GCC and G If

00:03:37.640 --> 00:03:39.870
you're a Windows developer,
this is kind of new ground

00:03:39.870 --> 00:03:42.300
that's kind of awkward and
uncomfortable for you.

00:03:42.300 --> 00:03:45.740
But first off, to get your code
compiling in GCC and G ,

00:03:45.740 --> 00:03:48.360
you have to make sure that it's
ISO and IEC complaint,

00:03:48.360 --> 00:03:50.590
which effectively means that it
matches these protocols and

00:03:50.590 --> 00:03:51.090
these standards.

00:03:51.090 --> 00:03:54.550
Now it's probably not best to go
look at these standards and

00:03:54.550 --> 00:03:55.580
figure out the mapping.

00:03:55.580 --> 00:03:57.790
It's probably actually best to
try to compile your code in

00:03:57.790 --> 00:04:00.070
GCC, figure out what it
complains about, and then

00:04:00.070 --> 00:04:02.390
iterate that way.

00:04:02.390 --> 00:04:05.710
Predominately, this standard
defines POSIX style coding and

00:04:05.710 --> 00:04:06.100
functioning.

00:04:06.100 --> 00:04:09.260
So it uses syntaxes like p
threads as opposed to begin

00:04:09.260 --> 00:04:12.480
and end thread, as well as
conditional variables rather

00:04:12.480 --> 00:04:14.580
than retexes and other
things like that.

00:04:14.580 --> 00:04:16.670
In addition, this compliance
standard-- and this is the

00:04:16.670 --> 00:04:17.630
important one--

00:04:17.630 --> 00:04:20.720
does not define any
OS specific calls.

00:04:20.720 --> 00:04:24.920
So you can't access the
registry from GCC.

00:04:24.920 --> 00:04:25.880
That doesn't make sense.

00:04:25.880 --> 00:04:28.340
You can't open up a direct
video stream

00:04:28.340 --> 00:04:29.190
using direct media.

00:04:29.190 --> 00:04:30.520
That doesn't make sense
either, right?

00:04:30.520 --> 00:04:32.910
So you need to make sure that
your code is platform

00:04:32.910 --> 00:04:36.300
independent and uses these
POSIX-style calls.

00:04:36.300 --> 00:04:39.620
The GCC and G compilers also
do the amazing thing-- and

00:04:39.620 --> 00:04:41.350
this is sort of the linchpin--

00:04:41.350 --> 00:04:43.700
it removes any unsafe code.

00:04:43.700 --> 00:04:45.120
This is the whole point
of Native Client.

00:04:45.120 --> 00:04:49.640
The whole point is to execute
safe, portable assembly

00:04:49.640 --> 00:04:51.510
language code in
a web browser.

00:04:51.510 --> 00:04:54.090
Security is of the utmost
importance here, more than

00:04:54.090 --> 00:04:55.730
performance, more than
anything else.

00:04:55.730 --> 00:04:57.270
Although we are amazingly
performant.

00:04:57.270 --> 00:04:59.340
And I can give you those numbers
offline, if you're

00:04:59.340 --> 00:05:00.450
looking for it.

00:05:00.450 --> 00:05:03.190
But it removes all this unsafe
stuff and creates this nice

00:05:03.190 --> 00:05:05.940
little package that can run,
execute, in multiple places.

00:05:08.690 --> 00:05:11.450
And so once you get this code--
and you're saying, OK,

00:05:11.450 --> 00:05:12.080
this is cool.

00:05:12.080 --> 00:05:13.790
I have the ability to
execute this code--

00:05:13.790 --> 00:05:16.000
how does it actually interact
with the system?

00:05:16.000 --> 00:05:18.910
So to understand how Native
Client gets access to these

00:05:18.910 --> 00:05:21.320
system-level resources, I have
to take a step back, and

00:05:21.320 --> 00:05:24.360
actually talk about how Chrome,
the web browser, gets

00:05:24.360 --> 00:05:26.340
access to these system-level
resources.

00:05:26.340 --> 00:05:29.920
So a long time ago, a company
made a plug-in architecture

00:05:29.920 --> 00:05:32.440
called NPAPI.

00:05:32.440 --> 00:05:35.500
Effectively, this plug-in
architecture allowed plug-ins

00:05:35.500 --> 00:05:38.090
to be developed for a browser
that then had access to lower

00:05:38.090 --> 00:05:40.060
level systems in various
ways, so that users

00:05:40.060 --> 00:05:41.380
can install the plug-in.

00:05:41.380 --> 00:05:43.990
And if the plug-in dll targeted
these header files,

00:05:43.990 --> 00:05:45.820
it had access to these things.

00:05:45.820 --> 00:05:49.340
Well, the problem was that
at its heyday, this NPAPI

00:05:49.340 --> 00:05:52.710
architecture was actually the
number one problem of malware

00:05:52.710 --> 00:05:54.200
and bugs in the environment.

00:05:54.200 --> 00:05:57.360
So Chrome went ahead and said,
we're going to support NPAPI.

00:05:57.360 --> 00:05:59.640
But we want to create a safer
version, so that we don't have

00:05:59.640 --> 00:06:01.450
to worry about all these
pop-ups, and

00:06:01.450 --> 00:06:02.810
spyware, and malware.

00:06:02.810 --> 00:06:06.540
So we created what we call the
Pepper API, or PPAPI, which is

00:06:06.540 --> 00:06:10.280
a plug-in architecture that
allows you to target file IO,

00:06:10.280 --> 00:06:12.510
rendering, audio, and even
have the ability to

00:06:12.510 --> 00:06:15.970
communicate back to the page
that's hosting the plug-in

00:06:15.970 --> 00:06:18.180
through JavaScript post
message results.

00:06:18.180 --> 00:06:20.650
So understanding this, that
there's effectively a Pepper

00:06:20.650 --> 00:06:24.640
API that allows plug-ins to
access these inner workings

00:06:24.640 --> 00:06:28.230
through Chrome, Native Client
is effectively a module that

00:06:28.230 --> 00:06:29.150
communicates with this.

00:06:29.150 --> 00:06:32.170
So your NEXE file, when you
compile it, you'll target

00:06:32.170 --> 00:06:34.690
these specific headers to do
things like file IO, audio,

00:06:34.690 --> 00:06:36.090
rendering, and JavaScript.

00:06:36.090 --> 00:06:38.650
This is how your program gets
access to the lower level

00:06:38.650 --> 00:06:40.830
architecture.

00:06:40.830 --> 00:06:43.150
Now it's worth noting this, too,
is that the Pepper thread

00:06:43.150 --> 00:06:46.140
is actually running on the
main thread of Chrome.

00:06:46.140 --> 00:06:47.370
So your Native Client module is

00:06:47.370 --> 00:06:49.060
sitting there doing execution.

00:06:49.060 --> 00:06:51.180
Also on this main thread,
though, are some other

00:06:51.180 --> 00:06:53.360
important buddies that you
need to be aware of.

00:06:53.360 --> 00:06:54.570
First off is WebKit.

00:06:54.570 --> 00:06:56.200
WebKit executes on
the same thread.

00:06:56.200 --> 00:06:58.670
This is the layout
organizational DOM rendering

00:06:58.670 --> 00:06:59.630
style engine.

00:06:59.630 --> 00:07:00.910
It is out there open source.

00:07:00.910 --> 00:07:04.260
Also V8, which is Chrome's
virtual machine for handling

00:07:04.260 --> 00:07:07.160
JavaScript, as well as some
other fun stuff like Web RTC,

00:07:07.160 --> 00:07:09.260
audio processing, video, and
all this other stuff.

00:07:09.260 --> 00:07:12.010
The important takeaway you
should see here is that your

00:07:12.010 --> 00:07:15.090
Native Client module has the
ability to effectively stall

00:07:15.090 --> 00:07:17.580
out this main thread not
doing correctly.

00:07:17.580 --> 00:07:21.180
So if you go in and put a spin
loop on your main thread,

00:07:21.180 --> 00:07:23.290
you're effectively going to
halt the entire web page,

00:07:23.290 --> 00:07:26.240
because the WebKit doesn't get
the input processing, and V8

00:07:26.240 --> 00:07:27.440
doesn't get JavaScript
processing.

00:07:27.440 --> 00:07:30.680
So it's going to stall the tab
and effectively crash out.

00:07:30.680 --> 00:07:34.000
Because of this, you're not
supposed to call any blocking

00:07:34.000 --> 00:07:35.730
functions on the main thread.

00:07:35.730 --> 00:07:38.350
This is a bad idea, so none of
your code should be calling

00:07:38.350 --> 00:07:40.600
blocking functions on
the main thread.

00:07:40.600 --> 00:07:43.930
And because of that, the
Pepper API's are all

00:07:43.930 --> 00:07:45.180
asynchronous.

00:07:45.180 --> 00:07:47.660
None of them are blocking
at all.

00:07:47.660 --> 00:07:50.250
This means that you can call the
Pepper API from the main

00:07:50.250 --> 00:07:51.690
thread, and then some
time in the future

00:07:51.690 --> 00:07:53.830
you'll get that result.

00:07:53.830 --> 00:07:55.240
Generally, that's
about one frame.

00:07:55.240 --> 00:07:57.230
So if you looked at that
previous diagram, you can see

00:07:57.230 --> 00:07:59.600
that we've got WebKit, we've
got V8, and then we've got

00:07:59.600 --> 00:08:00.610
NaCl and some other stuff.

00:08:00.610 --> 00:08:03.396
So if NaCl says, hey, I want
to go load this file, it's

00:08:03.396 --> 00:08:05.390
going to kick off a request. And
then we have to generally

00:08:05.390 --> 00:08:07.980
wait until WebKit, V8 gets
processed and the plug-in

00:08:07.980 --> 00:08:10.440
frame gets processed before
those results can be given

00:08:10.440 --> 00:08:15.270
back to the main thread of your
Native Client module.

00:08:15.270 --> 00:08:18.820
Also, one of the restrictions
of Pepper is that all the

00:08:18.820 --> 00:08:20.900
Pepper API's must be called
from the main

00:08:20.900 --> 00:08:21.570
thread right now.

00:08:21.570 --> 00:08:23.920
This is a current restriction
that our team is actively

00:08:23.920 --> 00:08:25.480
working on to fix.

00:08:25.480 --> 00:08:27.370
But this has some potential
downsides that you

00:08:27.370 --> 00:08:29.990
need to be aware of.

00:08:29.990 --> 00:08:31.300
Before we dive into
that, let's talk

00:08:31.300 --> 00:08:32.340
about how this works.

00:08:32.340 --> 00:08:35.460
So on the top here we've got a
function that shows how to do

00:08:35.460 --> 00:08:36.400
file layout.

00:08:36.400 --> 00:08:37.120
So we've got a function.

00:08:37.120 --> 00:08:39.490
We're asserting that this is
coming from the main thread.

00:08:39.490 --> 00:08:41.610
We get some information
from the user.

00:08:41.610 --> 00:08:43.679
And we actually call
FileIO.Open.

00:08:43.679 --> 00:08:46.840
With FileIO.Open you actually
provide a completion callback.

00:08:46.840 --> 00:08:49.990
The completion callback will
occur once this file open

00:08:49.990 --> 00:08:52.380
request has occurred at the
lower level, the Pepper API

00:08:52.380 --> 00:08:55.120
level, and the results of that
will be pushed back to you.

00:08:55.120 --> 00:08:56.880
That's the second function
here you can see

00:08:56.880 --> 00:08:59.620
open, f open callback.

00:08:59.620 --> 00:09:01.870
This will get called on your
main thread once everything

00:09:01.870 --> 00:09:05.240
has been done in the lower
bowels of Chrome and the

00:09:05.240 --> 00:09:06.200
Pepper API's.

00:09:06.200 --> 00:09:07.750
And then you can, yay,
do some stuff.

00:09:07.750 --> 00:09:08.640
Show a cat.

00:09:08.640 --> 00:09:09.350
Issue a read.

00:09:09.350 --> 00:09:11.770
Whatever you need to
do at that point.

00:09:11.770 --> 00:09:13.870
So this is sort of a problem.

00:09:13.870 --> 00:09:16.630
Because this works in a very
different way than all of your

00:09:16.630 --> 00:09:18.440
architectures.

00:09:18.440 --> 00:09:20.170
This is not how your game
engine is designed.

00:09:20.170 --> 00:09:21.440
I can guarantee this
is not how your

00:09:21.440 --> 00:09:22.330
game engine is designed.

00:09:22.330 --> 00:09:25.780
Even if you have asynchronous
loading in your game, sooner

00:09:25.780 --> 00:09:27.040
or later you're going
to expect f read

00:09:27.040 --> 00:09:28.020
as a blocking function.

00:09:28.020 --> 00:09:29.520
You've got everything
working around that.

00:09:29.520 --> 00:09:32.160
More importantly, you probably
have f read calls coming from

00:09:32.160 --> 00:09:35.260
the main thread, which, in
general, is a problem.

00:09:35.260 --> 00:09:40.900
So the point next is how do
you design around this?

00:09:40.900 --> 00:09:41.750
How do you beat this?

00:09:41.750 --> 00:09:42.870
How do you say--

00:09:42.870 --> 00:09:43.840
how do I touch my code?

00:09:43.840 --> 00:09:47.370
Well, one idea is to modify
all of your f reads to use

00:09:47.370 --> 00:09:49.220
this blocking callback system.

00:09:49.220 --> 00:09:50.310
Or how do you do these
other things?

00:09:50.310 --> 00:09:51.830
Make sure the thread
doesn't stall.

00:09:51.830 --> 00:09:52.250
Forget all that.

00:09:52.250 --> 00:09:54.470
I'm going to give you the
shortcut I'm going to drop

00:09:54.470 --> 00:09:55.450
some wisdom on you.

00:09:55.450 --> 00:09:57.030
I'm going to point my knowledge
cannon in your

00:09:57.030 --> 00:09:59.810
direction, and give you
a blast of info.

00:09:59.810 --> 00:10:02.930
The best idea is to actually
spin up a thread and run your

00:10:02.930 --> 00:10:05.570
main game logic on
that thread.

00:10:05.570 --> 00:10:09.820
And leave the original main
thread as the Pepper thread.

00:10:09.820 --> 00:10:12.070
Basically, what this allows you
to do is you wrap all of

00:10:12.070 --> 00:10:15.350
your platform functions to issue
communication back and

00:10:15.350 --> 00:10:17.050
forth to the main thread.

00:10:17.050 --> 00:10:19.090
Let's take a look at what
that looks like here.

00:10:19.090 --> 00:10:21.840
So your game has the Pepper
thread or the main thread.

00:10:21.840 --> 00:10:23.310
That spawns off your
logic thread.

00:10:23.310 --> 00:10:26.190
Now the logic thread is
effectively going to run the

00:10:26.190 --> 00:10:28.500
main loop, while true--

00:10:28.500 --> 00:10:32.300
update, render, network, update,
network, render.

00:10:32.300 --> 00:10:33.110
Do all that stuff.

00:10:33.110 --> 00:10:34.490
And it's going to just continue
doing that on the

00:10:34.490 --> 00:10:35.890
logic thread.

00:10:35.890 --> 00:10:38.280
The Pepper thread is the
only access to FileIO,

00:10:38.280 --> 00:10:39.260
JavaScript, and audio.

00:10:39.260 --> 00:10:42.030
Your logic thread should not
have direct access to that.

00:10:42.030 --> 00:10:44.880
Instead, the logic thread will
call specific commands, which

00:10:44.880 --> 00:10:47.570
pushes a function to the
Pepper thread and

00:10:47.570 --> 00:10:48.970
then it will block.

00:10:48.970 --> 00:10:51.190
The Pepper thread will then
receive that function,

00:10:51.190 --> 00:10:54.790
communicate off to the lower
level IO, do its fun stuff,

00:10:54.790 --> 00:10:58.260
return that data to the Pepper
thread, and the Pepper thread

00:10:58.260 --> 00:11:00.130
will then return that
data to your logic

00:11:00.130 --> 00:11:01.590
thread in the fashion.

00:11:01.590 --> 00:11:05.220
What this means is that you can
overload f read, f write,

00:11:05.220 --> 00:11:08.030
blocking functions like that,
to effectively do the same

00:11:08.030 --> 00:11:09.300
thing that you would
expect them to

00:11:09.300 --> 00:11:10.910
already do in your game.

00:11:10.910 --> 00:11:13.910
You just effectively create this
abstraction layer around

00:11:13.910 --> 00:11:15.720
them, so that it actually
communicates with the Pepper

00:11:15.720 --> 00:11:18.100
thread in a proper manner
without actually having to

00:11:18.100 --> 00:11:19.445
touch all the lines
of code that

00:11:19.445 --> 00:11:21.810
you've already got written.

00:11:21.810 --> 00:11:23.430
Here's an example of how
to look at this.

00:11:23.430 --> 00:11:26.000
So this top function here
is request and wait.

00:11:26.000 --> 00:11:28.090
So what this will do is assert
that, first off, you're not

00:11:28.090 --> 00:11:28.900
running on the main thread.

00:11:28.900 --> 00:11:30.240
You're running on
a worker thread.

00:11:30.240 --> 00:11:33.870
And Native Client and Pepper
actually provide a nice little

00:11:33.870 --> 00:11:37.840
API that will auto call your
function on the main thread on

00:11:37.840 --> 00:11:39.570
your behalf, so that you don't
have to write all the

00:11:39.570 --> 00:11:42.490
intricate threading, and
messaging, and queuing logic

00:11:42.490 --> 00:11:43.610
to get it to call there.

00:11:43.610 --> 00:11:46.840
So simply, you call
module.get.core.

00:11:46.840 --> 00:11:47.990
Call on main thread.

00:11:47.990 --> 00:11:50.570
And you effectively pass
it a callback function.

00:11:50.570 --> 00:11:53.820
And this will ensure that your
callback function will get

00:11:53.820 --> 00:11:55.030
pushed into the proper queues.

00:11:55.030 --> 00:11:56.715
And it will be called in the
main thread the next time a

00:11:56.715 --> 00:11:58.100
frame process happens.

00:11:58.100 --> 00:12:00.690
Now what's nice about this is
that this allows you, on the

00:12:00.690 --> 00:12:03.680
calling thread, to then set a
conditional data variable and

00:12:03.680 --> 00:12:04.770
sit around and wait.

00:12:04.770 --> 00:12:07.010
So with this function here, you
actually issue a function

00:12:07.010 --> 00:12:10.000
command, wait until it has been
called and executed on

00:12:10.000 --> 00:12:12.930
the main thread and control
has been returned.

00:12:12.930 --> 00:12:14.960
And you can see on the bottom
here, this is the return from

00:12:14.960 --> 00:12:16.920
main thread function.

00:12:16.920 --> 00:12:19.360
Effectively what this does is,
first off, asserts that you're

00:12:19.360 --> 00:12:20.780
on the main thread, because
you want to make sure your

00:12:20.780 --> 00:12:21.050
code's clean.

00:12:21.050 --> 00:12:22.800
You want to make sure you're
doing the right thing.

00:12:22.800 --> 00:12:24.420
And then it will actually get
the information that has been

00:12:24.420 --> 00:12:26.930
passed to it as a callback
parameter, set some result,

00:12:26.930 --> 00:12:29.170
and then signal the conditional
signal.

00:12:29.170 --> 00:12:31.270
That signal right there, that
event, that p thread

00:12:31.270 --> 00:12:34.910
conditional, will allow the
worker thread, the logic

00:12:34.910 --> 00:12:37.040
thread, that actually issued the
command to then wake up,

00:12:37.040 --> 00:12:38.820
continue doing what it was
doing, and move on.

00:12:38.820 --> 00:12:39.750
This is fantastic.

00:12:39.750 --> 00:12:41.950
With these two little functions
right here, you can

00:12:41.950 --> 00:12:44.930
implement a structure around it
that allow you to overload

00:12:44.930 --> 00:12:47.630
f read and f write and those
other functions to be blocking

00:12:47.630 --> 00:12:50.320
functions from the
logic thread.

00:12:50.320 --> 00:12:51.790
So this is effectively
what happens.

00:12:51.790 --> 00:12:54.280
You end up in a situation where
you start calling data.

00:12:54.280 --> 00:12:54.720
It blocks.

00:12:54.720 --> 00:12:55.280
Comes back.

00:12:55.280 --> 00:12:56.970
Calls data, blocks,
comes back.

00:12:56.970 --> 00:12:59.980
And this is fine for a lot of
functions that you expect to

00:12:59.980 --> 00:13:00.480
work this way.

00:13:00.480 --> 00:13:02.550
Your architecture will
transition over seamlessly.

00:13:02.550 --> 00:13:04.390
And you won't have to
worry about it.

00:13:04.390 --> 00:13:08.610
The problem turns into function
APIs that don't

00:13:08.610 --> 00:13:10.550
benefit from working
in this fashion.

00:13:10.550 --> 00:13:11.900
For example, rendering.

00:13:11.900 --> 00:13:13.920
Rendering works very
differently.

00:13:13.920 --> 00:13:15.910
Rendering expects that I
shouldn't have to block for

00:13:15.910 --> 00:13:19.080
lots and lots of frames to
submit each instance.

00:13:19.080 --> 00:13:21.310
In that situation, what you want
to do is for these types

00:13:21.310 --> 00:13:24.710
of calls that are best for
fire and forget, that you

00:13:24.710 --> 00:13:26.030
don't actually wait
for a response.

00:13:26.030 --> 00:13:27.800
These things don't need
any information back

00:13:27.800 --> 00:13:28.820
from the main thread.

00:13:28.820 --> 00:13:31.200
As such, you should just fire
them off very quickly and

00:13:31.200 --> 00:13:33.310
allow the logic thread
to move on.

00:13:33.310 --> 00:13:35.730
So you can see here you get
three fires really quick.

00:13:35.730 --> 00:13:37.490
And then the Pepper thread
spends its time doing the

00:13:37.490 --> 00:13:40.430
proper resource handling to the
underlying architecture

00:13:40.430 --> 00:13:42.090
without you having to block.

00:13:42.090 --> 00:13:44.700
Now for rendering, there's
actually a different process

00:13:44.700 --> 00:13:46.220
involved here that you can
actually think about in a

00:13:46.220 --> 00:13:47.680
different way.

00:13:47.680 --> 00:13:52.010
A very modern graphics engine
mechanic is actually the

00:13:52.010 --> 00:13:55.280
concept of buffering up all of
your draw commands, submitting

00:13:55.280 --> 00:13:58.860
them off to the Pepper thread at
a various form, so that it

00:13:58.860 --> 00:14:00.570
kind of gets the entire frame.

00:14:00.570 --> 00:14:03.160
And then it starts queuing
through it properly.

00:14:03.160 --> 00:14:05.460
So what happens is your logic
thread will go and do the

00:14:05.460 --> 00:14:07.050
rendering, actually
create the calls.

00:14:07.050 --> 00:14:09.230
But instead of actually doing
the rendering and calling the

00:14:09.230 --> 00:14:12.100
APIs, what happens is you
overload the API to create a

00:14:12.100 --> 00:14:15.750
small, little representation,
like a quad word or some form

00:14:15.750 --> 00:14:17.950
of it that gets pushed
into an FIFO.

00:14:17.950 --> 00:14:20.500
And that FIFO is then consumed
by the Pepper thread, and

00:14:20.500 --> 00:14:23.140
issued off to the appropriate
engines below that.

00:14:23.140 --> 00:14:25.180
Now this is important, that what
you're effectively doing

00:14:25.180 --> 00:14:27.700
here is you're creating a
waterfall processing method,

00:14:27.700 --> 00:14:30.960
or a producer consumer FIFO
between your logic thread and

00:14:30.960 --> 00:14:33.380
your Pepper thread, where the
logic thread will do logic

00:14:33.380 --> 00:14:37.020
frame n, kick off the rendering
results for that.

00:14:37.020 --> 00:14:40.670
And render thread will then do
render frame n while the logic

00:14:40.670 --> 00:14:42.470
thread moves on to
the next frame.

00:14:42.470 --> 00:14:45.390
This, again, is a very
common paradigm for

00:14:45.390 --> 00:14:46.430
next generation consoles--

00:14:46.430 --> 00:14:48.240
Xbox 360, PS3.

00:14:48.240 --> 00:14:49.530
This is what you're doing
in a lot of your

00:14:49.530 --> 00:14:50.690
systems right here.

00:14:50.690 --> 00:14:52.510
Traditionally they call the
Pepper thread the render

00:14:52.510 --> 00:14:53.520
thread at that point.

00:14:53.520 --> 00:14:55.430
And there's some variation
of what data is

00:14:55.430 --> 00:14:56.760
pushed between the two.

00:14:56.760 --> 00:15:00.250
In this particular method, you
want no logic occurring on the

00:15:00.250 --> 00:15:03.910
Pepper thread other than just
rendering your data.

00:15:03.910 --> 00:15:06.190
So that's the ecosystem
that you're in.

00:15:06.190 --> 00:15:07.590
That's sort of what you're
dealing with.

00:15:07.590 --> 00:15:10.245
Basically, what you need to do
is spin off a logic threat and

00:15:10.245 --> 00:15:13.000
then modify your code such that
you handle two different

00:15:13.000 --> 00:15:13.960
types of calls.

00:15:13.960 --> 00:15:15.930
You've got the calls that
require feedback from the

00:15:15.930 --> 00:15:16.570
Pepper thread.

00:15:16.570 --> 00:15:18.130
And then those you need to
block and wait for that

00:15:18.130 --> 00:15:19.400
information to return.

00:15:19.400 --> 00:15:21.110
And then you've got the
fire and forget calls.

00:15:21.110 --> 00:15:23.490
And those are the calls that
you just either issue

00:15:23.490 --> 00:15:25.150
immediately and then
keep moving on.

00:15:25.150 --> 00:15:27.710
Or you bundle up into some
sort of frame or boundary

00:15:27.710 --> 00:15:29.930
mechanic and submit in one
batch, and then let the Pepper

00:15:29.930 --> 00:15:32.670
thread do its thing while you're
logic thread moves on.

00:15:32.670 --> 00:15:34.510
So once you understand the
environment that you're in,

00:15:34.510 --> 00:15:36.630
because of the Pepper API
restrictions, which are

00:15:36.630 --> 00:15:39.320
temporary, by the way, now you
can actually start porting the

00:15:39.320 --> 00:15:40.440
rest of your code.

00:15:40.440 --> 00:15:41.620
And this involves understanding

00:15:41.620 --> 00:15:42.630
at a number of levels.

00:15:42.630 --> 00:15:44.690
So let's dive in.

00:15:44.690 --> 00:15:46.200
The first is FileIO.

00:15:46.200 --> 00:15:48.630
So if you've never developed a
web game, let me clue you in

00:15:48.630 --> 00:15:49.970
on some specific information.

00:15:49.970 --> 00:15:54.300
You're going to put your HTML
datas and your NEXE datas and

00:15:54.300 --> 00:15:57.030
your NMF datas on some
server somewhere.

00:15:57.030 --> 00:16:00.940
And when the user loads your
page that embeds this module,

00:16:00.940 --> 00:16:03.410
it's going to be received by the
client and auto-cached by

00:16:03.410 --> 00:16:04.960
Chrome on your behalf.

00:16:04.960 --> 00:16:06.720
This is just going to happen
automatically.

00:16:06.720 --> 00:16:09.180
And it will grab the HTML data,
the NEXE data, and the

00:16:09.180 --> 00:16:11.340
NMF data and cache it for
you because it's defined

00:16:11.340 --> 00:16:12.460
in the embed tag.

00:16:12.460 --> 00:16:13.470
And this is great.

00:16:13.470 --> 00:16:14.850
This means that Chrome
is handling your

00:16:14.850 --> 00:16:16.150
caching on your behalf.

00:16:16.150 --> 00:16:17.300
You don't have to do
anything else.

00:16:17.300 --> 00:16:19.590
You just sit back, hands
behind your head,

00:16:19.590 --> 00:16:20.250
allow it all to happen.

00:16:20.250 --> 00:16:21.600
It's good to go.

00:16:21.600 --> 00:16:22.840
The problem is that
there's other data

00:16:22.840 --> 00:16:23.580
that your game needs.

00:16:23.580 --> 00:16:26.180
There are zip files, for
instance, ZIP0 and ZIP1.

00:16:26.180 --> 00:16:28.690
These will not be pulled down
automatically for you when the

00:16:28.690 --> 00:16:29.880
user loads your page.

00:16:29.880 --> 00:16:33.830
Instead, for these, you have to
use a GetURL API inside of

00:16:33.830 --> 00:16:37.910
Pepper or an XHR request
inside of JavaScript.

00:16:37.910 --> 00:16:40.310
And that will pull down
these binary assets.

00:16:40.310 --> 00:16:43.120
Now the cool thing is that
with this call, with the

00:16:43.120 --> 00:16:45.910
GetURL call, it will also
cache itself in

00:16:45.910 --> 00:16:46.860
Chrome on your behalf.

00:16:46.860 --> 00:16:48.460
So you can actually fetch
these zip files.

00:16:48.460 --> 00:16:49.360
Chrome will cache it.

00:16:49.360 --> 00:16:51.450
And then the next time the
user asks for it, it will

00:16:51.450 --> 00:16:52.430
already be in the cache.

00:16:52.430 --> 00:16:53.870
And they can get it from there,
as opposed to going

00:16:53.870 --> 00:16:57.810
back to the server, which
is a longer round trip.

00:16:57.810 --> 00:17:00.190
One of the interesting things
about this, though, is that

00:17:00.190 --> 00:17:03.430
when your data is in the cache,
it can also be evicted

00:17:03.430 --> 00:17:05.180
from the cache at
any single time.

00:17:05.180 --> 00:17:07.780
The user can go and load a
website which uses more data.

00:17:07.780 --> 00:17:10.190
Or they can clear the
cache themselves.

00:17:10.190 --> 00:17:13.150
But basically, they can purge
all of this asset storing that

00:17:13.150 --> 00:17:16.540
you're doing on their behalf, so
that the experience in your

00:17:16.540 --> 00:17:18.230
game is not as optimal
as it should be.

00:17:18.230 --> 00:17:19.630
And this is a bad thing.

00:17:19.630 --> 00:17:21.790
To answer this, there's actually
a cool little API

00:17:21.790 --> 00:17:23.960
inside of Pepper called
the File Store API.

00:17:23.960 --> 00:17:27.319
The File Store API will allow
you to grab data inside of the

00:17:27.319 --> 00:17:32.140
client's memory and store it
to a persistent sandboxed

00:17:32.140 --> 00:17:33.960
obfuscated file store.

00:17:33.960 --> 00:17:37.690
Now, this data will exist on
disk until one of two things

00:17:37.690 --> 00:17:39.240
happens or both will happen.

00:17:39.240 --> 00:17:42.810
The user navigates to this
sandbox system somehow through

00:17:42.810 --> 00:17:44.950
their API and their operating
system and

00:17:44.950 --> 00:17:47.010
manually deletes the data.

00:17:47.010 --> 00:17:50.010
Or your program deletes
the data.

00:17:50.010 --> 00:17:52.140
So effectively this allows you
to take control over the

00:17:52.140 --> 00:17:53.770
caching mechanisms that
are used during

00:17:53.770 --> 00:17:54.950
this transfer process.

00:17:54.950 --> 00:17:57.710
So definitely make sure
you're using that.

00:17:57.710 --> 00:17:59.130
You can click the link at
the bottom here for more

00:17:59.130 --> 00:17:59.550
information.

00:17:59.550 --> 00:18:01.300
That actually directs
to gonacl.com.

00:18:01.300 --> 00:18:03.260
We have a specific article
on how to do all this.

00:18:05.820 --> 00:18:07.060
FileIO and shutdown.

00:18:07.060 --> 00:18:10.700
Console developers in here, you
will help me lament over

00:18:10.700 --> 00:18:14.460
the process of trying to write
to a memory stick that has

00:18:14.460 --> 00:18:16.190
been pushed into a console.

00:18:16.190 --> 00:18:18.280
And as you're writing, the
user rips the stick out

00:18:18.280 --> 00:18:19.290
because they think it's done.

00:18:19.290 --> 00:18:20.340
And now, all of a sudden,
you have--

00:18:20.340 --> 00:18:21.910
effectively the world
explodes.

00:18:21.910 --> 00:18:23.590
The data written to
disk is corrupted.

00:18:23.590 --> 00:18:25.290
The information being
transferred is corrupted.

00:18:25.290 --> 00:18:28.460
And the user is mad at you
because you didn't know they

00:18:28.460 --> 00:18:29.725
were going to rip
the stick out.

00:18:29.725 --> 00:18:30.000
Who knows?

00:18:30.000 --> 00:18:33.420
Well, anyhow, in a web page
you have the same problem.

00:18:33.420 --> 00:18:35.630
When you're trying to write data
to your persistent file

00:18:35.630 --> 00:18:37.720
store, the user can tab away.

00:18:37.720 --> 00:18:39.390
They can close the data.

00:18:39.390 --> 00:18:40.450
A crash can occur.

00:18:40.450 --> 00:18:41.790
Something can happen
that effectively

00:18:41.790 --> 00:18:43.060
does the same process.

00:18:43.060 --> 00:18:45.470
It effectively deteriorates
the data.

00:18:45.470 --> 00:18:46.860
Stops the write.

00:18:46.860 --> 00:18:48.780
Causes problems of all sorts.

00:18:48.780 --> 00:18:51.410
So if you've actually opened
this file and tried to write

00:18:51.410 --> 00:18:54.230
to it, when you try to load it
the next time around, the

00:18:54.230 --> 00:18:55.550
information is going
to be corrupt.

00:18:55.550 --> 00:18:57.110
Basically, you're going
to lose it.

00:18:57.110 --> 00:19:00.820
The better methodology here is
for any writes to file, what

00:19:00.820 --> 00:19:03.130
you actually want to do is write
to a separate file or a

00:19:03.130 --> 00:19:06.120
duplicate file and communicate
all of your data there.

00:19:06.120 --> 00:19:10.020
And then once all of your
writing has been finalized, at

00:19:10.020 --> 00:19:14.050
the end of your process, you
actually then move, rename,

00:19:14.050 --> 00:19:17.880
some process, over to the
intended position.

00:19:17.880 --> 00:19:21.050
And this means-- what occurs
here is that if the chance

00:19:21.050 --> 00:19:24.205
that the user corrupts the data
during the write to the

00:19:24.205 --> 00:19:26.550
persistent file store, that it
doesn't actually corrupt the

00:19:26.550 --> 00:19:27.755
original data on disks.

00:19:27.755 --> 00:19:30.320
So when the user loads the game
next time, all they've

00:19:30.320 --> 00:19:34.260
lost is the delta between the
last time they've saved, as

00:19:34.260 --> 00:19:39.300
opposed to your entire saved
file, which is a good thing.

00:19:39.300 --> 00:19:41.970
Now for those of you who are
doing FileIO, there is a

00:19:41.970 --> 00:19:45.220
really cool mode that's recent,
that's actually a

00:19:45.220 --> 00:19:46.880
dangerous FileIO.

00:19:46.880 --> 00:19:49.160
And there's some terminology
about why you want to call it

00:19:49.160 --> 00:19:49.860
dangerous or not.

00:19:49.860 --> 00:19:51.630
But this is really helpful
to those of you who are

00:19:51.630 --> 00:19:52.540
developers.

00:19:52.540 --> 00:19:55.700
So in developer mode, you can
actually write directly to

00:19:55.700 --> 00:19:59.220
disk outside of the obfuscated
sandbox.

00:19:59.220 --> 00:20:00.950
This is really helpful.

00:20:00.950 --> 00:20:03.200
Effectively, when you launch
Chrome, you can send an

00:20:03.200 --> 00:20:06.260
environment variable, NaCl
Dangerous Enable File Access.

00:20:06.260 --> 00:20:07.620
And then you run Chrome
with no sandbox.

00:20:07.620 --> 00:20:10.550
This effectively turns off some
of the security handles

00:20:10.550 --> 00:20:12.380
that you have available
to you.

00:20:12.380 --> 00:20:14.990
And then in the code, in your
C code, you actually do a

00:20:14.990 --> 00:20:18.530
direct f open and start
writing to it.

00:20:18.530 --> 00:20:21.300
And what this will do is
actually create a file in the

00:20:21.300 --> 00:20:24.240
application location
of where NaCl is.

00:20:24.240 --> 00:20:26.770
So for instance, path to Chrome
slash build number.

00:20:26.770 --> 00:20:29.010
That's where NaCl.exe exists.

00:20:29.010 --> 00:20:31.270
So with this set up here,
this actually creates a

00:20:31.270 --> 00:20:34.900
tracelog.txt in my application
folder for Chrome 19, which is

00:20:34.900 --> 00:20:36.090
currently in Canary.

00:20:36.090 --> 00:20:37.500
This is amazing.

00:20:37.500 --> 00:20:39.690
So for those of you developers
who are trying to do inline

00:20:39.690 --> 00:20:45.170
profiling or trying to dump
crash disks or crash logs to

00:20:45.170 --> 00:20:47.740
disk in these sorts of fashions,
having to wait for

00:20:47.740 --> 00:20:50.420
the asynchronous file system
is just not doable.

00:20:50.420 --> 00:20:52.540
Instead, you actually want
to control writing

00:20:52.540 --> 00:20:53.500
directly to a disk.

00:20:53.500 --> 00:20:55.000
And this gives you
that ability.

00:20:55.000 --> 00:20:56.180
This is really important.

00:20:56.180 --> 00:20:57.750
It allows you to move
forward with getting

00:20:57.750 --> 00:20:58.570
all this stuff done.

00:20:58.570 --> 00:21:00.040
And you can click that
link there for more.

00:21:00.040 --> 00:21:03.500
It's got more information on
it and how you use it.

00:21:03.500 --> 00:21:04.610
Rendering.

00:21:04.610 --> 00:21:09.540
So first off, Native Client
uses OpenGL ES 2.0 as a

00:21:09.540 --> 00:21:10.450
rendering API.

00:21:10.450 --> 00:21:14.260
So this is the same API that's
used on mobile devices today.

00:21:14.260 --> 00:21:17.190
Porting your game to use
this is step one.

00:21:17.190 --> 00:21:19.070
So if you're using DirectX, you
need to port your stuff

00:21:19.070 --> 00:21:20.850
over to OpenGL first, because
that will be an easy

00:21:20.850 --> 00:21:21.900
transition for you.

00:21:21.900 --> 00:21:25.280
And then from OpenGL, you need
to move to OpenGL ES 2.0.

00:21:25.280 --> 00:21:27.040
You can do this using a project

00:21:27.040 --> 00:21:28.820
called ANGLE on Windows.

00:21:28.820 --> 00:21:30.140
If you click that link,
there's a source code

00:21:30.140 --> 00:21:31.730
repository there where
the entire

00:21:31.730 --> 00:21:32.760
source code is available.

00:21:32.760 --> 00:21:38.170
Effectively, ANGLE is a dll
suite that provides OpenGL ES

00:21:38.170 --> 00:21:41.930
2.0 headers that you can then
target that will translate to

00:21:41.930 --> 00:21:43.150
DirectX calls internally.

00:21:43.150 --> 00:21:45.670
So you can effectively test how
your code is working and

00:21:45.670 --> 00:21:46.650
do this all on Windows.

00:21:46.650 --> 00:21:49.960
To note, there's no OpenGL ES
2.0 runtime on Windows.

00:21:49.960 --> 00:21:52.720
It doesn't exist. So if you're
going to try to test this on

00:21:52.720 --> 00:21:56.560
Windows, you're going to
need to use ANGLE.

00:21:56.560 --> 00:21:58.350
Specifically, you need
to know that OpenGL

00:21:58.350 --> 00:22:00.220
ES 2.0 is not OpenGL.

00:22:00.220 --> 00:22:01.980
There's a stricter set
of compiler rules.

00:22:01.980 --> 00:22:03.910
And this is because we need to
make sure that security is

00:22:03.910 --> 00:22:06.010
step one for the end user.

00:22:06.010 --> 00:22:07.600
The developer, your experience
that you're trying to

00:22:07.600 --> 00:22:09.290
communicate, that's all
fine and dandy.

00:22:09.290 --> 00:22:12.200
Keeping the user safe is more
important than all of that.

00:22:12.200 --> 00:22:14.120
And not all the extensions
are available.

00:22:14.120 --> 00:22:18.000
So, for instance, if you're
expecting instancing or access

00:22:18.000 --> 00:22:20.810
to a specific tessellation
shader, they're just not going

00:22:20.810 --> 00:22:21.350
to be there.

00:22:21.350 --> 00:22:22.210
This is an API.

00:22:22.210 --> 00:22:24.680
This is handled by the Khronos
group and then rolling the

00:22:24.680 --> 00:22:27.950
feature sets out is sort of
tiered because we have to go

00:22:27.950 --> 00:22:29.080
through those bodies.

00:22:29.080 --> 00:22:31.410
But make sure that you
understand that OpenGL ES 2.0

00:22:31.410 --> 00:22:33.240
and OpenGL are not
the same thing.

00:22:33.240 --> 00:22:35.850
Specifically, for API nuances.

00:22:35.850 --> 00:22:39.050
For instance, in OpenGL you
can create a compressed

00:22:39.050 --> 00:22:42.170
texture and not pass any
information into it.

00:22:42.170 --> 00:22:44.370
So you can just say, hey, create
this blank texture, and

00:22:44.370 --> 00:22:45.840
I'll fill it in later.

00:22:45.840 --> 00:22:48.820
OpenGL ES 2.0, actually, this
is considered an error.

00:22:48.820 --> 00:22:50.540
If you try to do this, it
will actually crash.

00:22:50.540 --> 00:22:53.460
Now the problem is this is
not well documented.

00:22:53.460 --> 00:22:55.600
And if you go to the Native
Client forums, you'll actually

00:22:55.600 --> 00:22:58.460
see about 10 or 11 people,
myself included, complaining

00:22:58.460 --> 00:23:00.520
about this problem and asking
for a solution.

00:23:00.520 --> 00:23:07.330
The reality is that this is an
OpenGL E 2.0 spec that is not

00:23:07.330 --> 00:23:08.510
compatible with OpenGL.

00:23:08.510 --> 00:23:10.820
Make sure you test all of
this stuff properly.

00:23:10.820 --> 00:23:12.930
And definitely make sure you're
checking the API before

00:23:12.930 --> 00:23:14.815
you start blaming Native Client,
because a lot of the

00:23:14.815 --> 00:23:16.065
times the problem is there.

00:23:18.750 --> 00:23:20.930
So the next thing you need to be
aware of when you're doing

00:23:20.930 --> 00:23:22.020
rendering is that
you're actually

00:23:22.020 --> 00:23:23.160
rendering from a sandbox.

00:23:23.160 --> 00:23:25.020
Now because of security issues,
we don't actually

00:23:25.020 --> 00:23:28.350
allow your code to directly
go to the driver.

00:23:28.350 --> 00:23:31.740
When you do a set command or a
draw command or anything, we

00:23:31.740 --> 00:23:33.400
don't actually go right
to the API.

00:23:33.400 --> 00:23:34.850
Instead, what occurs
is we have a

00:23:34.850 --> 00:23:36.060
separate render process.

00:23:36.060 --> 00:23:40.340
The render process is
responsible for handling all

00:23:40.340 --> 00:23:41.720
the interaction with the API.

00:23:41.720 --> 00:23:43.720
Nothing else goes through
this render

00:23:43.720 --> 00:23:45.580
process except API calls.

00:23:45.580 --> 00:23:48.040
Now to get from the Pepper
thread to the render process,

00:23:48.040 --> 00:23:50.830
though, we actually create
an RPC buffer.

00:23:50.830 --> 00:23:53.980
Now what happens is the Pepper
thread will push commands into

00:23:53.980 --> 00:23:55.010
the RPC buffer.

00:23:55.010 --> 00:23:57.470
And then that buffer will be
flushed at some time later to

00:23:57.470 --> 00:23:58.550
the render process.

00:23:58.550 --> 00:24:01.790
This basically creates about a
frame of latency between a

00:24:01.790 --> 00:24:06.180
producer-consumer FIFO that
you need to be aware of.

00:24:06.180 --> 00:24:08.530
What happens with this
producer-consumer FIFO,

00:24:08.530 --> 00:24:10.710
though, is that your RPC
buffer, sooner or

00:24:10.710 --> 00:24:13.190
later, will get full.

00:24:13.190 --> 00:24:14.500
So what happens is you
draw an object.

00:24:14.500 --> 00:24:15.910
You update your vertex buffer.

00:24:15.910 --> 00:24:18.320
You go to draw an object again,
and the buffer's full.

00:24:18.320 --> 00:24:19.430
So then it stalls.

00:24:19.430 --> 00:24:22.920
What happens here is you hit
something called a flush sink

00:24:22.920 --> 00:24:26.720
or sink flush, depending on
which documentation you get.

00:24:26.720 --> 00:24:30.030
What happens here is that the
process, even though you're

00:24:30.030 --> 00:24:32.610
not done with your frame,
will actually halt.

00:24:32.610 --> 00:24:33.760
And it will say, hey,
we're done here.

00:24:33.760 --> 00:24:34.460
I'm full.

00:24:34.460 --> 00:24:36.330
And it will actually
issue a flush sink.

00:24:36.330 --> 00:24:39.060
Now, what will happen here is
that it blocks the processing

00:24:39.060 --> 00:24:41.970
and calling thread until all
of the data inside that RPC

00:24:41.970 --> 00:24:44.950
buffer has been consumed
by the render process.

00:24:44.950 --> 00:24:46.980
What this means to you is
you'll start seeing

00:24:46.980 --> 00:24:49.110
30-millisecond spikes randomly
in your game,

00:24:49.110 --> 00:24:50.730
hitches in weird places.

00:24:50.730 --> 00:24:53.350
When you start debugging and
profiling down into it, you'll

00:24:53.350 --> 00:24:56.350
see random calls all of a sudden
taking 30 milliseconds.

00:24:56.350 --> 00:24:57.780
And to you this is going
to be maddening.

00:24:57.780 --> 00:25:00.550
You're going try to figure out
why this one draw object is

00:25:00.550 --> 00:25:01.410
taking 30 milliseconds.

00:25:01.410 --> 00:25:02.320
Is it the pixel shader?

00:25:02.320 --> 00:25:03.230
Is it the number of vertices?

00:25:03.230 --> 00:25:03.610
Yada, yada.

00:25:03.610 --> 00:25:06.030
You'll start moving the thing
around and noticing that it

00:25:06.030 --> 00:25:08.380
never happens on the same draw
call, that it happens sort of

00:25:08.380 --> 00:25:09.990
as a temporal problem.

00:25:09.990 --> 00:25:12.460
And what the real problem is
is that the RPC buffer is

00:25:12.460 --> 00:25:13.560
getting full.

00:25:13.560 --> 00:25:15.350
So make sure you note
that ahead of time.

00:25:15.350 --> 00:25:20.690
Now how you combat this is
kind of interesting.

00:25:20.690 --> 00:25:23.200
First off, swap buffers actually
kicks off a GL finish

00:25:23.200 --> 00:25:24.990
call on your behalf.

00:25:24.990 --> 00:25:27.660
GL finish will actually
force a flush to

00:25:27.660 --> 00:25:29.080
occur of the RPC buffer.

00:25:29.080 --> 00:25:30.230
So you fill in a frame.

00:25:30.230 --> 00:25:31.230
You hit swap buffers.

00:25:31.230 --> 00:25:32.430
And then you start filling
in the next frame.

00:25:32.430 --> 00:25:34.100
And that swap buffers will push
everything off to the

00:25:34.100 --> 00:25:35.760
render process on your behalf.

00:25:35.760 --> 00:25:40.290
The goal here is to implement
these flushes in strategic

00:25:40.290 --> 00:25:43.150
locations inside of your render
loop, so that you never

00:25:43.150 --> 00:25:44.350
hit a sink flush.

00:25:44.350 --> 00:25:46.780
So effectively what you're doing
is continuously pushing

00:25:46.780 --> 00:25:50.000
the data and forcing that RPC
buffer to flush, so that you

00:25:50.000 --> 00:25:52.500
never hit these 30-millisecond
waits.

00:25:52.500 --> 00:25:54.970
So you need to do is once
you draw some stuff,

00:25:54.970 --> 00:25:55.860
you insert a flush.

00:25:55.860 --> 00:25:57.940
You draw some more stuff, and
you insert another flush.

00:25:57.940 --> 00:26:01.280
Now the key here is that
figuring out where to insert

00:26:01.280 --> 00:26:03.040
these GL flush calls.

00:26:03.040 --> 00:26:04.060
That's the trick.

00:26:04.060 --> 00:26:06.020
To do that what you have to do
is you have to go back and

00:26:06.020 --> 00:26:07.110
analyze your frame.

00:26:07.110 --> 00:26:09.110
You got to take a look at where
the heavy spots are,

00:26:09.110 --> 00:26:11.450
where you're hitting your flush
sinks, and then figure

00:26:11.450 --> 00:26:14.730
out, hey, I need to insert a GL
flush manually before I hit

00:26:14.730 --> 00:26:16.800
that point to save me
30 milliseconds.

00:26:16.800 --> 00:26:19.740
Basically, what you're trying to
do is keep that RPC buffer

00:26:19.740 --> 00:26:22.350
continuously moving to keep
your frames from getting

00:26:22.350 --> 00:26:25.080
stalled out.

00:26:25.080 --> 00:26:27.910
So once you understand how all
this works and how you're

00:26:27.910 --> 00:26:30.330
rendering, how the rendering
occurs, and how the rendering

00:26:30.330 --> 00:26:33.430
happens between the Chrome and
Native Client module in the

00:26:33.430 --> 00:26:36.160
rendering process, you need to
take a step back and take a

00:26:36.160 --> 00:26:39.290
view of the bigger picture,
which is 3D and the web.

00:26:39.290 --> 00:26:42.180
3D API's, as well documented,
can be malicious on the web.

00:26:42.180 --> 00:26:45.850
As much as we would like
to admit it, the web is

00:26:45.850 --> 00:26:46.970
homogeneous.

00:26:46.970 --> 00:26:49.730
But GPUs and hardware are not.

00:26:49.730 --> 00:26:50.670
You've got a different
machine.

00:26:50.670 --> 00:26:51.850
You've got a different
machine.

00:26:51.850 --> 00:26:54.840
Heck, my coffee cup has a
different GPU processing in it

00:26:54.840 --> 00:26:58.120
than any of you, which I think
this is a 9,800, but we'll get

00:26:58.120 --> 00:26:59.180
back to that later.

00:26:59.180 --> 00:27:03.270
So the problem here is that
because of the fact that some

00:27:03.270 --> 00:27:06.350
of these drivers can be
malicious, WebGL actually has

00:27:06.350 --> 00:27:08.540
a list of blacklisted
3D drivers.

00:27:08.540 --> 00:27:10.740
Most of the time if a driver
has a problem, we can say,

00:27:10.740 --> 00:27:11.840
hey, here's the problem.

00:27:11.840 --> 00:27:12.860
Submit it to the vendor.

00:27:12.860 --> 00:27:15.470
The vendor can fix it and
push out a patch to it.

00:27:15.470 --> 00:27:18.860
In the situations where this
doesn't occur, we effectively

00:27:18.860 --> 00:27:20.600
have to say we have to blacklist
the driver because

00:27:20.600 --> 00:27:22.720
this is a malicious piece of
software that can cause

00:27:22.720 --> 00:27:25.090
problems on the end user's
machine and expose them to

00:27:25.090 --> 00:27:26.570
potential security risks.

00:27:26.570 --> 00:27:29.220
And because of that, the user
can hit a web page, and we can

00:27:29.220 --> 00:27:31.000
say, hey, you're not allowed
to run WebGL.

00:27:31.000 --> 00:27:33.420
You're not allowed
to run OpenGL

00:27:33.420 --> 00:27:35.560
inside of Native Client.

00:27:35.560 --> 00:27:37.720
And to detect this, effectively
what happens is

00:27:37.720 --> 00:27:39.400
you fail to create a context.

00:27:39.400 --> 00:27:40.370
That's the basic thing.

00:27:40.370 --> 00:27:43.280
The first thing you do in any
OpenGL-style system is you

00:27:43.280 --> 00:27:44.430
create a GL context.

00:27:44.430 --> 00:27:46.960
When that fails, it means
one of two things.

00:27:46.960 --> 00:27:49.620
Either the user doesn't have the
proper hardware to run any

00:27:49.620 --> 00:27:50.810
WebGL or OpenGL.

00:27:50.810 --> 00:27:54.160
Or the user has a set of
blacklisted drivers.

00:27:54.160 --> 00:27:57.760
Your job is to detect this
and respond very early.

00:27:57.760 --> 00:28:00.410
Because I'll tell you, nothing
is more annoying than a user

00:28:00.410 --> 00:28:02.660
spending an hour and a half
trying to get your game to run

00:28:02.660 --> 00:28:05.090
and updating drivers and
updating Chrome and doing this

00:28:05.090 --> 00:28:08.150
and that to finally get down to
and realize the problem is

00:28:08.150 --> 00:28:10.360
they needed to go update a patch
or that they just can't

00:28:10.360 --> 00:28:11.410
do it in general.

00:28:11.410 --> 00:28:13.610
Make sure you update this early
and tell the users, so

00:28:13.610 --> 00:28:16.090
you can save them
all that time.

00:28:16.090 --> 00:28:17.590
To do this is is actually
really simple.

00:28:17.590 --> 00:28:19.420
Here's a little snippet of
code that you can use in

00:28:19.420 --> 00:28:20.190
JavaScript.

00:28:20.190 --> 00:28:22.820
So this is way before Native
Client even loads.

00:28:22.820 --> 00:28:24.140
So the user loads your page.

00:28:24.140 --> 00:28:26.260
You're going to execute this
snippet of JavaScript to

00:28:26.260 --> 00:28:29.730
determine whether or not the
user is blacklisted first. OK.

00:28:29.730 --> 00:28:32.300
Basically what you do is you try
to create a WebGL context.

00:28:32.300 --> 00:28:35.400
If that WebGL context fails,
you can alert the user

00:28:35.400 --> 00:28:37.780
immediately, immediately that
they either have blacklisted

00:28:37.780 --> 00:28:39.180
hardware, or they don't
have hardware

00:28:39.180 --> 00:28:40.500
sufficient to run this.

00:28:40.500 --> 00:28:43.700
If it passes, then you know the
user has a system that can

00:28:43.700 --> 00:28:45.480
run your game, your 3D game.

00:28:45.480 --> 00:28:47.010
And you can also do some
other cool stuff here.

00:28:47.010 --> 00:28:49.350
Since you have the context,
you can go ahead and test

00:28:49.350 --> 00:28:50.460
additional extensions.

00:28:50.460 --> 00:28:52.150
Like does the user have
occlusion calling?

00:28:52.150 --> 00:28:54.570
Or does the user have
the ability to run

00:28:54.570 --> 00:28:56.810
4096 by 4096 textures?

00:28:56.810 --> 00:28:59.340
You can do all this in
JavaScript before you start

00:28:59.340 --> 00:29:01.780
loading all of your NEXEs and
start transferring your binary

00:29:01.780 --> 00:29:02.540
data from the web.

00:29:02.540 --> 00:29:04.190
This is really cool to do.

00:29:04.190 --> 00:29:07.160
The link at the bottom here,
actually, links to a specific

00:29:07.160 --> 00:29:08.620
example of how to do all this.

00:29:08.620 --> 00:29:10.880
As well as you should take a
look at the load progress

00:29:10.880 --> 00:29:12.370
example in the SDK.

00:29:12.370 --> 00:29:14.920
It has this as well as a fleet
of other tasks that you should

00:29:14.920 --> 00:29:18.150
be doing, as well as detecting
download process and

00:29:18.150 --> 00:29:19.230
displaying that to your users.

00:29:19.230 --> 00:29:22.770
So make sure that that's part
of your best practices.

00:29:22.770 --> 00:29:23.660
Working in a browser.

00:29:23.660 --> 00:29:26.080
So you understand the
environment you're in.

00:29:26.080 --> 00:29:28.210
You understand the hitches and
the hurdles that you're going

00:29:28.210 --> 00:29:31.110
to have to jump for FileIO and
rendering and all the problems

00:29:31.110 --> 00:29:32.090
associated with that.

00:29:32.090 --> 00:29:34.100
So now let's talk about working
inside of a browser.

00:29:34.100 --> 00:29:36.650
So this has less to do with your
technology and your code

00:29:36.650 --> 00:29:37.920
and more to do with
the ecosystem that

00:29:37.920 --> 00:29:39.340
you're living in.

00:29:39.340 --> 00:29:41.890
So first off is NaCl
white listing.

00:29:41.890 --> 00:29:45.610
Native Client is not enabled
inside of Chrome until an

00:29:45.610 --> 00:29:47.740
action occurs.

00:29:47.740 --> 00:29:49.130
This is for a number
of reasons,

00:29:49.130 --> 00:29:50.810
predominately security.

00:29:50.810 --> 00:29:52.770
If there's an issue in Native
Client that we're not aware

00:29:52.770 --> 00:29:54.770
of, we don't want malicious code
just sitting around on

00:29:54.770 --> 00:29:55.520
the internet.

00:29:55.520 --> 00:29:58.640
We want some way to make sure
that random users are not at

00:29:58.640 --> 00:30:01.790
the mercy of a problem
that we find.

00:30:01.790 --> 00:30:03.220
So Native Client is not enabled

00:30:03.220 --> 00:30:03.920
until one of two things.

00:30:03.920 --> 00:30:06.910
First off, for developers, you
can turn on Native Client by a

00:30:06.910 --> 00:30:08.860
flag in the about flags page.

00:30:08.860 --> 00:30:11.290
So this will allow you, as a
developer, to get access to

00:30:11.290 --> 00:30:13.830
any Native Client content
that exists on the web.

00:30:13.830 --> 00:30:16.210
For users, though, you don't
want them setting a flag.

00:30:16.210 --> 00:30:17.970
Users have to go through
a different path.

00:30:17.970 --> 00:30:20.340
They actually install the game
from the Chrome web store.

00:30:20.340 --> 00:30:23.100
And what happens here is that
the Chrome web store will

00:30:23.100 --> 00:30:26.510
actually list the origin that
you've specified for your NaCl

00:30:26.510 --> 00:30:28.890
module, so basically where
it's resting on a server.

00:30:28.890 --> 00:30:32.410
So I've got a website,
mainroach.blogspot.com.

00:30:32.410 --> 00:30:34.960
And I host my Native
Client app there.

00:30:34.960 --> 00:30:37.240
When I create my Chrome Web
Store instance, I say that my

00:30:37.240 --> 00:30:39.390
Native Client application
will be hosted for

00:30:39.390 --> 00:30:42.110
mainroach.blogspot.com.

00:30:42.110 --> 00:30:44.820
When you install that, as
a user, that origin,

00:30:44.820 --> 00:30:47.600
mainroach.blogspot.com will
get listed inside of your

00:30:47.600 --> 00:30:49.500
preferences as a white
listed location.

00:30:49.500 --> 00:30:51.380
Hey, it's OK to serve
Native Client

00:30:51.380 --> 00:30:54.370
content from this location.

00:30:54.370 --> 00:30:57.220
And note that the NMF and
the NEXEs must be

00:30:57.220 --> 00:30:58.380
loaded from that location.

00:30:58.380 --> 00:31:01.160
You can put zip data in
different places and aug files

00:31:01.160 --> 00:31:03.200
and JavaScript all on
a content network,

00:31:03.200 --> 00:31:04.100
wherever you want them.

00:31:04.100 --> 00:31:07.190
But the NEXEs and the NMFs
must exist from that

00:31:07.190 --> 00:31:10.110
white-listed origin.

00:31:10.110 --> 00:31:11.870
So once you've done that,
you have a pretty

00:31:11.870 --> 00:31:13.240
easy way to test this.

00:31:13.240 --> 00:31:15.815
So you can actually determine
beforehand whether or not the

00:31:15.815 --> 00:31:17.700
user actually has Native
Client enabled or

00:31:17.700 --> 00:31:19.020
available to install.

00:31:19.020 --> 00:31:20.845
So first off, you need to detect
whether or not the user

00:31:20.845 --> 00:31:21.660
is running Chrome.

00:31:21.660 --> 00:31:25.740
As of today, much to my dismay,
Chrome is the only one

00:31:25.740 --> 00:31:27.920
that uses and installs
Native Client.

00:31:27.920 --> 00:31:31.480
So first off, to determine if a
user can run Native Client,

00:31:31.480 --> 00:31:33.510
you need to detect if they're
using Chrome.

00:31:33.510 --> 00:31:37.940
Secondly the Chrome web store
has a really cool API called

00:31:37.940 --> 00:31:40.630
window.chrome.app.isinstalled.

00:31:40.630 --> 00:31:44.210
And you can define in this
whether or not the application

00:31:44.210 --> 00:31:45.940
defined on this page has
been installed from

00:31:45.940 --> 00:31:47.010
the Chrome web store.

00:31:47.010 --> 00:31:49.910
Now because an end user has
to install a Native Client

00:31:49.910 --> 00:31:52.470
application from the Chrome web
store, this is effectively

00:31:52.470 --> 00:31:54.510
your test to determine if
the user can run it.

00:31:54.510 --> 00:31:58.090
So if some user randomly browses
to your web page that

00:31:58.090 --> 00:32:00.660
doesn't have Native Client
installed or hasn't installed

00:32:00.660 --> 00:32:03.620
it from the web store, you can
detect it here and direct them

00:32:03.620 --> 00:32:04.580
to install it.

00:32:04.580 --> 00:32:07.420
You can also use something
called Inline Install, which

00:32:07.420 --> 00:32:09.320
is a great little nifty feature
from the Chrome web

00:32:09.320 --> 00:32:10.210
store, too.

00:32:10.210 --> 00:32:11.990
But the important thing here
is that you need to detect

00:32:11.990 --> 00:32:13.970
this and tell the user because,
otherwise, they're

00:32:13.970 --> 00:32:15.060
going to browse to
your website.

00:32:15.060 --> 00:32:17.020
And then they'll get a plug-in
request. And they're going to

00:32:17.020 --> 00:32:18.030
be like, hey, what's this?

00:32:18.030 --> 00:32:18.620
This is crummy.

00:32:18.620 --> 00:32:21.040
I'm going to give you zero star
reviews, and send you

00:32:21.040 --> 00:32:22.500
pictures that you don't
want to see.

00:32:22.500 --> 00:32:24.450
Definitely click the link at
the bottom of this slide.

00:32:24.450 --> 00:32:26.620
And also check out the load
progress example in the SDK

00:32:26.620 --> 00:32:28.770
for more on that.

00:32:28.770 --> 00:32:31.900
Now for developers, it's worth
pointing out that the Chrome

00:32:31.900 --> 00:32:35.220
caching mechanism is
both aggressive,

00:32:35.220 --> 00:32:37.500
amazing, and magical.

00:32:37.500 --> 00:32:40.270
How well it caches data and
how aggressive it is at

00:32:40.270 --> 00:32:42.260
keeping it around to make sure
that you're always hitting the

00:32:42.260 --> 00:32:44.410
cache as opposed to going
to the web is

00:32:44.410 --> 00:32:45.890
really a thing of beauty.

00:32:45.890 --> 00:32:49.820
The problem is for those of us
game developers who do test,

00:32:49.820 --> 00:32:52.620
launch, and iterate patterns,
this is a problem.

00:32:52.620 --> 00:32:55.780
Because as I change some code,
deploy it to Chrome, and then

00:32:55.780 --> 00:32:58.580
iterate on that content, I
want the latest version.

00:32:58.580 --> 00:33:00.020
I don't want the
cached version.

00:33:00.020 --> 00:33:03.310
To get around this, because
Chrome will bite you in this

00:33:03.310 --> 00:33:06.170
matter, you can actually go
to the developer tools and

00:33:06.170 --> 00:33:07.500
actually turn off caching.

00:33:07.500 --> 00:33:09.840
You can disable caching, so that
Chrome will always try to

00:33:09.840 --> 00:33:13.940
fetch the most recent version
and won't ever try to grab the

00:33:13.940 --> 00:33:14.660
data from the cache.

00:33:14.660 --> 00:33:16.500
Now, it's worth pointing out
that you probably don't want

00:33:16.500 --> 00:33:18.180
to do this on the version of
Chrome that you're running

00:33:18.180 --> 00:33:20.087
every day because otherwise your
browser will just slow

00:33:20.087 --> 00:33:21.280
down in general.

00:33:21.280 --> 00:33:23.190
But make sure that in your
developer version of Chrome

00:33:23.190 --> 00:33:26.380
that you're doing
it like this.

00:33:26.380 --> 00:33:28.360
Now also while you're developing
in Chrome, there's

00:33:28.360 --> 00:33:32.260
a whole fleet of tools that
will help you in your

00:33:32.260 --> 00:33:32.940
development.

00:33:32.940 --> 00:33:34.600
And these are called the
Chrome developer tools.

00:33:34.600 --> 00:33:37.200
You can click the link to the
more expansive declaration.

00:33:37.200 --> 00:33:39.910
But effectively, you can click
on the wrench, go down to

00:33:39.910 --> 00:33:41.860
tools, and go down to
developer tools.

00:33:41.860 --> 00:33:43.840
And this will launch a small
little bar at the bottom of

00:33:43.840 --> 00:33:45.810
your window that has a number
of options here--

00:33:45.810 --> 00:33:48.090
elements, resources, network
views, et cetera.

00:33:48.090 --> 00:33:49.830
One of the cool things about
this is that it actually

00:33:49.830 --> 00:33:51.750
provides a networking view.

00:33:51.750 --> 00:33:54.960
The networking view actually
lists all of the asset

00:33:54.960 --> 00:33:57.880
requests that your module has
made through Chrome over the

00:33:57.880 --> 00:33:59.390
lifetime of its application.

00:33:59.390 --> 00:34:02.470
So you can actually see, hey,
am I loading my zip file.

00:34:02.470 --> 00:34:03.770
Am I loading my audio data?

00:34:03.770 --> 00:34:05.780
How long does it take
to fetch that?

00:34:05.780 --> 00:34:07.790
Can I change anything
to make that faster?

00:34:07.790 --> 00:34:09.929
Can I bundle things up
to make that easier?

00:34:09.929 --> 00:34:13.070
These are sort of quintessential
tools that you

00:34:13.070 --> 00:34:15.159
need to be using, if you're
starting to develop inside of

00:34:15.159 --> 00:34:17.620
Chrome, especially the console
tab, which will tell you a lot

00:34:17.620 --> 00:34:19.780
of errors the Native Client
spits out that you may not be

00:34:19.780 --> 00:34:22.570
able to catch in
other fashions.

00:34:22.570 --> 00:34:25.260
Another amazing tool
is About Tracing.

00:34:25.260 --> 00:34:27.050
So if you open up Chrome, and
you create a new tab, and you

00:34:27.050 --> 00:34:31.906
type in the address bar About
Tracing, it will take you to

00:34:31.906 --> 00:34:34.889
this great API here, which
effectively is an inline

00:34:34.889 --> 00:34:37.940
profiler view of Chrome.

00:34:37.940 --> 00:34:41.030
So it actually shows you what
thread is running and what

00:34:41.030 --> 00:34:42.560
blocks of time is
running there.

00:34:42.560 --> 00:34:45.520
And it allows you to drill down
to actually get the name

00:34:45.520 --> 00:34:47.679
of the function being called.

00:34:47.679 --> 00:34:50.790
The best part about this is you
can actually issue data

00:34:50.790 --> 00:34:53.929
into About Tracing from
JavaScript or, subsequently,

00:34:53.929 --> 00:34:54.760
Native Client.

00:34:54.760 --> 00:34:57.660
And the even cooler thing about
this is see that little

00:34:57.660 --> 00:34:59.530
Load button over there?

00:34:59.530 --> 00:35:01.660
You can write out an
inline profile.

00:35:01.660 --> 00:35:04.280
So for those of you who have
inline profilers that already

00:35:04.280 --> 00:35:07.610
exist in your game, you can
modify it to output adjacent

00:35:07.610 --> 00:35:12.130
file that matches what this tool
uses, and use Chrome to

00:35:12.130 --> 00:35:14.450
do all of the profiling
in your game.

00:35:14.450 --> 00:35:16.180
It's an entire tool that allows
you to get all this

00:35:16.180 --> 00:35:18.530
progress and availability
to you free of charge.

00:35:18.530 --> 00:35:19.850
You don't have to
write the UI.

00:35:19.850 --> 00:35:20.520
You don't have to do that.

00:35:20.520 --> 00:35:22.230
We got a guy dedicated
to writing this.

00:35:22.230 --> 00:35:22.860
Use this tool.

00:35:22.860 --> 00:35:25.130
It's amazing to see.

00:35:25.130 --> 00:35:25.740
Google Stack.

00:35:25.740 --> 00:35:28.670
So now we've talked about what
the ecosystem is and all this

00:35:28.670 --> 00:35:29.020
other stuff.

00:35:29.020 --> 00:35:30.850
So let's talk about what
Google can do to

00:35:30.850 --> 00:35:31.980
help you with this.

00:35:31.980 --> 00:35:33.800
So you've got your game.

00:35:33.800 --> 00:35:36.300
You can serve your content, your
database information, off

00:35:36.300 --> 00:35:37.270
of Google App Engine.

00:35:37.270 --> 00:35:40.770
So this is basically your
database handling and your

00:35:40.770 --> 00:35:42.680
asset distribution.

00:35:42.680 --> 00:35:44.710
We have the Chrome web store
that we've already talked

00:35:44.710 --> 00:35:46.130
about and touched on,
which handles

00:35:46.130 --> 00:35:47.680
distribution and discovery.

00:35:47.680 --> 00:35:49.500
You also need to install your
Native Client apps from there

00:35:49.500 --> 00:35:50.560
to white list them.

00:35:50.560 --> 00:35:53.130
We've got Google Wallet, which
helps you monetize through

00:35:53.130 --> 00:35:55.890
in-app payments and everything
else along those lines.

00:35:55.890 --> 00:35:57.530
Once you've got all that, you're
eventually going to

00:35:57.530 --> 00:35:59.470
want some sort of social graph,
so that people can

00:35:59.470 --> 00:36:01.440
detect and move between
friends and submit

00:36:01.440 --> 00:36:01.870
information.

00:36:01.870 --> 00:36:04.820
We've got Google+ And then,
finally, we've got Google

00:36:04.820 --> 00:36:07.780
Analytics, which is an amazingly
powerful tool that

00:36:07.780 --> 00:36:10.180
allows you to detect what your
users are doing, how they're

00:36:10.180 --> 00:36:13.030
doing it, and kick off
events to match that.

00:36:13.030 --> 00:36:16.130
Now definitely check out my
other talk today on best

00:36:16.130 --> 00:36:19.100
practices in developing a web
application to do a deep dive

00:36:19.100 --> 00:36:22.020
on the way to properly use
these for your web game.

00:36:22.020 --> 00:36:23.110
Check it out, and
leave comments.

00:36:23.110 --> 00:36:25.040
I highly appreciate it.

00:36:25.040 --> 00:36:26.050
That's all for me.

00:36:26.050 --> 00:36:28.040
Make sure you check out
gonacl.com for the best

00:36:28.040 --> 00:36:29.140
information available.

00:36:29.140 --> 00:36:32.270
And then you can find me on all
of these different places,

00:36:32.270 --> 00:36:34.320
especially
mainroach.blogspot.com.

00:36:34.320 --> 00:36:35.540
So, hey, thank you
for your time.

00:36:35.540 --> 00:36:36.550
Appreciate your comments.

00:36:36.550 --> 00:36:37.290
Drop me a line.

00:36:37.290 --> 00:36:38.150
I'd love to hear from you.

00:36:38.150 --> 00:36:39.400
Thank you.

