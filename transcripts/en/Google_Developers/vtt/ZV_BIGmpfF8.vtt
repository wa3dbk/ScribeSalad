WEBVTT
Kind: captions
Language: en

00:00:05.400 --> 00:00:08.290
MALE SPEAKER 1: Shanghai GDG
is a very interesting

00:00:08.290 --> 00:00:09.160
developer community.

00:00:09.160 --> 00:00:10.000
FEMALE SPEAKER 1: I'm
glad somebody

00:00:10.000 --> 00:00:11.080
has asked this question.

00:00:11.080 --> 00:00:13.490
MALE SPEAKER 2: This is where
the magic happens.

00:00:13.490 --> 00:00:15.300
FEMALE SPEAKER 2: This is
primarily a question and

00:00:15.300 --> 00:00:15.520
answer show.

00:00:15.520 --> 00:00:16.770
So if any of you out there would
like to ask questions--

00:00:21.730 --> 00:00:23.490
PETER LUBBERS: Hello, and
welcome to the Chrome

00:00:23.490 --> 00:00:26.010
Developer Channel on Google
Developer Live.

00:00:26.010 --> 00:00:27.360
Really excited to
be here today.

00:00:27.360 --> 00:00:30.680
In the studio, we
have Jan Linden.

00:00:30.680 --> 00:00:33.960
And on air from Seattle,
we have Chris Wilson.

00:00:33.960 --> 00:00:37.930
I'm Peter Lubbers, the program
manager in the Chrome

00:00:37.930 --> 00:00:40.100
Developer Relations team.

00:00:40.100 --> 00:00:41.910
Jan, can you tell us a little
bit about what you do at

00:00:41.910 --> 00:00:43.610
Google before we get started?

00:00:43.610 --> 00:00:44.200
JAN LINDEN: Absolutely.

00:00:44.200 --> 00:00:46.170
So I'm on the Chrome team.

00:00:46.170 --> 00:00:50.790
I am a product manager that
focuses on everything audio in

00:00:50.790 --> 00:00:52.540
Chrome, which is really
exciting.

00:00:52.540 --> 00:00:54.710
Because there's happening a
lot in this area, and in

00:00:54.710 --> 00:00:57.270
particular, the Web Audio API
that we're talked about today

00:00:57.270 --> 00:01:01.300
is really bringing the web to
a new level that we haven't

00:01:01.300 --> 00:01:04.230
seen before.

00:01:04.230 --> 00:01:05.160
PETER LUBBERS: Thanks.

00:01:05.160 --> 00:01:08.780
And coming to us from Seattle,
Chris Wilson.

00:01:08.780 --> 00:01:10.420
Chris, can you tell us a little
bit about what you do

00:01:10.420 --> 00:01:13.280
at Google, and how you got
involved with web audio?

00:01:13.280 --> 00:01:14.050
CHRIS WILSON: Sure, Peter.

00:01:14.050 --> 00:01:17.260
So I'm on the Chrome Developer
Relations team.

00:01:17.260 --> 00:01:19.760
In short, that means I get to
play with all the neat stuff

00:01:19.760 --> 00:01:24.110
that Jan and his team put
together and build some neat

00:01:24.110 --> 00:01:27.020
demos, come up with different
ways of using it, push

00:01:27.020 --> 00:01:28.330
feedback back to him.

00:01:28.330 --> 00:01:31.680
And more than anything, work
with other developers on what

00:01:31.680 --> 00:01:34.550
they want to build and what they
want to get out of the

00:01:34.550 --> 00:01:38.090
API and other APIs as
well, of course.

00:01:38.090 --> 00:01:42.340
So that's kind of what I
do on a daily basis.

00:01:42.340 --> 00:01:45.070
As for how I got into web
audio, it was really--

00:01:45.070 --> 00:01:49.100
I got really interested when I
started seeing the ability to

00:01:49.100 --> 00:01:52.680
build software synthesizers
and processing units and

00:01:52.680 --> 00:01:53.725
things like that.

00:01:53.725 --> 00:01:56.260
It had been something I'd
started getting very

00:01:56.260 --> 00:01:56.910
interested in.

00:01:56.910 --> 00:02:01.430
Just because in the last decade
or so, all of this neat

00:02:01.430 --> 00:02:05.730
hardware that I grew up with
really as a keyboard player,

00:02:05.730 --> 00:02:08.660
suddenly you could actually
replicate it all in software

00:02:08.660 --> 00:02:10.139
relatively easily.

00:02:10.139 --> 00:02:14.440
And the Web Audio API letting
you do that in an even easier

00:02:14.440 --> 00:02:17.930
software way was really
exciting to me.

00:02:17.930 --> 00:02:18.410
PETER LUBBERS: Excellent.

00:02:18.410 --> 00:02:18.750
Excellent.

00:02:18.750 --> 00:02:22.830
Well, and full disclosure, I
don't know all that much about

00:02:22.830 --> 00:02:25.920
Web Audio myself, but I got to
carry Chris's speakers at

00:02:25.920 --> 00:02:30.320
Google I/O. And my youngest
son is an aspiring DJ.

00:02:30.320 --> 00:02:31.570
CHRIS WILSON: Everybody
needs roadies.

00:02:35.370 --> 00:02:36.230
PETER LUBBERS: Excellent.

00:02:36.230 --> 00:02:36.560
All right.

00:02:36.560 --> 00:02:38.550
So a quick agenda--

00:02:38.550 --> 00:02:39.770
so we're going to talk--

00:02:39.770 --> 00:02:45.100
and I mentioned this is the
first of a two-part series.

00:02:45.100 --> 00:02:49.880
In the first one, we'll talk
about mostly an introductory

00:02:49.880 --> 00:02:53.630
session about what Web Audio is,
how you can use it in your

00:02:53.630 --> 00:02:55.120
applications.

00:02:55.120 --> 00:02:58.900
And in the second one, which
will be in a few weeks-- we'll

00:02:58.900 --> 00:03:02.930
announce it on our
Google+ page--

00:03:02.930 --> 00:03:06.870
we'll talk more about how you
can use Web Audio in games.

00:03:06.870 --> 00:03:08.970
Chris is going to show a demo.

00:03:08.970 --> 00:03:11.750
That demo will be available on
GitHub, so for sure check it

00:03:11.750 --> 00:03:13.430
out after the event.

00:03:13.430 --> 00:03:16.200
So without further ado, Chris,
do you want to start off

00:03:16.200 --> 00:03:17.680
talking about Web Audio?

00:03:17.680 --> 00:03:18.840
CHRIS WILSON: Sure.

00:03:18.840 --> 00:03:23.190
So I gave a talk at Google
I/O on the Web Audio API.

00:03:23.190 --> 00:03:25.800
And I wanted to run through just
a couple of the slides

00:03:25.800 --> 00:03:30.110
from that because it sort of
helps capture, for me, what

00:03:30.110 --> 00:03:31.970
the Web Audio API is.

00:03:31.970 --> 00:03:36.610
I want to show off probably two
of the demos that I built

00:03:36.610 --> 00:03:43.180
for Google I/O. And then we'll
open it up to the floor from

00:03:43.180 --> 00:03:44.250
there, I think.

00:03:44.250 --> 00:03:47.360
But I do recommend, if you want
more detail about how Web

00:03:47.360 --> 00:03:50.610
Audio is put together, go watch
the YouTube video of the

00:03:50.610 --> 00:03:52.910
talk that I gave or run
through the slides.

00:03:52.910 --> 00:03:54.430
They're all publicly
available.

00:03:54.430 --> 00:03:57.810
And like you said, all the demos
that I have are actually

00:03:57.810 --> 00:03:59.720
up on GitHub and posted today.

00:03:59.720 --> 00:04:00.060
PETER LUBBERS: Right.

00:04:00.060 --> 00:04:03.860
Actually, just before you dive
into it, Chris, the moderator

00:04:03.860 --> 00:04:08.580
link is linked on the Google
Developers Live page for this

00:04:08.580 --> 00:04:11.330
event, for those of you
that haven't seen it.

00:04:11.330 --> 00:04:13.400
Scroll down to the bottom
of the page.

00:04:13.400 --> 00:04:17.380
Currently, we have six questions
with 65 votes, so

00:04:17.380 --> 00:04:19.670
we'll take those afterwards.

00:04:19.670 --> 00:04:21.945
But you can still ask additional
questions.

00:04:21.945 --> 00:04:22.530
All right.

00:04:22.530 --> 00:04:24.250
Over to you.

00:04:24.250 --> 00:04:30.550
CHRIS WILSON: OK, so let me flip
to my slide deck here.

00:04:30.550 --> 00:04:34.950
So the first question that
always comes up when I try to

00:04:34.950 --> 00:04:38.380
describe the Web Audio API to
people is, why do we even need

00:04:38.380 --> 00:04:39.940
another audio API?

00:04:39.940 --> 00:04:44.420
We now have this great audio
element that we've had for a

00:04:44.420 --> 00:04:48.260
few years now, but even that
took a long time for us to get

00:04:48.260 --> 00:04:50.490
implemented across
all the browsers.

00:04:50.490 --> 00:04:54.370
Because prior to that, we had
proprietary bgsound stuff that

00:04:54.370 --> 00:04:57.290
wasn't really controllable
and wasn't a great

00:04:57.290 --> 00:04:59.210
way of doing audio.

00:04:59.210 --> 00:05:01.130
And the audio element
is great.

00:05:01.130 --> 00:05:04.590
I don't want anyone walking away
thinking that we want to

00:05:04.590 --> 00:05:06.630
move people away from
the audio tag.

00:05:06.630 --> 00:05:10.310
Because it actually is a really
easy way to wrap up

00:05:10.310 --> 00:05:13.520
these steps of loading,
decoding, and playing audio

00:05:13.520 --> 00:05:14.350
all into one.

00:05:14.350 --> 00:05:16.100
And you get a set of controls
right there.

00:05:16.100 --> 00:05:19.640
The user can click the Play
button, and it plays.

00:05:19.640 --> 00:05:21.620
It shows you where you are
in the sound file.

00:05:21.620 --> 00:05:24.520
You've got volume controls and
all that kind of stuff.

00:05:24.520 --> 00:05:26.190
And of course, you can hook
in and control those

00:05:26.190 --> 00:05:27.990
yourself, if you want.

00:05:27.990 --> 00:05:31.510
But the problem that we have
with that is that you don't

00:05:31.510 --> 00:05:33.910
really have this fine-grained
control ability.

00:05:33.910 --> 00:05:36.320
Like, you can scrub in the
audio and play from a

00:05:36.320 --> 00:05:39.210
particular place in
the audio file.

00:05:39.210 --> 00:05:44.360
But you don't have the
ability to do this

00:05:44.360 --> 00:05:45.760
very precise timing.

00:05:45.760 --> 00:05:48.990
Because it packages up this
loading, decoding, and playing

00:05:48.990 --> 00:05:50.230
step altogether.

00:05:50.230 --> 00:05:53.780
So when you hit the button to
play a sound, it doesn't

00:05:53.780 --> 00:05:56.770
necessarily play it right at
that millisecond, or sub

00:05:56.770 --> 00:05:59.470
millisecond, even more
interestingly.

00:05:59.470 --> 00:06:02.140
So Web Audio lets you do this
very precise timing.

00:06:02.140 --> 00:06:04.470
You can have lots of overlapping
sounds as well.

00:06:04.470 --> 00:06:06.620
[VIDEO GAME SHOOTING
NOISE WITH REVERB]

00:06:06.620 --> 00:06:08.380
CHRIS WILSON: And it's really
easy to set that

00:06:08.380 --> 00:06:11.050
up inside the API.

00:06:11.050 --> 00:06:14.560
But secondly, even more
interestingly, the Web Audio

00:06:14.560 --> 00:06:17.930
API provides an audio pipeline,
a routing system,

00:06:17.930 --> 00:06:20.660
and a bunch of effects and
filters, so that you can very

00:06:20.660 --> 00:06:22.990
easily do different things
with your audio.

00:06:22.990 --> 00:06:23.890
You can filter it.

00:06:23.890 --> 00:06:25.340
You can add reverb effects.

00:06:25.340 --> 00:06:27.720
You can add all kinds of
echo or delay effects.

00:06:27.720 --> 00:06:29.960
[SHOOTING NOISE WITH ECHO]

00:06:29.960 --> 00:06:32.540
CHRIS WILSON: And it's pretty
easy to set those up.

00:06:32.540 --> 00:06:35.760
Inside this deck, by the way,
all of these things are live

00:06:35.760 --> 00:06:36.650
HTML demos.

00:06:36.650 --> 00:06:39.660
So it's pretty easy to dig in
and look at what they say.

00:06:39.660 --> 00:06:42.080
Later in the deck-- which I'm
not going to go into--

00:06:42.080 --> 00:06:44.390
there's a ton of code in there,
so you can see how I'm

00:06:44.390 --> 00:06:47.450
setting up these effects.

00:06:47.450 --> 00:06:50.930
And then finally, the Web Audio
API has a bunch of hooks

00:06:50.930 --> 00:06:55.040
to visualize audio data and
manipulate it on the fly.

00:06:55.040 --> 00:06:59.340
So it's not just a static, hey,
you have an MP3 file.

00:06:59.340 --> 00:07:00.810
Hit Play and it'll
come out through

00:07:00.810 --> 00:07:02.080
somebody's speaker somewhere.

00:07:02.080 --> 00:07:06.330
You can actually do things like
analyze it on a frequency

00:07:06.330 --> 00:07:11.390
basis and get kind of the
standard graphic equalizer

00:07:11.390 --> 00:07:15.160
view of the audio.

00:07:15.160 --> 00:07:20.375
Now, on top of that,
there were really--

00:07:20.375 --> 00:07:22.210
oops, sorry.

00:07:22.210 --> 00:07:24.610
There we go.

00:07:24.610 --> 00:07:27.670
The API itself is actually
defined at

00:07:27.670 --> 00:07:28.950
a pretty high level.

00:07:28.950 --> 00:07:31.920
So it's really easy to do
basic things like--

00:07:31.920 --> 00:07:32.940
COMPUTER: Play sound now.

00:07:32.940 --> 00:07:34.400
CHRIS WILSON: --playing
a single sound.

00:07:34.400 --> 00:07:35.900
That's the code for
it right there.

00:07:35.900 --> 00:07:38.420
I just create a buffer source.

00:07:38.420 --> 00:07:40.920
I set it to the right buffer,
connect it to the speakers,

00:07:40.920 --> 00:07:42.570
and start playing it.

00:07:42.570 --> 00:07:45.030
And even doing effects
and filters--

00:07:45.030 --> 00:07:49.130
what I have in this code is
essentially exactly the code

00:07:49.130 --> 00:07:51.750
from that last slide
when I hit Fire.

00:07:51.750 --> 00:07:53.670
And it had an echo effect.

00:07:53.670 --> 00:07:57.330
You don't need to understand
low-level audio digital signal

00:07:57.330 --> 00:08:00.660
processing in order to
use these things.

00:08:00.660 --> 00:08:02.520
In fact, I'm not an
audio engineer.

00:08:02.520 --> 00:08:06.870
And if I had to go build a whole
bunch of matrices and

00:08:06.870 --> 00:08:12.530
build my own or even directly
use an FFT transform to get

00:08:12.530 --> 00:08:15.020
these audio effects to work,
I'm pretty sure I would go

00:08:15.020 --> 00:08:16.250
find something else
to play with.

00:08:16.250 --> 00:08:18.840
Because that just seems like
a lot of hard work.

00:08:18.840 --> 00:08:20.490
But at the same time, of course,
if you want to do

00:08:20.490 --> 00:08:25.360
that, there is a way to do
very low-level API custom

00:08:25.360 --> 00:08:27.470
audio processing directly
in JavaScript.

00:08:27.470 --> 00:08:29.080
You can sit there and
manipulate the bits

00:08:29.080 --> 00:08:30.570
individually if you want to.

00:08:33.480 --> 00:08:35.705
Now--

00:08:35.705 --> 00:08:37.130
come on--

00:08:37.130 --> 00:08:38.520
one of our big goals--

00:08:38.520 --> 00:08:45.510
and this never works well in
screen sharing, so I'd

00:08:45.510 --> 00:08:49.770
encourage you to go look at
this in the slide deck

00:08:49.770 --> 00:08:51.390
yourself on your own machine.

00:08:51.390 --> 00:08:53.990
But the biggest thing that we
were really trying to do was

00:08:53.990 --> 00:08:58.780
make audio and audio processing
independent of all

00:08:58.780 --> 00:09:00.210
the other stuff that's
going on.

00:09:00.210 --> 00:09:03.560
We push all of our native audio
processing off into a

00:09:03.560 --> 00:09:07.750
separate high-priority thread,
which means doing even complex

00:09:07.750 --> 00:09:11.560
audio shouldn't cause glitches
in the visuals.

00:09:11.560 --> 00:09:13.660
Like I said, I'm not going to
run through this demo here,

00:09:13.660 --> 00:09:15.790
just because in screen sharing,
it doesn't work

00:09:15.790 --> 00:09:19.160
particularly well.

00:09:19.160 --> 00:09:23.170
But I wanted to give a really
high-level view of some of the

00:09:23.170 --> 00:09:27.520
features that we needed to
supply for gaming purposes and

00:09:27.520 --> 00:09:29.540
some of the features we
needed to supply for

00:09:29.540 --> 00:09:31.180
more musical purposes.

00:09:31.180 --> 00:09:34.960
And then I'll show a quick demo
or two that I've built.

00:09:34.960 --> 00:09:38.380
So I already mentioned you need
very precise timing for

00:09:38.380 --> 00:09:39.980
many simultaneous sounds.

00:09:39.980 --> 00:09:42.920
Games typically have tons and
tons of effects going on at

00:09:42.920 --> 00:09:44.520
the same time.

00:09:44.520 --> 00:09:47.950
And the HTML audio element
doesn't really scale to having

00:09:47.950 --> 00:09:49.670
lots of sounds.

00:09:49.670 --> 00:09:50.870
Half a dozen is OK.

00:09:50.870 --> 00:09:55.430
But 25 or so-- it starts
getting kind of wonky.

00:09:55.430 --> 00:09:57.490
And of course, you need
very precise timing.

00:09:57.490 --> 00:10:01.130
When you hit Fire, you want
to hear the fire almost

00:10:01.130 --> 00:10:03.680
immediately.

00:10:03.680 --> 00:10:06.660
But we also need features like
3D spatialization, placing

00:10:06.660 --> 00:10:09.250
sounds in a sound field.

00:10:09.250 --> 00:10:10.010
Doppler shift--

00:10:10.010 --> 00:10:13.990
If you drive past a police
officer in a driving game, you

00:10:13.990 --> 00:10:16.050
want to hear the siren
change pitch.

00:10:16.050 --> 00:10:19.660
And doing things like automatic
distance attenuation

00:10:19.660 --> 00:10:23.740
and sound directionality, so you
can hear where a sound is

00:10:23.740 --> 00:10:24.920
in a virtual environment.

00:10:24.920 --> 00:10:28.260
And it sounds very realistic.

00:10:28.260 --> 00:10:31.200
You also need lots of
filtering effects to

00:10:31.200 --> 00:10:35.710
automatically make audio sound
like it's being blocked by a

00:10:35.710 --> 00:10:39.380
wall, or like it's coming over
a radio or a telephone.

00:10:39.380 --> 00:10:42.962
This is the same sound file
that I played before.

00:10:42.962 --> 00:10:44.270
COMPUTER: Play sound now.

00:10:44.270 --> 00:10:45.990
CHRIS WILSON: --but it sounds
like it's coming over a

00:10:45.990 --> 00:10:48.980
telephone, even if you have a
really high-quality audio

00:10:48.980 --> 00:10:52.060
connection, which we don't
right now, but.

00:10:52.060 --> 00:10:53.640
And then finally, of course,
you need acoustic

00:10:53.640 --> 00:10:54.400
environments.

00:10:54.400 --> 00:10:59.990
If you walk into a large room
and fire your BFG9000, it

00:10:59.990 --> 00:11:02.230
should sound different than if
you're in a tiny little closet

00:11:02.230 --> 00:11:03.480
and you fire it.

00:11:06.180 --> 00:11:09.500
And of course, for both gaming
and music, we need the ability

00:11:09.500 --> 00:11:12.580
to create kind of scheduled
sound events.

00:11:12.580 --> 00:11:15.660
We need to create sequences or
loops or things like that.

00:11:15.660 --> 00:11:17.470
But we also need to automate
things like

00:11:17.470 --> 00:11:18.720
fade-ins and fade-outs.

00:11:22.420 --> 00:11:25.800
Now, for music, there are a
few kind of basic sound

00:11:25.800 --> 00:11:29.370
elements that you need for
musical applications.

00:11:29.370 --> 00:11:31.790
You may or may not use them
in gaming applications.

00:11:31.790 --> 00:11:35.450
Sometimes games record all
their music or effects.

00:11:35.450 --> 00:11:36.730
And they're all sound buffers.

00:11:36.730 --> 00:11:38.810
Sometimes they actually do
want to create the sound

00:11:38.810 --> 00:11:40.790
effects using oscillators.

00:11:40.790 --> 00:11:44.180
So oscillators let you create
sine waves and sawtooth waves

00:11:44.180 --> 00:11:47.210
and things like that, and set
frequency and change the

00:11:47.210 --> 00:11:49.220
frequency and that
sort of thing.

00:11:49.220 --> 00:11:52.070
Music also uses a lot of
dynamics processing.

00:11:52.070 --> 00:11:57.040
So this is usually referred to
as compression and expansion.

00:11:57.040 --> 00:11:59.650
If you look at-- this is
actually a picture of one of

00:11:59.650 --> 00:12:02.150
the racks in my music
studio at home.

00:12:02.150 --> 00:12:05.160
And one of the units in this
is actually a hardware

00:12:05.160 --> 00:12:06.450
compressor.

00:12:06.450 --> 00:12:10.040
So a piece of hardware that
actually does this one

00:12:10.040 --> 00:12:13.390
particular processing.

00:12:13.390 --> 00:12:15.480
We also need to do things
like distortion effects.

00:12:15.480 --> 00:12:18.470
One of the other units there
is a guitar amp processor.

00:12:18.470 --> 00:12:21.230
And a lot of that is actually
just applying very carefully

00:12:21.230 --> 00:12:25.440
designed distortion
to a sound.

00:12:25.440 --> 00:12:27.380
And then as we mentioned before,
you need a lot of

00:12:27.380 --> 00:12:30.255
frequency and waveform analysis
kind of features.

00:12:32.900 --> 00:12:36.410
So the first demo that I wanted
to show is actually--

00:12:36.410 --> 00:12:40.410
this is the Web Audio playground
is what I ended up

00:12:40.410 --> 00:12:41.380
calling this.

00:12:41.380 --> 00:12:43.850
And this basically is just
a way for you to visually

00:12:43.850 --> 00:12:47.170
explore what you can do with
the Web Audio API.

00:12:47.170 --> 00:12:50.640
So I can do things like add an
audio buffer source, connect

00:12:50.640 --> 00:12:53.764
it to the speakers,
and hit Play.

00:12:53.764 --> 00:12:56.550
[BELL DINGS]

00:12:56.550 --> 00:12:57.260
CHRIS WILSON: And--

00:12:57.260 --> 00:12:58.510
whoops.

00:13:00.480 --> 00:13:02.590
And I can--

00:13:02.590 --> 00:13:02.880
hm.

00:13:02.880 --> 00:13:05.145
I can restart.

00:13:05.145 --> 00:13:10.740
I obviously missed one of my
embedded features there.

00:13:10.740 --> 00:13:14.670
I can create something.

00:13:14.670 --> 00:13:18.510
I can do a-- oh, let's show
one of our neat frequency

00:13:18.510 --> 00:13:23.340
analyzers and connect
this guy up.

00:13:23.340 --> 00:13:24.825
And let's loop it.

00:13:24.825 --> 00:13:27.050
[DRUM BEAT]

00:13:27.050 --> 00:13:28.120
CHRIS WILSON: And you can
see what it looks

00:13:28.120 --> 00:13:29.310
like in real time.

00:13:29.310 --> 00:13:36.395
I can also do things like add
a filter node in there.

00:13:39.560 --> 00:13:43.430
And just for kicks, let's toss
another frequency analyzer so

00:13:43.430 --> 00:13:46.010
we can see what it looks like.

00:13:46.010 --> 00:13:48.880
Sorry, this is running on kind
of a smaller screen than I

00:13:48.880 --> 00:13:50.130
usually play with this.

00:13:52.910 --> 00:13:57.500
But now that I've got this all
connected, I can hit Play--

00:13:57.500 --> 00:13:59.110
[DRUM BEAT CONTINUES]

00:13:59.110 --> 00:14:01.180
CHRIS WILSON: --and change the
parameters of my filter.

00:14:05.100 --> 00:14:10.650
And you can actually see what it
does in real time, as well

00:14:10.650 --> 00:14:11.900
as hear it.

00:14:18.370 --> 00:14:21.810
So you can get some neat kind of
musical effects, as well as

00:14:21.810 --> 00:14:24.560
the filters are the same thing
that I used to create that

00:14:24.560 --> 00:14:26.440
telephone filter before.

00:14:26.440 --> 00:14:29.200
So this is kind of just a way
to play around with all the

00:14:29.200 --> 00:14:31.880
different types of audio nodes
that are in the Web Audio API.

00:14:31.880 --> 00:14:35.640
So you can play with the delay
node, the compressor node,

00:14:35.640 --> 00:14:36.220
[? convolver ?]

00:14:36.220 --> 00:14:38.570
for doing reverb and
stuff like that.

00:14:38.570 --> 00:14:43.710
But I wanted to create a little
bit more interesting

00:14:43.710 --> 00:14:46.300
demo of this myself.

00:14:46.300 --> 00:14:48.960
So I created a vocoder.

00:14:48.960 --> 00:14:52.150
This is actually one of the
first things that I set out to

00:14:52.150 --> 00:14:56.370
see if I could actually build
this using Web Audio.

00:14:56.370 --> 00:14:59.710
And a vocoder is an interesting
process.

00:14:59.710 --> 00:15:00.950
It's been around for
a long time.

00:15:00.950 --> 00:15:03.620
It's basically the robot
voice effect.

00:15:03.620 --> 00:15:07.510
And what vocoding does is it
takes one sound file or one

00:15:07.510 --> 00:15:10.990
sound input, usually referred to
as the modulator, which is

00:15:10.990 --> 00:15:12.630
frequently somebody speaking.

00:15:12.630 --> 00:15:13.805
So it's something like this.

00:15:13.805 --> 00:15:14.130
[AUDIO PLAYBACK]

00:15:14.130 --> 00:15:16.470
-Four score and seven
years ago.

00:15:16.470 --> 00:15:17.320
[END AUDIO PLAYBACK]

00:15:17.320 --> 00:15:20.320
CHRIS WILSON: And it maps the
frequency characteristics,

00:15:20.320 --> 00:15:21.620
which you can see on
the screen here.

00:15:21.620 --> 00:15:25.390
It maps the frequency
characteristics over time.

00:15:25.390 --> 00:15:29.020
And it applies the frequency
envelopes to a different

00:15:29.020 --> 00:15:32.070
sound, called the carrier, which
is usually some kind of

00:15:32.070 --> 00:15:35.580
frequency-rich synthesized
sound, like this one.

00:15:35.580 --> 00:15:38.200
[BUZZING]

00:15:38.200 --> 00:15:42.130
And no, that's not an error or
a disconnected audio input.

00:15:42.130 --> 00:15:44.230
It actually does sound
like that.

00:15:44.230 --> 00:15:46.990
But when you map these
together-- when you take the

00:15:46.990 --> 00:15:50.850
input of the modulator and you
apply it onto the carrier

00:15:50.850 --> 00:15:52.910
signal, you get something
that sounds like a

00:15:52.910 --> 00:15:54.570
robotic voice, like this.

00:15:54.570 --> 00:15:54.996
[AUDIO PLAYBACK]

00:15:54.996 --> 00:15:58.695
-Four score and seven years ago,
our fathers brought forth

00:15:58.695 --> 00:16:01.140
on this continent,
a new nation--

00:16:01.140 --> 00:16:03.530
CHRIS WILSON: Now, the really
cool thing about this, to me,

00:16:03.530 --> 00:16:06.040
is this is all happening
in real time.

00:16:06.040 --> 00:16:09.400
The Web Audio API is actually
doing everything

00:16:09.400 --> 00:16:11.950
here in real time.

00:16:11.950 --> 00:16:17.000
In fact, I set up this big graph
of nodes and plugged

00:16:17.000 --> 00:16:18.310
them all together.

00:16:18.310 --> 00:16:21.160
And then the only thing that
my JavaScript code is doing

00:16:21.160 --> 00:16:24.210
while this is running is
doing those visuals.

00:16:24.210 --> 00:16:27.330
Showing you what's going on in
the frequency analysis by

00:16:27.330 --> 00:16:28.190
mapping it.

00:16:28.190 --> 00:16:30.760
This means that I can change
things in real time, too.

00:16:30.760 --> 00:16:33.710
So I can change the pitch
of the carrier signal.

00:16:33.710 --> 00:16:34.960
[PITCH OF ROBOT SPEECH
CHANGES]

00:16:42.250 --> 00:16:44.180
CHRIS WILSON: And I can
also add more noise

00:16:44.180 --> 00:16:45.130
to the signal, or--

00:16:45.130 --> 00:16:48.140
[SIGNAL GETS MORE DISTORTED]

00:16:48.140 --> 00:16:49.250
CHRIS WILSON: --do other
things like that.

00:16:49.250 --> 00:16:50.190
[END AUDIO PLAYBACK]

00:16:50.190 --> 00:16:53.910
CHRIS WILSON: So there's a lot
of dynamics to this whole

00:16:53.910 --> 00:16:55.990
thing, like everything is
happening in real time.

00:16:55.990 --> 00:16:59.610
And I've done a bunch of
tweaking work behind the

00:16:59.610 --> 00:17:01.410
scenes to set this process up.

00:17:01.410 --> 00:17:04.440
But once the process is going,
all I have to do is go in and

00:17:04.440 --> 00:17:08.450
change parameters on the Web
Audio API nodes to make new

00:17:08.450 --> 00:17:10.079
things happen.

00:17:10.079 --> 00:17:13.880
So this was the first demo
that I was building.

00:17:13.880 --> 00:17:15.800
And it was kind of one of these
journeys, because I

00:17:15.800 --> 00:17:18.829
spent a ton of time just digging
through and starting

00:17:18.829 --> 00:17:21.599
to understand more and more
what a vocoder does.

00:17:21.599 --> 00:17:24.030
I was very, very naive when
I started building this.

00:17:24.030 --> 00:17:28.720
And I think Chris Rogers, the
engineer on the project--

00:17:28.720 --> 00:17:30.290
I think he didn't want
to tell me that I was

00:17:30.290 --> 00:17:31.360
in way over my head.

00:17:31.360 --> 00:17:35.350
But he helped me kind of dig my
way out, and managed to get

00:17:35.350 --> 00:17:38.100
my head above water
eventually.

00:17:38.100 --> 00:17:40.110
So this was kind
of a cool demo.

00:17:40.110 --> 00:17:41.730
There are a bunch of things
that I'm really looking

00:17:41.730 --> 00:17:44.750
forward to building and
adding to this demo

00:17:44.750 --> 00:17:46.730
as well in the future.

00:17:46.730 --> 00:17:51.500
So I'm kind of excited to see
what other demos can get built

00:17:51.500 --> 00:17:53.080
from that space.

00:17:53.080 --> 00:17:56.880
And I think, as we mentioned
earlier, by the way, the code

00:17:56.880 --> 00:17:59.650
for this is available
on GitHub.

00:17:59.650 --> 00:18:04.190
In fact, if you just go
to github.com/cwilso--

00:18:04.190 --> 00:18:06.010
C-W-I-L-S-O--

00:18:06.010 --> 00:18:08.820
you'll find a bunch of different
audio demos that

00:18:08.820 --> 00:18:11.730
I've been building lately.

00:18:11.730 --> 00:18:14.250
And with that, I think
I'll bring it back.

00:18:14.250 --> 00:18:18.560
And we can maybe start looking
at some of the questions.

00:18:18.560 --> 00:18:19.690
PETER LUBBERS: Sure.

00:18:19.690 --> 00:18:20.700
Just a quick question.

00:18:20.700 --> 00:18:25.760
What were some of the main
issues you ran into?

00:18:25.760 --> 00:18:30.470
Or are there any specific tips
that you would want to share

00:18:30.470 --> 00:18:34.250
after building that
great demo?

00:18:34.250 --> 00:18:36.510
What are some of the highlights
of that, or some of

00:18:36.510 --> 00:18:38.250
the things you should
say, well, really,

00:18:38.250 --> 00:18:40.180
watch out for this?

00:18:40.180 --> 00:18:40.330
CHRIS WILSON: Yeah.

00:18:40.330 --> 00:18:44.940
The number one thing that I
would encourage people to do,

00:18:44.940 --> 00:18:48.650
if you're going to do more
than just very basic--

00:18:48.650 --> 00:18:51.750
I want to play very precisely
timed sounds.

00:18:51.750 --> 00:18:55.100
The number one thing I would say
is, figure out very early

00:18:55.100 --> 00:18:58.660
on, like, package up
a visual analyzer.

00:18:58.660 --> 00:19:02.600
Figure out how to use the
real-time analyzer node and be

00:19:02.600 --> 00:19:05.570
able to use that as kind of an
oscilloscope to see what's

00:19:05.570 --> 00:19:07.650
going on in your code.

00:19:07.650 --> 00:19:11.300
It helps so dramatically to be
able to see what the frequency

00:19:11.300 --> 00:19:13.300
analysis is over time.

00:19:13.300 --> 00:19:19.310
And during the course of me
having this Web Audio vocoder

00:19:19.310 --> 00:19:22.680
code that I was in the process
of building, I would have four

00:19:22.680 --> 00:19:25.780
or five frequency analyzers on
the screen so I could see what

00:19:25.780 --> 00:19:27.410
was happening between
each step.

00:19:27.410 --> 00:19:30.890
And I could tell, oh, wait, this
isn't actually affecting

00:19:30.890 --> 00:19:33.460
the sound in the way
that I want it to.

00:19:33.460 --> 00:19:38.490
Or my frequency bands aren't
really very well defined.

00:19:38.490 --> 00:19:41.550
I need to up the order of the
filters that I'm using, or

00:19:41.550 --> 00:19:43.240
something like that.

00:19:43.240 --> 00:19:48.100
And it was fantastically helpful
for that purpose.

00:19:48.100 --> 00:19:52.340
I think other than that, there
weren't any huge gotchas that

00:19:52.340 --> 00:19:55.950
I ran into early on.

00:19:55.950 --> 00:19:59.010
Mostly it turns out that
a vocoder is a

00:19:59.010 --> 00:20:00.800
very finicky beast.

00:20:00.800 --> 00:20:04.220
And you have to sit there and
tweak all of the volume levels

00:20:04.220 --> 00:20:06.500
and the gain levels throughout
the whole thing.

00:20:06.500 --> 00:20:09.490
And you have to very carefully
filter things at the

00:20:09.490 --> 00:20:12.160
appropriate times to make it
sound good, because it turns

00:20:12.160 --> 00:20:16.950
out it's not just a well-defined
process.

00:20:16.950 --> 00:20:19.480
It's actually kind of a
very musical effect.

00:20:19.480 --> 00:20:21.550
And you have to tune it
musically in order to make it

00:20:21.550 --> 00:20:23.650
sound good in that context.

00:20:23.650 --> 00:20:24.205
PETER LUBBERS: Cool.

00:20:24.205 --> 00:20:25.960
Yeah, I really liked what
you did with the

00:20:25.960 --> 00:20:27.480
visualizations of it.

00:20:27.480 --> 00:20:30.280
Did you use Canvas
for that or--

00:20:30.280 --> 00:20:34.670
CHRIS WILSON: So that one,
actually, I shamelessly stole

00:20:34.670 --> 00:20:36.570
straight from Chris Rogers.

00:20:36.570 --> 00:20:40.280
He had built a visualizer,
I think fairly

00:20:40.280 --> 00:20:42.980
early on in Web Audio.

00:20:42.980 --> 00:20:46.290
And it uses WebGL to draw
the whole 3D mapping and

00:20:46.290 --> 00:20:48.310
everything.

00:20:48.310 --> 00:20:51.800
And the great thing about that
one, though, is it actually

00:20:51.800 --> 00:20:53.840
tracks it over time,
so you can see.

00:20:53.840 --> 00:20:58.240
The vocoder bars in the middle,
those are just a

00:20:58.240 --> 00:21:03.460
capture of what's going on in
my code or in the vocoder

00:21:03.460 --> 00:21:07.720
code, like tracking what the
frequency envelopes look like.

00:21:07.720 --> 00:21:10.740
But when I originally
built it, I built my

00:21:10.740 --> 00:21:11.980
own frequency analyzer.

00:21:11.980 --> 00:21:16.750
Because I wanted to see where
exactly are my frequency bands

00:21:16.750 --> 00:21:20.000
in relation to the frequency
analysis.

00:21:20.000 --> 00:21:25.630
I set up a frequency analyzer
that looked very much like the

00:21:25.630 --> 00:21:28.110
frequency analyzer that I played
with the drum sound

00:21:28.110 --> 00:21:29.720
during the slide deck.

00:21:29.720 --> 00:21:32.730
It looked like that, but
it drew vertical

00:21:32.730 --> 00:21:34.240
bars, so I could see--

00:21:34.240 --> 00:21:35.900
this is the center
of each of the

00:21:35.900 --> 00:21:37.805
frequency bands in my vocoder.

00:21:37.805 --> 00:21:40.600
And I could tell, wait a second,
this isn't lining up

00:21:40.600 --> 00:21:43.270
to the right place, or
things like that.

00:21:43.270 --> 00:21:44.120
It was super helpful.

00:21:44.120 --> 00:21:44.620
JAN LINDEN: Yeah.

00:21:44.620 --> 00:21:48.800
This was real exciting to see.

00:21:48.800 --> 00:21:51.090
Chris, I don't want to downplay
your abilities, but

00:21:51.090 --> 00:21:54.210
you're not exactly a signal
processing guy that knows

00:21:54.210 --> 00:21:56.420
exactly about all
these things.

00:21:56.420 --> 00:21:57.940
CHRIS WILSON: I am absolutely
not a signal processing guy.

00:21:57.940 --> 00:21:58.640
JAN LINDEN: And the fact
that you could build

00:21:58.640 --> 00:22:00.700
this is pretty amazing.

00:22:00.700 --> 00:22:03.870
So it shows the capabilities of
this, and how much of the

00:22:03.870 --> 00:22:06.860
hard stuff has been done
under the hood.

00:22:06.860 --> 00:22:11.230
And using, as you said, the
tools of the frequency

00:22:11.230 --> 00:22:14.670
analyzer to understand step by
step what you're doing makes

00:22:14.670 --> 00:22:17.940
it possible to then fiddle
around and figure it out

00:22:17.940 --> 00:22:21.920
without having to get into all
the details, and still come up

00:22:21.920 --> 00:22:23.790
with this excellent result.

00:22:23.790 --> 00:22:24.600
CHRIS WILSON: Yeah.

00:22:24.600 --> 00:22:28.370
I think in retrospect, the hard
part, and the parts where

00:22:28.370 --> 00:22:33.360
I spent the bulk of my time
building that demo, were not

00:22:33.360 --> 00:22:37.110
building the Web Audio graph
to handle the sound

00:22:37.110 --> 00:22:38.600
processing.

00:22:38.600 --> 00:22:41.510
The biggest thing that I spent a
lot of time in was tweaking.

00:22:41.510 --> 00:22:42.770
And there's actually--

00:22:42.770 --> 00:22:47.440
if you go into the developer
tools while it's running, you

00:22:47.440 --> 00:22:50.380
can actually find there's
a div with a

00:22:50.380 --> 00:22:51.990
huge number of sliders.

00:22:51.990 --> 00:22:55.030
I think it has about 20 sliders
still in it that were

00:22:55.030 --> 00:22:58.520
just letting me tweak gain
levels throughout the process

00:22:58.520 --> 00:22:59.530
of this thing.

00:22:59.530 --> 00:23:04.650
And if you do things like give
it a different sound file that

00:23:04.650 --> 00:23:07.770
isn't the same average volume
level, you may have to

00:23:07.770 --> 00:23:09.130
re-tweak some of those things.

00:23:09.130 --> 00:23:11.290
Because I didn't make
automatic volume

00:23:11.290 --> 00:23:13.170
detection in it.

00:23:13.170 --> 00:23:16.920
But really, it was that and
building a good-looking user

00:23:16.920 --> 00:23:19.720
experience that took the
bulk of the time.

00:23:19.720 --> 00:23:20.970
PETER LUBBERS: That's
excellent.

00:23:20.970 --> 00:23:23.270
You definitely succeeded
in that.

00:23:23.270 --> 00:23:23.800
Great.

00:23:23.800 --> 00:23:25.470
So let's take a couple
questions.

00:23:25.470 --> 00:23:30.100
So the first question on the
moderator is, will the API be

00:23:30.100 --> 00:23:32.880
cross-browser compatible out of
the box, or will we have to

00:23:32.880 --> 00:23:36.340
deal with vendor prefixes?

00:23:36.340 --> 00:23:38.100
JAN LINDEN: Well, we will.

00:23:38.100 --> 00:23:39.830
CHRIS WILSON: Always
a fun question.

00:23:39.830 --> 00:23:46.180
So out of the box is an
interesting point, because Web

00:23:46.180 --> 00:23:49.730
Audio has actually been in
Chrome for quite a while now.

00:23:49.730 --> 00:23:54.990
It's been shipping and
[? stable ?] for--

00:23:54.990 --> 00:23:56.030
before I was on the team.

00:23:56.030 --> 00:23:57.490
JAN LINDEN: Yeah,
Chrome 13 or 14.

00:23:57.490 --> 00:23:58.990
I can't remember, but
one of those.

00:23:58.990 --> 00:23:59.360
CHRIS WILSON: Yeah.

00:23:59.360 --> 00:24:00.190
Sounds about right.

00:24:00.190 --> 00:24:02.750
And it is WebKit prefixed.

00:24:02.750 --> 00:24:04.250
It is vendor prefixed today.

00:24:04.250 --> 00:24:10.120
Although it is vendor prefixed
at the point where you say, I

00:24:10.120 --> 00:24:11.580
want an audio context.

00:24:11.580 --> 00:24:13.570
Like, I want to use
the Web Audio API.

00:24:13.570 --> 00:24:15.770
Give me a handle to it.

00:24:15.770 --> 00:24:18.310
And from then on, you don't
have WebKit prefixes

00:24:18.310 --> 00:24:18.840
everywhere.

00:24:18.840 --> 00:24:22.720
So hopefully, we'll end up with
an API that is very easy

00:24:22.720 --> 00:24:26.660
to say, well, if you don't have
audio context, get WebKit

00:24:26.660 --> 00:24:27.500
audio context.

00:24:27.500 --> 00:24:30.890
And then most of it just
works after that.

00:24:30.890 --> 00:24:33.380
As far as other browsers
adopting it, we've spent a lot

00:24:33.380 --> 00:24:36.200
of time, and I think we've seen
a lot of movement in the

00:24:36.200 --> 00:24:40.770
last five to six months,
probably, from other vendors

00:24:40.770 --> 00:24:44.450
being very interested and
actively participating in the

00:24:44.450 --> 00:24:47.820
API on the working group.

00:24:47.820 --> 00:24:52.330
The Mozilla guys have been
involved in the Web Audio

00:24:52.330 --> 00:24:54.150
working group, I think
since the beginning,

00:24:54.150 --> 00:24:56.090
certainly for a long time.

00:24:56.090 --> 00:24:59.170
Opera has jumped in, and given
a lot of feedback on the API,

00:24:59.170 --> 00:25:00.060
which has been great.

00:25:00.060 --> 00:25:03.120
Microsoft team has been
looking at Web Audio.

00:25:03.120 --> 00:25:07.950
I feel like we're really pushing
very hard to move this

00:25:07.950 --> 00:25:11.020
to something that is
cross-vendor and

00:25:11.020 --> 00:25:13.610
cross-platform as well.

00:25:13.610 --> 00:25:20.820
And right now, actually, in
Safari 6 in beta, and in iOS 6

00:25:20.820 --> 00:25:23.620
Safari, we have support for
Web Audio, as well.

00:25:23.620 --> 00:25:25.350
Granted, it's still
built on WebKit.

00:25:25.350 --> 00:25:27.290
It's still WebKit
vendor prefixed.

00:25:27.290 --> 00:25:30.780
But we do have it on a different
platform and

00:25:30.780 --> 00:25:33.470
delivered from a different
vendor.

00:25:33.470 --> 00:25:34.910
PETER LUBBERS: Great.

00:25:34.910 --> 00:25:38.110
That question, by the
way, was from Ling.

00:25:38.110 --> 00:25:41.810
Another question that was voted
up quite a bit was a

00:25:41.810 --> 00:25:42.870
little bit about security.

00:25:42.870 --> 00:25:47.120
So the question was from tr67.

00:25:47.120 --> 00:25:49.200
What security measures need
to be taken in the

00:25:49.200 --> 00:25:50.700
future for Web Audio?

00:25:50.700 --> 00:25:53.660
Are audio popups a threat?

00:25:53.660 --> 00:25:56.950
And how would subsequent
blocking techniques affect us

00:25:56.950 --> 00:25:58.380
as developers?

00:25:58.380 --> 00:26:01.010
Sure, anyone can hit a Mute
button, but what if a browser

00:26:01.010 --> 00:26:02.470
is locked down completely?

00:26:02.470 --> 00:26:07.110
So, Jan, do you want to
take a stab at that?

00:26:07.110 --> 00:26:07.560
JAN LINDEN: Yeah.

00:26:07.560 --> 00:26:08.910
It's a very interesting
question.

00:26:08.910 --> 00:26:11.480
And actually, I'll start with
something that is not part of

00:26:11.480 --> 00:26:14.960
Web Audio API right now,
but something we are

00:26:14.960 --> 00:26:16.570
working hard on adding.

00:26:16.570 --> 00:26:20.450
And that's input audio, as
well, through another API

00:26:20.450 --> 00:26:24.710
called Get User Media,
which is right now

00:26:24.710 --> 00:26:26.640
available in Chrome.

00:26:26.640 --> 00:26:29.590
But they haven't been
hooked up yet.

00:26:29.590 --> 00:26:32.950
But that means that you can
take input audio and then

00:26:32.950 --> 00:26:37.010
process it, do an analysis, et
cetera, and directly either

00:26:37.010 --> 00:26:41.510
play it out or just do whatever
you want with it.

00:26:41.510 --> 00:26:44.150
And there, you definitely have
some interesting aspects of

00:26:44.150 --> 00:26:48.120
privacy and security,
which have been

00:26:48.120 --> 00:26:49.940
discussed and resolved.

00:26:49.940 --> 00:26:52.500
So we've been able
to ship that.

00:26:52.500 --> 00:26:57.470
But of course, then you have
to allow the microphone to

00:26:57.470 --> 00:26:58.590
record what you're doing.

00:26:58.590 --> 00:27:02.950
So there is a whole process
similar to getting location

00:27:02.950 --> 00:27:06.490
data, et cetera,
in other APIs.

00:27:06.490 --> 00:27:09.500
So that part has been
taken care of.

00:27:09.500 --> 00:27:12.300
It will, of course, always be
a little bit clumsy in the

00:27:12.300 --> 00:27:17.420
sense that the first time you go
to a domain, you will have

00:27:17.420 --> 00:27:18.040
to allow it.

00:27:18.040 --> 00:27:21.160
But then you can have always
allow for that one, if it's a

00:27:21.160 --> 00:27:23.710
secure HTTP.

00:27:23.710 --> 00:27:27.830
So that side is something that
I think people would be very

00:27:27.830 --> 00:27:33.510
worried about, but it
is taken care of.

00:27:33.510 --> 00:27:34.530
On the popups--

00:27:34.530 --> 00:27:37.490
maybe, Chris, you've thought
more about that?

00:27:37.490 --> 00:27:38.685
That's obviously--

00:27:38.685 --> 00:27:39.060
CHRIS WILSON: Yeah.

00:27:39.060 --> 00:27:43.740
I mean, I think for
output, it's a

00:27:43.740 --> 00:27:45.754
really interesting question.

00:27:45.754 --> 00:27:50.040
And I'm probably an interesting
person to

00:27:50.040 --> 00:27:50.640
have it asked of.

00:27:50.640 --> 00:27:55.110
Because despite being super
excited by the Web Audio API,

00:27:55.110 --> 00:27:56.560
I'm the guy who--

00:27:56.560 --> 00:27:59.850
my laptop is always muted.

00:27:59.850 --> 00:28:01.640
I don't want to be in the middle
of a meeting and have

00:28:01.640 --> 00:28:04.460
it start playing music or
something like that.

00:28:04.460 --> 00:28:08.750
But also, I just don't
particularly like going to

00:28:08.750 --> 00:28:11.660
websites and having
them play funky

00:28:11.660 --> 00:28:13.850
background music or whatever.

00:28:13.850 --> 00:28:19.590
So it's kind of a weird space
to be saying, hey, let's go

00:28:19.590 --> 00:28:22.840
build this audio stuff into
the web platform.

00:28:22.840 --> 00:28:27.890
I think that it is a
general concern.

00:28:27.890 --> 00:28:30.190
I don't think it's really a
denial of service, because you

00:28:30.190 --> 00:28:34.320
can always just hit the Mute
button on your machine.

00:28:34.320 --> 00:28:36.870
I don't think the browser would
be completely locked

00:28:36.870 --> 00:28:41.780
down in a situation where you
wouldn't want the user to have

00:28:41.780 --> 00:28:45.490
access to the Mute button, like
a library system or a

00:28:45.490 --> 00:28:48.600
kiosk system or something
like that.

00:28:48.600 --> 00:28:49.975
Those are always going
to be options

00:28:49.975 --> 00:28:52.470
unless it's simply disabled.

00:28:52.470 --> 00:28:56.650
So I think that it is an
interesting question to handle

00:28:56.650 --> 00:29:00.490
in the broader sense of what do
we do with audio elements

00:29:00.490 --> 00:29:02.680
and bgsound and stuff
like that.

00:29:02.680 --> 00:29:05.370
But I don't think it's
relevant just to

00:29:05.370 --> 00:29:08.920
Web Audio by itself.

00:29:08.920 --> 00:29:09.300
PETER LUBBERS: Cool.

00:29:09.300 --> 00:29:10.340
Yeah.

00:29:10.340 --> 00:29:12.340
That's definitely
a good question.

00:29:12.340 --> 00:29:16.400
So another question was from--

00:29:16.400 --> 00:29:17.210
let's see--

00:29:17.210 --> 00:29:18.460
maxw3st.

00:29:20.780 --> 00:29:25.040
What audio file formats
does the API handle?

00:29:25.040 --> 00:29:25.310
JAN LINDEN: Yeah.

00:29:25.310 --> 00:29:33.420
So in Chrome, we support AAC,
MP3, WAV files, and OGG.

00:29:33.420 --> 00:29:36.040
And then for other platforms,
that depends

00:29:36.040 --> 00:29:36.820
on what they support.

00:29:36.820 --> 00:29:41.200
But basically, what you will do
is you support the same as

00:29:41.200 --> 00:29:43.473
you do for the audio element.

00:29:46.350 --> 00:29:48.920
And that could obviously be
added more in the future.

00:29:48.920 --> 00:29:53.050
But these are, right now, the
ones that are the popular ones

00:29:53.050 --> 00:29:55.020
and the ones that we
want to support.

00:29:55.020 --> 00:29:57.430
But we are continuously looking
at if there are new

00:29:57.430 --> 00:30:02.440
ones we can add at a later
time, if there is enough

00:30:02.440 --> 00:30:06.260
reason for doing so.

00:30:06.260 --> 00:30:07.270
PETER LUBBERS: Another
question is

00:30:07.270 --> 00:30:09.460
from Tony-b from France.

00:30:09.460 --> 00:30:11.700
Multichannel support--

00:30:11.700 --> 00:30:15.640
how many, and what precision and
regularity for looping a

00:30:15.640 --> 00:30:19.060
small sound a few milliseconds
long is available?

00:30:21.600 --> 00:30:24.550
I think you dealt with
that extensively.

00:30:24.550 --> 00:30:24.900
CHRIS WILSON: Right.

00:30:24.900 --> 00:30:27.390
So multichannel support
is definitely--

00:30:27.390 --> 00:30:29.790
there's two versions
of multichannel.

00:30:29.790 --> 00:30:34.220
There's the can I get access
to stereo, or 5.1 surround

00:30:34.220 --> 00:30:35.830
sound, or things like that.

00:30:35.830 --> 00:30:39.620
Support for that is actually
built into the Web Audio API.

00:30:39.620 --> 00:30:44.870
One of the demos I did for IO
was a left-right stereo

00:30:44.870 --> 00:30:49.070
ping-pong delay, showing that
you could actually hook in and

00:30:49.070 --> 00:30:50.170
control that.

00:30:50.170 --> 00:30:56.320
There's also sort of the
multi-context support, like

00:30:56.320 --> 00:31:00.700
the idea that I want to have two
separate audio outputs on

00:31:00.700 --> 00:31:04.690
my computer, and be able to
control independently what

00:31:04.690 --> 00:31:06.220
goes to each one of them.

00:31:06.220 --> 00:31:11.160
A classic example of this for me
is one of the side projects

00:31:11.160 --> 00:31:14.450
that I'm working on
is building tools

00:31:14.450 --> 00:31:16.800
for doing disc jockeying.

00:31:16.800 --> 00:31:20.220
And DJs typically have one audio
output that's going to

00:31:20.220 --> 00:31:21.090
the main speakers.

00:31:21.090 --> 00:31:22.660
And then they have
their headphones.

00:31:22.660 --> 00:31:25.720
So you need to have two very
separate audio outputs,

00:31:25.720 --> 00:31:27.970
because they send different
things to

00:31:27.970 --> 00:31:29.000
those different speakers.

00:31:29.000 --> 00:31:31.630
Like, they have a button on
their deck that says, play

00:31:31.630 --> 00:31:34.130
this to my headphones, so they
can queue something up but not

00:31:34.130 --> 00:31:35.380
let everyone hear it.

00:31:35.380 --> 00:31:40.140
And I think that we need to have
that kind of capability.

00:31:40.140 --> 00:31:44.100
It is a concept that has been
considered, I think, from the

00:31:44.100 --> 00:31:47.350
very beginning of the API, but
we don't currently have

00:31:47.350 --> 00:31:50.670
support for it yet.

00:31:50.670 --> 00:31:58.150
As for the other side of that
question, what precision and

00:31:58.150 --> 00:32:02.140
regularity for looping small
sounds, you absolutely can do

00:32:02.140 --> 00:32:06.650
this essentially down
to the sample level.

00:32:06.650 --> 00:32:11.430
All of our durations
are in seconds.

00:32:11.430 --> 00:32:12.560
And they're floating
point numbers.

00:32:12.560 --> 00:32:15.450
So you can go in and say, I
want to loop this from the

00:32:15.450 --> 00:32:18.710
first sample to the last sample,
and it can only be--

00:32:18.710 --> 00:32:21.730
you can say, this is only
100 samples long.

00:32:21.730 --> 00:32:25.620
So 1/100 of whatever
the number of

00:32:25.620 --> 00:32:28.460
samples per second is.

00:32:28.460 --> 00:32:30.160
And I've actually done that.

00:32:30.160 --> 00:32:34.770
I used an extremely short sound
buffer to replicate--

00:32:34.770 --> 00:32:38.090
I think it was a sine wave,
before we got the oscillator

00:32:38.090 --> 00:32:39.470
up and running inside
the code.

00:32:39.470 --> 00:32:41.630
So it's very precise.

00:32:41.630 --> 00:32:46.965
And the precision for duration
is just as precise.

00:32:46.965 --> 00:32:49.200
PETER LUBBERS: Awesome.

00:32:49.200 --> 00:32:50.380
All right.

00:32:50.380 --> 00:32:52.970
One question I had as well,
and it was asked on the

00:32:52.970 --> 00:32:53.860
moderator--

00:32:53.860 --> 00:32:56.220
what are the options for
recording, archiving, and

00:32:56.220 --> 00:32:58.400
playing back audio
conversations?

00:32:58.400 --> 00:33:00.580
In fact, I was thinking
it would be great--

00:33:00.580 --> 00:33:03.470
I don't know if it's even
added to your demo.

00:33:03.470 --> 00:33:07.290
Once you've looped all these
things together, and you've

00:33:07.290 --> 00:33:10.110
created that sound that you
liked, is it even possible in

00:33:10.110 --> 00:33:10.800
your demo--

00:33:10.800 --> 00:33:12.340
the first demo you showed--

00:33:12.340 --> 00:33:16.250
to download or to save it?

00:33:16.250 --> 00:33:18.990
CHRIS WILSON: So today, in both
of those demos, you can't

00:33:18.990 --> 00:33:21.650
actually save the output
of it, [? trivially. ?]

00:33:21.650 --> 00:33:26.870
You can use a loopback audio
output and record it with

00:33:26.870 --> 00:33:30.450
different software, but
it's not built in.

00:33:30.450 --> 00:33:36.300
Today, I believe we don't have
any way natively to record it

00:33:36.300 --> 00:33:38.780
and encode it into one
of those formats--

00:33:38.780 --> 00:33:42.860
into OGG or WAV or MP3--

00:33:42.860 --> 00:33:45.830
but that's certainly something
we've discussed.

00:33:45.830 --> 00:33:48.880
You could actually build a
JavaScript audio node that

00:33:48.880 --> 00:33:52.460
captures data and stores that
in any form you want.

00:33:52.460 --> 00:33:54.920
It can store it as just an
audio buffer, which, of

00:33:54.920 --> 00:33:59.230
course, is trivial to store,
or write your own code to

00:33:59.230 --> 00:34:02.590
re-encode it as an mp3, or
whatever format you want.

00:34:02.590 --> 00:34:04.900
JAN LINDEN: So right now, that
would be the biggest problem.

00:34:04.900 --> 00:34:07.920
And doing an encoding can
be fairly complex.

00:34:07.920 --> 00:34:10.469
So JavaScript encoder--

00:34:10.469 --> 00:34:14.110
there are potentials to
do that, absolutely.

00:34:14.110 --> 00:34:17.610
The other way that is being
worked on, again, using the

00:34:17.610 --> 00:34:21.400
Get User Media API,
as I mentioned--

00:34:21.400 --> 00:34:26.239
that one will get a recording
function into it.

00:34:26.239 --> 00:34:27.150
It's a [? standardization ?]

00:34:27.150 --> 00:34:29.659
process right now to figure out
how, exactly, that should

00:34:29.659 --> 00:34:31.690
be done, but that's
also in the works.

00:34:31.690 --> 00:34:34.659
So then you can both record
directly what's coming in, but

00:34:34.659 --> 00:34:39.350
also feed what's the output from
Web Audio API into a Get

00:34:39.350 --> 00:34:42.420
User Media that can then
record or play out

00:34:42.420 --> 00:34:43.551
whatever you want.

00:34:43.551 --> 00:34:43.929
PETER LUBBERS: Yeah.

00:34:43.929 --> 00:34:46.000
And Get User Media, also
very important

00:34:46.000 --> 00:34:47.800
for WebRTC, of course.

00:34:47.800 --> 00:34:49.110
JAN LINDEN: Exactly.

00:34:49.110 --> 00:34:50.929
PETER LUBBERS: All
right, excellent.

00:34:50.929 --> 00:34:54.949
Another question from Gerwin
Sturm from Vienna.

00:34:54.949 --> 00:34:59.470
How does the Web Audio API
compare to the Audio Data API

00:34:59.470 --> 00:35:00.650
available in Firefox?

00:35:00.650 --> 00:35:03.040
Are there already libraries
to support both for

00:35:03.040 --> 00:35:04.350
cross-browser support?

00:35:04.350 --> 00:35:07.040
And will they be merged to one
standard in the long run?

00:35:07.040 --> 00:35:08.720
Who wants to take that?

00:35:08.720 --> 00:35:09.150
JAN LINDEN: Yeah.

00:35:09.150 --> 00:35:14.980
So basically, I think Mozilla
has moved on from that.

00:35:17.830 --> 00:35:22.500
The idea is that the Web Audio
API is the main API people are

00:35:22.500 --> 00:35:24.840
working on in the future.

00:35:24.840 --> 00:35:30.340
So that's where the focus
is on everybody's side.

00:35:30.340 --> 00:35:31.860
But there is still--

00:35:31.860 --> 00:35:36.440
for the Firefox data
API, there is the

00:35:36.440 --> 00:35:37.420
potential to use it.

00:35:37.420 --> 00:35:39.310
And there are JavaScript
libraries

00:35:39.310 --> 00:35:40.960
that do connect both.

00:35:40.960 --> 00:35:41.720
So you could use it.

00:35:41.720 --> 00:35:45.060
But since it is based on doing
everything in JavaScript, it's

00:35:45.060 --> 00:35:48.710
much more limited in terms of
what you can do in real time.

00:35:48.710 --> 00:35:51.415
And therefore, not all
functionality that you can do

00:35:51.415 --> 00:35:55.222
in Web Audio API is available
for the simple [? data ?]

00:35:55.222 --> 00:35:55.610
API.

00:35:55.610 --> 00:35:58.800
CHRIS WILSON: The Audio Data
API is really just about

00:35:58.800 --> 00:36:00.420
getting audio input
and output.

00:36:00.420 --> 00:36:05.150
It's not about providing a
routing and effects pipeline.

00:36:05.150 --> 00:36:06.830
And so you can use it.

00:36:06.830 --> 00:36:08.300
And there certainly
are libraries that

00:36:08.300 --> 00:36:09.920
are using it today.

00:36:09.920 --> 00:36:14.750
Mozilla has actually stated
publicly several times that

00:36:14.750 --> 00:36:18.900
I've seen that audio data
is not something they're

00:36:18.900 --> 00:36:20.710
interested in continuing.

00:36:20.710 --> 00:36:23.930
They were working on a
MediaStreams audio proposal

00:36:23.930 --> 00:36:25.140
for a while.

00:36:25.140 --> 00:36:31.910
And a lot of the guidance
from that is folded into

00:36:31.910 --> 00:36:33.370
the Web Audio API.

00:36:33.370 --> 00:36:36.880
And they continue to work-- we
all continue to work on that

00:36:36.880 --> 00:36:38.540
in the Web Audio
working group.

00:36:38.540 --> 00:36:41.064
PETER LUBBERS: Excellent.

00:36:41.064 --> 00:36:43.510
A couple of other questions--
so how does Web

00:36:43.510 --> 00:36:44.790
Audio relate to WebRTC?

00:36:44.790 --> 00:36:47.560
We touched on it briefly
with Get User Media.

00:36:47.560 --> 00:36:51.140
Will Web Audio eventually become
a component of WebRTC?

00:36:51.140 --> 00:36:52.970
How do you see that
fitting together?

00:36:52.970 --> 00:36:56.290
JAN LINDEN: No is the
simple answer.

00:36:56.290 --> 00:36:59.440
They're both extremely important
separate APIs.

00:36:59.440 --> 00:37:00.690
WebRTC--

00:37:02.400 --> 00:37:03.240
that's my background.

00:37:03.240 --> 00:37:05.960
I've been working with
RTC forever.

00:37:05.960 --> 00:37:09.700
And I come from the company that
brought this technology

00:37:09.700 --> 00:37:11.560
into Google.

00:37:11.560 --> 00:37:13.550
Anyway, so I'm working
on that as well.

00:37:13.550 --> 00:37:18.590
And that is evolving in its
own way and will become

00:37:18.590 --> 00:37:21.330
everything you need for doing
real-time voice and video

00:37:21.330 --> 00:37:22.310
communication.

00:37:22.310 --> 00:37:28.430
Then you will add Web Audio
API to this, either at the

00:37:28.430 --> 00:37:29.900
input or at the output.

00:37:29.900 --> 00:37:32.990
So at the input, it can be
interesting to add effects.

00:37:32.990 --> 00:37:39.570
So between the microphone and
the encoder that you will send

00:37:39.570 --> 00:37:42.850
data to the other side in
WebRTC, there you can add, for

00:37:42.850 --> 00:37:45.250
example, an effect so you sound
differently, or whatever

00:37:45.250 --> 00:37:46.320
you want to do--

00:37:46.320 --> 00:37:48.980
filtering and things
like that.

00:37:48.980 --> 00:37:52.450
And then on the output, it's
really nice to be able to add

00:37:52.450 --> 00:37:55.880
what Web Audio API can do in
terms of spatialization.

00:37:55.880 --> 00:37:58.340
For example, if you think about
a conferencing solution

00:37:58.340 --> 00:38:00.820
where you want different
participants to come from

00:38:00.820 --> 00:38:03.600
different locations, that's
easy to do that way.

00:38:03.600 --> 00:38:05.960
And again, add effects,
et cetera.

00:38:05.960 --> 00:38:09.320
So actually, the way WebRTC
is being specced out and

00:38:09.320 --> 00:38:13.580
designed, it's assumed that Web
Audio API will be there

00:38:13.580 --> 00:38:14.840
and take care of these things.

00:38:14.840 --> 00:38:18.630
So WebRTC will not include, for
example, spatialization,

00:38:18.630 --> 00:38:19.610
because it's not needed.

00:38:19.610 --> 00:38:24.670
So they are really working
together to accomplish the

00:38:24.670 --> 00:38:28.490
goals of all the audio
you want to have.

00:38:28.490 --> 00:38:29.890
PETER LUBBERS: Great.

00:38:29.890 --> 00:38:31.720
Another question from
stephband--

00:38:31.720 --> 00:38:34.340
so the obvious next step for
the vocoder is to give it

00:38:34.340 --> 00:38:35.710
real-time input.

00:38:35.710 --> 00:38:39.300
Where are we with being able
to send audio into

00:38:39.300 --> 00:38:40.550
Chrome in real time?

00:38:43.990 --> 00:38:47.100
It's on GitHub, right?

00:38:47.100 --> 00:38:49.910
CHRIS WILSON: Well, no.

00:38:49.910 --> 00:38:51.900
I've been pestering--

00:38:51.900 --> 00:38:54.490
I'll put it politely
as pestering--

00:38:54.490 --> 00:38:58.640
Jan and Chris about this for
probably about six months now.

00:38:58.640 --> 00:39:02.990
And I think I've sent at least
two mails in the last couple

00:39:02.990 --> 00:39:05.850
of weeks to Chris, saying, you
know, the instant you guys

00:39:05.850 --> 00:39:10.160
have any build that has
audio input support,

00:39:10.160 --> 00:39:11.060
please give it to me.

00:39:11.060 --> 00:39:13.480
Because I'm going to
go immediately hook

00:39:13.480 --> 00:39:15.600
it up to the vocoder.

00:39:15.600 --> 00:39:16.460
It is coming.

00:39:16.460 --> 00:39:19.470
It is something that the team's
actively working on and

00:39:19.470 --> 00:39:24.030
hopefully will be at least
initially implemented pretty

00:39:24.030 --> 00:39:25.240
quickly here.

00:39:25.240 --> 00:39:27.660
But it's not quite there yet.

00:39:27.660 --> 00:39:30.890
I will guarantee that I'll get
it into the vocoder as quickly

00:39:30.890 --> 00:39:32.780
as possible.

00:39:32.780 --> 00:39:35.600
JAN LINDEN: So the work is going
on right now, both on

00:39:35.600 --> 00:39:39.110
the Web Audio side and the
WebRTC, because we want to do

00:39:39.110 --> 00:39:40.090
both of these things.

00:39:40.090 --> 00:39:43.710
But basically, the first case
we are implementing is this

00:39:43.710 --> 00:39:48.260
case to get live audio
into Web Audio API.

00:39:48.260 --> 00:39:52.070
And you never know exactly
when it's done.

00:39:52.070 --> 00:39:54.435
But we're working as quickly
as possible,

00:39:54.435 --> 00:39:55.590
and it's a high priority.

00:39:55.590 --> 00:39:57.460
And we have people working
on it today.

00:39:57.460 --> 00:39:58.930
PETER LUBBERS: Excellent.

00:39:58.930 --> 00:40:01.460
All right, a question from
Jeff in Portland.

00:40:01.460 --> 00:40:05.790
With Web Audio, can I play a
long audio file, like a song,

00:40:05.790 --> 00:40:09.010
and synchronize JavaScript
events to be fired at certain

00:40:09.010 --> 00:40:10.400
times in the song?

00:40:10.400 --> 00:40:12.610
For example, having a function
that gets called when the

00:40:12.610 --> 00:40:15.100
audio file reaches the
three-second mark--

00:40:15.100 --> 00:40:15.855
something like that.

00:40:15.855 --> 00:40:17.105
Is that possible?

00:40:19.440 --> 00:40:23.920
CHRIS WILSON: So that's an
interesting use case.

00:40:23.920 --> 00:40:28.410
I think that you'll probably
find the best way to do that

00:40:28.410 --> 00:40:34.540
is to use tracks in the HTML5
audio element and then if you

00:40:34.540 --> 00:40:40.260
want processing on top of that,
you can actually get the

00:40:40.260 --> 00:40:43.380
output of an audio element
and push it into

00:40:43.380 --> 00:40:44.520
the Web Audio graphs.

00:40:44.520 --> 00:40:47.950
You can use that as a sound
source in Web Audio as well,

00:40:47.950 --> 00:40:52.790
if you want reverb or something
on the audio file.

00:40:55.420 --> 00:40:59.510
We don't actually have callbacks
from the functions.

00:40:59.510 --> 00:41:04.290
Because the audio in the Web
Audio API is running on the

00:41:04.290 --> 00:41:07.000
audio system clock, which may or
may not be the same as your

00:41:07.000 --> 00:41:08.100
computer clock.

00:41:08.100 --> 00:41:12.350
If you have a totally separate
audio interface internally, it

00:41:12.350 --> 00:41:15.320
probably has literally a
separate crystal for the clock

00:41:15.320 --> 00:41:17.260
to keep it stable.

00:41:17.260 --> 00:41:22.310
And callbacks would actually
cause some interesting timing

00:41:22.310 --> 00:41:23.560
challenges there.

00:41:23.560 --> 00:41:27.710
But you can synchronize
JavaScript events fairly

00:41:27.710 --> 00:41:31.000
easily, simply by saying, well,
this is going to happen

00:41:31.000 --> 00:41:31.970
in 15 seconds.

00:41:31.970 --> 00:41:34.790
So I'm going to set a callback
for 15 seconds.

00:41:34.790 --> 00:41:39.330
But tracks is really the way
to do that inside the HTML5

00:41:39.330 --> 00:41:41.760
audio element.

00:41:41.760 --> 00:41:44.410
JAN LINDEN: And if you want to
do something like your own

00:41:44.410 --> 00:41:47.070
analysis based on the
[? signal, ?] you can still

00:41:47.070 --> 00:41:50.780
hook up the audio tag to the
Web Audio API, and then use

00:41:50.780 --> 00:41:54.370
the JavaScript node to do your
analysis, and whatever you

00:41:54.370 --> 00:41:58.880
want to fire on that.

00:41:58.880 --> 00:42:01.420
PETER LUBBERS: So a couple final
questions here, then.

00:42:01.420 --> 00:42:04.290
And if I missed any, I will go
back through the moderator and

00:42:04.290 --> 00:42:06.610
answer everything that
we didn't get to.

00:42:06.610 --> 00:42:11.310
But somebody was asking, will
there be a port of Auto-Tune

00:42:11.310 --> 00:42:12.590
to the Web Audio API?

00:42:15.590 --> 00:42:17.970
CHRIS WILSON: A super
interesting question.

00:42:17.970 --> 00:42:21.800
So one of my multiple projects
that I have on my I Would Love

00:42:21.800 --> 00:42:25.640
To Do This list is an
Auto-Tune-like effect.

00:42:25.640 --> 00:42:30.640
Although, of course, Auto-Tune
itself is pretty heavily

00:42:30.640 --> 00:42:33.020
patented, I'm sure.

00:42:33.020 --> 00:42:37.250
The concept of re-tuning
audio files is a

00:42:37.250 --> 00:42:39.310
pretty powerful one.

00:42:39.310 --> 00:42:42.730
The main reason that I haven't
gone too deeply looking into

00:42:42.730 --> 00:42:45.120
it is, well, first of all,
pitch detection is hard.

00:42:47.980 --> 00:42:52.500
I keep uncovering one more layer
of the onion of being on

00:42:52.500 --> 00:42:56.470
my way to becoming a digital
signal processing engineer.

00:42:56.470 --> 00:42:57.900
But it's still--

00:42:57.900 --> 00:43:04.850
I get too deeply into the
technical papers that are all

00:43:04.850 --> 00:43:08.500
equations, and I kind
of glaze over.

00:43:08.500 --> 00:43:09.840
It's certainly--

00:43:09.840 --> 00:43:14.110
anything that you could build in
digital signal processing,

00:43:14.110 --> 00:43:17.310
you could push into Web Audio.

00:43:17.310 --> 00:43:22.260
I'm hoping that we get some
kinds of that work done

00:43:22.260 --> 00:43:24.060
relatively quickly.

00:43:24.060 --> 00:43:26.740
I'm looking for volunteers,
too.

00:43:26.740 --> 00:43:27.800
PETER LUBBERS: Excellent.

00:43:27.800 --> 00:43:30.120
All right, so I think that
pretty much concludes it.

00:43:30.120 --> 00:43:34.760
There was one question about
where we can get the

00:43:34.760 --> 00:43:35.540
presentation.

00:43:35.540 --> 00:43:38.850
So you showed, Chris, and of
course, I will be posting all

00:43:38.850 --> 00:43:44.960
of the links for this
presentation on our Google

00:43:44.960 --> 00:43:47.570
Chrome Developers
Google+ page.

00:43:47.570 --> 00:43:49.480
So definitely check
there after.

00:43:49.480 --> 00:43:51.910
And we'll have a link to all
of the material-- so the

00:43:51.910 --> 00:43:57.650
GitHub where Chris posted his
source, the presentation that

00:43:57.650 --> 00:44:00.360
he gave it at I/O, which
has a lot more

00:44:00.360 --> 00:44:02.420
information about Web Audio.

00:44:02.420 --> 00:44:06.650
We'll also post there the next
event, when we're going to do

00:44:06.650 --> 00:44:08.680
that, in a couple of weeks.

00:44:08.680 --> 00:44:13.110
And well, I think that's about
it in terms of questions.

00:44:13.110 --> 00:44:15.720
Like I said, we'll definitely
cover any

00:44:15.720 --> 00:44:16.620
questions that we missed.

00:44:16.620 --> 00:44:17.480
And we'll answer them.

00:44:17.480 --> 00:44:19.600
Did you have any other questions
there on the--

00:44:19.600 --> 00:44:21.776
JAN LINDEN: No, I think that
pretty much covered

00:44:21.776 --> 00:44:22.730
[? everything. ?]

00:44:22.730 --> 00:44:23.440
PETER LUBBERS: All right.

00:44:23.440 --> 00:44:26.300
Well, with that, I'd like to
thank everyone for tuning in.

00:44:26.300 --> 00:44:29.790
And I want to thank Chris
and Jan for the great

00:44:29.790 --> 00:44:30.440
information--

00:44:30.440 --> 00:44:33.280
excellent, excellent overview.

00:44:33.280 --> 00:44:35.810
The next session will be
about how you can use

00:44:35.810 --> 00:44:39.120
Web Audio in gaming.

00:44:39.120 --> 00:44:40.550
We'll do that in
a couple weeks.

00:44:40.550 --> 00:44:44.250
And in the meantime, follow
us on Google+

00:44:44.250 --> 00:44:46.310
Chrome Developers Channel.

00:44:46.310 --> 00:44:47.920
And that's it.

00:44:47.920 --> 00:44:49.457
Thank you for tuning in.

00:44:49.457 --> 00:44:50.331
CHRIS WILSON: Thanks, guys.

00:44:50.331 --> 00:44:50.770
JAN LINDEN: Thank you.

00:44:50.770 --> 00:44:52.020
PETER LUBBERS: Thanks.

