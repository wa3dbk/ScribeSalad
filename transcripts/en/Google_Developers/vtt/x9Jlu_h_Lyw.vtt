WEBVTT
Kind: captions
Language: en

00:00:00.906 --> 00:00:01.360
LOREENA LEE: All right.

00:00:01.360 --> 00:00:01.970
Hi, everyone.

00:00:01.970 --> 00:00:03.210
Good afternoon.

00:00:03.210 --> 00:00:04.170
My name is Loreena Lee.

00:00:04.170 --> 00:00:05.725
I'm an engineer on
the Gmail team.

00:00:05.725 --> 00:00:10.030
I've been working recently on
performance mostly and taking

00:00:10.030 --> 00:00:13.080
a good look at how much memory
Gmail's been using.

00:00:13.080 --> 00:00:13.510
JOHN MCCUTCHAN: Hi, everyone.

00:00:13.510 --> 00:00:14.430
I'm John McCutchan.

00:00:14.430 --> 00:00:15.660
I'm part of Chrome Dev Rel.

00:00:15.660 --> 00:00:19.830
And my focus is also on
performance and memory usage.

00:00:19.830 --> 00:00:21.430
LOREENA LEE: So today we're
going to cover everything from

00:00:21.430 --> 00:00:24.300
memory management basics
to garbage collection.

00:00:24.300 --> 00:00:26.290
And we're going to introduce
some tools and techniques to

00:00:26.290 --> 00:00:29.440
help you understand how much
memory your app is using.

00:00:29.440 --> 00:00:30.750
So why is this important?

00:00:37.130 --> 00:00:39.080
A lot of times when people talk
about performance versus

00:00:39.080 --> 00:00:43.320
memory, performance wins
9 times out of 10.

00:00:43.320 --> 00:00:46.180
And this is the trade-off
that people usually say,

00:00:46.180 --> 00:00:47.070
performance versus memory?

00:00:47.070 --> 00:00:49.150
Let's go ahead and
use more memory.

00:00:49.150 --> 00:00:51.262
JOHN MCCUTCHAN: So the idea
being that the more memory you

00:00:51.262 --> 00:00:53.220
use the better the
performance is?

00:00:53.220 --> 00:00:53.750
LOREENA LEE: Right.

00:00:53.750 --> 00:00:56.220
So generally, if your caching
more, you're keeping more

00:00:56.220 --> 00:00:58.880
resident memory, you have less
fetches to disk, so your

00:00:58.880 --> 00:01:00.610
performance is usually
improved.

00:01:00.610 --> 00:01:02.630
And so people were starting
to say that Gmail was

00:01:02.630 --> 00:01:03.690
using a lot of memory.

00:01:03.690 --> 00:01:06.840
We started hearing a lot of
anecdotes of people having a

00:01:06.840 --> 00:01:09.150
Gmail tab that's using
a whole gig of mem.

00:01:09.150 --> 00:01:10.740
And that seems kind of a lot.

00:01:10.740 --> 00:01:12.690
But a lot about the same time
were like, well, who cares?

00:01:12.690 --> 00:01:13.690
You have a ton of memory.

00:01:13.690 --> 00:01:14.690
Memory's cheap.

00:01:14.690 --> 00:01:16.580
Why not just use it?

00:01:16.580 --> 00:01:19.940
But the time of our users
is very important.

00:01:19.940 --> 00:01:22.670
So if they're spending two to
three seconds waiting for

00:01:22.670 --> 00:01:25.050
their app to be responsive,
that's not good.

00:01:25.050 --> 00:01:27.770
We don't want to waste
their time.

00:01:27.770 --> 00:01:30.480
So we'll start using a little
bit more memory, start caching

00:01:30.480 --> 00:01:33.340
a little bit more, help them
to get things to be more

00:01:33.340 --> 00:01:34.560
responsive.

00:01:34.560 --> 00:01:37.640
But at the same time, what's
worse than having your users

00:01:37.640 --> 00:01:40.750
wait two to three seconds?

00:01:40.750 --> 00:01:42.140
Having your app crash.

00:01:42.140 --> 00:01:44.600
So this is the "He's
Dead, Jim" sad tab.

00:01:44.600 --> 00:01:46.240
And a lot of you have probably
seen this before.

00:01:46.240 --> 00:01:48.600
This is the Chrome sad tab.

00:01:48.600 --> 00:01:51.390
And the "He's dead, Jim" variety
almost always comes as

00:01:51.390 --> 00:01:53.660
an out of memory situation.

00:01:53.660 --> 00:01:55.630
So we were starting to hear more
and more stories about

00:01:55.630 --> 00:01:57.820
Gmail running out of memory and
people getting sad tabs

00:01:57.820 --> 00:01:59.250
because of Gmail.

00:01:59.250 --> 00:02:01.120
But we didn't really have
any data to know

00:02:01.120 --> 00:02:03.050
how common this was.

00:02:03.050 --> 00:02:05.420
Our colleagues were telling us,
oh, my Gmail ran out of

00:02:05.420 --> 00:02:07.860
memory again, caused my
browser to crash.

00:02:07.860 --> 00:02:11.130
But we didn't know if this is
something that was only

00:02:11.130 --> 00:02:12.780
happening to people we knew.

00:02:12.780 --> 00:02:16.020
Our power users were having
this situation, but our

00:02:16.020 --> 00:02:17.380
parents weren't really
complaining.

00:02:17.380 --> 00:02:20.380
But they only get a couple
mails a day or a

00:02:20.380 --> 00:02:21.570
week, in some cases.

00:02:21.570 --> 00:02:23.540
They probably spend a few
minutes on Gmail.

00:02:23.540 --> 00:02:27.170
Whereas people at Google tend
to spend all day, getting

00:02:27.170 --> 00:02:28.900
several hundred messages
a day.

00:02:28.900 --> 00:02:29.175
JOHN MCCUTCHAN: Yeah.

00:02:29.175 --> 00:02:32.565
A few emails a minute.

00:02:32.565 --> 00:02:34.570
LOREENA LEE: But we didn't
have any scientific data.

00:02:34.570 --> 00:02:35.690
We only had anecdotes.

00:02:35.690 --> 00:02:39.570
We had a bunch of tools that
didn't necessarily scale up to

00:02:39.570 --> 00:02:42.970
things like applications
as big as Gmail.

00:02:42.970 --> 00:02:45.200
We didn't really know how to
track what was leaking.

00:02:45.200 --> 00:02:48.880
We didn't know how to
find the problems.

00:02:48.880 --> 00:02:51.890
And so we kind of were starting
from nothing.

00:02:51.890 --> 00:02:53.720
So I'm talking a little bit
about Gmail right now.

00:02:53.720 --> 00:02:55.780
But really, this problem
is universal.

00:02:55.780 --> 00:02:57.680
Running out of memory
is something that

00:02:57.680 --> 00:02:59.290
everyone can encounter.

00:02:59.290 --> 00:03:00.510
And you should care.

00:03:00.510 --> 00:03:03.490
Because I don't know how much
you know about the Chrome

00:03:03.490 --> 00:03:08.000
process model, but this isn't
just Gmail's problem.

00:03:08.000 --> 00:03:10.440
So if you see here, I have
a ton of tabs open.

00:03:10.440 --> 00:03:13.140
And Chrome will normally try to
open all of these tabs in

00:03:13.140 --> 00:03:14.820
their own renderer process, but

00:03:14.820 --> 00:03:16.080
that's not always possible.

00:03:16.080 --> 00:03:18.280
So Chrome has a hard
limit on how many

00:03:18.280 --> 00:03:19.910
processes it will fork.

00:03:19.910 --> 00:03:22.280
And once you've exhausted that
limit, it will start putting

00:03:22.280 --> 00:03:24.780
multiple tabs in a process.

00:03:24.780 --> 00:03:28.010
JOHN MCCUTCHAN: So do you mean
if Gmail uses a lot of memory

00:03:28.010 --> 00:03:30.980
or some pages a lot of memory,
it might kill five pages?

00:03:30.980 --> 00:03:31.330
LOREENA LEE: Right.

00:03:31.330 --> 00:03:34.580
So if all of these pages are
in the same process, that's

00:03:34.580 --> 00:03:36.990
why a lot of times if you do
see this out of memory

00:03:36.990 --> 00:03:39.950
situation with the sad tab
you'll notice several of them

00:03:39.950 --> 00:03:40.980
at the same time.

00:03:40.980 --> 00:03:42.640
It's not just one tab
that's crashing.

00:03:42.640 --> 00:03:45.060
It's all of them that are
in that same process.

00:03:45.060 --> 00:03:46.960
So this is something that
everyone needs to care about,

00:03:46.960 --> 00:03:50.300
not just Gmail, not just your
app, but anyone who ends up in

00:03:50.300 --> 00:03:52.420
the same process as your
app will care as well.

00:03:52.420 --> 00:03:54.990
Just like anyone who ends up in
the same process as Gmail

00:03:54.990 --> 00:03:57.090
will probably be glad that we
are making some effort to

00:03:57.090 --> 00:03:58.872
reduce the amount of memory
that we're using.

00:04:02.210 --> 00:04:02.690
JOHN MCCUTCHAN: All right.

00:04:02.690 --> 00:04:05.330
But before we can tackle
Gmail's problem, it's

00:04:05.330 --> 00:04:08.570
important that we go back to
basics and understand both the

00:04:08.570 --> 00:04:13.480
conceptual concepts for memory
management in JavaScript as

00:04:13.480 --> 00:04:17.500
well as the practical with
V8 in particular.

00:04:17.500 --> 00:04:20.230
So let's first talk about a high
level understanding of

00:04:20.230 --> 00:04:23.390
how memory is managed
inside JavaScript.

00:04:23.390 --> 00:04:27.270
So the questions I want you to
be able to answer after this

00:04:27.270 --> 00:04:29.900
set of slides is, what types
of values are there in

00:04:29.900 --> 00:04:30.870
JavaScript?

00:04:30.870 --> 00:04:32.910
How are they organized
in memory?

00:04:32.910 --> 00:04:33.970
What is garbage?

00:04:33.970 --> 00:04:34.870
And what is a leak?

00:04:34.870 --> 00:04:36.260
These are really basic
questions.

00:04:36.260 --> 00:04:39.060
And I'm sure a lot of you know
the answers to these already.

00:04:39.060 --> 00:04:41.190
But it's important that we have
really good definitions

00:04:41.190 --> 00:04:44.250
of what these are so that we
can understand both the

00:04:44.250 --> 00:04:47.300
problem and the tools.

00:04:47.300 --> 00:04:50.690
So JavaScript has very
few value types.

00:04:50.690 --> 00:04:54.090
There's booleans, there's
numbers, there's strings,

00:04:54.090 --> 00:04:56.710
there's objects, and then
there's external data.

00:04:56.710 --> 00:04:59.250
And so you'll know that there's
no arrays here.

00:04:59.250 --> 00:05:01.210
And that's actually because
JavaScript as a language

00:05:01.210 --> 00:05:02.200
doesn't have arrays.

00:05:02.200 --> 00:05:05.390
They're built on top of the
objects inside JavaScript.

00:05:05.390 --> 00:05:09.150
The keys are just the indexes
into the array.

00:05:09.150 --> 00:05:09.810
But this is it.

00:05:09.810 --> 00:05:13.080
This is all that
JavaScript has.

00:05:13.080 --> 00:05:17.440
And the way they're organized
in memory is in a graph.

00:05:17.440 --> 00:05:19.560
You'll see here this
blue node here.

00:05:19.560 --> 00:05:20.780
And this is a root node.

00:05:20.780 --> 00:05:23.680
This is outside of your
application's control, think

00:05:23.680 --> 00:05:25.630
document or window.

00:05:25.630 --> 00:05:27.370
This is created by
the browser.

00:05:27.370 --> 00:05:30.300
It's in there as long as your
page is loaded, and you really

00:05:30.300 --> 00:05:32.540
can't do anything with it
other than maybe add

00:05:32.540 --> 00:05:34.610
properties to it.

00:05:34.610 --> 00:05:36.480
From root nodes, there's
object nodes.

00:05:36.480 --> 00:05:38.070
And these are JavaScript
objects.

00:05:38.070 --> 00:05:40.820
And they're the only nodes which
can actually reference

00:05:40.820 --> 00:05:43.840
other values inside the graph.

00:05:43.840 --> 00:05:49.720
Terminating the graph are scaler
nodes, like a boolean

00:05:49.720 --> 00:05:51.060
or a number.

00:05:51.060 --> 00:05:54.800
These values cannot reference
other values inside the graph.

00:05:54.800 --> 00:05:55.330
So this is it.

00:05:55.330 --> 00:05:58.330
This is how memory is organized
inside JavaScript,

00:05:58.330 --> 00:06:01.410
and this is what you, as a
programmer, can observe.

00:06:01.410 --> 00:06:04.210
You have root notes, which are
outside of your control,

00:06:04.210 --> 00:06:06.820
objects, which you can extend
and reference other values,

00:06:06.820 --> 00:06:09.780
and then the scalar
nodes, which can't

00:06:09.780 --> 00:06:12.140
reference anything else.

00:06:12.140 --> 00:06:14.240
So another property that
values can have

00:06:14.240 --> 00:06:15.890
are retaining paths.

00:06:15.890 --> 00:06:19.140
And this is a path from the root
node to the value itself.

00:06:19.140 --> 00:06:23.740
And so, every value can have one
or more retaining paths.

00:06:23.740 --> 00:06:25.950
And if we look at the green
value on the graph, you can

00:06:25.950 --> 00:06:28.730
actually see that there's one
retaining path that starts at

00:06:28.730 --> 00:06:32.150
the root node and extends
along the red edge.

00:06:32.150 --> 00:06:35.000
And there's a second retaining
that starts at the root node

00:06:35.000 --> 00:06:37.190
and then extends along
these two red edges.

00:06:37.190 --> 00:06:39.770
Both of these are retaining
paths for the green node.

00:06:39.770 --> 00:06:41.720
It keeps the green
node in memory.

00:06:41.720 --> 00:06:44.130
Without a retaining path, the
value becomes garbage.

00:06:44.130 --> 00:06:48.640
And we'll get into
that in a moment.

00:06:48.640 --> 00:06:52.020
So again, this is a fairly
basic operation.

00:06:52.020 --> 00:06:54.230
But it's important to understand
exactly how you can

00:06:54.230 --> 00:06:56.180
remove a value from the graph.

00:06:56.180 --> 00:06:59.130
So if we want to remove the red
value from the graph, we

00:06:59.130 --> 00:07:02.970
could cut this edge right here,
from the root node to

00:07:02.970 --> 00:07:03.980
the first green node.

00:07:03.980 --> 00:07:06.280
And then the red value
is garbage.

00:07:06.280 --> 00:07:10.480
If we cut this edge,
it's also garbage.

00:07:10.480 --> 00:07:11.570
Or we cut this edge.

00:07:11.570 --> 00:07:13.890
Any of those three edges
cut would make

00:07:13.890 --> 00:07:16.650
the red node garbage.

00:07:16.650 --> 00:07:18.450
So what exactly is garbage?

00:07:18.450 --> 00:07:20.580
Well, it's all values which
cannot be reached

00:07:20.580 --> 00:07:21.690
from the root node.

00:07:21.690 --> 00:07:23.710
Or said another way, it's
all values that

00:07:23.710 --> 00:07:24.930
lack a retaining path.

00:07:24.930 --> 00:07:27.110
If something doesn't have a
retaining path, then it

00:07:27.110 --> 00:07:31.170
becomes garbage, like
these nodes here.

00:07:31.170 --> 00:07:34.740
You'll see that there is no
path from the root node to

00:07:34.740 --> 00:07:36.610
these values, so these values
are actually garbage.

00:07:36.610 --> 00:07:38.190
At some point, they
were on the graph,

00:07:38.190 --> 00:07:39.010
and now they're not.

00:07:39.010 --> 00:07:42.640
And at the next garbage
collection process, they'll be

00:07:42.640 --> 00:07:45.960
cleaned up, which actually
brings us to garbage

00:07:45.960 --> 00:07:46.490
collection.

00:07:46.490 --> 00:07:50.430
So the first step in a garbage
collection pass is to find all

00:07:50.430 --> 00:07:51.790
the live values.

00:07:51.790 --> 00:07:55.030
And then the second is to return
the memory used by the

00:07:55.030 --> 00:07:57.750
dead values back to the system
so that they can be recycled

00:07:57.750 --> 00:08:00.450
later on, as we see here.

00:08:03.250 --> 00:08:06.580
So another property that every
value inside JavaScript has is

00:08:06.580 --> 00:08:07.850
its retained size.

00:08:07.850 --> 00:08:10.530
So the retained size, you can
conceptually think about this

00:08:10.530 --> 00:08:13.810
as the amount of memory that
would be freed if the value

00:08:13.810 --> 00:08:14.810
became garbage.

00:08:14.810 --> 00:08:17.760
And so that's the size of
the value and all of its

00:08:17.760 --> 00:08:19.860
descendants which lack
retaining paths.

00:08:19.860 --> 00:08:23.200
So if we look at the yellow
node on the graph, its

00:08:23.200 --> 00:08:26.460
retained size is its size plus
the size of the green node.

00:08:26.460 --> 00:08:29.360
And if we pull back, the
retained sides of this new

00:08:29.360 --> 00:08:32.860
yellow node is both of the green
node size plus itself.

00:08:32.860 --> 00:08:35.190
And if we go all the way back to
the root node, the retained

00:08:35.190 --> 00:08:37.180
size is all memory being
used by JavaScript.

00:08:40.440 --> 00:08:42.809
So now let's talk
about a leak.

00:08:42.809 --> 00:08:46.470
A leak is when you, the
programmer, have mistakenly

00:08:46.470 --> 00:08:49.100
left a retaining path some
value inside the graph.

00:08:49.100 --> 00:08:52.610
You think that the value has no
path, starting from a root

00:08:52.610 --> 00:08:55.450
node, getting to it, and that
it'll be collected at the next

00:08:55.450 --> 00:08:57.240
garbage collection cycle.

00:08:57.240 --> 00:09:00.130
But you've accidentally
left a retaining path.

00:09:00.130 --> 00:09:03.900
So it's a program error, as
all memory leaks are.

00:09:03.900 --> 00:09:06.820
If we look at this really simple
example that's kind of

00:09:06.820 --> 00:09:09.990
Gmail themed, we have an email
object and we have the message

00:09:09.990 --> 00:09:11.300
field inside of it.

00:09:11.300 --> 00:09:14.820
And we assign that to be
a div node in the dom.

00:09:14.820 --> 00:09:17.960
We then want to display these
email messages, so we add that

00:09:17.960 --> 00:09:22.100
div node into a display
list as well.

00:09:22.100 --> 00:09:24.570
So this is what the object
graph looks like after

00:09:24.570 --> 00:09:25.940
running this code.

00:09:25.940 --> 00:09:28.560
Somewhere, starting at the root
node, there's paths to

00:09:28.560 --> 00:09:30.170
both email and display.

00:09:30.170 --> 00:09:33.240
And then off of email, there's
a path to message.

00:09:33.240 --> 00:09:36.060
And there's a special
kind of edge from

00:09:36.060 --> 00:09:37.490
message to the Div Node.

00:09:37.490 --> 00:09:40.380
And this is pinning a native
object, an external object

00:09:40.380 --> 00:09:44.470
that's not directly related
to JavaScript.

00:09:44.470 --> 00:09:45.430
But this is the way it looks.

00:09:45.430 --> 00:09:46.700
You follow the other path.

00:09:46.700 --> 00:09:49.150
You go from display, and then
you have this list of div

00:09:49.150 --> 00:09:52.030
elements, terminating with the
div node that we just created

00:09:52.030 --> 00:09:53.660
on the previous slide.

00:09:53.660 --> 00:09:55.190
LOREENA LEE: So everything
here, the green nodes are

00:09:55.190 --> 00:09:58.196
JavaScript objects, and the
yellow are actual dom nodes?

00:09:58.196 --> 00:09:58.532
JOHN MCCUTCHAN: Yes.

00:09:58.532 --> 00:09:58.870
Yeah.

00:09:58.870 --> 00:10:02.150
They're external to
the JavaScript.

00:10:02.150 --> 00:10:04.320
So at some point later on,
we're done looking at

00:10:04.320 --> 00:10:06.440
messages, and we want to just
clean out the display list.

00:10:06.440 --> 00:10:08.940
So the programmer writes
removeAllChildren, Children

00:10:08.940 --> 00:10:11.200
and you think, OK, all those
div nodes are gone.

00:10:11.200 --> 00:10:15.560
But whoops, we've actually
cached a reference from the

00:10:15.560 --> 00:10:17.910
message object to
the div node.

00:10:17.910 --> 00:10:21.280
So until the email itself is
removed from the system, which

00:10:21.280 --> 00:10:24.500
could take forever and might not
ever happen, this div node

00:10:24.500 --> 00:10:26.880
will be pinned in memory,
and we've leaked it.

00:10:29.520 --> 00:10:33.760
So in general, the really basics
of memory management in

00:10:33.760 --> 00:10:35.560
JavaScript are that
the values are all

00:10:35.560 --> 00:10:37.360
organized inside this graph.

00:10:37.360 --> 00:10:39.750
And they have retaining paths.

00:10:39.750 --> 00:10:41.750
And any value that
lacks a retaining

00:10:41.750 --> 00:10:44.160
path has become garbage.

00:10:44.160 --> 00:10:45.420
And then there's
retained sizes.

00:10:45.420 --> 00:10:46.910
And that's the amount of memory
that you're going to

00:10:46.910 --> 00:10:52.340
free up when the value itself
becomes garbage.

00:10:52.340 --> 00:10:56.530
So let's go from the general to
the specific and talk about

00:10:56.530 --> 00:10:59.580
the way V8 manages
memory and what

00:10:59.580 --> 00:11:02.680
happens during a GC Pause.

00:11:02.680 --> 00:11:04.940
The first question you want to
ask yourself is, what's the

00:11:04.940 --> 00:11:07.920
cost in allocating memory
in JavaScript?

00:11:07.920 --> 00:11:09.530
And it's not the call to new.

00:11:09.530 --> 00:11:11.890
Typically, the call to new
is incredibly fast.

00:11:14.820 --> 00:11:17.985
It's very, very quick, until
you've exhausted a memory

00:11:17.985 --> 00:11:19.950
pool, and we'll get to
this in a moment of

00:11:19.950 --> 00:11:21.100
what's actually happening.

00:11:21.100 --> 00:11:23.580
But at that point, the runtime
is forced to do a garbage

00:11:23.580 --> 00:11:23.940
collection.

00:11:23.940 --> 00:11:26.560
And this is where all
the time is spent.

00:11:26.560 --> 00:11:28.450
And it can actually
take milliseconds.

00:11:28.450 --> 00:11:32.170
So if you're writing a game, you
have 16 milliseconds to do

00:11:32.170 --> 00:11:33.920
everything inside
of your frame.

00:11:33.920 --> 00:11:36.680
And a garbage collection pause
might pause your application

00:11:36.680 --> 00:11:40.830
for 5, maybe 10 milliseconds,
which for Gmail might be OK,

00:11:40.830 --> 00:11:44.950
but for some applications
it's really too long.

00:11:44.950 --> 00:11:47.930
So it's important to be aware
at the pattern at which your

00:11:47.930 --> 00:11:52.170
application is allocating
objects and understand how it

00:11:52.170 --> 00:11:54.070
interacts with the garbage
collector.

00:11:54.070 --> 00:11:57.890
And this is what we're going
to talk about right now.

00:11:57.890 --> 00:12:00.040
V8 manages memory in
two generations.

00:12:00.040 --> 00:12:02.920
There's the young generation and
then the old generation.

00:12:02.920 --> 00:12:07.430
And by young and old, I mean
how long has the JavaScript

00:12:07.430 --> 00:12:09.460
value existed for.

00:12:09.460 --> 00:12:14.000
And over time, young values get
promoted to old values.

00:12:14.000 --> 00:12:16.540
So after a few garbage
collections, if the value

00:12:16.540 --> 00:12:20.110
survives, meaning that there's a
retaining path and it's kept

00:12:20.110 --> 00:12:23.150
in memory, eventually the value
gets promoted into the

00:12:23.150 --> 00:12:25.930
old generation.

00:12:25.930 --> 00:12:29.630
So what are the properties of
the young generation in V8?

00:12:29.630 --> 00:12:33.620
Well, it offers really fast
allocation, fast collection,

00:12:33.620 --> 00:12:35.220
and it's frequently collected.

00:12:35.220 --> 00:12:38.410
In fact, when you're using the
Timeline tool and you see the

00:12:38.410 --> 00:12:41.065
GC Event on it, this is a young
generation collection.

00:12:48.360 --> 00:12:51.770
In contrast, the old generation
offers fast

00:12:51.770 --> 00:12:55.650
allocation, but the collection
is much slower.

00:12:55.650 --> 00:12:58.010
The good thing is that it's very
infrequently collected.

00:12:58.010 --> 00:13:00.810
And some of the old generation's
collection occurs

00:13:00.810 --> 00:13:03.720
in parallel with your
page's execution.

00:13:03.720 --> 00:13:06.170
Whereas a young generation
collection, is really just

00:13:06.170 --> 00:13:09.320
everything is stopped, the
collection occurs, and then

00:13:09.320 --> 00:13:10.330
your page resumes.

00:13:10.330 --> 00:13:15.880
Old generation mixes a little
bit of collection with your

00:13:15.880 --> 00:13:18.250
page's execution.

00:13:18.250 --> 00:13:21.460
So I want to focus mostly on
young generation, because this

00:13:21.460 --> 00:13:24.990
is where you're going to feel
the pain inside your

00:13:24.990 --> 00:13:25.760
application.

00:13:25.760 --> 00:13:27.500
And it's going to happen
fairly regularly.

00:13:30.610 --> 00:13:33.770
It's important to understand
why collecting the young

00:13:33.770 --> 00:13:35.670
generation is faster.

00:13:35.670 --> 00:13:39.660
And intuitively, you have to
understand that the cost of

00:13:39.660 --> 00:13:42.450
the GC Pause is actually
proportional to the number of

00:13:42.450 --> 00:13:43.790
live objects.

00:13:43.790 --> 00:13:46.740
And because the objects are
split into the young and the

00:13:46.740 --> 00:13:48.750
old generation, the
young generation,

00:13:48.750 --> 00:13:51.050
actually not much survives.

00:13:51.050 --> 00:13:53.540
After a garbage collection,
most of the values in the

00:13:53.540 --> 00:13:56.020
young generation
don't make it.

00:13:56.020 --> 00:13:58.760
They have no retaining path,
because they were used just

00:13:58.760 --> 00:14:00.160
briefly, and they're gone,
and they're not

00:14:00.160 --> 00:14:01.600
really in the graph.

00:14:01.600 --> 00:14:05.330
Whereas by their nature, objects
in the old generation

00:14:05.330 --> 00:14:07.020
have survived quite
a long time.

00:14:07.020 --> 00:14:10.090
So you can't expect that when a
collection is triggered for

00:14:10.090 --> 00:14:11.650
the old generation
that many of them

00:14:11.650 --> 00:14:13.770
are going to disappear.

00:14:13.770 --> 00:14:16.710
So knowing that the cost of the
garbage collection pause

00:14:16.710 --> 00:14:19.170
really comes down to the number
of live objects, it

00:14:19.170 --> 00:14:21.500
becomes quite clear why
collecting the young

00:14:21.500 --> 00:14:24.870
generations so much faster.

00:14:24.870 --> 00:14:27.420
So let's look at the young
generation in action.

00:14:27.420 --> 00:14:29.630
The young generation
is split into two

00:14:29.630 --> 00:14:32.170
semispaces, equally sized.

00:14:32.170 --> 00:14:34.970
There's the To Space
and the From Space.

00:14:34.970 --> 00:14:38.010
The To Space is where values
that you allocate when your

00:14:38.010 --> 00:14:42.240
page executes, like, new Foo,
it's coming out of To Space.

00:14:42.240 --> 00:14:46.280
The From Space actually just
sits there not being used

00:14:46.280 --> 00:14:47.060
until later on.

00:14:47.060 --> 00:14:48.740
And we'll see what
happens with it.

00:14:52.220 --> 00:14:55.450
So assuming that To Space
started off empty and your

00:14:55.450 --> 00:14:57.480
page starts allocated
some objects.

00:14:57.480 --> 00:15:02.170
It does new A and then new B,
new C, and new D. Everything

00:15:02.170 --> 00:15:04.000
up until this point has been
really fast, and there's been

00:15:04.000 --> 00:15:08.600
no interruption in your
page's execution.

00:15:08.600 --> 00:15:11.670
But then, your page calls
new E. And actually,

00:15:11.670 --> 00:15:12.620
it's just too big.

00:15:12.620 --> 00:15:15.200
It doesn't fit into
the To Space.

00:15:15.200 --> 00:15:18.700
We've hit that threshold where
we've moved incrementally

00:15:18.700 --> 00:15:20.770
closer to this GC Pause,
and now we've

00:15:20.770 --> 00:15:22.430
actually triggered it.

00:15:22.430 --> 00:15:25.870
So what happens is new
E doesn't happen.

00:15:25.870 --> 00:15:27.410
It's kind of paused.

00:15:27.410 --> 00:15:29.970
So we're still in this state
where we just have A, B, C,

00:15:29.970 --> 00:15:32.065
and D inside of our To Space.

00:15:32.065 --> 00:15:34.880
The page is paused, everything
halts, and the

00:15:34.880 --> 00:15:36.130
collection is triggered.

00:15:38.350 --> 00:15:41.110
The first step in a young
generation collection is that

00:15:41.110 --> 00:15:43.270
the From and the To Space
and just swapped.

00:15:43.270 --> 00:15:46.470
The labels to them are
flipped internally.

00:15:46.470 --> 00:15:49.020
And then the live values
are found.

00:15:49.020 --> 00:15:51.950
And I'm not really going into
details about exactly how the

00:15:51.950 --> 00:15:54.790
live values are found, but
this is the next step.

00:15:54.790 --> 00:15:57.780
Everything that still has a
retaining path, still on the

00:15:57.780 --> 00:16:03.510
graph is discovered and
marked for copy.

00:16:03.510 --> 00:16:05.790
So you can see here that
A and C are marked.

00:16:05.790 --> 00:16:09.550
And B and D have not been
marked, so they're garbage.

00:16:09.550 --> 00:16:12.040
They're not going anywhere.

00:16:12.040 --> 00:16:13.860
And then this is where most
of the time goes.

00:16:13.860 --> 00:16:18.280
It's when the live values are
copied from the From Space to

00:16:18.280 --> 00:16:20.950
the To Space.

00:16:20.950 --> 00:16:21.740
So here we are.

00:16:21.740 --> 00:16:22.390
We've done the copy.

00:16:22.390 --> 00:16:23.620
We've done the collection.

00:16:23.620 --> 00:16:26.030
We've just copied the live
objects from one

00:16:26.030 --> 00:16:29.400
semispace to the next.

00:16:29.400 --> 00:16:32.130
And the From Space is just
recycled at this point.

00:16:32.130 --> 00:16:33.780
There's no other work
done to it.

00:16:33.780 --> 00:16:36.440
It's just ready for use next
time there's a collection that

00:16:36.440 --> 00:16:38.430
needs to happen.

00:16:38.430 --> 00:16:40.880
At this point, your page
is resumed, and

00:16:40.880 --> 00:16:42.460
the E object is allocated.

00:16:45.810 --> 00:16:48.760
What you have to understand is
that each allocation moves you

00:16:48.760 --> 00:16:50.330
closer to a collection.

00:16:50.330 --> 00:16:52.730
And so, when Loreena was talking
earlier about this

00:16:52.730 --> 00:16:56.220
trade-off between more memory
and performance, you start to

00:16:56.220 --> 00:16:58.610
see why that doesn't hold
up inside JavaScript.

00:16:58.610 --> 00:17:00.910
Because the more memory you use,
the faster you're going

00:17:00.910 --> 00:17:03.020
to get to this pause, and that's
actually where you're

00:17:03.020 --> 00:17:04.180
going to lose performance.

00:17:04.180 --> 00:17:04.609
LOREENA LEE: Right.

00:17:04.609 --> 00:17:06.310
And not only that, but the more
memory you're using, the

00:17:06.310 --> 00:17:07.444
longer the pause will take.

00:17:07.444 --> 00:17:07.800
JOHN MCCUTCHAN: Yes.

00:17:07.800 --> 00:17:09.200
LOREENA LEE: The larger the
heap, the longer the

00:17:09.200 --> 00:17:10.520
collection will take.

00:17:10.520 --> 00:17:10.770
JOHN MCCUTCHAN: Yep.

00:17:10.770 --> 00:17:11.170
Exactly.

00:17:11.170 --> 00:17:13.579
And so, when the collection
occurs, your

00:17:13.579 --> 00:17:14.409
application is paused.

00:17:14.409 --> 00:17:16.130
You get higher latency.

00:17:16.130 --> 00:17:18.250
Let's say the user clicks,
and then right then

00:17:18.250 --> 00:17:19.500
a collection occurs.

00:17:19.500 --> 00:17:21.829
Well, the click isn't going to
register for a while, because

00:17:21.829 --> 00:17:23.640
we've got to go and do
a big collection.

00:17:23.640 --> 00:17:26.720
So this leads to dropped
frames and poor user

00:17:26.720 --> 00:17:29.300
interaction, in general,
and unhappy users.

00:17:29.300 --> 00:17:32.340
And unhappy users don't come
back to your site.

00:17:32.340 --> 00:17:35.665
They'll go somewhere else
with better performance.

00:17:35.665 --> 00:17:36.280
LOREENA LEE: All right.

00:17:36.280 --> 00:17:39.020
So now we've heard a little bit
about what happens when

00:17:39.020 --> 00:17:41.080
you have a GC Pause and
how it all works.

00:17:41.080 --> 00:17:44.540
But let's see how we can now
take what we learned and apply

00:17:44.540 --> 00:17:48.030
some tools and techniques to
figure out how we can fix it.

00:17:48.030 --> 00:17:49.900
So I mentioned that we were
starting out from nothing in

00:17:49.900 --> 00:17:52.980
Gmail, and we really had no
idea how problematic the

00:17:52.980 --> 00:17:54.160
memory situation as.

00:17:54.160 --> 00:17:56.990
We heard our colleagues telling
us on a daily basis

00:17:56.990 --> 00:17:58.520
that they were having
lots of issues.

00:17:58.520 --> 00:17:59.840
But we didn't know exactly.

00:17:59.840 --> 00:18:02.650
So we wanted to start and take
some field measurements.

00:18:02.650 --> 00:18:05.120
We wanted to know how bad
it was for all of you.

00:18:05.120 --> 00:18:07.580
So we used the
performance.memory API.

00:18:07.580 --> 00:18:11.090
And what we do is we take
measurements every 30 minutes.

00:18:11.090 --> 00:18:13.610
We store them in our logs, we
aggregate them, and we can

00:18:13.610 --> 00:18:14.150
graph them.

00:18:14.150 --> 00:18:17.200
We can kind of see what's the
difference between our power

00:18:17.200 --> 00:18:20.670
users, the 99th percentile,
versus our median and the

00:18:20.670 --> 00:18:25.140
people who just spend a few
minutes a day here and there.

00:18:25.140 --> 00:18:27.580
So what the performance.memory
API does is it

00:18:27.580 --> 00:18:28.680
returns three values.

00:18:28.680 --> 00:18:31.320
It tells you the jsHeapSizeLimit
which is the

00:18:31.320 --> 00:18:34.290
total amount of memory available
for JavaScript.

00:18:34.290 --> 00:18:37.030
So this is the upper limit.

00:18:37.030 --> 00:18:39.420
And then it tells you the
totalJSHeapSize, which is the

00:18:39.420 --> 00:18:42.220
amount of memory that has been
allocated so far, including

00:18:42.220 --> 00:18:42.850
the free space.

00:18:42.850 --> 00:18:45.580
So this is including memory that
has already been GCed.

00:18:45.580 --> 00:18:49.710
JOHN MCCUTCHAN: So could you
predict an "I'm dead, Jim"

00:18:49.710 --> 00:18:52.790
situation by seeing when
totalJSHeapSize hits the

00:18:52.790 --> 00:18:53.560
jsHeapSizeLimit?

00:18:53.560 --> 00:18:53.820
LOREENA LEE: Right.

00:18:53.820 --> 00:18:54.080
Right.

00:18:54.080 --> 00:18:56.560
As that totalJSHeapSize gets
closer and closer, you know

00:18:56.560 --> 00:18:59.130
that at some point you're going
to trigger this out of

00:18:59.130 --> 00:18:59.706
memory situation.

00:18:59.706 --> 00:19:02.120
JOHN MCCUTCHAN: OK.

00:19:02.120 --> 00:19:03.830
LOREENA LEE: And then the third
value that returns is

00:19:03.830 --> 00:19:04.865
the usedJSHeapSize.

00:19:04.865 --> 00:19:06.530
And that tells you the amount
of memory that's

00:19:06.530 --> 00:19:07.510
currently in use.

00:19:07.510 --> 00:19:09.810
So this is the amount of memory
that's being used by

00:19:09.810 --> 00:19:11.240
live objects in the graph.

00:19:15.610 --> 00:19:16.760
We were taking these
measurements from a

00:19:16.760 --> 00:19:19.010
select set of users.

00:19:19.010 --> 00:19:21.990
Gmail has a lot of users, so
we were able to get quite a

00:19:21.990 --> 00:19:24.070
bit of data from these users.

00:19:24.070 --> 00:19:26.180
And what we did was
we took one user.

00:19:26.180 --> 00:19:27.600
We just sort of followed
that user.

00:19:27.600 --> 00:19:30.720
We took a user who we knew was
using a lot of memory, who was

00:19:30.720 --> 00:19:32.610
nearing this upper limit,
and we followed

00:19:32.610 --> 00:19:33.810
them for three days.

00:19:33.810 --> 00:19:36.320
So we wanted to see what the
correlation was between the

00:19:36.320 --> 00:19:38.980
memory data we were collecting
as well as the latency data we

00:19:38.980 --> 00:19:39.650
were collecting.

00:19:39.650 --> 00:19:42.310
And what we found a little bit
against what our common belief

00:19:42.310 --> 00:19:44.906
of the performance versus
memory trade-off was.

00:19:44.906 --> 00:19:49.620
What we found was that as the
user's heap memory footprint

00:19:49.620 --> 00:19:52.230
grew, their client
side latencies

00:19:52.230 --> 00:19:54.170
were increasing also.

00:19:54.170 --> 00:19:55.770
So over to the right
of each of these

00:19:55.770 --> 00:19:57.440
graphs is by day three.

00:19:57.440 --> 00:20:01.350
By day three, their heap size
was getting very large.

00:20:01.350 --> 00:20:02.980
It was well over a gig.

00:20:02.980 --> 00:20:05.890
And their latencies, the
variance between of the

00:20:05.890 --> 00:20:08.320
latencies as well as the actual
values of the latency

00:20:08.320 --> 00:20:09.900
were much much, much higher.

00:20:09.900 --> 00:20:12.120
And so, given what you've
just heard about garbage

00:20:12.120 --> 00:20:15.300
collection, you can see that
once the heap was large, these

00:20:15.300 --> 00:20:18.650
GC pauses were taking more
and more amount of time.

00:20:18.650 --> 00:20:21.130
And so that's what you see is
happening in these latencies.

00:20:21.130 --> 00:20:23.910
So some of those outliers were
probably several second long

00:20:23.910 --> 00:20:25.240
garbage collection pauses.

00:20:25.240 --> 00:20:27.690
And those are things that we
want to definitely avoid.

00:20:27.690 --> 00:20:28.180
JOHN MCCUTCHAN: Yeah.

00:20:28.180 --> 00:20:30.760
LOREENA LEE: So after seeing
this data, we were more

00:20:30.760 --> 00:20:34.910
motivated than ever to get
things under control.

00:20:34.910 --> 00:20:36.385
So we turned to the Chrome
Developer Tools.

00:20:36.385 --> 00:20:39.070
And If you haven't used
the tools before--

00:20:39.070 --> 00:20:41.100
I hope everyone in this room has
at least fiddled with them

00:20:41.100 --> 00:20:43.120
a little bit-- they're really,
really powerful.

00:20:43.120 --> 00:20:44.670
And they're getting better
and better every day.

00:20:44.670 --> 00:20:46.810
When we were first starting
out, some of these tools

00:20:46.810 --> 00:20:49.310
didn't really scale to
applications of Gmail size.

00:20:49.310 --> 00:20:51.960
But since then, we've forged
a relationship with the

00:20:51.960 --> 00:20:53.440
DevTools, and things
have gotten

00:20:53.440 --> 00:20:55.710
much, much, much better.

00:20:55.710 --> 00:20:58.130
Now we actually find that almost
anything we need to

00:20:58.130 --> 00:21:00.830
answer to we can find
in the DevTools.

00:21:00.830 --> 00:21:04.520
So to get to the DevTools, this
is what we affectionately

00:21:04.520 --> 00:21:06.840
call the hot dog menu, the
three bars you see in the

00:21:06.840 --> 00:21:09.530
upper right-hand corner of your
Chrome browser window.

00:21:09.530 --> 00:21:12.020
The hotdog menu, Tools,
and Developer Tools.

00:21:12.020 --> 00:21:13.740
JOHN MCCUTCHAN: It's not
the hamburger menu?

00:21:13.740 --> 00:21:15.135
LOREENA LEE: There's
hot debate.

00:21:15.135 --> 00:21:17.560
JOHN MCCUTCHAN: Yeah.

00:21:17.560 --> 00:21:19.000
LOREENA LEE: So once you open
up these tools, you'll see a

00:21:19.000 --> 00:21:21.030
powerful set of tools.

00:21:21.030 --> 00:21:23.110
Inside here, we have
a CPU profiler.

00:21:23.110 --> 00:21:24.250
We have a heap profiler.

00:21:24.250 --> 00:21:27.640
We have Timeline tools that can
tell you about your events

00:21:27.640 --> 00:21:29.690
that are happening in your
page, such as the garbage

00:21:29.690 --> 00:21:30.710
collection events.

00:21:30.710 --> 00:21:33.780
Also, things like paint
time, rendering time.

00:21:33.780 --> 00:21:36.060
All of these things you can
see in the DevTools.

00:21:36.060 --> 00:21:37.910
There's an interactive
JavaScript console.

00:21:37.910 --> 00:21:40.430
It can interact with
your application.

00:21:40.430 --> 00:21:41.670
So they're really powerful.

00:21:41.670 --> 00:21:43.920
But right now we're going to
talk about the part of the

00:21:43.920 --> 00:21:48.890
DevTools that we use to diagnose
these memory issues.

00:21:48.890 --> 00:21:51.620
The first thing I like to do is
go to the Memory Timeline.

00:21:51.620 --> 00:21:54.200
And this is in the Timeline
panel of your DevTools.

00:21:54.200 --> 00:21:57.460
And what you can do here is you
can see at the top there's

00:21:57.460 --> 00:21:59.480
actually multiple tabs here.

00:21:59.480 --> 00:22:02.110
There's an Events Timeline that
can show you the garbage

00:22:02.110 --> 00:22:04.490
collection pauses, like the
screenshot you saw earlier.

00:22:04.490 --> 00:22:06.800
And then here, we're
the Memory Panel

00:22:06.800 --> 00:22:08.750
and the Memory Timeline.

00:22:08.750 --> 00:22:11.040
At the top there, you
see the blue.

00:22:11.040 --> 00:22:12.810
And that's overall memory.

00:22:12.810 --> 00:22:16.250
And then down below, you have
the ability to see three

00:22:16.250 --> 00:22:17.180
different counts.

00:22:17.180 --> 00:22:19.660
And right now I only have the
dom node count enabled.

00:22:19.660 --> 00:22:22.790
But you can see the document
count, the dom node count, and

00:22:22.790 --> 00:22:23.595
the event listener account.

00:22:23.595 --> 00:22:27.090
And so these will tell you over
the timeline you recorded

00:22:27.090 --> 00:22:32.300
how many of each of these things
is currently live.

00:22:32.300 --> 00:22:35.290
So what you do is you take an
action or a sequence of

00:22:35.290 --> 00:22:37.960
actions that you identify
as possibly suspicious.

00:22:37.960 --> 00:22:39.330
You think that there
may be a leak in

00:22:39.330 --> 00:22:42.070
performing these actions.

00:22:42.070 --> 00:22:42.810
You start the timeline.

00:22:42.810 --> 00:22:45.410
You can perform these actions
a number of times.

00:22:45.410 --> 00:22:48.810
And so in this case, we
performed them six times.

00:22:48.810 --> 00:22:50.050
And then there's a little
garbage can

00:22:50.050 --> 00:22:51.500
button at the bottom.

00:22:51.500 --> 00:22:54.480
You can click that button, and
that'll force a full garbage

00:22:54.480 --> 00:22:56.240
collection.

00:22:56.240 --> 00:22:59.930
And if you suspect that this
action should not leave any

00:22:59.930 --> 00:23:03.370
dom nodes behind but that
number of nodes is not

00:23:03.370 --> 00:23:05.290
dropping back down to your
baseline, you have a pretty

00:23:05.290 --> 00:23:07.600
good indication that
there's a leak.

00:23:07.600 --> 00:23:10.160
So here we did the experiment
twice, just make sure.

00:23:10.160 --> 00:23:13.270
And we see that each time we
forced a GC, that number of

00:23:13.270 --> 00:23:16.150
dom nodes is not dropping back
down to the baseline.

00:23:16.150 --> 00:23:17.510
So we're pretty sure
we have a leak.

00:23:17.510 --> 00:23:19.560
This is an action that we've
identified that should be

00:23:19.560 --> 00:23:22.190
clean, but it's obviously not.

00:23:22.190 --> 00:23:24.710
JOHN MCCUTCHAN: By clean, you
mean there should be nothing

00:23:24.710 --> 00:23:25.720
in the graph afterwards?

00:23:25.720 --> 00:23:27.650
LOREENA LEE: We expect that the
actions should not leave

00:23:27.650 --> 00:23:28.540
behind any dom nodes.

00:23:28.540 --> 00:23:31.150
We think that we've cleaned
up after ourselves.

00:23:31.150 --> 00:23:32.440
So we obviously have not.

00:23:32.440 --> 00:23:34.880
So now what?

00:23:34.880 --> 00:23:37.300
I'm really excited to introduce
the Object Tracker.

00:23:37.300 --> 00:23:38.280
And this is brand new.

00:23:38.280 --> 00:23:41.990
This is currently only enabled
in Chrome Canary

00:23:41.990 --> 00:23:42.900
that you can get now.

00:23:42.900 --> 00:23:45.510
But you need to enable the
DevTools Experiments.

00:23:45.510 --> 00:23:47.040
And we'll give you instructions
on how to do

00:23:47.040 --> 00:23:51.120
that, DevTools Experiments, and
then the Object Tracker.

00:23:51.120 --> 00:23:52.870
And this is really cool because
it combines the best

00:23:52.870 --> 00:23:54.250
of both worlds.

00:23:54.250 --> 00:23:56.640
This combines the timeline
functionality, like the one I

00:23:56.640 --> 00:24:00.070
just showed, with the heap
profiler that is already

00:24:00.070 --> 00:24:03.360
existing in current
stable channel.

00:24:03.360 --> 00:24:05.590
And that heap profiler will tell
you all the objects that

00:24:05.590 --> 00:24:07.180
are in the heap at
any given time.

00:24:07.180 --> 00:24:09.830
When you collect a snapshot,
it'll show you everything

00:24:09.830 --> 00:24:12.390
that's in the heap that's
live at a given time.

00:24:12.390 --> 00:24:16.070
But here now, you can start
recording, and it'll take

00:24:16.070 --> 00:24:18.720
snapshots periodically through
that recording.

00:24:18.720 --> 00:24:22.900
And it'll tell you what objects
were live in that

00:24:22.900 --> 00:24:28.470
recording at any given time,
or I should say, that were

00:24:28.470 --> 00:24:30.410
allocated during that time.

00:24:30.410 --> 00:24:33.500
So let's look a little
bit more in detail.

00:24:33.500 --> 00:24:35.900
Here at the top, you see
some color-coded bars.

00:24:35.900 --> 00:24:38.210
These identify new objects
that were found that were

00:24:38.210 --> 00:24:39.890
allocated during the timeline.

00:24:39.890 --> 00:24:42.980
So I said that we take periodic
snapshots while we're

00:24:42.980 --> 00:24:43.690
doing this.

00:24:43.690 --> 00:24:47.300
And as you take a snapshot, it
does a full profile snapshot,

00:24:47.300 --> 00:24:48.920
heap profile.

00:24:48.920 --> 00:24:52.950
And it'll look for new objects
that weren't there the

00:24:52.950 --> 00:24:54.590
previous time.

00:24:54.590 --> 00:24:57.700
So here, you see that there
are 10 bars, and there's

00:24:57.700 --> 00:24:59.390
different colors.

00:24:59.390 --> 00:25:02.650
The blue bars indicate new
objects that were found during

00:25:02.650 --> 00:25:06.080
that time that are still live
at the end of the timeline.

00:25:06.080 --> 00:25:07.480
JOHN MCCUTCHAN: At the
end of the capture.

00:25:07.480 --> 00:25:08.900
LOREENA LEE: At the end
of the capture.

00:25:08.900 --> 00:25:11.550
So the end of this timeframe
that the whole

00:25:11.550 --> 00:25:13.080
recording was taken.

00:25:13.080 --> 00:25:15.080
The gray bars show that there
were new objects that were

00:25:15.080 --> 00:25:19.210
found at that point in time,
but they've since

00:25:19.210 --> 00:25:20.210
been garbage collected.

00:25:20.210 --> 00:25:24.270
So by the end of the capture,
those objects that are in gray

00:25:24.270 --> 00:25:27.250
now have been collected.

00:25:27.250 --> 00:25:30.900
You can also narrow in on any
of those bars to get more

00:25:30.900 --> 00:25:33.800
information about what exactly
was in that difference.

00:25:33.800 --> 00:25:35.990
JOHN MCCUTCHAN: Yeah.

00:25:35.990 --> 00:25:40.510
LOREENA LEE: And then down below
is the heap contents.

00:25:40.510 --> 00:25:43.770
JOHN MCCUTCHAN: The heap
contents is connected to the

00:25:43.770 --> 00:25:44.960
time window that you've
selected.

00:25:44.960 --> 00:25:45.310
LOREENA LEE: Right.

00:25:45.310 --> 00:25:47.800
JOHN MCCUTCHAN: So it's only
going to show objects that are

00:25:47.800 --> 00:25:50.360
alive that are within the time
range that you've picked.

00:25:50.360 --> 00:25:51.680
LOREENA LEE: Right.

00:25:51.680 --> 00:25:52.460
OK.

00:25:52.460 --> 00:25:55.100
I know it's hard to tell from
screenshots, so you probably

00:25:55.100 --> 00:25:56.350
want to see a demo.

00:25:58.410 --> 00:25:58.650
Let's see.

00:25:58.650 --> 00:26:01.180
So we wrote a simple mail-like
app, since we're talking about

00:26:01.180 --> 00:26:02.670
Gmail here.

00:26:02.670 --> 00:26:06.430
In Gmail, we cached messages
for better performance.

00:26:06.430 --> 00:26:10.350
In this little demo, we have
a cache of size 5.

00:26:10.350 --> 00:26:13.260
That means that, in theory, no
more than 5 messages should be

00:26:13.260 --> 00:26:14.600
in memory at any given time.

00:26:14.600 --> 00:26:17.794
So let's take a look.

00:26:17.794 --> 00:26:19.270
OK.

00:26:19.270 --> 00:26:22.010
So first we're going to start
off with our timeline.

00:26:22.010 --> 00:26:24.070
And you see that I'm
on the memory here.

00:26:24.070 --> 00:26:27.170
And let's go ahead and we'll
just look at dom node count to

00:26:27.170 --> 00:26:29.200
not confuse ourselves.

00:26:29.200 --> 00:26:30.280
And let's see.

00:26:30.280 --> 00:26:33.540
I said we have a cache
of size 5.

00:26:33.540 --> 00:26:35.100
One thing we should always
do is refresh.

00:26:35.100 --> 00:26:38.110
Make sure you're starting
with a clean slate.

00:26:38.110 --> 00:26:42.350
And we'll go ahead and read
those 5 messages.

00:26:42.350 --> 00:26:44.310
So we've now filled
up our cache.

00:26:44.310 --> 00:26:49.810
Let's read 5 more, and we'll do
a full garbage collection.

00:26:49.810 --> 00:26:51.776
JOHN MCCUTCHAN: Are we going
to start recording?

00:26:51.776 --> 00:26:52.260
LOREENA LEE: Oh, yes.

00:26:52.260 --> 00:26:53.680
We do need to be recording.

00:26:53.680 --> 00:26:54.070
OK.

00:26:54.070 --> 00:26:55.550
So the cache is full.

00:26:55.550 --> 00:27:01.590
Let's read 5 messages, let's
collect garbage, and let's

00:27:01.590 --> 00:27:03.680
stop the recording.

00:27:03.680 --> 00:27:07.390
So you see the blue bar at the
top shows you how much memory

00:27:07.390 --> 00:27:08.090
is being used.

00:27:08.090 --> 00:27:09.340
And we see this stairstep.

00:27:11.760 --> 00:27:14.740
This is when I clicked
the next message.

00:27:14.740 --> 00:27:17.480
You see there'll
be five steps.

00:27:17.480 --> 00:27:20.210
And you know, I'm pretty sure
I clicked that garbage can

00:27:20.210 --> 00:27:23.130
button, but I'm not seeing the
dom node count drop down.

00:27:23.130 --> 00:27:23.640
JOHN MCCUTCHAN: Yeah.

00:27:23.640 --> 00:27:25.900
LOREENA LEE: So let's try it
again, just to make sure.

00:27:25.900 --> 00:27:27.010
I'll record.

00:27:27.010 --> 00:27:28.260
Read 5 more messages.

00:27:32.480 --> 00:27:34.860
Click that.

00:27:34.860 --> 00:27:38.720
I'll expand it.

00:27:38.720 --> 00:27:40.460
It's dropping down, but
not quite as far as

00:27:40.460 --> 00:27:41.410
I expected it to.

00:27:41.410 --> 00:27:44.175
I expected it to be down
to the baseline.

00:27:44.175 --> 00:27:46.895
Our cache was already full, and
we've still got some dom

00:27:46.895 --> 00:27:47.910
nodes here.

00:27:47.910 --> 00:27:51.670
So now we're going to go over
to the Profile Panel, see if

00:27:51.670 --> 00:27:54.060
we can figure out
what's going on.

00:27:54.060 --> 00:27:56.560
Let's refresh, start
from the beginning.

00:27:56.560 --> 00:27:59.930
So this new Object Tracker, the
last one here, it's called

00:27:59.930 --> 00:28:00.980
Track Allocations.

00:28:00.980 --> 00:28:04.010
So this will run the heap
profiler continuously and

00:28:04.010 --> 00:28:06.620
collect these snapshots
periodically while we're

00:28:06.620 --> 00:28:08.200
interacting with our app.

00:28:08.200 --> 00:28:10.750
So we'll start this.

00:28:10.750 --> 00:28:16.150
And let's go ahead and
read 10 messages.

00:28:16.150 --> 00:28:19.560
7, 8, 9, 10.

00:28:19.560 --> 00:28:23.420
And we'll go ahead
and stop it.

00:28:23.420 --> 00:28:25.440
So once the snapshot is
loaded, we should

00:28:25.440 --> 00:28:26.470
see these 10 bars.

00:28:26.470 --> 00:28:29.990
1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

00:28:29.990 --> 00:28:34.300
We know our cache is
of size 5, right?

00:28:34.300 --> 00:28:36.580
So here we see the total.

00:28:36.580 --> 00:28:38.420
Let's scroll this up so
you guys can see it

00:28:38.420 --> 00:28:39.670
a little bit better.

00:28:41.690 --> 00:28:43.780
So we see these last 5 messages
that we read, and

00:28:43.780 --> 00:28:44.820
those are all blue.

00:28:44.820 --> 00:28:47.100
So we know that these are still
objects that are live in

00:28:47.100 --> 00:28:50.990
the graph at the end of this
whole timeline capture.

00:28:50.990 --> 00:28:53.030
But now we have this one blue
bar, this third one

00:28:53.030 --> 00:28:54.630
here, and it's blue.

00:28:54.630 --> 00:28:57.150
I'm expecting that we only have
5 messages in our cache,

00:28:57.150 --> 00:28:58.940
and I see that there's
something

00:28:58.940 --> 00:29:00.330
strange going on here.

00:29:00.330 --> 00:29:05.530
If we look at this message Aux
Data, which is our message

00:29:05.530 --> 00:29:07.790
headers, we actually can
look here we can

00:29:07.790 --> 00:29:08.620
see the object count.

00:29:08.620 --> 00:29:09.600
And there's 6.

00:29:09.600 --> 00:29:11.635
That confuses me, because I
expected that we had a cache

00:29:11.635 --> 00:29:14.070
of size 5, so I don't know why
we still have this sixth

00:29:14.070 --> 00:29:16.500
message that didn't
get collected.

00:29:16.500 --> 00:29:20.860
So we can actually zoom in
on any of these bars.

00:29:20.860 --> 00:29:23.190
And we can see exactly
the objects that were

00:29:23.190 --> 00:29:24.210
found in the diff.

00:29:24.210 --> 00:29:26.850
Basically, this is a diff
between this blue bar and the

00:29:26.850 --> 00:29:28.310
previous snapshot.

00:29:28.310 --> 00:29:30.180
We see that these objects
are still live.

00:29:30.180 --> 00:29:31.920
They're showing up here because
they're still live in

00:29:31.920 --> 00:29:35.250
the heap at the end of
this full timeline.

00:29:35.250 --> 00:29:37.820
So if I look at one of
these first ones--

00:29:37.820 --> 00:29:39.742
That's probably not a good one
because it's got some extra

00:29:39.742 --> 00:29:40.340
code in there.

00:29:40.340 --> 00:29:42.830
If I look at one of these here
that's all grey, we'll see

00:29:42.830 --> 00:29:43.490
nothing here.

00:29:43.490 --> 00:29:46.290
And this means that everything
that was found in this diff of

00:29:46.290 --> 00:29:49.330
snapshot, this snapshot that
was taken here, any new

00:29:49.330 --> 00:29:51.370
allocations here have since been
very garbage collected.

00:29:51.370 --> 00:29:52.500
And that's what we expect.

00:29:52.500 --> 00:29:55.240
But here we have this blue
bar, which confuses us.

00:29:55.240 --> 00:29:56.250
So let's take a look.

00:29:56.250 --> 00:29:58.330
We see that there's a message
Aux.Data here.

00:29:58.330 --> 00:30:01.830
We have a html div element
that's sticking around.

00:30:01.830 --> 00:30:04.280
And so we want to kind of see
what's retaining this.

00:30:04.280 --> 00:30:06.150
What's the retaining path
to these objects?

00:30:09.250 --> 00:30:13.420
So we see here that the
retaining path has this saved

00:30:13.420 --> 00:30:14.620
messages array.

00:30:14.620 --> 00:30:17.290
So this is index 0 in the
saved messages array.

00:30:17.290 --> 00:30:20.130
And what we see here is that
we actually have some extra

00:30:20.130 --> 00:30:22.980
array that's not a cache that's
holding on to this

00:30:22.980 --> 00:30:24.590
extra message, and
that's causing

00:30:24.590 --> 00:30:26.350
it to not be collected.

00:30:26.350 --> 00:30:29.170
And so we can actually go back
to the source and look and see

00:30:29.170 --> 00:30:32.050
what this saved messages array
is in this case and go ahead

00:30:32.050 --> 00:30:33.465
and make sure that we free
that reference up.

00:30:33.465 --> 00:30:35.010
And that will cause this
to get collected.

00:30:35.010 --> 00:30:35.350
JOHN MCCUTCHAN: Yeah.

00:30:35.350 --> 00:30:40.450
You can use the view of the
retaining path down here as a

00:30:40.450 --> 00:30:44.570
clue to where in your source
code this object was allocated

00:30:44.570 --> 00:30:46.680
and where it probably should
be cleaned up.

00:30:46.680 --> 00:30:47.390
LOREENA LEE: Right.

00:30:47.390 --> 00:30:49.930
Right.

00:30:49.930 --> 00:30:52.875
So that's the Object Tracker.

00:30:57.230 --> 00:30:59.280
Let's go back and see was
this really worth it.

00:30:59.280 --> 00:31:01.420
This is kind of a lot of work,
especially if you think about

00:31:01.420 --> 00:31:03.000
an application of Gmail size.

00:31:03.000 --> 00:31:05.910
The JavaScript is actually huge,
so going through and

00:31:05.910 --> 00:31:08.680
performing these techniques
actually can take some time.

00:31:08.680 --> 00:31:10.340
But was it really worth it?

00:31:10.340 --> 00:31:12.590
And I'd say a resounding yes.

00:31:12.590 --> 00:31:15.040
This is the data that we
collected using the

00:31:15.040 --> 00:31:17.260
performance memory API that
I mentioned earlier.

00:31:17.260 --> 00:31:18.930
This is actually a
graph of about a

00:31:18.930 --> 00:31:20.510
10month period in 2012.

00:31:20.510 --> 00:31:22.820
If you look far to the left,
you can see that memory was

00:31:22.820 --> 00:31:24.990
actually really far
out of control.

00:31:24.990 --> 00:31:26.070
JOHN MCCUTCHAN: And the
scale here is just

00:31:26.070 --> 00:31:27.690
relative to the median?

00:31:27.690 --> 00:31:28.530
LOREENA LEE: Right.

00:31:28.530 --> 00:31:31.470
Well, it's relative to
itself, I guess.

00:31:31.470 --> 00:31:32.140
Yeah.

00:31:32.140 --> 00:31:34.840
So the green line on the bottom
is actually the median.

00:31:34.840 --> 00:31:37.680
And the blue line up at the top
is the 99th percentile.

00:31:37.680 --> 00:31:40.050
So the blue line represents
mostly our power users.

00:31:40.050 --> 00:31:42.390
And you can see that for our
power users we've actually

00:31:42.390 --> 00:31:47.020
reduced memory in this 10-month
period by 80%, or

00:31:47.020 --> 00:31:48.330
more, actually.

00:31:48.330 --> 00:31:50.260
And for our median users--

00:31:50.260 --> 00:31:51.360
it's hard to tell on
this graph, just

00:31:51.360 --> 00:31:52.860
because of the scale--

00:31:52.860 --> 00:31:55.060
we actually reduced the amount
of memory that our median

00:31:55.060 --> 00:31:57.933
users was using by over 50%.

00:31:57.933 --> 00:31:58.780
JOHN MCCUTCHAN: Nice.

00:31:58.780 --> 00:32:00.660
LOREENA LEE: And you'll
see there's these two

00:32:00.660 --> 00:32:01.850
peaks on the blue line.

00:32:01.850 --> 00:32:04.470
And they're there on the other
lines as well, but the scale

00:32:04.470 --> 00:32:05.950
is not quite as obvious.

00:32:05.950 --> 00:32:08.560
And what these are actually
showing us is two regressions

00:32:08.560 --> 00:32:11.480
that we found that were in
Chrome itself, not in Gmail.

00:32:11.480 --> 00:32:13.350
JOHN MCCUTCHAN: So you
found bugs in V8?

00:32:13.350 --> 00:32:15.980
LOREENA LEE: We actually did
find some bugs in V8.

00:32:15.980 --> 00:32:17.200
And then these particular
cases, they were

00:32:17.200 --> 00:32:18.140
fragmentation bugs.

00:32:18.140 --> 00:32:20.960
So the garbage collector was
actually collecting garbage,

00:32:20.960 --> 00:32:23.590
but it was so fragmented and
in these tiny little chunks

00:32:23.590 --> 00:32:26.270
that Gmail wasn't able to use
them for new allocations.

00:32:26.270 --> 00:32:28.980
So what we noticed here was that
we mentioned there were

00:32:28.980 --> 00:32:30.800
three values that are being
reported by the

00:32:30.800 --> 00:32:32.150
performance.memory API.

00:32:32.150 --> 00:32:35.380
One of them was totalJSHeapSize,
which was the

00:32:35.380 --> 00:32:37.830
memory in use plus
the free space.

00:32:37.830 --> 00:32:41.530
And then there was the
usedJSHeapSize, which was the

00:32:41.530 --> 00:32:42.140
live objects.

00:32:42.140 --> 00:32:43.480
And we noticed that the
gap between these

00:32:43.480 --> 00:32:44.740
two lines was growing.

00:32:44.740 --> 00:32:46.680
So that's how we've realized
that it wasn't actually a

00:32:46.680 --> 00:32:49.350
Gmail problem that was causing
these two peaks.

00:32:49.350 --> 00:32:49.730
JOHN MCCUTCHAN: Yeah.

00:32:49.730 --> 00:32:51.860
LOREENA LEE: So once those were
fixed, we got things back

00:32:51.860 --> 00:32:52.580
under control.

00:32:52.580 --> 00:32:55.270
And we're in a pretty good
place right now.

00:32:55.270 --> 00:32:56.520
JOHN MCCUTCHAN: Looks like it.

00:32:58.960 --> 00:33:01.640
LOREENA LEE: Really, what we're
asking of everybody in

00:33:01.640 --> 00:33:06.370
this room, and hopefully beyond,
is to think about how

00:33:06.370 --> 00:33:09.280
your memory usage is affecting
your performance.

00:33:09.280 --> 00:33:13.490
And we recall that the higher
the memory footprint, the

00:33:13.490 --> 00:33:16.130
longer the latencies were and
the wider the variance.

00:33:16.130 --> 00:33:18.800
And so, really, these
GC pauses can be

00:33:18.800 --> 00:33:22.270
an performance killer.

00:33:22.270 --> 00:33:25.440
So ask yourself these questions
about your app.

00:33:25.440 --> 00:33:27.050
How much memory is
your page using?

00:33:27.050 --> 00:33:30.020
Are you using an amount of
memory that is reasonable for

00:33:30.020 --> 00:33:30.890
the size of your app?

00:33:30.890 --> 00:33:33.290
If you have a small, not so
interactive app, and you're

00:33:33.290 --> 00:33:36.820
using hundreds of megabytes of
memory, you're probably not

00:33:36.820 --> 00:33:39.130
using things most efficiently.

00:33:39.130 --> 00:33:40.950
JOHN MCCUTCHAN: Even for Gmail,
you were able to reduce

00:33:40.950 --> 00:33:44.940
memory usage for the 99th
percentile by 80% without

00:33:44.940 --> 00:33:46.480
impacting performance,
I imagine.

00:33:46.480 --> 00:33:47.950
LOREENA LEE: Well, without
negatively impacting

00:33:47.950 --> 00:33:48.300
performance.

00:33:48.300 --> 00:33:48.650
JOHN MCCUTCHAN: Yes.

00:33:48.650 --> 00:33:48.790
[INAUDIBLE]

00:33:48.790 --> 00:33:51.690
LOREENA LEE: We actually did
see a modest improvement in

00:33:51.690 --> 00:33:52.120
our latencies.

00:33:52.120 --> 00:33:54.550
And so it really does
make a difference.

00:33:54.550 --> 00:33:57.440
For Gmail, latencies are
hard to tell sometimes.

00:33:57.440 --> 00:34:00.700
But for the 99th percentile,
seeing a 10% improvement in

00:34:00.700 --> 00:34:02.745
latency is a big deal for us.

00:34:02.745 --> 00:34:04.140
JOHN MCCUTCHAN: Yeah.

00:34:04.140 --> 00:34:06.330
LOREENA LEE: So is your
page leak-free?

00:34:06.330 --> 00:34:09.550
When you first load your page,
versus after a day, after two

00:34:09.550 --> 00:34:14.070
days, after a week, is
the memory staying in

00:34:14.070 --> 00:34:15.239
a reasonable size?

00:34:15.239 --> 00:34:16.460
Is it growing over time?

00:34:16.460 --> 00:34:20.060
Or are you leaking memory
that you shouldn't be?

00:34:20.060 --> 00:34:21.790
And how frequently
are you GCing?

00:34:21.790 --> 00:34:24.190
We showed you some tools that
you can use to figure out how

00:34:24.190 --> 00:34:27.130
frequently you are GCing and
if those GC pauses are

00:34:27.130 --> 00:34:27.950
affecting your performance.

00:34:27.950 --> 00:34:28.340
JOHN MCCUTCHAN: Yeah.

00:34:28.340 --> 00:34:33.250
If you're seeing a lot of GCs,
that probably indicates that

00:34:33.250 --> 00:34:36.250
you're just allocating a ton of
objects inside JavaScript,

00:34:36.250 --> 00:34:38.580
which you likely don't
need to be doing.

00:34:38.580 --> 00:34:41.310
So that's just another indicator
that maybe there's a

00:34:41.310 --> 00:34:44.560
different way to structure your
page or your site so that

00:34:44.560 --> 00:34:48.969
the performance impact of
GCs can be lessened.

00:34:48.969 --> 00:34:50.219
LOREENA LEE: Right.

00:34:52.810 --> 00:34:54.790
And then we showed you
a bunch of tools.

00:34:54.790 --> 00:34:57.150
The Chrome Developer Tools
really are getting better and

00:34:57.150 --> 00:34:57.920
better every day.

00:34:57.920 --> 00:34:59.800
We have some really great
documentation on

00:34:59.800 --> 00:35:02.320
developers.google.com that
you can check out.

00:35:02.320 --> 00:35:04.630
There's a lot of tutorials on
there that you can use to get

00:35:04.630 --> 00:35:06.920
an introduction to
these tools.

00:35:06.920 --> 00:35:09.070
We'll actually also be
publishing an article that

00:35:09.070 --> 00:35:11.630
goes with this talk, so you can
get more information on

00:35:11.630 --> 00:35:14.850
how to enable the Object
Tracker and try it out.

00:35:14.850 --> 00:35:17.490
We'll also send you a
link to our demo, so

00:35:17.490 --> 00:35:20.000
you can follow along.

00:35:20.000 --> 00:35:20.480
JOHN MCCUTCHAN: Yeah.

00:35:20.480 --> 00:35:21.880
You can try this out yourself.

00:35:21.880 --> 00:35:24.000
You can try the continuous
snapshot technique.

00:35:24.000 --> 00:35:27.680
And the article will be
available next week.

00:35:27.680 --> 00:35:29.250
LOREENA LEE: And then, there's
the heap profiler.

00:35:29.250 --> 00:35:31.750
There's the Object Tracker
that we just showed.

00:35:31.750 --> 00:35:33.180
And play around with
everything.

00:35:33.180 --> 00:35:34.490
The Timeline is really cool.

00:35:34.490 --> 00:35:36.090
You can see, really,
everything that

00:35:36.090 --> 00:35:36.750
your page is doing.

00:35:36.750 --> 00:35:38.360
When you refresh it,
you can see how the

00:35:38.360 --> 00:35:40.380
page actually displays.

00:35:40.380 --> 00:35:42.790
There's a lot of great talks
this week that you guys should

00:35:42.790 --> 00:35:45.030
try to attend as many as you
can just to get more

00:35:45.030 --> 00:35:46.280
information.

00:35:47.980 --> 00:35:48.456
All right.

00:35:48.456 --> 00:35:49.410
That's it.

00:35:49.410 --> 00:35:49.970
Thank you.

00:35:49.970 --> 00:35:51.220
JOHN MCCUTCHAN: Thanks,
everyone.

00:35:56.940 --> 00:36:01.160
So for reference, there's a
link to the demo source.

00:36:01.160 --> 00:36:03.770
You can just hit it
with your browser.

00:36:03.770 --> 00:36:07.610
And here are the instructions
on how to enable this Object

00:36:07.610 --> 00:36:08.860
Tracker today.

00:36:11.600 --> 00:36:12.920
We can take questions.

00:36:12.920 --> 00:36:18.800
And be sure to rate the
talk using the app.

00:36:18.800 --> 00:36:21.420
AUDIENCE: Hi.

00:36:21.420 --> 00:36:25.340
Well, in an ideal world, your
application should not have

00:36:25.340 --> 00:36:25.820
memory leaks.

00:36:25.820 --> 00:36:27.700
But there's no ideal
world yet.

00:36:27.700 --> 00:36:32.340
And so my question is, is it
possible to have some kind of

00:36:32.340 --> 00:36:37.380
listener with JavaScript that,
once your application is about

00:36:37.380 --> 00:36:41.360
to hit a memory leak, with
JavaScript you will know about

00:36:41.360 --> 00:36:45.960
it, and instead of showing this
or that Jim page, you can

00:36:45.960 --> 00:36:49.600
take some actions before
actually losing everything?

00:36:49.600 --> 00:36:50.640
JOHN MCCUTCHAN: For those of
you who couldn't hear, the

00:36:50.640 --> 00:36:54.840
question was, could there be an
event channel that signals

00:36:54.840 --> 00:36:55.910
that a memory leak
has occurred?

00:36:55.910 --> 00:36:57.105
Is that correct?

00:36:57.105 --> 00:36:58.240
AUDIENCE: Is about to occur.

00:36:58.240 --> 00:36:59.150
JOHN MCCUTCHAN: Or
about to occur.

00:36:59.150 --> 00:37:00.295
Yes.

00:37:00.295 --> 00:37:03.810
The issue with that is that
there is no way to know the

00:37:03.810 --> 00:37:06.965
intention of the programmer.

00:37:06.965 --> 00:37:09.820
V8 can't possibly conclude that,
oh, this reference in

00:37:09.820 --> 00:37:13.440
the graph that's keeping this
value here is an error.

00:37:13.440 --> 00:37:16.040
Because maybe you actually
intended that

00:37:16.040 --> 00:37:17.780
reference to be there.

00:37:17.780 --> 00:37:21.150
Although it would be nice to
maybe have some event channels

00:37:21.150 --> 00:37:23.250
that tell you when you're
getting close--

00:37:23.250 --> 00:37:23.550
AUDIENCE: Yeah.

00:37:23.550 --> 00:37:24.820
Yeah. --to the heap
size or something.

00:37:24.820 --> 00:37:26.500
Yeah.

00:37:26.500 --> 00:37:28.040
LOREENA LEE: You could
definitely have some sort of

00:37:28.040 --> 00:37:31.500
listener that would poll this
performance.memory API and

00:37:31.500 --> 00:37:35.420
sort of see that the limit
is being approached.

00:37:35.420 --> 00:37:38.370
But there's not really any way
that you could say, hey, you

00:37:38.370 --> 00:37:40.700
know, you've been holding onto
this thing for a long time.

00:37:40.700 --> 00:37:41.720
Are you sure you wanted to?

00:37:41.720 --> 00:37:43.220
That's actually really,
really tricky.

00:37:43.220 --> 00:37:43.830
AUDIENCE: Oh.

00:37:43.830 --> 00:37:44.380
OK.

00:37:44.380 --> 00:37:44.990
OK, thanks.

00:37:44.990 --> 00:37:47.120
JOHN MCCUTCHAN: Thank you.

00:37:47.120 --> 00:37:49.720
AUDIENCE: So in terms of that
process that you guys went

00:37:49.720 --> 00:37:52.710
through last year, obviously
the example you showed here

00:37:52.710 --> 00:37:54.490
was ridiculously simple.

00:37:54.490 --> 00:37:57.270
So there's kind of like, OK,
we have a memory leak.

00:37:57.270 --> 00:38:01.740
What did you find were the
common actual sources of the

00:38:01.740 --> 00:38:04.310
memory leaks, like the
coding patterns that

00:38:04.310 --> 00:38:05.210
were causing them?

00:38:05.210 --> 00:38:09.270
And in a code base like Gmail,
which is hundreds of thousands

00:38:09.270 --> 00:38:12.290
of lines of code, how would
you just narrow it down?

00:38:12.290 --> 00:38:14.780
You have these objects, but then
you need to know where

00:38:14.780 --> 00:38:17.740
these objects are getting
allocated and where the bad

00:38:17.740 --> 00:38:19.060
stuff is actually happening.

00:38:19.060 --> 00:38:19.400
LOREENA LEE: Right.

00:38:19.400 --> 00:38:21.670
So we had the heap profiler.

00:38:21.670 --> 00:38:22.950
And the Object Tracker
is brand new.

00:38:22.950 --> 00:38:23.960
So it would have been
really awesome to

00:38:23.960 --> 00:38:24.820
have that last year.

00:38:24.820 --> 00:38:25.245
AUDIENCE: Yeah.

00:38:25.245 --> 00:38:25.670
Yeah.

00:38:25.670 --> 00:38:26.860
LOREENA LEE: That would have
made things a lot easier.

00:38:26.860 --> 00:38:27.390
AUDIENCE: For sure.

00:38:27.390 --> 00:38:29.790
LOREENA LEE: But using the
heap profiler, there's a

00:38:29.790 --> 00:38:32.010
technique that you can take
multiple snapshots and compare

00:38:32.010 --> 00:38:32.700
them to each other.

00:38:32.700 --> 00:38:35.820
So we performed some actions,
and we saw that memory was

00:38:35.820 --> 00:38:37.490
growing when we did something
as simple

00:38:37.490 --> 00:38:38.970
as compose and discard.

00:38:38.970 --> 00:38:42.080
If you compose a message and you
discard it, once the Undo

00:38:42.080 --> 00:38:42.620
[? butterbar ?]

00:38:42.620 --> 00:38:45.610
disappears, we really expected
that there should be nothing

00:38:45.610 --> 00:38:46.780
left over from that action.

00:38:46.780 --> 00:38:49.950
And so we could perform
something like that and then

00:38:49.950 --> 00:38:53.850
do these comparisons between
multiple heap profiles, heap

00:38:53.850 --> 00:38:57.630
snapshots, and see
what's lingering.

00:38:57.630 --> 00:39:00.040
And in those cases, we could
find certain objects, and we

00:39:00.040 --> 00:39:03.100
could look for those particular
objects that were

00:39:03.100 --> 00:39:04.400
being left behind.

00:39:04.400 --> 00:39:06.650
So that was one of them.

00:39:06.650 --> 00:39:09.650
I would say we have a few
different categories of bugs

00:39:09.650 --> 00:39:10.430
that we found.

00:39:10.430 --> 00:39:15.420
One of them was things like
infinitely growing caches, so

00:39:15.420 --> 00:39:17.350
things where we were saving
references to things that we

00:39:17.350 --> 00:39:19.010
didn't mean to.

00:39:19.010 --> 00:39:21.810
One case, we had a list of
callbacks that were supposed

00:39:21.810 --> 00:39:25.280
to be invoked when a particular
action occurred.

00:39:25.280 --> 00:39:26.890
And that action never occurred,
so we had an

00:39:26.890 --> 00:39:30.780
infinitely growing list
of callbacks.

00:39:30.780 --> 00:39:33.310
There was also a bunch of
cases where we had event

00:39:33.310 --> 00:39:35.970
listeners attached to
particular objects.

00:39:35.970 --> 00:39:38.050
And the event listener
was acting as a

00:39:38.050 --> 00:39:41.610
reference on those objects.

00:39:41.610 --> 00:39:42.900
The reason why I didn't
mention it here

00:39:42.900 --> 00:39:44.660
is the Closure team--

00:39:44.660 --> 00:39:47.150
we use the Closure Compiler--

00:39:47.150 --> 00:39:49.940
they've gone through some really
amazing hoops to try to

00:39:49.940 --> 00:39:53.020
eliminate this particular
coding problem.

00:39:53.020 --> 00:39:56.350
And so if you do use Closure and
you do have this problem

00:39:56.350 --> 00:39:58.870
where you have event listeners
that are causing references to

00:39:58.870 --> 00:40:02.440
particular objects sticking
around, newer versions of

00:40:02.440 --> 00:40:04.362
Closure should eliminate
that problem for you.

00:40:04.362 --> 00:40:04.834
AUDIENCE: OK.

00:40:04.834 --> 00:40:05.306
Great, thanks.

00:40:05.306 --> 00:40:07.790
JOHN MCCUTCHAN: Thanks.

00:40:07.790 --> 00:40:11.050
AUDIENCE: What would be the
ideal size for the young space

00:40:11.050 --> 00:40:13.355
to avoid frequent GC pause?

00:40:13.355 --> 00:40:15.160
How would you determine that?

00:40:15.160 --> 00:40:18.200
JOHN MCCUTCHAN: Well, the ideal
size would be infinite.

00:40:18.200 --> 00:40:20.220
You could just have it
grow forever, and

00:40:20.220 --> 00:40:22.610
you'd never GC pause.

00:40:22.610 --> 00:40:27.510
It's actually very difficult to
find that sweet spot of a

00:40:27.510 --> 00:40:30.190
practical number.

00:40:30.190 --> 00:40:34.420
So that's a difficult
question.

00:40:34.420 --> 00:40:36.300
There's not a straightforward
answer to it, I suppose.

00:40:36.300 --> 00:40:36.790
AUDIENCE: OK.

00:40:36.790 --> 00:40:39.070
So if I can actually
tack this on.

00:40:39.070 --> 00:40:40.120
JOHN MCCUTCHAN: Sure.

00:40:40.120 --> 00:40:43.860
AUDIENCE: In the GC pause that
you showed, freeing up two

00:40:43.860 --> 00:40:47.955
objects had enough room for E.
If there wasn't enough room

00:40:47.955 --> 00:40:52.730
for E, in that case would
that flush to old?

00:40:52.730 --> 00:40:53.420
JOHN MCCUTCHAN: No.

00:40:53.420 --> 00:40:54.460
Young generation.

00:40:54.460 --> 00:40:57.720
Collection occurs without an
old generation collection.

00:40:57.720 --> 00:41:00.080
AUDIENCE: But if the flushing
two objects didn't have enough

00:41:00.080 --> 00:41:00.820
room for E?

00:41:00.820 --> 00:41:01.580
JOHN MCCUTCHAN: Oh, I see.

00:41:01.580 --> 00:41:02.170
Yeah.

00:41:02.170 --> 00:41:06.530
At that point, you would fall
back to we have to do a full

00:41:06.530 --> 00:41:09.120
collection and try
and free memory.

00:41:09.120 --> 00:41:09.520
Yes.

00:41:09.520 --> 00:41:09.975
AUDIENCE: OK.

00:41:09.975 --> 00:41:10.430
Good.

00:41:10.430 --> 00:41:12.270
Thanks.

00:41:12.270 --> 00:41:13.272
JOHN MCCUTCHAN: Thanks.

00:41:13.272 --> 00:41:13.446
Yeah.

00:41:13.446 --> 00:41:13.620
Hey.

00:41:13.620 --> 00:41:16.760
AUDIENCE: So some of the graphs
you showed with the

00:41:16.760 --> 00:41:19.090
Gmail performance with the
different percentiles, that's

00:41:19.090 --> 00:41:22.010
actually awesome.

00:41:22.010 --> 00:41:25.780
So do you have any tips for
building tools like that?

00:41:25.780 --> 00:41:28.450
Are there any tools that you
know of that can help monitor

00:41:28.450 --> 00:41:31.090
your users in production?

00:41:31.090 --> 00:41:32.590
LOREENA LEE: You can actually
just call the

00:41:32.590 --> 00:41:35.290
performance.memory API
from your application

00:41:35.290 --> 00:41:36.000
at any given time.

00:41:36.000 --> 00:41:36.790
[INAUDIBLE].

00:41:36.790 --> 00:41:41.140
AUDIENCE: And that's for memory
and UI latency as well?

00:41:41.140 --> 00:41:43.710
LOREENA LEE: The latency is a
totally separate tracker.

00:41:43.710 --> 00:41:45.600
We have a separate tracker.

00:41:45.600 --> 00:41:46.750
We're actually out of
time, but we're

00:41:46.750 --> 00:41:49.180
happy to stick around.

00:41:49.180 --> 00:41:51.260
We'll probably head upstairs
to the Chrome

00:41:51.260 --> 00:41:54.050
office hours area.

00:41:54.050 --> 00:41:56.920
JOHN MCCUTCHAN: So anyone who
still has questions, you can

00:41:56.920 --> 00:41:59.830
just meet up upstairs in like
10 minutes, and we'll take

00:41:59.830 --> 00:42:00.450
questions there.

00:42:00.450 --> 00:42:02.030
LOREENA LEE: But the short
answer is that latency we

00:42:02.030 --> 00:42:04.330
track completely separately.

00:42:04.330 --> 00:42:05.350
JOHN MCCUTCHAN: Thank
you, everyone.

00:42:05.350 --> 00:42:06.600
LOREENA LEE: Thank you.

