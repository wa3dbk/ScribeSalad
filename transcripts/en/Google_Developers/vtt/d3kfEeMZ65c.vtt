WEBVTT
Kind: captions
Language: en

00:00:00.820 --> 00:00:02.910
IAN NI-LEWIS: Welcome,
audio diehards.

00:00:02.910 --> 00:00:06.770
We're so happy to
have you here.

00:00:06.770 --> 00:00:09.960
It's great to see that more
than 10 or 15 people would

00:00:09.960 --> 00:00:12.150
like to hear about high
performance audio on Android.

00:00:12.150 --> 00:00:13.400
We were running bets.

00:00:15.600 --> 00:00:17.080
So I'm Ian Ni-Lewis.

00:00:17.080 --> 00:00:19.390
I'm the developer relations
contact for audio.

00:00:19.390 --> 00:00:23.790
If you send audio questions to
our developers support email,

00:00:23.790 --> 00:00:26.880
probably I will answer them.

00:00:26.880 --> 00:00:29.550
But today, it's my great
pleasure to introduce a couple

00:00:29.550 --> 00:00:32.800
friends of mine from the
engineering team, Glenn Kasten

00:00:32.800 --> 00:00:36.970
and Raph Levien, who have
actually done a huge amount of

00:00:36.970 --> 00:00:41.710
work in the last couple of years
to set the standard for

00:00:41.710 --> 00:00:44.110
Android audio and
make it better.

00:00:44.110 --> 00:00:47.910
And you're going to be hearing
today some happy stories and

00:00:47.910 --> 00:00:53.850
some sad stories just
to prep you on that.

00:00:53.850 --> 00:00:57.175
But believe me, these guys have
advanced to state of the

00:00:57.175 --> 00:01:02.695
art for Android audio more than
anyone else and also Raph

00:01:02.695 --> 00:01:04.769
did some, too.

00:01:04.769 --> 00:01:07.020
I know you were going
to call me on that.

00:01:07.020 --> 00:01:08.750
Anyway, I start stop talking.

00:01:08.750 --> 00:01:12.170
Let's go ahead and welcome Glenn
Kasten to begin High

00:01:12.170 --> 00:01:14.122
Performance Audio on Android.

00:01:14.122 --> 00:01:19.790
[APPLAUSE]

00:01:19.790 --> 00:01:20.970
GLENN KASTEN: Hi, everyone.

00:01:20.970 --> 00:01:21.940
I'm Glenn Kasten.

00:01:21.940 --> 00:01:25.850
I'm on the Android audio team,
and my job is to provide great

00:01:25.850 --> 00:01:28.320
Android audio performance.

00:01:28.320 --> 00:01:35.470
I work with our OEMs and silicon
chip vendors to help

00:01:35.470 --> 00:01:38.840
them build devices that have
really great audio.

00:01:38.840 --> 00:01:40.810
And my goal is to provide
you developers

00:01:40.810 --> 00:01:42.360
really top notch audio.

00:01:42.360 --> 00:01:44.040
That's what I'm working on.

00:01:44.040 --> 00:01:45.520
I know what you want to hear.

00:01:45.520 --> 00:01:49.510
So let me disappoint you first,
as Ian was hinting at.

00:01:49.510 --> 00:01:51.230
We're not quite there yet.

00:01:51.230 --> 00:01:56.830
But the good news is we are
definitely making progress.

00:01:56.830 --> 00:01:59.280
So today, we're going to tell
you the story of what we've

00:01:59.280 --> 00:02:02.600
been doing so far and how you
can take advantage of the work

00:02:02.600 --> 00:02:03.470
we've done so far.

00:02:03.470 --> 00:02:05.230
We're also going to tell you
about what's coming up in the

00:02:05.230 --> 00:02:07.700
future in terms of our
performance goals.

00:02:07.700 --> 00:02:09.770
Now, performance could mean a
lot of different things to

00:02:09.770 --> 00:02:10.930
different people.

00:02:10.930 --> 00:02:13.900
But today, we're
going to focus.

00:02:13.900 --> 00:02:17.110
We're going to focus among all
these different things on just

00:02:17.110 --> 00:02:22.070
one area, which is
output latency.

00:02:22.070 --> 00:02:25.910
If you're interested in input
latency or other kinds of

00:02:25.910 --> 00:02:30.110
audio performance, definitely
check us out at office hours.

00:02:30.110 --> 00:02:32.340
Actually, check us out at office
hours anyway even if

00:02:32.340 --> 00:02:34.170
you're not interested
in something else.

00:02:34.170 --> 00:02:35.560
We want to talk to you about
the other things.

00:02:35.560 --> 00:02:38.360
But today, we're just going to
focus on output latency,

00:02:38.360 --> 00:02:40.580
because that's the area we've
made the most progress over

00:02:40.580 --> 00:02:42.930
the last two years.

00:02:42.930 --> 00:02:47.580
So with regards to latency, this
is a mock slide showing

00:02:47.580 --> 00:02:51.460
where we were, where we are now,
and where we want to be.

00:02:51.460 --> 00:02:54.720
But it doesn't really tell the
whole story of why did it take

00:02:54.720 --> 00:02:57.670
us on to get to this point,
what's the work that's been

00:02:57.670 --> 00:03:00.870
done, what's the work ahead,
what can you do as audio

00:03:00.870 --> 00:03:01.810
developers?

00:03:01.810 --> 00:03:03.780
So today, we're going
to really get into

00:03:03.780 --> 00:03:06.950
this in more detail.

00:03:06.950 --> 00:03:09.510
Explaining that is a really
big job, and so I brought

00:03:09.510 --> 00:03:13.060
along my buddy, Raph, who's
going to help me out.

00:03:13.060 --> 00:03:15.910
RAPH LEVIEN: Hi, my name is Raph
Levien, and I work on the

00:03:15.910 --> 00:03:17.470
Android Frameworks team.

00:03:17.470 --> 00:03:19.120
You may know me--

00:03:19.120 --> 00:03:21.320
Glenn, next slide--

00:03:21.320 --> 00:03:24.370
from such features
as Inconsolata,

00:03:24.370 --> 00:03:25.930
the programming font.

00:03:25.930 --> 00:03:27.690
Now, my day job--

00:03:27.690 --> 00:03:30.670
next slide-- my day job
is font and text

00:03:30.670 --> 00:03:31.570
rendering on Android.

00:03:31.570 --> 00:03:33.940
But in my spare time, I've
been building a software

00:03:33.940 --> 00:03:36.710
emulation of the Yamaha
DX7 synthesizer.

00:03:36.710 --> 00:03:40.100
I actually brought the original
with me today.

00:03:40.100 --> 00:03:44.780
But I've been building software
emulation, and I

00:03:44.780 --> 00:03:47.640
really wanted the emulation
to be as beautiful as the

00:03:47.640 --> 00:03:49.020
original synthesizer.

00:03:49.020 --> 00:03:51.070
And in fact, that's
how I met Glenn.

00:03:51.070 --> 00:03:52.720
I was trying to figure out
why I couldn't get better

00:03:52.720 --> 00:03:55.610
performance running my synth
engine on Android.

00:03:55.610 --> 00:03:59.620
And Glenn's name kept popping
up in email threads about

00:03:59.620 --> 00:04:00.940
audio latency.

00:04:00.940 --> 00:04:03.980
GLENN KASTEN: And I fixed
all of his problems.

00:04:03.980 --> 00:04:05.030
RAPH LEVIEN: Well, let's
just tell the story.

00:04:05.030 --> 00:04:08.190
It's a good story.

00:04:08.190 --> 00:04:10.580
GLENN KASTEN: When Raph first
contacted me, we were already

00:04:10.580 --> 00:04:12.320
looking into audio
performance.

00:04:12.320 --> 00:04:15.100
The Android Frameworks team,
the graphics team, and the

00:04:15.100 --> 00:04:17.680
apps team, they were all looking
into performance, too,

00:04:17.680 --> 00:04:21.130
mostly on the touch side and
on the graphic side.

00:04:21.130 --> 00:04:22.630
But the audio team was
definitely looking into

00:04:22.630 --> 00:04:23.600
performance, too.

00:04:23.600 --> 00:04:28.700
And overall, we were calling
this Project Butter.

00:04:28.700 --> 00:04:30.960
We were all thinking, how
can we make things

00:04:30.960 --> 00:04:34.030
more fast, more smooth?

00:04:34.030 --> 00:04:36.490
But when it came to audio,
there was really only one

00:04:36.490 --> 00:04:39.550
thing that everybody
knew for certain.

00:04:39.550 --> 00:04:43.120
The latency was just
too darn high--

00:04:43.120 --> 00:04:44.950
no question about that.

00:04:44.950 --> 00:04:46.840
RAPH LEVIEN: I think I was
in same situation as

00:04:46.840 --> 00:04:47.880
a lot of you guys.

00:04:47.880 --> 00:04:50.070
I was writing a musical
instrument that was supposed

00:04:50.070 --> 00:04:51.070
to be responsive.

00:04:51.070 --> 00:04:53.750
But I could hear a noticeable
delay between the time I hit a

00:04:53.750 --> 00:04:57.670
key and the time my
app responded.

00:04:57.670 --> 00:05:00.500
Latency is the delay as a signal
passes through the

00:05:00.500 --> 00:05:04.440
system, from your
app to sound.

00:05:04.440 --> 00:05:06.770
Some musicians, like organists,
are trained to deal

00:05:06.770 --> 00:05:08.980
with high latencies if
it's consistent.

00:05:08.980 --> 00:05:11.250
But most people are sensitive
to latencies greater than

00:05:11.250 --> 00:05:12.980
about 20 milliseconds.

00:05:12.980 --> 00:05:14.850
And some can't deal with
any latency at all.

00:05:14.850 --> 00:05:17.960
Any percussionists
or singers here?

00:05:17.960 --> 00:05:20.350
I wasn't asking for
zero latency.

00:05:20.350 --> 00:05:22.920
I would've been happy with 10,
maybe even 20 milliseconds.

00:05:22.920 --> 00:05:25.970
But I was hearing noticeable
delays-- over 100 milliseconds

00:05:25.970 --> 00:05:28.020
on some devices.

00:05:28.020 --> 00:05:30.480
This story is about how Glenn
helped me get my app's latency

00:05:30.480 --> 00:05:33.360
down to where it became a
truly playable synth.

00:05:33.360 --> 00:05:36.540
As you'll see, it took us some
work on both the Android side

00:05:36.540 --> 00:05:37.830
and the app side.

00:05:37.830 --> 00:05:40.000
So as we tell the story, we're
going to keep a running to do

00:05:40.000 --> 00:05:42.950
list of things we've done,
things we still need to do,

00:05:42.950 --> 00:05:45.400
and things you need to do in
your app to get low latency

00:05:45.400 --> 00:05:46.850
audio to work.

00:05:46.850 --> 00:05:48.400
GLENN KASTEN: Now, I know you're
all dragging out your

00:05:48.400 --> 00:05:50.370
notebooks now to start writing
down this to do list.

00:05:50.370 --> 00:05:51.270
But don't worry.

00:05:51.270 --> 00:05:53.450
We are going to show the to
do list at the end also.

00:05:56.080 --> 00:05:58.350
The first thing, the most
important thing, and you're

00:05:58.350 --> 00:05:59.880
going to see this throughout
the whole talk.

00:05:59.880 --> 00:06:02.370
It's going to keep coming up
over and over and over again,

00:06:02.370 --> 00:06:05.050
is measure everything.

00:06:05.050 --> 00:06:06.830
We do it, and we hope
you will too.

00:06:06.830 --> 00:06:08.710
RAPH LEVIEN: Before you can
make changes to improve

00:06:08.710 --> 00:06:11.040
performance, you have to have
an objective measurement of

00:06:11.040 --> 00:06:11.780
how bad it is.

00:06:11.780 --> 00:06:13.850
Otherwise, you're
flying blind.

00:06:13.850 --> 00:06:16.550
GLENN KASTEN: My brother, Steven
was a musician, and he

00:06:16.550 --> 00:06:18.080
also built electronics.

00:06:18.080 --> 00:06:20.520
And I told them about
my project working

00:06:20.520 --> 00:06:22.410
here on audio latency.

00:06:22.410 --> 00:06:26.770
And he encouraged me to get an
oscilloscope, because, lets

00:06:26.770 --> 00:06:30.780
face it, real engineers
have scopes.

00:06:30.780 --> 00:06:34.700
So even though I worked at
Google, I do have a budget.

00:06:34.700 --> 00:06:37.650
So I got the cheapest
oscilloscope I could find.

00:06:37.650 --> 00:06:41.070
And it's definitely not anything
fancy, not good for

00:06:41.070 --> 00:06:42.270
high speed communications.

00:06:42.270 --> 00:06:45.610
But it was certainly perfectly
adequate for audio.

00:06:45.610 --> 00:06:47.340
RAPH LEVIEN: The scope makes
it possible to get precise

00:06:47.340 --> 00:06:49.210
measurements, but the really
tricky part is getting

00:06:49.210 --> 00:06:52.080
accurately and reproducable
measurements, especially if we

00:06:52.080 --> 00:06:54.640
want to hopefully someday make
this part of the Android

00:06:54.640 --> 00:06:56.490
compatibility testing suite.

00:06:56.490 --> 00:06:59.200
We also need to make sure we
isolate audio output latency

00:06:59.200 --> 00:07:01.610
from the other sources of delay
in a system, like the

00:07:01.610 --> 00:07:03.480
audio input or the
touch panel.

00:07:03.480 --> 00:07:05.030
Glenn came up with a cool
way to do that.

00:07:07.600 --> 00:07:09.752
GLENN KASTEN: So besides the
scope, another great tool that

00:07:09.752 --> 00:07:13.280
I love is the LED, or lighting
emitting diode.

00:07:13.280 --> 00:07:15.670
I remember discovering the LED
when I was 12 years old, and

00:07:15.670 --> 00:07:17.350
I've been in love
ever since then.

00:07:17.350 --> 00:07:19.850
I think one of the greatest
things about a phone is the

00:07:19.850 --> 00:07:21.300
notification LED.

00:07:21.300 --> 00:07:26.440
It's so useful, so fast, and
yet it's really underused.

00:07:26.440 --> 00:07:30.220
I can measure audio latency with
an LED, a photo diode,

00:07:30.220 --> 00:07:31.410
and an oscilloscope.

00:07:31.410 --> 00:07:34.250
Basically, you just turn on the
LED at the same time as

00:07:34.250 --> 00:07:36.105
your application is outputting
audio data.

00:07:38.680 --> 00:07:40.980
Then measure the difference in
time between when you can

00:07:40.980 --> 00:07:44.680
detect the light from the LED
and when you can detect the

00:07:44.680 --> 00:07:46.380
audio signal.

00:07:46.380 --> 00:07:48.560
That difference is latency.

00:07:48.560 --> 00:07:51.760
So my brother was into
electronics.

00:07:51.760 --> 00:07:53.310
I was, too, especially
when I was younger.

00:07:53.310 --> 00:07:56.410
So I brought back my electronics
kit, and I started

00:07:56.410 --> 00:07:57.470
with a bread board design.

00:07:57.470 --> 00:07:59.560
This is it.

00:07:59.560 --> 00:08:02.290
Later on, one of our hardware
engineers, Clinton, helped me

00:08:02.290 --> 00:08:05.510
out, and he made be a real live
printed circuit board,

00:08:05.510 --> 00:08:07.090
which you can see here.

00:08:07.090 --> 00:08:09.000
No, it does not actually have
a red border on it.

00:08:09.000 --> 00:08:11.770
That's just a highlight.

00:08:11.770 --> 00:08:13.710
And here's the result with
an oscilloscope.

00:08:13.710 --> 00:08:16.960
Basically, the yellow trace is
the light detector from the

00:08:16.960 --> 00:08:19.060
LED to the photo diode.

00:08:19.060 --> 00:08:21.920
And the blue trace
is the audio.

00:08:21.920 --> 00:08:24.750
I unfortunately can't really
get into exact numbers.

00:08:24.750 --> 00:08:25.500
They don't let me here.

00:08:25.500 --> 00:08:27.680
But let's just say that it
was a really big number--

00:08:27.680 --> 00:08:29.320
way too big.

00:08:29.320 --> 00:08:31.880
So let's talk about why.

00:08:31.880 --> 00:08:34.120
RAPH LEVIEN: Latency in the real
world is complex, but in

00:08:34.120 --> 00:08:36.280
software, it generally boils
down to one thing--

00:08:36.280 --> 00:08:37.530
chains of buffers.

00:08:39.640 --> 00:08:42.070
GLENN KASTEN: Here's a typical
un-optimized audio pipeline,

00:08:42.070 --> 00:08:44.720
the kind that I found when I
first started looking at this

00:08:44.720 --> 00:08:46.810
problem a couple years ago.

00:08:46.810 --> 00:08:49.110
As you can see from this
diagram, we have four buffers

00:08:49.110 --> 00:08:52.010
of 1,024 frames or 23

00:08:52.010 --> 00:08:55.080
milliseconds each at 44 kilohertz.

00:08:55.080 --> 00:08:58.580
And that's just in the audio
hardware abstraction layer, or

00:08:58.580 --> 00:09:00.290
HAL, and the kernel driver.

00:09:00.290 --> 00:09:03.280
That doesn't even count the
buffers in the media server,

00:09:03.280 --> 00:09:07.800
in the DSP, in the mixer,
certainly not in the

00:09:07.800 --> 00:09:09.960
application.

00:09:09.960 --> 00:09:11.630
RAPH LEVIEN: In case that's
not clear, that's a huge

00:09:11.630 --> 00:09:12.400
amount of buffering.

00:09:12.400 --> 00:09:15.220
There's 92 milliseconds of
latency right there.

00:09:15.220 --> 00:09:16.990
If you're an audio developer,
you've got to be asking

00:09:16.990 --> 00:09:18.830
yourself, why are the
buffers so big?

00:09:18.830 --> 00:09:20.835
And why are there
so many of them?

00:09:20.835 --> 00:09:23.120
GLENN KASTEN: So there is a
technical explanation, which

00:09:23.120 --> 00:09:24.370
we're going to get into today.

00:09:24.370 --> 00:09:27.290
But I also think there's a
social explanation, and we'll

00:09:27.290 --> 00:09:30.000
hint at it throughout the
talk today, too, also.

00:09:30.000 --> 00:09:31.320
RAPH LEVIEN: Let's start
with the technical.

00:09:31.320 --> 00:09:33.150
It has to do with power
consumption.

00:09:33.150 --> 00:09:36.510
The larger the interval between
CPU core wake ups, the

00:09:36.510 --> 00:09:38.620
less power needed.

00:09:38.620 --> 00:09:39.960
GLENN KASTEN: As you
know, mobile

00:09:39.960 --> 00:09:41.390
phones run on batteries.

00:09:41.390 --> 00:09:42.930
Batteries have limited life.

00:09:42.930 --> 00:09:46.100
So the CPU switches on and off
very, very frequently between

00:09:46.100 --> 00:09:48.330
normal state and low
power state.

00:09:48.330 --> 00:09:51.570
The size of each audio buffer
basically puts a lower bound

00:09:51.570 --> 00:09:54.450
on the amount of time that the
CPU can be asleep before it

00:09:54.450 --> 00:09:57.940
has to wake up again and process
the next audio buffer.

00:09:57.940 --> 00:10:01.820
To a certain extent, that
defines both your power

00:10:01.820 --> 00:10:04.890
consumption and your
potential latency.

00:10:04.890 --> 00:10:07.500
And if you want to reduce power,
you have to add more

00:10:07.500 --> 00:10:11.310
buffering so the CPU doesn't
have to wake up as often.

00:10:11.310 --> 00:10:14.610
As for the social component, my
theory is that buffering is

00:10:14.610 --> 00:10:18.400
just a really quick and easy
way to fix audio glitches.

00:10:18.400 --> 00:10:21.680
If you hear a glitch, almost
always it seems that if you

00:10:21.680 --> 00:10:25.220
just make your buffers bigger,
it'll make it go away.

00:10:25.220 --> 00:10:29.920
And unless you actively police
buffer sizes, they're going to

00:10:29.920 --> 00:10:31.860
continue to increase
over time.

00:10:31.860 --> 00:10:33.930
RAPH LEVIEN: And other than a
devoted band of developers,

00:10:33.930 --> 00:10:36.310
like you and me, it didn't
seem like anyone in the

00:10:36.310 --> 00:10:39.010
Android world has had a
compelling incentive to reduce

00:10:39.010 --> 00:10:40.250
buffer sizes.

00:10:40.250 --> 00:10:42.420
I think a lot of us suspected
that there wasn't actually any

00:10:42.420 --> 00:10:44.590
particularly good reason
for latency to be

00:10:44.590 --> 00:10:45.450
as high as it was.

00:10:45.450 --> 00:10:48.530
Maybe the buffers were just
bigger than they had to be.

00:10:48.530 --> 00:10:50.070
GLENN KASTEN: Sounds
simple, huh?

00:10:50.070 --> 00:10:52.230
Well, this turned out
to be a pretty easy

00:10:52.230 --> 00:10:55.100
hypothesis to disprove.

00:10:55.100 --> 00:10:56.450
I tried an experiment.

00:10:56.450 --> 00:10:58.820
Remember, we started with
four buffers of 23

00:10:58.820 --> 00:10:59.880
milliseconds each.

00:10:59.880 --> 00:11:02.080
So I just said, OK, let's
make them smaller.

00:11:02.080 --> 00:11:03.180
Let's have fewer of them.

00:11:03.180 --> 00:11:07.660
Instead of four of 23, I went
down to two of 12 or 13, then

00:11:07.660 --> 00:11:08.360
two of six.

00:11:08.360 --> 00:11:10.670
And eventually, on one device, I
was even able to get down to

00:11:10.670 --> 00:11:12.500
two buffers of three
milliseconds.

00:11:12.500 --> 00:11:14.450
I didn't try to change the
system architecture or

00:11:14.450 --> 00:11:16.460
anything else, just
the buffers.

00:11:16.460 --> 00:11:17.770
And amazingly, it worked.

00:11:22.160 --> 00:11:23.670
Audio still played.

00:11:23.670 --> 00:11:25.650
The latency went down
dramatically.

00:11:25.650 --> 00:11:27.830
I was done.

00:11:27.830 --> 00:11:29.170
RAPH LEVIEN: You were done?

00:11:29.170 --> 00:11:29.580
Are you sure?

00:11:29.580 --> 00:11:34.710
GLENN KASTEN: Well, you knew the
talk wouldn't be over now.

00:11:34.710 --> 00:11:36.430
It did work most of the time.

00:11:36.430 --> 00:11:38.600
But every once in awhile,
I heard a

00:11:38.600 --> 00:11:41.620
click, a pop, an underrun.

00:11:41.620 --> 00:11:44.550
And this really did make
me sick to my stomach.

00:11:44.550 --> 00:11:48.430
I know it's hard for me to
show it today, but I felt

00:11:48.430 --> 00:11:50.390
awful every time I heard
those clicks.

00:11:50.390 --> 00:11:52.590
And I knew this was not
going to be so easy.

00:11:52.590 --> 00:11:54.540
RAPH LEVIEN: And I've have
a lot of experience with

00:11:54.540 --> 00:11:55.570
underruns myself.

00:11:55.570 --> 00:11:57.370
I heard them on my synthesizer
when I had

00:11:57.370 --> 00:11:58.620
too many voices playing.

00:11:58.620 --> 00:12:01.020
I think it's worth talking a
little bit about the methods

00:12:01.020 --> 00:12:03.020
we used to detect them.

00:12:03.020 --> 00:12:03.720
GLENN KASTEN: Definitely.

00:12:03.720 --> 00:12:07.080
But first, let's listen to
some underruns together.

00:12:07.080 --> 00:12:07.510
Don't worry.

00:12:07.510 --> 00:12:11.240
It's only a few seconds, but we
want all of us to use the

00:12:11.240 --> 00:12:12.350
same terminology.

00:12:12.350 --> 00:12:14.000
In this clip, we're going
to first hear

00:12:14.000 --> 00:12:15.970
a few shorter clicks.

00:12:15.970 --> 00:12:18.380
Followed by some longer
dropouts.

00:12:18.380 --> 00:12:20.902
They're all underruns.

00:12:20.902 --> 00:12:38.710
[MUSIC PLAYING]

00:12:38.710 --> 00:12:41.330
GLENN KASTEN: Did everybody
hear those?

00:12:41.330 --> 00:12:43.470
We're a little worried, because
in a room this large,

00:12:43.470 --> 00:12:44.760
there's quite a bit of reverb.

00:12:44.760 --> 00:12:48.120
And what Raph and I have found
is that when you're listening

00:12:48.120 --> 00:12:51.730
with speakers, and especially
in a room with a lot of

00:12:51.730 --> 00:12:54.050
reverb, that it's harder to
hear those underruns.

00:12:54.050 --> 00:12:57.080
So that's one reason why we
personally prefer to listen

00:12:57.080 --> 00:12:58.790
for audio problems
with headphones.

00:12:58.790 --> 00:13:01.290
Or as you'll soon see, we
actually like to look for them

00:13:01.290 --> 00:13:02.540
visually, too.

00:13:06.540 --> 00:13:08.390
So we heard the underruns.

00:13:08.390 --> 00:13:09.580
Let's look at them visually.

00:13:09.580 --> 00:13:11.130
I mentioned we were going to.

00:13:11.130 --> 00:13:14.460
Here is a long 15 millisecond
underrun in the audio editor

00:13:14.460 --> 00:13:16.760
tool called Audacity.

00:13:16.760 --> 00:13:17.400
RAPH LEVIEN: Those long
underruns are

00:13:17.400 --> 00:13:19.030
pretty easy to spot.

00:13:19.030 --> 00:13:20.770
GLENN KASTEN: Yeah, but
unfortunately, I wasn't just

00:13:20.770 --> 00:13:21.960
hearing those long ones.

00:13:21.960 --> 00:13:23.360
I was also hearing
short clicks.

00:13:23.360 --> 00:13:25.150
And those were really hard
to find with Audacity.

00:13:28.580 --> 00:13:29.360
Here's one here.

00:13:29.360 --> 00:13:32.620
This is only 64 frames, I
believe, which is 1 and 1/2

00:13:32.620 --> 00:13:37.230
milliseconds, I think at either
44 or 48 kilohertz.

00:13:37.230 --> 00:13:39.820
And it took me a long time
to find this one.

00:13:39.820 --> 00:13:41.250
I just didn't have
the patience to

00:13:41.250 --> 00:13:42.560
keep looking for these.

00:13:42.560 --> 00:13:44.570
RAPH LEVIEN: Yeah, they're
tricky to spot in time domain.

00:13:44.570 --> 00:13:47.650
But in the frequency domain,
underruns pop out.

00:13:47.650 --> 00:13:50.050
Here's that same area after
a Fourier transform.

00:13:50.050 --> 00:13:51.820
See those spikes on the right?

00:13:51.820 --> 00:13:54.690
Those regularly spaced
spikes mean trouble.

00:13:54.690 --> 00:13:57.990
You use Frequency Domain View,
and then you can binary search

00:13:57.990 --> 00:14:00.445
to help zoom in on the
shortest underruns.

00:14:00.445 --> 00:14:01.400
GLENN KASTEN: So let's
get back to my

00:14:01.400 --> 00:14:03.230
problem, my latency problem.

00:14:03.230 --> 00:14:05.880
I notice that when I reduced
buffer sizes, the latency went

00:14:05.880 --> 00:14:08.200
down, but I also was hearing
these clicks.

00:14:08.200 --> 00:14:09.040
RAPH LEVIEN: So we were wrong.

00:14:09.040 --> 00:14:12.090
The buffers were just about as
big as they had to be to keep

00:14:12.090 --> 00:14:14.220
the audio from glitching.

00:14:14.220 --> 00:14:15.600
They weren't just about
saving power.

00:14:15.600 --> 00:14:17.020
They were also keeping
it clean.

00:14:17.020 --> 00:14:17.880
GLENN KASTEN:

00:14:17.880 --> 00:14:20.420
GLENN KASTEN: Now we needed to
figure out why, why those

00:14:20.420 --> 00:14:21.550
glitches were happening.

00:14:21.550 --> 00:14:24.380
And while I was working on the
system problem, it turned out

00:14:24.380 --> 00:14:26.410
Raph had also collected some
data of his own, which we're

00:14:26.410 --> 00:14:28.140
going to look at right now.

00:14:28.140 --> 00:14:28.830
RAPH LEVIEN: That's right.

00:14:28.830 --> 00:14:30.430
Isn't this beautiful?

00:14:30.430 --> 00:14:32.560
Maybe I should take a couple
of minutes and explain what

00:14:32.560 --> 00:14:34.340
this plot is showing.

00:14:34.340 --> 00:14:37.750
What I was measuring is the
start time and the end time of

00:14:37.750 --> 00:14:39.420
every open SL callback.

00:14:39.420 --> 00:14:42.800
This is by far the most useful
information you can log.

00:14:42.800 --> 00:14:45.260
At first, I was doing this to
profile how long my own code

00:14:45.260 --> 00:14:45.750
took to run.

00:14:45.750 --> 00:14:47.760
But I ended up learning
a lot about how the

00:14:47.760 --> 00:14:49.360
system worked as well.

00:14:49.360 --> 00:14:52.970
So let's start with a little
bit of background.

00:14:52.970 --> 00:14:56.110
GLENN KASTEN: So we used Open
SLES from Cronos Group.

00:14:56.110 --> 00:15:00.440
And in our implementation, the
audio runs on a separate

00:15:00.440 --> 00:15:02.390
thread inside of your
application process.

00:15:02.390 --> 00:15:04.910
And the thread runs in a tight
little loop that looks a lot

00:15:04.910 --> 00:15:07.300
like a helix, like a spring.

00:15:07.300 --> 00:15:10.875
Each time through the loop, our
Open SLES implementation

00:15:10.875 --> 00:15:14.050
will call your buffer completion
callback handler to

00:15:14.050 --> 00:15:15.920
generate the next buffer.

00:15:15.920 --> 00:15:18.070
RAPH LEVIEN: The time between
two successive callbacks is

00:15:18.070 --> 00:15:19.320
the cycle time.

00:15:19.320 --> 00:15:20.890
GLENN KASTEN: And ideally,
the cycle time should be

00:15:20.890 --> 00:15:21.710
consistent.

00:15:21.710 --> 00:15:25.460
In part, it should be equal
to the size of one buffer.

00:15:25.460 --> 00:15:27.390
RAPH LEVIEN: So in an ideal
world, if we plotted the

00:15:27.390 --> 00:15:30.070
callback time against the
expected callback time, we'd

00:15:30.070 --> 00:15:31.880
see a perfectly straight line.

00:15:31.880 --> 00:15:33.140
Of course, nothing is perfect.

00:15:33.140 --> 00:15:35.510
If we plot the time that
callbacks actually arrive

00:15:35.510 --> 00:15:37.970
against the expected time of
arrival, we're going to see

00:15:37.970 --> 00:15:39.640
some deviations.

00:15:39.640 --> 00:15:42.360
Each little squiggle in this
graph represents a deviation

00:15:42.360 --> 00:15:44.300
from the ideal callback
timing.

00:15:44.300 --> 00:15:46.400
But to tell the truth, I have
a hard time using this graph

00:15:46.400 --> 00:15:48.400
to tell exactly how bad
the deviation is.

00:15:48.400 --> 00:15:51.360
Instead, I like to view the
data a little differently.

00:15:51.360 --> 00:15:54.490
Instead of looking at callback
times, I just look at how

00:15:54.490 --> 00:15:57.510
early or late each
callback arrived.

00:15:57.510 --> 00:16:00.610
Here, the y-axis is a
measurement of deviation from

00:16:00.610 --> 00:16:04.250
ideal timing amplified, so
we can see it better.

00:16:04.250 --> 00:16:05.560
You can think this as
a measurement of

00:16:05.560 --> 00:16:06.720
the system's jitter.

00:16:06.720 --> 00:16:08.700
I've also changed the
x-axis a bit.

00:16:08.700 --> 00:16:10.990
Instead of being measured in
time, it's simply a count of

00:16:10.990 --> 00:16:12.290
how many callbacks
have arrived.

00:16:12.290 --> 00:16:15.010
That way, I can compare the
jitter of two different

00:16:15.010 --> 00:16:16.180
systems, even if they
have different

00:16:16.180 --> 00:16:18.390
callback cycle times.

00:16:18.390 --> 00:16:20.040
GLENN KASTEN: So now that we
know how we're measuring and

00:16:20.040 --> 00:16:24.600
displaying this jitter, let's
look at some real world data.

00:16:24.600 --> 00:16:26.360
RAPH LEVIEN: So this is taken
from a build of Ice Cream

00:16:26.360 --> 00:16:29.446
Sandwich that's close to
the one Glenn used.

00:16:29.446 --> 00:16:31.220
GLENN KASTEN: It looks
interesting.

00:16:31.220 --> 00:16:33.800
But why does it slope down
and to the right?

00:16:33.800 --> 00:16:37.780
RAPH LEVIEN: That downward trend
is actually a difference

00:16:37.780 --> 00:16:40.770
in timing between the audio
clock and the system clock.

00:16:40.770 --> 00:16:43.490
So let's look at the
corrected version.

00:16:43.490 --> 00:16:46.500
Now remember an ideal system
would show all zeros on the

00:16:46.500 --> 00:16:49.210
y-axis, meaning that every
buffer completion callback had

00:16:49.210 --> 00:16:50.640
arrived exactly on time.

00:16:50.640 --> 00:16:52.600
Of course, no system
is perfect.

00:16:52.600 --> 00:16:55.590
So what you'd expect to see in a
good, real world system is a

00:16:55.590 --> 00:16:59.150
tight cluster of values right
around the zero mark.

00:16:59.150 --> 00:17:03.270
GLENN KASTEN: It looks kind of
like that, mostly, at least

00:17:03.270 --> 00:17:05.960
the green part.

00:17:05.960 --> 00:17:08.210
RAPH LEVIEN: Yeah, but you also
see a lot of callbacks

00:17:08.210 --> 00:17:10.040
arriving five or 10
milliseconds late.

00:17:10.040 --> 00:17:13.730
That's manageable, even
if it's not ideal.

00:17:13.730 --> 00:17:15.980
GLENN KASTEN: But I don't like
those red ones there,

00:17:15.980 --> 00:17:17.410
especially at the beginning--

00:17:17.410 --> 00:17:18.220
those outliers.

00:17:18.220 --> 00:17:23.010
They look like 20, 30,
35 milliseconds late.

00:17:23.010 --> 00:17:23.560
RAPH LEVIEN: Dang.

00:17:23.560 --> 00:17:27.099
That's with those giant buffers
were for, not just to

00:17:27.099 --> 00:17:30.080
save power, but to cover for the
fact that the audio system

00:17:30.080 --> 00:17:33.100
was delivering some of these
callbacks really late.

00:17:33.100 --> 00:17:35.590
GLENN KASTEN: Now, this really
bothered me, because Android

00:17:35.590 --> 00:17:36.800
is not a real time system.

00:17:36.800 --> 00:17:40.750
But we had configured the thread
priorities for audio to

00:17:40.750 --> 00:17:44.310
be nice little minus 19 for the
system mixer and then nice

00:17:44.310 --> 00:17:47.910
little minus 16 for application
threads.

00:17:47.910 --> 00:17:50.550
And the schedule really should
not have been doing this.

00:17:50.550 --> 00:17:53.770
It just didn't make sense.

00:17:53.770 --> 00:17:56.350
Just to give you background on
nice values, basically, if

00:17:56.350 --> 00:18:00.295
this pie is all the available
CPU time, than numerically low

00:18:00.295 --> 00:18:03.690
or nice values, like minus 19
and minus 16 should get more

00:18:03.690 --> 00:18:04.970
of the CPU pie.

00:18:04.970 --> 00:18:08.270
And they should be scheduled
on a regular cadence, not

00:18:08.270 --> 00:18:11.910
waiting 10s of milliseconds
and certainly not 35.

00:18:11.910 --> 00:18:13.610
RAPH LEVIEN: So those jitter
outliers who saw in the

00:18:13.610 --> 00:18:15.720
previous slide, those are going
to cause underruns.

00:18:15.720 --> 00:18:17.950
What was happening in the
system to cause them?

00:18:17.950 --> 00:18:20.010
GLENN KASTEN: That's exactly
what I wanted to know.

00:18:20.010 --> 00:18:21.470
So I dug a lot deeper.

00:18:21.470 --> 00:18:24.040
Now, I'm not a Linux Kernel
expert, but I do have a

00:18:24.040 --> 00:18:25.940
background in real time
operating systems.

00:18:25.940 --> 00:18:27.850
I used to write real
time Kernels.

00:18:27.850 --> 00:18:30.920
And so I feel very comfortable
jumping in and doing some

00:18:30.920 --> 00:18:32.950
system measurements at
the current level.

00:18:32.950 --> 00:18:35.820
At the time, we didn't have the
sys trace tool, which you

00:18:35.820 --> 00:18:36.910
may have heard of.

00:18:36.910 --> 00:18:40.300
And I didn't know about the
existing Linux tools for

00:18:40.300 --> 00:18:41.770
tracing, like f trace.

00:18:41.770 --> 00:18:43.770
So instead, I just built
my own custom

00:18:43.770 --> 00:18:45.940
context switch tracer.

00:18:45.940 --> 00:18:47.080
This is what it looked like.

00:18:47.080 --> 00:18:49.570
Basically, every time there was
a context switch, it would

00:18:49.570 --> 00:18:52.270
log information about
this context

00:18:52.270 --> 00:18:53.270
switch into a ring buffer.

00:18:53.270 --> 00:18:56.140
The information was basically
the next thread about to run

00:18:56.140 --> 00:18:58.900
and whatever was the current
system monotonic time.

00:19:01.600 --> 00:19:03.460
Then what I would do is
I would play audio.

00:19:03.460 --> 00:19:06.250
And at the same time, I would
run my context switch tracer.

00:19:06.250 --> 00:19:10.060
And whenever I heard a glitch,
I would look and see what was

00:19:10.060 --> 00:19:12.960
happening in the system at
the time of that glitch.

00:19:12.960 --> 00:19:15.540
And it took me a long,
long time.

00:19:15.540 --> 00:19:17.870
But eventually, I found
what looked to me to

00:19:17.870 --> 00:19:21.180
be the smoking gun.

00:19:23.870 --> 00:19:26.250
RAPH LEVIEN: This an excerpt of
Glenn's context switch log.

00:19:26.250 --> 00:19:28.880
The first 12 lines are exactly
what we want to see.

00:19:28.880 --> 00:19:31.200
The playback thread and the
audio track thread wake up, do

00:19:31.200 --> 00:19:33.950
their thing, and then go back to
sleep on a regular cadence.

00:19:33.950 --> 00:19:36.110
Those last four lines
look wrong.

00:19:36.110 --> 00:19:37.400
GLENN KASTEN: And by the
way, this is real data.

00:19:37.400 --> 00:19:40.040
All the data you're seeing
here today is real.

00:19:40.040 --> 00:19:42.310
This was the smoking gun.

00:19:42.310 --> 00:19:45.840
So let's look at that same data
as a sequence diagram.

00:19:45.840 --> 00:19:47.780
RAPH LEVIEN: You can see the
pattern here-- first, playback

00:19:47.780 --> 00:19:49.690
runs, then audio track
runs, and then

00:19:49.690 --> 00:19:51.380
lather, rinse, and repeat.

00:19:51.380 --> 00:19:53.490
But what happens near the
end of the trace?

00:19:53.490 --> 00:19:55.490
Right when the playback thread
was supposed to wake up,

00:19:55.490 --> 00:19:57.480
another task gets scheduled
instead.

00:19:57.480 --> 00:20:00.070
This is in spite of the fact
that the audio has a higher

00:20:00.070 --> 00:20:01.600
priority-- nice minus 19.

00:20:01.600 --> 00:20:02.770
How could that have happened?

00:20:02.770 --> 00:20:04.590
GLENN KASTEN: Well, it all comes
down to a Linux Kernel

00:20:04.590 --> 00:20:06.510
module, which is called
the completely fair

00:20:06.510 --> 00:20:09.230
scheduler, or CFS.

00:20:09.230 --> 00:20:11.010
Earlier, I showed this
slide showing nice

00:20:11.010 --> 00:20:12.960
values in the CPU pie.

00:20:12.960 --> 00:20:15.590
If you look really closely,
there's a very important

00:20:15.590 --> 00:20:16.450
caveat there.

00:20:16.450 --> 00:20:19.000
It says huge oversimplification.

00:20:19.000 --> 00:20:21.460
Nice values are not
a quota system.

00:20:21.460 --> 00:20:25.720
RAPH LEVIEN: The CFS scheduler
allocates CPU time fairly and

00:20:25.720 --> 00:20:28.430
proportionally to the nice
level in the long term.

00:20:28.430 --> 00:20:32.700
But it does not guarantee
wake up time.

00:20:32.700 --> 00:20:35.310
In these two timing diagrams,
the dark bars ar e audio

00:20:35.310 --> 00:20:37.630
threads, and the light bars
are other threads.

00:20:37.630 --> 00:20:40.610
To CFS, the top and bottom
diagrams are completely

00:20:40.610 --> 00:20:42.320
equivalent, but to an
audio programmer,

00:20:42.320 --> 00:20:43.950
they're completely different.

00:20:43.950 --> 00:20:45.200
We want the pattern on top.

00:20:49.300 --> 00:20:52.190
GLENN KASTEN: So I tried
working around CFS.

00:20:52.190 --> 00:20:54.920
CFS has a lot of tuning
parameters.

00:20:54.920 --> 00:20:58.230
The most important one is the
scheduling interval or

00:20:58.230 --> 00:20:59.160
scheduling quantum.

00:20:59.160 --> 00:21:02.480
There are other parameters,
such as how often it will

00:21:02.480 --> 00:21:03.810
check for fairness.

00:21:03.810 --> 00:21:06.720
And when I turned those down to
really small numbers, I was

00:21:06.720 --> 00:21:09.630
able to get rid of most of
the audio underruns.

00:21:09.630 --> 00:21:11.980
But it turned out that all that
messing around with CFS

00:21:11.980 --> 00:21:14.060
parameter used a
lot more power.

00:21:14.060 --> 00:21:17.370
And even worse, it caused the
overall system throughput for

00:21:17.370 --> 00:21:19.930
non-audio threads to
go down because of

00:21:19.930 --> 00:21:21.710
excessive context switching.

00:21:21.710 --> 00:21:25.440
And worst of all, it didn't even
solve my audio underrun

00:21:25.440 --> 00:21:26.600
problem completely.

00:21:26.600 --> 00:21:29.430
It just reduced the frequency.

00:21:29.430 --> 00:21:31.070
RAPH LEVIEN: The most effective
tweaks just reduce

00:21:31.070 --> 00:21:32.980
the time slice that each
thread gets before the

00:21:32.980 --> 00:21:34.320
scheduler reevaluates.

00:21:34.320 --> 00:21:36.970
It doesn't change the core
algorithm, which is to try to

00:21:36.970 --> 00:21:38.570
be fair to every thread.

00:21:38.570 --> 00:21:40.400
But in our case, we don't
want to be fair.

00:21:40.400 --> 00:21:43.170
We want audio to go to the front
of the line every time.

00:21:43.170 --> 00:21:45.750
Reducing the time slice just
causes more content switching,

00:21:45.750 --> 00:21:47.290
which uses more power.

00:21:47.290 --> 00:21:49.070
GLENN KASTEN: So from my real
time operating system

00:21:49.070 --> 00:21:51.820
background working on kernels,
I knew about fixed priority

00:21:51.820 --> 00:21:52.410
scheduling--

00:21:52.410 --> 00:21:53.810
it's a very old concept--

00:21:53.810 --> 00:21:56.150
and I desperately wanted
to use it.

00:21:56.150 --> 00:21:59.060
The basic idea is that you
always run the highest

00:21:59.060 --> 00:22:01.930
priority ready to run task,
no matter what.

00:22:01.930 --> 00:22:05.070
And if you assign your
priorities correctly and

00:22:05.070 --> 00:22:08.920
appropriately, your system will
work, no matter what.

00:22:08.920 --> 00:22:10.680
RAPH LEVIEN: In Linux, this
means using a scheduling

00:22:10.680 --> 00:22:11.910
policy called SCHED FIFO.

00:22:11.910 --> 00:22:14.910
A lot of audio developers know
about SCHED FIFO, and we know

00:22:14.910 --> 00:22:17.280
that there are plenty of Linux
desktop programs that use it,

00:22:17.280 --> 00:22:19.200
and Android apps that try.

00:22:19.200 --> 00:22:20.500
But it doesn't work
in Android.

00:22:20.500 --> 00:22:22.330
On Ice Cream Sandwich,
it did nothing.

00:22:22.330 --> 00:22:24.960
And in Jelly Bean, been asking
for SCHED FIFO causes thread

00:22:24.960 --> 00:22:26.636
creation to fail.

00:22:26.636 --> 00:22:28.270
GLENN KASTEN: That's because
we disabled it

00:22:28.270 --> 00:22:29.450
for user mode threads.

00:22:29.450 --> 00:22:31.200
RAPH LEVIEN: Why did
you do that?

00:22:31.200 --> 00:22:32.642
GLENN KASTEN: Not me.

00:22:32.642 --> 00:22:35.840
Our assistant team was afraid of
denial of service, because

00:22:35.840 --> 00:22:39.020
basically, one errant SCHED FIFO
thread could hog the CPU

00:22:39.020 --> 00:22:40.720
and take down the
whole system.

00:22:40.720 --> 00:22:44.260
And yet we still handled
our callbacks on time.

00:22:44.260 --> 00:22:47.580
So I went back to our system
team, and I tried to make

00:22:47.580 --> 00:22:48.940
another case for SCHED FIFO.

00:22:53.740 --> 00:22:56.710
I showed them slides with
numbers and statistics and

00:22:56.710 --> 00:22:57.700
power measurements.

00:22:57.700 --> 00:23:00.690
And this time, they sent me a
buddy, a Kernel expert named

00:23:00.690 --> 00:23:04.040
Dima, who you may
run into today.

00:23:04.040 --> 00:23:04.830
He's here.

00:23:04.830 --> 00:23:07.260
Dima helped me navigate the
issue and figure out how to

00:23:07.260 --> 00:23:09.430
mitigate the denial
of service risk.

00:23:09.430 --> 00:23:11.620
The answer turned out to be
based on a Kernel feature that

00:23:11.620 --> 00:23:13.660
actually Google started working
on several years ago

00:23:13.660 --> 00:23:17.450
in 2006 called Control
Groups, or C Groups.

00:23:17.450 --> 00:23:19.180
RAPH LEVIEN: Cgroups is
a system for resource

00:23:19.180 --> 00:23:19.620
accounting.

00:23:19.620 --> 00:23:21.920
You can use it for all kinds
of things, like setting CPU

00:23:21.920 --> 00:23:23.980
and memory quotas for different
processes or

00:23:23.980 --> 00:23:26.890
charging for cloud servers
by the CPU hour.

00:23:26.890 --> 00:23:29.260
In the case of Android, it lets
us prevent audio threads

00:23:29.260 --> 00:23:31.270
from ever exceeding
its CPU budget.

00:23:31.270 --> 00:23:35.120
And that mitigates the denial
of service attack.

00:23:35.120 --> 00:23:37.540
GLENN KASTEN: So in the end, the
system team did agree we

00:23:37.540 --> 00:23:40.900
could run audio threads at a
fixed priority if we used

00:23:40.900 --> 00:23:43.540
Cgroups to stay within the
budget they gave us, which was

00:23:43.540 --> 00:23:47.390
a whopping 5% of the CPU.

00:23:47.390 --> 00:23:49.980
Later on, we got that budget
increased, but actually

00:23:49.980 --> 00:23:52.720
starting with only 5% turned
out to be a really good

00:23:52.720 --> 00:23:54.920
constraint for us.

00:23:54.920 --> 00:23:58.970
It forced us to reduce the CPU
footprint of the audio system.

00:23:58.970 --> 00:24:00.420
RAPH LEVIEN: Keep that number
in mind for later.

00:24:00.420 --> 00:24:02.590
For now, it's important to
understand that SCHED FIFO

00:24:02.590 --> 00:24:05.120
priority only applies to threads
that are created by

00:24:05.120 --> 00:24:05.885
the audio system.

00:24:05.885 --> 00:24:08.150
You can't do it for
your own threads.

00:24:08.150 --> 00:24:10.200
So that means if you want the
lowest latency, you need to

00:24:10.200 --> 00:24:13.490
run your audio code on
an audio thread.

00:24:13.490 --> 00:24:15.920
In practice, that means you need
to do your processing in

00:24:15.920 --> 00:24:17.450
a buffer callback.

00:24:17.450 --> 00:24:19.590
That means writing your
sound engine in C++

00:24:19.590 --> 00:24:21.900
and using Open SLES.

00:24:21.900 --> 00:24:24.320
And of course, not doing your
engine in Java means you don't

00:24:24.320 --> 00:24:26.880
have to worry about pauses from
the Garbage Collector.

00:24:26.880 --> 00:24:28.650
GLENN KASTEN: But you are still
subject to the audio

00:24:28.650 --> 00:24:30.130
Cgroup budget.

00:24:30.130 --> 00:24:32.360
We'll discuss budgets
later on.

00:24:32.360 --> 00:24:34.590
But first, Raph, show us
some more numbers.

00:24:34.590 --> 00:24:35.180
RAPH LEVIEN: Sure.

00:24:35.180 --> 00:24:38.500
Let's see how well that change
to SCHED FIFO worked.

00:24:38.500 --> 00:24:39.830
This is a little misleading.

00:24:39.830 --> 00:24:44.300
But the build I measured
contains some other fixes

00:24:44.300 --> 00:24:45.180
besides SCHED FIFO.

00:24:45.180 --> 00:24:47.510
But it's essentially accurate.

00:24:47.510 --> 00:24:50.000
You can see that where Ice Cream
Sandwich jitter was all

00:24:50.000 --> 00:24:52.510
over the place, on Jelly Bean,
it's clumped in a tight band

00:24:52.510 --> 00:24:53.440
right around zero.

00:24:53.440 --> 00:24:55.340
The problem is solved.

00:24:55.340 --> 00:24:57.450
GLENN KASTEN: Woo-hoo!

00:24:57.450 --> 00:24:59.200
Well, not so fast.

00:24:59.200 --> 00:25:01.960
Remember that in order to get
that reduction in jitter, we

00:25:01.960 --> 00:25:05.100
had agreed to a really tight
budget for audio, at the time

00:25:05.100 --> 00:25:07.970
only 5% of the CPU.

00:25:07.970 --> 00:25:11.090
Unfortunately, when I profiled
the audio subsystem, on some

00:25:11.090 --> 00:25:14.750
devices, it took longer than
5% just to run our mixer or

00:25:14.750 --> 00:25:17.460
our sample reconverter
and audio effects,

00:25:17.460 --> 00:25:19.470
like reverb and EQ.

00:25:19.470 --> 00:25:22.810
And it looked like I had a
massive optimization task in

00:25:22.810 --> 00:25:26.970
front of me, because we had that
5% for his application.

00:25:26.970 --> 00:25:29.020
RAPH LEVIEN: And to be fair,
that subsystem is doing a lot

00:25:29.020 --> 00:25:30.790
of work, especially if effects
are turned on.

00:25:30.790 --> 00:25:33.040
What was frustrating to
me is that it was work

00:25:33.040 --> 00:25:34.290
that I didn't want.

00:25:34.290 --> 00:25:36.820
I'm not dependent on any
one sample rate.

00:25:36.820 --> 00:25:38.640
I can do my own mixing.

00:25:38.640 --> 00:25:41.270
And I spent weeks with a signal
analyzer determining

00:25:41.270 --> 00:25:45.995
the exact physical properties of
that synthesizer's digital

00:25:45.995 --> 00:25:49.150
to analog converter hardware to
build a precise emulation.

00:25:49.150 --> 00:25:51.070
I didn't want to add any
one size fits all

00:25:51.070 --> 00:25:53.840
effects on top of that.

00:25:53.840 --> 00:25:56.140
GLENN KASTEN: My big aha moment
was when I realized

00:25:56.140 --> 00:25:59.950
that pretty much every audio
developer feels the same way,

00:25:59.950 --> 00:26:01.910
every developer who's interested
in low latency

00:26:01.910 --> 00:26:03.810
audio, anyway.

00:26:03.810 --> 00:26:07.700
So instead of trying to optimize
our system audio

00:26:07.700 --> 00:26:09.670
path, I just bypassed it.

00:26:09.670 --> 00:26:11.350
And I call this the fast path.

00:26:11.350 --> 00:26:12.902
Here's how it works.

00:26:12.902 --> 00:26:15.620
The top section basically
is running

00:26:15.620 --> 00:26:17.760
under the old CFS scheduler.

00:26:17.760 --> 00:26:21.520
That includes our normal mixer,
normal track switch,

00:26:21.520 --> 00:26:24.230
support resampling, they support
mixing, they support

00:26:24.230 --> 00:26:26.220
effects, things like that.

00:26:26.220 --> 00:26:27.830
The bottom is the fast path.

00:26:27.830 --> 00:26:31.470
And here, the low latency
applications send their audio

00:26:31.470 --> 00:26:36.470
directly into the fast mixer,
which then drive the hardware

00:26:36.470 --> 00:26:37.870
abstraction layer.

00:26:37.870 --> 00:26:41.940
And they all run under the
SCHED FIFO policy.

00:26:41.940 --> 00:26:43.100
RAPH LEVIEN: And they're
limited to the

00:26:43.100 --> 00:26:45.300
audio budget of 5%.

00:26:45.300 --> 00:26:47.460
GLENN KASTEN: Yeah, 5%.

00:26:47.460 --> 00:26:49.630
We're actually able to negotiate
that up a little bit

00:26:49.630 --> 00:26:52.820
later, but there still
is a budget.

00:26:52.820 --> 00:26:55.150
Now remember, earlier we were
talking about power.

00:26:55.150 --> 00:26:59.580
And one of the reasons why
buffers were so big was to

00:26:59.580 --> 00:27:02.490
reduce the CPU wake
up frequency.

00:27:02.490 --> 00:27:06.520
So when we used the low latency
path, it does increase

00:27:06.520 --> 00:27:07.700
power consumption.

00:27:07.700 --> 00:27:10.590
Fortunately, one of our audio
engineers, our audio tech

00:27:10.590 --> 00:27:14.880
lead, Eric, added another
feature called the Deep Buffer

00:27:14.880 --> 00:27:17.980
Path, which is used, for
example, music playback when

00:27:17.980 --> 00:27:19.640
your phone is in your pocket.

00:27:19.640 --> 00:27:23.070
And that is recommended when
you're trying to conserve

00:27:23.070 --> 00:27:25.750
power instead of latency.

00:27:25.750 --> 00:27:27.680
RAPH LEVIEN: So at this point
in time, I'd been following

00:27:27.680 --> 00:27:30.220
Glenn's work pretty closely, I
was very excited to try out

00:27:30.220 --> 00:27:31.260
this new fast path.

00:27:31.260 --> 00:27:34.050
I had just gotten a shiny new
Nexus 4, so I flashed a build

00:27:34.050 --> 00:27:36.550
onto my device, loaded
up my synthesizer,

00:27:36.550 --> 00:27:39.650
and nothing, no change.

00:27:39.650 --> 00:27:40.970
GLENN KASTEN: No change?

00:27:40.970 --> 00:27:42.520
RAPH LEVIEN: Well,
almost no change.

00:27:42.520 --> 00:27:45.310
There was some reduction in
latency, but nowhere nearly as

00:27:45.310 --> 00:27:46.520
much as I would have liked.

00:27:46.520 --> 00:27:49.200
Keep in mind, I'd already made
all of the obvious changes.

00:27:49.200 --> 00:27:51.650
I had rewritten my synthesis
engine in C++.

00:27:51.650 --> 00:27:54.800
I was running in the open SL
callback, so my code would run

00:27:54.800 --> 00:27:56.820
at that same high priority
scheduling.

00:27:56.820 --> 00:27:59.410
The obvious conclusion was
that my app was to blame.

00:27:59.410 --> 00:28:01.050
So I started profiling.

00:28:01.050 --> 00:28:02.680
What I found surprised
me a little bit.

00:28:02.680 --> 00:28:05.240
When I looked at my jitter
measurements in the new build,

00:28:05.240 --> 00:28:06.930
they were terrible.

00:28:06.930 --> 00:28:09.590
I knew Glenn had measured much
better jitter than this in his

00:28:09.590 --> 00:28:11.620
build, so I asked him
what was going on.

00:28:11.620 --> 00:28:14.080
GLENN KASTEN: I was really
stumped too until I asked Raph

00:28:14.080 --> 00:28:16.690
was sample rate he was using,
and he said 44.1, which is

00:28:16.690 --> 00:28:20.300
what was used on the Nexus
7 and the Galaxy Nexus.

00:28:20.300 --> 00:28:24.670
But it turns out the Nexus 4
runs natively at 48 kilohertz.

00:28:24.670 --> 00:28:26.750
RAPH LEVIEN: So my buffers
had to go through

00:28:26.750 --> 00:28:27.840
the sample rate converter.

00:28:27.840 --> 00:28:32.150
And the sample rate converter
is not on the fast path.

00:28:32.150 --> 00:28:35.200
Here's another plot that
shows a related issue.

00:28:35.200 --> 00:28:36.750
This isn't as bad as
the first one.

00:28:36.750 --> 00:28:38.580
There's only about a five
millisecond variation

00:28:38.580 --> 00:28:39.490
in start time here.

00:28:39.490 --> 00:28:40.930
But there's something
weird about it.

00:28:40.930 --> 00:28:42.980
The stripes in the data make me
think I'm looking at some

00:28:42.980 --> 00:28:45.290
kind of periodic process,
not just random noise.

00:28:45.290 --> 00:28:48.460
Let's zoom in and see if
we can find a pattern.

00:28:48.460 --> 00:28:50.395
GLENN KASTEN: Yeah, that looks
like a pattern to me.

00:28:50.395 --> 00:28:52.050
RAPH LEVIEN: It's
pretty regular.

00:28:52.050 --> 00:28:55.190
Looks like every 16 buffers,
I get my callback late.

00:28:55.190 --> 00:28:57.390
It turns out this was because
of another assumption I had

00:28:57.390 --> 00:29:00.160
made that didn't hold
true on the Nexus 4.

00:29:00.160 --> 00:29:02.550
I had set my buffer size
to 256, which was

00:29:02.550 --> 00:29:03.720
a convenient size.

00:29:03.720 --> 00:29:06.150
GLENN KASTEN: What Raph didn't
know at the time was that on

00:29:06.150 --> 00:29:11.030
the Nexus 4, our native buffer
size was 240 frames, not 256.

00:29:11.030 --> 00:29:14.730
And the greatest common divisor
of those two is--

00:29:14.730 --> 00:29:17.380
RAPH LEVIEN: 16.

00:29:17.380 --> 00:29:20.090
So that's the next item on your
to do list-- adapt your

00:29:20.090 --> 00:29:22.390
buffer size and sample
rate to match what

00:29:22.390 --> 00:29:23.530
the system is using.

00:29:23.530 --> 00:29:25.100
But how do you know what
buffer size and

00:29:25.100 --> 00:29:28.520
sample rate to use?

00:29:28.520 --> 00:29:30.280
This is something--
next slide--

00:29:30.280 --> 00:29:32.900
this is something that not
only is there variation

00:29:32.900 --> 00:29:35.040
between devices, but
it can change even

00:29:35.040 --> 00:29:36.980
across Android versions.

00:29:36.980 --> 00:29:39.780
In the early days, I struggled
with this a lot.

00:29:39.780 --> 00:29:42.670
GLENN KASTEN: I asked Raph what
does he want in the next

00:29:42.670 --> 00:29:45.310
version of the Android
audio platform to

00:29:45.310 --> 00:29:46.230
better support apps.

00:29:46.230 --> 00:29:49.120
And the top of this list was an
API to return this kind of

00:29:49.120 --> 00:29:49.760
information--

00:29:49.760 --> 00:29:52.880
native buffer size, native
sample rate.

00:29:52.880 --> 00:29:55.380
And that shift in
API level 17--

00:29:55.380 --> 00:29:57.740
we'll give you a link
to how to do that at

00:29:57.740 --> 00:29:59.440
the end of this talk.

00:29:59.440 --> 00:30:01.440
RAPH LEVIEN: Here's a snippet
from my app showing how I use

00:30:01.440 --> 00:30:03.835
a new sample rate and buffer
size properties to set up my

00:30:03.835 --> 00:30:04.835
synth engine.

00:30:04.835 --> 00:30:07.350
After I hooked it up, I found
that my synth went from eight

00:30:07.350 --> 00:30:08.980
voices to 20.

00:30:08.980 --> 00:30:11.870
Finally, I was beating the
30-year-old synthesizer I was

00:30:11.870 --> 00:30:14.190
trying to emulate.

00:30:14.190 --> 00:30:17.210
Now, let's take a look at an
audible glitch that was really

00:30:17.210 --> 00:30:18.470
difficult to track down.

00:30:18.470 --> 00:30:19.970
GLENN KASTEN: You're going to
want to pay special attention

00:30:19.970 --> 00:30:22.490
to this, because even though
we are going to be using

00:30:22.490 --> 00:30:25.460
Raph's code as an example here
today, we've seen similar

00:30:25.460 --> 00:30:30.080
issues to this throughout the
audio platform and in other

00:30:30.080 --> 00:30:31.470
applications.

00:30:31.470 --> 00:30:34.050
And it's really hard
to track down.

00:30:34.050 --> 00:30:36.190
RAPH LEVIEN: Here's a plot
of the bug in action.

00:30:36.190 --> 00:30:38.380
What you're seeing is the start
and end times of each

00:30:38.380 --> 00:30:39.300
buffer callback.

00:30:39.300 --> 00:30:41.280
Start time is blue, the
end time is red.

00:30:41.280 --> 00:30:44.420
Most of the time the start and
end times are so close that

00:30:44.420 --> 00:30:46.020
you almost can't tell
them apart.

00:30:46.020 --> 00:30:47.320
What's happening at the
beginning here?

00:30:47.320 --> 00:30:49.430
Let's zoom in and
check it out.

00:30:49.430 --> 00:30:50.360
Here's a closer look.

00:30:50.360 --> 00:30:52.810
The callback started
right on time.

00:30:52.810 --> 00:30:55.140
But the end time is
way out there.

00:30:55.140 --> 00:30:58.120
It looks like the callback
took about 16

00:30:58.120 --> 00:31:00.030
milliseconds to process.

00:31:00.030 --> 00:31:02.360
That was enough to cause a
dropout and skip a couple of

00:31:02.360 --> 00:31:04.540
buffers, which is what all of
the subsequent callbacks that

00:31:04.540 --> 00:31:07.520
recorded is showing up
10 milliseconds late.

00:31:07.520 --> 00:31:08.440
GLENN KASTEN: This time
I didn't have an

00:31:08.440 --> 00:31:09.600
easy answer for Raph.

00:31:09.600 --> 00:31:12.770
But we did have a new tool for
investigating performance

00:31:12.770 --> 00:31:14.210
problems, sys trace.

00:31:14.210 --> 00:31:15.880
And I know that that
would be good for

00:31:15.880 --> 00:31:19.500
investigating this problem.

00:31:19.500 --> 00:31:22.430
Sys trace basically collects the
same kind of data that I'd

00:31:22.430 --> 00:31:25.000
been collecting with
my manual home brew

00:31:25.000 --> 00:31:26.310
context switch recorder.

00:31:26.310 --> 00:31:29.050
But it's much easier to use and
has a really attractive

00:31:29.050 --> 00:31:30.300
user interface.

00:31:32.650 --> 00:31:35.330
We're going to show you a sys
trace first of some good audio

00:31:35.330 --> 00:31:37.980
playback and then
a bad sys trace.

00:31:37.980 --> 00:31:39.660
First, here's a sys
trace of audio

00:31:39.660 --> 00:31:41.430
playback working correctly.

00:31:41.430 --> 00:31:43.960
You're going to see every five
milliseconds the fast mixer

00:31:43.960 --> 00:31:47.980
thread is the one in red.

00:31:47.980 --> 00:31:50.320
It writes out a buffer of audio
to the hardware, then it

00:31:50.320 --> 00:31:52.480
wakes up the audio track
thread, which

00:31:52.480 --> 00:31:53.360
is part of the client.

00:31:53.360 --> 00:31:56.770
And that's the one in green,
which is actually part of your

00:31:56.770 --> 00:31:58.060
application.

00:31:58.060 --> 00:31:59.800
And that's the thread that's
generating the

00:31:59.800 --> 00:32:01.070
next buffer of audio.

00:32:01.070 --> 00:32:04.110
Then that computes beautiful
FM sounds for a couple

00:32:04.110 --> 00:32:06.810
milliseconds and queues
its buffer, which

00:32:06.810 --> 00:32:07.720
goes to the fast mixer.

00:32:07.720 --> 00:32:11.050
And then it goes back to sleep
for the next callback.

00:32:11.050 --> 00:32:12.810
RAPH LEVIEN: So around
here, we see

00:32:12.810 --> 00:32:13.655
something else happening.

00:32:13.655 --> 00:32:16.090
The UI thread of the
synthesizer, which is purple,

00:32:16.090 --> 00:32:17.750
wakes up and starts computing.

00:32:17.750 --> 00:32:19.830
But both the fast mixer and the
audio track threads are

00:32:19.830 --> 00:32:20.650
higher priorities.

00:32:20.650 --> 00:32:24.080
So when it's time for them
to wake up, the scheduler

00:32:24.080 --> 00:32:26.740
suspends the UI thread and lets
the high priority audio

00:32:26.740 --> 00:32:27.610
threads run.

00:32:27.610 --> 00:32:28.540
So that's good.

00:32:28.540 --> 00:32:31.060
No audible glitch here.

00:32:31.060 --> 00:32:32.740
GLENN KASTEN: But something
still looks a

00:32:32.740 --> 00:32:33.850
little funny here.

00:32:33.850 --> 00:32:38.660
The audio track thread looks
like it's been split in two.

00:32:38.660 --> 00:32:41.250
Zooming in, we see our UI thread
being scheduled, even

00:32:41.250 --> 00:32:43.560
though the audio thread should
be higher priority.

00:32:43.560 --> 00:32:45.060
What's going on?

00:32:45.060 --> 00:32:46.720
RAPH LEVIEN: Turns out that
when that thread went to

00:32:46.720 --> 00:32:49.780
sleep, it was holding a mutex
belonging to the allocator.

00:32:49.780 --> 00:32:52.470
Then when the audio callback
went to allocate some memory,

00:32:52.470 --> 00:32:54.820
it tried to take the
mutex and blocked.

00:32:54.820 --> 00:32:57.030
The only other thread to
run is the UI thread.

00:32:57.030 --> 00:32:58.520
So the scheduler wakes it up.

00:32:58.520 --> 00:32:59.480
Then it releases the mutex.

00:32:59.480 --> 00:33:02.260
And boom-- the audio thread
is runnable again.

00:33:02.260 --> 00:33:05.090
It's higher priority, so the
scheduler bumps the UI thread

00:33:05.090 --> 00:33:07.330
and lets the audio thread
run to completion.

00:33:07.330 --> 00:33:09.120
And we get our buffer
to the mixer with

00:33:09.120 --> 00:33:10.530
plenty of time to spare.

00:33:10.530 --> 00:33:13.160
This time we were lucky.

00:33:13.160 --> 00:33:13.920
GLENN KASTEN: This time.

00:33:13.920 --> 00:33:15.480
This wasn't our audible
glitch.

00:33:15.480 --> 00:33:16.960
But let's keep looking.

00:33:16.960 --> 00:33:19.740
So to help us out, I added a new
sys trace counter for us

00:33:19.740 --> 00:33:22.310
for audio called f ready, which
basically is the number

00:33:22.310 --> 00:33:24.450
of frames that the application
is providing

00:33:24.450 --> 00:33:25.740
to the audio mixer.

00:33:25.740 --> 00:33:29.380
You want that to always be
high, high enough for the

00:33:29.380 --> 00:33:31.780
mixture to be able to read
the next data from the

00:33:31.780 --> 00:33:32.500
application.

00:33:32.500 --> 00:33:34.910
And as you can see, most of the
time it's 480, which is

00:33:34.910 --> 00:33:37.110
two buffers worth.

00:33:37.110 --> 00:33:40.430
But around 1.1 seconds into the
sys trace, we can see it

00:33:40.430 --> 00:33:41.760
dropping down to zero.

00:33:41.760 --> 00:33:43.620
That's definitely going
to cause a glitch--

00:33:43.620 --> 00:33:44.700
no question.

00:33:44.700 --> 00:33:47.740
Sys traces is a great tool
for finding these kind of

00:33:47.740 --> 00:33:48.670
performance problems.

00:33:48.670 --> 00:33:53.790
It's much easier to see them
than to listen for them.

00:33:53.790 --> 00:33:55.810
So we have a glitch.

00:33:55.810 --> 00:33:57.200
Let's zoom in and see
if we can figure out

00:33:57.200 --> 00:33:59.580
exactly what's happening.

00:33:59.580 --> 00:34:01.690
At the arrow here, our
user interface

00:34:01.690 --> 00:34:03.600
thread, UI, stop running.

00:34:03.600 --> 00:34:06.440
And it turns out it's holding
a mutex for a memory

00:34:06.440 --> 00:34:07.530
allocation.

00:34:07.530 --> 00:34:09.420
Then a whole bunch of
other stuff runs.

00:34:09.420 --> 00:34:12.489
And it looks like
UEventObserver--

00:34:12.489 --> 00:34:14.370
then the usual.

00:34:14.370 --> 00:34:17.100
Fast mixer wakes up.

00:34:17.100 --> 00:34:19.219
That wakes up audio track.

00:34:19.219 --> 00:34:21.510
But at the arrow, the
audio track tries to

00:34:21.510 --> 00:34:22.940
allocate some memory.

00:34:22.940 --> 00:34:24.510
And that's going to block.

00:34:24.510 --> 00:34:26.300
The UI thread was holding
the mutex

00:34:26.300 --> 00:34:28.330
for the memory allocator.

00:34:28.330 --> 00:34:30.280
RAPH LEVIEN: Remember the last
time this happened, the UI

00:34:30.280 --> 00:34:31.929
thread was the only thing
ready to run.

00:34:31.929 --> 00:34:34.440
That's why we were so lucky
there was nothing else for the

00:34:34.440 --> 00:34:35.330
kernel to schedule.

00:34:35.330 --> 00:34:38.320
So the UI thread did its 30
microseconds worth of work and

00:34:38.320 --> 00:34:39.229
unblocked this.

00:34:39.229 --> 00:34:41.960
This time, we're not nearly as
lucky, because there's tons of

00:34:41.960 --> 00:34:44.010
other threads that want to run,
and the scheduler isn't

00:34:44.010 --> 00:34:46.679
smart enough to realize that it
needs to run the UI thread

00:34:46.679 --> 00:34:49.510
in order to unblock
the audio thread.

00:34:49.510 --> 00:34:52.530
The fast mixer keeps waking up,
but every time it does,

00:34:52.530 --> 00:34:53.219
there's no audio.

00:34:53.219 --> 00:34:54.040
We were blocked.

00:34:54.040 --> 00:34:57.440
So f radio runs out, and
we hear a glitch.

00:34:57.440 --> 00:35:00.440
It isn't until 1141 milliseconds
in this trace

00:35:00.440 --> 00:35:03.150
that the UI thread finally gets
scheduled again, then

00:35:03.150 --> 00:35:06.130
releases a mutex and the
callback can run.

00:35:06.130 --> 00:35:08.710
GLENN KASTEN: So this is known
as classic priority inversion.

00:35:08.710 --> 00:35:10.610
Basically, it means that a high
priority thread is being

00:35:10.610 --> 00:35:13.370
blocked by a lower priority
thread that's holding a

00:35:13.370 --> 00:35:16.240
resource, such as a mutex.

00:35:16.240 --> 00:35:19.170
And some operating systems have
special logic, especially

00:35:19.170 --> 00:35:21.520
in their mutexes, to
handle this case.

00:35:21.520 --> 00:35:23.980
But Android is not using
that feature.

00:35:23.980 --> 00:35:24.800
RAPH LEVIEN: Here's
the funny thing.

00:35:24.800 --> 00:35:26.460
I know about priority
inversions.

00:35:26.460 --> 00:35:27.790
I wrote my code very
carefully.

00:35:27.790 --> 00:35:30.510
I didn't take any mutexes, or
allocate any memory-- anything

00:35:30.510 --> 00:35:31.410
they could block.

00:35:31.410 --> 00:35:33.830
Yet the sys trace clearly showed
that the thread was

00:35:33.830 --> 00:35:35.430
blocking on the mutex.

00:35:35.430 --> 00:35:38.800
Tracing further, I found that
the sprintf call I was using

00:35:38.800 --> 00:35:41.340
to generate a log line
was blocking.

00:35:41.340 --> 00:35:42.900
GLENN KASTEN: Sprintf
of all things.

00:35:46.430 --> 00:35:49.150
So turns out I ran into a
similar issue when I was

00:35:49.150 --> 00:35:51.440
working on the audio
fast path.

00:35:51.440 --> 00:35:55.030
I had a thread that was calling
into another server by

00:35:55.030 --> 00:35:58.310
IPC, inter-process
communication, via binder.

00:35:58.310 --> 00:36:01.990
And I knew about classic mutex
priority inversion.

00:36:01.990 --> 00:36:03.030
It's a well known issue.

00:36:03.030 --> 00:36:06.266
But I didn't think about
the risks of IPC.

00:36:06.266 --> 00:36:07.590
RAPH LEVIEN: There are
a bunch of ways to

00:36:07.590 --> 00:36:08.590
deal with this problem.

00:36:08.590 --> 00:36:10.330
But for this kind of thing,
the simplest is to use

00:36:10.330 --> 00:36:11.780
non-blocking techniques.

00:36:11.780 --> 00:36:14.110
Don't ever take a mutex on
the audio callback either

00:36:14.110 --> 00:36:17.290
explicitly or implicitly through
things like memory

00:36:17.290 --> 00:36:19.030
allocation.

00:36:19.030 --> 00:36:22.720
GLENN KASTEN: One really simple
among the non-blocking

00:36:22.720 --> 00:36:27.040
techniques is, way of avoiding
blocking, is single reader,

00:36:27.040 --> 00:36:28.630
single writer ring buffers.

00:36:28.630 --> 00:36:29.840
It's really easy to write.

00:36:29.840 --> 00:36:32.380
It's simple to understand, and
it works really well for

00:36:32.380 --> 00:36:34.290
shuttling either small
or large amounts of

00:36:34.290 --> 00:36:35.710
data between threads.

00:36:35.710 --> 00:36:38.540
It's commonly used in audio
applications for this reason.

00:36:38.540 --> 00:36:40.105
RAPH LEVIEN: Here's how
I used it in my app.

00:36:40.105 --> 00:36:43.010
A Java app puts its MIDI bytes
into the ring buffer.

00:36:43.010 --> 00:36:45.610
Then the C++ takes
the bytes out.

00:36:45.610 --> 00:36:48.100
Checking how many bytes are
available and reading them can

00:36:48.100 --> 00:36:49.890
both be done without blocking.

00:36:49.890 --> 00:36:52.210
If you weren't in a soft real
time context, you'd probably

00:36:52.210 --> 00:36:54.100
use a mutex for this instead.

00:36:54.100 --> 00:36:56.590
Do keep in mind, though, that
you still need to use memory

00:36:56.590 --> 00:36:59.460
barriers because ARM has a
weekly ordered memory model.

00:36:59.460 --> 00:37:02.060
X86 has a total store order,
so if you've implemented a

00:37:02.060 --> 00:37:03.530
ring buffer there, you
may not be aware

00:37:03.530 --> 00:37:05.440
you need these barriers.

00:37:05.440 --> 00:37:06.670
If none of this makes sense
to you, just use

00:37:06.670 --> 00:37:08.660
existing correct code.

00:37:08.660 --> 00:37:11.150
GLENN KASTEN: And definitely
don't call sprintf.

00:37:11.150 --> 00:37:13.330
So let's see what your new graph
looks like now that you

00:37:13.330 --> 00:37:14.945
fixed your priority inversion.

00:37:14.945 --> 00:37:15.210
RAPH LEVIEN: You bet.

00:37:15.210 --> 00:37:16.260
Here it is.

00:37:16.260 --> 00:37:18.670
And here it is contracted
for drift.

00:37:18.670 --> 00:37:19.640
Now, it's looking clean.

00:37:19.640 --> 00:37:21.080
The outliers are gone.

00:37:21.080 --> 00:37:23.260
All of the code is strictly
non-blocking.

00:37:23.260 --> 00:37:25.210
You do see some weird little
ups and down because of the

00:37:25.210 --> 00:37:27.380
power management system changing
the clock frequency,

00:37:27.380 --> 00:37:29.310
but that's OK.

00:37:29.310 --> 00:37:30.870
Even at the lowest clock
frequency, everything is

00:37:30.870 --> 00:37:32.600
happening under two
milliseconds, which is

00:37:32.600 --> 00:37:33.870
properly quick.

00:37:33.870 --> 00:37:35.850
This might not seem like it
looks better than the previous

00:37:35.850 --> 00:37:38.110
plot, but take a look
at the scale.

00:37:38.110 --> 00:37:40.700
GLENN KASTEN: That's
a one and a two.

00:37:40.700 --> 00:37:42.380
The start times are all
clustered together

00:37:42.380 --> 00:37:43.560
the way we like them.

00:37:43.560 --> 00:37:46.100
But the end times are still
a little bit weird.

00:37:46.100 --> 00:37:48.130
It looks like there's
two bands.

00:37:48.130 --> 00:37:48.790
What's going on there?

00:37:48.790 --> 00:37:50.510
RAPH LEVIEN: My synth was
doing its computation in

00:37:50.510 --> 00:37:53.230
blocks of 64 samples because
it's convenient.

00:37:53.230 --> 00:37:55.290
Lots of other libraries
do that too.

00:37:55.290 --> 00:37:58.450
Remember, the Nexus 4 buffer
is 240 samples long.

00:37:58.450 --> 00:38:02.185
So sometimes we'd compute
256, other times, 192.

00:38:02.185 --> 00:38:04.000
That variation explains
the two bands.

00:38:04.000 --> 00:38:06.210
This is a nice optimization,
and it took my synth from

00:38:06.210 --> 00:38:09.510
about 20 to 30 voices
of polyphony.

00:38:09.510 --> 00:38:12.240
After this, I took it the rest
of the way with some old

00:38:12.240 --> 00:38:15.110
fashioned cache optimization
and SIMD magic.

00:38:15.110 --> 00:38:17.510
So now it's up to 64 voices.

00:38:17.510 --> 00:38:20.140
Between Glenn's work on the
system and my optimizations in

00:38:20.140 --> 00:38:21.775
this synth engine, my
DX7 app is starting

00:38:21.775 --> 00:38:23.160
to look pretty good.

00:38:23.160 --> 00:38:27.700
GLENN KASTEN: This is where
things stand for some devices.

00:38:27.700 --> 00:38:28.340
That's right.

00:38:28.340 --> 00:38:31.080
You knew there had to be a
catch, because as soon as we

00:38:31.080 --> 00:38:34.430
started testing this design on
a wider variety of devices,

00:38:34.430 --> 00:38:36.615
things started to get
more complicated.

00:38:36.615 --> 00:38:38.220
RAPH LEVIEN: The core
of what Glenn did is

00:38:38.220 --> 00:38:39.310
valid on every device.

00:38:39.310 --> 00:38:42.340
But each device has its own set
of bugs-- power management

00:38:42.340 --> 00:38:45.210
issues, driver bugs, or
scheduling snafus.

00:38:45.210 --> 00:38:47.700
And each one of those has to
be solved individually.

00:38:47.700 --> 00:38:49.510
GLENN KASTEN: If you want to,
catch me during office hours.

00:38:49.510 --> 00:38:52.070
I'll tell you some
war stories.

00:38:52.070 --> 00:38:55.560
So that's the last thing on my
to do list is to work with our

00:38:55.560 --> 00:38:58.440
hardware partners to track down
these crazy kernel driver

00:38:58.440 --> 00:39:01.810
and hardware issues that can
affect audio performance.

00:39:01.810 --> 00:39:02.750
I'm committed to it.

00:39:02.750 --> 00:39:04.070
We're committed to it.

00:39:04.070 --> 00:39:05.470
But we're not there yet.

00:39:05.470 --> 00:39:07.410
RAPH LEVIEN: But we are moving
in the right direction.

00:39:07.410 --> 00:39:09.060
GLENN KASTEN: Yes we are.

00:39:09.060 --> 00:39:11.420
RAPH LEVIEN: If you have some
questions or would like to see

00:39:11.420 --> 00:39:14.550
more data, come see us in the
Android office hours area

00:39:14.550 --> 00:39:15.800
right after this presentation.

00:39:18.690 --> 00:39:22.680
GLENN KASTEN: We put together a
website for all of you with

00:39:22.680 --> 00:39:25.480
a lot of good audio performance
resources.

00:39:25.480 --> 00:39:28.360
So this QR code has a short link
to it, and there's also

00:39:28.360 --> 00:39:31.340
the long link there
if you prefer--

00:39:31.340 --> 00:39:32.590
codegoogle.com/p
/high-performance-audio.

00:39:35.470 --> 00:39:36.940
Lots and lots of resources
there.

00:39:36.940 --> 00:39:39.860
And we do plan on continuing
to keep that website up to

00:39:39.860 --> 00:39:43.120
date with more things as
we come across some.

00:39:43.120 --> 00:39:45.144
So thank you all for coming.

00:39:45.144 --> 00:39:50.760
[APPLAUSE]

00:39:50.760 --> 00:39:54.010
GLENN KASTEN: And again, please
fill the review forms.

00:39:54.010 --> 00:39:56.920
And let's talk at
office hours.

00:39:56.920 --> 00:39:57.520
RAPH LEVIEN: See you there.

00:39:57.520 --> 00:39:58.770
Thank you.

