WEBVTT
Kind: captions
Language: en

00:00:00.470 --> 00:00:01.887
PAMELA FOX: Hello.

00:00:01.887 --> 00:00:03.290
AUDIENCE: Hello.

00:00:03.290 --> 00:00:04.410
PAMELA FOX: How are you?

00:00:04.410 --> 00:00:06.370
AUDIENCE: [INAUDIBLE].

00:00:06.370 --> 00:00:07.256
PAMELA FOX: OK.

00:00:07.256 --> 00:00:07.682
How are you?

00:00:07.682 --> 00:00:08.109
AUDIENCE: Good.

00:00:08.109 --> 00:00:08.374
PAMELA FOX: All right.

00:00:08.374 --> 00:00:08.640
OK.

00:00:08.640 --> 00:00:10.220
Good.

00:00:10.220 --> 00:00:11.820
I know this is like the time
of the afternoon where

00:00:11.820 --> 00:00:12.640
typically you sleep.

00:00:12.640 --> 00:00:14.100
And they did just turn
off the lights.

00:00:14.100 --> 00:00:17.115
But I will try and be as loud
and obnoxious as possible in

00:00:17.115 --> 00:00:18.690
order to keep you awake.

00:00:18.690 --> 00:00:20.600
So my name is Pamela fox.

00:00:20.600 --> 00:00:22.480
I'm a product engineer
at Coursera.

00:00:22.480 --> 00:00:24.210
And today I want to
talk about feature

00:00:24.210 --> 00:00:26.650
detection in the real world.

00:00:26.650 --> 00:00:28.690
So this shit's gonna get real.

00:00:28.690 --> 00:00:29.410
All right.

00:00:29.410 --> 00:00:32.020
So you guys are in
a Chrome track.

00:00:32.020 --> 00:00:34.750
And presumably you guys are all
on the Chrome track and

00:00:34.750 --> 00:00:36.110
doing web development stuff.

00:00:36.110 --> 00:00:39.733
And you're probably all pretty
excited about HTML5, right?

00:00:39.733 --> 00:00:40.660
Whoo.

00:00:40.660 --> 00:00:41.280
AUDIENCE: Whoo.

00:00:41.280 --> 00:00:43.300
PAMELA FOX: So HTML5 is awesome,
because it's bringing

00:00:43.300 --> 00:00:45.780
us all these things that for
years and years we wanted as

00:00:45.780 --> 00:00:46.220
web developers.

00:00:46.220 --> 00:00:48.580
And we had to do all
these crazy hacks

00:00:48.580 --> 00:00:49.380
in order to do them.

00:00:49.380 --> 00:00:51.880
And finally, the browsers are
just making it really

00:00:51.880 --> 00:00:53.150
easy for us, right?

00:00:53.150 --> 00:00:56.120
I remember once spending two
months implementing rounded

00:00:56.120 --> 00:00:58.880
corners on this little gadget
back when I was working at

00:00:58.880 --> 00:01:02.280
Google, and finally getting it
to work in IE6, and then

00:01:02.280 --> 00:01:05.630
taking it to UX Review with
Marissa finding out that

00:01:05.630 --> 00:01:09.070
apparently we didn't do rounded
corners at Google.

00:01:09.070 --> 00:01:10.520
So stuff like that, right?

00:01:10.520 --> 00:01:13.010
These days it would take me
one line of code to put a

00:01:13.010 --> 00:01:15.060
border radius on there and
then get it rejected.

00:01:15.060 --> 00:01:17.250
And hey, life would
go on, right?

00:01:17.250 --> 00:01:20.140
So HTML5 is great, because we
get all these new features.

00:01:20.140 --> 00:01:21.920
But we're getting them
incrementally, right?

00:01:21.920 --> 00:01:23.390
So we have them in
some browsers.

00:01:23.390 --> 00:01:24.640
We don't have them in
other browsers.

00:01:24.640 --> 00:01:26.680
We have kind of parts of the
features in some and they

00:01:26.680 --> 00:01:28.270
don't quite work.

00:01:28.270 --> 00:01:31.210
So that means we actually have
to worry about whether a

00:01:31.210 --> 00:01:34.450
particular feature is actually
supported, because most of us

00:01:34.450 --> 00:01:36.460
probably have to actually
develop things

00:01:36.460 --> 00:01:39.080
for multiple browsers.

00:01:39.080 --> 00:01:41.430
If we could, we'd probably just
tell all of our users,

00:01:41.430 --> 00:01:44.260
hey, just use Chrome.

00:01:44.260 --> 00:01:45.330
I've tried that.

00:01:45.330 --> 00:01:47.380
It kind of works.

00:01:47.380 --> 00:01:49.190
So what do we do?

00:01:49.190 --> 00:01:50.870
We think to ourself
like, all right, I

00:01:50.870 --> 00:01:52.520
want to use this feature.

00:01:52.520 --> 00:01:54.210
But first I need to see
if it's supported.

00:01:54.210 --> 00:01:55.970
How should I do that?

00:01:55.970 --> 00:01:59.400
The obvious thing to do is to
ask the browser, like, hey, I

00:01:59.400 --> 00:02:00.250
want to use this feature.

00:02:00.250 --> 00:02:01.520
Do you use that?

00:02:01.520 --> 00:02:03.590
And we do that via this
technique that we

00:02:03.590 --> 00:02:04.850
call feature detection.

00:02:04.850 --> 00:02:06.320
And we have various
ways of actually

00:02:06.320 --> 00:02:08.400
doing feature detection.

00:02:08.400 --> 00:02:09.770
So here are some examples.

00:02:09.770 --> 00:02:12.380
If we want to know if a
browser supports some

00:02:12.380 --> 00:02:15.750
JavaScript API, we might
ask, OK, does

00:02:15.750 --> 00:02:19.000
window.webkitAudioContext
exist?

00:02:19.000 --> 00:02:22.210
If it does exist, than this
browser supports that

00:02:22.210 --> 00:02:23.900
particular JavaScript API.

00:02:23.900 --> 00:02:26.480
If we're trying to see if a
particular HTML element works,

00:02:26.480 --> 00:02:29.460
we can try creating the HTML
element and seeing if it gets

00:02:29.460 --> 00:02:31.880
particular attributes
automatically applied to it by

00:02:31.880 --> 00:02:33.340
the browser.

00:02:33.340 --> 00:02:38.240
If we want to know some CSS
works, we can just create an

00:02:38.240 --> 00:02:43.050
element and see if that style
property is actually a key on

00:02:43.050 --> 00:02:44.480
that element.

00:02:44.480 --> 00:02:47.800
And most of us probably use
Modernizr, which is a library

00:02:47.800 --> 00:02:50.720
that does these detections for
you behind the scenes.

00:02:50.720 --> 00:02:52.000
And then you just
ask Modernizr,

00:02:52.000 --> 00:02:54.500
hey, does this work?

00:02:54.500 --> 00:02:56.150
So that's feature detection.

00:02:56.150 --> 00:02:59.390
And it sounds like it's
actually really great.

00:02:59.390 --> 00:03:01.530
All we have to do is say, we
want to use this feature, just

00:03:01.530 --> 00:03:03.610
tell the browser, hey,
tell us if it works.

00:03:06.120 --> 00:03:08.260
So it's really, really awesome
when it works.

00:03:08.260 --> 00:03:09.910
It's a great idea.

00:03:09.910 --> 00:03:13.400
However, it doesn't
always work.

00:03:13.400 --> 00:03:15.430
Sometimes it's impossible
to detect a feature.

00:03:15.430 --> 00:03:19.650
Sometimes you get false
negatives, positive falsities,

00:03:19.650 --> 00:03:21.980
whatever you want to call
them, all those things.

00:03:21.980 --> 00:03:23.670
And you need a different plan.

00:03:23.670 --> 00:03:26.440
And a lot of times what
you do instead is

00:03:26.440 --> 00:03:28.730
use user agent detection.

00:03:28.730 --> 00:03:32.280
And this is where we just look
at the navigator.userAgent.

00:03:32.280 --> 00:03:35.400
And we try to understand
what device and what

00:03:35.400 --> 00:03:38.170
browser a user is using.

00:03:38.170 --> 00:03:39.590
So a very basic check here.

00:03:39.590 --> 00:03:42.300
If I want to know if they're on
an iPad or iPhone, I'm just

00:03:42.300 --> 00:03:45.250
looking for iPhone or iPod
in that user agent,

00:03:45.250 --> 00:03:46.560
doing a regex here.

00:03:46.560 --> 00:03:49.860
This is where we have
a lot of regex's.

00:03:49.860 --> 00:03:53.760
I hate regex's, so I will never
make these up myself.

00:03:53.760 --> 00:03:55.000
But they get worse.

00:03:55.000 --> 00:03:58.010
So if I want to check for mobile
browsers, maybe the top

00:03:58.010 --> 00:04:01.502
mobile browsers, here's a check
that gets a bit more of

00:04:01.502 --> 00:04:05.150
a crazier regex that's going
to get me maybe the top 10

00:04:05.150 --> 00:04:08.250
mobile browsers.

00:04:08.250 --> 00:04:09.810
But it's not that simple.

00:04:09.810 --> 00:04:12.380
There's a lot more browsers out
there and devices in the

00:04:12.380 --> 00:04:13.840
world, especially as you
go international.

00:04:13.840 --> 00:04:16.470
I know a lot of you are
from outside America.

00:04:16.470 --> 00:04:18.990
And I'm sure you have Android
devices that I've never even

00:04:18.990 --> 00:04:20.040
heard of, right?

00:04:20.040 --> 00:04:22.320
So if you really wanted to
check for every mobile

00:04:22.320 --> 00:04:25.230
browser, you get something
like this.

00:04:25.230 --> 00:04:28.870
I think this from
mobilebrowserdetect.com.

00:04:28.870 --> 00:04:31.760
And as you can see, there's
a lot of mobile

00:04:31.760 --> 00:04:33.190
browsers in the world.

00:04:33.190 --> 00:04:34.900
Do you actually need to
check for all of them?

00:04:34.900 --> 00:04:35.540
I don't know.

00:04:35.540 --> 00:04:38.010
I don't know you're doing.

00:04:38.010 --> 00:04:41.430
But this is an example of
how intense user agent

00:04:41.430 --> 00:04:42.490
sniffing can be.

00:04:42.490 --> 00:04:45.520
And we usually don't want to do
user agent sniffing for a

00:04:45.520 --> 00:04:46.440
couple reasons.

00:04:46.440 --> 00:04:48.710
First of all, we have
to write regex's.

00:04:48.710 --> 00:04:52.930
And I don't know about you,
but I don't like regex.

00:04:52.930 --> 00:04:54.880
The thing is, it's very
easy to get it wrong.

00:04:54.880 --> 00:04:56.330
It's generally easy to
get regex's wrong.

00:04:56.330 --> 00:04:59.220
But it's also really easy to get
user agents wrong, because

00:04:59.220 --> 00:05:01.950
user agents, they're kind of
these crazy strings that

00:05:01.950 --> 00:05:02.920
browsers come up with.

00:05:02.920 --> 00:05:05.510
And browsers are always trying
to fool developers into

00:05:05.510 --> 00:05:07.850
thinking that they're not
what they used to be.

00:05:07.850 --> 00:05:11.920
So I think the new IE10 has
gotten rid of something in its

00:05:11.920 --> 00:05:14.340
user agent string that people
normally sniff for to find out

00:05:14.340 --> 00:05:16.650
that it's IE, because IE10, they
don't want you thinking

00:05:16.650 --> 00:05:19.770
it's IE anymore, because
it's cool now.

00:05:19.770 --> 00:05:20.260
And then--

00:05:20.260 --> 00:05:21.550
AUDIENCE: [LAUGHTER]

00:05:21.550 --> 00:05:23.040
PAMELA FOX: Oh, you guys
didn't get that memo.

00:05:23.040 --> 00:05:23.630
OK.

00:05:23.630 --> 00:05:26.370
And then some browsers, like
if you're viewing IE with

00:05:26.370 --> 00:05:29.790
Chrome Frame, it'll tell you
Chrome in the user agent.

00:05:29.790 --> 00:05:32.330
But then Chrome Frame might
not actually be

00:05:32.330 --> 00:05:33.130
running on the page.

00:05:33.130 --> 00:05:34.760
So that's kind of confusing.

00:05:34.760 --> 00:05:36.800
And then of course every user
agent string in the world has

00:05:36.800 --> 00:05:40.100
Mozilla, because that was
the original dupe.

00:05:40.100 --> 00:05:42.270
So user agent detection
can be really tricky.

00:05:42.270 --> 00:05:44.130
And it also means that when
you're detecting the user

00:05:44.130 --> 00:05:47.220
agent, if that user agent
eventually does come to

00:05:47.220 --> 00:05:50.120
support a feature, you've
prematurely blocked it.

00:05:50.120 --> 00:05:53.970
If you say like, hey, Safari
doesn't support this feature,

00:05:53.970 --> 00:05:57.650
we're not going to use this
feature in Safari, and then

00:05:57.650 --> 00:06:00.850
Safari tomorrow comes out with
a release that supports that

00:06:00.850 --> 00:06:03.120
feature, you've probably moved
on to other things.

00:06:03.120 --> 00:06:04.920
The chance that you're actually
going to update that

00:06:04.920 --> 00:06:08.400
bit of code that blocks Safari
users is really small.

00:06:08.400 --> 00:06:10.690
So we don't like user agent
detection because it's often

00:06:10.690 --> 00:06:12.960
not future-thinking.

00:06:12.960 --> 00:06:15.910
It can really easily leave us in
a state where parts of our

00:06:15.910 --> 00:06:19.370
site aren't working as well when
they actually could be,

00:06:19.370 --> 00:06:21.600
because these browsers
do move fast.

00:06:21.600 --> 00:06:25.260
But it is a tool that
we can use.

00:06:25.260 --> 00:06:26.450
So here's the thing.

00:06:26.450 --> 00:06:28.760
We have these two tools, feature
detection and user

00:06:28.760 --> 00:06:29.990
agent sniffing.

00:06:29.990 --> 00:06:32.500
And a lot of people will tell
you, hey, you've got to use

00:06:32.500 --> 00:06:33.080
feature detection.

00:06:33.080 --> 00:06:34.410
You've got to use feature
detection.

00:06:34.410 --> 00:06:35.820
That's the only way.

00:06:35.820 --> 00:06:38.690
And I definitely do try to.

00:06:38.690 --> 00:06:42.000
But I've run into all these
cases where it hasn't quite

00:06:42.000 --> 00:06:44.910
worked and I've had to use
other techniques instead.

00:06:44.910 --> 00:06:47.700
So I wanted to share those with
you so that hopefully

00:06:47.700 --> 00:06:51.030
when you guys are working on
using these fancy new features

00:06:51.030 --> 00:06:54.000
yourself, you'll know what to
look out for and you'll know

00:06:54.000 --> 00:06:57.020
how to react yourself so that
you can spend less time

00:06:57.020 --> 00:06:59.440
figuring out how to detect
things and just move on to

00:06:59.440 --> 00:07:01.570
actually making stuff happen,
which is what

00:07:01.570 --> 00:07:03.840
we all want to do.

00:07:03.840 --> 00:07:06.820
So let's talk about
a few cases.

00:07:06.820 --> 00:07:12.210
LocalStorage is this cool,
lightweight storage API.

00:07:12.210 --> 00:07:14.670
It's actually supported in a
quite a few browsers now.

00:07:14.670 --> 00:07:17.250
It's from the W3 Web
Storage spec.

00:07:17.250 --> 00:07:21.270
And it's a very simple key
value store that you can

00:07:21.270 --> 00:07:25.555
access from JavaScript and use
to store in cache data from

00:07:25.555 --> 00:07:27.510
your application.

00:07:27.510 --> 00:07:30.390
And I thought it was
really cool.

00:07:30.390 --> 00:07:34.560
So I wrote a library on top of
LocalStorage called lscache,

00:07:34.560 --> 00:07:36.970
which was inspired by memcache,
which is a tool we

00:07:36.970 --> 00:07:39.640
use on the server and would
allow me to store stuff in

00:07:39.640 --> 00:07:42.225
LocalStorage with a particular
expiration and then they would

00:07:42.225 --> 00:07:43.820
get automatically kicked out.

00:07:43.820 --> 00:07:47.670
So in this library, I thought it
would be responsible of me

00:07:47.670 --> 00:07:50.730
to actually check to see if
LocalStorage worked in the

00:07:50.730 --> 00:07:54.500
browser before I attempted
to store anything in it.

00:07:54.500 --> 00:07:56.980
So I needed to figure out how
to do this detection.

00:07:56.980 --> 00:08:00.830
So I started off with the most
basic thing I could do, which

00:08:00.830 --> 00:08:06.760
is, OK, LocalStorage on
window and not null?

00:08:06.760 --> 00:08:11.120
Therefore, this browser supports
the LocalStorage API.

00:08:11.120 --> 00:08:14.910
That was my very naive
first attempt.

00:08:14.910 --> 00:08:17.910
But what happened is that you
could have LocalStorage

00:08:17.910 --> 00:08:19.240
supported by a browser.

00:08:19.240 --> 00:08:22.570
It didn't mean you could
actually use it, because it

00:08:22.570 --> 00:08:25.230
could be that the browser was
currently in incognito mode

00:08:25.230 --> 00:08:27.080
and doesn't let you store
LocalStorage.

00:08:27.080 --> 00:08:31.160
It could be that the
LocalStorage was over quota.

00:08:31.160 --> 00:08:33.679
It could be just for whatever
reason-- there was one version

00:08:33.679 --> 00:08:35.780
of iPad where they just
turned it off.

00:08:35.780 --> 00:08:38.210
So the only way you can actually
check to see if

00:08:38.210 --> 00:08:40.650
LocalStorage works is to
try and use it the way

00:08:40.650 --> 00:08:41.679
you want to use it.

00:08:41.679 --> 00:08:44.530
So my LocalStorage check then
turned into this, which is,

00:08:44.530 --> 00:08:49.360
OK, let's try to set an item
in the cache and remove the

00:08:49.360 --> 00:08:50.450
item from the cache.

00:08:50.450 --> 00:08:52.780
And if we're able to do that
and we don't get any

00:08:52.780 --> 00:08:57.230
exceptions during that time,
then OK, LocalStorage works.

00:08:57.230 --> 00:08:59.540
So the only way I could actually
check this was to use

00:08:59.540 --> 00:09:03.830
it exactly the way I wanted
to be able to use it.

00:09:03.830 --> 00:09:05.630
So I went to that check.

00:09:05.630 --> 00:09:10.060
Now, even that caused
me some problems.

00:09:10.060 --> 00:09:12.180
So I was using this in
a mobile web app.

00:09:12.180 --> 00:09:14.730
It was a PhoneGap hybrid app.

00:09:14.730 --> 00:09:18.560
And I noticed that my web app
was taken a long time to load.

00:09:18.560 --> 00:09:20.570
And I was trying to get
this load time down.

00:09:20.570 --> 00:09:21.840
So I profiled it.

00:09:21.840 --> 00:09:25.130
I put little new Date
in between all the

00:09:25.130 --> 00:09:25.835
things that it did.

00:09:25.835 --> 00:09:28.790
And I tried to figure out, why
is it taking so much time just

00:09:28.790 --> 00:09:30.740
to get to this main screen?

00:09:30.740 --> 00:09:33.240
And I found it was actually
taking something like 300

00:09:33.240 --> 00:09:36.270
milliseconds on Android in
order to get through this

00:09:36.270 --> 00:09:40.340
LocalStorage detection check,
because in my code I had

00:09:40.340 --> 00:09:42.370
script source equals
lscache.js.

00:09:42.370 --> 00:09:43.610
It would execute that code.

00:09:43.610 --> 00:09:45.540
And that code would
immediately do the

00:09:45.540 --> 00:09:47.110
LocalStorage detection check.

00:09:47.110 --> 00:09:49.730
So what I realized was I needed
to stop doing that

00:09:49.730 --> 00:09:54.750
detection check on page load,
and defer it, only do it later

00:09:54.750 --> 00:09:56.330
when I actually needed it.

00:09:56.330 --> 00:09:58.640
So what I did is I made a little
cached variable to

00:09:58.640 --> 00:10:01.740
remember where LocalStorage
works, because we don't want

00:10:01.740 --> 00:10:02.630
to do this check all the time.

00:10:02.630 --> 00:10:04.170
We just want to do it once.

00:10:04.170 --> 00:10:06.300
So basically what happens,
every time you try to use

00:10:06.300 --> 00:10:10.120
lscache, it will check to
see, have we figured

00:10:10.120 --> 00:10:11.050
out yet that it works?

00:10:11.050 --> 00:10:11.250
OK.

00:10:11.250 --> 00:10:13.360
If we haven't, let's
do that check.

00:10:13.360 --> 00:10:14.780
Let's remember it.

00:10:14.780 --> 00:10:17.670
And then next time when they
use it, we'll remember.

00:10:17.670 --> 00:10:23.500
So what I learned here is that
you have to be careful when

00:10:23.500 --> 00:10:25.730
you're checking if something
supports an API not just that

00:10:25.730 --> 00:10:28.120
it supports it, but it supports
the way you want to

00:10:28.120 --> 00:10:31.330
use it, I mean, LocalStorage,
you could actually be in a

00:10:31.330 --> 00:10:33.220
mode where you could
read it but you

00:10:33.220 --> 00:10:34.450
wouldn't be able to write.

00:10:34.450 --> 00:10:36.640
But maybe you only care about
reading, in which case you

00:10:36.640 --> 00:10:38.360
should just check for that.

00:10:38.360 --> 00:10:41.920
So there's a lot of subtleties
to when we say something is

00:10:41.920 --> 00:10:43.940
supported or works.

00:10:43.940 --> 00:10:48.370
It's, again, a bit more
complex than that.

00:10:48.370 --> 00:10:50.520
You also need to make sure that
you don't let feature

00:10:50.520 --> 00:10:52.590
detection slow down your site.

00:10:52.590 --> 00:10:55.940
It's always simple to do
everything up, do all your

00:10:55.940 --> 00:10:56.760
checks upfront.

00:10:56.760 --> 00:10:59.620
And then you know you can
always have it there.

00:10:59.620 --> 00:11:02.440
But you don't want to sacrifice
the users loading

00:11:02.440 --> 00:11:04.760
performance just
for simplicity.

00:11:04.760 --> 00:11:07.490
This is the unfortunate thing
pretty much when it comes to

00:11:07.490 --> 00:11:10.540
performance, your code can
start off beautiful.

00:11:10.540 --> 00:11:13.410
As soon as you start worrying
about performance, your code's

00:11:13.410 --> 00:11:15.760
not going to be beautiful
anymore.

00:11:15.760 --> 00:11:17.600
You're going to have to
implement caching.

00:11:17.600 --> 00:11:19.720
And it's not going to
look very clean.

00:11:19.720 --> 00:11:23.620
But sometimes we have to make
our code look not as beautiful

00:11:23.620 --> 00:11:26.340
in order for users to have
a better experience.

00:11:26.340 --> 00:11:29.340
So we sacrifice a little bit of
developer happiness for a

00:11:29.340 --> 00:11:30.190
little bit of user happiness.

00:11:30.190 --> 00:11:33.310
And I know that's really
hard for us to give up.

00:11:33.310 --> 00:11:36.680
But it's important.

00:11:36.680 --> 00:11:39.150
And along with this, every time
I encountered something

00:11:39.150 --> 00:11:43.300
with this feature detection, I
thought to myself, OK, what

00:11:43.300 --> 00:11:44.270
would I want out of browsers?

00:11:44.270 --> 00:11:47.700
What could browsers give to me
as a developer that would have

00:11:47.700 --> 00:11:50.090
made it easier for
me in this case?

00:11:50.090 --> 00:11:52.410
So here, it would've been
awesome if I could just ask

00:11:52.410 --> 00:11:54.490
the browser like,
hey, browser.

00:11:54.490 --> 00:11:56.960
Can I use LocalStorage storage
in a read mode?

00:11:56.960 --> 00:11:58.990
Can I use LocalStorage
in a write mode?

00:11:58.990 --> 00:11:59.330
OK.

00:11:59.330 --> 00:11:59.690
Great.

00:11:59.690 --> 00:12:02.800
And then the browser could
figure out the most optimal

00:12:02.800 --> 00:12:05.890
way of checking and I wouldn't
be up to me.

00:12:05.890 --> 00:12:09.010
So the good thing about
browsers, having browsers give

00:12:09.010 --> 00:12:12.770
us these checks, is that they
could do it in a very fast way

00:12:12.770 --> 00:12:15.270
and a very efficient way, ways
that I couldn't necessarily do

00:12:15.270 --> 00:12:16.980
because I'm not going
behind the scenes

00:12:16.980 --> 00:12:18.300
in the browser code.

00:12:18.300 --> 00:12:21.480
So I hope that this is something
that browsers do

00:12:21.480 --> 00:12:24.030
going forward with things
like the storage APIs.

00:12:24.030 --> 00:12:25.810
And I think that IndexedDB
actually does

00:12:25.810 --> 00:12:27.410
have stuff like this.

00:12:27.410 --> 00:12:29.920
So they learn.

00:12:29.920 --> 00:12:31.000
All right.

00:12:31.000 --> 00:12:31.910
Whoo.

00:12:31.910 --> 00:12:37.140
So then we have this thing
called FormData.

00:12:37.140 --> 00:12:40.110
FormData is another
addition to HTML5.

00:12:40.110 --> 00:12:44.120
And it's something that lets
you take data from all your

00:12:44.120 --> 00:12:46.090
form inputs, serialize
it, send it

00:12:46.090 --> 00:12:47.850
in an XML HTTP request.

00:12:47.850 --> 00:12:49.120
The idea is that you
don't have to

00:12:49.120 --> 00:12:52.650
use jQuery.ajax anymore.

00:12:52.650 --> 00:12:54.280
And I thought, oh, this
is really cool.

00:12:54.280 --> 00:12:57.740
And I saw all the Google Dev
Rellers were tweeting about

00:12:57.740 --> 00:12:58.410
how cool FormData.

00:12:58.410 --> 00:13:00.310
And I was like, man.

00:13:00.310 --> 00:13:01.700
I want to be cool like them.

00:13:01.700 --> 00:13:04.530
I want to use FormData.

00:13:04.530 --> 00:13:08.530
So I implemented it for a signup
form on this website I

00:13:08.530 --> 00:13:10.770
made last year, so that
when you signed

00:13:10.770 --> 00:13:12.430
up, you would actually--

00:13:12.430 --> 00:13:14.840
it would go through this code
here, which would say, OK.

00:13:14.840 --> 00:13:16.400
If window.FormData--

00:13:16.400 --> 00:13:18.200
we're just starting with
this basic check.

00:13:18.200 --> 00:13:21.430
If window.FormData, create the
new FormData from the form.

00:13:21.430 --> 00:13:23.290
Do a new XHR.

00:13:23.290 --> 00:13:25.580
Send that FormData to the XHR.

00:13:25.580 --> 00:13:28.960
If not, then we just go down
to our Ajax technique.

00:13:28.960 --> 00:13:29.720
So I was like, OK.

00:13:29.720 --> 00:13:31.400
This is awesome.

00:13:31.400 --> 00:13:32.550
I've been all proper.

00:13:32.550 --> 00:13:34.900
And I've implemented the feature
detection check.

00:13:34.900 --> 00:13:36.730
And I've done a fallback
technique.

00:13:36.730 --> 00:13:39.390
And I tested it and it
works and it's great.

00:13:39.390 --> 00:13:40.480
And I put it out there.

00:13:40.480 --> 00:13:41.895
And I tweeted about it.

00:13:41.895 --> 00:13:43.560
And I felt really good.

00:13:43.560 --> 00:13:47.230
But then I got all these reports
from Safari users that

00:13:47.230 --> 00:13:49.080
they weren't able to sign up.

00:13:49.080 --> 00:13:51.030
I was like, well, this
is not very good.

00:13:51.030 --> 00:13:53.960
Sign up is somewhat a crucial
part of an application.

00:13:53.960 --> 00:13:56.190
So I was like, what is this?

00:13:56.190 --> 00:13:57.340
Why can't they sign
up on Safari?

00:13:57.340 --> 00:14:00.880
Because it worked fine on my
Safari, and I realized that

00:14:00.880 --> 00:14:03.020
there was this particular
version of Safari--

00:14:03.020 --> 00:14:11.090
it was like 5.1.50 or whatever,
only on Macs, maybe

00:14:11.090 --> 00:14:13.900
on Windows-- but this particular
version of Safari

00:14:13.900 --> 00:14:16.280
where FormData didn't
quite work.

00:14:16.280 --> 00:14:17.790
It pretended to work.

00:14:17.790 --> 00:14:19.540
But it didn't actually work.

00:14:19.540 --> 00:14:21.860
And what would actually happen
is that when you created that

00:14:21.860 --> 00:14:24.780
FormData object, it would
create it and

00:14:24.780 --> 00:14:25.830
pretend it all worked.

00:14:25.830 --> 00:14:29.575
But then there was nothing in
it, which is kind of horrible,

00:14:29.575 --> 00:14:32.430
because people would be trying
to sign up and there would be

00:14:32.430 --> 00:14:34.280
no data going to my server.

00:14:34.280 --> 00:14:37.070
So I couldn't even find out what
email address they put in

00:14:37.070 --> 00:14:39.520
in order to tell them like, oh,
hey, I fixed it, because I

00:14:39.520 --> 00:14:41.440
was getting an empty string.

00:14:41.440 --> 00:14:43.110
So that was pretty bad.

00:14:43.110 --> 00:14:45.500
And the other bad thing is
that there was no way to

00:14:45.500 --> 00:14:49.190
actually do a detection check
for this, because FormData has

00:14:49.190 --> 00:14:50.100
no accessors.

00:14:50.100 --> 00:14:53.040
You can't ask FormData to tell
you what's in it, to

00:14:53.040 --> 00:14:54.660
say get a key out.

00:14:54.660 --> 00:14:56.200
Give me the length of
what's in there.

00:14:56.200 --> 00:14:59.050
It's just this blob that
you can't look inside.

00:14:59.050 --> 00:15:00.740
And maybe there's
nothing in it.

00:15:00.740 --> 00:15:01.750
So I was like, OK.

00:15:01.750 --> 00:15:05.150
I'm going to have to just
blacklist Safari, because I

00:15:05.150 --> 00:15:08.440
knew it had a problem and
that was my only option.

00:15:08.440 --> 00:15:11.780
So I ended up coming up with a
detection, user agent sniffing

00:15:11.780 --> 00:15:13.030
for Safari.

00:15:13.030 --> 00:15:13.980
And I said, OK.

00:15:13.980 --> 00:15:18.730
If window.FormData and we're
not in Safari, then lets go

00:15:18.730 --> 00:15:20.460
send it on.

00:15:20.460 --> 00:15:23.060
And I could have done the very
specific version of Safari,

00:15:23.060 --> 00:15:25.550
but I didn't want to-- you know,
if they introduce the

00:15:25.550 --> 00:15:27.430
bug in one version, who's to
say they're not going to

00:15:27.430 --> 00:15:28.590
introduce it in another
version?

00:15:28.590 --> 00:15:31.060
So I just wanted to
move on with life

00:15:31.060 --> 00:15:34.760
and get it over with.

00:15:34.760 --> 00:15:38.570
So what I learned here is
that it sounds really--

00:15:38.570 --> 00:15:41.220
these new APIs, they seem
really exciting.

00:15:41.220 --> 00:15:47.530
And if you go to conferences a
lot, like you guys might, you

00:15:47.530 --> 00:15:49.040
hear about these new APIs
and you're like,

00:15:49.040 --> 00:15:49.660
oh, that's so cool.

00:15:49.660 --> 00:15:51.290
I'm going to go home
and implement it

00:15:51.290 --> 00:15:52.680
immediately for my app.

00:15:52.680 --> 00:15:54.150
And you get really excited.

00:15:54.150 --> 00:15:57.730
But you've got to be careful
about using new APIs, because

00:15:57.730 --> 00:15:59.640
the bugs in them are new.

00:15:59.640 --> 00:16:02.080
They're not documented.

00:16:02.080 --> 00:16:06.120
New bugs will come up in recent
versions of browsers.

00:16:06.120 --> 00:16:08.240
And especially if you're doing
something, if it's some

00:16:08.240 --> 00:16:11.530
mission-critical part of your
site, like signup, I wouldn't

00:16:11.530 --> 00:16:14.100
recommend trying out
a new API there.

00:16:14.100 --> 00:16:16.770
If it's a mission-critical part
of your site, then just

00:16:16.770 --> 00:16:18.790
go with the old techniques.

00:16:18.790 --> 00:16:22.650
They might not be as cool, but
we've had them for years.

00:16:22.650 --> 00:16:24.080
And people have tested them.

00:16:24.080 --> 00:16:26.200
And people know what all
the bugs are with

00:16:26.200 --> 00:16:28.280
file upload in IE7.

00:16:28.280 --> 00:16:30.640
And they've figured them
out in libraries.

00:16:30.640 --> 00:16:35.510
So I would say try and use those
old APIs and libraries

00:16:35.510 --> 00:16:39.220
that people have written,
because they're battle-tested.

00:16:39.220 --> 00:16:43.280
And you don't want to be using
something so new and shiny for

00:16:43.280 --> 00:16:45.840
something that's so important.

00:16:45.840 --> 00:16:51.010
Now, for browsers, we really
need accessors for anything

00:16:51.010 --> 00:16:52.450
that has storage in it.

00:16:52.450 --> 00:16:54.810
Like with LocalStorage, if there
was no accessor, I would

00:16:54.810 --> 00:16:56.970
have had no way of knowing that
it actually successfully

00:16:56.970 --> 00:16:58.090
stored something.

00:16:58.090 --> 00:16:59.910
So this is something that
they should add to any

00:16:59.910 --> 00:17:03.190
sort of API like this.

00:17:03.190 --> 00:17:07.339
So now let's talk a bit about
CSS, because this is something

00:17:07.339 --> 00:17:09.180
that you can run into as well,
because we have a lot

00:17:09.180 --> 00:17:11.560
of fancy CSS now.

00:17:11.560 --> 00:17:15.250
We've got shiny animations
and transforms.

00:17:15.250 --> 00:17:17.119
So I was working on that mobile

00:17:17.119 --> 00:17:18.950
web app, using PhoneGap.

00:17:18.950 --> 00:17:20.720
And I had this embedded
WebView.

00:17:20.720 --> 00:17:23.420
And I decided to do it as a
mobile web app because I

00:17:23.420 --> 00:17:24.640
already knew HTML and CSS.

00:17:24.640 --> 00:17:26.670
And I was like, I already
know HTML and CSS.

00:17:26.670 --> 00:17:28.144
I'm just going to use
it to make this app.

00:17:28.144 --> 00:17:28.790
I'll be great.

00:17:28.790 --> 00:17:30.620
I don't have to learn
something new.

00:17:30.620 --> 00:17:34.100
And at the time, I
was doing it for

00:17:34.100 --> 00:17:35.190
both iPhone and Android.

00:17:35.190 --> 00:17:37.780
And only iPhone had a set
of design guidelines.

00:17:37.780 --> 00:17:40.440
Android hadn't really come
up with anything yet.

00:17:40.440 --> 00:17:42.740
So I just followed the iPhone
design guidelines.

00:17:42.740 --> 00:17:46.900
And they were a lot of like
rounded corners and gradients

00:17:46.900 --> 00:17:48.790
and they kind of looked
really bubbly.

00:17:48.790 --> 00:17:51.700
And luckily, CSS3 made it really
easy to make something

00:17:51.700 --> 00:17:54.650
look iPhone-y, because we have
the box shadow and the

00:17:54.650 --> 00:17:57.870
gradient and the border radius
and all of that.

00:17:57.870 --> 00:17:59.200
So I had my app.

00:17:59.200 --> 00:18:00.350
And it was all good.

00:18:00.350 --> 00:18:04.410
And I was feeling good, having
it out on the markets there.

00:18:04.410 --> 00:18:09.170
But then what happened is I was
using Android at the time

00:18:09.170 --> 00:18:12.380
and I would notice from time to
time that the entire screen

00:18:12.380 --> 00:18:15.260
would just go completely
white.

00:18:15.260 --> 00:18:16.640
And I would be unable--

00:18:16.640 --> 00:18:18.080
there would just be nothing
there anymore.

00:18:18.080 --> 00:18:22.650
And I would have to restart the
app or somehow go back.

00:18:22.650 --> 00:18:24.000
And it was kind of useless.

00:18:24.000 --> 00:18:26.320
You can't use an app that's
just a white screen.

00:18:26.320 --> 00:18:28.150
It's highly unfunctional.

00:18:28.150 --> 00:18:29.390
So I was like, OK.

00:18:29.390 --> 00:18:32.250
Clearly something is not working
in this app that I

00:18:32.250 --> 00:18:33.520
need to work out.

00:18:33.520 --> 00:18:36.680
And I kind of had a suspicion
that maybe Android didn't like

00:18:36.680 --> 00:18:38.340
all this fancy CSS.

00:18:38.340 --> 00:18:41.640
I'd kind of heard rumors that
Android wasn't so good with

00:18:41.640 --> 00:18:43.890
new CSS3 stuff.

00:18:43.890 --> 00:18:46.760
So I suspected that it was
having trouble actually

00:18:46.760 --> 00:18:48.060
rendering this.

00:18:48.060 --> 00:18:52.420
So what I did was I spent an
entire afternoon sitting there

00:18:52.420 --> 00:18:55.670
commenting out CSS, redeploying
my APK to my

00:18:55.670 --> 00:18:59.860
phone, scrolling and scrolling
and scrolling, waiting to see

00:18:59.860 --> 00:19:01.220
if I got a white screen.

00:19:01.220 --> 00:19:02.830
That was probably one
of the most boring

00:19:02.830 --> 00:19:05.740
afternoons of my life.

00:19:05.740 --> 00:19:08.180
And so eventually, I did figure
out that if I commented

00:19:08.180 --> 00:19:11.490
out enough of the fancy CSS,
that I wouldn't get white

00:19:11.490 --> 00:19:13.000
screens anymore.

00:19:13.000 --> 00:19:15.450
And I didn't want to have to
sit there and figure out

00:19:15.450 --> 00:19:19.140
exactly how much CSS Android
can handle, because it was

00:19:19.140 --> 00:19:20.400
just really boring.

00:19:20.400 --> 00:19:21.885
So I decided, well,
you know what?

00:19:21.885 --> 00:19:23.720
I'm just going to get
rid of all of it.

00:19:23.720 --> 00:19:25.420
I'll take away the border
radius, the

00:19:25.420 --> 00:19:27.620
gradients, the box shadows.

00:19:27.620 --> 00:19:30.890
And so it ended up looking
really flat.

00:19:30.890 --> 00:19:33.280
Then, conveniently, Android
came out with their design

00:19:33.280 --> 00:19:36.650
guidelines, which were the
opposite of iPhone's.

00:19:36.650 --> 00:19:39.830
And their design guidelines
were flat,

00:19:39.830 --> 00:19:43.400
not gradient, square.

00:19:43.400 --> 00:19:44.830
Wow, that's perfect.

00:19:44.830 --> 00:19:46.420
It's like you knew
that you were

00:19:46.420 --> 00:19:48.170
incapable of handling CSS3.

00:19:50.860 --> 00:19:52.840
So that worked out really
well, actually.

00:19:52.840 --> 00:19:55.480
But the thing is that I still
wanted to have the iPhone look

00:19:55.480 --> 00:19:59.490
and feel for iPhone users and
the Android look and feel for

00:19:59.490 --> 00:20:00.460
the Android users.

00:20:00.460 --> 00:20:04.600
And I was doing this from the
same code base, so I needed to

00:20:04.600 --> 00:20:05.930
detect Android.

00:20:05.930 --> 00:20:08.750
So you can see here the
transformation from the iPhone

00:20:08.750 --> 00:20:10.370
to the Android.

00:20:10.370 --> 00:20:14.380
So to detect Android, it's a
little more complex than you

00:20:14.380 --> 00:20:15.490
would imagine.

00:20:15.490 --> 00:20:17.990
I was doing the standard user
agent check for popular

00:20:17.990 --> 00:20:19.090
Android devices.

00:20:19.090 --> 00:20:21.630
I was also using the PhoneGap
API that they provide for

00:20:21.630 --> 00:20:22.820
checking device.

00:20:22.820 --> 00:20:25.610
And I was also checking the URL
parameter, because I test

00:20:25.610 --> 00:20:28.150
my mobile web app in the browser
as well, so I wanted

00:20:28.150 --> 00:20:30.310
to be able to just fake Android
when I was testing in

00:20:30.310 --> 00:20:31.460
the browser.

00:20:31.460 --> 00:20:34.070
But finally, when I decided to
Android, I add the Android

00:20:34.070 --> 00:20:35.720
class to the body tag.

00:20:35.720 --> 00:20:38.230
And then in my CSS, I can
just say, oh, OK.

00:20:38.230 --> 00:20:41.190
If we're looking at a modal
class inside the Android body

00:20:41.190 --> 00:20:44.640
class, then just reset all
these fancy things.

00:20:44.640 --> 00:20:46.630
Box shadow, none.

00:20:46.630 --> 00:20:48.660
No border radius.

00:20:48.660 --> 00:20:49.530
Get rid of all that.

00:20:49.530 --> 00:20:51.590
Reset it all to zero.

00:20:51.590 --> 00:20:52.600
And that worked.

00:20:52.600 --> 00:20:55.980
So what I learned here is that
just because something is

00:20:55.980 --> 00:21:00.190
supported, does not mean
it's supported well.

00:21:00.190 --> 00:21:03.060
It's really easy to throw in
support for these things.

00:21:03.060 --> 00:21:06.220
It's much harder to make them
work really well and be really

00:21:06.220 --> 00:21:10.780
performant, especially
for this CSS3 stuff.

00:21:10.780 --> 00:21:13.930
So you really need to check for
that, and especially if

00:21:13.930 --> 00:21:15.680
you're using these
features in bulk.

00:21:15.680 --> 00:21:18.230
Part of my problem was that
I had kind of an infinite

00:21:18.230 --> 00:21:19.660
scrolling interface.

00:21:19.660 --> 00:21:22.370
So there was potentially lots
and lots of these features

00:21:22.370 --> 00:21:25.270
that were kind of building up
and being used by the browser.

00:21:25.270 --> 00:21:29.150
I think if I only had a limited
amount of usage of it,

00:21:29.150 --> 00:21:32.100
I probably could have more
easily controlled it and

00:21:32.100 --> 00:21:34.130
predicted how it would form.

00:21:34.130 --> 00:21:37.510
But since I had more and more of
this CSS3 features building

00:21:37.510 --> 00:21:39.760
up, I think that contributed
to Android kind of freaking

00:21:39.760 --> 00:21:43.210
out and going, oh,
it's too many.

00:21:43.210 --> 00:21:46.630
I'm just guessing that's
what Android does.

00:21:46.630 --> 00:21:49.260
So if you have any sort of
interfaces which potentially

00:21:49.260 --> 00:21:52.330
get bigger and bigger amounts
of content and don't have a

00:21:52.330 --> 00:21:56.870
finite cap, really be careful
about your performance there.

00:21:56.870 --> 00:22:00.140
I worked on the Google
Wave team years ago.

00:22:00.140 --> 00:22:05.210
And we had that problem
with Waves, Waves

00:22:05.210 --> 00:22:06.710
that got way too long.

00:22:06.710 --> 00:22:08.910
They just had too much
DOM inside them.

00:22:08.910 --> 00:22:11.300
So we really had to look at
that DOM and say, OK, we

00:22:11.300 --> 00:22:13.700
probably shouldn't be using
a table to make all of our

00:22:13.700 --> 00:22:17.250
buttons, because that really,
really adds up when you get

00:22:17.250 --> 00:22:18.710
these really long Waves.

00:22:18.710 --> 00:22:22.970
So definitely any place where
you've got this scrolling or

00:22:22.970 --> 00:22:25.410
lots of things adding
up, look out for it.

00:22:25.410 --> 00:22:29.690
Now for browsers, I just want
browsers to know their limits.

00:22:29.690 --> 00:22:32.470
I would much rather that
Android realize that it

00:22:32.470 --> 00:22:37.100
couldn't render my fancy CSS and
just not done it, instead

00:22:37.100 --> 00:22:39.660
of pretending it could do it
and then rendering a white

00:22:39.660 --> 00:22:45.330
screen, because white screens
are really not easy to use.

00:22:45.330 --> 00:22:46.540
It's like worse than
blue screens.

00:22:46.540 --> 00:22:48.900
At least blue screens you know
it's a blue screen of death.

00:22:48.900 --> 00:22:49.700
You're like, oh, OK.

00:22:49.700 --> 00:22:49.965
It died.

00:22:49.965 --> 00:22:51.500
I'm just going to restart it.

00:22:51.500 --> 00:22:53.720
White screens it's like,
eh, I don't know

00:22:53.720 --> 00:22:54.420
what's going on here.

00:22:54.420 --> 00:22:56.690
It's kind of abstract.

00:22:56.690 --> 00:22:59.580
So browsers should just
know their limits.

00:22:59.580 --> 00:23:00.580
So should all of us.

00:23:00.580 --> 00:23:03.320
OK.

00:23:03.320 --> 00:23:06.040
So finally I want to talk about
a signup process that we

00:23:06.040 --> 00:23:09.250
have at Coursera that I helped
on a few months ago.

00:23:09.250 --> 00:23:11.560
So we introduced this thing
called Signature Track, which

00:23:11.560 --> 00:23:15.020
is a way of taking courses while
verifying your identity.

00:23:15.020 --> 00:23:17.690
And there are a few technical
components of Signature Track.

00:23:17.690 --> 00:23:20.270
And we wanted to make sure that
people knew about these

00:23:20.270 --> 00:23:22.710
technical requirements before
they signed up, because I

00:23:22.710 --> 00:23:25.130
didn't want users to get
halfway through this

00:23:25.130 --> 00:23:27.930
multi-step signup process and
then realize that there was no

00:23:27.930 --> 00:23:30.180
way they would've able to
complete it and then they get

00:23:30.180 --> 00:23:33.060
all mad, like, Coursera, why
you tease me like that?

00:23:33.060 --> 00:23:39.390
So the requirements were that
you needed to have a physical

00:23:39.390 --> 00:23:43.210
keyboard, because we do this
keystroke biometrics algorithm

00:23:43.210 --> 00:23:45.730
and it doesn't work so well
on soft keyboards.

00:23:45.730 --> 00:23:48.400
So we wanted you to have a
real physical keyboard.

00:23:48.400 --> 00:23:50.630
You needed to have a webcam,
because we took a picture of

00:23:50.630 --> 00:23:53.070
your face every time you took a
quiz and when you signed up

00:23:53.070 --> 00:23:55.520
and match it to your ID.

00:23:55.520 --> 00:23:58.320
So we couldn't have you do it
if you didn't have a webcam.

00:23:58.320 --> 00:24:01.030
And you needed to have
a modern browser.

00:24:01.030 --> 00:24:02.990
And also you needed to have
Flash, because we're using

00:24:02.990 --> 00:24:04.860
Flash to get the webcam stuff.

00:24:04.860 --> 00:24:07.610
I know that you can it
in HTML5, but it

00:24:07.610 --> 00:24:09.720
didn't work so well.

00:24:09.720 --> 00:24:13.790
So I needed to figure out how to
do checks for all of these.

00:24:13.790 --> 00:24:15.650
The first thing was a
physical keyboard.

00:24:15.650 --> 00:24:18.330
And that was a little tricky,
because there's no such thing

00:24:18.330 --> 00:24:19.820
as asking the browser
if there's a

00:24:19.820 --> 00:24:21.790
physical keyboard attached.

00:24:21.790 --> 00:24:23.930
So we said, all right, well,
maybe we should just look to

00:24:23.930 --> 00:24:25.500
see if it's a touch device.

00:24:25.500 --> 00:24:27.800
So we started off with this
check here, like is

00:24:27.800 --> 00:24:30.380
ontouchstart in window or
DocumentTouch, then OK, we're

00:24:30.380 --> 00:24:31.580
on a touch device.

00:24:31.580 --> 00:24:34.520
And we rolled that out, but we
immediately got cases where it

00:24:34.520 --> 00:24:36.220
thought you were on a touch
device and you weren't and

00:24:36.220 --> 00:24:37.920
vice versa.

00:24:37.920 --> 00:24:39.830
And people would actually
have physical keyboards.

00:24:39.830 --> 00:24:40.570
And we're like, all right.

00:24:40.570 --> 00:24:44.310
We are just going to blacklist
mobile browsers.

00:24:44.310 --> 00:24:47.040
So basically, you're only going
to be able to do this on

00:24:47.040 --> 00:24:48.190
your desktop browser.

00:24:48.190 --> 00:24:50.770
And we'll give you a link to
let us know that if you

00:24:50.770 --> 00:24:52.940
actually do have a physical
keyboard, we'll

00:24:52.940 --> 00:24:55.100
give you that option.

00:24:55.100 --> 00:24:57.490
So we ended up doing that,
because we needed something--

00:24:57.490 --> 00:25:00.590
I just needed something that
worked to get this out fast.

00:25:00.590 --> 00:25:02.720
But the thing is, we
would tell people.

00:25:02.720 --> 00:25:06.400
So every time I would detect
something about a user, I

00:25:06.400 --> 00:25:08.990
would let them know like, hey,
this is the reason that we're

00:25:08.990 --> 00:25:12.010
not letting you do it, so that
then they could see.

00:25:12.010 --> 00:25:15.290
And then they could contact us
and say, oh, hey, you say that

00:25:15.290 --> 00:25:17.150
you blocked me because I didn't
have a hard keyboard,

00:25:17.150 --> 00:25:18.460
but actually I do.

00:25:18.460 --> 00:25:20.910
And then we can decide to
unblock them or we can change

00:25:20.910 --> 00:25:22.890
our blocking process.

00:25:22.890 --> 00:25:25.880
We actually haven't gotten
emails about that check yet,

00:25:25.880 --> 00:25:28.810
so I guess it's kind
of working.

00:25:28.810 --> 00:25:31.990
Now I just want to give an aside
on touch events, because

00:25:31.990 --> 00:25:34.460
touch events are really, really
interesting things.

00:25:34.460 --> 00:25:37.370
And there's been a lot of very
interesting articles lately

00:25:37.370 --> 00:25:41.050
about touch events and
whether you should be

00:25:41.050 --> 00:25:42.610
detecting them and how.

00:25:42.610 --> 00:25:46.480
So if we want to look for touch
events, there's a couple

00:25:46.480 --> 00:25:49.270
things we have to do across
different browsers to find out

00:25:49.270 --> 00:25:53.180
if that browser is capable
of doing touch events.

00:25:53.180 --> 00:25:55.660
But there's a difference between
a browser supporting

00:25:55.660 --> 00:25:59.130
touch events and the user
actually using touch events.

00:25:59.130 --> 00:26:02.140
So if you're on an Android
tablet, you could still

00:26:02.140 --> 00:26:04.380
connect a mouse to
your tablet.

00:26:04.380 --> 00:26:06.490
And you can actually potentially
be using a website

00:26:06.490 --> 00:26:10.490
and switching between using a
mouse and using your finger on

00:26:10.490 --> 00:26:13.300
the same web page.

00:26:13.300 --> 00:26:15.630
So that means as a developer
you shouldn't be relying on

00:26:15.630 --> 00:26:19.840
just the fact that something's a
touch device as meaning that

00:26:19.840 --> 00:26:22.180
you should be just be doing
everything reacting to touch,

00:26:22.180 --> 00:26:24.530
because a lot of times the users
can connect these other

00:26:24.530 --> 00:26:25.280
devices as well.

00:26:25.280 --> 00:26:27.230
And I think this is going to
become more and more common,

00:26:27.230 --> 00:26:29.400
that we'll have these devices
that are both.

00:26:29.400 --> 00:26:31.740
I mean, we all just got that
Chrome Pixel, right?

00:26:31.740 --> 00:26:35.250
And a Chrome Pixel is a
touchscreen and a keyboard and

00:26:35.250 --> 00:26:38.060
you have a little mouse
down there.

00:26:38.060 --> 00:26:40.040
So this is becoming more and
more the reality, so we have

00:26:40.040 --> 00:26:43.810
to be really careful that when
we're looking for touch, that

00:26:43.810 --> 00:26:45.910
we consider the fact that
they could still

00:26:45.910 --> 00:26:48.710
be using click events.

00:26:48.710 --> 00:26:50.720
So the standard way--

00:26:50.720 --> 00:26:54.570
or one way that you could
actually not care about this

00:26:54.570 --> 00:26:57.470
is that you could listen to a
touch event and if you get a

00:26:57.470 --> 00:26:59.790
touch event, you would just
trigger your listener for the

00:26:59.790 --> 00:27:00.220
click event.

00:27:00.220 --> 00:27:04.370
And basically, they would both
do the same thing, so that way

00:27:04.370 --> 00:27:08.010
the user can go between using
touching and using click and

00:27:08.010 --> 00:27:10.730
your web page should respond
exactly the same way.

00:27:10.730 --> 00:27:13.530
So if you are doing anything
right now or thinking about

00:27:13.530 --> 00:27:15.520
doing something where you're
detecting touch events and

00:27:15.520 --> 00:27:18.470
doing something different, think
to yourself, how would

00:27:18.470 --> 00:27:23.090
this work if the user also
had a mouse attached?

00:27:23.090 --> 00:27:25.940
How would it work if they
switched between the mouse and

00:27:25.940 --> 00:27:28.060
this touch screen halfway
through the interaction?

00:27:28.060 --> 00:27:32.070
That's kind of the trickiest,
but it could happen.

00:27:32.070 --> 00:27:33.980
And there are some really
interesting articles about

00:27:33.980 --> 00:27:35.330
that there.

00:27:35.330 --> 00:27:35.850
OK.

00:27:35.850 --> 00:27:37.640
So that's an aside.

00:27:37.640 --> 00:27:39.690
We also need to detect
the Flash plug-in.

00:27:39.690 --> 00:27:43.200
And I just used the SWFObject
library for this, which is a

00:27:43.200 --> 00:27:44.430
nice, well-supported library.

00:27:44.430 --> 00:27:46.530
And it'll even tell you the
Flash Player versions, in case

00:27:46.530 --> 00:27:48.730
you want to support
particular verses.

00:27:48.730 --> 00:27:50.730
And I also wanted to
check for a webcam.

00:27:50.730 --> 00:27:54.170
Unfortunately, there is no way
to check for a webcam unless

00:27:54.170 --> 00:27:58.520
you actually put up the webcam
prompt and ask the user to

00:27:58.520 --> 00:27:59.870
give permission.

00:27:59.870 --> 00:28:02.260
And I wanted to check for this
before they even got to the

00:28:02.260 --> 00:28:04.150
webcam part of the process.

00:28:04.150 --> 00:28:05.160
So I gave up.

00:28:05.160 --> 00:28:08.760
And we put up a little modal
that said, hey, remember, you

00:28:08.760 --> 00:28:09.870
need a webcam.

00:28:09.870 --> 00:28:13.640
And presumably if they saw that
and decided to keep going

00:28:13.640 --> 00:28:16.300
even though they didn't have a
webcam, well, that's their

00:28:16.300 --> 00:28:17.950
prerogative.

00:28:17.950 --> 00:28:19.840
So sometimes you just
can't detect things.

00:28:19.840 --> 00:28:24.480
And you have to accept that.

00:28:24.480 --> 00:28:29.560
So in this case, I learned that
you can't detect things

00:28:29.560 --> 00:28:30.140
all the time.

00:28:30.140 --> 00:28:31.640
And you have to do
different things.

00:28:31.640 --> 00:28:35.920
And if you do decide to block
users, which can be a bad

00:28:35.920 --> 00:28:38.640
thing, but if you do block
them, tell them why you

00:28:38.640 --> 00:28:39.560
blocked them.

00:28:39.560 --> 00:28:45.080
Give them an option to contact
you and explain what their

00:28:45.080 --> 00:28:46.120
particular setup is.

00:28:46.120 --> 00:28:49.160
And maybe you'll realize then
that the code you're using

00:28:49.160 --> 00:28:51.550
could actually be
much improved.

00:28:51.550 --> 00:28:54.040
And for browsers, I would really
like for browsers to

00:28:54.040 --> 00:28:57.500
give us a way to detect those
physical devices and plug-ins

00:28:57.500 --> 00:28:59.450
so I wouldn't have to go through
all this effort to try

00:28:59.450 --> 00:29:00.080
and figure it out.

00:29:00.080 --> 00:29:02.700
So something like, is there
a physical keyboard?

00:29:02.700 --> 00:29:04.240
Are they using it right now?

00:29:04.240 --> 00:29:05.470
Do they have a webcam?

00:29:05.470 --> 00:29:06.540
Do they have Flash?

00:29:06.540 --> 00:29:10.190
Those would all have made my
life much, much easier.

00:29:10.190 --> 00:29:12.710
So to finish up, this
is a reminder of

00:29:12.710 --> 00:29:13.670
why this all matters.

00:29:13.670 --> 00:29:16.060
This is a visualization of
browser support for a

00:29:16.060 --> 00:29:16.970
particular feature.

00:29:16.970 --> 00:29:18.980
And there's lots more
visualizations of this, but

00:29:18.980 --> 00:29:21.400
the point is that, yeah, we're
going to have unequal

00:29:21.400 --> 00:29:24.670
distribution of feature support
for a long time going

00:29:24.670 --> 00:29:26.400
forward, basically forever.

00:29:26.400 --> 00:29:28.460
People will keep coming
up with new things.

00:29:28.460 --> 00:29:30.560
Browsers will keep not
implementing them at the same

00:29:30.560 --> 00:29:32.490
rate, keep implementing them
in different ways, with

00:29:32.490 --> 00:29:34.160
different performance concerns,
with different

00:29:34.160 --> 00:29:35.400
attributes supported.

00:29:35.400 --> 00:29:37.960
And we're going to just have
to keep dealing with that.

00:29:37.960 --> 00:29:39.560
So this is something that we're
going to have to think

00:29:39.560 --> 00:29:43.600
about for years to come.

00:29:43.600 --> 00:29:44.830
Now browsers are
aware of this.

00:29:44.830 --> 00:29:45.970
And browsers are
trying to help.

00:29:45.970 --> 00:29:48.650
So browsers, they did
introduce this CSS

00:29:48.650 --> 00:29:51.720
conditionals, level 3 spec,
which actually has this

00:29:51.720 --> 00:29:54.690
@support rule for CSS, where
you can say, oh, hey.

00:29:54.690 --> 00:29:57.050
Does this browser actually
support this CSS?

00:29:57.050 --> 00:29:58.880
And then you could serve
different styles.

00:29:58.880 --> 00:30:00.530
And they've got the same
thing in JavaScript,

00:30:00.530 --> 00:30:02.200
window.supportsCSS.

00:30:02.200 --> 00:30:04.760
And this is actually supported
by three browsers now.

00:30:04.760 --> 00:30:06.300
So the cool thing is that
browsers are actually

00:30:06.300 --> 00:30:08.140
realizing that, yeah,
this is something

00:30:08.140 --> 00:30:09.030
developers care about.

00:30:09.030 --> 00:30:10.800
And they're trying to come up
with more ways for us to

00:30:10.800 --> 00:30:11.790
figure it out.

00:30:11.790 --> 00:30:13.860
But this is still really
cutting-edge.

00:30:13.860 --> 00:30:17.280
And most of you, we won't be
able to use this quite yet.

00:30:17.280 --> 00:30:20.850
So in the meantime, what should
be your strategy?

00:30:20.850 --> 00:30:23.430
First of all, don't assume it's
going to be easy, because

00:30:23.430 --> 00:30:24.200
sometimes it's not.

00:30:24.200 --> 00:30:25.810
And if you assume it's easy,
you might look for an easy

00:30:25.810 --> 00:30:28.380
solution and overlook all
the complexities.

00:30:28.380 --> 00:30:30.940
Don't just copy the first answer
off Stack Overflow,

00:30:30.940 --> 00:30:32.450
which is something I do a lot.

00:30:32.450 --> 00:30:36.940
But I'm trying to
cut back on it.

00:30:36.940 --> 00:30:39.480
Do use the tried and
true techniques.

00:30:39.480 --> 00:30:41.480
So use popular and well-tested
libraries.

00:30:41.480 --> 00:30:43.270
Look at the number of forks,
the number of issues, the

00:30:43.270 --> 00:30:44.500
number of contributors.

00:30:44.500 --> 00:30:46.620
Look at how recently
the change was.

00:30:46.620 --> 00:30:48.260
Browse through the issue tracker
and see what people

00:30:48.260 --> 00:30:50.220
say about it.

00:30:50.220 --> 00:30:51.580
And if you're not
sure, just ask.

00:30:51.580 --> 00:30:53.500
When I was trying to figure
out the Signature Track

00:30:53.500 --> 00:30:56.430
process, I just emailed my
buddies on the Chrome

00:30:56.430 --> 00:30:57.650
team and said, hey.

00:30:57.650 --> 00:31:00.180
Is there anything I'm not
thinking of here?

00:31:00.180 --> 00:31:02.290
And we don't all of have buddies
on the Chrome team,

00:31:02.290 --> 00:31:05.410
but we do all have Paul Irish's
Twitter account.

00:31:05.410 --> 00:31:08.490
So I recommend just tweeting
at him, because he really

00:31:08.490 --> 00:31:09.670
likes to answer these things.

00:31:09.670 --> 00:31:11.230
And he's got the lowdown.

00:31:11.230 --> 00:31:12.850
So don't be afraid to ask.

00:31:12.850 --> 00:31:15.570
There's a lot of people out
there that'll answer.

00:31:15.570 --> 00:31:17.540
And do try feature
detection first.

00:31:17.540 --> 00:31:18.780
So use Modernizr.

00:31:18.780 --> 00:31:21.060
And you can see all the
different ways of using it.

00:31:21.060 --> 00:31:23.970
Also, if you do need to do user
agent detection, use this

00:31:23.970 --> 00:31:26.000
library called ua-parser.

00:31:26.000 --> 00:31:28.440
It's maintained by BrowserStack
and contributed

00:31:28.440 --> 00:31:30.460
to by Google and Facebook.

00:31:30.460 --> 00:31:34.020
So it's got a lot of great,
well-tested regex's in it.

00:31:34.020 --> 00:31:36.570
And it's supported in lots
of different languages.

00:31:36.570 --> 00:31:38.050
And you can also
mix and match.

00:31:38.050 --> 00:31:40.610
You can see if something works
and then maybe blacklist it

00:31:40.610 --> 00:31:42.850
for certain browsers that
you know have problems.

00:31:42.850 --> 00:31:44.370
Certain browsers and versions,
that's the

00:31:44.370 --> 00:31:47.330
best kind of blacklist.

00:31:47.330 --> 00:31:50.960
Basically, the conclusion here
is that we don't have that.

00:31:50.960 --> 00:31:53.380
Do you guys know what
that is up there?

00:31:53.380 --> 00:31:53.680
Yeah.

00:31:53.680 --> 00:31:56.170
So that's a sonic screwdriver
from Doctor Who.

00:31:56.170 --> 00:31:58.430
And basically, it can
do everything.

00:31:58.430 --> 00:32:01.210
We don't have something that
can do everything.

00:32:01.210 --> 00:32:04.310
We don't have the perfect
solution in web development.

00:32:04.310 --> 00:32:06.020
That's just how it is.

00:32:06.020 --> 00:32:09.550
But we do have a lot of
tools in our tool box.

00:32:09.550 --> 00:32:11.450
And we can learn how
to use those tools.

00:32:11.450 --> 00:32:12.650
And we can combine
them together.

00:32:12.650 --> 00:32:15.540
And we can try and use the more
sophisticated ones first.

00:32:15.540 --> 00:32:18.660
And we also have each other, so
that we can learn from each

00:32:18.660 --> 00:32:20.510
other about how to learn
these tools, so we're

00:32:20.510 --> 00:32:21.270
not alone in it.

00:32:21.270 --> 00:32:24.110
So when you're figuring this
out, look to each other for

00:32:24.110 --> 00:32:27.330
the solutions, document what
you find out, write it up,

00:32:27.330 --> 00:32:30.900
open source your code, and then
we'll all learn how to do

00:32:30.900 --> 00:32:33.800
all this detection together,
so that we can fully take

00:32:33.800 --> 00:32:36.900
advantage of everything the
web has for us today.

00:32:36.900 --> 00:32:38.510
Got it?

00:32:38.510 --> 00:32:39.394
Done.

00:32:39.394 --> 00:32:49.280
[APPLAUSE]

00:32:49.280 --> 00:32:50.590
PAMELA FOX: So, questions,
yeah?

00:32:53.190 --> 00:32:55.540
Anyone have questions?

00:32:55.540 --> 00:32:57.080
Speechless.

00:32:57.080 --> 00:32:58.395
Doctor Who episodes, perhaps?

00:33:04.480 --> 00:33:06.200
There's a little microphone-y
thing there.

00:33:10.610 --> 00:33:11.210
AUDIENCE: OK.

00:33:11.210 --> 00:33:14.350
So there seems to be kind
of an underlying

00:33:14.350 --> 00:33:15.520
theme to all of this.

00:33:15.520 --> 00:33:18.210
And that is, you're doing
all this checking.

00:33:18.210 --> 00:33:20.670
It almost feels like you're
trying to implement what you

00:33:20.670 --> 00:33:26.340
can when you can, rather than
trying to develop to implement

00:33:26.340 --> 00:33:29.510
to cover as many browsers as
possible and then dealing with

00:33:29.510 --> 00:33:30.270
exceptions.

00:33:30.270 --> 00:33:35.510
Am I just kind of reading into
that the wrong way or--

00:33:35.510 --> 00:33:37.260
PAMELA FOX: So you're wondering,
am I trying to use

00:33:37.260 --> 00:33:38.670
new things--

00:33:38.670 --> 00:33:41.410
am I trying like overly hard
to use new things, versus

00:33:41.410 --> 00:33:43.470
using the older things?

00:33:43.470 --> 00:33:44.740
AUDIENCE: I wouldn't
say overly hard.

00:33:44.740 --> 00:33:47.850
But it seems like not just
you, I see a lot of

00:33:47.850 --> 00:33:48.580
developers out there.

00:33:48.580 --> 00:33:51.470
I feel like there's this push,
this emphasis to use

00:33:51.470 --> 00:33:54.460
everything possibly available,
even if it causes

00:33:54.460 --> 00:33:55.910
10 times the work.

00:33:55.910 --> 00:33:58.160
PAMELA FOX: Right.

00:33:58.160 --> 00:33:58.820
Yeah.

00:33:58.820 --> 00:34:00.480
I think that's a good point.

00:34:00.480 --> 00:34:02.860
I think that we see the new
stuff and we get really

00:34:02.860 --> 00:34:03.670
excited about it.

00:34:03.670 --> 00:34:06.770
And it makes us feel good to try
out the new stuff, because

00:34:06.770 --> 00:34:10.040
we feel like we're on
the cutting edge.

00:34:10.040 --> 00:34:12.330
It's kind of like Not Invented
Here syndrome.

00:34:12.330 --> 00:34:14.900
It helps us kind of feel like
inventors if we're using the

00:34:14.900 --> 00:34:15.620
new stuff too.

00:34:15.620 --> 00:34:17.460
And we're going on this alone.

00:34:17.460 --> 00:34:18.280
But it's true.

00:34:18.280 --> 00:34:22.830
Nowadays, like at Coursera, most
of time I will just try

00:34:22.830 --> 00:34:26.929
and go with the tried and true
techniques now, because now

00:34:26.929 --> 00:34:29.060
that I've had this much
experience with trying the new

00:34:29.060 --> 00:34:32.639
stuff, I like knowing
that it's there.

00:34:32.639 --> 00:34:34.750
But I also know that if I'm
going to try it out, I'm

00:34:34.750 --> 00:34:36.560
probably going to be one of the
first people to really try

00:34:36.560 --> 00:34:37.670
it out in a big app.

00:34:37.670 --> 00:34:39.179
And I'm going to have
to struggle with

00:34:39.179 --> 00:34:40.310
figuring that out.

00:34:40.310 --> 00:34:42.540
And sometimes I'm up for that
challenge, because it can be

00:34:42.540 --> 00:34:43.320
quite interesting.

00:34:43.320 --> 00:34:45.530
But sometimes I just
want it to work.

00:34:45.530 --> 00:34:45.850
AUDIENCE: OK.

00:34:45.850 --> 00:34:48.420
So I hadn't quite formed
the question until now

00:34:48.420 --> 00:34:49.730
that you've said that.

00:34:49.730 --> 00:34:52.320
In your experience, these things
that are out there, are

00:34:52.320 --> 00:34:56.179
they generally stable enough
that it's OK for the better

00:34:56.179 --> 00:34:59.740
part of the user base
to try to use them

00:34:59.740 --> 00:35:00.570
and deal with them?

00:35:00.570 --> 00:35:04.240
Or if you've got to really deal
with the general public,

00:35:04.240 --> 00:35:07.800
should you just stick with those
tried and true methods?

00:35:07.800 --> 00:35:09.300
PAMELA FOX: It really depends
on what they are.

00:35:09.300 --> 00:35:13.520
Some of them have been out there
for longer than others.

00:35:13.520 --> 00:35:17.040
I guess I've experienced even
with LocalStorage that

00:35:17.040 --> 00:35:19.580
browsers introduce new bugs.

00:35:19.580 --> 00:35:21.940
And it's even been around
for a couple of years.

00:35:21.940 --> 00:35:23.720
We use HTML5 video
at Coursera.

00:35:23.720 --> 00:35:26.350
And we still have a lot
of problems with it.

00:35:26.350 --> 00:35:27.920
And it's been out for
a year or so.

00:35:27.920 --> 00:35:30.600
So we've started defaulting
users to Flash instead.

00:35:30.600 --> 00:35:31.750
AUDIENCE: OK.

00:35:31.750 --> 00:35:32.730
That right there says a lot.

00:35:32.730 --> 00:35:34.870
PAMELA FOX: So sometimes there
are advantages to stuff.

00:35:34.870 --> 00:35:36.830
We're using HTML5 video at
Coursera because we get

00:35:36.830 --> 00:35:39.250
playback rate, because we can
do the speed-it-up buttons.

00:35:39.250 --> 00:35:42.000
So we're using it there because
we're getting a real

00:35:42.000 --> 00:35:43.710
advantage to using it.

00:35:43.710 --> 00:35:45.430
So if there is a real advantage
in terms of

00:35:45.430 --> 00:35:47.910
performance or productivity--

00:35:47.910 --> 00:35:50.820
like border radius, I'm going to
use that and just not care

00:35:50.820 --> 00:35:52.910
if it doesn't work in other
browsers, because I get a big

00:35:52.910 --> 00:35:56.200
advantage there and not
a big decrease.

00:35:56.200 --> 00:35:57.730
So it's a balance.

00:35:57.730 --> 00:36:00.000
AUDIENCE: Thank you.

00:36:00.000 --> 00:36:03.560
AUDIENCE: Regarding your
fancy CSS woes, did

00:36:03.560 --> 00:36:06.560
you file any bugs?

00:36:06.560 --> 00:36:09.690
PAMELA FOX: So did I file bugs
on the Android white-out?

00:36:09.690 --> 00:36:12.270
AUDIENCE: Was it Chrome, or was
it the Android browser?

00:36:12.270 --> 00:36:13.910
PAMELA FOX: This was
Android WebKit.

00:36:13.910 --> 00:36:15.700
So the thing is, when you're
doing PhoneGap, you have to

00:36:15.700 --> 00:36:18.790
use the embedded webview, which
means using the Android

00:36:18.790 --> 00:36:23.480
WebKit, also known as like
the worst webkit ever.

00:36:23.480 --> 00:36:26.300
So I mean, there were a lot of
issues with that webkit.

00:36:26.300 --> 00:36:30.050
I think I filed some
issues on that.

00:36:30.050 --> 00:36:32.480
But I don't know if I filed on
the white-out in particular,

00:36:32.480 --> 00:36:34.180
because it's something where
you'd have to give

00:36:34.180 --> 00:36:35.120
them the test case.

00:36:35.120 --> 00:36:38.180
And it's kind of a-- sometimes
it can be really complex to

00:36:38.180 --> 00:36:40.160
come up with the test
cases for people.

00:36:40.160 --> 00:36:42.480
And I feel bad reporting bugs
without a really nice test

00:36:42.480 --> 00:36:43.030
case for it.

00:36:43.030 --> 00:36:44.210
So I probably didn't.

00:36:44.210 --> 00:36:44.720
AUDIENCE: I gotcha.

00:36:44.720 --> 00:36:45.470
Cool.

00:36:45.470 --> 00:36:47.450
We'd like to help fix those.

00:36:47.450 --> 00:36:49.030
PAMELA FOX: Nice.

00:36:49.030 --> 00:36:50.090
OK.

00:36:50.090 --> 00:36:51.340
Anything else?

00:36:53.340 --> 00:36:54.040
All right.

00:36:54.040 --> 00:36:57.290
How many of you use
Modernizr now?

00:36:57.290 --> 00:36:57.870
Cool.

00:36:57.870 --> 00:36:59.120
Any of you guys do ua-parser?

00:37:01.640 --> 00:37:02.150
We got one.

00:37:02.150 --> 00:37:02.460
Yeah.

00:37:02.460 --> 00:37:04.931
I actually had never even
heard of it before, so--

00:37:04.931 --> 00:37:06.181
AUDIENCE: [INAUDIBLE]?

00:37:08.160 --> 00:37:09.330
PAMELA FOX: Why doesn't
Modernizr have an [INAUDIBLE]

00:37:09.330 --> 00:37:10.290
Flash?

00:37:10.290 --> 00:37:12.680
So there is a whole
issue on it.

00:37:12.680 --> 00:37:15.070
So this is what I recommend,
like when you use Modernizr,

00:37:15.070 --> 00:37:17.340
you'll find it doesn't have
checks for-- there's lots of

00:37:17.340 --> 00:37:18.850
things it doesn't
have checks for.

00:37:18.850 --> 00:37:21.240
Many of the things I check for
these days, like playback rate

00:37:21.240 --> 00:37:24.510
on the video element, Modernizr
doesn't have that.

00:37:24.510 --> 00:37:27.510
But if you look in the issue
tracker, you will often find

00:37:27.510 --> 00:37:28.860
discussions about it.

00:37:28.860 --> 00:37:32.170
So any time you use a library,
look in the issue tracker.

00:37:32.170 --> 00:37:33.790
So I always look in
the issue tracker.

00:37:33.790 --> 00:37:36.330
So you've got to look and see
what are the common issues

00:37:36.330 --> 00:37:38.320
that people are having, to see,
oh, is that something

00:37:38.320 --> 00:37:39.390
that's going to hit me too?

00:37:39.390 --> 00:37:41.630
And also look for interesting
discussions,

00:37:41.630 --> 00:37:43.050
especially with Modernizr.

00:37:43.050 --> 00:37:46.240
And I also look to see just when
people respond to issues,

00:37:46.240 --> 00:37:48.905
if they're nice or if they're
mean, because if I'm thinking

00:37:48.905 --> 00:37:51.410
about using a library and all
the responses on the issue

00:37:51.410 --> 00:37:55.100
tracker are kind of mean,
then I don't use it.

00:37:55.100 --> 00:37:57.250
So I definitely check out--

00:37:57.250 --> 00:38:00.150
when I'm thinking of using a
library, I check out their

00:38:00.150 --> 00:38:04.240
issue tracker and their code
history fairly thoroughly,

00:38:04.240 --> 00:38:07.650
because any time you use a
library, it's an investment,

00:38:07.650 --> 00:38:09.180
because you will encounter
issues with it.

00:38:09.180 --> 00:38:11.140
So they don't have
a Flash support.

00:38:11.140 --> 00:38:13.230
But they do have a long
thread about it.

00:38:13.230 --> 00:38:16.280
And I followed a few links from
there, but in the end

00:38:16.280 --> 00:38:20.190
SWFObject was the best option.

00:38:20.190 --> 00:38:21.440
It was the most accurate.

00:38:24.130 --> 00:38:24.580
Cool.

00:38:24.580 --> 00:38:27.080
All right.

00:38:27.080 --> 00:38:28.100
You're free to go.

00:38:28.100 --> 00:38:39.998
[APPLAUSE]

