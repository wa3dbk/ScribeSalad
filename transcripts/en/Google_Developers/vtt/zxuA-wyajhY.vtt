WEBVTT
Kind: captions
Language: en

00:00:04.840 --> 00:00:07.630
PETE LEPAGE: I'm going to do a
quick intro of our panelists,

00:00:07.630 --> 00:00:09.550
and then I will hand it over.

00:00:09.550 --> 00:00:10.800
Sitting right here
we have Mairead--

00:00:13.360 --> 00:00:14.240
MAIREAD BUCHAN: Buchan.

00:00:14.240 --> 00:00:15.050
PETE LEPAGE: Buchan.

00:00:15.050 --> 00:00:18.330
So I've messed her name up
probably five times already,

00:00:18.330 --> 00:00:21.380
and I've known her for
about four minutes.

00:00:21.380 --> 00:00:23.620
So I apologize.

00:00:23.620 --> 00:00:25.120
Boris Smus from Google.

00:00:25.120 --> 00:00:30.520
We've got Francois Daoust, and
then Matt Caruana, who is

00:00:30.520 --> 00:00:32.259
going to come and do
our first intro.

00:00:46.899 --> 00:00:49.060
MATT CARUANA GALIZIA: So I'm
going to start by talking

00:00:49.060 --> 00:00:51.760
about something really simple.

00:00:51.760 --> 00:00:54.430
It's just text input, which is
probably one of the most

00:00:54.430 --> 00:01:00.640
fundamental kinds of
input on the web.

00:01:00.640 --> 00:01:03.030
I just think that there are a
lot of lessons to be learned

00:01:03.030 --> 00:01:07.220
here because obviously, we've
been using this kind of input

00:01:07.220 --> 00:01:09.390
for a long time, longer than
we've had touch or

00:01:09.390 --> 00:01:10.760
anything like that.

00:01:10.760 --> 00:01:15.820
So we've gone quite far toward
standardizing it.

00:01:15.820 --> 00:01:18.900
And in the beginning, there
were really only low-level

00:01:18.900 --> 00:01:23.690
events like keydown, keypress,
keyup, that are very tied to

00:01:23.690 --> 00:01:25.090
the hardware.

00:01:25.090 --> 00:01:28.340
In a way, because of that,
they're really good.

00:01:28.340 --> 00:01:31.720
They allow us to attach special
functionality to key

00:01:31.720 --> 00:01:36.700
combinations in web apps that
should support where users

00:01:36.700 --> 00:01:38.590
need to be able to do
things quickly.

00:01:38.590 --> 00:01:44.320
The problem is that they're not
really suited to form- and

00:01:44.320 --> 00:01:45.690
text-based inputs.

00:01:45.690 --> 00:01:49.230
They're too hardware specific.

00:01:49.230 --> 00:01:52.870
For a start, they have a lot of
problems, for example, with

00:01:52.870 --> 00:01:55.630
non-Latin keyboards.

00:01:55.630 --> 00:01:58.570
Like the Chinese keyboard,
pressing the character key for

00:01:58.570 --> 00:02:02.990
man, for example, results in
a keydown event with one

00:02:02.990 --> 00:02:06.760
character, which is an accented
a and the keyup event

00:02:06.760 --> 00:02:08.380
with the actual character
itself.

00:02:08.380 --> 00:02:11.230
So it's difficult to
tell what the user

00:02:11.230 --> 00:02:14.520
actually wanted to input.

00:02:14.520 --> 00:02:17.200
Key events aren't just really
difficult to use.

00:02:17.200 --> 00:02:20.660
There are many kinds of text
input that they just aren't

00:02:20.660 --> 00:02:22.260
designed to handle.

00:02:22.260 --> 00:02:26.670
And really, it's a mistake
to assume that text input

00:02:26.670 --> 00:02:29.100
involves a keyboard.

00:02:29.100 --> 00:02:32.380
Speech dictation and drag
and drop can also be

00:02:32.380 --> 00:02:35.440
used to input text.

00:02:35.440 --> 00:02:39.210
The keyboard on Android has a
microphone button on the side,

00:02:39.210 --> 00:02:41.650
for example, which you can just
press to dictate text

00:02:41.650 --> 00:02:42.900
into an input fields.

00:02:45.720 --> 00:02:49.180
Thankfully, no one has attempted
to write a speech

00:02:49.180 --> 00:02:52.100
dictation to keypress
event polyfill.

00:02:52.100 --> 00:02:54.760
Instead, there's another event
that we can use, which is the

00:02:54.760 --> 00:02:57.210
input events.

00:02:57.210 --> 00:03:00.230
It's been recently standardized
in HTML5, and

00:03:00.230 --> 00:03:02.190
it's now supported by
all major browsers.

00:03:05.405 --> 00:03:13.570
So this makes it really easy to
detect input in a hardware

00:03:13.570 --> 00:03:15.790
agnostic way.

00:03:15.790 --> 00:03:18.870
Key events are just a bit too
low level for most kinds of

00:03:18.870 --> 00:03:19.920
text input.

00:03:19.920 --> 00:03:22.360
We don't really want to listen
for physical key presses.

00:03:22.360 --> 00:03:25.072
Really, we just want
to grab input.

00:03:25.072 --> 00:03:29.430
And the input event is a whole
different way of about

00:03:29.430 --> 00:03:30.230
thinking about this.

00:03:30.230 --> 00:03:33.050
We stop thinking in terms of
hardware and start thinking in

00:03:33.050 --> 00:03:34.490
terms of intent.

00:03:34.490 --> 00:03:38.470
We just don't really care about
the hardware at all.

00:03:38.470 --> 00:03:42.210
That really, I think, makes much
more sense than listening

00:03:42.210 --> 00:03:43.460
for key events.

00:03:45.680 --> 00:03:49.100
So why didn't we take the
lessons from text input and

00:03:49.100 --> 00:03:52.370
apply them to other forms
of input, like

00:03:52.370 --> 00:03:55.000
pointing and touching?

00:03:55.000 --> 00:03:57.100
So take the anchor
tag, for example.

00:03:57.100 --> 00:03:59.390
It can be clicked,
touched, tabbed.

00:04:03.660 --> 00:04:06.330
Do we really want to know
if the user clicked

00:04:06.330 --> 00:04:07.390
it or touched it?

00:04:07.390 --> 00:04:08.895
Most of the time we don't.

00:04:08.895 --> 00:04:11.870
We just want to know if
the user wanted to

00:04:11.870 --> 00:04:15.180
navigate to that link.

00:04:15.180 --> 00:04:18.180
There are fundamental problems
with listening only for click

00:04:18.180 --> 00:04:19.360
events on anchor tags.

00:04:19.360 --> 00:04:22.170
What if the user tabbed
to the link and then

00:04:22.170 --> 00:04:23.530
pressed the Enter key?

00:04:23.530 --> 00:04:28.240
Or what if the user issued a
voice command intending to

00:04:28.240 --> 00:04:30.190
navigate to that link?

00:04:30.190 --> 00:04:34.010
Perhaps we can just have an
activate event that we can

00:04:34.010 --> 00:04:37.760
just use to listen for
the intent itself.

00:04:37.760 --> 00:04:42.610
This can apply to command
elements, buttons, as well as

00:04:42.610 --> 00:04:44.790
anchor tags.

00:04:44.790 --> 00:04:48.470
But at the same time,
pointer events are

00:04:48.470 --> 00:04:49.640
still really useful.

00:04:49.640 --> 00:04:53.680
They're ideal in 2D drawing
applications, and developers

00:04:53.680 --> 00:04:56.950
will rely on them to define
custom gestures for their

00:04:56.950 --> 00:04:58.690
applications.

00:04:58.690 --> 00:05:02.110
So those gestures can come from
a trackpad, a touchscreen

00:05:02.110 --> 00:05:04.580
device, a Kinect, or a
Leap Motion device

00:05:04.580 --> 00:05:08.060
used in a 2D context.

00:05:08.060 --> 00:05:11.650
To ask a common question, can
touch events coexist with

00:05:11.650 --> 00:05:12.570
pointer events?

00:05:12.570 --> 00:05:12.990
Yes.

00:05:12.990 --> 00:05:13.770
Should they?

00:05:13.770 --> 00:05:15.190
Perhaps not.

00:05:15.190 --> 00:05:17.590
It's unlikely that a developer
would want to capture touch

00:05:17.590 --> 00:05:20.680
events as a subset of
pointer events.

00:05:20.680 --> 00:05:23.390
If you have access to pointer
events, it's probably best

00:05:23.390 --> 00:05:25.260
just to use those.

00:05:25.260 --> 00:05:29.390
Besides, the pointer-type
attributes of a pointer event

00:05:29.390 --> 00:05:32.640
gives you access to the input
device type, whether it's a

00:05:32.640 --> 00:05:35.560
mouse, pen, or touch.

00:05:35.560 --> 00:05:38.230
The same point on coexistence
goes for click events.

00:05:38.230 --> 00:05:39.960
Sorry, I've gone too far.

00:05:42.520 --> 00:05:46.640
In fact, developers will
eventually get to abandon

00:05:46.640 --> 00:05:49.690
click events completely, and
they'll be replaced by more

00:05:49.690 --> 00:05:53.540
semantically correct and
hardware-agnostic events in

00:05:53.540 --> 00:05:55.650
the cases that they're now most
frequently used, like

00:05:55.650 --> 00:05:59.370
anchor tags and buttons.

00:05:59.370 --> 00:06:03.200
Libraries, like pointer.js for
example, already make it

00:06:03.200 --> 00:06:07.290
possible to move away from click
events and move towards

00:06:07.290 --> 00:06:08.910
pointers, which are
more abstract.

00:06:12.620 --> 00:06:17.220
The trouble is that almost
all forms of inputs we've

00:06:17.220 --> 00:06:22.320
discussed so far involve
input in a 2D space.

00:06:22.320 --> 00:06:25.280
Take Leap Motion's JavaScript
API for example.

00:06:28.620 --> 00:06:33.180
You can receive input as
an array of hands.

00:06:33.180 --> 00:06:37.400
And they can be anything from
zero to infinity, really,

00:06:37.400 --> 00:06:38.480
because it depends--

00:06:38.480 --> 00:06:41.350
if you have multiple Leap Motion
devices, you can just

00:06:41.350 --> 00:06:45.240
have an infinite amount
of hands.

00:06:45.240 --> 00:06:52.810
And each hand has coordinates
on x, y, and z.

00:06:52.810 --> 00:06:55.440
And how do we turn these
into pointers?

00:06:55.440 --> 00:06:59.490
Pointers don't really give us
a z-axis, but it shouldn't

00:06:59.490 --> 00:07:02.320
really be that difficult to
add it to the standard.

00:07:07.270 --> 00:07:11.860
Hands from Leap Motion can fit
into the pointer event spec.

00:07:17.950 --> 00:07:20.400
But at the same time--

00:07:20.400 --> 00:07:21.640
sorry.

00:07:21.640 --> 00:07:22.890
Just a second.

00:07:34.780 --> 00:07:39.090
So another big issue is
standardizing gestures.

00:07:43.050 --> 00:07:51.960
There isn't really much going on
in this respect with specs.

00:07:51.960 --> 00:07:54.660
The closest we've come, really,
toward standardizing

00:07:54.660 --> 00:08:05.970
gestures is in the UI event
spec, which gives us a way to

00:08:05.970 --> 00:08:11.770
separate the actual method of
input or the physical action

00:08:11.770 --> 00:08:14.610
that the user made
from the intent.

00:08:14.610 --> 00:08:23.110
So, for example, we can take a
physical push action and turn

00:08:23.110 --> 00:08:29.160
it into an activate intent for
a link, which gives us a more

00:08:29.160 --> 00:08:30.690
abstract way of dealing
with input.

00:08:35.330 --> 00:08:40.590
Taking a swipe gesture, for
example, on a trackpad, in the

00:08:40.590 --> 00:08:45.690
UI event spec gives us a way to
turn this into a pan event.

00:08:45.690 --> 00:08:52.760
So it doesn't matter whether
the user provided the input

00:08:52.760 --> 00:08:57.910
using the speech API, say, as
go left command, as a verbal

00:08:57.910 --> 00:09:03.400
command, or by swiping their
hand on a touchscreen or by

00:09:03.400 --> 00:09:08.435
just moving your hand in the air
to mimic a swipe action.

00:09:08.435 --> 00:09:11.340
The spec gives us a way to
translate this into a pan

00:09:11.340 --> 00:09:13.705
event, which we can then use
to move a page around.

00:09:23.330 --> 00:09:33.430
Really in conclusion, we want
developers to produce more

00:09:33.430 --> 00:09:34.580
adaptive web apps.

00:09:34.580 --> 00:09:41.640
To do that, we need to
standardize input methods.

00:09:41.640 --> 00:09:44.870
We need browsers to
support pointers.

00:09:44.870 --> 00:09:49.870
And it would also help if
we standardize gestures.

00:09:49.870 --> 00:09:54.090
But at the same time, a probably
more future-proof way

00:09:54.090 --> 00:09:58.730
is by providing developers with
more abstract ways of

00:09:58.730 --> 00:10:04.080
dealing with the actions that
the user intends, like

00:10:04.080 --> 00:10:07.260
activate actions for links, say,
or panning actions for

00:10:07.260 --> 00:10:09.330
moving a page around.

00:10:09.330 --> 00:10:15.600
And that will just make our
life a whole lot easier.

00:10:15.600 --> 00:10:19.670
Instead of requiring every
developer to listen for all

00:10:19.670 --> 00:10:22.850
these different kinds of events,
for all different

00:10:22.850 --> 00:10:26.130
kinds of input methods, we can
just listen for one event,

00:10:26.130 --> 00:10:30.308
which is the intent,
and support that.

00:10:30.308 --> 00:10:31.805
That's it.

00:10:31.805 --> 00:10:32.803
Thanks.

00:10:32.803 --> 00:10:38.292
[APPLAUSE]

00:10:38.292 --> 00:10:40.800
PETE LEPAGE: All right.

00:10:40.800 --> 00:10:43.440
So while I'm unlocking my
computer so I can have a look

00:10:43.440 --> 00:10:44.820
at the questions,
I know the first

00:10:44.820 --> 00:10:46.090
question that's on there.

00:10:46.090 --> 00:10:49.540
And it's by far the most popular
question, is what are

00:10:49.540 --> 00:10:53.310
the new input types that really,
as developers, we need

00:10:53.310 --> 00:10:55.170
to start thinking about today?

00:10:55.170 --> 00:10:58.360
And what are the implications
of using those?

00:10:58.360 --> 00:11:01.230
So I'd like to hear from all of
you guys what you sort of

00:11:01.230 --> 00:11:04.330
think is the biggest and most
important one and what

00:11:04.330 --> 00:11:06.800
developers need to think.

00:11:06.800 --> 00:11:08.780
So, Mairead, do you
want to go ahead?

00:11:08.780 --> 00:11:12.120
MAIREAD BUCHAN: Well, in terms
of the biggest at the moment,

00:11:12.120 --> 00:11:14.990
I think in terms of something
that's not just keyboard or

00:11:14.990 --> 00:11:16.440
mouse, is touch.

00:11:16.440 --> 00:11:18.660
That the majority of your users
are going to have that.

00:11:18.660 --> 00:11:20.460
If you're talking about things
that you haven't really

00:11:20.460 --> 00:11:25.750
thought of that are coming in,
maybe motion sensing, so maybe

00:11:25.750 --> 00:11:27.670
Leap Motion because that's
coming next.

00:11:27.670 --> 00:11:31.800
It should be released at the end
of this month allegedly.

00:11:31.800 --> 00:11:35.500
But also like [INAUDIBLE] did
loads of work into how many

00:11:35.500 --> 00:11:39.740
children are actually using
games consoles, so anything

00:11:39.740 --> 00:11:43.290
that you can interact with a
games console with, and also

00:11:43.290 --> 00:11:47.370
hybrid mobiles that are games
console devices and mobiles.

00:11:47.370 --> 00:11:49.240
So they have joysticks and

00:11:49.240 --> 00:11:52.450
touchscreens and maybe keyboards.

00:11:52.450 --> 00:11:55.540
So you've got to think about
what application you're making

00:11:55.540 --> 00:11:59.120
and what that your users
are likely to be using.

00:11:59.120 --> 00:12:00.350
PETE LEPAGE: Cool.

00:12:00.350 --> 00:12:01.116
Boris?

00:12:01.116 --> 00:12:03.800
BORIS SMUS: Yeah, I would
basically agree with that.

00:12:03.800 --> 00:12:07.780
Touch is, realistically
speaking, the only interesting

00:12:07.780 --> 00:12:10.650
new mode, at least from the
perspective of what we need to

00:12:10.650 --> 00:12:12.030
do as web developers.

00:12:12.030 --> 00:12:15.510
But there's a whole slew of
emerging technology that--

00:12:15.510 --> 00:12:17.890
I don't think Leap is
at all like the

00:12:17.890 --> 00:12:20.030
extent of what's coming.

00:12:20.030 --> 00:12:22.330
There's a whole number of--
pretty much every large

00:12:22.330 --> 00:12:27.920
corporation has some finger in
this pie of camera-based or

00:12:27.920 --> 00:12:31.610
something like this input
technologies, whether it's

00:12:31.610 --> 00:12:34.090
tracking fingers,
hands, bodies,

00:12:34.090 --> 00:12:36.110
faces, irises, et cetera.

00:12:36.110 --> 00:12:38.850
So there's a whole number of
primitives in the real world

00:12:38.850 --> 00:12:40.760
that are going to start
to be tracked.

00:12:40.760 --> 00:12:43.430
And this is obviously a little
further out, but still

00:12:43.430 --> 00:12:44.732
interesting.

00:12:44.732 --> 00:12:49.210
FRANCOIS DAOUST: So just to
maybe add something more on

00:12:49.210 --> 00:12:52.700
top of the huge list you
already mentioned.

00:12:52.700 --> 00:12:56.700
Maybe at the intent level that
Pete mentioned, I would

00:12:56.700 --> 00:13:01.340
perhaps add presence or user
attention as a possible way

00:13:01.340 --> 00:13:03.910
for a more immersive
experience.

00:13:03.910 --> 00:13:06.090
For instance, if you have a
screen that is displayed on a

00:13:06.090 --> 00:13:09.890
wall, a mirror, or something,
something that is connected,

00:13:09.890 --> 00:13:13.920
you might just want to know
whether the user is in front

00:13:13.920 --> 00:13:15.450
of it or whether it's not.

00:13:15.450 --> 00:13:17.860
And the thing that you're
going to display, the

00:13:17.860 --> 00:13:20.890
interaction with the user, will
change based on that.

00:13:20.890 --> 00:13:23.790
Again, it's at the intent level,
so you don't need to

00:13:23.790 --> 00:13:29.520
know how the system knows
that the user is there.

00:13:29.520 --> 00:13:32.560
They already have some
mechanisms to do that with the

00:13:32.560 --> 00:13:36.800
RFID, with NFC, with, actually,
the user manually

00:13:36.800 --> 00:13:40.170
entering his status on Skype
or whatever saying, I'm

00:13:40.170 --> 00:13:42.860
available, I'm busy,
I'm not there.

00:13:42.860 --> 00:13:44.330
So it has [? fallback, ?]

00:13:44.330 --> 00:13:49.980
and that could be a new kind of
a user input coming in the

00:13:49.980 --> 00:13:52.436
near future.

00:13:52.436 --> 00:13:55.050
MATT CARUANA GALIZIA: I think
that one of the most

00:13:55.050 --> 00:13:59.200
interesting developments in
input is speech, because it

00:13:59.200 --> 00:14:01.830
forces us to think of input
in a whole new way.

00:14:01.830 --> 00:14:06.550
We suddenly have to deal with a
method of input that doesn't

00:14:06.550 --> 00:14:09.120
involve fingers, doesn't
involve hands, doesn't

00:14:09.120 --> 00:14:12.260
touching, moving, or
anything like that.

00:14:12.260 --> 00:14:16.480
So we just have to completely
change the way that we think

00:14:16.480 --> 00:14:19.670
about input and write
applications

00:14:19.670 --> 00:14:22.510
in different ways.

00:14:22.510 --> 00:14:26.640
The first step is to probably
change standards or develop

00:14:26.640 --> 00:14:31.000
new standards to allow
developers to more easily

00:14:31.000 --> 00:14:33.380
support this new form of inputs

00:14:33.380 --> 00:14:34.980
without relying on polyfills.

00:14:38.270 --> 00:14:43.520
I tend to think that providing
polyfills is probably a good

00:14:43.520 --> 00:14:45.380
way of getting started.

00:14:45.380 --> 00:14:49.110
We can produce the polyfill, get
developers to start using

00:14:49.110 --> 00:14:53.866
it, and then eventually the
standard will come later.

00:14:53.866 --> 00:14:57.330
PETE LEPAGE: Actually, that's
a great sort of segue to the

00:14:57.330 --> 00:15:00.420
next question that Andrew
had put in.

00:15:00.420 --> 00:15:02.960
And his question was, if
we use a mechanism for

00:15:02.960 --> 00:15:06.650
abstracting all directional
input into pointer events,

00:15:06.650 --> 00:15:10.050
will we ultimately regret
that decision?

00:15:10.050 --> 00:15:12.570
I believe there's a pointer
event polyfill library you can

00:15:12.570 --> 00:15:14.270
start playing with today.

00:15:14.270 --> 00:15:17.650
But are we regret that decision
in 6 months, 12

00:15:17.650 --> 00:15:21.301
months, maybe in 60 months?

00:15:21.301 --> 00:15:23.850
BORIS SMUS: I'll take
a stab at this.

00:15:23.850 --> 00:15:27.490
So I think that there's some
kinds of directional input

00:15:27.490 --> 00:15:30.690
that makes sense to try to
abstract as a pointer and

00:15:30.690 --> 00:15:34.010
other things it totally
does not.

00:15:34.010 --> 00:15:37.560
Things that are screen based is
an obvious fit, where you

00:15:37.560 --> 00:15:39.860
have a natural mapping to
screen coordinates.

00:15:39.860 --> 00:15:41.020
This includes mouse and touch.

00:15:41.020 --> 00:15:44.480
But when you're talking about
things like Leap or any sort

00:15:44.480 --> 00:15:47.310
of sensing in the real world, I
think you quickly fall into

00:15:47.310 --> 00:15:50.580
this weird place where
it's unclear what the

00:15:50.580 --> 00:15:52.630
client x is, really.

00:15:52.630 --> 00:15:56.290
And at that point, you're
dealing with physical units if

00:15:56.290 --> 00:15:59.720
you have some z-coordinates,
and you're just

00:15:59.720 --> 00:16:01.320
polluting the space.

00:16:01.320 --> 00:16:03.090
I feel like it's a
perilous path.

00:16:03.090 --> 00:16:06.826
So I guess the short
answer, depends.

00:16:06.826 --> 00:16:07.910
PETE LEPAGE: All right.

00:16:07.910 --> 00:16:08.395
Anybody--

00:16:08.395 --> 00:16:11.090
MAIREAD BUCHAN: Your only other
choice is coding every

00:16:11.090 --> 00:16:13.040
single aspect from scratch.

00:16:13.040 --> 00:16:16.370
And is your project going
to be profitable?

00:16:16.370 --> 00:16:18.630
Have you really got the
development time to do

00:16:18.630 --> 00:16:23.650
pointers and touch and click and
keyboard, which I reckon

00:16:23.650 --> 00:16:26.510
probably most web developers
are failing at already.

00:16:26.510 --> 00:16:29.400
Like we're not even doing
keyboard and click that well.

00:16:29.400 --> 00:16:31.880
So are you going to add another
interaction paradigm

00:16:31.880 --> 00:16:34.190
into your development
lifecycle?

00:16:34.190 --> 00:16:36.370
PETE LEPAGE: But isn't the point
of pointer events that

00:16:36.370 --> 00:16:39.690
you can sort of reduce the touch
and the mouse and all

00:16:39.690 --> 00:16:41.730
that kind of stuff to
one simple place?

00:16:41.730 --> 00:16:42.100
MAIREAD BUCHAN: Yeah.

00:16:42.100 --> 00:16:43.020
Absolutely.

00:16:43.020 --> 00:16:45.780
I think it's a great idea,
and I agree with Matt.

00:16:45.780 --> 00:16:47.400
You've got to abstract it.

00:16:47.400 --> 00:16:49.980
Otherwise, we're entering
a world of pain.

00:16:49.980 --> 00:16:50.646
You've got to.

00:16:50.646 --> 00:16:51.480
BORIS SMUS: Yeah.

00:16:51.480 --> 00:16:53.610
I think abstracting is
important, but you still need

00:16:53.610 --> 00:16:55.840
to retain the ability of
distinguishing between these

00:16:55.840 --> 00:16:58.860
different types of input.

00:16:58.860 --> 00:17:02.410
Like for example, you often do
want to have a touch-specific

00:17:02.410 --> 00:17:05.069
thing, which pointer events do
let you do because you can

00:17:05.069 --> 00:17:07.140
distinguish between [INAUDIBLE]
and touch.

00:17:07.140 --> 00:17:12.619
But that's an important thing
to carry over so that we're

00:17:12.619 --> 00:17:14.920
still able to do these sorts
of customizations.

00:17:14.920 --> 00:17:15.680
FRANCOIS DAOUST: Yeah.

00:17:15.680 --> 00:17:20.250
So just to complete, again,
there are different layers or

00:17:20.250 --> 00:17:21.369
different levels.

00:17:21.369 --> 00:17:24.329
And you want both of them--

00:17:24.329 --> 00:17:28.329
maybe there's more than two,
but you want actually the

00:17:28.329 --> 00:17:32.740
intent level for generic
interaction, and you want the

00:17:32.740 --> 00:17:35.680
more precise level, the pointer
level, being one, the

00:17:35.680 --> 00:17:40.430
touch level being a
deeper one, maybe.

00:17:40.430 --> 00:17:42.820
All of them have some use cases

00:17:42.820 --> 00:17:45.150
that need to be fulfilled.

00:17:45.150 --> 00:17:50.800
So the difficulty is teaching
the developer what to use and

00:17:50.800 --> 00:17:53.270
how not to misuse, because if
you mix the levels, you're

00:17:53.270 --> 00:17:57.090
going to end up breaking your
app pretty quickly, I suppose.

00:17:57.090 --> 00:17:57.660
PETE LEPAGE: Yeah.

00:17:57.660 --> 00:18:00.070
And I think we've all seen lots
of apps that have gotten

00:18:00.070 --> 00:18:03.320
a little bit broken with touch
and that kind of thing.

00:18:03.320 --> 00:18:03.890
Well, let's go--

00:18:03.890 --> 00:18:04.160
all right.

00:18:04.160 --> 00:18:05.460
Go ahead.

00:18:05.460 --> 00:18:07.730
BORIS SMUS: A question for
people in the audience.

00:18:07.730 --> 00:18:10.880
How many of you actually know
what pointer events are?

00:18:10.880 --> 00:18:11.415
Just curious.

00:18:11.415 --> 00:18:12.592
PETE LEPAGE: Awesome.

00:18:12.592 --> 00:18:13.620
BORIS SMUS: OK.

00:18:13.620 --> 00:18:16.780
So we actually are talking about
something that half the

00:18:16.780 --> 00:18:19.410
people don't seem to
know what it is.

00:18:19.410 --> 00:18:19.590
OK.

00:18:19.590 --> 00:18:19.800
Cool.

00:18:19.800 --> 00:18:22.590
So maybe just a quick intro
to pointer events.

00:18:22.590 --> 00:18:22.760
Basically--

00:18:22.760 --> 00:18:24.716
PETE LEPAGE: 30 seconds.

00:18:24.716 --> 00:18:27.300
BORIS SMUS: Pointer events is a
way to consolidate mouse and

00:18:27.300 --> 00:18:31.490
touch input into one type
of event system.

00:18:31.490 --> 00:18:35.610
The reason for this is touch
events and mouse events are

00:18:35.610 --> 00:18:38.260
basically two completely
separate systems.

00:18:38.260 --> 00:18:41.630
There's this weird synthetic
event concept where mouse

00:18:41.630 --> 00:18:44.390
events are generated for touch
on mobile devices.

00:18:44.390 --> 00:18:46.880
So if you don't have a
touch handler, you

00:18:46.880 --> 00:18:47.520
still get mouse events.

00:18:47.520 --> 00:18:50.400
But this leads to a whole
bunch of problems.

00:18:50.400 --> 00:18:52.450
So, anyway, now that we're
on the same page,

00:18:52.450 --> 00:18:53.580
another quick question.

00:18:53.580 --> 00:18:56.030
How many of you actually have
touch-specific handlers in

00:18:56.030 --> 00:18:57.280
your applications?

00:19:00.560 --> 00:19:00.640
OK.

00:19:00.640 --> 00:19:02.160
So maybe about half.

00:19:02.160 --> 00:19:02.630
Sounds good.

00:19:02.630 --> 00:19:02.960
Thanks.

00:19:02.960 --> 00:19:04.610
PETE LEPAGE: Cool.

00:19:04.610 --> 00:19:07.580
Mairead, I wanted to go
to your question next.

00:19:07.580 --> 00:19:10.500
Do you think that devices lying
about the event they are

00:19:10.500 --> 00:19:14.090
sending, ie, touch devices
sending fake clicks, motion

00:19:14.090 --> 00:19:18.220
sensors that likely motion
faking a touch event, is

00:19:18.220 --> 00:19:22.690
unhelpful and somewhat
reminiscent of browsers lying

00:19:22.690 --> 00:19:24.636
about their user agent?

00:19:24.636 --> 00:19:27.620
MAIREAD BUCHAN: So to kind of
clarify this, well, I was

00:19:27.620 --> 00:19:28.650
looking at the Leap Motion.

00:19:28.650 --> 00:19:31.760
And what it does is
it projects a 2D

00:19:31.760 --> 00:19:33.140
plane in front of you.

00:19:33.140 --> 00:19:36.030
And when you touch that
plane, it sends

00:19:36.030 --> 00:19:37.530
that as a touch event.

00:19:37.530 --> 00:19:40.960
So anything you've built to be
touch related, Leap Motion can

00:19:40.960 --> 00:19:45.930
do in 3D by pretending
it has a 2D surface.

00:19:45.930 --> 00:19:48.760
If you look at how a touchscreen
pretends that it's

00:19:48.760 --> 00:19:51.930
had a click, and that doesn't
really work, is the Leap

00:19:51.930 --> 00:19:55.110
Motion touch really going
to be the same as

00:19:55.110 --> 00:19:56.270
you touching a surface?

00:19:56.270 --> 00:19:58.900
It's not, is it?

00:19:58.900 --> 00:20:01.810
So the more we end up
down this dark path.

00:20:01.810 --> 00:20:04.760
And also, if you're doing
feature detection, are you a

00:20:04.760 --> 00:20:05.410
touch device?

00:20:05.410 --> 00:20:06.060
Yes, I am.

00:20:06.060 --> 00:20:07.040
No, it's not.

00:20:07.040 --> 00:20:09.660
It's something else lying that
it's a touch device.

00:20:09.660 --> 00:20:13.530
So that's dangerous ground, I
think, because, what, are you

00:20:13.530 --> 00:20:16.350
going to go back to user agent
sniffing because your feature

00:20:16.350 --> 00:20:18.360
detection is not working?

00:20:18.360 --> 00:20:21.958
I don't know what's the
answer to that.

00:20:21.958 --> 00:20:23.920
MATT CARUANA GALIZIA: One of
the problems that we have

00:20:23.920 --> 00:20:27.930
right now, in fact, is devices
that support multiple input

00:20:27.930 --> 00:20:31.610
types, like laptops with screens
which you can touch,

00:20:31.610 --> 00:20:34.085
for example, but which also
have a mouse connected.

00:20:38.360 --> 00:20:42.950
In the FD web app, we use a
library called FT Scroller.

00:20:42.950 --> 00:20:48.150
But the issue that we have with
scrolling right now is

00:20:48.150 --> 00:20:52.700
that we feature detect first
if the browser supports

00:20:52.700 --> 00:20:55.870
pointers, then if it supports
touches, and then obviously

00:20:55.870 --> 00:20:58.750
will fall back to
mouse events.

00:20:58.750 --> 00:21:05.506
The problem with that is that
we sacrifice usability.

00:21:08.560 --> 00:21:12.070
After we successfully feature
detect touch events, it means

00:21:12.070 --> 00:21:16.100
that user won't be able to use
the mouse, for example, to

00:21:16.100 --> 00:21:17.350
scroll a layer.

00:21:19.610 --> 00:21:23.140
We should really be able to just
use pointer events, and

00:21:23.140 --> 00:21:26.100
it should work for all the
different inputs, for the

00:21:26.100 --> 00:21:29.474
mouse or for the touchscreen
itself.

00:21:29.474 --> 00:21:30.400
BORIS SMUS: Yeah.

00:21:30.400 --> 00:21:35.370
So on that point, I think for
the case of a touch laptop,

00:21:35.370 --> 00:21:40.050
it's important not to
just ignore mouse.

00:21:40.050 --> 00:21:43.180
Maybe the best practice is to
prevent default on such events

00:21:43.180 --> 00:21:47.340
as opposed to not listening to
mouse events at all, since you

00:21:47.340 --> 00:21:50.655
can no longer assume that
touch implies not mouse.

00:21:55.250 --> 00:21:59.430
And on the question of reducing
different kinds of

00:21:59.430 --> 00:22:03.940
input to different other kinds
of input, I agree with you.

00:22:03.940 --> 00:22:05.310
It's a dangerous path.

00:22:05.310 --> 00:22:10.240
Just like reducing touch to
mouse didn't work, reducing a

00:22:10.240 --> 00:22:12.760
Leap, which actually tracks--

00:22:12.760 --> 00:22:14.900
it's a sausage tracker,
essentially, tracks sausages

00:22:14.900 --> 00:22:16.090
in the air--

00:22:16.090 --> 00:22:20.830
reducing that into a touchscreen
also doesn't work.

00:22:20.830 --> 00:22:25.310
And it's an insult to what
Leap can do, just like

00:22:25.310 --> 00:22:28.800
reducing a touchscreen to a
mouse basically eliminates any

00:22:28.800 --> 00:22:31.380
possibility of multitouch.

00:22:31.380 --> 00:22:36.470
We have completely unexplored
territory in the 3D tracking

00:22:36.470 --> 00:22:41.102
space that we would just
lose entirely.

00:22:41.102 --> 00:22:44.420
PETE LEPAGE: I want to dive a
little bit deeper into the

00:22:44.420 --> 00:22:48.810
interactions when using both
touch and mouse because,

00:22:48.810 --> 00:22:53.670
Boris, you showed me a couple
of demos yesterday where

00:22:53.670 --> 00:22:56.110
having an object on screen, you
can put your finger on it,

00:22:56.110 --> 00:22:59.370
and then use the touchpad or
your mouse to make it move.

00:22:59.370 --> 00:23:01.680
I think there are a lot
of really interesting

00:23:01.680 --> 00:23:03.530
opportunities there that
haven't been explored.

00:23:03.530 --> 00:23:05.960
Let's talk about some of
those different ones

00:23:05.960 --> 00:23:07.210
for a minute or so.

00:23:09.770 --> 00:23:10.570
BORIS SMUS: OK.

00:23:10.570 --> 00:23:14.180
So I guess there's a
couple things that

00:23:14.180 --> 00:23:15.900
are interesting here.

00:23:15.900 --> 00:23:18.910
So the first one is just the
transition between the two

00:23:18.910 --> 00:23:24.200
modes, in like a Windows 8
touch laptop, seems like

00:23:24.200 --> 00:23:26.930
there's some opportunity
to have some--

00:23:26.930 --> 00:23:30.590
almost like a responsive
input-type approach, where

00:23:30.590 --> 00:23:32.300
instead of adapting to
screen size, you're

00:23:32.300 --> 00:23:35.730
adapting to input method.

00:23:35.730 --> 00:23:37.340
Just kind of throwing
this idea out there.

00:23:37.340 --> 00:23:41.110
I haven't seen anyone do it
well, but it's interesting.

00:23:41.110 --> 00:23:44.770
The other angle is multiple
inputs simultaneously.

00:23:44.770 --> 00:23:49.570
So like what Pete was
describing, with a trackpad

00:23:49.570 --> 00:23:52.790
and a simultaneous touchscreen
interaction.

00:23:52.790 --> 00:23:56.620
Again, I've built some
prototypes around this stuff,

00:23:56.620 --> 00:23:58.910
but it's pretty early.

00:23:58.910 --> 00:24:02.210
And I think it'd be cool to see
more of them from other

00:24:02.210 --> 00:24:06.200
people and have a discussion
about them, but it's a little

00:24:06.200 --> 00:24:07.930
too early, I think,
to really go into.

00:24:07.930 --> 00:24:08.820
PETE LEPAGE: All right.

00:24:08.820 --> 00:24:10.270
Fair answer.

00:24:10.270 --> 00:24:15.100
Anybody else have any
thoughts on that?

00:24:15.100 --> 00:24:18.030
All right.

00:24:18.030 --> 00:24:21.310
So the next question we have,
tapping links on a page incurs

00:24:21.310 --> 00:24:25.890
a 300 millisecond delay to work
out if the user is doing

00:24:25.890 --> 00:24:28.360
a double tap to zoom.

00:24:28.360 --> 00:24:30.090
Can we get rid of this
delay somehow

00:24:30.090 --> 00:24:31.440
without losing the zoom?

00:24:36.520 --> 00:24:38.750
MATT CARUANA GALIZIA: In
maintaining FastClick, which

00:24:38.750 --> 00:24:45.170
is a polyfill that we developed
at the FT to get rid

00:24:45.170 --> 00:24:49.380
of the delay, we've dealt
with a lot of issues.

00:24:49.380 --> 00:24:50.010
[? You will ?]

00:24:50.010 --> 00:24:53.010
constantly bring up the issue
that we've effectively

00:24:53.010 --> 00:24:58.740
disabled zooming by firing a
click event as soon as the

00:24:58.740 --> 00:25:01.645
finger leaves the screen,
as soon as the touch

00:25:01.645 --> 00:25:02.895
end event is fired.

00:25:06.190 --> 00:25:10.250
The issue seems to be that
really, we can't have the best

00:25:10.250 --> 00:25:15.370
of both worlds at the moment
without an API that we can use

00:25:15.370 --> 00:25:19.880
to zoom the page when we
detect a second tap.

00:25:19.880 --> 00:25:23.550
But even in that case, really,
because once the finger has

00:25:23.550 --> 00:25:27.890
left the screen, then you've
already fired the click event.

00:25:27.890 --> 00:25:32.740
So we haven't figured out a
way yet to get the both of

00:25:32.740 --> 00:25:34.580
both worlds.

00:25:34.580 --> 00:25:38.080
FRANCOIS DAOUST: I guess,
unfortunately, the double tap

00:25:38.080 --> 00:25:41.320
thing is really at the operating
system level.

00:25:41.320 --> 00:25:44.480
It's something that
the device brings.

00:25:44.480 --> 00:25:52.300
And you cannot just prevent it
from happening within a web

00:25:52.300 --> 00:25:57.770
app, within a web browser,
within this device, without--

00:25:57.770 --> 00:26:01.960
we can't even imagine, I guess,
an API that would allow

00:26:01.960 --> 00:26:06.150
the web app to prevent the
double tap, because it's a

00:26:06.150 --> 00:26:07.220
usability feature.

00:26:07.220 --> 00:26:11.105
It has also accessibility
implications.

00:26:14.550 --> 00:26:18.210
I guess the answer for me is,
no, you cannot right now.

00:26:18.210 --> 00:26:22.010
New devices will probably
improve the touch interaction

00:26:22.010 --> 00:26:24.926
and maybe remove
the double tap.

00:26:24.926 --> 00:26:25.710
I don't know.

00:26:25.710 --> 00:26:28.540
MATT CARUANA GALIZIA: Do you
that if we're building

00:26:28.540 --> 00:26:32.250
responsive layouts, then the
users shouldn't really have to

00:26:32.250 --> 00:26:33.395
zoom in the first place?

00:26:33.395 --> 00:26:36.656
FRANCOIS DAOUST: Well, no,
but I know that the--

00:26:36.656 --> 00:26:41.070
I believe that they should be
able to zoom in, but I know

00:26:41.070 --> 00:26:45.850
that it can trigger a lot
analyst discussions on who's

00:26:45.850 --> 00:26:47.570
right and who's wrong.

00:26:47.570 --> 00:26:49.080
So I'm more--

00:26:49.080 --> 00:26:50.870
it's the same thing with
the meta viewport

00:26:50.870 --> 00:26:53.930
when you disable scaling.

00:26:53.930 --> 00:26:56.360
It's the same discussion
somehow.

00:26:56.360 --> 00:27:00.550
And in my view, it's supposed
to be the user choosing

00:27:00.550 --> 00:27:02.080
whether he wants to
zoom in o or.

00:27:02.080 --> 00:27:04.060
He may have good reasons
to do that.

00:27:04.060 --> 00:27:10.300
But on mobile devices or tablet
devices, it's hard to

00:27:10.300 --> 00:27:15.720
find another interaction that
could be used to zoom in.

00:27:15.720 --> 00:27:18.030
So you're kind of stuck.

00:27:18.030 --> 00:27:21.630
So when you develop web apps for
customers, for instance,

00:27:21.630 --> 00:27:25.320
you will have to make
some workarounds.

00:27:25.320 --> 00:27:28.980
And you will disable zoom in,
even if you don't want to,

00:27:28.980 --> 00:27:30.810
just because otherwise,
the web app is

00:27:30.810 --> 00:27:32.726
not responsive enough.

00:27:32.726 --> 00:27:35.580
BORIS SMUS: So we've had lots
of discussions about this

00:27:35.580 --> 00:27:36.720
particular thing.

00:27:36.720 --> 00:27:40.150
And I think this is an
optimization that's either in

00:27:40.150 --> 00:27:43.060
the Chrome beta for Android
or coming soon.

00:27:43.060 --> 00:27:46.680
Basically, if you have a
non-user-scalable page,

00:27:46.680 --> 00:27:50.670
there's no reason to have this
click delay, so we just

00:27:50.670 --> 00:27:53.560
disable it.

00:27:53.560 --> 00:27:56.960
Basically, I think this is the
way that things should be, and

00:27:56.960 --> 00:28:01.200
FastClick is a giant hack that
should never have existed.

00:28:01.200 --> 00:28:03.400
I'm not saying it's
like a bad thing.

00:28:03.400 --> 00:28:04.390
Clearly, there was a--

00:28:04.390 --> 00:28:05.250
MATT CARUANA GALIZIA:
I agree completely.

00:28:05.250 --> 00:28:06.980
BORIS SMUS: There was a
need for it when there

00:28:06.980 --> 00:28:07.610
was a need for it.

00:28:07.610 --> 00:28:10.450
But it's time to get past that
and fix our browsers.

00:28:10.450 --> 00:28:11.700
MATT CARUANA GALIZIA: I agree.

00:28:14.855 --> 00:28:17.410
MAIREAD BUCHAN: I don't know.

00:28:17.410 --> 00:28:18.790
Why would you loading a page?

00:28:18.790 --> 00:28:23.340
Or can you guarantee that when
a pages is loaded that it's

00:28:23.340 --> 00:28:25.320
going to be zoom disabled?

00:28:25.320 --> 00:28:25.920
Do you see what I mean?

00:28:25.920 --> 00:28:28.880
Like even if you've made a
responsive mobile site, a user

00:28:28.880 --> 00:28:32.950
still might want to zoom
in on something.

00:28:32.950 --> 00:28:37.230
Can you ever really make
a web page that's--

00:28:37.230 --> 00:28:40.500
BORIS SMUS: I would argue that
yes, because if you look at

00:28:40.500 --> 00:28:42.430
native apps, basically--

00:28:42.430 --> 00:28:45.570
if we look at the extreme of
adapting content to your

00:28:45.570 --> 00:28:51.540
device, then in the ideal case,
we should be doing this.

00:28:51.540 --> 00:28:52.240
I don't think it's

00:28:52.240 --> 00:28:54.760
unreasonable for special cases.

00:28:54.760 --> 00:28:57.980
I'm not saying disable pinch
zooming in general or double

00:28:57.980 --> 00:29:00.280
tap to zoom, but I
think there are

00:29:00.280 --> 00:29:01.980
cases where it's justified.

00:29:01.980 --> 00:29:04.650
MATT CARUANA GALIZIA: If we
have a pinch event, then

00:29:04.650 --> 00:29:07.930
really, we could just listen for
that and zoom when we get

00:29:07.930 --> 00:29:11.170
that event, rather than
using double tap or

00:29:11.170 --> 00:29:12.810
anything like that.

00:29:12.810 --> 00:29:18.720
And pinch makes sense because
you can theoretically pinch

00:29:18.720 --> 00:29:22.520
with your hands if you're using
a Leap Motion device.

00:29:22.520 --> 00:29:24.780
So it makes sense as an
abstract gesture.

00:29:27.672 --> 00:29:29.080
PETE LEPAGE: Cool.

00:29:29.080 --> 00:29:32.550
So as you guys were talking
about that, I wrote down one

00:29:32.550 --> 00:29:35.310
off-the-cuff idea is, why can't
we just put an attribute

00:29:35.310 --> 00:29:38.480
on elements and say, this
element, if the user double

00:29:38.480 --> 00:29:44.010
taps on it, anything in here,
we don't get a zoom.

00:29:44.010 --> 00:29:45.730
And then you can just say,
all right, great.

00:29:45.730 --> 00:29:48.340
Everything in here, if the user
touches on it, that's an

00:29:48.340 --> 00:29:51.320
immediate click.

00:29:51.320 --> 00:29:52.340
BORIS SMUS: Great idea.

00:29:52.340 --> 00:29:56.690
Microsoft implemented it in
IE 10, or maybe IE 9.

00:29:56.690 --> 00:30:00.580
There's a CSS property called
ms-touch-action, I think, and

00:30:00.580 --> 00:30:04.640
you can configure exactly what
happens when you touch this

00:30:04.640 --> 00:30:07.570
particular element
to the extent of

00:30:07.570 --> 00:30:09.490
disabling particular gestures.

00:30:09.490 --> 00:30:13.700
So you can say no scrolling
on this thing, or no pinch

00:30:13.700 --> 00:30:14.720
zooming on it.

00:30:14.720 --> 00:30:17.230
And I think it would be great
to standardize this sort of

00:30:17.230 --> 00:30:21.570
thing, just because declarative
things are kind of

00:30:21.570 --> 00:30:24.040
better from many perspectives.

00:30:24.040 --> 00:30:28.608
So, yeah, that's
my perspective.

00:30:28.608 --> 00:30:31.560
PETE LEPAGE: Do you know
where it is in the

00:30:31.560 --> 00:30:32.730
standardization process?

00:30:32.730 --> 00:30:33.610
Or is it even there?

00:30:33.610 --> 00:30:35.750
BORIS SMUS: As far as I know,
it's not anywhere.

00:30:35.750 --> 00:30:36.530
PETE LEPAGE: OK.

00:30:36.530 --> 00:30:36.845
All right.

00:30:36.845 --> 00:30:37.920
BORIS SMUS: But I
could be wrong.

00:30:37.920 --> 00:30:39.170
Rick?

00:30:44.682 --> 00:30:46.255
RICK BYERS: I'm Rick Byers.

00:30:46.255 --> 00:30:50.030
I'm the Google person on the
Pointer Events Working Group.

00:30:50.030 --> 00:30:54.820
And so the question was the
ability to disable double tap

00:30:54.820 --> 00:30:56.210
to zoom with touch
action, right?

00:30:56.210 --> 00:30:59.190
So touch action, as we
standardize it right now, has

00:30:59.190 --> 00:31:03.120
pan, none, and auto-- pan-x,
pan-y, none, and auto.

00:31:03.120 --> 00:31:06.550
And double tap isn't in there,
in particular because to talk

00:31:06.550 --> 00:31:08.820
about zooming individual
elements only makes sense in

00:31:08.820 --> 00:31:11.420
IE's concept of content zoomable
where you can have an

00:31:11.420 --> 00:31:13.800
element that's independently
zoomable from

00:31:13.800 --> 00:31:15.140
the rest of the page.

00:31:15.140 --> 00:31:17.440
And so we debated adding some
notion of zoom-to-touch

00:31:17.440 --> 00:31:19.170
action, but without a notion
of content zoomable, it

00:31:19.170 --> 00:31:20.060
doesn't make any sense.

00:31:20.060 --> 00:31:22.570
All that really makes sense
is the page itself

00:31:22.570 --> 00:31:24.940
being zoomable or not.

00:31:24.940 --> 00:31:27.970
So far, in Chrome desktop, for
example, we don't have any

00:31:27.970 --> 00:31:29.240
zooming at all.

00:31:29.240 --> 00:31:31.100
We're not going to add double
tap, because there's no way in

00:31:31.100 --> 00:31:32.710
hell we want to add that
300 millisecond

00:31:32.710 --> 00:31:33.750
delay in Chrome desktop.

00:31:33.750 --> 00:31:35.610
And in Android, it's
the viewport tag to

00:31:35.610 --> 00:31:37.130
disable double tap.

00:31:37.130 --> 00:31:37.790
That's where we are right now.

00:31:37.790 --> 00:31:39.450
But I think we'll--

00:31:39.450 --> 00:31:43.160
we've got to figure out how
can we not delay the click

00:31:43.160 --> 00:31:45.150
while still permitting some--

00:31:45.150 --> 00:31:47.990
certainly pinch, we should still
permit without disabling

00:31:47.990 --> 00:31:48.380
double tap.

00:31:48.380 --> 00:31:50.630
So I think maybe adding
something to touch action is

00:31:50.630 --> 00:31:52.050
appropriate or some
other mechanism.

00:31:58.511 --> 00:31:59.320
PETE LEPAGE: Anybody?

00:31:59.320 --> 00:32:01.160
MAIREAD BUCHAN: I kind of feel
like, why don't we just ditch

00:32:01.160 --> 00:32:02.170
double tap?

00:32:02.170 --> 00:32:04.570
Like, is it really that
much of a win?

00:32:04.570 --> 00:32:07.890
If you can pitch to zoom, do
you need two ways to zoom?

00:32:07.890 --> 00:32:10.586
Not really.

00:32:10.586 --> 00:32:13.670
Let's just filter that
out, fix that.

00:32:18.198 --> 00:32:20.440
PETE LEPAGE: All right.

00:32:20.440 --> 00:32:22.640
Anybody have anything else they
want to add on that one?

00:32:22.640 --> 00:32:23.636
MATT CARUANA GALIZIA:
Just that I agree.

00:32:23.636 --> 00:32:26.130
PETE LEPAGE: All right.

00:32:26.130 --> 00:32:26.870
What do you guys think?

00:32:26.870 --> 00:32:30.490
Should just everybody take
away double tap to zoom?

00:32:30.490 --> 00:32:31.418
AUDIENCE: No.

00:32:31.418 --> 00:32:32.346
PETE LEPAGE: No.

00:32:32.346 --> 00:32:32.810
All right.

00:32:32.810 --> 00:32:34.000
Well, there we go.

00:32:34.000 --> 00:32:37.560
So it seems that the panelists
disagree with you.

00:32:37.560 --> 00:32:40.336
Jake?

00:32:40.336 --> 00:32:41.586
Can we get a mic?

00:32:45.350 --> 00:32:48.180
AUDIENCE: So it's quite often
if I load a page on my phone

00:32:48.180 --> 00:32:53.500
that's not optimized for the
screen size-- it doesn't have

00:32:53.500 --> 00:32:54.440
a viewport metatag--

00:32:54.440 --> 00:32:56.950
I'll quite often do the double
tap thing, right, to bring the

00:32:56.950 --> 00:33:00.350
paragraph to full width
so I can read it.

00:33:00.350 --> 00:33:02.730
But there's probably some way
that we can do around that.

00:33:02.730 --> 00:33:08.680
If it does have a viewport tag,
but it isn't fixed zoom,

00:33:08.680 --> 00:33:10.360
when the user starts the
interaction we know that

00:33:10.360 --> 00:33:13.190
double tap's going to have no
effect because the paragraph

00:33:13.190 --> 00:33:14.230
is already full width.

00:33:14.230 --> 00:33:17.200
And then we could take
the shortcut there.

00:33:17.200 --> 00:33:19.200
We would assume that
one tap is click.

00:33:19.200 --> 00:33:20.600
We don't wait 300 milliseconds,
because double

00:33:20.600 --> 00:33:22.985
tap is probably not what
they're going to do.

00:33:25.615 --> 00:33:30.910
AUDIENCE: And there are also
some touch devices that it

00:33:30.910 --> 00:33:33.250
doesn't implement multitouch.

00:33:33.250 --> 00:33:38.592
So with the single input, the
double tap solves the problem.

00:33:38.592 --> 00:33:39.710
FRANCOIS DAOUST: That's
one point I

00:33:39.710 --> 00:33:41.440
wanted to raise as well.

00:33:41.440 --> 00:33:44.500
When we talk about input, we
are actually entering a

00:33:44.500 --> 00:33:47.480
wonderful world of patents
and that kind of stuff.

00:33:47.480 --> 00:33:51.410
And it makes it hard, actually,
to be able to do

00:33:51.410 --> 00:33:53.530
whatever you want.

00:33:53.530 --> 00:33:57.390
And so indeed, the pinch
couldn't be done in previous

00:33:57.390 --> 00:34:02.010
version, at least of other
mobile devices, because of

00:34:02.010 --> 00:34:03.470
obvious patents--

00:34:03.470 --> 00:34:06.920
or maybe not obvious, actually--
but anyway, because

00:34:06.920 --> 00:34:07.490
of patents.

00:34:07.490 --> 00:34:10.639
So there's always this side of
the story that we don't like

00:34:10.639 --> 00:34:13.360
to talk about and that we don't
like as developers but

00:34:13.360 --> 00:34:15.749
that still exists
in this world.

00:34:15.749 --> 00:34:16.439
BORIS SMUS: Right.

00:34:16.439 --> 00:34:17.830
But I think that's--

00:34:17.830 --> 00:34:18.650
hello.

00:34:18.650 --> 00:34:19.080
Test.

00:34:19.080 --> 00:34:19.510
Test.

00:34:19.510 --> 00:34:20.370
FRANCOIS DAOUST: [INAUDIBLE].

00:34:20.370 --> 00:34:21.830
BORIS SMUS: Sure.

00:34:21.830 --> 00:34:24.780
That said, I think as
developers, there's nothing

00:34:24.780 --> 00:34:26.550
that prevents us from
implementing.

00:34:26.550 --> 00:34:27.810
[LAUGHTER]

00:34:27.810 --> 00:34:31.600
PETE LEPAGE: So obviously,
the audio gods don't

00:34:31.600 --> 00:34:32.760
want Boris to speak.

00:34:32.760 --> 00:34:32.940
There we go.

00:34:32.940 --> 00:34:33.636
All right.

00:34:33.636 --> 00:34:34.570
Let's try this again.

00:34:34.570 --> 00:34:39.280
BORIS SMUS: So I think the
patents don't affect insomuch

00:34:39.280 --> 00:34:41.460
as web developers as
we can implement

00:34:41.460 --> 00:34:42.750
our own gesture handlers.

00:34:42.750 --> 00:34:45.080
They're just not going to
be available natively in

00:34:45.080 --> 00:34:48.180
platforms for any foreseeable
future.

00:34:48.180 --> 00:34:51.340
But we can still make our own
gesture libraries, and there's

00:34:51.340 --> 00:34:52.620
many of them out there.

00:34:52.620 --> 00:34:56.100
So that shouldn't
be stopping any

00:34:56.100 --> 00:34:57.350
development in this direction.

00:35:00.502 --> 00:35:03.390
FRANCOIS DAOUST: What it stops
usually is standardization.

00:35:03.390 --> 00:35:07.310
It's where things stop.

00:35:07.310 --> 00:35:12.650
And gestures have been stopped
for that precise reason, at

00:35:12.650 --> 00:35:15.012
W3C, at least.

00:35:15.012 --> 00:35:18.750
There are other examples.

00:35:18.750 --> 00:35:19.320
PETE LEPAGE: All right.

00:35:19.320 --> 00:35:20.950
Anything else?

00:35:20.950 --> 00:35:21.600
All right.

00:35:21.600 --> 00:35:23.190
Let's pop down to the
next question.

00:35:23.190 --> 00:35:25.460
This is one that I added because
I think it's a really

00:35:25.460 --> 00:35:30.340
important question that
gets addressed.

00:35:30.340 --> 00:35:35.170
As web developers, how can we
test our sites if we don't own

00:35:35.170 --> 00:35:38.160
a touch PC or a touch
laptop, right?

00:35:38.160 --> 00:35:40.350
How can we be testing our sites
to see how they're going

00:35:40.350 --> 00:35:42.110
to interact on some
of these things?

00:35:42.110 --> 00:35:45.210
Obviously, going down to the
local computer store and

00:35:45.210 --> 00:35:49.350
testing your web app on there
and then going home isn't

00:35:49.350 --> 00:35:50.600
going to work.

00:35:52.618 --> 00:35:56.240
MAIREAD BUCHAN: Well, in my
experience, the only way to

00:35:56.240 --> 00:36:00.530
develop, to test on a device
is to have in your hand.

00:36:00.530 --> 00:36:03.180
And if you really can't afford
to that, then I think you need

00:36:03.180 --> 00:36:06.840
to get testing labs or these
kind of browser shop places

00:36:06.840 --> 00:36:08.200
where you've got someone
else doing it

00:36:08.200 --> 00:36:09.100
with an actual device.

00:36:09.100 --> 00:36:13.960
I haven't found any emulator or
simulator that was really

00:36:13.960 --> 00:36:14.510
that useful.

00:36:14.510 --> 00:36:17.680
And even if you're looking at
something on a screen, and

00:36:17.680 --> 00:36:20.760
you've got an iPad-shaped thing,
like our designers were

00:36:20.760 --> 00:36:21.520
designing things.

00:36:21.520 --> 00:36:24.420
And then when the QA actually
had an iPad in his hand, his

00:36:24.420 --> 00:36:27.580
thumb, the way he was holding
the device, actually obscured

00:36:27.580 --> 00:36:30.800
part of the design, which you
can't mimic unless you're

00:36:30.800 --> 00:36:33.540
really holding an
actual thing.

00:36:33.540 --> 00:36:35.840
I think if you can't afford
every device, and if you're a

00:36:35.840 --> 00:36:38.740
sole trader, there's no
way you could do that.

00:36:38.740 --> 00:36:42.300
You're going to have to
put an extra line

00:36:42.300 --> 00:36:45.475
item in your budget.

00:36:45.475 --> 00:36:46.710
FRANCOIS DAOUST: Yeah.

00:36:46.710 --> 00:36:51.250
Well, I'm afraid there's not
many other solutions.

00:36:51.250 --> 00:36:54.410
We do a lot of development on
connected TVs, for instance.

00:36:54.410 --> 00:36:59.590
And you try the emulators.

00:36:59.590 --> 00:37:04.420
They just don't work as the
actual TV, so you really have

00:37:04.420 --> 00:37:08.290
no other choice than to have the
set-top box, the TV, the

00:37:08.290 --> 00:37:10.330
whatever in your room
and try it.

00:37:10.330 --> 00:37:15.120
You can just delay the time at
which you start to try to test

00:37:15.120 --> 00:37:20.630
the app on a natural device,
but it has to be done,

00:37:20.630 --> 00:37:23.192
unfortunately.

00:37:23.192 --> 00:37:25.540
MATT CARUANA GALIZIA: At the FT
we use a testing framework

00:37:25.540 --> 00:37:31.710
called eggPlant to test using
the iOS simulator, and it

00:37:31.710 --> 00:37:32.790
seems to work quite well.

00:37:32.790 --> 00:37:38.080
It's just very difficult to get
using, because you have to

00:37:38.080 --> 00:37:40.705
learn their scripting language,
script the device.

00:37:40.705 --> 00:37:41.955
It's very labor intensive.

00:37:44.690 --> 00:37:47.570
BORIS SMUS: I think it's worth
mentioning that the simplest

00:37:47.570 --> 00:37:51.820
thing you can do, if you're
especially a content-oriented

00:37:51.820 --> 00:37:55.800
site, is you can enable
touch events in the

00:37:55.800 --> 00:37:57.340
Chrome Developer Tools.

00:37:57.340 --> 00:37:59.770
So it's just a tick box
in the settings.

00:37:59.770 --> 00:38:03.690
And if your site doesn't work
with that enabled-- basically,

00:38:03.690 --> 00:38:06.550
what it does is it creates a
touch-equivalent event for

00:38:06.550 --> 00:38:07.710
each mouse event.

00:38:07.710 --> 00:38:11.090
And if your site doesn't work
there, then it's not

00:38:11.090 --> 00:38:12.180
guaranteed--

00:38:12.180 --> 00:38:14.180
or basically, if it doesn't work
there, it's guaranteed

00:38:14.180 --> 00:38:17.350
not to work on a
mobile device.

00:38:17.350 --> 00:38:22.020
So you don't have the opposite
guarantee, but

00:38:22.020 --> 00:38:24.340
it's at least something.

00:38:24.340 --> 00:38:26.810
The other thing is I would--

00:38:26.810 --> 00:38:30.960
pardon my shameless plug, but
basically, there's a GitHub

00:38:30.960 --> 00:38:37.440
repo that lets you take your
multitouch trackpad on your

00:38:37.440 --> 00:38:42.690
Mac device and just essentially
pass those events

00:38:42.690 --> 00:38:46.410
into the browser, synthesizing
multitouch events.

00:38:46.410 --> 00:38:49.460
If you want to check it out,
it's called MagicTouch, and

00:38:49.460 --> 00:38:51.302
it'll work on your Mac.

00:38:51.302 --> 00:38:52.552
End of plug.

00:38:56.102 --> 00:38:58.174
BORIS SMUS: Rick.

00:38:58.174 --> 00:38:59.630
PETE LEPAGE: Mic coming
up behind you.

00:38:59.630 --> 00:39:01.862
MATT CARUANA GALIZIA:
Behind you.

00:39:01.862 --> 00:39:04.820
RICK BYERS: There's just one
more really important piece I

00:39:04.820 --> 00:39:06.910
think I just wanted to mention,
that for this common

00:39:06.910 --> 00:39:12.110
case that Matt was discussing
about a site that when you run

00:39:12.110 --> 00:39:14.230
it on a computer with
touch and mouse,

00:39:14.230 --> 00:39:15.630
the mouse stops working.

00:39:15.630 --> 00:39:19.180
That's the case we see all
the time in Chrome on

00:39:19.180 --> 00:39:20.290
touch-enabled laptops.

00:39:20.290 --> 00:39:21.650
That's actually really
easy to test.

00:39:21.650 --> 00:39:24.970
You can run Chrome with the
flag, dash, dash, touch

00:39:24.970 --> 00:39:25.790
events, colon, enable.

00:39:25.790 --> 00:39:27.910
From about:flags, you
can turn that on.

00:39:27.910 --> 00:39:30.090
We really would like to
have Chrome always

00:39:30.090 --> 00:39:31.090
support touch events.

00:39:31.090 --> 00:39:33.150
The problem is, people conflate
the idea "does the

00:39:33.150 --> 00:39:35.490
browser support touch events"
with "is there a touchscreen

00:39:35.490 --> 00:39:36.090
attached?"

00:39:36.090 --> 00:39:38.150
And in theory, we want the
browser to always support

00:39:38.150 --> 00:39:39.640
touch events, because you
could plug in a USB

00:39:39.640 --> 00:39:40.960
touchscreen any time.

00:39:40.960 --> 00:39:43.140
And we can't just suddenly start
have [? window down ?]

00:39:43.140 --> 00:39:44.440
on touch.

00:39:44.440 --> 00:39:46.940
We can't change whether or not
the browser supports touch

00:39:46.940 --> 00:39:49.790
events during the lifetime
of a renderer process.

00:39:49.790 --> 00:39:51.670
We can only do it on startup.

00:39:51.670 --> 00:39:53.860
It would confuse the page,
even if we could do.

00:39:53.860 --> 00:39:56.120
So we'd love to be able
to just say-- in

00:39:56.120 --> 00:39:56.890
fact, we've done it.

00:39:56.890 --> 00:39:58.970
I think for Chrome 22
for a while, we

00:39:58.970 --> 00:39:59.720
supported touch events.

00:39:59.720 --> 00:40:01.790
Everyone complained that
sites were broken.

00:40:01.790 --> 00:40:03.360
I'm like, yeah, it's because
they assume that supporting

00:40:03.360 --> 00:40:05.200
touch events means that there's
touchscreen attached

00:40:05.200 --> 00:40:06.110
when it doesn't.

00:40:06.110 --> 00:40:07.290
So please, turn that flag on.

00:40:07.290 --> 00:40:08.220
Run with it on all the time.

00:40:08.220 --> 00:40:10.210
It doesn't hurt anything except
it might break your

00:40:10.210 --> 00:40:11.490
site because you've got
bugs in your site.

00:40:14.577 --> 00:40:17.660
BORIS SMUS: So actually
on that, it's sort

00:40:17.660 --> 00:40:19.330
of interesting when--

00:40:19.330 --> 00:40:21.630
I think we're getting to a place
where there's a lot of

00:40:21.630 --> 00:40:24.270
possible permutations of
input that's available.

00:40:24.270 --> 00:40:26.740
And there's no real
way to know what's

00:40:26.740 --> 00:40:30.815
actually hooked up.

00:40:30.815 --> 00:40:31.540
I don't know.

00:40:31.540 --> 00:40:35.040
Maybe I'm the only one that's
kind of hit this, but it seems

00:40:35.040 --> 00:40:37.880
like sort of a bigger issue
for the web platform.

00:40:37.880 --> 00:40:38.640
Just--

00:40:38.640 --> 00:40:42.490
yeah, no real point here.

00:40:42.490 --> 00:40:43.710
PETE LEPAGE: All right.

00:40:43.710 --> 00:40:45.764
Anything else we want
to add to this?

00:40:45.764 --> 00:40:46.890
All right.

00:40:46.890 --> 00:40:48.360
Let's pop down to the
next question.

00:40:48.360 --> 00:40:50.730
And I think it's actually going
back to the sort of

00:40:50.730 --> 00:40:54.140
standardization comments we've
had a couple of times.

00:40:54.140 --> 00:40:57.110
But should we started working
on this standardizing of

00:40:57.110 --> 00:41:00.490
spatial and gestural input from
the upcoming wave of 3D

00:41:00.490 --> 00:41:03.602
motion sensing devices
like Leap Motion?

00:41:03.602 --> 00:41:06.690
MAIREAD BUCHAN: And so I was
talking to a research

00:41:06.690 --> 00:41:09.270
department at Kingston
University, and they deal with

00:41:09.270 --> 00:41:10.900
human-computer interaction.

00:41:10.900 --> 00:41:16.850
So they've been working with
multimillion pound software

00:41:16.850 --> 00:41:21.020
and hardware to do human pose
and gesture detection.

00:41:21.020 --> 00:41:24.780
And they've written a couple
of EU standards for gesture

00:41:24.780 --> 00:41:26.860
and also human body pose.

00:41:26.860 --> 00:41:32.090
So that kind of research has
already existed, not in the

00:41:32.090 --> 00:41:35.840
web development world but
in the HCI world, for

00:41:35.840 --> 00:41:37.520
quite a long time.

00:41:37.520 --> 00:41:40.470
If I was going to see a standard
for us to work with

00:41:40.470 --> 00:41:44.740
Leap and Kinect, I would like
it to be following in the

00:41:44.740 --> 00:41:46.420
paths of other people's
research.

00:41:46.420 --> 00:41:49.340
I don't want to reinvent the
wheel for that kind of thing.

00:41:53.480 --> 00:41:55.260
MATT CARUANA GALIZIA:
I agree with that.

00:41:55.260 --> 00:41:58.330
For most use cases, developers
will just want to listen to

00:41:58.330 --> 00:41:58.970
the intent.

00:41:58.970 --> 00:42:03.120
For example, in the few use
cases right now where a Leap

00:42:03.120 --> 00:42:06.040
Motion device is attached, we
just want our website to

00:42:06.040 --> 00:42:08.930
continue working if we're
listening for

00:42:08.930 --> 00:42:11.340
events on links, say.

00:42:11.340 --> 00:42:17.220
But for applications that
specifically target--

00:42:17.220 --> 00:42:20.070
meant to be used with Leap
Motion devices or the Kinect,

00:42:20.070 --> 00:42:25.220
say, then really need a standard
way of dealing with

00:42:25.220 --> 00:42:26.770
input from these devices.

00:42:26.770 --> 00:42:28.720
The market is probably
going to grow.

00:42:28.720 --> 00:42:31.990
There are going to be
many new devices.

00:42:31.990 --> 00:42:35.890
We can't just ship all the
different JavaScript libraries

00:42:35.890 --> 00:42:38.060
for every single device
with our application.

00:42:38.060 --> 00:42:40.356
It's just not scalable.

00:42:40.356 --> 00:42:41.260
BORIS SMUS: Yeah.

00:42:41.260 --> 00:42:44.810
I would sort of agree
in spirit with the

00:42:44.810 --> 00:42:48.260
standardization idea, but I
really do think it's early

00:42:48.260 --> 00:42:51.020
days for these kinds
of inputs.

00:42:51.020 --> 00:42:53.650
And I think before standardizing
it, it's

00:42:53.650 --> 00:42:57.660
worthwhile just to let a million
flowers bloom and just

00:42:57.660 --> 00:43:02.160
to see what the commonalities
are and what the useful things

00:43:02.160 --> 00:43:05.110
are for standardization before
we move in that path, because

00:43:05.110 --> 00:43:06.360
it's going to slow us down.

00:43:09.172 --> 00:43:13.700
PETE LEPAGE: Matt, I want to
go back on the same path of

00:43:13.700 --> 00:43:16.890
something that you said that
kind of jogged my mind and I

00:43:16.890 --> 00:43:18.350
thought was kind
of interesting.

00:43:18.350 --> 00:43:21.040
Should we maybe think about with
the PointerEvents spec

00:43:21.040 --> 00:43:24.660
just adding a z-coordinate
to it?

00:43:24.660 --> 00:43:25.520
MATT CARUANA GALIZIA: Yeah.

00:43:25.520 --> 00:43:27.450
I think that make sense.

00:43:27.450 --> 00:43:29.790
Why not, really?

00:43:29.790 --> 00:43:32.160
PETE LEPAGE: Would something
like that work for Leap and

00:43:32.160 --> 00:43:35.080
all of these other things,
potentially?

00:43:35.080 --> 00:43:39.390
MATT CARUANA GALIZIA: It would
work in a limited sense.

00:43:39.390 --> 00:43:44.200
It wouldn't allow you to make
the best use of the Leap

00:43:44.200 --> 00:43:46.540
Motion device.

00:43:46.540 --> 00:43:52.440
But for doing basic things, like
manipulating something,

00:43:52.440 --> 00:43:57.160
let's say a graphic within a
3D plane, then that works.

00:43:57.160 --> 00:44:00.616
For more complex gestures, then
of course, it will be a

00:44:00.616 --> 00:44:03.910
bit more difficult to use
pointers in that sense.

00:44:03.910 --> 00:44:05.630
You'd need something a bit
more sophisticated.

00:44:08.295 --> 00:44:11.170
MAIREAD BUCHAN: I think the way
I see it, there's a couple

00:44:11.170 --> 00:44:13.490
of different kinds of
applications that you might

00:44:13.490 --> 00:44:16.770
want to use, a 3D motion-sensor

00:44:16.770 --> 00:44:19.045
device and the internet.

00:44:19.045 --> 00:44:22.260
So one kind of use case is that
you're building a website

00:44:22.260 --> 00:44:23.200
that someone's going
to browse.

00:44:23.200 --> 00:44:25.090
So they're swiping carousels,
and they're

00:44:25.090 --> 00:44:26.110
scrolling the page.

00:44:26.110 --> 00:44:28.610
And that's quite traditional
web development.

00:44:28.610 --> 00:44:30.920
Or there's another aspect
where you might be doing

00:44:30.920 --> 00:44:35.480
something more in a 3D
environment, so gaming and

00:44:35.480 --> 00:44:41.640
things where you need inertia
and speed and like also, 3D

00:44:41.640 --> 00:44:44.960
motion does kind of tilt,
and rotation of a point.

00:44:44.960 --> 00:44:46.750
So it's not just x, y, z.

00:44:46.750 --> 00:44:49.090
There's actually a lot of other
information, and that's

00:44:49.090 --> 00:44:50.570
relevant to a 3D world.

00:44:50.570 --> 00:44:53.450
But it's not really relevant to
someone browsing a web page

00:44:53.450 --> 00:44:56.840
or reading a magazine
on their television.

00:44:56.840 --> 00:45:00.100
So what kind of application
you're developing, it depends

00:45:00.100 --> 00:45:01.530
how much information you need.

00:45:01.530 --> 00:45:07.030
So pointer is really good for
websites, and there's other

00:45:07.030 --> 00:45:11.412
things that would be relevant
for other kinds.

00:45:11.412 --> 00:45:12.360
BORIS SMUS: I agree.

00:45:12.360 --> 00:45:14.920
And I would actually be wary
of adding a z-coordinate to

00:45:14.920 --> 00:45:20.010
pointer events, partly just
because it's unclear what the

00:45:20.010 --> 00:45:22.700
units would be for
all this stuff.

00:45:22.700 --> 00:45:26.640
You're breaking the connection
of a mapping-to-a-screen

00:45:26.640 --> 00:45:28.140
coordinate.

00:45:28.140 --> 00:45:31.200
As soon as you're dealing with
tracking real world stuff,

00:45:31.200 --> 00:45:33.450
it's in some different
coordinate systems that's

00:45:33.450 --> 00:45:34.880
basically--

00:45:34.880 --> 00:45:38.300
if you can bring it back to
screen space, you're doing it

00:45:38.300 --> 00:45:39.740
with some weird transform.

00:45:39.740 --> 00:45:41.960
But there's some other
set of coordinates.

00:45:41.960 --> 00:45:45.810
Typically for a depth cam, it's
x, y, z, in millimeters,

00:45:45.810 --> 00:45:49.390
which would be very confusing to
suddenly change your units

00:45:49.390 --> 00:45:51.070
to millimeters in
pointer spec.

00:45:51.070 --> 00:45:54.745
So my vote for keeping
pointers clean.

00:45:57.788 --> 00:45:59.940
PETE LEPAGE: Francois, do you
want to weigh in on that one?

00:45:59.940 --> 00:46:00.370
FRANCOIS DAOUST: [INAUDIBLE].

00:46:00.370 --> 00:46:01.091
PETE LEPAGE: All right.

00:46:01.091 --> 00:46:01.395
All right.

00:46:01.395 --> 00:46:04.496
FRANCOIS DAOUST: [INAUDIBLE].

00:46:04.496 --> 00:46:05.310
PETE LEPAGE: All right.

00:46:05.310 --> 00:46:07.710
So pop down to our
next question.

00:46:07.710 --> 00:46:11.240
What will be the equivalent
event for hover mouseover for

00:46:11.240 --> 00:46:12.660
touch devices?

00:46:12.660 --> 00:46:14.290
Should we abandon the
hover event when

00:46:14.290 --> 00:46:15.660
considering touch devices?

00:46:19.167 --> 00:46:22.880
FRANCOIS DAOUST: I guess that
could happen in the future.

00:46:22.880 --> 00:46:25.840
You can already do that, some
kind of presence detection of

00:46:25.840 --> 00:46:30.290
the finger, with several
systems, infrared or--

00:46:30.290 --> 00:46:31.420
what's it's called?

00:46:31.420 --> 00:46:32.640
Ultrasound.

00:46:32.640 --> 00:46:34.830
There are some systems that
allow you to detect the

00:46:34.830 --> 00:46:38.860
presence of a finger without
actually touching the screen.

00:46:38.860 --> 00:46:44.170
But it has more limited use than
hover, and it's supposed

00:46:44.170 --> 00:46:49.470
that the user is not shaking and
is actually pointing his

00:46:49.470 --> 00:46:50.720
finger correctly.

00:46:52.820 --> 00:46:55.250
We should not close the door
to that possibility, but I

00:46:55.250 --> 00:46:58.080
don't think that's a main
use case right now.

00:46:58.080 --> 00:47:00.170
BORIS SMUS: I think it's
important that we don't rely

00:47:00.170 --> 00:47:06.720
on hover for just the general
web, again, because of mixed

00:47:06.720 --> 00:47:09.160
modalities, possibly of input.

00:47:09.160 --> 00:47:11.370
If you rely on hover, generally
touch devices are

00:47:11.370 --> 00:47:13.750
not going to be able to
see whatever's there.

00:47:13.750 --> 00:47:16.500
It's a very clunky interaction
to have this.

00:47:16.500 --> 00:47:19.880
You can activate the hover
state, the CSS hover state, by

00:47:19.880 --> 00:47:22.360
doing this weird action.

00:47:22.360 --> 00:47:25.540
You press down on the link, and
then you move away from it

00:47:25.540 --> 00:47:27.480
before it long presses, or
something like that.

00:47:27.480 --> 00:47:29.390
And then you get the
hover state.

00:47:29.390 --> 00:47:32.430
But obviously this is not
something that we want to do

00:47:32.430 --> 00:47:34.080
or have people do.

00:47:34.080 --> 00:47:37.170
So I do think that
it's important.

00:47:37.170 --> 00:47:40.020
Though there's technology coming
to make this happen,

00:47:40.020 --> 00:47:42.630
it's not going to
happen tomorrow.

00:47:42.630 --> 00:47:45.950
You should be very aware of
hover states in touch and

00:47:45.950 --> 00:47:48.442
don't do it.

00:47:48.442 --> 00:47:49.610
PETE LEPAGE: There
a comment back--

00:47:49.610 --> 00:47:52.320
AUDIENCE: Actually, I
ask a question, yes.

00:47:52.320 --> 00:47:59.110
And the reason I ask is, so my
wife has a Samsung Note, which

00:47:59.110 --> 00:48:01.250
comes with a pen.

00:48:01.250 --> 00:48:05.120
Because it comes with pen, pen
can do the kind of hover

00:48:05.120 --> 00:48:05.320
equivalent.

00:48:05.320 --> 00:48:10.010
When it comes too close to the
surface, it mimics hover.

00:48:10.010 --> 00:48:13.670
And also, when you do a drawing
in something like

00:48:13.670 --> 00:48:15.960
Wacom they also have
the hover.

00:48:15.960 --> 00:48:18.200
And it's very critical,
especially when you start

00:48:18.200 --> 00:48:20.470
doing [? data ?] visualization
or something, you don't want

00:48:20.470 --> 00:48:23.130
to touch everything, because
you just want to glance the

00:48:23.130 --> 00:48:24.110
information.

00:48:24.110 --> 00:48:26.800
Then you need a [INAUDIBLE]

00:48:26.800 --> 00:48:31.380
information, which I don't
want to touch everything.

00:48:31.380 --> 00:48:36.400
So I think hover is kind of
getting neglected, especially

00:48:36.400 --> 00:48:36.960
in the touch.

00:48:36.960 --> 00:48:40.070
You think a touch panel
enhances the input--

00:48:40.070 --> 00:48:40.860
PETE LEPAGE: Yeah.

00:48:40.860 --> 00:48:41.570
AUDIENCE: --but it's actually
one [? other ?]

00:48:41.570 --> 00:48:41.760
thing.

00:48:41.760 --> 00:48:42.450
It's decreasing.

00:48:42.450 --> 00:48:43.240
PETE LEPAGE: Yeah.

00:48:43.240 --> 00:48:43.550
Yeah.

00:48:43.550 --> 00:48:45.350
I think that's a really
valid point.

00:48:45.350 --> 00:48:48.350
MAIREAD BUCHAN: I think it's
kind of highlighting the

00:48:48.350 --> 00:48:51.610
problem of like a kind of--

00:48:51.610 --> 00:48:53.820
I don't want to use the word
"semantics," but I can't think

00:48:53.820 --> 00:48:54.670
of anything better--

00:48:54.670 --> 00:48:59.650
like a hover with a mouse on
a 2D screen is not really a

00:48:59.650 --> 00:49:00.160
hover at all.

00:49:00.160 --> 00:49:02.860
That's a mouse entering
a bounded area.

00:49:02.860 --> 00:49:05.260
It's not hovering just above it
because you've only got two

00:49:05.260 --> 00:49:07.370
dimensions.

00:49:07.370 --> 00:49:11.120
What's a hover in a 3D world
is different to a

00:49:11.120 --> 00:49:12.010
hover in a 2D world.

00:49:12.010 --> 00:49:16.700
And actually, it should be
pointer Enter before pointer

00:49:16.700 --> 00:49:17.920
is activated.

00:49:17.920 --> 00:49:20.990
And your active is your click,
and your Enter is your hover.

00:49:20.990 --> 00:49:24.370
But we need to move away from
that kind of terminology,

00:49:24.370 --> 00:49:26.570
because it is confusing.

00:49:26.570 --> 00:49:27.820
It's a mixed metaphor.

00:49:30.330 --> 00:49:32.790
I like hover, but I tell my
designers they're not allowed

00:49:32.790 --> 00:49:35.802
to use it anymore.

00:49:35.802 --> 00:49:37.530
PETE LEPAGE: We've
got time for, I

00:49:37.530 --> 00:49:38.780
think, one more question.

00:49:41.950 --> 00:49:44.420
So we'll go for this last one.

00:49:44.420 --> 00:49:47.280
Smooth scrolling is critical
for a good touchscreen

00:49:47.280 --> 00:49:48.180
experience.

00:49:48.180 --> 00:49:50.520
What are some of the common
pitfalls for introducing

00:49:50.520 --> 00:49:52.750
scroll jank to touch input?

00:49:55.396 --> 00:49:57.850
BORIS SMUS: So one of the common
things people tend to

00:49:57.850 --> 00:50:02.330
do is do a bunch of stuff
in their input handlers.

00:50:02.330 --> 00:50:05.470
So this breaks down really
quickly with multitouch,

00:50:05.470 --> 00:50:09.765
because you're having your
touch move events firing

00:50:09.765 --> 00:50:11.380
basically at a rate proportional
to the number of

00:50:11.380 --> 00:50:12.770
fingers on your screen.

00:50:12.770 --> 00:50:15.420
So you end up having
a flood of--

00:50:15.420 --> 00:50:16.810
I don't know-- something
like--

00:50:16.810 --> 00:50:21.940
I've seen it go up to, like,
200 fps touch input events.

00:50:21.940 --> 00:50:26.860
So if you're trying to render
at 200 fps, you're obviously

00:50:26.860 --> 00:50:31.210
going to be throttling your
rendering engine.

00:50:31.210 --> 00:50:35.270
The workaround to this is use
RequestAnimationFrame, set

00:50:35.270 --> 00:50:40.960
state in your input handler, and
then render on render as

00:50:40.960 --> 00:50:42.210
opposed to on input.

00:50:45.556 --> 00:50:47.080
PETE LEPAGE: Anybody else
got anything they

00:50:47.080 --> 00:50:48.660
want to add to that?

00:50:48.660 --> 00:50:49.090
Who's there?

00:50:49.090 --> 00:50:49.650
RICK BYERS: Rick.

00:50:49.650 --> 00:50:50.640
PETE LEPAGE: All right.

00:50:50.640 --> 00:50:51.910
Can we get a mic over
there real quick.

00:50:54.540 --> 00:50:55.400
RICK BYERS: I'm sorry.

00:50:55.400 --> 00:50:58.840
This is such a big problem I
can't help not speak up again.

00:50:58.840 --> 00:51:00.770
I think people often don't
realize the implication of

00:51:00.770 --> 00:51:02.260
putting a touch handler
on your page.

00:51:02.260 --> 00:51:05.190
So if you're using touch events,
the model is that the

00:51:05.190 --> 00:51:07.390
browser can't decide whether
or not to scroll until it's

00:51:07.390 --> 00:51:10.010
dispatched the touch
starter-touch move event to

00:51:10.010 --> 00:51:11.110
you and waited to see if
you're going to call

00:51:11.110 --> 00:51:11.770
preventDefault.

00:51:11.770 --> 00:51:13.820
And if you preventDefault on the
touch starter-touch move,

00:51:13.820 --> 00:51:15.040
that means you're canceling
the scroll.

00:51:15.040 --> 00:51:17.040
You might even be in the middle
of the scroll, and you

00:51:17.040 --> 00:51:18.710
preventDefault to move, and it
means we have to cancel the

00:51:18.710 --> 00:51:21.520
scroll, which means in modern
browsers, we try to do as much

00:51:21.520 --> 00:51:23.700
scrolling as possible
on the GPU thread.

00:51:23.700 --> 00:51:26.350
Which means we've got to block
the GPU thread, synchronize

00:51:26.350 --> 00:51:27.680
with the main thread that might
be in the middle of

00:51:27.680 --> 00:51:30.660
JavaScript or loading a page to
wait to see what your touch

00:51:30.660 --> 00:51:31.940
handler is going to do
before we can go

00:51:31.940 --> 00:51:32.940
back and undo scrolling.

00:51:32.940 --> 00:51:34.020
And it's a huge problem.

00:51:34.020 --> 00:51:37.240
So the key guidance
I would give is--

00:51:37.240 --> 00:51:40.070
what we've done in the recent
versions of Chrome and what

00:51:40.070 --> 00:51:43.540
iOS does is it's got region
tracking so that the GPU

00:51:43.540 --> 00:51:45.860
thread knows which regions
of the page have a

00:51:45.860 --> 00:51:47.060
touch handler on it.

00:51:47.060 --> 00:51:49.590
So if you confine your touch
handlers to just the elements

00:51:49.590 --> 00:51:52.890
that really need to have touch
handlers, then we can only

00:51:52.890 --> 00:51:54.680
introduce the jank when
you touch those.

00:51:54.680 --> 00:51:57.530
If you put a touch-move handler
on your document, it

00:51:57.530 --> 00:51:59.580
means that every single scroll
has got a block on the main

00:51:59.580 --> 00:52:01.710
thread, and it's going to be
almost impossible to have

00:52:01.710 --> 00:52:03.990
smooth scrolling.

00:52:03.990 --> 00:52:05.570
This is one of the things I
think is a problem with the

00:52:05.570 --> 00:52:06.300
touch event model.

00:52:06.300 --> 00:52:08.640
Pointer event solves this.

00:52:08.640 --> 00:52:11.744
PETE LEPAGE: There's a
comment back there.

00:52:11.744 --> 00:52:12.680
AUDIENCE: Hi.

00:52:12.680 --> 00:52:14.370
It was just related to
what you were saying.

00:52:14.370 --> 00:52:16.850
How does that translate
through to clicks?

00:52:16.850 --> 00:52:19.300
Is it just touch, or what
happens when you've got the

00:52:19.300 --> 00:52:21.955
simulated clicks from the touch
events with scrolling?

00:52:24.822 --> 00:52:25.590
PETE LEPAGE: Sorry.

00:52:25.590 --> 00:52:26.520
Just to make sure
I understand.

00:52:26.520 --> 00:52:28.250
What happens when you have
simulated clicks?

00:52:28.250 --> 00:52:30.925
AUDIENCE: So if you've got a
click handler element that

00:52:30.925 --> 00:52:33.355
you're using to scroll, does
exactly the same thing apply,

00:52:33.355 --> 00:52:33.703
or it just--

00:52:33.703 --> 00:52:37.330
RICK BYERS: It's just touch
handlers, because click is

00:52:37.330 --> 00:52:40.280
triggered by a tap gesture, and
so there's no ambiguity

00:52:40.280 --> 00:52:41.990
between scrolling and tapping.

00:52:41.990 --> 00:52:43.483
So you can have a tap handler,
you can have

00:52:43.483 --> 00:52:44.870
a mouse-down handler.

00:52:44.870 --> 00:52:46.900
In theory, mouse wheel
has the same problem.

00:52:46.900 --> 00:52:49.740
In theory, mouse wheels are
blocked on JavaScript.

00:52:49.740 --> 00:52:51.640
If there's a JavaScript
handler, we have to.

00:52:51.640 --> 00:52:51.970
But--

00:52:51.970 --> 00:52:52.480
AUDIENCE: [INAUDIBLE]--

00:52:52.480 --> 00:52:54.120
RICK BYERS: --all browser
implementations

00:52:54.120 --> 00:52:55.370
today always block.

00:52:55.370 --> 00:52:57.070
They don't do the region
tracking for mouse wheel,

00:52:57.070 --> 00:52:59.310
because there's a psychological
effect.

00:52:59.310 --> 00:53:01.370
Scrolling with your finger, you
really notice the jank.

00:53:01.370 --> 00:53:03.040
Scrolling with your mouse wheel
or the trackpad, you

00:53:03.040 --> 00:53:04.070
don't notice it so much
because you're

00:53:04.070 --> 00:53:05.450
not physically connected.

00:53:05.450 --> 00:53:08.050
So in theory, the problem exists
for mouse wheel, and we

00:53:08.050 --> 00:53:11.200
said we're probably going to
apply the same region tracking

00:53:11.200 --> 00:53:12.830
we've done for touch to
mouse wheel in Chrome.

00:53:12.830 --> 00:53:14.390
We just haven't done it yet,
because it's not as important

00:53:14.390 --> 00:53:15.640
because of that psychological
effect.

00:53:18.900 --> 00:53:21.000
FRANCOIS DAOUST: I know the
discussion has focused on

00:53:21.000 --> 00:53:24.030
touch, and the question
mentioned touch explicitly,

00:53:24.030 --> 00:53:28.600
which I just wanted to open it
to another dimension, which is

00:53:28.600 --> 00:53:33.840
just a regular nav-down,
nav-right, nav-left, nav-up

00:53:33.840 --> 00:53:37.800
events, which are the ones that
you'll receive when the

00:53:37.800 --> 00:53:41.210
user is using a TV remote,
for instance, on a TV.

00:53:41.210 --> 00:53:45.080
And it makes scrolling,
actually, a bit of a pain

00:53:45.080 --> 00:53:48.460
because you have to handle it
yourself in the web app with

00:53:48.460 --> 00:53:49.590
the nav-down.

00:53:49.590 --> 00:53:53.540
And you have to, well, scroll
the viewport, obviously, and

00:53:53.540 --> 00:53:57.040
then also handle links
in the good old days.

00:53:57.040 --> 00:54:01.010
But the TV is kind of huge
screen, as opposed to the

00:54:01.010 --> 00:54:04.950
mobile of 2000, where you had
the keypad, but you had the

00:54:04.950 --> 00:54:07.570
small screen, so it was kind
of easy to make the

00:54:07.570 --> 00:54:08.340
navigation.

00:54:08.340 --> 00:54:10.990
So anyway, I just wanted
to raise the point.

00:54:10.990 --> 00:54:15.460
Do not forget that there's more
than touch and mouse.

00:54:15.460 --> 00:54:18.960
PETE LEPAGE: I think that's a
great point, and I think the

00:54:18.960 --> 00:54:21.440
performance tip there of really
making sure that you're

00:54:21.440 --> 00:54:25.030
being aware of where you're
putting your touch events,

00:54:25.030 --> 00:54:28.010
listeners, and all that stuff
is a really great

00:54:28.010 --> 00:54:29.560
point to end on.

00:54:29.560 --> 00:54:32.310
I want to thank the panelists
for joining us up on stage.

00:54:32.310 --> 00:54:35.470
I hope you guys learned
something, and it was quite

00:54:35.470 --> 00:54:37.010
interesting for you.

00:54:37.010 --> 00:54:38.490
And go build cool.

