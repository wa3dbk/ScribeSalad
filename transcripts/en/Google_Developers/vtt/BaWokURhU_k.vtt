WEBVTT
Kind: captions
Language: en

00:00:00.170 --> 00:00:03.010
&gt;&gt;Richard: Welcome to the tech talk.

00:00:03.010 --> 00:00:09.720
Thank you for coming, and today we'll be talking
about optimizing every bit of your site serving

00:00:09.720 --> 00:00:12.660
and Web pages using Page Speed.

00:00:12.660 --> 00:00:13.660
I'm Richard Rabbat.

00:00:13.660 --> 00:00:14.940
I’m a project manager at Google.

00:00:14.940 --> 00:00:16.320
&gt;&gt;Bryan: And I'm Bryan McQuade.

00:00:16.320 --> 00:00:18.561
I'm a software engineer working on Web performance.

00:00:18.561 --> 00:00:24.610
&gt;&gt;Richard: Before we start, has anybody ever
used Page Speed?

00:00:24.610 --> 00:00:30.240
Can I show, see a show of hands?

00:00:30.240 --> 00:00:32.380
Great, perfect.

00:00:32.380 --> 00:00:34.929
This is the link to the Google Wave.

00:00:34.929 --> 00:00:35.929
We encourage you to look at it.

00:00:35.929 --> 00:00:43.100
There are live notes being taken, as well
as you can put moderator questions there,

00:00:43.100 --> 00:00:47.010
IO-speed [inaudible].

00:00:47.010 --> 00:00:49.760
And what you're gonna get from this talk quickly.

00:00:49.760 --> 00:00:51.909
This is a one-on-one kind of talk.

00:00:51.909 --> 00:00:59.510
So we don't assume a lot of pre, past knowledge
in terms of understanding of Page Speed and

00:00:59.510 --> 00:01:00.510
performance.

00:01:00.510 --> 00:01:04.049
So we cover some of the basics, but we'll
also go into some more details, more advanced

00:01:04.049 --> 00:01:05.049
details.

00:01:05.049 --> 00:01:08.520
We're gonna cover a few things.

00:01:08.520 --> 00:01:13.939
Most importantly, why you should be here and
why performance affects your site and why

00:01:13.939 --> 00:01:15.710
you should pay attention to performance.

00:01:15.710 --> 00:01:19.869
We're gonna make sure you become familiar
with Page Speed and the, the new features

00:01:19.869 --> 00:01:21.030
in Page Speed.

00:01:21.030 --> 00:01:28.270
And we'll also be talking about four new product
features, namely export functionality in Page

00:01:28.270 --> 00:01:35.530
Speed, DSDK and Apache module as well as Page
Speed as far as ads, analytics.

00:01:35.530 --> 00:01:40.351
We're gonna spend some time looking, talking
about Web performance.

00:01:40.351 --> 00:01:45.280
So I wanted to kind of give you, for those
of the people that haven't seen Page Speed,

00:01:45.280 --> 00:01:51.969
a brief UI basically, a bunch of rules and
how a Web page has been doing against the

00:01:51.969 --> 00:01:52.969
rules.

00:01:52.969 --> 00:01:53.969
We're gonna go over the details.

00:01:53.969 --> 00:01:58.380
But since we're spending some time talking
about Web performance, it's good to, for you

00:01:58.380 --> 00:02:01.810
guys to see the product first.

00:02:01.810 --> 00:02:05.219
Web performance 101.

00:02:05.219 --> 00:02:11.090
And here is why should it matter, why should,
should speed matter to you.

00:02:11.090 --> 00:02:17.349
We know from a lot of user studies that speed
is more people viewing your site, more people

00:02:17.349 --> 00:02:19.080
coming back to your site.

00:02:19.080 --> 00:02:26.069
Last year at the Velocity conference that's
run by O'Reilly we were fortunate enough to

00:02:26.069 --> 00:02:31.810
have a number of companies actually share
some of the data on their, on how performance

00:02:31.810 --> 00:02:34.310
actually, actually affects traffic.

00:02:34.310 --> 00:02:43.260
So, in, in, in, in those lists Google ran
what, what we consider a 400 millisecond latency

00:02:43.260 --> 00:02:44.260
increase.

00:02:44.260 --> 00:02:50.390
So basically we, we took a bunch of people
that we served more slowly by 400 milliseconds.

00:02:50.390 --> 00:02:56.980
And it actually, like corresponded to about
0.6% search decrease, which is very substantial

00:02:56.980 --> 00:02:59.140
for a company such as Google.

00:02:59.140 --> 00:03:01.870
Yahoo did a similar experiment.

00:03:01.870 --> 00:03:06.200
It actually hit their traffic by 5% to 9%.

00:03:06.200 --> 00:03:07.200
Shopzilla went a little bit further.

00:03:07.200 --> 00:03:12.170
So what they did is they basically archetyped
the whole UI and it actually contributed to

00:03:12.170 --> 00:03:13.959
about five second latency decrease.

00:03:13.959 --> 00:03:17.710
And they got a 12% revenue increase.

00:03:17.710 --> 00:03:22.269
And not only that, it actually de, decreased
their OPEX costs because they needed to use

00:03:22.269 --> 00:03:24.769
less hardware to do the serving.

00:03:24.769 --> 00:03:31.180
So important things that you should worry
about whenever you're developing your web,

00:03:31.180 --> 00:03:32.180
website.

00:03:32.180 --> 00:03:33.180
So Bryan.

00:03:33.180 --> 00:03:38.879
&gt;&gt;Bryan: So, now that we've seen why speed,
Web speed, is important, I'll do a little

00:03:38.879 --> 00:03:41.290
bit of a, more of a deep dive into the technical
aspects.

00:03:41.290 --> 00:03:45.950
Why don't we start with the building blocks
of Web performance?

00:03:45.950 --> 00:03:48.909
So there are three categories you need to
be thinking about when you're thinking about

00:03:48.909 --> 00:03:51.549
Web performance, or the end-to-end picture.

00:03:51.549 --> 00:03:56.859
That is performance at the Web server, on
the network and in the client on the browser

00:03:56.859 --> 00:03:57.859
as well.

00:03:57.859 --> 00:04:01.780
So on the server really, the, the most important
thing or the only thing we really, we, we

00:04:01.780 --> 00:04:03.549
look at is that server processing time.

00:04:03.549 --> 00:04:07.980
How long does it take your server to generate
the response?

00:04:07.980 --> 00:04:13.230
So for a static resource like a file stored
on disk you'd expect that to be close to zero.

00:04:13.230 --> 00:04:19.590
But for a dynamic response, something in response
to a user query, you might see increased processing

00:04:19.590 --> 00:04:20.590
time.

00:04:20.590 --> 00:04:22.280
Now we'll actually talk about, a little later
in the talk we'll talk about some ways to

00:04:22.280 --> 00:04:25.300
mitigate the impact of that processing time.

00:04:25.300 --> 00:04:27.990
But that's, that's the primary factor at the
Web server.

00:04:27.990 --> 00:04:32.060
And then on the network the two factors, the
primary factors, are bandwidth, or the contributing

00:04:32.060 --> 00:04:34.110
factors, bandwidth and round trip time.

00:04:34.110 --> 00:04:39.240
And then finally, we'll dive into those a
little bit more on future slides as well.

00:04:39.240 --> 00:04:44.020
Finally, on the client and the browser you're
looking at parse time, so how efficient is

00:04:44.020 --> 00:04:47.310
the browser at parsing HTML.

00:04:47.310 --> 00:04:51.050
Resource fetch time, how efficient is the
browser at finding and fetching resources.

00:04:51.050 --> 00:04:56.100
So we've seen a big improvement in efficiencies
and browsers in the last 12 months in terms

00:04:56.100 --> 00:04:59.890
of resource discovery and resource fetching.

00:04:59.890 --> 00:05:02.810
Previously we, browsers had fetched JavaScript
serially.

00:05:02.810 --> 00:05:08.780
So now most modern browsers, all modern browsers
in fact in the past 12 months do parallel

00:05:08.780 --> 00:05:10.840
JavaScript fetches which is, is a big win.

00:05:10.840 --> 00:05:12.840
And we're continuing to see improvements there.

00:05:12.840 --> 00:05:17.310
And then finally the last two categories,
layout and render and JavaScript.

00:05:17.310 --> 00:05:21.910
And for most traditional Web pages on the,
on the, out there, these categories don't

00:05:21.910 --> 00:05:27.130
tend to, traditional being the pre-AJAX pages.

00:05:27.130 --> 00:05:28.920
These don't have as big an impact.

00:05:28.920 --> 00:05:32.390
But if you've got a large DOM or a complex
DOM, layout can actually be a significant

00:05:32.390 --> 00:05:34.840
time, time contributor.

00:05:34.840 --> 00:05:41.460
And then JavaScript, again if, if you're using
a JavaScript heavy AJAX page, that's an, potentially

00:05:41.460 --> 00:05:43.640
an important contributor as well.

00:05:43.640 --> 00:05:48.490
So in those latter two cases there's actually
another tool, and hopefully you got to attend

00:05:48.490 --> 00:05:50.840
the tech talk's Google Speed Tracer.

00:05:50.840 --> 00:05:55.220
That does a nice job at giving you a timeline
and drilling down into the specifics of time

00:05:55.220 --> 00:05:58.970
spent in layout and rendering, and time spent
executing and parsing JavaScript.

00:05:58.970 --> 00:06:01.270
And I'd recommend checking that out to Google
Chrome extension.

00:06:01.270 --> 00:06:04.230
That does a nice job.

00:06:04.230 --> 00:06:09.380
So now that we've looked at the building blocks,
why don't we look at an example page load

00:06:09.380 --> 00:06:17.090
and sort of see how those building blocks
come together to, over the lifetime of the

00:06:17.090 --> 00:06:18.090
page load.

00:06:18.090 --> 00:06:23.160
So we'll look at a page load for a Google
search request, a search query for Half Dome

00:06:23.160 --> 00:06:24.160
photos.

00:06:24.160 --> 00:06:27.240
And what I'll show is we've got sort of three
columns here.

00:06:27.240 --> 00:06:28.430
Client and server.

00:06:28.430 --> 00:06:31.330
These are operations that happen either on
the client or the server.

00:06:31.330 --> 00:06:33.240
And then the third column we've got the render
column.

00:06:33.240 --> 00:06:37.650
This is what the page looks like as a result
of these different steps along the course

00:06:37.650 --> 00:06:38.650
of the page load.

00:06:38.650 --> 00:06:43.200
So what we've done here is we've really slowed
down the page load.

00:06:43.200 --> 00:06:47.000
And, and we'll see the discrete steps that
we go through, then in turn what that looks

00:06:47.000 --> 00:06:48.000
like in the browser as a result.

00:06:48.000 --> 00:06:54.461
So we'll understand how all these building
blocks come together to actually display the

00:06:54.461 --> 00:06:55.590
page for the user.

00:06:55.590 --> 00:07:01.800
So first, the first thing the browser has
to do every time you navigate to a Web page

00:07:01.800 --> 00:07:05.620
is potentially perform a DNS lookup.

00:07:05.620 --> 00:07:08.770
Subsequently, once the DNS lookup completes,
and that's, that takes about a round trip

00:07:08.770 --> 00:07:09.770
time, DNS lookup.

00:07:09.770 --> 00:07:13.470
And in fact, in many cases it'll take longer
than a round trip time because you'll hit

00:07:13.470 --> 00:07:15.580
multiple DNS caches along the way.

00:07:15.580 --> 00:07:19.430
But roughly speaking you're looking at one
round trip time. TCP connection, connect to

00:07:19.430 --> 00:07:22.320
the server, another round trip time.

00:07:22.320 --> 00:07:25.760
And then finally, after those two round trip
times the client will send a HTTP request

00:07:25.760 --> 00:07:30.900
to the server, so asking for that specific
resource.

00:07:30.900 --> 00:07:35.330
The server begins to process that query and
will start sending back the response.

00:07:35.330 --> 00:07:38.030
And at this point we've seen three round trip
times pass.

00:07:38.030 --> 00:07:44.470
So round trip time varies considerably depending
on where you are, how well connected you are

00:07:44.470 --> 00:07:45.470
on the Internet.

00:07:45.470 --> 00:07:52.270
But you're looking at anywhere from single
digit milliseconds on a local LAN to 10, 40,

00:07:52.270 --> 00:07:57.800
I think the average is about 70 milliseconds,
up to hundreds of milliseconds or even a second

00:07:57.800 --> 00:07:59.030
in the worst cases.

00:07:59.030 --> 00:08:05.750
So minimizing round trip times is a really
important part of optimizing your website.

00:08:05.750 --> 00:08:11.110
So finally once the response comes back after
these three round trip times, the browser

00:08:11.110 --> 00:08:13.440
can begin to parse that content.

00:08:13.440 --> 00:08:17.250
And then we start to see the page rendering
on the screen.

00:08:17.250 --> 00:08:20.590
And subsequently, more of the content comes
back.

00:08:20.590 --> 00:08:21.770
The browser continues to parse.

00:08:21.770 --> 00:08:25.210
And in this case the browser's discovered
that there are four image resources embedded

00:08:25.210 --> 00:08:26.420
in the response.

00:08:26.420 --> 00:08:29.870
And so it begins to fetch those resources.

00:08:29.870 --> 00:08:33.689
And what we see is that the network just echoes
and begins fetching these.

00:08:33.689 --> 00:08:38.199
Each of those sub fetches is potentially going
to incur a DNS lookup, a TCP connection as

00:08:38.199 --> 00:08:39.199
well.

00:08:39.199 --> 00:08:41.879
So you're seeing additional latency there
as well.

00:08:41.879 --> 00:08:45.589
And then eventually we see these responses
start to come back.

00:08:45.589 --> 00:08:51.990
And I'll, I'll mention too, the gray section
is the sort of off screen section, portion

00:08:51.990 --> 00:08:52.990
of the page.

00:08:52.990 --> 00:08:55.980
So we're looking at the -- the top portion
is the part the user can actually see.

00:08:55.980 --> 00:09:00.490
What we're seeing here is that the page is
rendering that most important content, the

00:09:00.490 --> 00:09:01.670
user visible content first.

00:09:01.670 --> 00:09:06.569
And then the yellow regions are the current,
the repainted regions during that last iteration

00:09:06.569 --> 00:09:07.699
of the load.

00:09:07.699 --> 00:09:12.709
So what we start to see is the image responses
come back, they continue to fill in.

00:09:12.709 --> 00:09:15.980
And finally, the page finishes rendering.

00:09:15.980 --> 00:09:24.790
So this is sort of how these different factors,
DNS, TCP, client cypings, parsed layout, sub

00:09:24.790 --> 00:09:29.440
resource fetches come together during lifecycle
to page load to, to sort of load and render

00:09:29.440 --> 00:09:30.440
that page.

00:09:30.440 --> 00:09:31.440
So in fact—

00:09:31.440 --> 00:09:35.279
[ pause ]

00:09:35.279 --> 00:09:42.399
Typically when you're performing a Google
search, it feels like it loads, hopefully

00:09:42.399 --> 00:09:45.670
it feels like it loads like that [ snaps fingers
 ].

00:09:45.670 --> 00:09:48.180
But in fact all these little discrete steps
are happening along the way.

00:09:48.180 --> 00:09:52.589
And understanding those, understanding how
they come together can help to understand

00:09:52.589 --> 00:09:54.410
how to optimize the page.

00:09:54.410 --> 00:09:57.220
So given that, Richard will summarize.

00:09:57.220 --> 00:10:02.170
&gt;&gt;Richard: So, if you go away from this tech
talk, and you need to remember in fact three,

00:10:02.170 --> 00:10:03.570
three things out of this.

00:10:03.570 --> 00:10:07.740
These are like the three speed guidelines
you should like always worry about when, whenever

00:10:07.740 --> 00:10:10.800
you are developing a Web app.

00:10:10.800 --> 00:10:13.649
And the first one is you want to try to serve
fewer bytes.

00:10:13.649 --> 00:10:18.050
And you're, you're going over the network.

00:10:18.050 --> 00:10:22.430
You want to try to minimize the number of
bytes that you're sending over the network

00:10:22.430 --> 00:10:24.470
because they, they fit in packets.

00:10:24.470 --> 00:10:25.660
There are so many round trips.

00:10:25.660 --> 00:10:32.170
So the way, some of the ways that we suggest
that you do it is by compressing and serving,

00:10:32.170 --> 00:10:33.310
enable user compression.

00:10:33.310 --> 00:10:37.050
Obviously lots of people do it; some just
still don't.

00:10:37.050 --> 00:10:43.029
If you have a Web host, Web hoster that is
hosting your, your content and is not enabling

00:10:43.029 --> 00:10:45.290
compression move to another one.

00:10:45.290 --> 00:10:46.290
Optimize damages.

00:10:46.290 --> 00:10:51.810
A lot of the images that come out of, of a
camera are very wordy and verbose.

00:10:51.810 --> 00:10:55.410
There's like a lot of meta information that's
un, unnecessary.

00:10:55.410 --> 00:10:59.029
Get rid of it with a lot of open source tools;
you can see a bunch of them.

00:10:59.029 --> 00:11:04.080
And also make sure that you're only sending
the right size resolution of the image.

00:11:04.080 --> 00:11:10.889
It saves bytes on the wire, but it also saves
processing time on the server, on the client

00:11:10.889 --> 00:11:11.889
side.

00:11:11.889 --> 00:11:17.120
Get rid of all the content in the HTML, in
the JavaScript in the, in the style sheet

00:11:17.120 --> 00:11:20.670
that is something that you've put for development
sake.

00:11:20.670 --> 00:11:23.939
All the comments are things that your browser
doesn't care about.

00:11:23.939 --> 00:11:25.089
So get rid of them.

00:11:25.089 --> 00:11:31.250
Use minification tools such as Closure Compiler,
which is also an open source project.

00:11:31.250 --> 00:11:33.199
And also, cache aggressively.

00:11:33.199 --> 00:11:38.480
The way I think of it is the best, the fastest
serving is when you don't have to serve.

00:11:38.480 --> 00:11:40.700
That everything is in your cache.

00:11:40.700 --> 00:11:47.450
So see if you can push things earlier to the
browser that is gonna be, is gonna be needed

00:11:47.450 --> 00:11:52.240
a little bit later so you're not waiting,
the user's not waiting.

00:11:52.240 --> 00:11:53.779
So, serve fewer bytes.

00:11:53.779 --> 00:11:55.320
Parallelize resource downloads.

00:11:55.320 --> 00:11:59.430
Modern browsers use up to 60 parallel connections.

00:11:59.430 --> 00:12:04.279
Try to make use of them all.

00:12:04.279 --> 00:12:09.699
And we'll talk a little bit about like one
of the rules about like optimizing autostarts

00:12:09.699 --> 00:12:12.319
and scripts, which also helps in parallelism.

00:12:12.319 --> 00:12:16.920
And don't shy away from promoting modern browsers.

00:12:16.920 --> 00:12:19.430
Don't develop for the lowest common denominator.

00:12:19.430 --> 00:12:20.839
It doesn't help.

00:12:20.839 --> 00:12:22.389
Push the envelope.

00:12:22.389 --> 00:12:28.079
If you need to support older browsers, check
the user agent and serve unoptimized content

00:12:28.079 --> 00:12:30.160
for that, for that user agent.

00:12:30.160 --> 00:12:35.189
For example, don't serve sprites to old browsers
that don't support it.

00:12:35.189 --> 00:12:40.749
But use spriting, image spriting, when you're,
the user agent can support it.

00:12:40.749 --> 00:12:48.680
So three things: serve fewer bytes, parallelize
and push the envelope in terms of browser

00:12:48.680 --> 00:12:50.620
support.

00:12:50.620 --> 00:12:56.829
So I know it's been a few minutes since we've
started this talk, and people are anxious

00:12:56.829 --> 00:12:57.829
to see it.

00:12:57.829 --> 00:13:05.529
So Page Speed is, is a, it's a Firefox, Firebug
extension.

00:13:05.529 --> 00:13:08.439
And we have about one million active users.

00:13:08.439 --> 00:13:17.470
So for the people that haven't used it, download
it and join the fun.

00:13:17.470 --> 00:13:19.019
[pause]

00:13:19.019 --> 00:13:23.870
This is our site, code.google.com/speed/page-speed.

00:13:23.870 --> 00:13:29.110
And the way you're gonna use it is -- this
is the little Firebug.

00:13:29.110 --> 00:13:30.950
And you, you start it up.

00:13:30.950 --> 00:13:33.370
Page Speed is an extension in Firebug.

00:13:33.370 --> 00:13:36.700
And it tells you about like the new features
that we have.

00:13:36.700 --> 00:13:41.809
And the first thing you're gonna do is analyze
the performance of that page.

00:13:41.809 --> 00:13:48.749
So I'm analyzing this page on the code site,
and it gives me a bunch of rules.

00:13:48.749 --> 00:13:50.100
The first thing you see is a score.

00:13:50.100 --> 00:13:57.999
A score is a, is something that we believe
is good indication for, it's a good metric

00:13:57.999 --> 00:14:02.619
that you can use that, that's reliably reproducible.

00:14:02.619 --> 00:14:04.699
So you're getting about 82 over a hundred.

00:14:04.699 --> 00:14:06.490
We think it, it's okay.

00:14:06.490 --> 00:14:08.619
It's a, it's an okay Web page.

00:14:08.619 --> 00:14:14.110
And it's gonna, you have a bunch of rules
that you executed, and each one is gonna tell

00:14:14.110 --> 00:14:15.779
you what, what the issue is.

00:14:15.779 --> 00:14:19.230
So for example here, leverage browser caching.

00:14:19.230 --> 00:14:25.559
So all these, a lot of this JavaScript is,
has an expiry time of like one hour.

00:14:25.559 --> 00:14:27.730
You should look at the expiry time.

00:14:27.730 --> 00:14:30.240
Do you really need it to be one hour, or can
you push it?

00:14:30.240 --> 00:14:34.579
Can you like, can you put it at 24 hours or
seven, seven days?

00:14:34.579 --> 00:14:35.650
Seven days is a good time.

00:14:35.650 --> 00:14:40.540
You'll, you'll make sure that anybody that
comes back to your site can actually, can

00:14:40.540 --> 00:14:47.189
actually have it in its cache, in the cache
of the browser.

00:14:47.189 --> 00:14:49.930
And obviously not, a number of rules here.

00:14:49.930 --> 00:14:53.050
I encourage you to explore them.

00:14:53.050 --> 00:14:57.050
And I encourage you to also like look at some
of the documentation.

00:14:57.050 --> 00:15:03.170
So the easiest way to get to the documentation
is just to press on the rule.

00:15:03.170 --> 00:15:08.459
'Cause once you see a rule and go like I don't
understand what this rule is, just press on

00:15:08.459 --> 00:15:09.459
the rule and you have a lot of documentation.

00:15:09.459 --> 00:15:10.459
All this, all the documentation in open source.

00:15:10.459 --> 00:15:16.500
And we, we try to be very descriptive of what,
what the problem is and how you can resolve

00:15:16.500 --> 00:15:17.500
it.

00:15:17.500 --> 00:15:23.010
So going back to, going back to our presentation.

00:15:23.010 --> 00:15:24.010
Bryan?

00:15:24.010 --> 00:15:29.079
&gt;&gt;Bryan: Yep. So let's look at one example
of, of why speed minded development matters.

00:15:29.079 --> 00:15:34.529
So for, for each of those Page Speed suggestions,
why is it important that you adopt that, that

00:15:34.529 --> 00:15:35.529
suggestion?

00:15:35.529 --> 00:15:36.529
You apply it to your site.

00:15:36.529 --> 00:15:38.259
What, what is it doing and how is it making
the site faster?

00:15:38.259 --> 00:15:42.639
So we'll look at one specific example, which
we talked a little bit about earlier around

00:15:42.639 --> 00:15:43.639
parallelization.

00:15:43.639 --> 00:15:46.279
So the ordering of styles and scripts.

00:15:46.279 --> 00:15:50.230
So here's an example I had of an HTML Web
page.

00:15:50.230 --> 00:15:53.569
What we've got is sort of some interspersed
CSS and JavaScript content.

00:15:53.569 --> 00:15:56.249
It looks reasonable enough.

00:15:56.249 --> 00:16:03.680
But in fact, in some browsers what you'll
see is that intermixing CSS and JavaScript

00:16:03.680 --> 00:16:08.160
like this, so some CSS, some JavaScripts and
CSS introduces additional serialization delays

00:16:08.160 --> 00:16:09.160
in the page load.

00:16:09.160 --> 00:16:13.249
So what, what you get is you get the two,
the CSS and the JavaScript file will load.

00:16:13.249 --> 00:16:18.100
Youl get another delay on the next JavaScript
file and then the final CSS files load.

00:16:18.100 --> 00:16:24.499
And it turns out, so, so what you're looking
at here is roughly 300 milliseconds in this

00:16:24.499 --> 00:16:26.639
example if it's a hundred millisecond round
trip.

00:16:26.639 --> 00:16:32.459
So it turns out that if you just reorder these
things, so you put all the CSS upfront followed

00:16:32.459 --> 00:16:37.309
by the JavaScript, the browser can more efficiently,
some browsers do anyway, more efficiently

00:16:37.309 --> 00:16:41.189
will fetch that content and you'll be able
to remove one of the round trip times.

00:16:41.189 --> 00:16:45.670
So this is an example where it's an easy fix,
an easy thing to do.

00:16:45.670 --> 00:16:48.939
All of our suggestions, this one and all of
our suggestions, won't have any, shouldn't

00:16:48.939 --> 00:16:50.721
have any impact on the look and feel of your
page.

00:16:50.721 --> 00:16:54.319
So as far as the user's concerned the page
is exactly the same.

00:16:54.319 --> 00:16:58.889
And then finally, what you get is you reduce
one of those round trip times and go from

00:16:58.889 --> 00:17:04.800
the 300 milliseconds to 200 milliseconds without
any other change in the page.

00:17:04.800 --> 00:17:07.820
So over the last, we launched in June?

00:17:07.820 --> 00:17:08.820
&gt;&gt;Richard: Yep.

00:17:08.820 --> 00:17:10.520
&gt;&gt;Bryan: So it's been about a year.

00:17:10.520 --> 00:17:16.750
And over the last year we've been working
hard on a number of things.

00:17:16.750 --> 00:17:18.790
We've added some new rules and fixed some
others.

00:17:18.790 --> 00:17:22.120
And we just wanted to talk about a few of
them just to give some examples.

00:17:22.120 --> 00:17:25.620
So we added a rule, called minimize request
size, within the last year.

00:17:25.620 --> 00:17:32.020
And the idea there is that each request that
the browser makes has some overhead.

00:17:32.020 --> 00:17:34.580
And there are things you can do.

00:17:34.580 --> 00:17:40.730
Reducing cookie size, reducing the length
of the URL in fact can keep that request size

00:17:40.730 --> 00:17:45.150
small so that it fits within a single TCP
packet and is more likely to be transmitted

00:17:45.150 --> 00:17:46.960
efficiently and quickly over the network.

00:17:46.960 --> 00:17:53.910
And that's especially important in mobile
because mobile tends to have a high latency

00:17:53.910 --> 00:17:57.810
and asymmetric bandwidth where you've got
a slower up than a down link.

00:17:57.810 --> 00:18:02.740
So, next specify a cache validator is a new
rule that we added actually pretty recently.

00:18:02.740 --> 00:18:08.150
And the idea there is that for static content,
for static resources, once they do expire,

00:18:08.150 --> 00:18:12.240
so if you set an expiration of a week or a
month or a year, once they do expire it's

00:18:12.240 --> 00:18:17.110
possible for the browser to ask the server,
"Hey, I have this resource. It's not fresh

00:18:17.110 --> 00:18:21.900
anymore. It's not, it's not, it's expired.
Has it changed?"

00:18:21.900 --> 00:18:24.071
And the server can say, "Nope, it hasn't changed."

00:18:24.071 --> 00:18:26.650
You can update it and keep it for another
week for instance.

00:18:26.650 --> 00:18:29.750
Using a cache validator allows you to do that,
otherwise you have to download the entire

00:18:29.750 --> 00:18:31.680
resource again even if it hasn't changed.

00:18:31.680 --> 00:18:33.910
So that's a rule we've added.

00:18:33.910 --> 00:18:37.710
Specify a character set early.

00:18:37.710 --> 00:18:42.690
It turns out that if you, if you're serving
HTML content and you don't specify the character

00:18:42.690 --> 00:18:46.860
set, so UTF-8 or Shift-JIS or whatever it
might be, the browser has to guess as to what

00:18:46.860 --> 00:18:47.860
the character set is.

00:18:47.860 --> 00:18:51.640
And in order to do that, it buffers content
in its, in, in memory before it actually starts

00:18:51.640 --> 00:18:52.640
parsing it.

00:18:52.640 --> 00:18:53.860
So the browser's downloading the content.

00:18:53.860 --> 00:18:57.060
It's being served from the, the server as
quickly as possible.

00:18:57.060 --> 00:19:02.370
But the user's not seeing anything on the
screen until it finishes buffering, analyzes

00:19:02.370 --> 00:19:06.960
all that content to guess the character set,
which it could possibly guess wrong, and only

00:19:06.960 --> 00:19:08.720
at that point to start rendering content.

00:19:08.720 --> 00:19:16.310
So just specify in your character set and
HTTP response headers, content type text html;charset=

00:19:16.310 --> 00:19:17.310
whatever it might be.

00:19:17.310 --> 00:19:20.510
It allows the browser to more efficiently
parse and render the content as it comes,

00:19:20.510 --> 00:19:22.830
as it arrives on the wire.

00:19:22.830 --> 00:19:27.480
And then finally, minimize DNS lookups is
a rule that we implemented initially based

00:19:27.480 --> 00:19:33.490
on analyzing some pages internally, a long
time ago in fact.

00:19:33.490 --> 00:19:38.810
And what we noticed is that for certain sites
and for certain content, third party content,

00:19:38.810 --> 00:19:45.170
it tended to flag those resources and sort
of say you should, it would flag resources

00:19:45.170 --> 00:19:47.490
that we, we felt we probably shouldn't be
flagging.

00:19:47.490 --> 00:19:52.180
So we spent some time and just recently looked
at the algorithm and tuned that algorithm

00:19:52.180 --> 00:19:58.540
so that it, it doesn't flag, it's basically
more accurate and gives more accurate recommendations.

00:19:58.540 --> 00:20:03.150
So actually we just released Page Speed 1.8,
which has a new implementation to minimize

00:20:03.150 --> 00:20:08.120
DNS lookups that is more accurate and less
likely to give you sort of incorrect suggestions.

00:20:08.120 --> 00:20:09.780
So we're constantly tuning these rules.

00:20:09.780 --> 00:20:15.490
We're constantly adding new rules, both as
we find issues either ourselves or from feedback

00:20:15.490 --> 00:20:16.490
from users.

00:20:16.490 --> 00:20:22.250
So we'll send you a link of the Page Speed
discussion forum at the end of the talk.

00:20:22.250 --> 00:20:25.010
And then, right.

00:20:25.010 --> 00:20:29.110
Yes.

00:20:29.110 --> 00:20:30.340
So, go ahead Richard.

00:20:30.340 --> 00:20:34.270
&gt;&gt;Richard: So, a bunch of new features.

00:20:34.270 --> 00:20:38.920
And today we'll talk a little bit about the,
the export fun, functionality.

00:20:38.920 --> 00:20:43.080
It's basically a beacon that you can send.

00:20:43.080 --> 00:20:46.870
And I'll just go through the demo directly.

00:20:46.870 --> 00:20:52.690
So let's go back here.

00:20:52.690 --> 00:20:57.010
And, so we have, of course [laughs].

00:20:57.010 --> 00:20:58.010
&gt;&gt;Bryan: Right.

00:20:58.010 --> 00:21:00.710
&gt;&gt;Richard: So we have export functionality
that will allow us to export—

00:21:00.710 --> 00:21:01.710
&gt;&gt;Bryan: To our reload.

00:21:01.710 --> 00:21:02.710
[pause]

00:21:02.710 --> 00:21:03.710
&gt;&gt;Richard: Yeah. That's fine.

00:21:03.710 --> 00:21:04.710
&gt;&gt;Bryan: Or switch browsers.

00:21:04.710 --> 00:21:05.710
&gt;&gt;Richard: Yeah.

00:21:05.710 --> 00:21:08.240
Yeah, it doesn't want to start.

00:21:08.240 --> 00:21:14.510
&gt;&gt;Bryan: Switch to Safari.

00:21:14.510 --> 00:21:20.870
Like I said, we're always finding and fixing
problems, so—

00:21:20.870 --> 00:21:21.870
&gt;&gt;Richard: Yeah.

00:21:21.870 --> 00:21:23.890
So basically we have two export functionalities.

00:21:23.890 --> 00:21:27.770
And one we, we send the data back in JSON
format.

00:21:27.770 --> 00:21:31.830
And we also send the scores to www.showslow.com.

00:21:31.830 --> 00:21:35.610
If you want, if you guys want to try it if
you have Page Speed running, just send it

00:21:35.610 --> 00:21:36.610
out.

00:21:36.610 --> 00:21:38.690
You're gonna have a bit of a legal disclaimer.

00:21:38.690 --> 00:21:45.660
We worked with this outside independent developer
who maintains showslow.com.

00:21:45.660 --> 00:21:55.580
And basically, it gives you a way of keeping
track of your Page Speed score across, across

00:21:55.580 --> 00:21:56.580
time.

00:21:56.580 --> 00:22:03.690
And in this case I'm showing an example of
I believe Google.com and YouTube.com and gmail.com

00:22:03.690 --> 00:22:05.910
and measurements that we're sending to Show
Slow.

00:22:05.910 --> 00:22:13.270
So when you're doing the development you change
some of your, you, you adapt to the Web page

00:22:13.270 --> 00:22:20.930
to be more performant and you can track the
performance of your page across, across time.

00:22:20.930 --> 00:22:22.860
So I encourage you to use this.

00:22:22.860 --> 00:22:25.770
It's a great functionality.

00:22:25.770 --> 00:22:32.870
Don't hit showslow.com with too many, too
many beacons at the same time.

00:22:32.870 --> 00:22:33.870
[pause]

00:22:33.870 --> 00:22:36.240
&gt;&gt;Bryan: Do you want to show the site?

00:22:36.240 --> 00:22:37.240
&gt;&gt;Richard: Sure.

00:22:37.240 --> 00:22:38.240
&gt;&gt;Bryan: Do you want to go look at the—

00:22:38.240 --> 00:22:39.240
&gt;&gt;Richard: Oh yeah.

00:22:39.240 --> 00:22:44.030
So the, the actual site here is, here's the
site.

00:22:44.030 --> 00:22:46.760
YSlow is a competitor to Page Speed.

00:22:46.760 --> 00:22:51.620
We encourage you to use as many performance
tools as available as you can, you can try

00:22:51.620 --> 00:22:52.620
out.

00:22:52.620 --> 00:23:01.500
And in this case what we, what we did earlier
is we sent a bunch of requests, too much of

00:23:01.500 --> 00:23:08.500
beacons to showslow.com and recoursed them
right here so you can keep track of them.

00:23:08.500 --> 00:23:13.160
And you can, these are the comparisons.

00:23:13.160 --> 00:23:16.070
So Google.com and YouTube.com are here.

00:23:16.070 --> 00:23:23.610
And you can see over time the, the performance
of your page obviously.

00:23:23.610 --> 00:23:26.190
Okay, so let's go to the next feature.

00:23:26.190 --> 00:23:27.190
Bryan?

00:23:27.190 --> 00:23:33.111
&gt;&gt;Bryan: So, so one of the things we've been
working on over the past year is the Page

00:23:33.111 --> 00:23:34.230
Speed SDK.

00:23:34.230 --> 00:23:35.230
So—

00:23:35.230 --> 00:23:38.620
[pause]

00:23:38.620 --> 00:23:42.360
At the time of our initial launch. Page Speed
was entirely a JavaScript implementation.

00:23:42.360 --> 00:23:44.700
It was pretty, it was tightly coupled to Firefox
APIs.

00:23:44.700 --> 00:23:49.650
And what we found was that we wanted to reuse
the Page Speed logic in other

00:23:49.650 --> 00:23:50.650
environments.

00:23:50.650 --> 00:23:53.940
So one area, one spot, one place early on
that we said we'd like to provide this is

00:23:53.940 --> 00:23:55.160
in Google Webmaster Tools.

00:23:55.160 --> 00:23:57.970
How many, has any, how many are familiar with
Google Webmaster Tools?

00:23:57.970 --> 00:24:00.040
Great.

00:24:00.040 --> 00:24:04.320
So hopefully, maybe you've seen that there
are Page Speed suggestions actually in the

00:24:04.320 --> 00:24:05.850
Webmaster Tools UI, in the lab section.

00:24:05.850 --> 00:24:09.350
And if you haven't used Webmaster Tools before,
I would definitely encourage you to check

00:24:09.350 --> 00:24:10.350
it out.

00:24:10.350 --> 00:24:14.340
It's a, a great resource with lots of good
helpful information for your website, assuming

00:24:14.340 --> 00:24:17.820
you have a website you can sign up and, and
learn about your site on that site.

00:24:17.820 --> 00:24:23.581
So what we did was we, over time, over the
last nine months, we've been porting rules

00:24:23.581 --> 00:24:29.500
from the JavaScripts space to a sort of browser
independent library we've implemented in C++,

00:24:29.500 --> 00:24:35.321
that we're able to reuse in Page Speed for
Firefox, in Webmaster Tools and in other environments

00:24:35.321 --> 00:24:36.330
as well.

00:24:36.330 --> 00:24:41.480
So you can now download that SDK, use it.
We've got a build set up for Linux and for

00:24:41.480 --> 00:24:42.480
Windows.

00:24:42.480 --> 00:24:46.610
And if you want to build on Mac, I don't think
it'll take much work.

00:24:46.610 --> 00:24:50.710
So we, if you figure, if you figure out what
small changes to make to the Mac's file or

00:24:50.710 --> 00:24:55.610
you get that to work we'd definitely, feel
free to share that with us and we'd be more

00:24:55.610 --> 00:24:59.920
than happy to include it in our open source
repository.

00:24:59.920 --> 00:25:05.901
So I mentioned Webmaster Tools. Do you want
to—

00:25:05.901 --> 00:25:06.901
&gt;&gt;Richard: Yeah.

00:25:06.901 --> 00:25:08.090
&gt;&gt;Bryan: —display that.

00:25:08.090 --> 00:25:09.910
This is one of the places where Page Speed
is available today.

00:25:09.910 --> 00:25:11.391
And so here's, here's an example of Webmaster
Tools.

00:25:11.391 --> 00:25:16.910
You can sort of see, right, that this is the
YouTube area of Webmaster Tools, which we,

00:25:16.910 --> 00:25:17.980
we're able to see.

00:25:17.980 --> 00:25:21.870
And it gives you some example feedback for
some pages on your site.

00:25:21.870 --> 00:25:27.120
So you can drill down and for instance see
that these four rules have specific suggestions

00:25:27.120 --> 00:25:28.730
to help you tune and optimize the site.

00:25:28.730 --> 00:25:34.450
Here for example is real combine external
JavaScript, which you can learn more about

00:25:34.450 --> 00:25:37.250
in our documentation Richard showed earlier.

00:25:37.250 --> 00:25:43.010
But the idea is that if you combine these
two resources the browser will be able to

00:25:43.010 --> 00:25:46.700
load the page more efficiently, at least in
some browsers.

00:25:46.700 --> 00:25:51.510
So now not only do you have access to Page
Speed suggestions in the Firefox tool, you

00:25:51.510 --> 00:25:56.350
can just go to this website, Webmaster Tools,
Google Webmaster Tools, and get this information

00:25:56.350 --> 00:26:01.660
without having to install an extension, without
having to run it live on your site.

00:26:01.660 --> 00:26:05.220
This data's just provided for you as part
of the Google Webmaster Tools service.

00:26:05.220 --> 00:26:10.510
Do you want to [inaudible].
[pause]

00:26:10.510 --> 00:26:14.760
So in addition we've actually, so we've worked
with a couple other tools as well.

00:26:14.760 --> 00:26:20.760
This is the Page Speed for Firefox UI. Page
Speed for Firefox is now driven off of the

00:26:20.760 --> 00:26:21.760
Page Speed SDK as well.

00:26:21.760 --> 00:26:29.520
Gomez, a Web performance company we've been
working with, also integrated the Page Speed

00:26:29.520 --> 00:26:32.120
SDK rule set and they're providing that in
their tools.

00:26:32.120 --> 00:26:33.120
This is a pre-release.

00:26:33.120 --> 00:26:36.720
They haven't actually launched this yet, but
this is something that'll be coming soon.

00:26:36.720 --> 00:26:43.460
And then [ coughs ] Steve Souders, excuse
me, Steve Souders built a nice Web page where

00:26:43.460 --> 00:26:49.100
you can take a HAR file, a HAR file's an HTTP
archive file, sort of a new JSON format that

00:26:49.100 --> 00:26:55.480
lets you capture all the information about
a page load, so all the resource content,

00:26:55.480 --> 00:26:57.540
headers, timing information.

00:26:57.540 --> 00:26:58.861
You post that into this Web page.

00:26:58.861 --> 00:27:03.150
It uses the Page Speed SDK and comes back
and gives you a Page Speed score.

00:27:03.150 --> 00:27:05.120
So these are just a few deployments.

00:27:05.120 --> 00:27:07.900
We launched the SDK about a month ago.

00:27:07.900 --> 00:27:08.900
And we've seen great uptake.

00:27:08.900 --> 00:27:13.160
And we, well, let's do a, a little bit of
a deep dive into the SDK now [ clears throat

00:27:13.160 --> 00:27:18.350
 ] to see how you might use it.

00:27:18.350 --> 00:27:21.010
So if you wanted to use the Page Speed SDK
it's, it's pretty straightforward.

00:27:21.010 --> 00:27:25.131
You just need to choose an output formatter,
sort of how do you want to present the results.

00:27:25.131 --> 00:27:30.260
Do you want just plain text, HTML, JSON, et
cetera?

00:27:30.260 --> 00:27:33.890
Pick the Page Speed rules you'd like to run.

00:27:33.890 --> 00:27:35.090
Specify a source of your input data.

00:27:35.090 --> 00:27:39.990
So for instance, HAR or some other input source.
And then just invoke the engine.

00:27:39.990 --> 00:27:44.760
So let's look at a snippet of code that does
that now.

00:27:44.760 --> 00:27:45.760
[pause]

00:27:45.760 --> 00:27:50.030
&gt;&gt;Bryan: So we're choosing to use a text format,
or just something that will print to standard

00:27:50.030 --> 00:27:55.100
out in this case.

00:27:55.100 --> 00:27:58.481
And we're populating the core rule set, the
core Page Speed rule set, so the rules that

00:27:58.481 --> 00:28:00.020
you're familiar with in the tool.

00:28:00.020 --> 00:28:06.510
We're going to use a HAR file as our input.

00:28:06.510 --> 00:28:07.510
So this is an example HAR.

00:28:07.510 --> 00:28:08.510
HAR is a JSON format.

00:28:08.510 --> 00:28:13.460
The dot, dot, dot would be a big blob of content
that contains all the resource bodies and

00:28:13.460 --> 00:28:16.230
other things.

00:28:16.230 --> 00:28:18.520
And then finally we'll invoke the Page Speed
engine.

00:28:18.520 --> 00:28:25.600
So pass at the rules, initialize, compute
and format results.

00:28:25.600 --> 00:28:31.400
And at this point the results will be printed
to the standard out on the, on the, on the

00:28:31.400 --> 00:28:32.400
console.

00:28:32.400 --> 00:28:33.400
So let's look at that actually.

00:28:33.400 --> 00:28:37.090
So one of the tools bundled with the Page
Speed SDK is called HAR to Page Speed, which

00:28:37.090 --> 00:28:41.810
is actually the tool that powers the HAR to
Page Speed website that Steve built.

00:28:41.810 --> 00:28:45.610
And you invoke it, you, essentially the code
we just looked at is the core, the guts, of

00:28:45.610 --> 00:28:46.610
that tool.

00:28:46.610 --> 00:28:51.290
It's got the ability to read a file from a
command line argument.

00:28:51.290 --> 00:28:54.170
But beyond that, I mean, it's essentially
what we just looked at.

00:28:54.170 --> 00:28:56.470
And so you run it like this, very simple,
right.

00:28:56.470 --> 00:28:57.770
Now you're not in a browser anymore.

00:28:57.770 --> 00:29:01.380
You're on the command line, different, different
environment.

00:29:01.380 --> 00:29:07.060
And you're able to get that same information,
those same results, here on the console easily

00:29:07.060 --> 00:29:08.060
and quickly.

00:29:08.060 --> 00:29:14.550
And so potentially you could write an automation
tool that you use something like this to automatically

00:29:14.550 --> 00:29:20.160
analyze HAR files over time, all without having
to stand up a browser and run Page Speed and

00:29:20.160 --> 00:29:21.550
that sort of thing.

00:29:21.550 --> 00:29:27.210
So we can learn specifically what we can do
to speed up the Web page.

00:29:27.210 --> 00:29:30.020
So that's the Page Speed SDK.

00:29:30.020 --> 00:29:33.580
Now let's look at another deployment of Page
Speed technology that we've been working on.

00:29:33.580 --> 00:29:36.460
It's sort of, it's very early in the lifecycle,
the project.

00:29:36.460 --> 00:29:41.100
But what we decided we wanted to do is try
to shift as much as possible from telling

00:29:41.100 --> 00:29:45.870
Web developers what they can do to speed up
their site, and just actually try to do that

00:29:45.870 --> 00:29:46.870
for them.

00:29:46.870 --> 00:29:51.560
So essentially, so what, what we decided to
do was implement an Apache module that en,

00:29:51.560 --> 00:29:54.140
encapsulates a lot of these Page Speed suggestions.

00:29:54.140 --> 00:30:00.640
So all you have to do is install this module
on your Apache server and then you don't have

00:30:00.640 --> 00:30:02.010
to think about the problem anymore ideally.

00:30:02.010 --> 00:30:08.650
We just automatically optimize the images,
the HTML, the CSS, the JavaScript, combine

00:30:08.650 --> 00:30:15.490
resources, extend caching lifetimes using
a technique called resource fingerprinting,

00:30:15.490 --> 00:30:17.610
which is talked about in our documentation
as well.

00:30:17.610 --> 00:30:21.460
All these things are captured automatically
so you don't have to go to the trouble of

00:30:21.460 --> 00:30:28.120
implementing them, or Web content hosters
don't have to do that, and they can just sort

00:30:28.120 --> 00:30:30.030
of have this applied automatically.

00:30:30.030 --> 00:30:32.590
So this project is open source as well.

00:30:32.590 --> 00:30:35.460
Like I said, it's early in the development
cycle so it's not ready for use yet.

00:30:35.460 --> 00:30:39.960
But if you're interested, take a look at our
code.google.com repository.

00:30:39.960 --> 00:30:44.790
&gt;&gt;: [Inaudible] does it insert semicolons?

00:30:44.790 --> 00:30:46.460
&gt;&gt;Richard: So the question is—

00:30:46.460 --> 00:30:49.120
&gt;&gt;Bryan: Does it insert semicolons at the
end of lines?

00:30:49.120 --> 00:30:50.120
&gt;&gt;: Yes.

00:30:50.120 --> 00:30:55.960
&gt;&gt;Bryan: I don't know actually.

00:30:55.960 --> 00:30:58.611
I want to say, so the—

00:30:58.611 --> 00:31:01.130
&gt;&gt;: [Inaudible]. Does it preserve the new
lines, or what?

00:31:01.130 --> 00:31:04.110
&gt;&gt;Bryan: I actually don't think it preserves
the new lines, so it would need to insert

00:31:04.110 --> 00:31:05.110
semicolons.

00:31:05.110 --> 00:31:08.300
So, so that's actually a good example of a
case where—

00:31:08.300 --> 00:31:10.010
&gt;&gt;Richard: If you can repeat the question,
because—

00:31:10.010 --> 00:31:11.010
&gt;&gt;Bryan: Yeah.

00:31:11.010 --> 00:31:16.391
So, so he asked if it retains semicolons at
the end of new lines.

00:31:16.391 --> 00:31:21.510
'Cause one of the things JavaScript minifiers
do is they tend to remove new, new lines.

00:31:21.510 --> 00:31:24.290
JavaScript new lines implicitly add a semicolon.

00:31:24.290 --> 00:31:29.220
So if you just combine the two lines you can
end up with JavaScript that breaks, I want

00:31:29.220 --> 00:31:31.480
to say we do fix that, but I'd have to double
check.

00:31:31.480 --> 00:31:36.720
In any case, if, if you run into a problem
do, you can actually go to the same URL and

00:31:36.720 --> 00:31:40.880
file an issue or post it on our discussion
forum.

00:31:40.880 --> 00:31:45.130
And we'd be happy, we're always happy to accept
code patches if you're interested in, in submitting

00:31:45.130 --> 00:31:50.290
patches or we'll try to fix the issue ourselves
for a subsequent release.

00:31:50.290 --> 00:31:57.410
So here's an example of as the HTML flows
through Apache, sort of coming in unoptimized

00:31:57.410 --> 00:32:04.570
like this perhaps, we'll parse that HTML and
perform some optimizations.

00:32:04.570 --> 00:32:07.390
And what you end up with is HTML that's a
little more minified and it's serving fewer

00:32:07.390 --> 00:32:08.390
resources.

00:32:08.390 --> 00:32:13.010
So what we've done here is we've combined
the two CSS resources, we've combined the

00:32:13.010 --> 00:32:14.410
two JavaScript resources.

00:32:14.410 --> 00:32:19.420
What you can't see here is we would have also
extended caching lifetimes and removed unnecessary

00:32:19.420 --> 00:32:20.770
white space along the way.

00:32:20.770 --> 00:32:23.770
&gt;&gt;Richard: So, before you move on why don't
you talk a little bit about the extension

00:32:23.770 --> 00:32:25.650
of caching lifetime because it's quite interesting.

00:32:25.650 --> 00:32:26.650
&gt;&gt;Bryan: Oh sure.

00:32:26.650 --> 00:32:32.810
So, one thing that we'll often find is that
caching lifetimes are either unspecified or

00:32:32.810 --> 00:32:36.150
set sort of not very aggressively, on some
sites anyway.

00:32:36.150 --> 00:32:42.340
And developers are sometimes concerned that
well, if I extend it for a week or a year,

00:32:42.340 --> 00:32:43.900
what if I need to change that resource?

00:32:43.900 --> 00:32:52.600
And so what we recommend is a technique we
call fingerprinting, URL fingerprinting essentially,

00:32:52.600 --> 00:32:56.390
which looks at the actual content of the resource
and embeds that fingerprint in the URL.

00:32:56.390 --> 00:32:58.060
So what you're looking at here is /cache/someblob.

00:32:58.060 --> 00:33:02.280
That makes no sense, right, .css.

00:33:02.280 --> 00:33:08.910
And what that actually is an, part of an md5sum
of the concatenation of a.b, a.css and b.css.

00:33:08.910 --> 00:33:13.920
So now because we've sort of captured a fingerprint
of the actual contents in the URL, we can

00:33:13.920 --> 00:33:15.660
use a really aggressive caching lifetime.

00:33:15.660 --> 00:33:18.310
We can set this thing to not expire for a
year.

00:33:18.310 --> 00:33:22.170
And then if it does happen to change, well
the contents will change, the fingerprint

00:33:22.170 --> 00:33:25.280
will change and in turn the URL will change,
right.

00:33:25.280 --> 00:33:29.230
So the browser will know, "Oh, I have to go
fetch this other resource which has a different

00:33:29.230 --> 00:33:31.370
URL that's not in my cache."

00:33:31.370 --> 00:33:37.620
So this lets you sort of, instead of specifying
how long the browser, you basically can expire

00:33:37.620 --> 00:33:38.970
the resource when it expires.

00:33:38.970 --> 00:33:44.430
Instead of having to wait for that expiration
time you just change the URL and the browser

00:33:44.430 --> 00:33:47.310
will download it as soon as the URL changes.

00:33:47.310 --> 00:33:48.310
So that's a technique we'll do.

00:33:48.310 --> 00:33:49.310
It, it's a bit of a fragile technique.

00:33:49.310 --> 00:33:54.180
You have to sort of match up the content signatures
with actually URLs in the content, which you

00:33:54.180 --> 00:34:01.820
can do by hand or if you use them mod Page
Speed, we'll do that for you automatically.

00:34:01.820 --> 00:34:02.820
So that's mod Page Speed.

00:34:02.820 --> 00:34:10.129
&gt;&gt;Richard: So, so Page Speed came out of Google
labs.

00:34:10.129 --> 00:34:14.169
We, we spent a lot of time trying to understand
optimization of UI.

00:34:14.169 --> 00:34:18.829
At Google we, we built a lot of these rules
internally.

00:34:18.829 --> 00:34:25.169
And after we, we released it as open source
about a year ago just like Bryan said, we

00:34:25.169 --> 00:34:26.990
got a lot of good feedback.

00:34:26.990 --> 00:34:34.249
And one of the, one of the most important
pieces of feedback is a website is not usually

00:34:34.249 --> 00:34:38.029
coming from one, one property.

00:34:38.029 --> 00:34:43.349
There's, there's content that, for example
for a publisher there's a content, there's

00:34:43.349 --> 00:34:48.599
content that the reporter's writing, there's
the ad systems that are, that are, that you're

00:34:48.599 --> 00:34:53.940
shipping so that you can monetize your, your,
your, your pages.

00:34:53.940 --> 00:35:00.299
And there's also tracking analytics that you
need to, so you can keep track of measurements

00:35:00.299 --> 00:35:02.599
and all the metrics that you care about.

00:35:02.599 --> 00:35:06.329
So we spent a lot of time trying to understand
how to adjust this.

00:35:06.329 --> 00:35:12.490
And our approach is, is to try to give as
much information back to the developer as

00:35:12.490 --> 00:35:14.300
possible.

00:35:14.300 --> 00:35:21.430
And to do that we basically started focusing
as, as a first step in terms of like third

00:35:21.430 --> 00:35:23.170
party content on ads and trackers.

00:35:23.170 --> 00:35:26.119
And I will show the demo.

00:35:26.119 --> 00:35:27.369
[pause]

00:35:27.369 --> 00:35:30.940
&gt;&gt;Richard: So this is the YouTube page.

00:35:30.940 --> 00:35:32.749
And I'm gonna start Firebug.

00:35:32.749 --> 00:35:34.599
This is Page Speed.

00:35:34.599 --> 00:35:40.619
And there is a filter option with these, these
options.

00:35:40.619 --> 00:35:46.039
The first one is analyze ads only, analyze
trackers only, content only and the complete

00:35:46.039 --> 00:35:47.039
page.

00:35:47.039 --> 00:35:50.350
The complete page is what you're used to when
you run Page Speed for tho, for those of you

00:35:50.350 --> 00:35:52.749
that have run it.

00:35:52.749 --> 00:35:58.180
And now what we're going to do is we're going
to filter only ads and try to, and try to

00:35:58.180 --> 00:36:02.890
see what the, what we're gonna get in terms
of that.

00:36:02.890 --> 00:36:05.410
So I’m going to, first going to analyze
the performance for the complete page.

00:36:05.410 --> 00:36:09.849
I get a bunch of rules.

00:36:09.849 --> 00:36:17.250
Obviously there, there's a lot of recommendations
for just about every rule.

00:36:17.250 --> 00:36:20.109
And then I'm gonna analyze the ads only.

00:36:20.109 --> 00:36:23.319
All right, refresh the analysis.

00:36:23.319 --> 00:36:26.749
You can see like all these rules are not applicable
anymore.

00:36:26.749 --> 00:36:33.480
And what we're, what we're looking at is specifically
the ad content.

00:36:33.480 --> 00:36:39.589
And so we have a number of filters for, for
what we think are ads.

00:36:39.589 --> 00:36:43.391
And by the way all the, all the filters are
open source.

00:36:43.391 --> 00:36:46.400
So if you have suggestions for adding more.

00:36:46.400 --> 00:36:51.029
We know today we're not very, we don't have
a lot of coverage internationally.

00:36:51.029 --> 00:36:59.799
So it will be good to have more international
coverage for ads, systems, ads that we don't

00:36:59.799 --> 00:37:03.869
capture today.

00:37:03.869 --> 00:37:07.839
And you'll see like double-click is being
served on YouTube, but obviously it's a, it's

00:37:07.839 --> 00:37:09.619
a, it's an ad.

00:37:09.619 --> 00:37:12.710
And we're going to give you recommendations
about this ad.

00:37:12.710 --> 00:37:19.930
The same thing happens for analytics, although
I don't believe that YouTube has analytics

00:37:19.930 --> 00:37:22.569
on their, on their pages.

00:37:22.569 --> 00:37:30.359
So what this will give you is enough information
to understand how third party content is affecting

00:37:30.359 --> 00:37:31.829
the performance of your pages.

00:37:31.829 --> 00:37:33.950
We're going to extend it to gadgets.

00:37:33.950 --> 00:37:40.089
We believe gadgets are becoming a big, a big
part of every Web page and we, we think it's

00:37:40.089 --> 00:37:46.299
important for every Web developer to actually
understand the impact of all the content that

00:37:46.299 --> 00:37:51.329
they have, and understand the impact of things
that they can, they have control over versus

00:37:51.329 --> 00:37:55.000
things they don't have control over, and make
the right decision.

00:37:55.000 --> 00:38:01.170
And every, every development is a, is a, is
a balance between adding more features and

00:38:01.170 --> 00:38:04.390
for thinking about speed as a feature.

00:38:04.390 --> 00:38:08.999
And we're sure, we're sure you can find the
balance there.

00:38:08.999 --> 00:38:14.770
With, with this we hope that giving all this
information will, will also spur third party

00:38:14.770 --> 00:38:20.289
content to actually try to make sure that
they are optimum so that when they're served

00:38:20.289 --> 00:38:26.509
out of your Web pages they, they are fast
and performant.

00:38:26.509 --> 00:38:30.430
&gt;&gt;Bryan: And this is a feature we just added
in—

00:38:30.430 --> 00:38:32.430
&gt;&gt;Richard : So, we just released it this morning.

00:38:32.430 --> 00:38:33.430
&gt;&gt;Bryan: Yeah.

00:38:33.430 --> 00:38:36.839
&gt;&gt;Richard: We just pushed it out, it's in
beta, ten percent of—

00:38:36.839 --> 00:38:37.839
&gt;&gt;Bryan: Yeah.

00:38:37.839 --> 00:38:40.270
&gt;&gt;Richard: —all of our users are getting
it—

00:38:40.270 --> 00:38:41.270
&gt;&gt;Bryan: [Inaudible].

00:38:41.270 --> 00:38:42.270
&gt;&gt;Richard: —as of this morning.

00:38:42.270 --> 00:38:44.259
&gt;&gt;Bryan: You may get it automatically if you
have Page Speed installed, and if not you

00:38:44.259 --> 00:38:47.789
can go to Page Speed download page and download
the Page Speed beta and you'll get that feature

00:38:47.789 --> 00:38:49.690
as part of that download.

00:38:49.690 --> 00:38:51.329
&gt;&gt;Richard: And, so it's a new feature.

00:38:51.329 --> 00:38:57.770
So give us feedback online on the discussion
list, it would be great.

00:38:57.770 --> 00:39:01.420
And obviously I just covered this.

00:39:01.420 --> 00:39:02.420
[pause]

00:39:02.420 --> 00:39:03.529
Future work.

00:39:03.529 --> 00:39:04.950
&gt;&gt;Bryan: Yep.

00:39:04.950 --> 00:39:09.799
So looking forward, I'll talk about a few
of the rules that we're thinking about adding

00:39:09.799 --> 00:39:11.589
to the rule set over the coming months.

00:39:11.589 --> 00:39:13.960
I'll talk about three rules.

00:39:13.960 --> 00:39:16.910
The first is to recommend using chunked encoding.

00:39:16.910 --> 00:39:21.339
So chunked encoding is a technique that allows
you to send a page in pieces as opposed to

00:39:21.339 --> 00:39:23.829
sending the whole thing after generating the
whole thing.

00:39:23.829 --> 00:39:28.289
And this actually relates to that bit I talked
about at the beginning where server latency,

00:39:28.289 --> 00:39:33.579
what do we call it, server processing time
can add to the page load.

00:39:33.579 --> 00:39:39.380
Often times if you use chunked encoding, you'll
mitigate or even eliminate that, that, as

00:39:39.380 --> 00:39:40.480
far as the user's concerned.

00:39:40.480 --> 00:39:46.319
What it lets you do is essentially send the,
so the assumption is that most pages that

00:39:46.319 --> 00:39:53.480
are dynamic, search results pages, user customized
pages like email websites, etcetera, have

00:39:53.480 --> 00:39:59.030
sort of a static bit of content at the head
of the page that's, doesn't take anything

00:39:59.030 --> 00:40:00.030
to compute it.

00:40:00.030 --> 00:40:01.309
It's essentially just a static string.

00:40:01.309 --> 00:40:05.890
And the idea is that you send that as the
first chunk of the response.

00:40:05.890 --> 00:40:09.190
While you're doing that you start computing
the actual dynamic data the user requested.

00:40:09.190 --> 00:40:14.310
And what you have is in parallel you're sending
that static data on the wire while you're

00:40:14.310 --> 00:40:16.019
computing the user's result.

00:40:16.019 --> 00:40:19.710
And then as soon as that dynamic content is
generated and ready to serve, you serve it

00:40:19.710 --> 00:40:21.049
right behind as a separate chunk.

00:40:21.049 --> 00:40:25.140
And as far as the, depending on the user's
connection, it may just look like a, a, a,

00:40:25.140 --> 00:40:29.140
a consistent stream of data that actually
was never interrupted.

00:40:29.140 --> 00:40:34.230
So chunked encoding, so I should say the default
behavior in HTTP is to specify the length

00:40:34.230 --> 00:40:36.190
through response in the response headers.

00:40:36.190 --> 00:40:40.019
The response headers come before the entire
response body.

00:40:40.019 --> 00:40:44.289
So by default, you have to wait and buffer
the entire response, the entire dynamic response,

00:40:44.289 --> 00:40:46.700
before you start sending any of it.

00:40:46.700 --> 00:40:48.819
So chunked encoding lets you do this in chunks.

00:40:48.819 --> 00:40:52.499
Send that static header first and the, the
dynamic body afterwards.

00:40:52.499 --> 00:40:56.780
And what we see is that this has been a big
win for Google properties like search and

00:40:56.780 --> 00:41:01.299
calendar that have fit that constraint of
dynamic response with a static header.

00:41:01.299 --> 00:41:06.950
And so, whoops, so what we'll see oftentimes
is that before implementing this kind of technique

00:41:06.950 --> 00:41:12.210
you'll have this HTTP waterfall chart that
shows the timeline of the resources being

00:41:12.210 --> 00:41:13.210
downloaded.

00:41:13.210 --> 00:41:14.210
It looks something like this.

00:41:14.210 --> 00:41:17.730
HTML you'll take, you'll spend a lot of time
downloading that HTML resource.

00:41:17.730 --> 00:41:21.280
Towards the end of that download you'll start
downloading the sub resources declared in

00:41:21.280 --> 00:41:22.339
that content.

00:41:22.339 --> 00:41:27.630
And once you enable chunking what you get
is, so one nice side effect of, of this is

00:41:27.630 --> 00:41:33.019
that external JavaScript and CSS are oftentimes
declared in that static chunk.

00:41:33.019 --> 00:41:38.349
So by sending that static chunk much sooner
you pull in those sub resource fetches cons,

00:41:38.349 --> 00:41:42.831
considerably and allow the browser to start
downloading, parsing and applying those resources

00:41:42.831 --> 00:41:44.299
much earlier in the page load.

00:41:44.299 --> 00:41:48.869
So this is a useful technique for dynamic
responses.

00:41:48.869 --> 00:41:52.579
So second, minimize the size of early loaded
resources.

00:41:52.579 --> 00:41:58.470
And the idea here is that browsers have become
much more efficient at downloading resources,

00:41:58.470 --> 00:41:59.579
specifically JavaScript.

00:41:59.579 --> 00:42:04.119
A year ago, most browsers out there would
download JavaScript serially.

00:42:04.119 --> 00:42:07.849
They'd sort of, if you had ten JavaScript
files declared in a row it would download

00:42:07.849 --> 00:42:11.539
one, wait for it to finish, parse and execute
it, move on, dowload the next one.

00:42:11.539 --> 00:42:14.650
And you saw this stair step in the waterfall
chart.

00:42:14.650 --> 00:42:17.680
So what we're seeing now with the modern browsers,
all the modern browsers, all the major browser

00:42:17.680 --> 00:42:22.450
vendors have implemented this, is that you
get parallelized JavaScript fetches much more

00:42:22.450 --> 00:42:24.359
efficient use of the network.

00:42:24.359 --> 00:42:30.260
But regardless, the browser can't show anything
til, to the user until all of those resources

00:42:30.260 --> 00:42:34.670
have been downloaded and all of the JavaScript
has been parsed and executed, CSS as well.

00:42:34.670 --> 00:42:38.490
So the less you serve up front the less you
serve in the head of the page, and the more

00:42:38.490 --> 00:42:42.300
you can defer to later in the page until after
content has been rendered.

00:42:42.300 --> 00:42:46.920
The faster that initial flash of content,
that initial sort of time to first paint will

00:42:46.920 --> 00:42:50.210
be in the fast, the less time the user's sort
of sitting there staring, waiting at a blank

00:42:50.210 --> 00:42:51.230
screen.

00:42:51.230 --> 00:42:54.970
So you can actually accomplish this technique
today using two of our rules in the Page Speed

00:42:54.970 --> 00:42:56.749
rule set in Firefox.

00:42:56.749 --> 00:43:01.170
Remove unused CSS and defer loading of JavaScript,
which will help you to understand which JavaScript

00:43:01.170 --> 00:43:07.380
and CSS are actually used on your page and
which, which are, are not until later.

00:43:07.380 --> 00:43:10.420
We're gonna sort of, what this rule will do
is it will streamline that process a little

00:43:10.420 --> 00:43:14.869
bit to make it a little easier to apply the
technique.

00:43:14.869 --> 00:43:18.730
And then finally, minimi, minimize fetches
from JavaScript.

00:43:18.730 --> 00:43:22.589
So as browsers have become more efficient
in the last 12 months and they've parallelized

00:43:22.589 --> 00:43:25.470
JavaScript fetches.

00:43:25.470 --> 00:43:31.549
What we've seen is that JavaScript that's
fetched using JavaScript still gets serialized.

00:43:31.549 --> 00:43:38.119
So we pay a penalty for fetching JavaScript,
from JavaScript.

00:43:38.119 --> 00:43:41.320
So, so sometimes JavaScript libraries, you'll
see this in a lot of actually major websites,

00:43:41.320 --> 00:43:43.280
will do something like this.

00:43:43.280 --> 00:43:46.640
Very straightforward, write a couple script
tags.

00:43:46.640 --> 00:43:51.829
And then they'll use some JavaScript library
to load a couple of these JavaScript resources.

00:43:51.829 --> 00:43:54.509
It seems pretty reasonable.

00:43:54.509 --> 00:43:57.400
But what this does in the modern browsers,
traditionally this actually had no latency

00:43:57.400 --> 00:43:58.400
impact.

00:43:58.400 --> 00:44:00.930
A year ago, most browsers it didn't make a
difference because it was just gonna be fetched

00:44:00.930 --> 00:44:06.420
serially whether you fetched it using JavaScript
or whether you fetched it using a script tag.

00:44:06.420 --> 00:44:10.829
And so what happens here is that the browser
uses sort of a, a speculative fetcher.

00:44:10.829 --> 00:44:15.249
So it goes and parses ahead of the renderer,
looks for tags and says, "Oh, I found a script

00:44:15.249 --> 00:44:17.460
tag. Okay foo.js, I'll fetch that".

00:44:17.460 --> 00:44:18.910
Parses ahead, parses ahead.

00:44:18.910 --> 00:44:19.910
Hits a script tag.

00:44:19.910 --> 00:44:23.630
It says, "Well I'm just a speculative fetcher,
I don't actually execute JavaScript. So I

00:44:23.630 --> 00:44:26.680
can't do anything about this one. Skip it."

00:44:26.680 --> 00:44:30.549
Then eventually the renderer receives foo.jss,
js, common.js and effects.js.

00:44:30.549 --> 00:44:35.869
Parses and executes those and says, "Okay,
next I'll execute that script block," because

00:44:35.869 --> 00:44:38.239
it executes scripts in order.

00:44:38.239 --> 00:44:41.859
And what this ends up looking like is that
stair stepping behavior that you saw in older

00:44:41.859 --> 00:44:45.069
browsers, the serialized JavaScript fetches.

00:44:45.069 --> 00:44:50.069
So if you've got JavaScript fetched in this
way on your page, and it's easy to just turn

00:44:50.069 --> 00:44:56.989
them into script tags, you'll go from that
serialized JavaScript fetching to parallel

00:44:56.989 --> 00:45:04.579
JavaScript fetching, making your page, display
its contents sooner than it otherwise would.

00:45:04.579 --> 00:45:07.119
So then finally, I'll let Richard talk.

00:45:07.119 --> 00:45:13.069
&gt;&gt;Richard: So a lot of the development for
Page Speed happened early on when we didn't

00:45:13.069 --> 00:45:16.109
have Chrome, we didn't have Developer Tools.

00:45:16.109 --> 00:45:21.170
And the past year we've been focused a lot
on the rules and the, the correctness of the

00:45:21.170 --> 00:45:27.470
rules, and building that, that, the SDK.

00:45:27.470 --> 00:45:32.920
We're going to be releasing a version of Page
Speed for Chrome with integration with Chrome

00:45:32.920 --> 00:45:34.380
Developer Tools.

00:45:34.380 --> 00:45:39.619
And we're hoping to get it at the end, by
the end of this year.

00:45:39.619 --> 00:45:44.660
We know it's a, it's a, it's a very high request
by everybody.

00:45:44.660 --> 00:45:48.059
We apologize for like not having been able
to do it earlier.

00:45:48.059 --> 00:45:53.500
But Developer Tools are now such a complete
developer environment for us that we, we're

00:45:53.500 --> 00:46:03.079
going to be landing in the, landing in Chrome
this year.

00:46:03.079 --> 00:46:05.970
So where can you get more information?

00:46:05.970 --> 00:46:06.970
A bunch of places.

00:46:06.970 --> 00:46:13.869
So we have a very developed website thanks
to our wonderful tech writer.

00:46:13.869 --> 00:46:17.329
So everything is at code.google.com/speed/page-speed.

00:46:17.329 --> 00:46:22.670
We, we have -- all our development is an open
source.

00:46:22.670 --> 00:46:28.089
We don't do any developments in the sandbox
somewhere.

00:46:28.089 --> 00:46:35.670
Do contribute, if you'd like to contribute
there's also, bug, just asking for features

00:46:35.670 --> 00:46:37.769
and bugs is great.

00:46:37.769 --> 00:46:44.010
And it's a pretty active mailing list that
you can subscribe to and help us make the

00:46:44.010 --> 00:46:45.010
product better.

00:46:45.010 --> 00:46:50.630
And tell us about success stories using Page
Speed or problems of how you use Page Speed

00:46:50.630 --> 00:46:55.999
and how it didn't perform so we can make it
better.

00:46:55.999 --> 00:46:57.900
Thank you.

00:46:57.900 --> 00:47:02.200
So let's see if we have anything on, on moderator
to cover.

00:47:02.200 --> 00:47:05.210
&gt;&gt;Bryan: And if you have questions.

00:47:05.210 --> 00:47:07.259
&gt;&gt;Richard: And if you have questions, please
the microphone is there.

00:47:07.259 --> 00:47:08.259
[ Audience clapping ]

00:47:08.259 --> 00:47:08.262
&gt;&gt;Richard: Thank you.

