WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.110
JAMES HAWKINS: My name
is James Hawkins.

00:00:03.110 --> 00:00:05.510
I'm the tech lead of the Chrome
team in Los Angeles.

00:00:05.510 --> 00:00:08.930
And for the past year, we've
been working very closely with

00:00:08.930 --> 00:00:12.590
the Google+ Photos team on a new
product that's the Google+

00:00:12.590 --> 00:00:14.090
Photos Chrome app.

00:00:14.090 --> 00:00:17.240
So this is a Chrome
packaged app.

00:00:17.240 --> 00:00:20.120
And if you'll remember, packaged
apps were announced a

00:00:20.120 --> 00:00:21.540
little over a year ago.

00:00:21.540 --> 00:00:27.870
And this is the key piece of
Chrome's app platform.

00:00:27.870 --> 00:00:30.880
Packaged apps give you the
ability to have extended

00:00:30.880 --> 00:00:32.520
permissions, you can do
a little bit more.

00:00:32.520 --> 00:00:35.920
You can have a more native look
and feel with your app.

00:00:35.920 --> 00:00:37.420
It's a step above what
you can do with the

00:00:37.420 --> 00:00:39.140
web platform today.

00:00:39.140 --> 00:00:42.330
So we're going to talk about
Google+ Photos Chrome app.

00:00:42.330 --> 00:00:43.450
Actually, instead of
talking about it,

00:00:43.450 --> 00:00:45.160
let's cut to the demo.

00:00:58.030 --> 00:01:01.240
So this is Google+ Photos,
the Chrome app.

00:01:01.240 --> 00:01:02.980
This is my personal account.

00:01:02.980 --> 00:01:05.720
I've got all my photos
loaded up into it.

00:01:05.720 --> 00:01:07.450
We're doing some
nice scrolling.

00:01:07.450 --> 00:01:09.500
And if you note, I'm on
a Pixel right here.

00:01:09.500 --> 00:01:11.850
So we obviously have touchscreen
capabilities to do

00:01:11.850 --> 00:01:14.170
scrolling with this.

00:01:14.170 --> 00:01:16.230
OK, so we're viewing
some photos.

00:01:16.230 --> 00:01:19.480
Let's say I want to go in and
check out a particular photo.

00:01:19.480 --> 00:01:21.770
All right, I've got this photo,
and I've got my nice

00:01:21.770 --> 00:01:24.620
information, my tags,
and details.

00:01:24.620 --> 00:01:27.280
Very neat.

00:01:27.280 --> 00:01:30.060
But I just went and used my
camera and took a bunch of

00:01:30.060 --> 00:01:32.510
pictures, and I've got
it on an SD card.

00:01:32.510 --> 00:01:34.030
I'd like to upload these
to the Cloud.

00:01:34.030 --> 00:01:34.960
I want to share with
my friends.

00:01:34.960 --> 00:01:36.210
So let's go ahead and do that.

00:01:44.190 --> 00:01:45.440
Close this.

00:01:48.010 --> 00:01:49.600
So here we go.

00:01:49.600 --> 00:01:51.260
The app was already open.

00:01:51.260 --> 00:01:53.360
And it's already started
importing photos, and it's

00:01:53.360 --> 00:01:55.490
going to start uploading them.

00:01:55.490 --> 00:01:59.960
We can view the ones that
are on this SD card.

00:01:59.960 --> 00:02:00.380
Cool.

00:02:00.380 --> 00:02:02.110
So these are the pictures
that I just took.

00:02:02.110 --> 00:02:05.080
Got a little notification that
we had some photos copied, and

00:02:05.080 --> 00:02:06.330
they're being uploaded
right now.

00:02:10.110 --> 00:02:12.130
We got a notification that we're
finding the best photos,

00:02:12.130 --> 00:02:13.620
and there we go.

00:02:13.620 --> 00:02:15.700
What you just saw is something
that you heard

00:02:15.700 --> 00:02:17.150
about in the keynote.

00:02:17.150 --> 00:02:18.530
This is autocuration.

00:02:18.530 --> 00:02:22.110
So in the back end, Google said,
we're looking at your

00:02:22.110 --> 00:02:24.250
photos, we want to see what
are the best photos of the

00:02:24.250 --> 00:02:25.380
ones you just took.

00:02:25.380 --> 00:02:29.090
Let's make it very simple for
you to share the best photos

00:02:29.090 --> 00:02:30.810
that you have with your
friends, your

00:02:30.810 --> 00:02:32.250
families, et cetera.

00:02:32.250 --> 00:02:35.340
For example, this photo
has been deemed to be

00:02:35.340 --> 00:02:36.680
underexposed.

00:02:36.680 --> 00:02:37.030
Cool.

00:02:37.030 --> 00:02:37.290
All right.

00:02:37.290 --> 00:02:38.400
That's fine.

00:02:38.400 --> 00:02:39.220
I'm not too picky.

00:02:39.220 --> 00:02:40.700
I just want the best
photos to go up.

00:02:40.700 --> 00:02:42.980
So we want to share these.

00:02:53.720 --> 00:02:53.985
Cool.

00:02:53.985 --> 00:02:55.230
I've shared it with my family.

00:02:55.230 --> 00:02:56.480
Cool new photos.

00:03:08.440 --> 00:03:12.250
And so these are the photos
that I just shared.

00:03:12.250 --> 00:03:13.500
We can change the name.

00:03:19.960 --> 00:03:22.780
No, it's '13.

00:03:22.780 --> 00:03:24.730
It is early after all.

00:03:24.730 --> 00:03:26.890
Cool.

00:03:26.890 --> 00:03:29.280
So this is Google+ Photos.

00:03:29.280 --> 00:03:31.360
You've got the autocuration
magic behind the scenes.

00:03:31.360 --> 00:03:33.460
You've got a very
slick interface.

00:03:33.460 --> 00:03:36.840
Very fast viewing of
all your photos,

00:03:36.840 --> 00:03:38.950
just really nice scrolling.

00:03:38.950 --> 00:03:42.360
And we're going to talk a bit
today about what it took to

00:03:42.360 --> 00:03:44.320
develop this product
as a Chrome

00:03:44.320 --> 00:03:45.570
packaged app on the platform.

00:03:49.432 --> 00:03:51.830
AUDIENCE: Is it available
in the marketplace?

00:03:51.830 --> 00:03:53.170
JAMES HAWKINS: This is
not available yet.

00:03:53.170 --> 00:03:54.420
It'll be available soon.

00:03:56.950 --> 00:03:59.520
So we started developing
this product with a

00:03:59.520 --> 00:04:00.540
set of goals in mind.

00:04:00.540 --> 00:04:03.220
What did we want
to accomplish?

00:04:03.220 --> 00:04:06.930
When we started development, the
only way to view photos in

00:04:06.930 --> 00:04:10.390
Chrome OS was through the file
manager, and even then, that

00:04:10.390 --> 00:04:11.810
was not the best experience.

00:04:11.810 --> 00:04:13.720
You could do some
minimal editing.

00:04:13.720 --> 00:04:15.830
You couldn't really
share very easily.

00:04:15.830 --> 00:04:19.079
And the viewing experience
was just a stopgap.

00:04:19.079 --> 00:04:20.790
That's not to say,
it's not good.

00:04:20.790 --> 00:04:22.240
But we wanted to do
something better.

00:04:22.240 --> 00:04:24.170
We wanted a better photos
experience for ChromeOS.

00:04:27.160 --> 00:04:30.930
In addition, we wanted a place
where the Google+ Photos team

00:04:30.930 --> 00:04:34.970
could experiment with new UI,
new back end functionality

00:04:34.970 --> 00:04:37.440
like we're talking about
with autocuration.

00:04:37.440 --> 00:04:42.020
In fact, autocuration was not
available to the public in the

00:04:42.020 --> 00:04:45.660
Google+ desktop until we just
announced it at I/O

00:04:45.660 --> 00:04:46.990
a couple days ago.

00:04:46.990 --> 00:04:50.170
And so this product was the
only place where the

00:04:50.170 --> 00:04:53.950
autocuration team could see
autocuration live, see how it

00:04:53.950 --> 00:04:56.860
worked out, get a lot of
feedback on the feature.

00:04:56.860 --> 00:04:59.310
And so this is going to continue
to be one of the

00:04:59.310 --> 00:05:02.140
places where that feature
development happens like

00:05:02.140 --> 00:05:03.390
sandboxed, if you will.

00:05:06.160 --> 00:05:08.980
And coming from the Chrome team
side of things, we wanted

00:05:08.980 --> 00:05:12.500
to make sure that the platform
had everything that we needed

00:05:12.500 --> 00:05:15.500
in order to be very successful
and very easy for people to

00:05:15.500 --> 00:05:16.420
develop apps.

00:05:16.420 --> 00:05:17.170
What's missing?

00:05:17.170 --> 00:05:18.170
Could we identify it?

00:05:18.170 --> 00:05:20.580
What are the bugs?

00:05:20.580 --> 00:05:23.070
It's a very nascent platform,
and a lot of the API's that

00:05:23.070 --> 00:05:26.430
are being developed are even,
right now, in development.

00:05:26.430 --> 00:05:29.150
And we wanted to test them
out, have a user for the

00:05:29.150 --> 00:05:33.260
platform instead of giving it to
you guys, and you guys have

00:05:33.260 --> 00:05:34.210
to cut your teeth on it.

00:05:34.210 --> 00:05:35.870
Which is not the best
experience.

00:05:35.870 --> 00:05:41.340
We wanted to do that ourselves
to spare you guys some pain.

00:05:41.340 --> 00:05:44.020
And as a part of that, as well,
we are Chrome developers

00:05:44.020 --> 00:05:46.240
in addition to doing some
of this front end stuff.

00:05:46.240 --> 00:05:49.350
So when we did find areas that
were lacking in the platform,

00:05:49.350 --> 00:05:53.380
we could go in and add those
APIs that we were missing.

00:05:53.380 --> 00:05:55.570
And I'll talk about one of those
specifically later on.

00:05:59.070 --> 00:06:03.230
So Chrome, as you know, has
three core principles.

00:06:03.230 --> 00:06:05.230
You want your UI
to be extremely

00:06:05.230 --> 00:06:06.570
quick, extremely fast.

00:06:06.570 --> 00:06:09.280
You want animations to be
very snappy and fluid.

00:06:09.280 --> 00:06:11.750
When you have jink, you have
stuttering, you have a really

00:06:11.750 --> 00:06:12.810
bad user experience.

00:06:12.810 --> 00:06:15.800
It's jarring for the user.

00:06:15.800 --> 00:06:19.650
Keeping your app very simple,
to me, it means

00:06:19.650 --> 00:06:20.430
getting out of the way.

00:06:20.430 --> 00:06:23.080
Get your UI out of the way of
the user, out of the way of

00:06:23.080 --> 00:06:24.720
what they're trying to do.

00:06:24.720 --> 00:06:26.780
And sometimes that is actually
the hardest thing to

00:06:26.780 --> 00:06:28.720
accomplish.

00:06:28.720 --> 00:06:30.900
Security, obviously, is
extremely important.

00:06:30.900 --> 00:06:34.430
You want to keep your users
secure not only from your app

00:06:34.430 --> 00:06:41.840
misbehaving but from malicious
attackers that can use your

00:06:41.840 --> 00:06:43.100
app to harm your user.

00:06:43.100 --> 00:06:45.870
You want to make sure that
that is not possible.

00:06:45.870 --> 00:06:48.010
So we took these principles to
mind when we were developing

00:06:48.010 --> 00:06:48.640
in the app.

00:06:48.640 --> 00:06:51.880
And the challenges that we faced
when developing the app

00:06:51.880 --> 00:06:53.495
I'm going to frame around
these core principles.

00:06:58.970 --> 00:06:59.770
Speed.

00:06:59.770 --> 00:07:00.650
You've got to be fast.

00:07:00.650 --> 00:07:01.900
Everybody wants to be fast.

00:07:04.980 --> 00:07:08.790
One of the first problems we
ran into was with having to

00:07:08.790 --> 00:07:11.890
have a client side photo and
needing to know if we needed

00:07:11.890 --> 00:07:12.750
to upload it or not.

00:07:12.750 --> 00:07:15.630
You obviously don't want to
waste bandwidth if the user

00:07:15.630 --> 00:07:17.530
already has that photo
in the Cloud.

00:07:17.530 --> 00:07:21.450
And so the way we did that is
to store SHA-512 hashes of

00:07:21.450 --> 00:07:24.820
these photos in the Cloud when
it was already uploaded.

00:07:24.820 --> 00:07:27.260
And so when we have a new photo
to upload, we have to

00:07:27.260 --> 00:07:29.960
calculate that hash to
say hey, do you have

00:07:29.960 --> 00:07:30.670
this photo or not?

00:07:30.670 --> 00:07:32.710
And if not, we don't
need to upload it.

00:07:36.810 --> 00:07:38.990
So we have a little demo here.

00:07:38.990 --> 00:07:42.000
This is a quite large image.

00:07:42.000 --> 00:07:44.000
It's about 12 megabytes,
I think.

00:07:44.000 --> 00:07:46.950
And this is just one example
of what the user could be

00:07:46.950 --> 00:07:50.250
uploading that we need
to get the hash of.

00:07:50.250 --> 00:07:53.870
And we found that the JavaScript
implementation,

00:07:53.870 --> 00:07:57.260
while we could optimize it as
much as we possibly could, it

00:07:57.260 --> 00:08:00.980
could never compare to a
native implementation.

00:08:00.980 --> 00:08:03.380
And we got that native
implementation through Native

00:08:03.380 --> 00:08:05.170
Client, which allows
you to run C++

00:08:05.170 --> 00:08:07.110
binaries in your web app.

00:08:07.110 --> 00:08:10.000
It's a really amazing technology
that is extremely

00:08:10.000 --> 00:08:12.990
useful, especially for these use
cases where you need to do

00:08:12.990 --> 00:08:15.670
data processing, you want to get
bare bones as close to the

00:08:15.670 --> 00:08:17.240
metal as possible.

00:08:17.240 --> 00:08:18.530
So I'm going to do
a little demo.

00:08:18.530 --> 00:08:20.700
We have hashing done
in JavaScript.

00:08:20.700 --> 00:08:22.200
And we have hashing done
in Native Client.

00:08:22.200 --> 00:08:24.350
And we're going to get
the timings of those.

00:08:24.350 --> 00:08:25.967
And we'll see what the
difference is.

00:08:30.170 --> 00:08:31.540
OK.

00:08:31.540 --> 00:08:34.600
Almost three seconds compared
to 200 milliseconds.

00:08:34.600 --> 00:08:37.330
That is an order of magnitude
difference.

00:08:37.330 --> 00:08:38.299
That's amazing.

00:08:38.299 --> 00:08:40.799
Not to mention the fact that
Native Client doesn't block

00:08:40.799 --> 00:08:42.190
the UI, the main thread.

00:08:42.190 --> 00:08:45.850
Whereas this JavaScript
implementation does.

00:08:45.850 --> 00:08:48.330
So if you're taking three
seconds to hash an image, your

00:08:48.330 --> 00:08:49.660
user is doing nothing.

00:08:49.660 --> 00:08:51.950
They're looking at your app
not doing anything.

00:08:51.950 --> 00:08:54.660
So Native Client saved
us on this one.

00:08:54.660 --> 00:08:58.640
And, in fact, with more
native-like apps being

00:08:58.640 --> 00:09:01.230
produced for the web, I think
we're going to see Native

00:09:01.230 --> 00:09:03.880
Client being used a
tremendous amount.

00:09:03.880 --> 00:09:07.080
One of the first big apps that
was done with Native Client

00:09:07.080 --> 00:09:08.400
was actually games.

00:09:08.400 --> 00:09:09.710
That makes perfect sense.

00:09:09.710 --> 00:09:12.850
You've got to have high, super
high performance calculating

00:09:12.850 --> 00:09:14.100
with a lot of data.

00:09:21.270 --> 00:09:23.930
So actually, I want to go in,
and let's look at this and see

00:09:23.930 --> 00:09:26.480
how we hooked up with
Native Client.

00:09:31.720 --> 00:09:33.020
So we're going to go into
the JavaScript.

00:09:38.300 --> 00:09:42.000
And the meat of this is the
NaCl hash for the NaCl

00:09:42.000 --> 00:09:42.560
implementation.

00:09:42.560 --> 00:09:44.760
We'll ignore the JavaScript
for now.

00:09:44.760 --> 00:09:47.450
We're going to do document,
the element ID file_io.

00:09:47.450 --> 00:09:51.040
I/O. So let's go see
what that was.

00:09:51.040 --> 00:09:52.780
That is, I'm going to
zoom this up so you

00:09:52.780 --> 00:09:54.030
guys can see it.

00:09:56.900 --> 00:10:00.320
That's an embed of
type X NaCl.

00:10:00.320 --> 00:10:04.630
This file_io.nmf is an
NaCl manifest format.

00:10:04.630 --> 00:10:08.140
And it specifies what
the binary is for--

00:10:08.140 --> 00:10:09.190
I'm not going to open it up.

00:10:09.190 --> 00:10:10.990
But it specifies what
the binary is

00:10:10.990 --> 00:10:12.880
that needs to be run.

00:10:12.880 --> 00:10:16.910
We communicate with this
with postMessage.

00:10:16.910 --> 00:10:19.620
So we postMessage the file
name, and inside the

00:10:19.620 --> 00:10:22.480
implementation of the NaCl
module, we take that file

00:10:22.480 --> 00:10:27.460
name, do the hashing on it in
C++, that's compiled, and send

00:10:27.460 --> 00:10:30.240
a message back through the
NaCl API to the app.

00:10:30.240 --> 00:10:33.020
And we handle that
message here.

00:10:33.020 --> 00:10:34.510
So this is essentially
how we were doing

00:10:34.510 --> 00:10:35.190
it in Native Client.

00:10:35.190 --> 00:10:36.150
It's actually really simple.

00:10:36.150 --> 00:10:40.680
So this is what, maybe 10
lines total of code for

00:10:40.680 --> 00:10:41.510
handling this.

00:10:41.510 --> 00:10:44.420
And C++ code on the
other side.

00:10:44.420 --> 00:10:47.760
The meat of it is getting the
NaCl module built, which there

00:10:47.760 --> 00:10:48.970
are tons of tutorials
out there.

00:10:48.970 --> 00:10:50.220
It's not that hard.

00:10:59.610 --> 00:11:00.860
Doesn't want to full screen.

00:11:06.170 --> 00:11:07.546
OK, hold on.

00:11:20.010 --> 00:11:21.260
Just one second.

00:11:28.204 --> 00:11:28.690
Oh, yeah.

00:11:28.690 --> 00:11:29.770
Thank you very much.

00:11:29.770 --> 00:11:31.020
I was zoomed in.

00:11:40.120 --> 00:11:43.490
So the next issue that we
are running into is

00:11:43.490 --> 00:11:44.960
the data store layer.

00:11:44.960 --> 00:11:46.850
So with Photos, there
are users that

00:11:46.850 --> 00:11:49.350
have, say, 40,000 photos.

00:11:49.350 --> 00:11:50.930
This is a case that
we have to handle.

00:11:50.930 --> 00:11:52.300
It's very difficult.

00:11:52.300 --> 00:11:55.150
And the fact that this app needs
to be native, needs to

00:11:55.150 --> 00:11:58.570
act like a real app on your
platform, you have to have

00:11:58.570 --> 00:12:01.150
offline support, which means you
need to store your users'

00:12:01.150 --> 00:12:03.440
data locally to some degree.

00:12:03.440 --> 00:12:04.740
You don't have to store
everything but

00:12:04.740 --> 00:12:06.250
at least the metadata.

00:12:06.250 --> 00:12:10.050
For Photos, you would have maybe
a link to where the file

00:12:10.050 --> 00:12:13.980
is on the file system and the
dimensions of the photo and

00:12:13.980 --> 00:12:16.460
any other metadata
that you have.

00:12:16.460 --> 00:12:18.750
This needs to be stored
somewhere in your data layer,

00:12:18.750 --> 00:12:23.000
and we use IndexedDB do this.

00:12:23.000 --> 00:12:25.170
The problem that we ran
into with our initial

00:12:25.170 --> 00:12:29.200
implementation is that we were
not using transactions in

00:12:29.200 --> 00:12:31.050
IndexedDB appropriately.

00:12:31.050 --> 00:12:34.710
And this was kind of killer
because it's not immediately

00:12:34.710 --> 00:12:37.130
obvious what you're doing wrong
when your reads are

00:12:37.130 --> 00:12:39.240
going really slowly
unless you're very

00:12:39.240 --> 00:12:40.880
familiar with the API.

00:12:40.880 --> 00:12:43.340
So I'll give you a demo here.

00:12:43.340 --> 00:12:47.120
We have writing 1,000 records,
reading, removing them, et

00:12:47.120 --> 00:12:50.530
cetera, and with transaction
and with no transaction.

00:12:50.530 --> 00:12:51.780
We'll see what the
differences are.

00:12:56.110 --> 00:12:59.540
OK, it's taking a long time.

00:12:59.540 --> 00:13:00.420
And this is even worse.

00:13:00.420 --> 00:13:03.780
This is two orders of magnitude
worse without

00:13:03.780 --> 00:13:05.100
transactions.

00:13:05.100 --> 00:13:05.970
And it's very simple.

00:13:05.970 --> 00:13:08.550
Let's go in and see what
the transactions do.

00:13:19.160 --> 00:13:22.990
So you open a transaction,
we'll zoom this up.

00:13:22.990 --> 00:13:24.110
And I thank you very much.

00:13:24.110 --> 00:13:26.240
I will zoom back out when
I'm done with this.

00:13:33.000 --> 00:13:35.590
So we have a notification when
the transaction is complete.

00:13:35.590 --> 00:13:39.400
That is when we say I've done
all of my 1,000 operations.

00:13:39.400 --> 00:13:42.690
And you just do all of your
operations at once using the

00:13:42.690 --> 00:13:44.890
transaction object.

00:13:44.890 --> 00:13:48.190
You get the object store out
from the transaction.

00:13:48.190 --> 00:13:50.780
You do your operation
on the store.

00:13:50.780 --> 00:13:52.980
And once this goes
out of scope, the

00:13:52.980 --> 00:13:54.460
transaction will be complete.

00:13:54.460 --> 00:13:55.580
And we'll be done.

00:13:55.580 --> 00:14:01.880
The implementation that doesn't
use transaction has

00:14:01.880 --> 00:14:04.330
one database transaction
per call.

00:14:04.330 --> 00:14:06.270
So every time you are doing a
new call, you're creating a

00:14:06.270 --> 00:14:07.240
new transaction.

00:14:07.240 --> 00:14:08.490
Very inefficient.

00:14:23.650 --> 00:14:26.990
So I think the biggest part
of making this app very

00:14:26.990 --> 00:14:29.540
performant is the scrolling
performance.

00:14:29.540 --> 00:14:32.740
And this was the biggest
challenge for us to solve.

00:14:32.740 --> 00:14:34.560
There's a lot of optimizations
you have to do

00:14:34.560 --> 00:14:35.820
all across the board.

00:14:35.820 --> 00:14:37.580
You have to make sure that
you don't have any leaks.

00:14:37.580 --> 00:14:39.940
You have to make sure that
you're doing the right thing

00:14:39.940 --> 00:14:42.910
in order to be on fast
scroll path.

00:14:42.910 --> 00:14:45.630
This needs to be very
non-choppy.

00:14:45.630 --> 00:14:48.340
Otherwise, if it is choppy,
your users are jarred.

00:14:48.340 --> 00:14:49.810
And they're just
very confused.

00:14:49.810 --> 00:14:51.510
It looks like not
a native app.

00:14:51.510 --> 00:14:54.940
It looks like a web app.

00:14:54.940 --> 00:14:58.730
And so the solution for this
is a fast scroll path.

00:14:58.730 --> 00:15:01.960
The fast scroll path is
where the GPU does the

00:15:01.960 --> 00:15:03.180
scrolling for you.

00:15:03.180 --> 00:15:07.000
Offload the processing for
handling this chunk of video

00:15:07.000 --> 00:15:10.040
memory, you've got everything
rendered into it, and whenever

00:15:10.040 --> 00:15:12.280
you scroll, you just ask the
GPU to do the [? offset ?]

00:15:12.280 --> 00:15:13.010
for you.

00:15:13.010 --> 00:15:15.570
This is common in games,
graphics, whatever.

00:15:15.570 --> 00:15:16.980
And we're starting to
add this to the

00:15:16.980 --> 00:15:18.800
browser in a lot of places.

00:15:18.800 --> 00:15:22.190
Keep in mind that this is very
preliminary, and the GPU team

00:15:22.190 --> 00:15:23.670
is working very hard on this.

00:15:23.670 --> 00:15:27.320
But there are a lot of things
you have to keep in mind.

00:15:27.320 --> 00:15:30.510
When you do scrolling, the
element that you scroll has to

00:15:30.510 --> 00:15:31.520
be the body element.

00:15:31.520 --> 00:15:32.910
That's the first thing.

00:15:32.910 --> 00:15:36.790
And I say that right off the bat
because it's not obvious

00:15:36.790 --> 00:15:39.210
that is a requirement
or a constraint.

00:15:39.210 --> 00:15:42.720
And you can set up your DOM,
your HTML structure, in such a

00:15:42.720 --> 00:15:46.620
way that it's very hard
after the fact to move

00:15:46.620 --> 00:15:47.790
scrolling to the body.

00:15:47.790 --> 00:15:49.300
And we ran into that problem.

00:15:49.300 --> 00:15:51.740
It was a total pain.

00:15:51.740 --> 00:15:53.690
For example, let's go look
at the app for a second.

00:15:58.100 --> 00:16:00.380
We have our main content
here in the middle.

00:16:00.380 --> 00:16:01.640
And I'm going to go into
the single photo

00:16:01.640 --> 00:16:02.650
view to show you more.

00:16:02.650 --> 00:16:06.340
In the toolbar on the top and
this sidebar on the right, the

00:16:06.340 --> 00:16:09.580
toolbar and the sidebar were
siblings of the main content.

00:16:09.580 --> 00:16:11.150
And this was all in one wrapper

00:16:11.150 --> 00:16:12.510
that could be scrolled.

00:16:12.510 --> 00:16:14.380
This doesn't work because
you're not on the body.

00:16:14.380 --> 00:16:17.170
And in order to be on the body
element, we had to make the

00:16:17.170 --> 00:16:20.580
toolbar and the sidebar
fixed position.

00:16:20.580 --> 00:16:23.680
And that has its own
intricacies.

00:16:23.680 --> 00:16:26.320
Like for example, the scroll
bar goes all way the up

00:16:26.320 --> 00:16:27.440
through the toolbar.

00:16:27.440 --> 00:16:30.390
There's really not anything we
can do about that right now.

00:16:30.390 --> 00:16:32.780
And if that's the worst of our
problems that gets us this

00:16:32.780 --> 00:16:34.900
type of scrolling, this fast
scrolling, then it's

00:16:34.900 --> 00:16:36.150
definitely worth it.

00:16:40.940 --> 00:16:42.770
You also want to make sure
when you're handling the

00:16:42.770 --> 00:16:45.720
scroll event, that you're
not doing too much work.

00:16:45.720 --> 00:16:49.260
This is when the browser is
saying I'm about to scroll,

00:16:49.260 --> 00:16:51.590
I'm about to change
your UI, the page.

00:16:51.590 --> 00:16:53.930
If you start doing a lot of
processing, maybe start

00:16:53.930 --> 00:16:55.800
loading a bunch of image
elements, a lot of photo

00:16:55.800 --> 00:16:59.520
elements, that inherently is
going to make the scrolling a

00:16:59.520 --> 00:17:01.300
lot worse, a lot slower.

00:17:01.300 --> 00:17:05.660
So you want to offload your
processing to a time that is

00:17:05.660 --> 00:17:06.960
not in your body scrolling.

00:17:06.960 --> 00:17:09.690
Perhaps queueing up and batching
operations that could

00:17:09.690 --> 00:17:11.180
be done later.

00:17:11.180 --> 00:17:13.660
And we'll talk about that
in one of our solutions.

00:17:13.660 --> 00:17:16.750
One thing that we had to do
was to reduce image loads.

00:17:16.750 --> 00:17:20.369
So when you set the source
attribute on an image element,

00:17:20.369 --> 00:17:23.450
the browser, no matter whether
it's in the view port or not,

00:17:23.450 --> 00:17:26.040
the image element has
to decode the image.

00:17:26.040 --> 00:17:28.900
And we found that the decoding
can be very expensive, and it

00:17:28.900 --> 00:17:31.820
obviously scales with the
size of the image.

00:17:31.820 --> 00:17:34.720
So you want to question
expensive

00:17:34.720 --> 00:17:37.180
operations like that.

00:17:37.180 --> 00:17:39.340
And setting image source is
one of those expensive

00:17:39.340 --> 00:17:41.550
operations.

00:17:41.550 --> 00:17:45.340
So we talked about batching your
heavy processing so that

00:17:45.340 --> 00:17:47.530
you're not doing everything
in your scroll.

00:17:47.530 --> 00:17:51.400
One way to do this, and the best
way right now, is to have

00:17:51.400 --> 00:17:54.910
a callback to this method call
RequestAnimationFrame.

00:17:54.910 --> 00:17:58.950
This method is a way for the
browser to alert you, hey, I'm

00:17:58.950 --> 00:18:03.070
about to do an animation, and
you should do some heavy

00:18:03.070 --> 00:18:05.370
processing in this time period,
batch it all up.

00:18:05.370 --> 00:18:07.240
Do everything at once because
we're going to

00:18:07.240 --> 00:18:08.570
swap everything out.

00:18:08.570 --> 00:18:11.450
And this is a way for the
browser to say this will be

00:18:11.450 --> 00:18:13.610
less janky.

00:18:13.610 --> 00:18:16.330
And so whenever we do
scrolling, we do

00:18:16.330 --> 00:18:19.330
RequestAnimationFrame, and then
we obviously need to load

00:18:19.330 --> 00:18:20.050
more elements.

00:18:20.050 --> 00:18:21.750
So when we
RequestAnimationFrame, the

00:18:21.750 --> 00:18:24.640
callback, we do that
image loading then.

00:18:24.640 --> 00:18:26.410
Because that's when the browser
says, do your heavy,

00:18:26.410 --> 00:18:27.640
intensive processing.

00:18:27.640 --> 00:18:30.210
And this is really great
to have high

00:18:30.210 --> 00:18:33.340
performance in your scrolling.

00:18:33.340 --> 00:18:36.460
Another thing that I think is
starting to be more well

00:18:36.460 --> 00:18:39.950
known, but it is not that well
known I think, and it's not

00:18:39.950 --> 00:18:42.860
very necessarily intuitive, is
that when you measure certain

00:18:42.860 --> 00:18:46.490
properties on DOM elements, you
can cause reflows, which

00:18:46.490 --> 00:18:47.900
may cause repaints.

00:18:47.900 --> 00:18:49.930
And painting is the one
thing you want to

00:18:49.930 --> 00:18:51.370
minimize at all costs.

00:18:51.370 --> 00:18:53.290
If you're doing a bunch of
paints, then you don't have

00:18:53.290 --> 00:18:55.990
the benefit of the GPU doing
the scroll for you.

00:18:55.990 --> 00:18:59.860
Because you're just thrashing
what the GPU had.

00:18:59.860 --> 00:19:00.820
ScrollTop, for example.

00:19:00.820 --> 00:19:03.800
If you're reading scrollTop, not
writing to it, if you read

00:19:03.800 --> 00:19:05.710
it, you're going to do a
reflow, and you could

00:19:05.710 --> 00:19:07.740
potentially repaint.

00:19:07.740 --> 00:19:08.490
Another one is

00:19:08.490 --> 00:19:10.670
getClientBoundingRect on elements.

00:19:10.670 --> 00:19:13.310
And you know what, it's kind
of iffy on some of these

00:19:13.310 --> 00:19:15.010
whether it will cause
a reflow or not.

00:19:15.010 --> 00:19:17.410
There are several good articles,
and I recommend

00:19:17.410 --> 00:19:21.430
looking up reflow, HTML reflow,
to get a lot of

00:19:21.430 --> 00:19:22.410
information about this.

00:19:22.410 --> 00:19:25.040
But this is something that
you have to keep in mind.

00:19:25.040 --> 00:19:27.290
This is the next stage
of app development.

00:19:27.290 --> 00:19:31.220
And this type of performance is
what these apps are going

00:19:31.220 --> 00:19:32.085
to be doing.

00:19:32.085 --> 00:19:33.670
And you want your app to
be this performant.

00:19:36.580 --> 00:19:38.410
Garbage collection is nasty.

00:19:38.410 --> 00:19:40.900
JavaScript is a fun language.

00:19:40.900 --> 00:19:46.450
And, obviously, the way the
memory layout works is very

00:19:46.450 --> 00:19:48.680
fortunate in some ways, but
garbage collection is not one

00:19:48.680 --> 00:19:49.570
of those ways.

00:19:49.570 --> 00:19:52.140
So you want to try to minimize
garbage collection by

00:19:52.140 --> 00:19:55.790
minimizing the pressure
buildup on memory.

00:19:55.790 --> 00:20:01.250
One of the ways that we do that
in this Photos app is if

00:20:01.250 --> 00:20:04.380
you consider it, you have your
main viewport, and you have

00:20:04.380 --> 00:20:06.620
image elements for each
of the photos that the

00:20:06.620 --> 00:20:07.720
user wants to see.

00:20:07.720 --> 00:20:09.730
And we obviously have to
preload before and

00:20:09.730 --> 00:20:11.520
after the view port.

00:20:11.520 --> 00:20:13.780
And that could be 40,000
DOM nodes.

00:20:13.780 --> 00:20:14.840
That's too many.

00:20:14.840 --> 00:20:16.600
That's going to cause a lot of
garbage collection, a lot of

00:20:16.600 --> 00:20:18.470
memory pressure that
you don't need.

00:20:18.470 --> 00:20:23.030
Consider that you can compress
those nodes given like say a

00:20:23.030 --> 00:20:27.980
square of 1,024 by 768
higher up that is not

00:20:27.980 --> 00:20:29.480
visible in the viewport.

00:20:29.480 --> 00:20:31.680
Get rid of all those nodes,
you can either store them

00:20:31.680 --> 00:20:34.450
around somewhere, but at least
keep them out of the tree, and

00:20:34.450 --> 00:20:37.040
replace them with one
div that's sized

00:20:37.040 --> 00:20:38.900
the exact same size.

00:20:38.900 --> 00:20:40.970
So that's like compressing
what you had before.

00:20:40.970 --> 00:20:43.020
And that will keep the structure
of your document,

00:20:43.020 --> 00:20:45.830
will not change the size
of the entire body.

00:20:45.830 --> 00:20:47.680
So the user won't even
be aware that

00:20:47.680 --> 00:20:49.520
you've taken nodes out.

00:20:49.520 --> 00:20:52.280
A nifty little trick
you can do.

00:20:52.280 --> 00:20:53.010
It's really important.

00:20:53.010 --> 00:20:53.780
Leaks are bad.

00:20:53.780 --> 00:20:54.780
Everybody knows that.

00:20:54.780 --> 00:20:57.660
But you've got to pay
attention to it.

00:20:57.660 --> 00:21:01.220
The profiler inside of
Chrome itself can

00:21:01.220 --> 00:21:02.280
really help with this.

00:21:02.280 --> 00:21:03.530
Let's take a look real quick.

00:21:08.570 --> 00:21:09.820
Nope.

00:21:12.540 --> 00:21:18.510
So profiles here allows you
to take a heap snapshot.

00:21:18.510 --> 00:21:20.730
Obviously, the heap snapshot
for this is not going to be

00:21:20.730 --> 00:21:22.880
entirely interesting.

00:21:22.880 --> 00:21:25.300
But it does show you some of the
objects that are going on.

00:21:25.300 --> 00:21:27.870
So we have like this slide
deck object, and

00:21:27.870 --> 00:21:28.620
there are two of them.

00:21:28.620 --> 00:21:32.530
So I may question if I only have
one set of slides, why do

00:21:32.530 --> 00:21:34.530
I have two slide decks?

00:21:34.530 --> 00:21:35.550
I don't know the
answer to that.

00:21:35.550 --> 00:21:37.590
Could be a leak.

00:21:37.590 --> 00:21:40.350
We found, in many instances of
just going through this, and

00:21:40.350 --> 00:21:43.510
you can arrange things by, for
example, dominators, which are

00:21:43.510 --> 00:21:45.580
saying this thing is huge.

00:21:45.580 --> 00:21:47.740
Obviously, you want to go
through the native stuff at

00:21:47.740 --> 00:21:50.720
the top that's not yours, but
get down to where you're

00:21:50.720 --> 00:21:54.600
allocating stuff and say
this is too heavy.

00:21:54.600 --> 00:21:58.720
This slide deck is too
heavy, for example.

00:21:58.720 --> 00:22:02.050
And that's just one way to say I
need to go in here and start

00:22:02.050 --> 00:22:03.970
looking for places where
I may be leaking.

00:22:03.970 --> 00:22:06.630
I may not be freeing references,
removing

00:22:06.630 --> 00:22:08.370
references, et cetera.

00:22:08.370 --> 00:22:10.480
There are a lot of tools that
can help with this.

00:22:10.480 --> 00:22:12.580
They're, in our experience,
not very great.

00:22:12.580 --> 00:22:15.930
There's not a lot of tools right
now that have a very low

00:22:15.930 --> 00:22:16.990
false positive rate.

00:22:16.990 --> 00:22:19.230
But it can point you in
the right direction.

00:22:19.230 --> 00:22:22.290
And it doesn't hurt to just run
it every once in awhile

00:22:22.290 --> 00:22:24.160
and say these are the known
false positives.

00:22:24.160 --> 00:22:27.060
These are the ones
we need to fix.

00:22:27.060 --> 00:22:28.700
Listeners can get
very expensive.

00:22:28.700 --> 00:22:31.790
We had an instance where you
would start the app with no

00:22:31.790 --> 00:22:35.570
photos, and we had
40,000 listeners.

00:22:35.570 --> 00:22:37.010
What are they listening to?

00:22:37.010 --> 00:22:39.100
I mean, that doesn't
even make sense.

00:22:39.100 --> 00:22:41.180
You need to make sure that
things are being detached

00:22:41.180 --> 00:22:41.840
appropriately.

00:22:41.840 --> 00:22:43.490
They stop listening.

00:22:43.490 --> 00:22:46.630
They can be dangerous not just
in the memory footprint but

00:22:46.630 --> 00:22:48.140
also in the processing
footprint.

00:22:48.140 --> 00:22:51.650
If these listeners are being
fired on events, and they

00:22:51.650 --> 00:22:53.540
don't need to be listening, then
they're going to do some

00:22:53.540 --> 00:22:55.280
processing that is
unnecessary.

00:22:55.280 --> 00:22:58.010
And that's going to hurt your
performance as well.

00:22:58.010 --> 00:23:00.120
And we already talked about
profiling memory usage, so

00:23:00.120 --> 00:23:03.260
we'll skip that.

00:23:03.260 --> 00:23:05.830
So back to simplicity.

00:23:05.830 --> 00:23:09.490
I truly think this is one of the
most difficult things that

00:23:09.490 --> 00:23:13.570
you have to solve in an app, how
to get out of the way so

00:23:13.570 --> 00:23:16.420
that the user can just see what
they want to see, do what

00:23:16.420 --> 00:23:20.940
they want to do, minimize your
UI footprint, et cetera.

00:23:20.940 --> 00:23:24.090
And the Chrome platform is
really starting to take over

00:23:24.090 --> 00:23:26.960
this and give you APIs
that allow you to

00:23:26.960 --> 00:23:28.210
get out of the way.

00:23:30.530 --> 00:23:34.110
One of the big ones we
had was with sign-in.

00:23:34.110 --> 00:23:38.350
Signing into an app really feels
like a web page that you

00:23:38.350 --> 00:23:39.540
have to sign into.

00:23:39.540 --> 00:23:42.520
Especially if you don't have
the ability to sign in once

00:23:42.520 --> 00:23:45.470
and have that persistent across
multiple lifetimes,

00:23:45.470 --> 00:23:49.160
multiple instances of the app,
it just doesn't feel native.

00:23:49.160 --> 00:23:52.140
And we do, that's our goal
is to feel native.

00:23:52.140 --> 00:23:54.580
Also, if you're signing in,
that's a step, that's a road

00:23:54.580 --> 00:23:57.880
block to the user getting to
do what they want to do.

00:23:57.880 --> 00:23:59.880
And so we really needed
a way around this.

00:23:59.880 --> 00:24:04.190
And thankfully, the Chrome
platform has a way.

00:24:04.190 --> 00:24:07.800
There is this thing called the
Identity API which allows you

00:24:07.800 --> 00:24:10.920
to retrieve the OAuth2 token
of the user that's

00:24:10.920 --> 00:24:12.130
currently signed in.

00:24:12.130 --> 00:24:14.780
Now this app is right now
designed for ChromeOS.

00:24:14.780 --> 00:24:18.090
But the Identity API works
on all platforms.

00:24:18.090 --> 00:24:20.340
So if the user is signed into
the browser, you can get their

00:24:20.340 --> 00:24:23.430
OAuth2 token for their
Google account.

00:24:23.430 --> 00:24:28.190
For example, in this app, I
didn't have to sign in.

00:24:28.190 --> 00:24:29.590
There is no sign in
button anywhere.

00:24:29.590 --> 00:24:32.810
When you start the app, I don't
ask you to sign in, or

00:24:32.810 --> 00:24:34.400
I'm not asked to sign in.

00:24:34.400 --> 00:24:37.305
And that all comes from the
Identity API and the fact that

00:24:37.305 --> 00:24:39.510
on ChromeOS, specifically,
you're always

00:24:39.510 --> 00:24:40.540
signed into the browser.

00:24:40.540 --> 00:24:43.410
So for an app on ChromeOS, you
shouldn't have to sign in if

00:24:43.410 --> 00:24:45.390
you're using Google Accounts.

00:24:45.390 --> 00:24:49.640
Now you may not be using Google
Accounts, and the

00:24:49.640 --> 00:24:51.495
Identity API has a solution
for that.

00:24:51.495 --> 00:24:54.190
It's called launch
WebAuth flow.

00:24:54.190 --> 00:24:58.510
And so with that API, you can
pass in a third party URL in

00:24:58.510 --> 00:25:02.030
point for OAuth2, and under
the hood, all of

00:25:02.030 --> 00:25:04.805
the workings happen.

00:25:04.805 --> 00:25:08.890
A pop-up is shown that allows
the user to login.

00:25:08.890 --> 00:25:11.960
Now, obviously, that doesn't
solve the issue of getting out

00:25:11.960 --> 00:25:13.300
of the way and not having
a dialogue.

00:25:13.300 --> 00:25:15.510
But if you're not using Google
Accounts, which is a fair

00:25:15.510 --> 00:25:18.590
point, you need a way to sign
in the user to your app.

00:25:18.590 --> 00:25:22.020
And that token can be
persisted across

00:25:22.020 --> 00:25:23.280
instances of the app.

00:25:23.280 --> 00:25:27.600
So, for example, in this code
sample here, we are calling

00:25:27.600 --> 00:25:30.840
getAuthToken, and we're
storing that token.

00:25:30.840 --> 00:25:32.720
So for the lifetime of the app,
we don't have to keep

00:25:32.720 --> 00:25:35.290
calling getAuthToken, we just
have the token around.

00:25:35.290 --> 00:25:39.620
And we build our requests
with this token.

00:25:39.620 --> 00:25:42.410
For example, the Photos
back end at Google.

00:25:42.410 --> 00:25:44.920
We're going to do a request
to read all the

00:25:44.920 --> 00:25:46.980
photos of the user.

00:25:46.980 --> 00:25:49.770
And so what we've done is we
have the token stored.

00:25:49.770 --> 00:25:52.430
We just keep using this same
token for all of our requests

00:25:52.430 --> 00:25:52.890
in the app.

00:25:52.890 --> 00:25:54.220
It's really easy to use.

00:26:01.120 --> 00:26:03.980
So like I said, I had
a camera, and I had

00:26:03.980 --> 00:26:05.270
an SD card in it.

00:26:05.270 --> 00:26:10.660
And I plugged it in, and the
right thing just happened.

00:26:10.660 --> 00:26:11.680
It's a Photos app.

00:26:11.680 --> 00:26:13.060
I've installed this app.

00:26:13.060 --> 00:26:16.470
I said I trust this app to
do what I need it to do,

00:26:16.470 --> 00:26:18.530
including the fact that
it says it has

00:26:18.530 --> 00:26:21.120
access to your media.

00:26:21.120 --> 00:26:24.690
Currently, in the web today,
and in most native apps as

00:26:24.690 --> 00:26:29.230
well, you have to select the
media specifically, say by the

00:26:29.230 --> 00:26:32.980
file open dialog, which I
consider the worst piece of UI

00:26:32.980 --> 00:26:33.665
in browser history.

00:26:33.665 --> 00:26:34.550
It's awful.

00:26:34.550 --> 00:26:37.150
But everybody has to
go through that.

00:26:37.150 --> 00:26:39.580
The alternative is Flash, but
even then, you still have to

00:26:39.580 --> 00:26:42.210
do file directory browsing,
et cetera.

00:26:42.210 --> 00:26:43.640
We wanted to get rid of that.

00:26:46.540 --> 00:26:49.500
The solution to this was the
Media Gallery API, which is

00:26:49.500 --> 00:26:51.400
like the pinnacle
API in this app.

00:26:51.400 --> 00:26:52.822
It's what makes this app pop.

00:26:52.822 --> 00:26:54.860
It's what makes it real.

00:26:54.860 --> 00:27:00.120
The Media Galleries API allows
the developer to have access

00:27:00.120 --> 00:27:05.040
to media devices, so SD cards,
platform media, like my

00:27:05.040 --> 00:27:09.180
pictures or the photos
on a Mac.

00:27:09.180 --> 00:27:10.810
And it has a seamless access.

00:27:10.810 --> 00:27:14.230
You don't have to ask the user
at the time of app running, at

00:27:14.230 --> 00:27:15.870
the app running, only
at installation and

00:27:15.870 --> 00:27:17.320
only that one time.

00:27:17.320 --> 00:27:21.200
So in this app, we have UI that
shows up a notification

00:27:21.200 --> 00:27:22.625
that says you just plugged
in a card, we're

00:27:22.625 --> 00:27:23.890
going to start uploading.

00:27:23.890 --> 00:27:26.940
And you have the ability to stop
the uploading, but that

00:27:26.940 --> 00:27:28.290
action happens right away.

00:27:28.290 --> 00:27:30.940
The user doesn't have to wait,
and the user doesn't have to

00:27:30.940 --> 00:27:32.845
do the file open dialog,
which is just awful.

00:27:35.600 --> 00:27:38.590
So here's a little code snapshot
of how to use this.

00:27:38.590 --> 00:27:41.680
The API call is
getMediaFileSystems.

00:27:41.680 --> 00:27:45.410
And if you're familiar with
it, it returns a DOM file

00:27:45.410 --> 00:27:49.450
system, which has its own file
entries inside of that.

00:27:49.450 --> 00:27:52.000
Its directory structure, you can
read through this with the

00:27:52.000 --> 00:27:53.460
file system API.

00:27:53.460 --> 00:27:56.180
So this is really neat.

00:27:56.180 --> 00:27:59.350
We just have this one little
layer on top of the already

00:27:59.350 --> 00:28:04.410
existing file system API that
restricts what is shown to the

00:28:04.410 --> 00:28:06.510
app to just media locations.

00:28:06.510 --> 00:28:11.250
For example, when I plugged in
the SD card, it knew that it

00:28:11.250 --> 00:28:14.740
had a DCIM folder and said
we think this is a media.

00:28:14.740 --> 00:28:18.380
It's a simple heuristic, but
it really solves 90% of the

00:28:18.380 --> 00:28:20.140
use cases that we're
looking for.

00:28:20.140 --> 00:28:22.700
If you plugged in an external
drive, and it had a DCIM

00:28:22.700 --> 00:28:25.080
directory, we would say
that it probably has

00:28:25.080 --> 00:28:26.440
photos on it as well.

00:28:26.440 --> 00:28:27.690
And we would start
loading that.

00:28:35.440 --> 00:28:39.760
So the first time I saw the
Pixel screen, it was detached

00:28:39.760 --> 00:28:40.840
from the actual laptop.

00:28:40.840 --> 00:28:42.770
It was not even put
together yet.

00:28:42.770 --> 00:28:44.290
It was this little piece.

00:28:44.290 --> 00:28:45.790
And he said, you have to
see this, one of the

00:28:45.790 --> 00:28:46.800
developers of the Pixel.

00:28:46.800 --> 00:28:50.180
And he showed it to me, and it
was just mind blowing, the

00:28:50.180 --> 00:28:51.210
picture that he showed on it.

00:28:51.210 --> 00:28:53.200
I'd never seen something
like this.

00:28:53.200 --> 00:28:56.460
And then he started swiping it
and moving things around, the

00:28:56.460 --> 00:28:59.820
touch on this one screen,
it was just amazing.

00:28:59.820 --> 00:29:03.410
And so you have the ability when
writing apps not just for

00:29:03.410 --> 00:29:07.080
this but say for tablets as
well, like high DPI tablets,

00:29:07.080 --> 00:29:11.240
you obviously have MacBooks
that have Retina Display.

00:29:11.240 --> 00:29:13.560
You want to make sure that
you're optimizing for these

00:29:13.560 --> 00:29:15.190
form factors which are becoming

00:29:15.190 --> 00:29:16.440
more and more prevalent.

00:29:19.650 --> 00:29:23.070
And for the high resolution
display, it's not hard.

00:29:23.070 --> 00:29:27.050
You just provide 2x assets,
high-resolution assets.

00:29:27.050 --> 00:29:29.820
The API to do this
is in CSS itself.

00:29:29.820 --> 00:29:31.550
It's called WebKit Media Set.

00:29:31.550 --> 00:29:34.980
And you can specify
the multiplicative

00:29:34.980 --> 00:29:37.010
factor, so 1x or 2x.

00:29:37.010 --> 00:29:40.030
And you just pass in the right
resource through that.

00:29:40.030 --> 00:29:42.590
One thing to keep in mind is
that you want to make sure to

00:29:42.590 --> 00:29:47.250
set the background size of your
asset to the low res.

00:29:47.250 --> 00:29:51.630
So we have this close icon,
and it's 32 pixels in the

00:29:51.630 --> 00:29:53.230
low-res asset.

00:29:53.230 --> 00:29:55.750
When we load the high-res asset,
we still want it to be

00:29:55.750 --> 00:29:59.590
32 pixels on the screen.

00:29:59.590 --> 00:30:01.810
So that doesn't blow up
un-proportionally.

00:30:01.810 --> 00:30:06.630
We just have it more dense
inside of those 32 pixels.

00:30:06.630 --> 00:30:09.070
You want to make sure you do
this especially if your user

00:30:09.070 --> 00:30:11.190
is going to be on a
high-resolution display

00:30:11.190 --> 00:30:16.040
because on most browsers and
definitely in Chrome, the

00:30:16.040 --> 00:30:19.470
scaling algorithm for images to
scale up to high resolution

00:30:19.470 --> 00:30:21.820
is optimized for speed,
not quality.

00:30:21.820 --> 00:30:25.280
You'll get very blurry images,
and your users are going to

00:30:25.280 --> 00:30:26.290
get a headache after a while.

00:30:26.290 --> 00:30:27.540
It looks really bad.

00:30:27.540 --> 00:30:30.900
We had a regression one time
where the high-resolution

00:30:30.900 --> 00:30:32.770
assets were not being
loaded properly.

00:30:32.770 --> 00:30:35.900
And every body was like, oh
my gosh, this is awful.

00:30:35.900 --> 00:30:37.930
Something is clearly wrong
with this app.

00:30:37.930 --> 00:30:39.910
And imagine if your user
saw that, they're

00:30:39.910 --> 00:30:40.970
not expecting it.

00:30:40.970 --> 00:30:42.860
They just know something
is wrong.

00:30:45.590 --> 00:30:47.950
And to touch support.

00:30:47.950 --> 00:30:49.330
This is a really fun
thing to touch.

00:30:49.330 --> 00:30:52.940
And they always say, why would
you touch this laptop screen?

00:30:52.940 --> 00:30:55.520
People don't want to reach over
their keyboard to do it.

00:30:55.520 --> 00:30:58.610
But the more you use this, the
more you start touching

00:30:58.610 --> 00:30:59.900
everything around you.

00:30:59.900 --> 00:31:01.060
Like you reach over
everything.

00:31:01.060 --> 00:31:04.810
I touch my work 32-inch monitor

00:31:04.810 --> 00:31:06.110
expecting it to do something.

00:31:06.110 --> 00:31:06.770
And it doesn't.

00:31:06.770 --> 00:31:08.840
It's extremely frustrating.

00:31:08.840 --> 00:31:10.930
More and more, displays are
going to be touch, whether

00:31:10.930 --> 00:31:14.530
it's a hybrid, whether it can
be converted, et cetera.

00:31:14.530 --> 00:31:17.960
Your app should really handle,
if not touch gestures

00:31:17.960 --> 00:31:23.060
specifically like dragging and
touch start, touch end, to

00:31:23.060 --> 00:31:25.700
consider what your user
actions should be.

00:31:25.700 --> 00:31:27.350
For example, consider
the Photos view.

00:31:31.700 --> 00:31:34.120
So we have this photo here.

00:31:34.120 --> 00:31:36.470
I admit, I was in the wrong
when we were having this

00:31:36.470 --> 00:31:37.290
discussion.

00:31:37.290 --> 00:31:39.990
I felt that we should
have double-click to

00:31:39.990 --> 00:31:41.980
activate these objects.

00:31:41.980 --> 00:31:44.180
So if I wanted to go into the
single photo view for this

00:31:44.180 --> 00:31:46.200
photo, I should have
double-click.

00:31:46.200 --> 00:31:49.640
And that was me coming from
wanting to have a more native

00:31:49.640 --> 00:31:50.360
experience.

00:31:50.360 --> 00:31:55.040
And in native apps and in the
file system browsing around

00:31:55.040 --> 00:31:57.820
things, you double-click to
activate for the most part.

00:31:57.820 --> 00:31:59.820
And I thought that would be
a more native experience.

00:31:59.820 --> 00:32:02.220
But then we had the issue of
well, what do you do when

00:32:02.220 --> 00:32:03.090
you're tapping?

00:32:03.090 --> 00:32:05.600
Do you double tap the screen?

00:32:05.600 --> 00:32:06.180
No.

00:32:06.180 --> 00:32:07.500
That doesn't work.

00:32:07.500 --> 00:32:10.940
We could have it where you, with
a mouse or a track pad,

00:32:10.940 --> 00:32:13.980
that you double-click, and
then with touch, you

00:32:13.980 --> 00:32:14.500
single-click.

00:32:14.500 --> 00:32:17.400
But then you have a very
confusing UX, your user

00:32:17.400 --> 00:32:18.590
doesn't know what to do.

00:32:18.590 --> 00:32:20.240
And then they're going to start
doing the wrong thing

00:32:20.240 --> 00:32:20.860
the entire time.

00:32:20.860 --> 00:32:24.570
They're going to start double
touching the screen.

00:32:24.570 --> 00:32:28.220
So the key takeaway for this one
is just to consider that

00:32:28.220 --> 00:32:30.710
tap support is very important.

00:32:30.710 --> 00:32:35.290
Users are going to start using
tap and touch screens.

00:32:35.290 --> 00:32:38.210
And you don't necessarily have
to have full touch support.

00:32:38.210 --> 00:32:40.860
Just think about what your
UX is going to be.

00:32:40.860 --> 00:32:42.790
I know a lot of you are
engineers, maybe some of you

00:32:42.790 --> 00:32:44.320
are designers in UX.

00:32:44.320 --> 00:32:45.910
But it's all our responsibility
to create the

00:32:45.910 --> 00:32:47.160
best looking app.

00:32:50.210 --> 00:32:54.730
So on to security, that
last principle.

00:32:54.730 --> 00:32:57.260
This section, it can come
off a little dry.

00:32:57.260 --> 00:33:00.750
It's kind of difficult to deal
with, but security is

00:33:00.750 --> 00:33:03.110
extremely important
for the user.

00:33:06.540 --> 00:33:09.370
And there are a lot of things in
the platform that at first

00:33:09.370 --> 00:33:12.760
feel like you have to deal with,
but at the end, assuming

00:33:12.760 --> 00:33:14.930
you start designing your app
the right way from the

00:33:14.930 --> 00:33:17.450
beginning, you're
much better off.

00:33:17.450 --> 00:33:18.935
Your user is much safer.

00:33:22.300 --> 00:33:27.020
So content security policy is
this essentially white list,

00:33:27.020 --> 00:33:30.810
black list that says your app
has access to these resources,

00:33:30.810 --> 00:33:33.810
these remote URLs, these
domains, et cetera.

00:33:33.810 --> 00:33:37.130
And by default, you really don't
have access to hardly

00:33:37.130 --> 00:33:38.010
anything at all.

00:33:38.010 --> 00:33:40.930
As you're adding a white list
for resources your app should

00:33:40.930 --> 00:33:44.280
have access to, you consider
like your back end server, you

00:33:44.280 --> 00:33:47.560
obviously need access to
that, and nothing else.

00:33:47.560 --> 00:33:51.990
So if an attacker gets a hold
of your app, something gets

00:33:51.990 --> 00:33:55.230
injected, and starts making
requests to some malicious

00:33:55.230 --> 00:33:58.780
server, those requests are going
to be denied because

00:33:58.780 --> 00:34:01.920
they're blocked by content
security policy.

00:34:01.920 --> 00:34:04.770
The key thing here is to start
designing your app from the

00:34:04.770 --> 00:34:07.360
very beginning with content
security policy in mind.

00:34:07.360 --> 00:34:09.120
You can't load remote scripts.

00:34:09.120 --> 00:34:10.820
You can't use eval.

00:34:10.820 --> 00:34:14.560
And, for us, this was kind of
a problem because we were

00:34:14.560 --> 00:34:17.719
getting JSON objects back from
the server, and so we had to

00:34:17.719 --> 00:34:20.850
translate those into objects
using eval, and

00:34:20.850 --> 00:34:22.739
we couldn't do that.

00:34:22.739 --> 00:34:25.780
So what we ended up doing was
having a sandboxed iframe that

00:34:25.780 --> 00:34:29.280
had the use of eval inside of
it, and we passed the JSON

00:34:29.280 --> 00:34:30.820
objects into this iframe.

00:34:30.820 --> 00:34:34.389
It would do the eval, get the
object back, and then post a

00:34:34.389 --> 00:34:36.520
message back to the
app, this object.

00:34:36.520 --> 00:34:39.620
So if something malicious goes
on, the eval is going wonky,

00:34:39.620 --> 00:34:42.370
that sandbox iframe has no
permissions whatsoever.

00:34:42.370 --> 00:34:44.420
All it can do is communicate
back and forth.

00:34:44.420 --> 00:34:46.690
So you're pretty safe
as far as that goes.

00:34:51.590 --> 00:34:52.699
Making requests.

00:34:52.699 --> 00:34:55.020
So you can't say image
source equal remote.

00:34:55.020 --> 00:34:58.080
You actually have to pull down
the bits for that image.

00:34:58.080 --> 00:35:00.250
So all of these photos, we have
to pull them down from

00:35:00.250 --> 00:35:01.240
the server.

00:35:01.240 --> 00:35:04.220
XML HTTP requests is
the way we do this.

00:35:04.220 --> 00:35:08.560
You just create your URL for
the request, send it off.

00:35:08.560 --> 00:35:11.740
You get your response, you
should save it in your data

00:35:11.740 --> 00:35:12.860
layer obviously.

00:35:12.860 --> 00:35:15.960
And then once you get that,
the data gets bubbled up

00:35:15.960 --> 00:35:17.210
through your UI.

00:35:20.880 --> 00:35:23.610
And another tip as far as
thinking what you should do

00:35:23.610 --> 00:35:26.920
from the beginning, designing
from the beginning, resource

00:35:26.920 --> 00:35:29.790
compilation comes in very handy
with packaged apps.

00:35:29.790 --> 00:35:32.690
We particularly use Closure, but
there are a lot of tools

00:35:32.690 --> 00:35:35.320
that you can use to
do the same thing.

00:35:35.320 --> 00:35:38.550
You're going to say,
essentially, in your main HTML

00:35:38.550 --> 00:35:42.900
of the packaged app, script
equals some local file.

00:35:42.900 --> 00:35:45.480
You could say a bunch of local
files, but it's a lot easier

00:35:45.480 --> 00:35:48.300
to just have your code compiled,
have it minified, et

00:35:48.300 --> 00:35:50.520
cetera, and say script equals
this local file.

00:35:54.830 --> 00:36:00.350
So to wrap it up, we look back
at what our goals were, and I

00:36:00.350 --> 00:36:03.600
think we really achieved
those goals.

00:36:03.600 --> 00:36:06.150
We identified holes
in the platform,

00:36:06.150 --> 00:36:07.340
APIs that were missing.

00:36:07.340 --> 00:36:09.900
We added media gallery APIs.

00:36:09.900 --> 00:36:13.040
We tested a lot of features
from Google+ Photos.

00:36:13.040 --> 00:36:16.230
We got autocuration working
really well.

00:36:16.230 --> 00:36:18.760
And we just pushed the platform
to its limits.

00:36:18.760 --> 00:36:20.740
How far can you go with this?

00:36:20.740 --> 00:36:23.090
How hard is it for developers
to use this?

00:36:23.090 --> 00:36:25.000
I think the answer
is not very hard.

00:36:25.000 --> 00:36:27.650
The biggest thing you have to
do is to understand your

00:36:27.650 --> 00:36:29.820
constraints from the
very beginning.

00:36:29.820 --> 00:36:33.260
Understand that you don't have
access to remote URLs.

00:36:33.260 --> 00:36:35.390
Understand that if you want fast
scrolling, you need to

00:36:35.390 --> 00:36:36.740
scroll your body.

00:36:36.740 --> 00:36:39.870
And, obviously, the platform is
constantly changing, things

00:36:39.870 --> 00:36:40.910
are being fixed.

00:36:40.910 --> 00:36:45.440
I know I've reached out to the
GPU team a lot to say, this is

00:36:45.440 --> 00:36:46.480
not easy enough.

00:36:46.480 --> 00:36:47.590
We have to fix this.

00:36:47.590 --> 00:36:52.140
And just imagine the evolution
that's happening right now.

00:36:52.140 --> 00:36:55.680
You can see it at I/O. This
platform is just moving

00:36:55.680 --> 00:36:57.470
forward at the speed of light,
the things that you're going

00:36:57.470 --> 00:36:58.470
to be able to do.

00:36:58.470 --> 00:37:00.590
It's getting a lot easier.

00:37:00.590 --> 00:37:02.850
And it's getting a lot better.

00:37:02.850 --> 00:37:07.230
So packaged apps, yeah, we
definitely want that.

00:37:07.230 --> 00:37:10.910
And I think the way to think
about it in terms of how does

00:37:10.910 --> 00:37:14.290
it relate to web apps is that
you could have the core of

00:37:14.290 --> 00:37:17.100
your app have functionality
that is available

00:37:17.100 --> 00:37:19.840
cross-platform, is not
necessarily specific to

00:37:19.840 --> 00:37:23.020
Chrome, doesn't have these
extended APIs and permissions

00:37:23.020 --> 00:37:24.570
that are requested.

00:37:24.570 --> 00:37:27.640
And in doing that, you're going
to have a lot safer API.

00:37:27.640 --> 00:37:31.186
For example, you've got to use
XML HTTP requests, you're

00:37:31.186 --> 00:37:34.480
going to have content security
policy support, all of that

00:37:34.480 --> 00:37:35.220
from the get-go.

00:37:35.220 --> 00:37:37.080
And that's just your
core bundle.

00:37:37.080 --> 00:37:40.140
Layered on top of this is all
the goodies that you get from

00:37:40.140 --> 00:37:40.680
the platform.

00:37:40.680 --> 00:37:43.120
You get the Identity
API, so use it.

00:37:43.120 --> 00:37:44.320
If you have it, use it.

00:37:44.320 --> 00:37:46.030
You get Media Galleries API.

00:37:46.030 --> 00:37:46.450
Use it.

00:37:46.450 --> 00:37:48.730
And if not, degrade
gracefully.

00:37:48.730 --> 00:37:52.290
And this is how if you build
your app, whether it's for

00:37:52.290 --> 00:37:54.750
Chrome packaged apps
specifically, or if you're

00:37:54.750 --> 00:37:57.690
going to deploy it on the web
across multiple browsers, if

00:37:57.690 --> 00:38:00.620
you do this, you can have one
product that can work on

00:38:00.620 --> 00:38:01.950
multiple platforms.

00:38:01.950 --> 00:38:05.570
And on some platforms, it just
has more functionality.

00:38:05.570 --> 00:38:07.600
We've done that with Google+
Photos Chrome app.

00:38:07.600 --> 00:38:10.850
And we think it's working
out really well.

00:38:10.850 --> 00:38:14.590
So I actually think we don't
have time for questions.

00:38:14.590 --> 00:38:15.880
We only have about
a minute left.

00:38:15.880 --> 00:38:19.346
But I will be at the Office
Hours bar if you want to come

00:38:19.346 --> 00:38:21.090
by and ask any questions
you have.

00:38:21.090 --> 00:38:22.900
It's been a real pleasure.

00:38:22.900 --> 00:38:24.490
Thank you very much
for attending.

00:38:24.490 --> 00:38:26.230
And I hope to see
you guys soon.

00:38:26.230 --> 00:38:30.013
[APPLAUSE]

