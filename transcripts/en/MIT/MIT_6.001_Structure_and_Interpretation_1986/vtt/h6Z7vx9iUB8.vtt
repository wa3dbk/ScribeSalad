WEBVTT
Kind: captions
Language: en

00:00:03.936 --> 00:00:04.279
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY

00:00:04.279 --> 00:00:05.529
JOHANN SEBASTIAN BACH]

00:00:20.180 --> 00:00:21.840
PROFESSOR: So far in this course
we've been talking a

00:00:21.840 --> 00:00:23.780
lot about data abstraction.

00:00:23.780 --> 00:00:28.230
And remember the idea is that
we build systems that have

00:00:28.230 --> 00:00:31.980
these horizontal barriers in
them, these abstraction

00:00:31.980 --> 00:00:38.490
barriers that separate use,
the way you might use some

00:00:38.490 --> 00:00:41.180
data object, from the way
you might represent it.

00:00:48.985 --> 00:00:51.760
Or another way to think of that
is up here you have the

00:00:51.760 --> 00:00:57.110
boss who's going to be using
some sort of data object.

00:00:57.110 --> 00:01:02.310
And down here is George
who's implemented it.

00:01:02.310 --> 00:01:05.760
Now this notion of separating
use from representation so you

00:01:05.760 --> 00:01:10.930
can think about these two
problems separately is a very,

00:01:10.930 --> 00:01:15.930
very powerful programming
methodology, data abstraction.

00:01:15.930 --> 00:01:21.040
On the other hand, it's not
really sufficient for really

00:01:21.040 --> 00:01:28.640
complex systems. And the problem
with this is George.

00:01:28.640 --> 00:01:32.110
Or actually, the problem
is that there

00:01:32.110 --> 00:01:34.630
are a lot of Georges.

00:01:34.630 --> 00:01:35.390
Let's be concrete.

00:01:35.390 --> 00:01:41.192
Let's suppose there is George,
and there's also Martha.

00:01:41.192 --> 00:01:46.040
OK, now George and Martha are
both working on this system,

00:01:46.040 --> 00:01:49.250
both designing representations,
and

00:01:49.250 --> 00:01:51.750
absolutely are incompatible.

00:01:51.750 --> 00:01:54.620
They wouldn't cooperate on a
representation under any

00:01:54.620 --> 00:01:57.250
circumstances.

00:01:57.250 --> 00:02:00.060
And the problem is you would
like to have some system where

00:02:00.060 --> 00:02:05.380
both George and Martha are
designing representations, and

00:02:05.380 --> 00:02:09.756
yet, if you're above this
abstraction barrier you don't

00:02:09.756 --> 00:02:12.360
want to have to worry about
that, whether something is

00:02:12.360 --> 00:02:14.180
done by George or by Martha.

00:02:14.180 --> 00:02:15.430
And you don't want George
and Martha to

00:02:15.430 --> 00:02:16.630
interfere with each other.

00:02:16.630 --> 00:02:20.310
Somehow in designing a system,
you not only want these

00:02:20.310 --> 00:02:26.300
horizontal barriers, but you
also want some kind of

00:02:26.300 --> 00:02:32.980
vertical barrier to keep George
and Martha separate.

00:02:32.980 --> 00:02:36.560
Let me be a little bit
more concrete.

00:02:36.560 --> 00:02:42.650
Imagine that you're thinking
about personnel records for a

00:02:42.650 --> 00:02:48.180
large company with a lot of
loosely linked divisions that

00:02:48.180 --> 00:02:50.430
don't cooperate very
well either.

00:02:50.430 --> 00:02:57.040
And imagine even that this
company is formed by merging a

00:02:57.040 --> 00:02:59.450
whole bunch of companies that
already have their personnel

00:02:59.450 --> 00:03:00.700
record system set up.

00:03:03.250 --> 00:03:06.570
And imagine that once these
divisions are all linked in

00:03:06.570 --> 00:03:08.530
some kind of very sophisticated
satellite

00:03:08.530 --> 00:03:12.240
network, and all these databases
are put together.

00:03:12.240 --> 00:03:17.260
And what you'd like to do is,
from any place in the company,

00:03:17.260 --> 00:03:23.130
to be able to say things like,
oh, what's the name in a

00:03:23.130 --> 00:03:26.400
personnel record?

00:03:26.400 --> 00:03:30.540
Or, what's the job description
in a personnel record?

00:03:30.540 --> 00:03:34.840
And not have to worry about the
fact that each division

00:03:34.840 --> 00:03:36.760
obviously is going to have
completely separate

00:03:36.760 --> 00:03:41.580
conventions for how you might
implement these records.

00:03:41.580 --> 00:03:44.960
From this point you don't
want to know about that.

00:03:44.960 --> 00:03:48.430
Well how could you
possibly do that?

00:03:48.430 --> 00:03:52.640
One way, of course, is to send
down an edict from somewhere

00:03:52.640 --> 00:03:56.290
that everybody has to change
their format to some fixed

00:03:56.290 --> 00:03:58.070
compatible thing.

00:03:58.070 --> 00:04:01.820
That's what people often try,
and of course it never works.

00:04:01.820 --> 00:04:07.340
Another thing that you might
want to do is somehow arrange

00:04:07.340 --> 00:04:11.250
it so you can have these
vertical barriers.

00:04:11.250 --> 00:04:14.430
So that when you ask for the
name of a personnel record,

00:04:14.430 --> 00:04:17.970
somehow, whatever format it
happens to be, name will

00:04:17.970 --> 00:04:19.470
figure out how to do
the right thing.

00:04:22.730 --> 00:04:26.260
We want name to be, so-called,
a generic operator.

00:04:26.260 --> 00:04:30.060
Generic operator means what it
sort of precisely does depends

00:04:30.060 --> 00:04:33.650
on the kind of data that
it's looking at.

00:04:33.650 --> 00:04:37.100
More than that, you'd like to
design the system so that the

00:04:37.100 --> 00:04:43.250
next time a new division comes
into the company they don't

00:04:43.250 --> 00:04:45.640
have to make any big changes in
what they're already doing

00:04:45.640 --> 00:04:50.110
to link into this system, and
the rest of the company

00:04:50.110 --> 00:04:53.500
doesn't have to make any big
changes to admit their stuff

00:04:53.500 --> 00:04:55.520
to the system.

00:04:55.520 --> 00:04:58.700
So that's the problem you should
be thinking about.

00:04:58.700 --> 00:05:00.770
Like it's sort of
just your work.

00:05:00.770 --> 00:05:02.390
You want to be able to
include new things by

00:05:02.390 --> 00:05:03.640
making minimal changes.

00:05:05.980 --> 00:05:07.340
OK, well that's the problem
that we'll be

00:05:07.340 --> 00:05:09.440
talking about today.

00:05:09.440 --> 00:05:13.140
And you should have this sort
of distributed personnel

00:05:13.140 --> 00:05:14.240
record system in your mind.

00:05:14.240 --> 00:05:16.620
But actually the one I'll be
talking about is a problem

00:05:16.620 --> 00:05:18.900
that's a little bit more
self-contained than that.

00:05:18.900 --> 00:05:21.870
that'll bring up the issues,
I think, more clearly.

00:05:21.870 --> 00:05:25.300
That's the problem of doing a
system that does arithmetic on

00:05:25.300 --> 00:05:27.770
complex numbers.

00:05:27.770 --> 00:05:30.690
So let's take a look here.

00:05:30.690 --> 00:05:32.460
Just as a little review,
there are things

00:05:32.460 --> 00:05:35.250
called complex numbers.

00:05:35.250 --> 00:05:36.960
Complex number you can think
of as a point in

00:05:36.960 --> 00:05:39.370
the plane, or z.

00:05:39.370 --> 00:05:46.230
And you can represent a point
either by its real-part and

00:05:46.230 --> 00:05:47.190
its imaginary-part.

00:05:47.190 --> 00:05:51.690
So if this is z and its
real-part is this much, and

00:05:51.690 --> 00:05:54.880
its imaginary-part is that
much, and you write z

00:05:54.880 --> 00:05:56.130
equals x plus iy.

00:05:59.110 --> 00:06:03.210
Or another way to represent a
complex number is by saying,

00:06:03.210 --> 00:06:10.900
what's the distance from the
origin, and what's the angle?

00:06:10.900 --> 00:06:13.540
So that represents a complex
number as its

00:06:13.540 --> 00:06:16.670
radius times an angle.

00:06:19.520 --> 00:06:20.820
This one's called-- the
original one's called

00:06:20.820 --> 00:06:24.690
rectangular form, rectangular
representation, real- and

00:06:24.690 --> 00:06:28.640
imaginary-part, or polar
representation.

00:06:28.640 --> 00:06:30.040
Magnitude and angle--

00:06:30.040 --> 00:06:32.260
and if you know the real- and
imaginary-part, you can figure

00:06:32.260 --> 00:06:33.720
out the magnitude and angle.

00:06:33.720 --> 00:06:37.190
If you know x and y, you can
get r by this formula.

00:06:37.190 --> 00:06:39.480
Square root of sum of the
squares, and you can get the

00:06:39.480 --> 00:06:41.420
angle as an arctangent.

00:06:41.420 --> 00:06:44.420
Or conversely, if you knew
r and A you could

00:06:44.420 --> 00:06:45.800
figure out x and y.

00:06:45.800 --> 00:06:49.435
x is r times the cosine of A,
and y is r times the sine of

00:06:49.435 --> 00:06:52.490
A. All right, so there's
these two.

00:06:52.490 --> 00:06:54.130
They're complex numbers.

00:06:54.130 --> 00:06:55.810
You can think of them
either in polar form

00:06:55.810 --> 00:06:57.150
or rectangular form.

00:06:57.150 --> 00:06:59.830
What we would like to do is
make a system that does

00:06:59.830 --> 00:07:03.850
arithmetic on complex numbers.

00:07:03.850 --> 00:07:05.580
In other words, what
we'd like--

00:07:05.580 --> 00:07:07.380
just like the rational
number example--

00:07:07.380 --> 00:07:11.120
is to have some operations plus
c, which is going to take

00:07:11.120 --> 00:07:14.640
two complex numbers and add
them, subtract them, and

00:07:14.640 --> 00:07:16.910
multiply them, and
divide them.

00:07:20.730 --> 00:07:25.280
OK, well there's little bit
of mathematics behind it.

00:07:25.280 --> 00:07:29.800
What are the actual formulas for
manipulating such things?

00:07:29.800 --> 00:07:34.270
And it's sort of not important
where they come from, but just

00:07:34.270 --> 00:07:36.120
as an implementer let's see--

00:07:36.120 --> 00:07:40.030
if you want to add two complex
numbers it's pretty easy to

00:07:40.030 --> 00:07:42.660
get its real-part and
its imaginary-part.

00:07:42.660 --> 00:07:47.810
The real-part of the sum of
two complex numbers, the

00:07:47.810 --> 00:07:53.720
real-part of the z1 plus z2 is
the real-part of z1 plus the

00:07:53.720 --> 00:07:54.970
real-part of z2.

00:07:57.820 --> 00:08:02.770
And the imaginary-part of z1
plus z2 is the imaginary part

00:08:02.770 --> 00:08:07.410
of z1 plus the imaginary
part of z2.

00:08:07.410 --> 00:08:09.480
So it's pretty easy to
add complex numbers.

00:08:09.480 --> 00:08:12.320
You just add the corresponding
parts and make a new complex

00:08:12.320 --> 00:08:13.400
number with those parts.

00:08:13.400 --> 00:08:17.180
If you want to multiply them,
it's kind of nice to do it in

00:08:17.180 --> 00:08:17.840
polar form.

00:08:17.840 --> 00:08:21.810
Because if you have two complex
numbers, the magnitude

00:08:21.810 --> 00:08:26.285
of their product is here, the
product of the magnitudes.

00:08:28.850 --> 00:08:35.809
And the angle of the product
is the sum of the angles.

00:08:35.809 --> 00:08:39.179
So that's sort of mathematics
that allows you to do

00:08:39.179 --> 00:08:40.549
arithmetic on complex numbers.

00:08:40.549 --> 00:08:43.720
Let's actually think about
the implementation.

00:08:43.720 --> 00:08:49.330
Well we do it just like
rational numbers.

00:08:49.330 --> 00:08:52.200
We come down, we assume
we have some

00:08:52.200 --> 00:08:53.840
constructors and selectors.

00:08:53.840 --> 00:08:55.330
What would we like?

00:08:55.330 --> 00:08:58.890
Well let's assume that we make
a data object cloud, which is

00:08:58.890 --> 00:09:02.510
a complex number that has some
stuff in it, and that we can

00:09:02.510 --> 00:09:05.870
get out from a complex number
the real-part, or the

00:09:05.870 --> 00:09:12.150
imaginary-part, or the
magnitude, or the angle.

00:09:12.150 --> 00:09:14.320
We want some ways of making
complex numbers-- not only

00:09:14.320 --> 00:09:16.800
selectors, but constructors.

00:09:16.800 --> 00:09:20.160
So we'll assume we have a thing
called make-rectangular.

00:09:20.160 --> 00:09:24.510
What make-rectangular is going
to do is take a real-part and

00:09:24.510 --> 00:09:28.610
an imaginary-part and construct
a complex number

00:09:28.610 --> 00:09:31.920
with those parts.

00:09:31.920 --> 00:09:35.010
Similarly, we can have
make-polar which will take a

00:09:35.010 --> 00:09:42.550
magnitude and an angle, and
construct a complex number

00:09:42.550 --> 00:09:44.680
which has that magnitude
and angle.

00:09:44.680 --> 00:09:45.460
So here's a system.

00:09:45.460 --> 00:09:48.910
We'll have two constructors
and four selectors.

00:09:48.910 --> 00:09:55.150
And now, just like before, in
terms of that abstract data

00:09:55.150 --> 00:09:59.220
we'll go ahead and implement our
complex number operations.

00:09:59.220 --> 00:10:03.280
And here you can see translated
into Lisp code just

00:10:03.280 --> 00:10:08.330
the arithmetic formulas
I put down before.

00:10:08.330 --> 00:10:13.450
If I want to add two complex
numbers I will make a complex

00:10:13.450 --> 00:10:16.630
number out of its real-
and imaginary-parts.

00:10:16.630 --> 00:10:19.680
The real part of the complex
number I'm going to make is

00:10:19.680 --> 00:10:23.310
the sum of the real-parts.

00:10:23.310 --> 00:10:25.250
The imaginary part of the
complex number I'm going to

00:10:25.250 --> 00:10:27.005
make is the sum of the
imaginary-parts.

00:10:30.310 --> 00:10:31.990
I put those together, make
a complex number.

00:10:31.990 --> 00:10:35.780
That's how I implement complex
number addition.

00:10:35.780 --> 00:10:39.650
Subtraction is essentially
the same.

00:10:39.650 --> 00:10:45.140
All I do is subtract the parts
rather than add them.

00:10:45.140 --> 00:10:47.980
To multiply two complex
numbers, I

00:10:47.980 --> 00:10:49.270
use the other formula.

00:10:49.270 --> 00:10:55.350
I'll make a complex number out
of a magnitude and angle.

00:10:55.350 --> 00:10:58.740
The magnitude is going to be the
product of the magnitudes

00:10:58.740 --> 00:11:00.465
of the two complex numbers
I'm multiplying.

00:11:03.710 --> 00:11:06.980
And the angle is going to be the
sum of the angles of the

00:11:06.980 --> 00:11:09.620
two complex numbers
I'm multiplying.

00:11:09.620 --> 00:11:11.230
So there's multiplication.

00:11:11.230 --> 00:11:17.370
And then division, division
is almost the same.

00:11:17.370 --> 00:11:19.660
Here I divide the magnitudes
and subtract the angles.

00:11:28.640 --> 00:11:31.870
Now I've implemented
the operations.

00:11:31.870 --> 00:11:33.640
And what do we do?

00:11:33.640 --> 00:11:36.060
We call on George.

00:11:36.060 --> 00:11:38.070
We've done the use, let's
worry about the

00:11:38.070 --> 00:11:38.800
representation.

00:11:38.800 --> 00:11:42.200
We'll call on George and say to
George, go ahead and build

00:11:42.200 --> 00:11:45.250
us a complex number
representation.

00:11:45.250 --> 00:11:47.770
Well that's fine.

00:11:47.770 --> 00:11:52.660
George can say, we'll implement
a complex number

00:11:52.660 --> 00:11:56.400
simply as a pair that has
the real-part and the

00:11:56.400 --> 00:11:57.200
imaginary-part.

00:11:57.200 --> 00:12:01.020
So if I want to make a complex
number with a certain

00:12:01.020 --> 00:12:03.860
real-part and an imaginary-part,
I'll just use

00:12:03.860 --> 00:12:06.640
cons to form a pair, and that
will-- that's George's

00:12:06.640 --> 00:12:09.780
representation of a
complex number.

00:12:09.780 --> 00:12:12.420
So if I want to get out the
real-part of something, I just

00:12:12.420 --> 00:12:14.350
extract the car,
the first part.

00:12:14.350 --> 00:12:16.300
If I want to get the
imaginary-part, I extract the

00:12:16.300 --> 00:12:22.220
cdr. How do I deal with the
magnitude and angle?

00:12:22.220 --> 00:12:25.550
Well if I want to extract the
magnitude of one of these

00:12:25.550 --> 00:12:28.895
things, I get the square root
of the sum of the square of

00:12:28.895 --> 00:12:34.310
the car plus the square of the
cdr. If I want to get the

00:12:34.310 --> 00:12:37.660
angle, I compute the
arctangent of

00:12:37.660 --> 00:12:39.530
the cdr in the car.

00:12:39.530 --> 00:12:42.300
This is a list procedure for
computing arctangent.

00:12:44.970 --> 00:12:49.150
And if somebody hands me a
magnitude and an angle and

00:12:49.150 --> 00:12:51.670
says, make me a complex number,
well I compute the

00:12:51.670 --> 00:12:54.280
real-part and the
imaginary-part, or our cosine

00:12:54.280 --> 00:12:58.120
of a and our sine of
a, and stick them

00:12:58.120 --> 00:13:01.460
together into a pair.

00:13:01.460 --> 00:13:02.260
OK so we're done.

00:13:02.260 --> 00:13:07.830
In fact, what I just did,
conceptually, is absolutely no

00:13:07.830 --> 00:13:11.710
different from the rational
number representation that we

00:13:11.710 --> 00:13:12.510
looked at last time.

00:13:12.510 --> 00:13:13.910
It's the same sort of idea.

00:13:13.910 --> 00:13:18.070
You implement the operators,
you pick a representation.

00:13:18.070 --> 00:13:20.070
Nothing different.

00:13:20.070 --> 00:13:23.210
Now let's worry about Martha.

00:13:23.210 --> 00:13:26.670
See, Martha has a
different idea.

00:13:26.670 --> 00:13:29.490
She doesn't want to represent a
complex number as a pair of

00:13:29.490 --> 00:13:30.900
a real-part and an
imaginary-part.

00:13:30.900 --> 00:13:34.170
What she would like to do is
represent a complex number as

00:13:34.170 --> 00:13:39.550
a pair of a magnitude
and an angle.

00:13:39.550 --> 00:13:42.130
So if instead of calling up
George we ask Martha to design

00:13:42.130 --> 00:13:44.570
our representation, we get
something like this.

00:13:44.570 --> 00:13:47.160
We get make-polar.

00:13:47.160 --> 00:13:50.220
Sure, if I give you a magnitude
and an angle we're

00:13:50.220 --> 00:13:55.430
just going to form a pair that
has magnitude and angle.

00:13:55.430 --> 00:13:57.680
If you want to extract the
magnitude, that's easy.

00:13:57.680 --> 00:13:59.780
You just pull out the
car or the pair.

00:13:59.780 --> 00:14:02.670
If you want to extract the
angle, sure, that's easy.

00:14:02.670 --> 00:14:05.480
You just pull out the cdr.
If you want to look for

00:14:05.480 --> 00:14:07.660
real-parts and imaginary-parts,
well then you

00:14:07.660 --> 00:14:08.590
have to do some work.

00:14:08.590 --> 00:14:14.580
If you want the real-part, you
have to get r cosine a.

00:14:14.580 --> 00:14:19.990
In other words, r, the car of
the pair, times the cosine of

00:14:19.990 --> 00:14:20.910
the cdr of the pair.

00:14:20.910 --> 00:14:26.230
So this is r times
the cosine of a,

00:14:26.230 --> 00:14:28.330
and that's the real-part.

00:14:28.330 --> 00:14:30.810
If you want to get the
imaginary-part, it's r times

00:14:30.810 --> 00:14:32.660
the sine of a.

00:14:32.660 --> 00:14:37.930
And if I hand you a real-part
and an imaginary-part and say,

00:14:37.930 --> 00:14:42.030
make me a complex number
with that real-part and

00:14:42.030 --> 00:14:44.170
imaginary-part, well I figure
out what the magnitude and

00:14:44.170 --> 00:14:45.540
angle should be.

00:14:45.540 --> 00:14:48.090
The magnitude's the square root
of the sum of the squares

00:14:48.090 --> 00:14:49.230
and the angle's the
arctangent.

00:14:49.230 --> 00:14:52.090
I put those together
to make a pair.

00:14:52.090 --> 00:14:54.170
So there's Martha's idea.

00:14:56.690 --> 00:14:59.680
Well which is better?

00:14:59.680 --> 00:15:02.850
Well if you're doing a lot of
additions, probably George's

00:15:02.850 --> 00:15:04.810
is better, because you're doing
a lot of real-parts and

00:15:04.810 --> 00:15:05.850
imaginary-parts.

00:15:05.850 --> 00:15:07.920
If mostly you're going to be
doing multiplications and

00:15:07.920 --> 00:15:11.140
divisions, then maybe Martha's
idea is better.

00:15:11.140 --> 00:15:16.590
Or maybe, and this is the real
point, you can't decide.

00:15:16.590 --> 00:15:21.170
Or maybe you just have to let
them both hang around, for

00:15:21.170 --> 00:15:23.480
personality reasons.

00:15:23.480 --> 00:15:25.870
Maybe you just really
can't ever decide

00:15:25.870 --> 00:15:28.560
what you would like.

00:15:28.560 --> 00:15:31.520
And again, what we would really
like is a system that

00:15:31.520 --> 00:15:32.320
looks like this.

00:15:32.320 --> 00:15:37.090
That somehow there's George
over here, who has built

00:15:37.090 --> 00:15:41.470
rectangular complex numbers.

00:15:41.470 --> 00:15:46.120
And Martha, who has polar
complex numbers.

00:15:46.120 --> 00:15:54.200
And somehow we have operations
that can add, and subtract,

00:15:54.200 --> 00:15:59.710
and multiply, and divide, and it
shouldn't matter that there

00:15:59.710 --> 00:16:02.790
are two incompatible
representations of complex

00:16:02.790 --> 00:16:04.410
numbers floating around
this system.

00:16:04.410 --> 00:16:09.640
In other words, not only like
an abstraction barrier here

00:16:09.640 --> 00:16:15.770
that has things in it like
a real-part, and an

00:16:15.770 --> 00:16:23.830
imaginary-part, and magnitude,
and angle.

00:16:23.830 --> 00:16:26.850
So not only is there an
abstraction barrier that hides

00:16:26.850 --> 00:16:30.310
the actual representation from
us, but also there's some kind

00:16:30.310 --> 00:16:33.620
of vertical barrier here that
allows both of these

00:16:33.620 --> 00:16:36.270
representations to
exist without

00:16:36.270 --> 00:16:38.570
interfering with each other.

00:16:38.570 --> 00:16:41.900
The idea is that the
things in here--

00:16:41.900 --> 00:16:44.120
real-part, imaginary-part,
magnitude, and angle--

00:16:44.120 --> 00:16:47.310
will be generic operators.

00:16:47.310 --> 00:16:50.190
If you ask for the real-part,
it will worry about what

00:16:50.190 --> 00:16:53.880
representation it's
looking at.

00:16:53.880 --> 00:16:56.840
OK, well how can we do that?

00:16:56.840 --> 00:17:00.290
There's actually a really
obvious idea, if you're used

00:17:00.290 --> 00:17:02.770
to thinking about
complex numbers.

00:17:02.770 --> 00:17:06.390
If you're used to thinking
about compound data.

00:17:06.390 --> 00:17:10.690
See, suppose you could just tell
by looking at a complex

00:17:10.690 --> 00:17:13.190
number whether it
was constructed

00:17:13.190 --> 00:17:15.790
by George or Martha.

00:17:15.790 --> 00:17:18.900
In other words, so it's not that
what's floating around

00:17:18.900 --> 00:17:20.910
here are ordinary, just complex
numbers, right?

00:17:20.910 --> 00:17:24.390
They're fancy, designer
complex numbers.

00:17:24.390 --> 00:17:27.260
So you look at a complex numbers
as it's not just a

00:17:27.260 --> 00:17:29.190
complex number, it's got a label
on it that says, this

00:17:29.190 --> 00:17:31.450
one is by Martha.

00:17:31.450 --> 00:17:34.480
Or this is a complex
number by George.

00:17:34.480 --> 00:17:34.700
Right?

00:17:34.700 --> 00:17:36.860
They're signed.

00:17:36.860 --> 00:17:40.155
See, and then whenever we looked
at a complex number we

00:17:40.155 --> 00:17:45.800
could just read the label, and
then we'd know how you expect

00:17:45.800 --> 00:17:48.030
to operate on that.

00:17:48.030 --> 00:17:49.850
In other words, what
we want is not just

00:17:49.850 --> 00:17:51.190
ordinary data objects.

00:17:51.190 --> 00:17:53.120
We want to introduce the
notion of what's

00:17:53.120 --> 00:17:54.370
called typed data.

00:17:59.760 --> 00:18:03.940
Typed data means, again, there's
some sort of cloud.

00:18:03.940 --> 00:18:08.930
And what it's got in it is an
ordinary data object like

00:18:08.930 --> 00:18:10.180
we've been thinking about.

00:18:13.180 --> 00:18:16.540
Pulled out the contents, sort
of the actual data.

00:18:19.320 --> 00:18:24.220
But also a thing called a
type, but it's signed by

00:18:24.220 --> 00:18:25.850
either George or Martha.

00:18:25.850 --> 00:18:28.340
So we're going to go from
regular data to type data.

00:18:31.950 --> 00:18:32.710
How do we build that?

00:18:32.710 --> 00:18:33.990
Well that's easy.

00:18:33.990 --> 00:18:34.980
We know how to build clouds.

00:18:34.980 --> 00:18:37.920
We build them out of pairs.

00:18:37.920 --> 00:18:41.050
So here's a little
representation that supports

00:18:41.050 --> 00:18:43.510
typed data.

00:18:43.510 --> 00:18:49.020
There's a thing called take a
type and attach it to a piece

00:18:49.020 --> 00:18:51.530
of contents, and we
just use cons.

00:18:51.530 --> 00:18:53.770
And if we have a piece of typed
data, we can look at the

00:18:53.770 --> 00:18:56.290
type, which is the car.

00:18:56.290 --> 00:19:00.460
We can look at the contents,
which is the cdr. Now along

00:19:00.460 --> 00:19:05.420
with that, the way we use our
type data will test, when

00:19:05.420 --> 00:19:07.520
we're given a piece of data,
what type it is.

00:19:07.520 --> 00:19:10.510
So we have some type
predicates with us.

00:19:10.510 --> 00:19:13.730
For example, to see whether
a complex number is one of

00:19:13.730 --> 00:19:16.860
George's, whether it's
rectangular, we just check to

00:19:16.860 --> 00:19:23.850
see if the type of that is the
symbol rectangular, right?

00:19:23.850 --> 00:19:25.100
The symbol rectangular.

00:19:27.200 --> 00:19:30.650
And to check whether a complex
number is one of Martha's, we

00:19:30.650 --> 00:19:33.430
check to see whether the type
is the symbol polar.

00:19:36.460 --> 00:19:38.710
So that's a way to test
what kind of number

00:19:38.710 --> 00:19:40.350
we're looking at.

00:19:40.350 --> 00:19:42.070
Now let's think about
how we can use that

00:19:42.070 --> 00:19:43.870
to build the system.

00:19:43.870 --> 00:19:46.170
So let's suppose that George
and Martha were off working

00:19:46.170 --> 00:19:50.710
separately, and each of them
had designed their complex

00:19:50.710 --> 00:19:52.640
number representation
packages.

00:19:52.640 --> 00:19:58.980
What do they have to do to
become part of the system, to

00:19:58.980 --> 00:20:00.140
exist compatibly?

00:20:00.140 --> 00:20:02.860
Well it's really pretty easy.

00:20:02.860 --> 00:20:05.970
Remember, George had
this package.

00:20:05.970 --> 00:20:08.980
Here's George's original
package, or half of it.

00:20:08.980 --> 00:20:12.090
And underlined in red are the
changes he has to make.

00:20:12.090 --> 00:20:16.010
So before, when George made a
complex number out of an x and

00:20:16.010 --> 00:20:20.930
y, he just put them together
to make a pair.

00:20:20.930 --> 00:20:24.090
And the only difference is
that now he signs them.

00:20:24.090 --> 00:20:26.920
He attaches the type,
which is the symbol

00:20:26.920 --> 00:20:30.600
rectangular to that pair.

00:20:30.600 --> 00:20:33.920
Everything else George does
is the same, except that--

00:20:33.920 --> 00:20:35.970
see, George and Martha both
have procedures named

00:20:35.970 --> 00:20:38.700
real-part and imaginary-part.

00:20:38.700 --> 00:20:44.220
So to allow them both to exist
in the same Lisp environment,

00:20:44.220 --> 00:20:45.920
George had changed the names
of his procedures.

00:20:45.920 --> 00:20:49.045
So we'll say, this is George's
real-part procedure.

00:20:49.045 --> 00:20:52.710
It's the real-part rectangular
procedure, the imaginary-part

00:20:52.710 --> 00:20:55.170
rectangular procedure.

00:20:55.170 --> 00:20:59.130
And then here's the rest
of George's package.

00:20:59.130 --> 00:21:02.060
He'd had magnitude and angle,
just renames them magnitude

00:21:02.060 --> 00:21:05.702
rectangular and angle
rectangular.

00:21:05.702 --> 00:21:09.860
And Martha has to do basically
the same thing.

00:21:09.860 --> 00:21:15.200
Martha previously, when she made
a complex number out of a

00:21:15.200 --> 00:21:19.270
magnitude and angle,
she just cons them.

00:21:19.270 --> 00:21:25.330
Now she attaches the type polar,
and she changes the

00:21:25.330 --> 00:21:28.100
name so her real-part procedure
won't conflict in

00:21:28.100 --> 00:21:30.710
name with George's.

00:21:30.710 --> 00:21:34.540
It's a real-part-polar,
imaginary-part-polar,

00:21:34.540 --> 00:21:38.060
magnitude polar, and
angle polar.

00:21:45.000 --> 00:21:46.130
Now we have the system.

00:21:46.130 --> 00:21:49.160
Right there's George
and Martha.

00:21:49.160 --> 00:21:51.050
And now we've got to get some
kind of manager to look at

00:21:51.050 --> 00:21:52.300
these types.

00:21:55.050 --> 00:21:57.530
How are these things actually
going to work now that George

00:21:57.530 --> 00:22:00.530
and Martha have supplied
us with typed data?

00:22:00.530 --> 00:22:05.260
Well what we have are a bunch
of generic selectors.

00:22:05.260 --> 00:22:07.800
Generic selectors for complex
numbers real-part,

00:22:07.800 --> 00:22:10.630
imaginary-part, magnitude,
and angle.

00:22:14.140 --> 00:22:15.410
Let's look at them
more closely.

00:22:17.930 --> 00:22:19.310
What does a real-part do?

00:22:19.310 --> 00:22:24.070
If I ask for the real part
of a complex number,

00:22:24.070 --> 00:22:25.800
well I look at it.

00:22:25.800 --> 00:22:26.690
I look at its type.

00:22:26.690 --> 00:22:27.940
I say, is it rectangular?

00:22:31.020 --> 00:22:36.970
If so, I apply George's real
part procedure to the contents

00:22:36.970 --> 00:22:38.220
of that complex number.

00:22:41.230 --> 00:22:43.720
This is a number that
has a type on it.

00:22:43.720 --> 00:22:46.340
I strip off the type
using contents and

00:22:46.340 --> 00:22:47.590
apply George's procedure.

00:22:50.700 --> 00:22:53.950
Or is this a polar
complex number?

00:22:53.950 --> 00:22:56.890
If I want the real part, I
apply Martha's real part

00:22:56.890 --> 00:22:59.850
procedure to the contents
of that number.

00:22:59.850 --> 00:23:02.260
So that's how real part works.

00:23:02.260 --> 00:23:04.670
And then similarly there's
imaginary-part, which is

00:23:04.670 --> 00:23:06.770
almost the same.

00:23:06.770 --> 00:23:09.600
It looks at the number and
if it's rectangular, uses

00:23:09.600 --> 00:23:11.130
George's imaginary-part
procedure.

00:23:11.130 --> 00:23:13.380
If it's polar, uses Martha's.

00:23:13.380 --> 00:23:17.240
And then there's a magnitude
and an angle.

00:23:19.880 --> 00:23:21.130
So there's a system.

00:23:23.460 --> 00:23:24.260
Has three parts.

00:23:24.260 --> 00:23:26.760
There's sort of George, and
Martha, and the manager.

00:23:26.760 --> 00:23:28.970
And that's how you get generic
operators implemented.

00:23:28.970 --> 00:23:33.500
Let's look at just a simple
example, just to pin it down.

00:23:33.500 --> 00:23:40.240
But exactly how this is going to
work, suppose you're going

00:23:40.240 --> 00:23:44.460
to be looking at the complex
number who's real-part is one,

00:23:44.460 --> 00:23:46.090
and who's imaginary-part
is two.

00:23:46.090 --> 00:23:50.310
So that would be one plus 2i.

00:23:50.310 --> 00:23:56.350
What would happen is up here,
up here above where the

00:23:56.350 --> 00:23:58.530
operations have to happen,
that number would be

00:23:58.530 --> 00:24:10.320
represented as a pair of 1 and
2 together with typed data.

00:24:10.320 --> 00:24:11.870
That would be the contents.

00:24:11.870 --> 00:24:16.300
And the whole data would be
that thing with the symbol

00:24:16.300 --> 00:24:17.960
rectangular added onto that.

00:24:17.960 --> 00:24:20.980
And that's the way that complex
number would exist in

00:24:20.980 --> 00:24:22.330
the system.

00:24:22.330 --> 00:24:26.560
When you went to take the
real-part, the manager would

00:24:26.560 --> 00:24:30.270
look at this and say, oh
it's one of George's.

00:24:30.270 --> 00:24:34.440
He'll strip off the type
and hand down to

00:24:34.440 --> 00:24:37.532
George the pair 1, 2.

00:24:37.532 --> 00:24:41.420
And that's the kind of data
that George developed his

00:24:41.420 --> 00:24:42.670
system to use.

00:24:44.950 --> 00:24:46.680
So it gets stripped down.

00:24:46.680 --> 00:24:51.240
Later on, if you ask George to
construct a complex number,

00:24:51.240 --> 00:24:55.370
George would construct some
complex number as a pair, and

00:24:55.370 --> 00:24:59.630
before he passes it back up
through the manager would

00:24:59.630 --> 00:25:00.880
attach the type rectangular.

00:25:03.920 --> 00:25:04.650
So you see what happens.

00:25:04.650 --> 00:25:05.850
There's no confusion
in this system.

00:25:05.850 --> 00:25:13.780
It doesn't matter in the least
that the pair 1, 2 means

00:25:13.780 --> 00:25:15.750
something completely different
in Martha's world.

00:25:15.750 --> 00:25:18.440
In Martha's world this pair
means the complex number whose

00:25:18.440 --> 00:25:21.190
magnitude is 1 and
whose angle is 2.

00:25:21.190 --> 00:25:23.930
And there's no confusion,
because by the time any pair

00:25:23.930 --> 00:25:27.250
like this gets handed back
through the manager to the

00:25:27.250 --> 00:25:31.210
main system it's going to have
the type polar attached.

00:25:31.210 --> 00:25:33.670
Whereas this one would have the
type rectangular attached.

00:25:36.930 --> 00:25:38.180
OK, let's take a break.

00:25:40.770 --> 00:25:41.057
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY

00:25:41.057 --> 00:25:42.307
JOHANN SEBASTIAN BACH]

00:26:20.210 --> 00:26:22.080
We just looked at
a strategy for

00:26:22.080 --> 00:26:24.150
implementing generic operators.

00:26:24.150 --> 00:26:31.400
That strategy has a name: it's
called dispatch type.

00:26:34.310 --> 00:26:38.480
And the idea is that you
break your system

00:26:38.480 --> 00:26:39.360
into a bunch of pieces.

00:26:39.360 --> 00:26:43.250
There's George and Martha, who
are making representations,

00:26:43.250 --> 00:26:46.320
and then there's the manager.

00:26:46.320 --> 00:26:49.880
Looks at the types on the data
and then dispatches them to

00:26:49.880 --> 00:26:51.990
the right person.

00:26:51.990 --> 00:26:55.320
Well what criticisms can we
make of that as a system

00:26:55.320 --> 00:26:56.570
organization?

00:26:58.150 --> 00:27:00.400
Well first of all there was this
little, annoying problem

00:27:00.400 --> 00:27:02.350
that George and Martha had to
change the names of their

00:27:02.350 --> 00:27:04.220
procedures.

00:27:04.220 --> 00:27:06.160
George originally had a
real-part procedure, and he

00:27:06.160 --> 00:27:09.110
had to go name it real-part
rectangular so it wouldn't

00:27:09.110 --> 00:27:11.170
interfere with Martha's
real-part procedure, which is

00:27:11.170 --> 00:27:14.410
now named real-part-polar, so it
wouldn't interfere with the

00:27:14.410 --> 00:27:17.310
manager's real-part procedure,
who's now named real-part.

00:27:17.310 --> 00:27:19.460
That's kind of an annoying
problem.

00:27:19.460 --> 00:27:21.270
But I'm not going to talk
about that one now.

00:27:21.270 --> 00:27:24.450
We'll see later on when we think
about the structure of

00:27:24.450 --> 00:27:27.480
Lisp names and environments that
there really are ways to

00:27:27.480 --> 00:27:30.390
package all those so-called name
spaces separately so they

00:27:30.390 --> 00:27:32.500
don't interfere with
each other.

00:27:32.500 --> 00:27:35.720
Not going to think about
that problem now.

00:27:35.720 --> 00:27:38.740
The problem that I actually
want to focus on is what

00:27:38.740 --> 00:27:44.510
happens when you bring somebody
new into the system.

00:27:44.510 --> 00:27:45.320
What has to happen?

00:27:45.320 --> 00:27:47.690
Well George and Martha
don't care.

00:27:47.690 --> 00:27:52.830
George is sitting there in his
rectangular world, has his

00:27:52.830 --> 00:27:54.090
procedures and his types.

00:27:54.090 --> 00:27:56.260
Martha sits in her
polar world.

00:27:56.260 --> 00:27:59.380
She doesn't care.

00:27:59.380 --> 00:28:01.540
But let's look at the manager.

00:28:01.540 --> 00:28:03.180
What's the manager have to do?

00:28:03.180 --> 00:28:07.360
The manager comes through and
had these operations.

00:28:07.360 --> 00:28:09.040
There was a test
for rectangular

00:28:09.040 --> 00:28:10.140
and a test for polar.

00:28:10.140 --> 00:28:17.210
If Harry comes in with some new
kind of complex number,

00:28:17.210 --> 00:28:20.430
and Harry has a new type, Harry
type complex number, the

00:28:20.430 --> 00:28:25.240
manager has to go in and change
all those procedures.

00:28:25.240 --> 00:28:28.940
So the inflexibility in the
system, the place where work

00:28:28.940 --> 00:28:34.890
has to happen to accommodate
change, is in the manager.

00:28:34.890 --> 00:28:35.990
That's pretty annoying.

00:28:35.990 --> 00:28:40.300
It's even more annoying when you
realize the manager's not

00:28:40.300 --> 00:28:42.590
doing anything.

00:28:42.590 --> 00:28:46.690
The manager is just being
a paper pusher.

00:28:46.690 --> 00:28:51.760
Let's look again at these
programs. What are they doing?

00:28:51.760 --> 00:28:52.880
What does real-part do?

00:28:52.880 --> 00:28:56.170
Real-part says, oh, is it the
kind of complex number that

00:28:56.170 --> 00:28:57.000
George can handle?

00:28:57.000 --> 00:28:59.410
If so, send it off to George.

00:28:59.410 --> 00:29:01.910
Is it the kind of complex number
that Martha can handle?

00:29:01.910 --> 00:29:05.040
If so, send it off to Martha.

00:29:05.040 --> 00:29:08.720
So it's really annoying that the
bottleneck in this system,

00:29:08.720 --> 00:29:13.040
the thing that's preventing
flexibility and change, is

00:29:13.040 --> 00:29:15.000
completely in the bureaucracy.

00:29:15.000 --> 00:29:19.700
It's not in anybody who's
doing any of the work.

00:29:19.700 --> 00:29:23.300
Not an uncommon situation,
unfortunately.

00:29:23.300 --> 00:29:24.570
See, what's really going on--

00:29:24.570 --> 00:29:28.100
abstractly in the system,
there's a table.

00:29:28.100 --> 00:29:30.150
So what's really happening is
somewhere there's a table.

00:29:32.780 --> 00:29:34.400
There're types.

00:29:34.400 --> 00:29:38.565
There's polar and rectangular.

00:29:41.550 --> 00:29:44.380
And Harry's may be over here.

00:29:44.380 --> 00:29:48.050
And there are operators.

00:29:48.050 --> 00:29:50.340
There's an operator
like real-part.

00:29:55.600 --> 00:30:00.010
Or imaginary-part.

00:30:00.010 --> 00:30:05.830
Or a magnitude and angle.

00:30:05.830 --> 00:30:19.280
And sitting in this table are
the right procedures.

00:30:19.280 --> 00:30:21.990
So sitting here for the type
polar and real-part is

00:30:21.990 --> 00:30:24.730
Martha's procedure
real-part-polar.

00:30:30.570 --> 00:30:33.740
And over here in the table
is George's procedure

00:30:33.740 --> 00:30:34.990
real-part-rectangular.

00:30:37.740 --> 00:30:40.680
And over here would be, say,
Martha's procedure

00:30:40.680 --> 00:30:46.780
magnitude-polar, and
George's procedure

00:30:46.780 --> 00:30:49.760
magnitude-rectangular,
right, and so on.

00:30:49.760 --> 00:30:52.390
The rest of this table's
filled in.

00:30:52.390 --> 00:30:54.260
And that's really
what's going on.

00:30:57.630 --> 00:31:03.380
So in some sense, all the
manager is doing is acting as

00:31:03.380 --> 00:31:04.630
this table.

00:31:06.860 --> 00:31:08.610
Well how do we fix our system?

00:31:12.110 --> 00:31:13.770
How do you fix bureaucracies
a lot of the time?

00:31:13.770 --> 00:31:16.240
What you do is you get
rid of the manager.

00:31:16.240 --> 00:31:20.170
We just take the manager and
replace him by a computer.

00:31:20.170 --> 00:31:23.320
We're going to automate
him out of existence.

00:31:23.320 --> 00:31:25.970
Namely, instead of having the
manager who basically consults

00:31:25.970 --> 00:31:31.020
this table, we'll have our
system use the table directly.

00:31:31.020 --> 00:31:32.110
What do I mean by that?

00:31:32.110 --> 00:31:38.730
Let's assume, again using data
abstraction, that we have some

00:31:38.730 --> 00:31:40.880
kind of data structure
that's a table.

00:31:40.880 --> 00:31:43.080
And we have ways of sticking
things in and ways of getting

00:31:43.080 --> 00:31:44.356
things out.

00:31:44.356 --> 00:31:47.000
And to be explicit, let me
assume that there's an

00:31:47.000 --> 00:31:52.710
operation called "put." And put
is going to take, in this

00:31:52.710 --> 00:32:00.130
case two things I'll call
"keys." Key1 and key2.

00:32:00.130 --> 00:32:01.380
And a value.

00:32:06.200 --> 00:32:11.490
And that stores the value in the
table under key1 and key2.

00:32:11.490 --> 00:32:15.530
And then we'll assume there's
a thing called "get," such

00:32:15.530 --> 00:32:19.680
that if later on I say, get me
what's in the table stored

00:32:19.680 --> 00:32:25.010
under key1 and key2, it'll
retrieve whatever value was

00:32:25.010 --> 00:32:26.730
stored there.

00:32:26.730 --> 00:32:30.000
And let's not worry about how
tables are implemented.

00:32:30.000 --> 00:32:33.060
That's yet another data
abstraction, George's problem.

00:32:33.060 --> 00:32:34.700
And maybe we'll see later--

00:32:34.700 --> 00:32:36.970
talk about how you might
actually build tables in Lisp.

00:32:40.710 --> 00:32:44.850
Well given this organization,
what did George and Martha

00:32:44.850 --> 00:32:47.380
have to do?

00:32:47.380 --> 00:32:50.010
Well when they build their
system, they each have the

00:32:50.010 --> 00:32:52.750
responsibility to set
up their appropriate

00:32:52.750 --> 00:32:55.210
column in the table.

00:32:55.210 --> 00:33:00.620
So what George does, for
example, when he defines his

00:33:00.620 --> 00:33:04.020
procedures, all he has to do
is go off and put into the

00:33:04.020 --> 00:33:06.990
table under the
type-rectangular.

00:33:09.820 --> 00:33:14.100
And the name of the operation
is real-part, his procedure

00:33:14.100 --> 00:33:16.250
real-part-rectangular.

00:33:16.250 --> 00:33:17.780
So notice what's going
into this table.

00:33:17.780 --> 00:33:22.100
The two keys here are symbols,
rectangular and real-part.

00:33:22.100 --> 00:33:24.400
That's the quote.

00:33:24.400 --> 00:33:27.410
And what's going into the table
is the actual procedure

00:33:27.410 --> 00:33:28.870
that he wrote, real-part
rectangular.

00:33:32.040 --> 00:33:35.000
And then puts an imaginary part
into the table, filed

00:33:35.000 --> 00:33:39.370
under the keys rectangular-
and imaginary-part, and

00:33:39.370 --> 00:33:44.020
magnitude under the keys
rectangular magnitude, angle

00:33:44.020 --> 00:33:45.270
under rectangular-angle.

00:33:47.350 --> 00:33:50.840
So that's what George has to do
to be part of this system.

00:33:54.420 --> 00:33:57.740
Martha similarly sets
up the column and

00:33:57.740 --> 00:33:59.430
the table under polar.

00:33:59.430 --> 00:34:02.160
Polar and real-part.

00:34:02.160 --> 00:34:04.340
Is the procedure
real-part-polar?

00:34:04.340 --> 00:34:09.030
And imaginary-part, and
magnitude, and angle.

00:34:09.030 --> 00:34:11.409
So this is what Martha has to
do to be part of the system.

00:34:11.409 --> 00:34:13.550
Everyone who makes a
representation has the

00:34:13.550 --> 00:34:17.840
responsibility for setting
up a column in the table.

00:34:17.840 --> 00:34:19.900
And what does Harry do when
Harry comes in with his

00:34:19.900 --> 00:34:21.800
brilliant idea for implementing
complex numbers?

00:34:21.800 --> 00:34:25.170
Well he makes whatever procedure
he wants and builds

00:34:25.170 --> 00:34:28.550
a new column in this table.

00:34:28.550 --> 00:34:31.330
OK, well what happened
to the manager?

00:34:31.330 --> 00:34:34.610
The manager has been automated
out of existence and is

00:34:34.610 --> 00:34:37.110
replaced by a procedure
called operate.

00:34:37.110 --> 00:34:40.380
And this is the key procedure
in the whole system.

00:34:40.380 --> 00:34:45.920
Let's say define operate.

00:34:51.060 --> 00:34:57.750
Operate is going to take an
operation that you want to do,

00:34:57.750 --> 00:35:01.840
the name of an operation, and an
object that you would like

00:35:01.840 --> 00:35:04.210
to apply that operation to.

00:35:04.210 --> 00:35:07.400
So for example, the real-part
of some particular complex

00:35:07.400 --> 00:35:09.890
number, what does it do?

00:35:09.890 --> 00:35:12.650
Well the first thing it does,
it looks in the table.

00:35:12.650 --> 00:35:20.710
Goes into the table and tries
to find a procedure that's

00:35:20.710 --> 00:35:23.320
stored in the table.

00:35:23.320 --> 00:35:29.830
So it gets from the table, using
as keys the type of the

00:35:29.830 --> 00:35:40.450
object and the operator, but
looks on the table and sees

00:35:40.450 --> 00:35:42.300
what's stored under the type
of the object and the

00:35:42.300 --> 00:35:44.440
operator, sees if anything's
stored.

00:35:44.440 --> 00:35:45.930
Let's assume that get
is implemented.

00:35:45.930 --> 00:35:52.560
So if nothing is stored there,
it'll return the empty list.

00:35:52.560 --> 00:35:55.130
So it says, if there's actually
something stored

00:35:55.130 --> 00:36:04.920
there, if the procedure here is
not no, then it'll take the

00:36:04.920 --> 00:36:11.240
procedure that it found in the
table and apply it to the

00:36:11.240 --> 00:36:15.120
contents of the object.

00:36:18.042 --> 00:36:21.445
And otherwise if there was
nothing stored there, it'll--

00:36:21.445 --> 00:36:22.435
well we can decide.

00:36:22.435 --> 00:36:25.920
In this case let's have it put
out an error message saying,

00:36:25.920 --> 00:36:28.650
undefined operator.

00:36:28.650 --> 00:36:30.230
No operator for this type.

00:36:32.770 --> 00:36:34.285
Or some appropriate
error message.

00:36:39.150 --> 00:36:39.300
OK?

00:36:39.300 --> 00:36:41.890
And that replaces the manager.

00:36:41.890 --> 00:36:43.960
How do we really use it?

00:36:43.960 --> 00:36:48.580
Well what we say is we'll go
off and define our generic

00:36:48.580 --> 00:36:50.040
selectors using operate.

00:36:50.040 --> 00:36:57.140
We'll say that the real-part
of an object is found by

00:36:57.140 --> 00:37:05.010
operating on the object with
the name of the operation

00:37:05.010 --> 00:37:06.260
being real-part.

00:37:08.070 --> 00:37:10.870
And then similarly,
imaginary-part is operate

00:37:10.870 --> 00:37:16.080
using the name imaginary-part
and magnitude and angle.

00:37:16.080 --> 00:37:17.430
That's our implementation.

00:37:17.430 --> 00:37:21.330
That plus the tape plus
the operate procedure.

00:37:21.330 --> 00:37:23.100
And the table effectively
replaces what the

00:37:23.100 --> 00:37:24.150
manager used to do.

00:37:24.150 --> 00:37:27.040
Let's just go through that
slowly to show you

00:37:27.040 --> 00:37:27.900
what's going on.

00:37:27.900 --> 00:37:33.000
Suppose I have one of Martha's
complex numbers.

00:37:35.520 --> 00:37:39.100
It's got magnitude
1 and angle 2.

00:37:39.100 --> 00:37:40.220
And it's one of Martha's.

00:37:40.220 --> 00:37:47.120
So it's labeled here, polar.

00:37:47.120 --> 00:37:48.000
Let's call that z.

00:37:48.000 --> 00:37:49.250
Suppose that's z.

00:37:51.770 --> 00:37:54.320
And suppose with this
implementation someone comes

00:37:54.320 --> 00:37:57.110
up and asks for the
real-part of z.

00:38:04.870 --> 00:38:08.920
Well real-part now is defined
in terms of operate.

00:38:08.920 --> 00:38:18.470
So that's equivalent to saying
operate with the name of the

00:38:18.470 --> 00:38:27.060
operator being real-part, the
symbol real-part on z.

00:38:27.060 --> 00:38:28.090
And now operate comes.

00:38:28.090 --> 00:38:31.720
It's going to look in the table,
and it's going to try

00:38:31.720 --> 00:38:34.005
and find something
stored under--

00:38:38.830 --> 00:38:42.160
the operation is going to apply
by looking in the table

00:38:42.160 --> 00:38:46.225
under the type of the object.

00:38:46.225 --> 00:38:48.790
And the type of z is polar.

00:38:48.790 --> 00:38:52.990
So it's going to look and say,
can I get using polar?

00:38:52.990 --> 00:38:58.250
And the operation name,
which was real-part.

00:39:05.960 --> 00:39:09.490
It's going to look in there
and apply that to

00:39:09.490 --> 00:39:14.930
the contents of z.

00:39:14.930 --> 00:39:15.650
And that?

00:39:15.650 --> 00:39:20.350
If everything was set up
correctly, this thing is the

00:39:20.350 --> 00:39:21.700
procedure that Martha
put there.

00:39:21.700 --> 00:39:22.950
This is real-part-polar.

00:39:30.790 --> 00:39:35.130
And this is z without
its type.

00:39:35.130 --> 00:39:37.860
The thing that Martha originally
designed those

00:39:37.860 --> 00:39:40.340
procedures to work on,
which is 1, 2.

00:39:43.790 --> 00:39:47.210
And so operate sort of does
uniformly what the manager

00:39:47.210 --> 00:39:49.450
used to do sort of all
over the system.

00:39:49.450 --> 00:39:52.170
It finds the right thing, looks
in the table, strips off

00:39:52.170 --> 00:39:56.600
the type, and passes
it down into the

00:39:56.600 --> 00:39:59.160
person who handles it.

00:39:59.160 --> 00:40:04.980
This is another, and, you can
see, more flexible for most

00:40:04.980 --> 00:40:07.990
purposes, way of implementing
generic operators.

00:40:07.990 --> 00:40:15.505
And it's called data-directed
programming.

00:40:20.350 --> 00:40:24.920
And the idea of that is in some
sense the data objects

00:40:24.920 --> 00:40:27.260
themselves, those little complex
numbers that are

00:40:27.260 --> 00:40:30.340
floating around the system,
are carrying with them the

00:40:30.340 --> 00:40:35.390
information about how you
should operate on them.

00:40:35.390 --> 00:40:36.640
Let's break for questions.

00:40:41.000 --> 00:40:41.240
Yes.

00:40:41.240 --> 00:40:43.390
AUDIENCE: What do you have
stored in that data object?

00:40:43.390 --> 00:40:47.850
You have the data itself, you
have its type, and you have

00:40:47.850 --> 00:40:49.690
the operations for that type?

00:40:49.690 --> 00:40:53.600
Or where are the operations
that you found?

00:40:53.600 --> 00:40:54.980
PROFESSOR: OK, let me--

00:40:54.980 --> 00:40:56.500
yeah, that's a good question.

00:40:56.500 --> 00:40:59.700
Because it raises other
possibilities of how

00:40:59.700 --> 00:41:00.750
you might do it.

00:41:00.750 --> 00:41:04.200
And of course there are a
lot of possibilities.

00:41:04.200 --> 00:41:06.820
In this particular
implementation, what's sitting

00:41:06.820 --> 00:41:11.630
in this data object, for
example, is the data itself--

00:41:11.630 --> 00:41:14.980
which in this case is
a pair of 1 and 2--

00:41:14.980 --> 00:41:16.550
and also a symbol.

00:41:16.550 --> 00:41:21.140
This is the symbol, the word
P-O-L-A-R, and that's what's

00:41:21.140 --> 00:41:22.390
sitting in this data object.

00:41:24.870 --> 00:41:26.690
Where are the operations
themselves?

00:41:26.690 --> 00:41:29.850
The operations are sitting
in the table.

00:41:29.850 --> 00:41:35.450
So in this table, the rows and
columns of the table are

00:41:35.450 --> 00:41:38.230
labeled by symbols.

00:41:38.230 --> 00:41:40.810
So when I store something in
this table, the key might be

00:41:40.810 --> 00:41:48.240
the symbol polar and the
symbol magnitude.

00:41:48.240 --> 00:41:51.310
And I think by writing it this
way I've been very confusing.

00:41:51.310 --> 00:41:53.160
Because what's really
sitting here isn't--

00:41:53.160 --> 00:41:58.360
when I wrote magnitude polar,
what I mean is the procedure

00:41:58.360 --> 00:41:59.850
magnitude polar.

00:41:59.850 --> 00:42:02.580
And probably what I really
should have written--

00:42:02.580 --> 00:42:04.200
except it's too small
for me to write

00:42:04.200 --> 00:42:05.580
in this little space--

00:42:05.580 --> 00:42:11.250
is something like lambda
of z, the thing that

00:42:11.250 --> 00:42:14.710
Martha wrote to implement.

00:42:14.710 --> 00:42:16.620
And then you can see from that,
there's another way that

00:42:16.620 --> 00:42:20.250
I alluded to of solving this
name conflict problem, which

00:42:20.250 --> 00:42:22.380
is that George and Martha
never have to name their

00:42:22.380 --> 00:42:23.150
procedures at all.

00:42:23.150 --> 00:42:26.710
They can just stick the
anonymous things generated by

00:42:26.710 --> 00:42:28.660
lambda directly into
the table.

00:42:28.660 --> 00:42:32.540
There's also another thing that
your question raises, is

00:42:32.540 --> 00:42:36.045
the possibility that maybe what
I would like somehow is

00:42:36.045 --> 00:42:40.120
to store in this data object not
the symbol P-O-L-A-R but

00:42:40.120 --> 00:42:43.520
maybe actually all the
operations themselves.

00:42:43.520 --> 00:42:45.860
And that's another way to
organize the system, called

00:42:45.860 --> 00:42:48.650
message passing.

00:42:48.650 --> 00:42:49.970
So there are a lot of
ways you can do it.

00:42:54.640 --> 00:42:58.040
AUDIENCE: Therefore if Martha
and George had used the same

00:42:58.040 --> 00:43:01.230
procedure names, it would be
OK because it wouldn't look

00:43:01.230 --> 00:43:02.560
[UNINTELLIGIBLE].

00:43:02.560 --> 00:43:03.010
PROFESSOR: That's right.

00:43:03.010 --> 00:43:04.890
That's right.

00:43:04.890 --> 00:43:07.060
See, they wouldn't even
have to name their

00:43:07.060 --> 00:43:09.470
procedures at all.

00:43:09.470 --> 00:43:12.440
What George could have written
instead of saying put in the

00:43:12.440 --> 00:43:16.890
table under rectangular- and
real-part, the procedure

00:43:16.890 --> 00:43:19.660
real-part rectangular, George
could have written put under

00:43:19.660 --> 00:43:23.080
rectangular real-part, lambda
of z, such and such,

00:43:23.080 --> 00:43:24.540
and such and such.

00:43:24.540 --> 00:43:27.330
And the system would work
completely the same.

00:43:27.330 --> 00:43:31.750
AUDIENCE: My question is, Martha
could have put key1

00:43:31.750 --> 00:43:37.120
key2 real-part, and George
could have put key1 key2

00:43:37.120 --> 00:43:40.060
real-part, and as long as they
defined them differently they

00:43:40.060 --> 00:43:41.290
wouldn't have had any
conflicts, right?

00:43:41.290 --> 00:43:45.130
PROFESSOR: Yes, that would all
be OK except for the fact that

00:43:45.130 --> 00:43:47.130
if you imagine George and Martha
typing at the same

00:43:47.130 --> 00:43:50.090
console with the same meanings
for all their names, and it

00:43:50.090 --> 00:43:51.720
would get confused by real-part,
but there are ways

00:43:51.720 --> 00:43:52.800
to arrange that, too.

00:43:52.800 --> 00:43:54.980
And in principle you're
absolutely right.

00:43:54.980 --> 00:43:56.290
If their names didn't
conflict--

00:43:56.290 --> 00:43:58.190
it's the objects that go in
the table, not the names.

00:44:08.200 --> 00:44:09.450
OK, let's take a break.

00:44:12.493 --> 00:44:12.836
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY

00:44:12.836 --> 00:44:14.086
JOHANN SEBASTIAN BACH]

00:45:12.880 --> 00:45:17.680
All right, well we just looked
at data-directed programming

00:45:17.680 --> 00:45:21.590
as a way of implementing a
system that does arithmetic on

00:45:21.590 --> 00:45:22.840
complex numbers.

00:45:27.420 --> 00:45:32.880
So I had these operations in it
called plus C and minus C,

00:45:32.880 --> 00:45:38.230
and multiply, and divide,
and maybe some others.

00:45:38.230 --> 00:45:46.030
And that sat on top of-- and
this is the key point-- sat on

00:45:46.030 --> 00:45:50.340
top of two different
representations.

00:45:50.340 --> 00:45:55.110
A rectangular package here,
and a polar package.

00:45:58.240 --> 00:45:59.150
And maybe some more.

00:45:59.150 --> 00:46:01.640
And we saw that the whole idea
is that maybe some more are

00:46:01.640 --> 00:46:04.670
now very easy to add.

00:46:04.670 --> 00:46:08.900
But that doesn't really show the
power of this methodology.

00:46:08.900 --> 00:46:10.150
Shows you what's going on.

00:46:10.150 --> 00:46:13.260
The power of the methodology
only becomes apparent when you

00:46:13.260 --> 00:46:17.080
start embedding this in some
more complex system.

00:46:17.080 --> 00:46:19.180
What I'm going to do now is
embed this in some more

00:46:19.180 --> 00:46:20.250
complex system.

00:46:20.250 --> 00:46:23.960
Let's assume that what we really
have is a general kind

00:46:23.960 --> 00:46:25.280
of arithmetic system.

00:46:25.280 --> 00:46:27.240
So called generic arithmetic
system.

00:46:27.240 --> 00:46:32.060
And at the top level here,
somebody can say add two

00:46:32.060 --> 00:46:38.450
things, or subtract two things,
or multiply two

00:46:38.450 --> 00:46:41.180
things, or divide two things.

00:46:44.140 --> 00:46:47.930
And underneath that there's
an abstraction barrier.

00:46:47.930 --> 00:46:50.510
And underneath this barrier,
is, say, a

00:46:50.510 --> 00:46:52.850
complex arithmetic package.

00:46:52.850 --> 00:46:55.110
And you can say, add two
complex numbers.

00:46:55.110 --> 00:46:57.540
Or you might also have--
remember we did a rational

00:46:57.540 --> 00:47:00.190
number package-- you might
have that sitting there.

00:47:00.190 --> 00:47:03.950
And there might be
a rational thing.

00:47:03.950 --> 00:47:07.760
And the rational number package,
well, has the things

00:47:07.760 --> 00:47:08.320
we implemented.

00:47:08.320 --> 00:47:15.490
Plus rat, and times
rat, and so on.

00:47:15.490 --> 00:47:17.010
Or you might have ordinary
Lisp numbers.

00:47:17.010 --> 00:47:19.310
You might say add
three and four.

00:47:19.310 --> 00:47:29.030
So we might have ordinary
numbers, in which case we have

00:47:29.030 --> 00:47:36.670
the Lisp supplied plus, and
minus, and times, and slash.

00:47:36.670 --> 00:47:39.840
OK, so we might imagine this
complex number system sitting

00:47:39.840 --> 00:47:43.660
in a more complicated generic
operator structure at

00:47:43.660 --> 00:47:44.910
the next level up.

00:47:47.730 --> 00:47:49.050
Well how can we make that?

00:47:49.050 --> 00:47:50.240
We already have the
idea, we're just

00:47:50.240 --> 00:47:52.780
going to do it again.

00:47:52.780 --> 00:47:54.720
We've implemented a rational
number package.

00:47:54.720 --> 00:47:56.650
Let's look at how it
has to be changed.

00:48:01.590 --> 00:48:02.660
In fact, at this level
it doesn't have to

00:48:02.660 --> 00:48:03.730
be changed at all.

00:48:03.730 --> 00:48:07.180
This is exactly the code that
we wrote last time.

00:48:07.180 --> 00:48:10.140
To add two rational
numbers, remember

00:48:10.140 --> 00:48:11.140
there was this formula.

00:48:11.140 --> 00:48:14.980
You make a rational number
whose numerator--

00:48:14.980 --> 00:48:17.330
the numerator of the first times
the denominator of the

00:48:17.330 --> 00:48:20.486
second, plus the denominator
of the first times the

00:48:20.486 --> 00:48:21.520
numerator of the second.

00:48:21.520 --> 00:48:25.760
And who's denominator is the
product of the denominators.

00:48:25.760 --> 00:48:30.580
And minus rat, and star
rat, and slash rat.

00:48:30.580 --> 00:48:34.420
And this is exactly the rational
number package that

00:48:34.420 --> 00:48:36.310
we made before.

00:48:36.310 --> 00:48:38.390
We're ignoring the GCD problem,
but let's not worry

00:48:38.390 --> 00:48:40.240
about that.

00:48:40.240 --> 00:48:42.980
As implementers of this rational
number package, how

00:48:42.980 --> 00:48:45.570
do we install it in the generic
arithmetic system?

00:48:45.570 --> 00:48:46.820
Well that's easy.

00:48:48.980 --> 00:48:51.840
There's only one thing we
have to do differently.

00:48:51.840 --> 00:48:56.270
Whereas previously we said that
to make a rational number

00:48:56.270 --> 00:49:00.960
you built a pair of the
numerator and denominator,

00:49:00.960 --> 00:49:03.300
here we'll not only build the
pair, but we'll sign it.

00:49:03.300 --> 00:49:06.120
We'll attach the
type rational.

00:49:06.120 --> 00:49:08.940
That's the only thing we have
to do different, make it a

00:49:08.940 --> 00:49:12.380
typed data object.

00:49:12.380 --> 00:49:14.500
And now we'll stick our
operations in the table.

00:49:14.500 --> 00:49:18.920
We'll put under the symbol
rational and the operation add

00:49:18.920 --> 00:49:21.820
our procedure, plus rat.

00:49:21.820 --> 00:49:23.580
And, again, note this
is a symbol.

00:49:23.580 --> 00:49:23.930
Right?

00:49:23.930 --> 00:49:26.830
Quote, unquote, but the actual
thing we're putting in the

00:49:26.830 --> 00:49:30.060
table is the procedure.

00:49:30.060 --> 00:49:33.700
And for how to subtract,
well you subtract

00:49:33.700 --> 00:49:38.270
rationals with minus rat.

00:49:38.270 --> 00:49:41.090
And multiply, and divide.

00:49:41.090 --> 00:49:43.640
And that is exactly and
precisely what we have to do

00:49:43.640 --> 00:49:48.510
to fit inside this generic
arithmetic system.

00:49:48.510 --> 00:49:51.560
Well how does the whole
thing work?

00:49:51.560 --> 00:50:00.170
See, what we want to do is have
some generic operators.

00:50:00.170 --> 00:50:01.720
Have add and sub and
[UNINTELLIGIBLE]

00:50:01.720 --> 00:50:03.990
be generic operators.

00:50:03.990 --> 00:50:18.930
So we're going to define add and
say, to add x and y, that

00:50:18.930 --> 00:50:21.840
will be operate--

00:50:26.080 --> 00:50:27.490
we were going to call
it operate-2.

00:50:27.490 --> 00:50:30.350
This is our operator procedure,
but set up for two

00:50:30.350 --> 00:50:37.261
arguments using add
on x and y.

00:50:37.261 --> 00:50:40.420
And so this is the analog
to operate.

00:50:40.420 --> 00:50:41.680
Let's look at the
code for second.

00:50:41.680 --> 00:50:42.930
It's almost like operate.

00:50:46.040 --> 00:50:51.550
To operate with some operator
on an argument 1 and an

00:50:51.550 --> 00:50:56.370
argument 2, well the first thing
we're going to do is

00:50:56.370 --> 00:51:01.900
check and see if the two
arguments have the same type.

00:51:01.900 --> 00:51:06.610
So we'll say, is the type of the
first argument the same as

00:51:06.610 --> 00:51:07.860
the type of the second
argument?

00:51:10.350 --> 00:51:15.070
And if they're not, we'll go
off and complain, and say,

00:51:15.070 --> 00:51:15.670
that's an error.

00:51:15.670 --> 00:51:19.140
We don't know how to do that.

00:51:19.140 --> 00:51:20.920
If they do have the same
type, we'll do

00:51:20.920 --> 00:51:22.080
exactly what we did before.

00:51:22.080 --> 00:51:26.460
We'll go look and filed under
the type of the argument--

00:51:26.460 --> 00:51:30.420
arg 1 and arg 2 have the same
type, so it doesn't matter.

00:51:30.420 --> 00:51:33.640
So we'll look in the table,
find the procedure.

00:51:33.640 --> 00:51:38.870
If there is a procedure there,
then we'll apply it to the

00:51:38.870 --> 00:51:43.030
contents of the argument 1 and
the contents of arg 2.

00:51:43.030 --> 00:51:44.760
And otherwise we'll
say, error.

00:51:44.760 --> 00:51:46.890
Undefined operator.

00:51:46.890 --> 00:51:48.140
And so there's operate-2.

00:51:51.326 --> 00:51:55.160
And that's all we have to do.

00:51:55.160 --> 00:51:57.640
We just built the complex
number package before.

00:51:57.640 --> 00:52:00.140
How do we embed that complex
number package in

00:52:00.140 --> 00:52:02.140
this generic system?

00:52:02.140 --> 00:52:03.390
Almost the same.

00:52:06.410 --> 00:52:11.060
We make a procedure called
make-complex that takes

00:52:11.060 --> 00:52:14.100
whatever George and Martha
hand to us and add the

00:52:14.100 --> 00:52:15.350
type-complex.

00:52:18.170 --> 00:52:25.840
And then we say, to add complex
numbers, plus complex,

00:52:25.840 --> 00:52:32.240
we use our internal procedure,
plus c, and attach a type,

00:52:32.240 --> 00:52:33.490
make that a complex number.

00:52:37.560 --> 00:52:42.840
So our original package had
names plus c and minus c that

00:52:42.840 --> 00:52:45.250
we're using to communicate
with George and Martha.

00:52:45.250 --> 00:52:47.730
And then to communicate with the
outside world, we have a

00:52:47.730 --> 00:52:52.380
thing called plus-complex
and minus-complex.

00:52:55.920 --> 00:52:56.530
And so on.

00:52:56.530 --> 00:52:59.000
And the only difference
is that these return

00:52:59.000 --> 00:53:01.120
values that are tight.

00:53:01.120 --> 00:53:02.850
So they can be looked
at up here.

00:53:02.850 --> 00:53:04.690
And these are internal
operations.

00:53:09.250 --> 00:53:10.680
Let's go look at that
slide again.

00:53:10.680 --> 00:53:13.740
There's one more thing we do.

00:53:13.740 --> 00:53:19.280
After defining plus-complex, we
put under the type complex

00:53:19.280 --> 00:53:23.200
and the symbol add, that
procedure plus complex.

00:53:23.200 --> 00:53:27.130
And then similarly for
subtracting complex numbers,

00:53:27.130 --> 00:53:29.130
and multiplying them,
and dividing them.

00:53:31.700 --> 00:53:35.250
OK, how do we install
ordinary numbers?

00:53:35.250 --> 00:53:38.160
Exactly the same way.

00:53:38.160 --> 00:53:40.500
Come off and say, well we'll
make a thing called

00:53:40.500 --> 00:53:41.750
make-number.

00:53:44.340 --> 00:53:48.500
Make-number takes a number and
attaches a type, which is the

00:53:48.500 --> 00:53:50.260
symbol number.

00:53:50.260 --> 00:53:55.300
We build a procedure called
plus-number, which is simply,

00:53:55.300 --> 00:53:59.220
add the two things using the
ordinary addition, because in

00:53:59.220 --> 00:54:01.850
this case we're talking about
ordinary numbers, and attach a

00:54:01.850 --> 00:54:04.510
type to it and make
that a number.

00:54:04.510 --> 00:54:08.700
And then we put into the table
under the symbol number and

00:54:08.700 --> 00:54:12.550
the operation add, this
procedure plus-number, and

00:54:12.550 --> 00:54:15.360
then the same thing for
subtracting, and multiplying,

00:54:15.360 --> 00:54:16.610
and dividing.

00:54:22.750 --> 00:54:26.060
Let's look at an example,
just to make it clear.

00:54:26.060 --> 00:54:32.600
Suppose, for instance,
I'm going

00:54:32.600 --> 00:54:34.150
to perform the operation.

00:54:34.150 --> 00:54:38.220
So I sit up here and I'm going
to perform the operation,

00:54:38.220 --> 00:54:40.930
which looks like multiplying
two complex numbers.

00:54:40.930 --> 00:54:49.786
So I would multiply, say,
3 plus 4i and 2 plus 6i.

00:54:49.786 --> 00:54:51.740
And that's something that
I might want to take

00:54:51.740 --> 00:54:52.840
hand that to mul.

00:54:52.840 --> 00:54:57.170
I'll write mul as my generic
operator here.

00:54:57.170 --> 00:54:58.280
How's that going to work?

00:54:58.280 --> 00:55:05.020
Well 3 plus 4i, say, sits in
the system at this level as

00:55:05.020 --> 00:55:06.250
something that looks
like this.

00:55:06.250 --> 00:55:08.280
Let's say it was one
of George's.

00:55:08.280 --> 00:55:14.695
So it would have a 3 and a 4.

00:55:18.490 --> 00:55:25.330
And attached to that would be
George's type, which would say

00:55:25.330 --> 00:55:29.510
rectangular, it came
from George.

00:55:29.510 --> 00:55:31.230
And attached to that--

00:55:31.230 --> 00:55:35.630
and this itself would be the
data view from the next level

00:55:35.630 --> 00:55:37.700
up, which it is--

00:55:37.700 --> 00:55:41.030
so that itself would be a
type-data object which would

00:55:41.030 --> 00:55:42.280
say complex.

00:55:44.820 --> 00:55:49.240
So that's what this object would
look like up here at the

00:55:49.240 --> 00:55:52.300
very highest level, where
the really super-generic

00:55:52.300 --> 00:55:55.560
operations are looking at it.

00:55:55.560 --> 00:55:58.220
Now what happens, mul
eventually's going to come

00:55:58.220 --> 00:56:00.400
along and say, oh,
what's it's type?

00:56:00.400 --> 00:56:01.650
It's type is complex.

00:56:04.270 --> 00:56:08.460
Go through to operate-2 and say,
oh, what I want to do is

00:56:08.460 --> 00:56:10.440
apply what's in the table,
which is going to be the

00:56:10.440 --> 00:56:17.150
procedure star complex, on
this thing with the type

00:56:17.150 --> 00:56:17.950
stripped off.

00:56:17.950 --> 00:56:22.400
So it's going to strip off the
type, take that much, and send

00:56:22.400 --> 00:56:26.288
that down into the
complex world.

00:56:26.288 --> 00:56:28.950
The complex world looks at its
operations and says, oh, I

00:56:28.950 --> 00:56:31.280
have to apply star c.

00:56:31.280 --> 00:56:34.490
Star c might say, oh, at some
point I want to look at the

00:56:34.490 --> 00:56:39.420
magnitude of this object that
it's in, that it's got.

00:56:39.420 --> 00:56:40.160
And they'll say, oh, it's

00:56:40.160 --> 00:56:41.870
rectangular, it's one of George's.

00:56:41.870 --> 00:56:47.340
So it'll then strip off the next
version of type, and hand

00:56:47.340 --> 00:56:52.160
that down to George to take
the magnitude of.

00:56:52.160 --> 00:56:55.290
So you see what's going
on is that there are

00:56:55.290 --> 00:56:59.320
these chains of types.

00:56:59.320 --> 00:57:01.530
And the length of the chain is
sort of the number of levels

00:57:01.530 --> 00:57:05.090
that you're going to be going
up in this table.

00:57:05.090 --> 00:57:09.590
And what a type tells you, every
time you have a vertical

00:57:09.590 --> 00:57:12.350
barrier in this table, where
there's some ambiguity about

00:57:12.350 --> 00:57:15.010
where you should go down to the
next level, the type is

00:57:15.010 --> 00:57:17.440
telling you where to go.

00:57:17.440 --> 00:57:19.950
And then everybody at the
bottom, as they construct data

00:57:19.950 --> 00:57:22.810
and filter it up, they stick
their type back on.

00:57:25.350 --> 00:57:30.750
So that's the general structure
of the system.

00:57:33.410 --> 00:57:34.820
OK.

00:57:34.820 --> 00:57:38.660
Now that we've got this, let's
go and make this thing even

00:57:38.660 --> 00:57:39.910
more complex.

00:57:41.890 --> 00:57:46.150
Let's talk about adding to the
system not only these kinds of

00:57:46.150 --> 00:57:49.680
numbers, but it's also
meaningful to start talking

00:57:49.680 --> 00:57:51.510
about adding polynomials.

00:57:51.510 --> 00:57:53.360
Might do arithmetic
on polynomials.

00:57:53.360 --> 00:57:57.570
Like we could have x to the
fifteenth plus 2x to the

00:57:57.570 --> 00:58:04.480
seventh plus 5.

00:58:04.480 --> 00:58:06.380
That might be some polynomial.

00:58:06.380 --> 00:58:08.720
And if we have two such gadgets
we can add them or

00:58:08.720 --> 00:58:10.530
multiply them.

00:58:10.530 --> 00:58:12.140
Let's not worry about
dividing them.

00:58:12.140 --> 00:58:15.870
Just add them, multiply them,
then we'll subtract them.

00:58:15.870 --> 00:58:16.660
What do we have to do?

00:58:16.660 --> 00:58:21.830
Well let's think about how we
might represent a polynomial.

00:58:21.830 --> 00:58:24.950
It's going to be some
typed data object.

00:58:24.950 --> 00:58:29.690
So let's say a polynomial to
this system might look like a

00:58:29.690 --> 00:58:32.000
thing that starts with
the type polynomial.

00:58:32.000 --> 00:58:33.710
And then maybe it says the
next thing is what

00:58:33.710 --> 00:58:34.550
variable its in.

00:58:34.550 --> 00:58:38.960
So I might say I'm a polynomial
in the variable x.

00:58:38.960 --> 00:58:40.500
And then it'll have some
information about

00:58:40.500 --> 00:58:42.250
what the terms are.

00:58:42.250 --> 00:58:45.620
And there're just tons of ways
to do this, but one way is to

00:58:45.620 --> 00:58:51.520
say we're going to have a thing
called a term-list. And

00:58:51.520 --> 00:58:53.700
a term-list--

00:58:53.700 --> 00:58:54.830
well, in our case we'll
use something

00:58:54.830 --> 00:58:56.360
that looks like this.

00:58:56.360 --> 00:58:59.010
We'll make it a bunch of pairs
which have an order in a

00:58:59.010 --> 00:58:59.690
coefficient.

00:58:59.690 --> 00:59:09.070
So this polynomial would be
represented by this term-list.

00:59:09.070 --> 00:59:12.910
And what that means is that
this polynomial starts off

00:59:12.910 --> 00:59:19.710
with a term of order 15
and coefficient 1.

00:59:23.820 --> 00:59:26.780
And the next thing in it is
a term of order 7 and

00:59:26.780 --> 00:59:29.680
coefficient 2, a term of order
0, which is constant in

00:59:29.680 --> 00:59:31.450
coefficient 5.

00:59:31.450 --> 00:59:35.600
And there are lots and lots of
ways, and lots and lots of

00:59:35.600 --> 00:59:37.890
trade-offs when you really think
about making algebraic

00:59:37.890 --> 00:59:40.570
manipulation packages about
exactly how you should

00:59:40.570 --> 00:59:41.730
represent these things.

00:59:41.730 --> 00:59:44.180
But this is a fairly
standard one.

00:59:44.180 --> 00:59:47.770
It's useful in a lot
of contexts.

00:59:47.770 --> 00:59:50.815
OK, well how do we implement
our polynomial arithmetic?

00:59:54.270 --> 00:59:55.520
Let's start out.

00:59:57.950 --> 01:00:00.760
What we'll do to make
a polynomial--

01:00:00.760 --> 01:00:05.690
we'll first have a way
to make polynomials.

01:00:05.690 --> 01:00:08.560
We're going to make a polynomial
out of variable

01:00:08.560 --> 01:00:13.180
like x and term-list. And all
that does is we'll package

01:00:13.180 --> 01:00:14.290
them together someway.

01:00:14.290 --> 01:00:18.740
We'll put the variable together
with the term list

01:00:18.740 --> 01:00:21.380
using cons, and then attached
to that the type polynomial.

01:00:26.270 --> 01:00:29.280
OK, how do we add
two polynomials?

01:00:29.280 --> 01:00:33.330
To add a polynomial, p1 and
p2, and then just for

01:00:33.330 --> 01:00:36.060
simplicity let's say
we will only add

01:00:36.060 --> 01:00:37.380
things in the same variable.

01:00:37.380 --> 01:00:40.740
So if they have the same
variable, and same variable

01:00:40.740 --> 01:00:43.160
here is going to be some
selector we write, whose

01:00:43.160 --> 01:00:45.150
details we don't care about.

01:00:45.150 --> 01:00:48.280
If the two polynomials have the
same variable, then we'll

01:00:48.280 --> 01:00:48.810
do something.

01:00:48.810 --> 01:00:52.350
If they don't have the same
variable, we'll give an error,

01:00:52.350 --> 01:00:55.480
polynomials not in the
same variable.

01:00:55.480 --> 01:00:58.120
And if they do have the same
variable, what we'll do is

01:00:58.120 --> 01:01:01.130
we'll make a polynomial whose
variable is whatever that

01:01:01.130 --> 01:01:05.570
variable is, and whose term-list
is something we'll

01:01:05.570 --> 01:01:10.170
call sum-terms. Plus terms will
add the two term lists.

01:01:10.170 --> 01:01:13.500
So we'll add the two term
lists to the polynomial.

01:01:13.500 --> 01:01:16.755
That'll give us a term-list.
We'll add on, we'll say it's a

01:01:16.755 --> 01:01:19.500
polynomial in the variable
with that

01:01:19.500 --> 01:01:22.550
term-list. That's plus poly.

01:01:22.550 --> 01:01:26.360
And then we're going to put in
our table under the type

01:01:26.360 --> 01:01:30.520
polynomial, add them
using plus poly.

01:01:30.520 --> 01:01:31.750
And of course we really
haven't done much.

01:01:31.750 --> 01:01:34.360
What we've really done is pushed
all the work onto this

01:01:34.360 --> 01:01:38.480
thing, plus-terms, which is
supposed to add term-lists.

01:01:38.480 --> 01:01:40.920
Let's look at that.

01:01:40.920 --> 01:01:48.900
Here's an overview of how we
might add two term-lists.

01:01:48.900 --> 01:01:51.860
So L1 and L2 were going
to be two term-lists.

01:01:51.860 --> 01:01:55.700
And a term-list is a bunch of
pairs, coefficient in order.

01:01:55.700 --> 01:01:56.950
And it's a big case analysis.

01:01:59.860 --> 01:02:03.470
And the first thing we'll check
for and see if there are

01:02:03.470 --> 01:02:07.020
any terms. We're going to
recursively work down these

01:02:07.020 --> 01:02:09.980
term-lists, so eventually we'll
get to a place where

01:02:09.980 --> 01:02:12.270
either L1 or L2 might
be empty.

01:02:12.270 --> 01:02:15.160
And if either one is empty,
our answer will

01:02:15.160 --> 01:02:15.850
be the other one.

01:02:15.850 --> 01:02:20.720
So if L1 is empty we'll return
L2, and if L2 is empty

01:02:20.720 --> 01:02:23.470
we'll return L1.

01:02:23.470 --> 01:02:27.220
Otherwise there are sort of
three interesting cases.

01:02:27.220 --> 01:02:30.560
What we're going to do is grab
the first term in each of

01:02:30.560 --> 01:02:37.660
those lists, called t1 and t2.

01:02:37.660 --> 01:02:43.090
And we're going to look at
three cases, depending on

01:02:43.090 --> 01:02:47.230
whether the order of t1 is
greater than the order of t2,

01:02:47.230 --> 01:02:50.470
or less than t2, or the same.

01:02:53.290 --> 01:02:54.910
Those are the three cases
we're going to look at.

01:02:54.910 --> 01:02:56.160
Let's look at this case.

01:02:58.640 --> 01:03:03.550
If the order of t1 is greater
than the order of t2, then

01:03:03.550 --> 01:03:08.280
what that means is that our
answer is going to start with

01:03:08.280 --> 01:03:11.480
this term of the order of t1.

01:03:11.480 --> 01:03:14.455
Because it won't combine with
any lower order terms. So what

01:03:14.455 --> 01:03:19.720
we do is add the lower order
terms. We recursively add

01:03:19.720 --> 01:03:21.900
together all the terms
in the rest of the

01:03:21.900 --> 01:03:26.880
term-list in L1 and L2.

01:03:26.880 --> 01:03:30.120
That's going to be the lower
order terms of the answer.

01:03:30.120 --> 01:03:31.490
And then we're going to
adjoin to that the

01:03:31.490 --> 01:03:33.180
highest order term.

01:03:33.180 --> 01:03:35.120
And I'm using here a whole bunch
of procedures I haven't

01:03:35.120 --> 01:03:39.360
defined, like a adjoin-term, and
rest-terms, and selectors

01:03:39.360 --> 01:03:41.410
that get order.

01:03:41.410 --> 01:03:44.730
But you can imagine
what those are.

01:03:44.730 --> 01:03:48.550
So if the first term-list has
a higher order than the

01:03:48.550 --> 01:03:51.830
second, we recursively add all
the lower terms and then stick

01:03:51.830 --> 01:03:55.540
on that last term.

01:03:55.540 --> 01:03:56.890
The other case, the same way.

01:03:56.890 --> 01:04:05.400
If the first term has a smaller
order, well then we

01:04:05.400 --> 01:04:07.740
add the first term-list and the
rest of the terms in the

01:04:07.740 --> 01:04:11.430
second one, and adjoin on
this highest order term.

01:04:14.570 --> 01:04:16.660
So so far nothing's much
happened, we've just sort of

01:04:16.660 --> 01:04:19.700
pushed this thing off into
adding lower order terms. The

01:04:19.700 --> 01:04:22.870
last case where you actually get
to a coefficients that you

01:04:22.870 --> 01:04:24.240
have to add, this will
be the case where

01:04:24.240 --> 01:04:27.240
the orders are equal.

01:04:27.240 --> 01:04:30.340
What we do is, well again
recursively add the lower

01:04:30.340 --> 01:04:33.460
order terms. But now we have to
really combine something.

01:04:33.460 --> 01:04:38.960
What we do is we make a term
whose order is the order of

01:04:38.960 --> 01:04:40.820
the term we're looking at.

01:04:40.820 --> 01:04:44.320
By now t1 and t2 have
the same order.

01:04:44.320 --> 01:04:45.090
That's its order.

01:04:45.090 --> 01:04:50.400
And its coefficient is gotten
by adding the coefficient of

01:04:50.400 --> 01:04:52.230
t1 and the coefficient of t2.

01:04:56.360 --> 01:04:59.800
This is a big recursive working
down of terms, but

01:04:59.800 --> 01:05:03.070
really there's only one
interesting symbol in this

01:05:03.070 --> 01:05:05.900
procedure, only one
interesting idea.

01:05:05.900 --> 01:05:08.500
The interesting idea
is this add.

01:05:12.390 --> 01:05:15.330
And the reason that's
interesting is because

01:05:15.330 --> 01:05:18.220
something completely wonderful
just happened.

01:05:18.220 --> 01:05:25.440
We reduced adding polynomials,
not to sort of plus, but to

01:05:25.440 --> 01:05:28.820
the generic add.

01:05:28.820 --> 01:05:33.270
In other words, by implementing
it that way, not

01:05:33.270 --> 01:05:37.530
only do we have our system where
we can have rational

01:05:37.530 --> 01:05:42.090
numbers, or complex numbers,
or ordinary numbers, we've

01:05:42.090 --> 01:05:43.340
just added on polynomials.

01:05:48.520 --> 01:05:51.820
But the coefficients of the
polynomials can be anything

01:05:51.820 --> 01:05:53.590
that the system can add.

01:05:53.590 --> 01:05:57.450
So these could be polynomials
whose coefficients are

01:05:57.450 --> 01:06:04.110
rational numbers or complex
numbers, which in turn could

01:06:04.110 --> 01:06:11.250
be either rectangular, or polar,
or ordinary numbers.

01:06:19.860 --> 01:06:23.460
So what I mean precisely
is our system right now

01:06:23.460 --> 01:06:30.200
automatically can handle things
like adding together

01:06:30.200 --> 01:06:35.830
polynomials that have this one:
2/3 of x squared plus

01:06:35.830 --> 01:06:40.940
5/17 x plus 11/4.

01:06:40.940 --> 01:06:44.210
Or automatically handle
polynomials that look like 3

01:06:44.210 --> 01:06:54.160
plus 2i times x to the fifth
plus 4 plus 7i, or something.

01:06:54.160 --> 01:06:56.210
You can automatically
handle those things.

01:06:56.210 --> 01:06:57.820
Why is that?

01:06:57.820 --> 01:07:03.280
That's merely because, or
profoundly because we reduced

01:07:03.280 --> 01:07:06.790
adding polynomials to adding
their coefficients.

01:07:06.790 --> 01:07:09.670
And adding coefficients was
done by the generic add

01:07:09.670 --> 01:07:12.970
operator, which said, I don't
care what your types are as

01:07:12.970 --> 01:07:15.170
long as I know how to add you.

01:07:15.170 --> 01:07:17.800
So automatically for
free we get the

01:07:17.800 --> 01:07:20.880
ability to handle that.

01:07:20.880 --> 01:07:24.920
What's even better than that,
because remember one of the

01:07:24.920 --> 01:07:29.870
things we did is we put into the
table that the way you add

01:07:29.870 --> 01:07:34.660
polynomials is using
plus poly.

01:07:34.660 --> 01:07:37.480
That means that polynomials
themselves are

01:07:37.480 --> 01:07:39.370
things that can be added.

01:07:39.370 --> 01:07:42.110
So for instance let
me write one here.

01:07:45.260 --> 01:07:46.510
Here's a polynomial.

01:07:50.560 --> 01:07:55.080
So this gadget here I'm
writing up, this is a

01:07:55.080 --> 01:08:02.710
polynomial in y whose
coefficients are

01:08:02.710 --> 01:08:04.690
polynomials in x.

01:08:08.610 --> 01:08:13.110
So you see, simply by saying,
polynomials are themselves

01:08:13.110 --> 01:08:15.590
things that can be added, we can
go off and say, well not

01:08:15.590 --> 01:08:19.560
only can we deal with rationals,
or complex, or

01:08:19.560 --> 01:08:22.330
ordinary numbers, but we can
deal with polynomials whose

01:08:22.330 --> 01:08:25.420
coefficients are rationals, or
complex, or ordinary numbers,

01:08:25.420 --> 01:08:31.979
or polynomials whose
coefficients are rationals, or

01:08:31.979 --> 01:08:37.569
complex, rectangular, polar,
or ordinary numbers, or

01:08:37.569 --> 01:08:42.609
polynomials whose coefficients
are rationals, complex, or

01:08:42.609 --> 01:08:43.670
ordinary numbers.

01:08:43.670 --> 01:08:45.950
And so on, and so
on, and so on.

01:08:45.950 --> 01:08:50.830
So this is sort of an infinite
or maybe a recursive tower of

01:08:50.830 --> 01:08:53.880
types that we've built up.

01:08:53.880 --> 01:08:56.420
And it's all exactly from
that one little symbol.

01:08:56.420 --> 01:08:59.615
A-D-D. Writing "add" instead
of "plus" in

01:08:59.615 --> 01:09:02.270
the polynomial thing.

01:09:02.270 --> 01:09:04.620
Slightly different way to
think about it is that

01:09:04.620 --> 01:09:08.740
polynomials are a constructor
for types.

01:09:08.740 --> 01:09:12.149
Namely you give it a type, like
integer, and it returns

01:09:12.149 --> 01:09:16.279
for you polynomials in x whose
coefficients are integers.

01:09:16.279 --> 01:09:20.010
And the important thing about
that is that the operations on

01:09:20.010 --> 01:09:22.729
polynomials reduce to the
operations on the

01:09:22.729 --> 01:09:23.500
coefficients.

01:09:23.500 --> 01:09:25.840
And there are a lot of
things like that.

01:09:25.840 --> 01:09:28.870
So for example, let's go back
and rational numbers.

01:09:28.870 --> 01:09:32.410
We thought about rational
numbers as an integer over an

01:09:32.410 --> 01:09:34.229
integer, but there's
the general notion

01:09:34.229 --> 01:09:36.240
of a rational object.

01:09:36.240 --> 01:09:43.010
Like we might think about 3x
plus 7 over x squared plus 1.

01:09:43.010 --> 01:09:47.430
That's general rational object
whose numerator and

01:09:47.430 --> 01:09:50.310
denominator are polynomials.

01:09:50.310 --> 01:09:52.990
And to add two of them we use
the same formula, numerator

01:09:52.990 --> 01:09:55.720
times denominator plus
denominator times numerator

01:09:55.720 --> 01:09:57.290
over product of denominators.

01:09:57.290 --> 01:09:59.430
How could we install
that in our system?

01:09:59.430 --> 01:10:01.820
Well here's our original
rational

01:10:01.820 --> 01:10:04.250
number arithmetic package.

01:10:04.250 --> 01:10:08.660
And all we have to do in order
to make the entire system

01:10:08.660 --> 01:10:12.530
continue working with general
rational objects, is replace

01:10:12.530 --> 01:10:16.480
these particular pluses and
stars by the generic operator.

01:10:16.480 --> 01:10:19.870
So if we simply change that
procedure to this one, here

01:10:19.870 --> 01:10:23.100
we've changed plus and star
to add a mul, those are

01:10:23.100 --> 01:10:28.170
absolutely the only change,
then suddenly our entire

01:10:28.170 --> 01:10:34.000
system can start talking about
objects that look like this.

01:10:34.000 --> 01:10:40.350
So for example, here is a
rational object whose

01:10:40.350 --> 01:10:44.030
numerator is a polynomial in
x whose coefficients are

01:10:44.030 --> 01:10:47.350
rational numbers.

01:10:47.350 --> 01:10:53.740
Or here is a rational object
whose numerator is polynomials

01:10:53.740 --> 01:11:00.480
in x whose coefficients are
rational objects constructed

01:11:00.480 --> 01:11:03.390
out of complex numbers.

01:11:03.390 --> 01:11:04.850
And then there are a lot of
other things like that.

01:11:04.850 --> 01:11:07.500
See, whenever you have a thing
where the operations reduce to

01:11:07.500 --> 01:11:10.450
operations on the pieces,
another example would be two

01:11:10.450 --> 01:11:12.310
by two matrices.

01:11:12.310 --> 01:11:17.030
I have the idea, there might
be a matrix here of general

01:11:17.030 --> 01:11:18.650
things that I don't
care about.

01:11:18.650 --> 01:11:25.180
But if I add two of them, the
answer over here is gotten by

01:11:25.180 --> 01:11:29.030
adding this one and that one,
however they like to add.

01:11:29.030 --> 01:11:31.110
So I can implement that
the same way.

01:11:31.110 --> 01:11:33.520
And if I do that, then again
suddenly my system can start

01:11:33.520 --> 01:11:35.480
handling things like this.

01:11:35.480 --> 01:11:39.460
So here's a matrix whose
elements happen to be--

01:11:39.460 --> 01:11:43.330
we'll say this element here
is a rational object whose

01:11:43.330 --> 01:11:47.230
numerator and denominators
are polynomials.

01:11:47.230 --> 01:11:49.510
And all that comes for free.

01:11:52.580 --> 01:11:53.920
What's really going on here?

01:11:53.920 --> 01:11:58.910
What's really going on is
getting rid of this manager

01:11:58.910 --> 01:12:02.060
who's sitting there poking his
nose into who everybody's

01:12:02.060 --> 01:12:03.120
business is.

01:12:03.120 --> 01:12:05.900
We built a system that has
decentralized control.

01:12:14.350 --> 01:12:18.340
So when you come into and no
one's poking around saying,

01:12:18.340 --> 01:12:21.080
gee, are you in the
official list of

01:12:21.080 --> 01:12:22.440
people who can be added?

01:12:22.440 --> 01:12:24.850
Rather you say, well go off
and add yourself how your

01:12:24.850 --> 01:12:27.810
parts like to be added.

01:12:27.810 --> 01:12:31.030
And the result of that is you
can get this very, very, very

01:12:31.030 --> 01:12:33.870
complex hierarchy where a lot
of things just get done and

01:12:33.870 --> 01:12:36.482
rooted to the right place
automatically.

01:12:36.482 --> 01:12:37.732
Let's stop for questions.

01:12:40.380 --> 01:12:43.020
AUDIENCE: You say you
get this for free.

01:12:43.020 --> 01:12:46.920
One thing that strikes me is
that now you've lost kind of

01:12:46.920 --> 01:12:50.150
the cleanness of the break
between what's on top and

01:12:50.150 --> 01:12:50.910
what's underneath.

01:12:50.910 --> 01:12:52.770
In other words, now you're
defining some of the

01:12:52.770 --> 01:12:54.850
lower-level procedures
in terms of things

01:12:54.850 --> 01:12:56.610
above their own line.

01:12:56.610 --> 01:13:00.350
Isn't that dangerous?

01:13:00.350 --> 01:13:05.440
Or, if nothing more, a little
less structured?

01:13:05.440 --> 01:13:06.125
PROFESSOR: No, I--

01:13:06.125 --> 01:13:07.770
the question is whether that's
less structured.

01:13:07.770 --> 01:13:08.690
Depends on what you
mean by structure.

01:13:08.690 --> 01:13:11.050
All this is doing
is recursion.

01:13:11.050 --> 01:13:15.780
See, it's saying that the
way you add these

01:13:15.780 --> 01:13:18.640
guys is to use that.

01:13:18.640 --> 01:13:20.520
And that's not less structured,
it's just a

01:13:20.520 --> 01:13:22.610
recursive structure.

01:13:22.610 --> 01:13:24.730
So I don't think it's
particularly any less clean.

01:13:24.730 --> 01:13:27.250
AUDIENCE: Now when you want to
change the multiplier or the

01:13:27.250 --> 01:13:31.380
add operator, suddenly you've
got tremendous consequences

01:13:31.380 --> 01:13:34.480
underneath that you're not
even sure the extent of.

01:13:34.480 --> 01:13:37.080
PROFESSOR: That's right, but
it depends what you mean.

01:13:37.080 --> 01:13:38.470
See, this goes both ways.

01:13:41.790 --> 01:13:44.690
What would be a good example?

01:13:44.690 --> 01:13:47.500
I ignored greatest common
divisor, for instance.

01:13:47.500 --> 01:13:50.280
I ignored that problem just to
keep the example simple.

01:13:50.280 --> 01:13:59.820
But if I suddenly decided that
plus rat here should do a GCD

01:13:59.820 --> 01:14:04.750
computation and install that,
then that immediately becomes

01:14:04.750 --> 01:14:08.280
available to all of these, to
that guy, and that guy, and

01:14:08.280 --> 01:14:11.560
that guy, and all
the way down.

01:14:11.560 --> 01:14:13.890
So it depends what you mean by
the coherence of your system.

01:14:13.890 --> 01:14:17.030
It's certainly true that you
might want to have a special

01:14:17.030 --> 01:14:18.950
different one that didn't
filter down through the

01:14:18.950 --> 01:14:21.400
coefficients, but the nice thing
about this particular

01:14:21.400 --> 01:14:25.440
example is that mostly you do.

01:14:25.440 --> 01:14:27.630
AUDIENCE: Isn't that the
problem, I think, that you're

01:14:27.630 --> 01:14:32.950
getting to tied in with the fact
that the structuring, the

01:14:32.950 --> 01:14:36.330
recursiveness of that
structuring there is actually

01:14:36.330 --> 01:14:40.340
in execution as opposed to just
definition of the actual

01:14:40.340 --> 01:14:41.590
types themselves?

01:14:44.680 --> 01:14:46.120
PROFESSOR: I think I understand
the question.

01:14:46.120 --> 01:14:48.650
The point is that these types
evolve and get more and more

01:14:48.650 --> 01:14:50.400
complex as the thing's
actually running.

01:14:50.400 --> 01:14:50.730
Is that what--

01:14:50.730 --> 01:14:50.990
AUDIENCE: Yes.

01:14:50.990 --> 01:14:51.790
As it's running.

01:14:51.790 --> 01:14:51.956
PROFESSOR: --what
you're saying?

01:14:51.956 --> 01:14:52.090
Yes, the point is--

01:14:52.090 --> 01:14:54.180
AUDIENCE: As opposed to
the basic definitions.

01:14:54.180 --> 01:14:54.830
PROFESSOR: Right.

01:14:54.830 --> 01:14:57.210
The type structure is
sort of recursive.

01:14:57.210 --> 01:15:02.770
It's not that you can make this
finite list of the actual

01:15:02.770 --> 01:15:04.850
things they might look like
before the system runs.

01:15:04.850 --> 01:15:06.780
It's something that evolves.

01:15:06.780 --> 01:15:09.610
So if you want to specify that
system, you have to do in some

01:15:09.610 --> 01:15:12.275
other way than by this finite
list. You have to do it by a

01:15:12.275 --> 01:15:13.670
recursive structure.

01:15:13.670 --> 01:15:16.960
AUDIENCE: Because the basic
structure of the types is

01:15:16.960 --> 01:15:17.900
pretty clean and simple.

01:15:17.900 --> 01:15:20.125
PROFESSOR: Right.

01:15:20.125 --> 01:15:21.460
Yes?

01:15:21.460 --> 01:15:22.870
AUDIENCE: I have a question.

01:15:22.870 --> 01:15:25.980
I understand once you have your
data structure set up,

01:15:25.980 --> 01:15:29.230
how it pulls off complex and
passes that down, and then

01:15:29.230 --> 01:15:30.640
pulls off rect, passes
that down.

01:15:30.640 --> 01:15:32.790
But if you're just a user and
you don't know anything about

01:15:32.790 --> 01:15:35.610
rect or polar or whatever, how
do you initially set up that

01:15:35.610 --> 01:15:37.330
data structure so that
everything goes

01:15:37.330 --> 01:15:38.390
to the right spot?

01:15:38.390 --> 01:15:41.210
If I just have the equation over
there on the left and I

01:15:41.210 --> 01:15:42.500
just want to add, multiply
complex numbers--

01:15:42.500 --> 01:15:43.640
PROFESSOR: Well that's
the wonderful thing.

01:15:43.640 --> 01:15:47.730
If you're just a user
you say "mul."

01:15:47.730 --> 01:15:50.280
AUDIENCE: And it figures out
that I mean complex numbers?

01:15:50.280 --> 01:15:51.420
Or how do I tell it
that I want--

01:15:51.420 --> 01:15:51.950
PROFESSOR: Well you're
going to have in your

01:15:51.950 --> 01:15:53.050
hands complex numbers.

01:15:53.050 --> 01:15:56.490
See what you would have at some
level, as a real user, is

01:15:56.490 --> 01:15:58.370
a constructor for
complex numbers.

01:15:58.370 --> 01:15:59.470
AUDIENCE: So then I have to
make complex numbers?

01:15:59.470 --> 01:16:00.350
PROFESSOR: So you have
to make them.

01:16:00.350 --> 01:16:03.180
What you would probably have as
a user is some little thing

01:16:03.180 --> 01:16:07.390
in the reader loop, which would
give you some plausible

01:16:07.390 --> 01:16:09.850
way to type in a complex
number, in

01:16:09.850 --> 01:16:11.590
whatever format you like.

01:16:11.590 --> 01:16:14.360
Or it might be that you're
never typing them in.

01:16:14.360 --> 01:16:16.170
Someone's just handing
you a complex number.

01:16:16.170 --> 01:16:19.500
AUDIENCE: OK, so if I had a
complex number that had a

01:16:19.500 --> 01:16:21.505
polynomial in it, I'd have to
make my polynomial and then

01:16:21.505 --> 01:16:21.960
make my complex number.

01:16:21.960 --> 01:16:24.220
PROFESSOR: Right if you wanted
it constructed from scratch.

01:16:24.220 --> 01:16:25.710
At some point you construct
them from scratch.

01:16:25.710 --> 01:16:27.880
But what you don't have to know
of that is when you have

01:16:27.880 --> 01:16:32.345
the object you can just say
"mul." And it'll multiply.

01:16:32.345 --> 01:16:33.279
Yeah?

01:16:33.279 --> 01:16:36.450
AUDIENCE: I think the question
that was being posed here is,

01:16:36.450 --> 01:16:40.220
say if I want to change my
presentation of complexes, or

01:16:40.220 --> 01:16:46.330
some operation of complex, how
much real code I will have to

01:16:46.330 --> 01:16:49.860
gets around with, or change
to change it in

01:16:49.860 --> 01:16:52.270
one specific operation?

01:16:52.270 --> 01:16:53.490
PROFESSOR: [UNINTELLIGIBLE]
what you have to change.

01:16:53.490 --> 01:16:54.690
And the point is that
you only have to

01:16:54.690 --> 01:16:56.070
change what you're changing.

01:16:56.070 --> 01:17:00.320
See if Martha decides that
she would rather--

01:17:00.320 --> 01:17:01.440
let's see something silly--

01:17:01.440 --> 01:17:04.040
like change the order
in the pair.

01:17:04.040 --> 01:17:09.700
Like angle and magnitude in
the other order, she just

01:17:09.700 --> 01:17:10.970
makes that change locally.

01:17:10.970 --> 01:17:12.750
And the whole thing will
propagate through the system

01:17:12.750 --> 01:17:14.790
in the right way.

01:17:14.790 --> 01:17:18.040
Or if suddenly you said, gee, I
have another representation

01:17:18.040 --> 01:17:19.700
for rationals.

01:17:19.700 --> 01:17:22.740
And I'm going to stick it
here, by filing those

01:17:22.740 --> 01:17:24.820
operations in the table.

01:17:24.820 --> 01:17:27.220
Then suddenly all of these
polynomials whose coefficients

01:17:27.220 --> 01:17:29.240
are coefficients of
coefficients, or whatever,

01:17:29.240 --> 01:17:32.970
also can automatically have
available that representation.

01:17:32.970 --> 01:17:35.952
That's the power of this
particular one.

01:17:35.952 --> 01:17:37.625
AUDIENCE: I'm not sure if I can
even pose an intelligent

01:17:37.625 --> 01:17:38.700
sounding question.

01:17:38.700 --> 01:17:42.920
But somehow this whole thing
went really nicely to this

01:17:42.920 --> 01:17:44.910
beautiful finish where
all the things seemed

01:17:44.910 --> 01:17:47.280
to fall into place.

01:17:47.280 --> 01:17:48.530
Sort of seemed a little
contrived.

01:17:50.930 --> 01:17:52.670
That's all for the sake,
I'm sure, of teaching.

01:17:52.670 --> 01:17:55.100
I doubt that the guys
who first did this--

01:17:55.100 --> 01:17:56.510
and I could be wrong--

01:17:56.510 --> 01:17:59.200
figured it all out so that when
they just all put it all

01:17:59.200 --> 01:18:02.410
together, you could all of the
sudden, blam, do any kind of

01:18:02.410 --> 01:18:04.860
arithmetic on any
kind of object.

01:18:04.860 --> 01:18:07.930
It seems like maybe they had
to play with it for a while

01:18:07.930 --> 01:18:11.800
and had to bash it
and rework it.

01:18:11.800 --> 01:18:14.120
And it seems like that's the
kind of problem we're really

01:18:14.120 --> 01:18:16.540
faced with we start trying to
design a really complex

01:18:16.540 --> 01:18:19.390
system, is having lots of
different kinds of parts and

01:18:19.390 --> 01:18:22.730
not even knowing what kinds of
operations we're going to want

01:18:22.730 --> 01:18:24.620
to do on those parts.

01:18:24.620 --> 01:18:27.580
How to organize the operations
in this nice way so that no

01:18:27.580 --> 01:18:29.630
matter what you do, when you
start putting them together

01:18:29.630 --> 01:18:31.700
everything starts falling
out for free.

01:18:31.700 --> 01:18:33.090
PROFESSOR: OK, well
that's certainly a

01:18:33.090 --> 01:18:34.340
very intelligent question.

01:18:37.020 --> 01:18:40.560
One part is this is a very good
methodology that people

01:18:40.560 --> 01:18:44.590
have discovered a lot coming
from symbolic algebra.

01:18:44.590 --> 01:18:47.590
Because there are a lot
of complications.

01:18:47.590 --> 01:18:50.710
To allow you to implement these
things before you decide

01:18:50.710 --> 01:18:52.130
what you want all the
operations to

01:18:52.130 --> 01:18:53.310
be, and all of that.

01:18:53.310 --> 01:18:55.580
So in some sense it's an
answer that people have

01:18:55.580 --> 01:18:58.560
discovered by wading
through this stuff.

01:18:58.560 --> 01:19:02.160
In another sense, it is a
very contrived example.

01:19:02.160 --> 01:19:06.240
AUDIENCE: It seems like to be
able to do this you do have to

01:19:06.240 --> 01:19:08.320
wade through it for a certain
amount of time before you can

01:19:08.320 --> 01:19:09.010
become good at it.

01:19:09.010 --> 01:19:12.220
PROFESSOR: Let me show you how
terribly contrived this is.

01:19:12.220 --> 01:19:14.130
So you can write all these
wonderful things.

01:19:14.130 --> 01:19:17.600
But the system that I wrote
here, and if we had another

01:19:17.600 --> 01:19:19.820
half an hour to give this
lecture I would have given

01:19:19.820 --> 01:19:23.470
this part of it, which says,
notice that it breaks down if

01:19:23.470 --> 01:19:30.880
I tell it to do something as
foolish as add 3 plus 7/2.

01:19:30.880 --> 01:19:33.980
Because what will happen is
you'll get to operate-2, and

01:19:33.980 --> 01:19:36.180
operate-2 will say, oh
this is type number,

01:19:36.180 --> 01:19:37.560
and that's type rational.

01:19:37.560 --> 01:19:38.810
I don't know how to add them.

01:19:41.530 --> 01:19:43.600
So you'd like the system at
least to be able to say

01:19:43.600 --> 01:19:48.660
something like, gee,
before you do that

01:19:48.660 --> 01:19:50.480
change that to 3/1.

01:19:50.480 --> 01:19:52.250
Turn it into a rational number,
hand that to the

01:19:52.250 --> 01:19:53.500
rational package.

01:19:55.510 --> 01:19:58.860
That's the thing I didn't talk
about in this lecture.

01:19:58.860 --> 01:20:00.880
It's a little bit in the book,
which talks about the problem

01:20:00.880 --> 01:20:03.390
of what's called coercion.

01:20:03.390 --> 01:20:05.310
Where you wanted--

01:20:05.310 --> 01:20:08.280
see, having so carefully set
up all of these types as

01:20:08.280 --> 01:20:11.720
distinct objects, a lot of times
you want to also put in

01:20:11.720 --> 01:20:16.650
knowledge about how to view
an ordinary number

01:20:16.650 --> 01:20:19.110
as a kind of rational.

01:20:19.110 --> 01:20:21.620
Or view an ordinary number
as a kind of complex.

01:20:21.620 --> 01:20:24.580
That's where the complexity in
the system really starts

01:20:24.580 --> 01:20:27.110
happening, where you talk
about, see where

01:20:27.110 --> 01:20:28.420
do I put that knowledge?

01:20:28.420 --> 01:20:30.810
Is it rational to know that
ordinary numbers might be

01:20:30.810 --> 01:20:33.130
pieces of [UNINTELLIGIBLE]
of them?

01:20:33.130 --> 01:20:38.790
Or they're terrible, terrible
examples, like if I might want

01:20:38.790 --> 01:20:47.510
to add a complex number
to a rational number.

01:20:50.080 --> 01:20:50.760
Bad example.

01:20:50.760 --> 01:20:52.010
5/7.

01:20:53.860 --> 01:20:57.300
Then somebody's got to know that
I have to convert these

01:20:57.300 --> 01:20:59.790
to another type, which is
complex numbers whose parts

01:20:59.790 --> 01:21:01.540
might be rationals.

01:21:01.540 --> 01:21:02.680
And who worries about that?

01:21:02.680 --> 01:21:03.950
Does complex worry about that?

01:21:03.950 --> 01:21:05.030
Does rational worry
about that?

01:21:05.030 --> 01:21:06.900
Does plus worry about that?

01:21:06.900 --> 01:21:08.520
That's where the real
complexity comes in.

01:21:08.520 --> 01:21:11.380
And that's where it's pretty
well sorted out.

01:21:11.380 --> 01:21:14.810
And a lot of, in fact, all of
this message passing stuff was

01:21:14.810 --> 01:21:18.460
motivated by problems
like this.

01:21:18.460 --> 01:21:21.630
And when you really push it,
people are-- somehow the

01:21:21.630 --> 01:21:25.330
algebraic manipulation problem
seems to be so complex that

01:21:25.330 --> 01:21:27.410
the people who are always at the
edge of it are exactly in

01:21:27.410 --> 01:21:28.050
the state you said.

01:21:28.050 --> 01:21:29.940
They're wading through this
thing, mucking around, seeing

01:21:29.940 --> 01:21:33.470
what they use, trying
to distill stuff.

01:21:33.470 --> 01:21:36.030
AUDIENCE: I just want to come
back to this issue of

01:21:36.030 --> 01:21:39.250
complexity once more.

01:21:39.250 --> 01:21:44.550
It certainly seems to be true
that you have a great deal of

01:21:44.550 --> 01:21:49.580
flexibility in altering the
lower level kinds of things.

01:21:49.580 --> 01:21:54.320
But it is true that you are,
in a sense, freezing higher

01:21:54.320 --> 01:21:55.450
level operations.

01:21:55.450 --> 01:21:58.510
Or at least if you change them
you don't know where all of

01:21:58.510 --> 01:22:02.060
the changes are going to show
up, or how they are.

01:22:02.060 --> 01:22:04.840
PROFESSOR: OK, that's an
extremely good question.

01:22:04.840 --> 01:22:10.130
What I have to do is, if I
decide there's a new general

01:22:10.130 --> 01:22:16.300
operation called equality test,
then all of these people

01:22:16.300 --> 01:22:19.835
have to decide whether or not
they would like to have an

01:22:19.835 --> 01:22:24.650
equality test by looking
in the table.

01:22:24.650 --> 01:22:27.870
There're ways to decentralize
it even more.

01:22:27.870 --> 01:22:31.430
That's what I sort of hinted at
last time, where I said you

01:22:31.430 --> 01:22:34.240
could not only have this type as
a symbol, but you actually

01:22:34.240 --> 01:22:37.850
might store in each object
the operations

01:22:37.850 --> 01:22:40.450
that it knows of that.

01:22:40.450 --> 01:22:44.670
So you might have things like
greatest common divisor, which

01:22:44.670 --> 01:22:47.540
is a thing here which is defined
only for integers, and

01:22:47.540 --> 01:22:51.030
not in general for
rational numbers.

01:22:51.030 --> 01:22:53.110
So it might be a very, very
fragmented system.

01:22:53.110 --> 01:22:56.570
And then depending on where
you want your flexibility,

01:22:56.570 --> 01:22:58.190
there's a whole spectrum
of places that you

01:22:58.190 --> 01:22:59.960
can build that in.

01:22:59.960 --> 01:23:02.320
But you're pointing at the place
where this starts being

01:23:02.320 --> 01:23:04.540
weak, that there has to be some
agreement on top here

01:23:04.540 --> 01:23:06.370
about these general
operations.

01:23:06.370 --> 01:23:08.390
Or at least people have
to think about them.

01:23:08.390 --> 01:23:10.340
Or you might decide, you might
have a table that's very

01:23:10.340 --> 01:23:14.010
sparse, that only has
a few things in it.

01:23:14.010 --> 01:23:15.490
But there are lot of ways
to play that game.

01:23:19.780 --> 01:23:21.030
OK, thank you.

01:23:23.534 --> 01:23:23.849
[MUSIC: "JESU, JOY OF
MAN'S DESIRING" BY

01:23:23.849 --> 01:23:25.099
JOHANN SEBASTIAN BACH]

