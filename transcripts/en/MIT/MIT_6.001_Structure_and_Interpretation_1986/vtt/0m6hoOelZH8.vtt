WEBVTT
Kind: captions
Language: en

00:00:15.314 --> 00:00:17.580
PROFESSOR: Well today we're
going to learn about something

00:00:17.580 --> 00:00:18.410
quite amazing.

00:00:18.410 --> 00:00:22.950
We're going to understand what
we mean by a program a little

00:00:22.950 --> 00:00:26.800
bit more profoundly than
we have up till now.

00:00:26.800 --> 00:00:30.650
Up till now, we've been thinking
of programs as

00:00:30.650 --> 00:00:32.729
describing machines.

00:00:32.729 --> 00:00:38.800
So for example, looking at this
still store, we see here

00:00:38.800 --> 00:00:42.800
is a program for factorial.

00:00:42.800 --> 00:00:46.970
And what it is, is a character
string description, if you

00:00:46.970 --> 00:00:49.520
will, of the wiring
diagram of a

00:00:49.520 --> 00:00:52.230
potentially infinite machine.

00:00:52.230 --> 00:00:53.870
And we can look at that
a little bit and

00:00:53.870 --> 00:00:55.130
just see the idea.

00:00:55.130 --> 00:00:58.950
That this is a sort of compact
notation which says, if n is

00:00:58.950 --> 00:01:00.170
0, the result is one.

00:01:00.170 --> 00:01:03.800
Well here comes n coming into
this machine, and if it's 0,

00:01:03.800 --> 00:01:06.720
then I control this switch in
such a way that the switch

00:01:06.720 --> 00:01:09.340
allows the output to be one.

00:01:09.340 --> 00:01:12.970
Otherwise, it's n times
factorial of n minus one.

00:01:12.970 --> 00:01:15.920
Well, I'm computing factorial of
n minus one and multiplying

00:01:15.920 --> 00:01:19.350
that by n, and, in the case that
it's not 0, this switch

00:01:19.350 --> 00:01:21.900
makes the output come
from there.

00:01:21.900 --> 00:01:24.460
Of course, this is a machine
with a potentially infinite

00:01:24.460 --> 00:01:27.300
number of parts, because
factorial occurs within

00:01:27.300 --> 00:01:31.070
factorial, so we don't know
how deep it has to be.

00:01:31.070 --> 00:01:36.480
But that's basically what our
notation for programs really

00:01:36.480 --> 00:01:38.310
means to us at this point.

00:01:38.310 --> 00:01:41.810
It's a character string
description, if you will, of a

00:01:41.810 --> 00:01:44.900
wiring diagram that could also
be drawn some other way.

00:01:44.900 --> 00:01:47.520
And, in fact, many people have
proposed to me, programming

00:01:47.520 --> 00:01:49.490
languages look graphical
like this.

00:01:49.490 --> 00:01:51.500
I'm not sure I believe there
are many advantages.

00:01:51.500 --> 00:01:54.470
The major disadvantage, of
course, is that it takes up

00:01:54.470 --> 00:01:57.360
more space on a page, and,
therefore, it's harder to pack

00:01:57.360 --> 00:02:01.090
into a listing or to
edit very well.

00:02:01.090 --> 00:02:05.300
But in any case, there's
something very remarkable that

00:02:05.300 --> 00:02:08.810
can happen in the competition
world which is that you can

00:02:08.810 --> 00:02:10.450
have something called
a universal machine.

00:02:10.450 --> 00:02:18.340
If we look at the second
slide, what we see is a

00:02:18.340 --> 00:02:21.260
special machine called eval.

00:02:21.260 --> 00:02:23.670
There is a machine called eval,
and I'm going to show it

00:02:23.670 --> 00:02:25.720
to you today.

00:02:25.720 --> 00:02:27.780
It's very simple.

00:02:27.780 --> 00:02:30.490
What is remarkable is that it
will fit on the blackboard.

00:02:33.350 --> 00:02:38.310
However, eval is a machine
which takes as input a

00:02:38.310 --> 00:02:40.450
description of another
machine.

00:02:40.450 --> 00:02:42.620
It could take the wiring
diagram of a

00:02:42.620 --> 00:02:46.490
factorial machine as input.

00:02:46.490 --> 00:02:52.020
Having done so, it becomes a
simulator for the factorial

00:02:52.020 --> 00:02:58.910
machine such that, if you put
a six in, out comes a 720.

00:02:58.910 --> 00:03:02.130
That's a very remarkable
sort of machine.

00:03:02.130 --> 00:03:04.560
And the most amazing part of
it is that it fits on a

00:03:04.560 --> 00:03:05.590
blackboard.

00:03:05.590 --> 00:03:10.070
By contrast, one could imagine
in the analog electronics

00:03:10.070 --> 00:03:17.180
world a very different machine,
a machine which also

00:03:17.180 --> 00:03:20.440
was, in some sense, universal,
where you gave a circuit

00:03:20.440 --> 00:03:24.830
diagram as one of the inputs,
for example, of this little

00:03:24.830 --> 00:03:28.050
low-pass filter, one-pole
low-pass filter.

00:03:28.050 --> 00:03:30.230
And you can imagine that
you could, for

00:03:30.230 --> 00:03:32.030
example, scan this out--

00:03:32.030 --> 00:03:37.950
the scan lines are the signal
that's describing what this

00:03:37.950 --> 00:03:40.770
machine is to simulate--

00:03:40.770 --> 00:03:43.040
then the analog of that which
is made out of electrical

00:03:43.040 --> 00:03:45.540
circuits, should configure
itself into a filter that has

00:03:45.540 --> 00:03:47.010
the frequency response
specified

00:03:47.010 --> 00:03:49.890
by the circuit diagram.

00:03:49.890 --> 00:03:52.520
That's a very hard machine to
make, and, surely, there's no

00:03:52.520 --> 00:03:55.670
chance that I could put
it on a blackboard.

00:03:55.670 --> 00:03:58.430
So we're going to see an
amazing thing today.

00:03:58.430 --> 00:04:01.240
We're going to see,
on the blackboard,

00:04:01.240 --> 00:04:02.790
the universal machine.

00:04:02.790 --> 00:04:06.780
And we'll see that among other
things, it's extremely simple.

00:04:06.780 --> 00:04:10.070
Now, we're getting very close
to the real spirit in the

00:04:10.070 --> 00:04:11.280
computer at this point.

00:04:11.280 --> 00:04:14.110
So I have to show a certain
amount of reverence and

00:04:14.110 --> 00:04:16.970
respect, so I'm going to wear
a suit jacket for the only

00:04:16.970 --> 00:04:20.470
time that you'll ever see me
wear a suit jacket here.

00:04:20.470 --> 00:04:25.730
And I think I'm also going to
put on an appropriate hat for

00:04:25.730 --> 00:04:26.980
the occasion.

00:04:28.780 --> 00:04:31.390
Now, this is a lecturer which
I have to warn you--

00:04:34.140 --> 00:04:37.690
let's see, normally, people
under 40 and who don't have

00:04:37.690 --> 00:04:40.370
several children are advised
to be careful.

00:04:40.370 --> 00:04:44.170
If they're really worried, they
should leave. Because

00:04:44.170 --> 00:04:46.890
there's a certain amount of
mysticism that will appear

00:04:46.890 --> 00:04:50.140
here which may be disturbing
and cause

00:04:50.140 --> 00:04:51.820
trouble in your minds.

00:04:51.820 --> 00:04:57.300
Well in any case, let's see,
I wish to write for you the

00:04:57.300 --> 00:05:02.510
evaluator for Lisp.

00:05:02.510 --> 00:05:05.020
Now the evaluator isn't
very complicated.

00:05:05.020 --> 00:05:08.240
It's very much like all the
programs we've seen already.

00:05:08.240 --> 00:05:10.860
That's the amazing part of it.

00:05:10.860 --> 00:05:15.370
It's going to be-- and I'm going
to write it right here--

00:05:15.370 --> 00:05:16.620
it's a program called eval.

00:05:22.900 --> 00:05:28.780
And it's a procedure of two
arguments in expression of an

00:05:28.780 --> 00:05:30.030
environment.

00:05:31.860 --> 00:05:33.130
And like every interesting

00:05:33.130 --> 00:05:34.940
procedure, it's a case analysis.

00:05:40.460 --> 00:05:44.210
But before I start on this, I
want to tell you some things.

00:05:44.210 --> 00:05:46.880
The program we're going to write
on the blackboard is

00:05:46.880 --> 00:05:52.450
ugly, dirty, disgusting, not the
way I would write this is

00:05:52.450 --> 00:05:54.210
a professional.

00:05:54.210 --> 00:05:57.940
It is written with concrete
syntax, meaning you've got

00:05:57.940 --> 00:05:59.630
really to use lots of CARs and
CDRs which is exactly what I

00:05:59.630 --> 00:06:02.550
told you not to do.

00:06:02.550 --> 00:06:07.180
That's on purpose in this case,
because I want it to be

00:06:07.180 --> 00:06:11.010
small, compact, fit on the
blackboard so you can get the

00:06:11.010 --> 00:06:12.420
whole thing.

00:06:12.420 --> 00:06:15.800
So I don't want to use long
names like I normally use.

00:06:15.800 --> 00:06:19.580
I want to use CAR-CDR
because it's short.

00:06:19.580 --> 00:06:20.950
Now, that's a trade-off.

00:06:20.950 --> 00:06:23.570
I don't want you writing
programs like this.

00:06:23.570 --> 00:06:26.090
This is purely for an effect.

00:06:26.090 --> 00:06:27.530
Now, you're going to have to
work a little harder to read

00:06:27.530 --> 00:06:29.270
it, but I'm going to try
to make it clear

00:06:29.270 --> 00:06:31.270
as I'm writing it.

00:06:31.270 --> 00:06:32.395
I'm also--

00:06:32.395 --> 00:06:34.960
this is a pretty much complete
interpreter, but there's going

00:06:34.960 --> 00:06:36.290
to be room for putting
in more things--

00:06:36.290 --> 00:06:39.160
I'm going to leave out
definition and assignment,

00:06:39.160 --> 00:06:45.310
just because they are not
essential, for a mathematical

00:06:45.310 --> 00:06:51.670
reason I'll show you later and
also they take up more space.

00:06:51.670 --> 00:06:54.170
But, in any case, what
do we have to do?

00:06:54.170 --> 00:06:57.160
We have to do a dispatch which
breaks the types of

00:06:57.160 --> 00:07:02.030
expressions up into particular
classes.

00:07:02.030 --> 00:07:03.525
So that's what we're
going to have here.

00:07:03.525 --> 00:07:05.150
Well, what expressions
are there?

00:07:05.150 --> 00:07:06.810
Let's look at the kinds
of expressions.

00:07:06.810 --> 00:07:10.420
We can have things like
the numeral three.

00:07:10.420 --> 00:07:12.720
What do I want that to do?

00:07:12.720 --> 00:07:15.640
I can make choices, but I think
right now, I want it to

00:07:15.640 --> 00:07:17.050
be a three.

00:07:17.050 --> 00:07:18.860
That's what I want.

00:07:18.860 --> 00:07:19.800
So that's easy enough.

00:07:19.800 --> 00:07:27.520
That means I want, if the
thing is a number, the

00:07:27.520 --> 00:07:30.720
expression, that I want
the expression

00:07:30.720 --> 00:07:31.970
itself as the answer.

00:07:35.420 --> 00:07:37.700
Now the next possibility
is things that we

00:07:37.700 --> 00:07:39.390
represent as symbols.

00:07:39.390 --> 00:07:47.614
Examples of symbols are things
like x, n, eval, number, x.

00:07:47.614 --> 00:07:49.630
What do I mean them to be?

00:07:49.630 --> 00:07:51.690
Those are things that stand
for other things.

00:07:51.690 --> 00:07:54.770
Those are the variables
of our language.

00:07:54.770 --> 00:07:58.540
And so I want to be able to say,
for example, that x, for

00:07:58.540 --> 00:08:02.930
example, transforms to it's
value which might be three.

00:08:02.930 --> 00:08:07.920
Or I might ask something
like car.

00:08:07.920 --> 00:08:09.710
I want to have as its value--

00:08:09.710 --> 00:08:17.380
be something like some
procedure, which I don't know

00:08:17.380 --> 00:08:20.440
what is inside there, perhaps
a machine language code or

00:08:20.440 --> 00:08:23.100
something like that.

00:08:23.100 --> 00:08:24.430
So, well, that's easy enough.

00:08:24.430 --> 00:08:27.890
I'm going to push that
off on someone else.

00:08:27.890 --> 00:08:33.370
If something is a symbol, if
the expression is a symbol,

00:08:33.370 --> 00:08:38.140
then I want the answer to be
the result, looking up the

00:08:38.140 --> 00:08:40.159
expression in the environment.

00:08:46.480 --> 00:08:52.410
Now the environment is a
dictionary which maps the

00:08:52.410 --> 00:08:54.060
symbol names to their values.

00:08:54.060 --> 00:08:56.280
And that's all it is.

00:08:56.280 --> 00:08:57.530
How it's done?

00:08:57.530 --> 00:08:59.760
Well, we'll see that later.

00:08:59.760 --> 00:09:01.670
It's very easy.

00:09:01.670 --> 00:09:03.630
It's easy to make data
structures that are tables of

00:09:03.630 --> 00:09:04.670
various sorts.

00:09:04.670 --> 00:09:07.080
But it's only a table, and this
is the access routine for

00:09:07.080 --> 00:09:10.040
some table.

00:09:10.040 --> 00:09:12.720
Well, the next thing, another
kind of expression--

00:09:12.720 --> 00:09:14.870
you have things that are
described constants that are

00:09:14.870 --> 00:09:17.430
not numbers, like 'foo.

00:09:20.170 --> 00:09:22.450
Well, for my convenience,
I want to syntactically

00:09:22.450 --> 00:09:31.520
transform that into a list
structure which is, quote foo.

00:09:35.140 --> 00:09:39.950
A quoted object, whatever it is,
is going to be actually an

00:09:39.950 --> 00:09:43.550
abbreviation, which is not
part of the evaluator but

00:09:43.550 --> 00:09:46.960
happens somewhere else, an
abbreviation for an expression

00:09:46.960 --> 00:09:48.780
that looks like this.

00:09:48.780 --> 00:09:52.120
This way, I can test for the
type of the expression as

00:09:52.120 --> 00:09:55.615
being a quotation by examining
the car of the expression.

00:09:58.460 --> 00:10:01.650
So I'm not going to worry about
that in the evaluator.

00:10:01.650 --> 00:10:02.780
It's happening somewhere
earlier in

00:10:02.780 --> 00:10:05.540
the reader or something.

00:10:05.540 --> 00:10:18.620
If the expression of the
expression is quote, then what

00:10:18.620 --> 00:10:25.140
I want, I want quote foo to
itself evaluate to foo.

00:10:25.140 --> 00:10:27.530
It's a constant.

00:10:27.530 --> 00:10:30.645
This is just a way of saying
that this evaluates to itself.

00:10:33.150 --> 00:10:33.660
What is that?

00:10:33.660 --> 00:10:37.330
That's the second of the list.
It's the second element of the

00:10:37.330 --> 00:10:41.604
list. The second element of the
list is it's CADR. So I'm

00:10:41.604 --> 00:10:51.290
just going to write
here, CADR.

00:10:51.290 --> 00:10:52.510
What else do we have here?

00:10:52.510 --> 00:10:56.040
We have lambda expressions,
for example,

00:10:56.040 --> 00:11:04.160
lambda of x plus x y.

00:11:04.160 --> 00:11:05.910
Well, I going have to have some
representation for the

00:11:05.910 --> 00:11:08.610
procedure which is the value of
an expression, of a lambda

00:11:08.610 --> 00:11:09.600
expression.

00:11:09.600 --> 00:11:13.030
The procedure here is not
the expression lambda x.

00:11:13.030 --> 00:11:16.170
That's the description of it,
the textual description.

00:11:16.170 --> 00:11:18.800
However, what what I going
to expect to see here is

00:11:18.800 --> 00:11:20.930
something which contains an
environment as one of its

00:11:20.930 --> 00:11:27.360
parts if I'm implementing
a lexical language.

00:11:27.360 --> 00:11:30.790
And so what I'd like to see
is some type flags.

00:11:30.790 --> 00:11:33.440
I'm going to have to be able
to distinguish procedures

00:11:33.440 --> 00:11:37.190
later, procedures which were
produced by lambdas, from ones

00:11:37.190 --> 00:11:39.060
that may be primitive.

00:11:39.060 --> 00:11:42.440
And so I'm going to have some
flag, which I'll just

00:11:42.440 --> 00:11:44.935
arbitrarily call closure, just
for historical reasons.

00:11:47.760 --> 00:11:49.920
Now, to say what parts of
this are important.

00:11:49.920 --> 00:11:51.970
I'm going to need to know
the bound variable

00:11:51.970 --> 00:11:54.220
list and the body.

00:11:54.220 --> 00:12:00.870
Well, that's the CDR of this, so
it's going to be x and plus

00:12:00.870 --> 00:12:03.795
x y and some environment.

00:12:08.170 --> 00:12:13.980
Now this is not something that
users should ever see, this is

00:12:13.980 --> 00:12:16.680
purely a representation,
internally,

00:12:16.680 --> 00:12:18.520
for a procedure object.

00:12:18.520 --> 00:12:22.010
It contains a bound variable
list, a body, and an

00:12:22.010 --> 00:12:26.340
environment, and some type tag
saying, I am a procedure.

00:12:26.340 --> 00:12:28.080
I'm going to make one now.

00:12:28.080 --> 00:12:43.720
So if the CAR of the expression
is quote lambda,

00:12:43.720 --> 00:12:45.970
then what I'm going
to put here is--

00:12:45.970 --> 00:12:58.860
I'm going to make a list of
closure, the CDR of the

00:12:58.860 --> 00:13:07.520
procedure description was
everything except the lambda,

00:13:07.520 --> 00:13:10.250
and the current environment.

00:13:10.250 --> 00:13:14.470
This implements the rule
for environments in the

00:13:14.470 --> 00:13:15.190
environment model.

00:13:15.190 --> 00:13:17.980
It has to do with construction
of procedures from lambda

00:13:17.980 --> 00:13:19.210
expressions.

00:13:19.210 --> 00:13:22.180
The environment that was
around at the time the

00:13:22.180 --> 00:13:25.940
evaluator encountered the
lambda expression is the

00:13:25.940 --> 00:13:30.990
environment where the procedure
resulting interprets

00:13:30.990 --> 00:13:32.240
it's free variables.

00:13:34.720 --> 00:13:35.920
So that's part of that.

00:13:35.920 --> 00:13:38.120
And so we have to capture that
environment as part of the

00:13:38.120 --> 00:13:39.210
procedure object.

00:13:39.210 --> 00:13:41.750
And we'll see how that
gets used later.

00:13:41.750 --> 00:13:45.140
There are also conditional
expressions of things like

00:13:45.140 --> 00:13:54.520
COND of say, p one, e
one, p two, e two.

00:13:54.520 --> 00:13:57.670
Where this is a predicate, a
predicate is a thing that is

00:13:57.670 --> 00:14:00.930
either true or false, and the
expression to be evaluated if

00:14:00.930 --> 00:14:03.480
the predicate is true.

00:14:03.480 --> 00:14:05.516
A set of clauses, if you
will, that's the

00:14:05.516 --> 00:14:06.790
name for such a thing.

00:14:06.790 --> 00:14:09.360
So I'm going put that
somewhere else.

00:14:09.360 --> 00:14:12.420
We're going to worry about that
in another piece of code.

00:14:12.420 --> 00:14:13.670
So EQ--

00:14:15.900 --> 00:14:24.710
if the CAR of the expression is
COND, then I'm going to do

00:14:24.710 --> 00:14:30.800
nothing more than evaluate
the COND, the CDR of the

00:14:30.800 --> 00:14:32.050
expression.

00:14:34.080 --> 00:14:38.380
That's all the clauses in the
environment that I'm given.

00:14:41.430 --> 00:14:46.480
Well, there's one more case,
arbitrary thing like the sum

00:14:46.480 --> 00:14:53.380
of x and three, where this
is an operator applied to

00:14:53.380 --> 00:14:56.590
operands, and there's nothing
special about it.

00:14:56.590 --> 00:14:59.850
It's not one of the special
cases, the special forms.

00:14:59.850 --> 00:15:09.650
These are the special forms.

00:15:09.650 --> 00:15:12.480
And if I were writing here a
professional program, again, I

00:15:12.480 --> 00:15:14.370
would somehow make this
data directed.

00:15:14.370 --> 00:15:16.690
So there wouldn't be a sequence
of conditionals here,

00:15:16.690 --> 00:15:20.290
there'd be a dispatch on some
bits if I were trying to do

00:15:20.290 --> 00:15:22.360
this in a more professional
way.

00:15:22.360 --> 00:15:25.750
So that, in fact, I can add to
the thing without changing my

00:15:25.750 --> 00:15:26.710
program much.

00:15:26.710 --> 00:15:29.850
So, for example, they would run
fast, but I'm not worried

00:15:29.850 --> 00:15:31.280
about that.

00:15:31.280 --> 00:15:34.890
Here we're trying to look
at this in its entirety.

00:15:34.890 --> 00:15:37.360
So it's else.

00:15:37.360 --> 00:15:38.560
Well, what do we do?

00:15:38.560 --> 00:15:40.965
In this case, I have to somehow
do an addition.

00:15:44.350 --> 00:15:46.565
Well, I could find out
what the plus is.

00:15:46.565 --> 00:15:50.550
I have to find out what the
x and the three are.

00:15:50.550 --> 00:15:53.330
And then I have to apply the
result of finding what the

00:15:53.330 --> 00:15:56.360
plus is to the result of
finding out what the x

00:15:56.360 --> 00:15:58.020
and the three are.

00:15:58.020 --> 00:15:59.830
We'll have a name for that.

00:15:59.830 --> 00:16:11.280
So I'm going to apply the result
of evaluating the CAR

00:16:11.280 --> 00:16:13.270
of the expression--

00:16:13.270 --> 00:16:17.210
the car of the expression
is the operator--

00:16:17.210 --> 00:16:20.480
in the environment given.

00:16:20.480 --> 00:16:24.050
So evaluating the operator
gets me the procedure.

00:16:24.050 --> 00:16:27.290
Now I have to evaluate all the
operands to get the arguments.

00:16:27.290 --> 00:16:34.710
I'll call that EVLIST, the CDR
of the operands, of the

00:16:34.710 --> 00:16:38.835
expression, with respect
to the environment.

00:16:41.940 --> 00:16:43.290
EVLIST will come up later--

00:16:43.290 --> 00:16:48.070
EVLIST, apply, COND pair,
COND, lambda, define.

00:16:50.900 --> 00:16:53.630
So that what you are seeing here
now is pretty much all

00:16:53.630 --> 00:16:56.590
there is in the evaluator
itself.

00:16:56.590 --> 00:17:01.370
It's the case dispatch on the
type of the expression with

00:17:01.370 --> 00:17:07.470
the default being a general
application or a combination.

00:17:17.520 --> 00:17:20.089
Now there is lots of things
we haven't defined yet.

00:17:20.089 --> 00:17:21.780
Let's just look at them
and see what they are.

00:17:21.780 --> 00:17:25.480
We're going to have to do
this later, evcond.

00:17:25.480 --> 00:17:27.579
We have to write apply.

00:17:27.579 --> 00:17:29.120
We're going to have to
write EVLIST. We're

00:17:29.120 --> 00:17:31.790
going to write LOOKUP.

00:17:31.790 --> 00:17:33.430
I think that's everything,
isn't there?

00:17:33.430 --> 00:17:35.860
Everything else is something
which is simple, or primitive,

00:17:35.860 --> 00:17:38.570
or something like that.

00:17:38.570 --> 00:17:42.360
And, of course, we could many
more special forms here, but

00:17:42.360 --> 00:17:44.450
that would be a bad idea in
general in a language.

00:17:44.450 --> 00:17:46.730
You make a language very
complicated by putting a lot

00:17:46.730 --> 00:17:47.690
of things in there.

00:17:47.690 --> 00:17:49.830
The number of reserve words
that should exist in a

00:17:49.830 --> 00:17:52.540
language should be no more than
a person could remember

00:17:52.540 --> 00:17:54.010
on his fingers and toes.

00:17:54.010 --> 00:17:56.820
And I get very upset with
languages which have hundreds

00:17:56.820 --> 00:17:59.410
of reserve words.

00:17:59.410 --> 00:18:00.710
But that's where the
reserve words go.

00:18:04.750 --> 00:18:06.430
Well, now let's get to
the next part of

00:18:06.430 --> 00:18:09.640
this, the kernel, apply.

00:18:09.640 --> 00:18:11.590
What else is this doing?

00:18:11.590 --> 00:18:17.020
Well, apply's job is to take a
procedure and apply it to its

00:18:17.020 --> 00:18:19.500
arguments after both have been
evaluated to come up with a

00:18:19.500 --> 00:18:22.560
procedure and the arguments
rather the operator symbols

00:18:22.560 --> 00:18:25.360
and the operand symbols,
whatever they are--

00:18:25.360 --> 00:18:26.610
symbolic expressions.

00:18:33.270 --> 00:18:40.810
So we will define apply to be a
procedure of two arguments,

00:18:40.810 --> 00:18:43.280
a procedure and arguments.

00:18:47.110 --> 00:18:48.080
And what does it do?

00:18:48.080 --> 00:18:49.720
It does nothing very
complicated.

00:18:49.720 --> 00:18:50.970
It's got two cases.

00:18:53.580 --> 00:18:55.095
Either the procedure
is primitive--

00:19:02.970 --> 00:19:06.930
And I don't know exactly
how that is done.

00:19:06.930 --> 00:19:10.930
It's possible there's some type
information just like we

00:19:10.930 --> 00:19:14.110
made closure for, here, being
the description of the type of

00:19:14.110 --> 00:19:16.810
a compound thing--

00:19:16.810 --> 00:19:18.550
probably so.

00:19:18.550 --> 00:19:21.360
But it is not essential how that
works, and, in fact, it

00:19:21.360 --> 00:19:24.140
turns out, as you probably know
or have deduced, that you

00:19:24.140 --> 00:19:27.350
don't need any primitives
anyway.

00:19:27.350 --> 00:19:30.732
You can compute anything without
them because some of

00:19:30.732 --> 00:19:33.190
the lambda that I've
been playing with.

00:19:33.190 --> 00:19:34.750
But it's nice to have them.

00:19:34.750 --> 00:19:36.630
So here we're going to do
some magic which I'm

00:19:36.630 --> 00:19:38.060
not going to explain.

00:19:38.060 --> 00:19:42.860
Go to machine language,
apply primop.

00:19:42.860 --> 00:19:44.850
Here's how it adds.

00:19:44.850 --> 00:19:46.100
Execute an add instruction.

00:19:50.360 --> 00:19:52.840
However, the interesting part
of a language is the glue by

00:19:52.840 --> 00:19:54.940
which the predicates
are glued together.

00:19:54.940 --> 00:19:56.910
So let's look at that.

00:19:56.910 --> 00:20:01.210
Well, the other possibility is
that this is a compound made

00:20:01.210 --> 00:20:05.140
up by executing a lambda
expression, this

00:20:05.140 --> 00:20:07.620
is a compound procedure.

00:20:07.620 --> 00:20:10.110
Well, we'll check its type.

00:20:10.110 --> 00:20:23.010
If it is closure, if it's one of
those, then I have to do an

00:20:23.010 --> 00:20:24.500
eval of the body.

00:20:24.500 --> 00:20:28.960
The way I do this, the way I
deal with this at all, is the

00:20:28.960 --> 00:20:31.210
way I evaluate the application
of a procedure to its

00:20:31.210 --> 00:20:34.400
arguments, is by evaluating the
body of the procedure in

00:20:34.400 --> 00:20:37.050
the environment resulting from
extending the environment of

00:20:37.050 --> 00:20:39.670
the procedure with the bindings
of the formal

00:20:39.670 --> 00:20:43.010
parameters of the procedure
to the arguments that

00:20:43.010 --> 00:20:44.260
were passed to it.

00:20:47.030 --> 00:20:48.280
That was a long sentence.

00:20:51.130 --> 00:20:52.822
Well that's easy enough.

00:20:52.822 --> 00:20:56.214
Now here's going to be
a lot of CAR-CDRing.

00:20:56.214 --> 00:20:59.400
I have to get the body
of the procedure.

00:20:59.400 --> 00:21:02.960
Where's the body of the
procedure in here?

00:21:02.960 --> 00:21:05.490
Well here's the CAR, here's
the CDR is the

00:21:05.490 --> 00:21:06.130
whole rest of this.

00:21:06.130 --> 00:21:09.130
So here's the CADR. And so I
see, what I have here is the

00:21:09.130 --> 00:21:11.430
body is the second element
of the second

00:21:11.430 --> 00:21:13.200
element of the procedure.

00:21:13.200 --> 00:21:19.170
So it's the CADR of the
CADR or the CADADR.

00:21:19.170 --> 00:21:27.495
It's the C-A-D-A-D-R, CADADR
of the procedure.

00:21:30.260 --> 00:21:35.170
To evaluate the body in the
result of binding that's

00:21:35.170 --> 00:21:39.080
making up more environment,
well I need the formal

00:21:39.080 --> 00:21:43.500
parameters of the of the
procedure, what is that?

00:21:43.500 --> 00:21:48.780
That's the CAR of the CDR.
It's horrible isn't it?

00:21:52.440 --> 00:21:55.440
--of the procedure.

00:21:55.440 --> 00:22:00.370
Bind that to the arguments
that were passed in the

00:22:00.370 --> 00:22:04.540
environment, which is passed
also as part of the procedure.

00:22:04.540 --> 00:22:09.670
Well, that's the CAR of the
CDR of the CDR of this,

00:22:09.670 --> 00:22:16.315
CADADR, of the procedure.

00:22:20.290 --> 00:22:26.490
Bind, eval, pair, COND,
lamda, define--

00:22:26.490 --> 00:22:29.370
Now, of course, if I were being
really a neat character,

00:22:29.370 --> 00:22:33.490
and I was being very careful, I
would actually put an extra

00:22:33.490 --> 00:22:36.540
case here for checking for
certain errors like, did you

00:22:36.540 --> 00:22:39.000
try to apply one
to an argument?

00:22:39.000 --> 00:22:42.570
You get a undefined
procedure type.

00:22:42.570 --> 00:22:45.500
So I may as well
do that anyway.

00:22:45.500 --> 00:22:57.610
--else, some sort of
error, like that.

00:22:57.610 --> 00:23:02.620
Now, of course, again, in some
sort of more real system,

00:23:02.620 --> 00:23:06.770
written for professional
reasons, this would be written

00:23:06.770 --> 00:23:10.750
with a case analysis done by
some sort of dispatch.

00:23:10.750 --> 00:23:13.250
Over here, I would probably have
other cases like, is this

00:23:13.250 --> 00:23:16.220
compiled code?

00:23:16.220 --> 00:23:17.020
It's very important.

00:23:17.020 --> 00:23:19.530
I might have distinguished the
kind of code that's produced

00:23:19.530 --> 00:23:23.150
by a directly evaluating a
lambda in interpretation from

00:23:23.150 --> 00:23:25.190
code that was produced by
somebody's compiler or

00:23:25.190 --> 00:23:25.880
something like that.

00:23:25.880 --> 00:23:27.230
And we'll talk about
that later.

00:23:27.230 --> 00:23:28.710
Or is this a piece Fortran
program I have

00:23:28.710 --> 00:23:30.510
to go off and execute.

00:23:30.510 --> 00:23:31.820
It's a perfectly possible
thing, at this

00:23:31.820 --> 00:23:32.920
point, to do that.

00:23:32.920 --> 00:23:36.070
In fact, in this concrete syntax
evaluator I'm writing

00:23:36.070 --> 00:23:42.600
here, there's an assumption
built in that this is Lisp,

00:23:42.600 --> 00:23:44.360
because I'm using
CARs and CDRs.

00:23:44.360 --> 00:23:46.750
CAR means the operator, and
CDR means the operand.

00:23:46.750 --> 00:23:50.500
In the text, there is an
abstract syntax evaluator for

00:23:50.500 --> 00:23:52.160
which these could be--

00:23:52.160 --> 00:23:54.310
these are given abstract names
like operator, and operand,

00:23:54.310 --> 00:23:56.160
and all these other things
are like that.

00:23:56.160 --> 00:24:00.320
And, in that case, you could
reprogram it to be ALGOL with

00:24:00.320 --> 00:24:01.570
no problem.

00:24:03.760 --> 00:24:07.410
Well, here we have added another
couple of things that

00:24:07.410 --> 00:24:08.660
we haven't defined.

00:24:10.810 --> 00:24:13.800
I don't think I'll worry about
these at all, however, this

00:24:13.800 --> 00:24:15.050
one will be interesting later.

00:24:17.930 --> 00:24:20.550
Let's just proceed through
this and get it done.

00:24:20.550 --> 00:24:21.810
There's only two more
blackboards so it

00:24:21.810 --> 00:24:23.060
can't be very long.

00:24:27.056 --> 00:24:30.070
It's carefully tailored
to exactly fit.

00:24:30.070 --> 00:24:30.980
Well, what do we have left?

00:24:30.980 --> 00:24:33.730
We have to define EVLIST,
which is over here.

00:24:33.730 --> 00:24:40.620
And EVLIST is nothing more than
a map down a bunch of

00:24:40.620 --> 00:24:44.240
operands producing arguments.

00:24:44.240 --> 00:24:45.820
But I'm going to write it out.

00:24:45.820 --> 00:24:47.445
And one of the reasons I'm going
to write this out is for

00:24:47.445 --> 00:24:51.820
a mystical reason, which is I
want to make this evaluator so

00:24:51.820 --> 00:24:53.610
simple that it can understand
itself.

00:24:56.450 --> 00:25:00.230
I'm going to really worry
about that a little bit.

00:25:00.230 --> 00:25:02.850
So let's write it
out completely.

00:25:02.850 --> 00:25:04.890
See, I don't want to worry about
whether or not the thing

00:25:04.890 --> 00:25:06.080
can pass functional arguments.

00:25:06.080 --> 00:25:08.980
The value evaluator is not
going to use them.

00:25:08.980 --> 00:25:10.880
The evaluator is not going to
produce functional values.

00:25:10.880 --> 00:25:12.310
So even if there were a
different, alternative

00:25:12.310 --> 00:25:16.510
language that were very close
to this, this evaluates a

00:25:16.510 --> 00:25:19.830
complex language like Scheme
which does allow procedural

00:25:19.830 --> 00:25:24.070
arguments, procedural values,
and procedural data.

00:25:24.070 --> 00:25:28.100
But even if I were evaluating
ALGOL, which doesn't allow

00:25:28.100 --> 00:25:31.580
procedural values, I could
use this evaluator.

00:25:31.580 --> 00:25:32.870
And this evaluator
is not making any

00:25:32.870 --> 00:25:34.050
assumptions about that.

00:25:34.050 --> 00:25:36.580
And, in fact, if this value were
to be restricted to not

00:25:36.580 --> 00:25:37.700
being able to that, it wouldn't
matter, because it

00:25:37.700 --> 00:25:40.640
doesn't use any of those
clever things.

00:25:40.640 --> 00:25:44.070
So that's why I'm arranging
this to be super simple.

00:25:44.070 --> 00:25:45.970
This is sort of the kernel
of all possible language

00:25:45.970 --> 00:25:47.810
evaluators.

00:25:47.810 --> 00:25:49.420
How about that?

00:25:49.420 --> 00:25:50.670
Evlist--

00:25:52.525 --> 00:25:53.820
well, what is it?

00:25:53.820 --> 00:25:56.300
It's the procedure of two
arguments, l and an

00:25:56.300 --> 00:26:06.260
environment, where l is a list
such that if the list of

00:26:06.260 --> 00:26:12.380
arguments is the empty list,
then the result is the empty

00:26:12.380 --> 00:26:21.480
list. Otherwise, I want to
cons up the result of

00:26:21.480 --> 00:26:31.880
evaluating the CAR of the
list of operands in the

00:26:31.880 --> 00:26:33.260
environment.

00:26:33.260 --> 00:26:36.360
So I want the first operand
evaluated, and I'm going to

00:26:36.360 --> 00:26:40.735
make a list of the results by
CONSing that onto the result

00:26:40.735 --> 00:26:48.880
of this EVLISTing as a CDR
recursion, the CDR of the list

00:26:48.880 --> 00:26:50.130
relative to the same
environment.

00:26:53.350 --> 00:26:57.960
Evlist, cons, else, COND,
lambda, define--

00:27:00.950 --> 00:27:03.620
And I have one more that I want
to put on the blackboard.

00:27:03.620 --> 00:27:05.470
It's the essence of
this whole thing.

00:27:05.470 --> 00:27:08.130
And there's some sort
of next layer down.

00:27:14.540 --> 00:27:15.770
Conditionals--

00:27:15.770 --> 00:27:17.500
conditionals are the only thing
left that are sort of

00:27:17.500 --> 00:27:18.880
substantial.

00:27:18.880 --> 00:27:22.320
Then below that, we have to
worry about things like lookup

00:27:22.320 --> 00:27:25.530
and bind, and we'll look
at that in a second.

00:27:25.530 --> 00:27:29.030
But of the substantial stuff at
this level of detail, next

00:27:29.030 --> 00:27:31.600
important thing is how you
deal with conditionals.

00:27:31.600 --> 00:27:33.330
Well, how do we have a
conditional thing?

00:27:37.670 --> 00:27:44.720
It's a procedure of a set of
clauses and an environment.

00:27:47.340 --> 00:27:49.820
And what does it do?

00:27:49.820 --> 00:28:03.310
It says, if I've no more
clauses, well, I have to give

00:28:03.310 --> 00:28:04.520
this a value.

00:28:04.520 --> 00:28:06.540
It could be that it
was an error.

00:28:06.540 --> 00:28:08.030
Supposing it run off
the end of a

00:28:08.030 --> 00:28:10.060
conditional, it's pretty arbitrary.

00:28:10.060 --> 00:28:13.650
It's up to me as programmer to
choose what I want to happen.

00:28:13.650 --> 00:28:15.940
It's convenient for me, right
now, to write down that this

00:28:15.940 --> 00:28:20.100
has a value which is the empty
list, doesn't matter.

00:28:20.100 --> 00:28:21.530
For error checking,
some people might

00:28:21.530 --> 00:28:23.110
prefer something else.

00:28:23.110 --> 00:28:25.570
But the interesting things
are the following ones.

00:28:25.570 --> 00:28:27.450
If I've got an else clause--

00:28:31.420 --> 00:28:34.120
You see, if I have a list of
clauses, then each clause is a

00:28:34.120 --> 00:28:37.480
list. And so the predicate
part is

00:28:37.480 --> 00:28:40.265
the CAAR of the clauses.

00:28:43.560 --> 00:28:48.070
It's the CAR, which is the first
part of the first clause

00:28:48.070 --> 00:28:51.090
in the list of clauses.

00:28:51.090 --> 00:28:55.900
If it's an else, then it means
I want my result of the

00:28:55.900 --> 00:28:58.400
conditional to be the result
of evaluating the matching

00:28:58.400 --> 00:28:59.800
expression.

00:28:59.800 --> 00:29:10.610
So I eval the CADR. So this is
the first clause, the second

00:29:10.610 --> 00:29:12.830
element of it, CADAR--

00:29:12.830 --> 00:29:16.360
CADAR of a CAR--

00:29:16.360 --> 00:29:22.195
of the clauses, with respect
to the environment.

00:29:26.620 --> 00:29:29.630
Now the next possibility
is more interesting.

00:29:29.630 --> 00:29:34.860
If it's false, if the first
predicate in the predicate

00:29:34.860 --> 00:29:38.840
list is not an else, and it's
not false, if it's not the

00:29:38.840 --> 00:29:42.050
word else, and if it's
not a false thing--

00:29:42.050 --> 00:29:44.360
Let's write down what it is
if it's a false thing.

00:29:44.360 --> 00:29:49.590
If the result of evaluating
the first

00:29:49.590 --> 00:29:52.900
predicate, the clauses--

00:29:55.490 --> 00:30:01.630
respect the environment, if that
evaluation yields false,

00:30:01.630 --> 00:30:04.180
then it means, I want to look
at the next clause.

00:30:04.180 --> 00:30:05.990
So I want to discard
the first one.

00:30:05.990 --> 00:30:15.450
So we just go around loop,
evcond, the CDR of the clauses

00:30:15.450 --> 00:30:16.700
relative to that environment.

00:30:21.240 --> 00:30:27.740
And otherwise, I had a true
clause, in which case, what I

00:30:27.740 --> 00:30:40.710
want is to evaluate the CADAR
of the clauses relative to

00:30:40.710 --> 00:30:41.960
that environment.

00:30:48.200 --> 00:30:51.210
Boy, it's almost done.

00:30:51.210 --> 00:30:53.730
It's quite close to done.

00:30:53.730 --> 00:30:56.210
I think we're going to
finish this part off.

00:30:56.210 --> 00:30:59.530
So just buzzing through this
evaluator, but so far you're

00:30:59.530 --> 00:31:01.220
seeing almost everything.

00:31:01.220 --> 00:31:04.040
Let's look at the next
transparency here.

00:31:08.980 --> 00:31:11.980
Here is bind.

00:31:11.980 --> 00:31:15.460
Bind is for making more table.

00:31:15.460 --> 00:31:19.260
And what we are going to
do here is make a--

00:31:19.260 --> 00:31:22.800
we're going to make a no-frame
for an environment structure.

00:31:22.800 --> 00:31:26.230
The environment structure is
going to be represented as a

00:31:26.230 --> 00:31:28.080
list of frames.

00:31:28.080 --> 00:31:30.520
So given an existing environment
structure, I'm

00:31:30.520 --> 00:31:32.500
going to make a new environment
structure by

00:31:32.500 --> 00:31:35.270
consing a new frame onto the
existing environment

00:31:35.270 --> 00:31:38.700
structure, where the new frame
consists of the result of

00:31:38.700 --> 00:31:41.940
pairing up the variables, which
are the bound variables

00:31:41.940 --> 00:31:45.610
of the procedure I'm applying,
to the values which are the

00:31:45.610 --> 00:31:49.690
arguments that were passed
that procedure.

00:31:49.690 --> 00:31:53.260
This is just making a list,
adding a new element to our

00:31:53.260 --> 00:31:56.070
list of frames, which is an
environment structure, to make

00:31:56.070 --> 00:31:58.391
a new environment.

00:31:58.391 --> 00:32:01.540
Where pair-up is very simple.

00:32:01.540 --> 00:32:04.610
Pair-up is nothing more than if
I have a list of variables

00:32:04.610 --> 00:32:07.830
and a list of values, well, if
I run out of variables and if

00:32:07.830 --> 00:32:09.720
I run out of values,
everything's OK.

00:32:09.720 --> 00:32:12.990
Otherwise, I've given
too many arguments.

00:32:12.990 --> 00:32:15.390
If I've not run out of
variables, but I've run out of

00:32:15.390 --> 00:32:18.560
values, that I have
too few arguments.

00:32:18.560 --> 00:32:20.695
And in the general case, where
I don't have any errors, and

00:32:20.695 --> 00:32:26.860
I'm not done, then I really am
just adding a new pair of the

00:32:26.860 --> 00:32:32.810
first variable with the first
argument, the first value,

00:32:32.810 --> 00:32:37.780
onto a list resulting from
pairing-up the rest of the

00:32:37.780 --> 00:32:42.950
variables with the rest
of the values.

00:32:42.950 --> 00:32:46.620
Lookup is of course
equally simple.

00:32:46.620 --> 00:32:50.230
If I have to look up a symbol
in an environment, well, if

00:32:50.230 --> 00:32:54.650
the environment is empty, then
I've got an unbound variable.

00:32:54.650 --> 00:32:59.770
Otherwise, what I'm going to do
is use a special pair list

00:32:59.770 --> 00:33:02.540
lookup procedure, which we'll
have very shortly, of the

00:33:02.540 --> 00:33:05.930
symbol in the first frame
of the environment.

00:33:05.930 --> 00:33:07.670
Since I know the environment is
not empty, it must have a

00:33:07.670 --> 00:33:09.200
first frame.

00:33:09.200 --> 00:33:11.140
So I lookup the symbol
in the first frame.

00:33:11.140 --> 00:33:15.150
That becomes the value
cell here.

00:33:15.150 --> 00:33:19.860
And then, if the value cell is
empty, if there is no such

00:33:19.860 --> 00:33:22.150
value cell, then I have to
continue and look at the rest

00:33:22.150 --> 00:33:23.720
of the frames.

00:33:23.720 --> 00:33:25.990
It means there was nothing
found there.

00:33:25.990 --> 00:33:29.740
So that's a property of ASSQ is
it returns emptiness if it

00:33:29.740 --> 00:33:32.010
doesn't find something.

00:33:32.010 --> 00:33:35.175
but if it did find something,
then I'm going to use the CDR

00:33:35.175 --> 00:33:38.080
of the value cell here, which is
the thing that was the pair

00:33:38.080 --> 00:33:41.050
consisting of the variable
and the value.

00:33:41.050 --> 00:33:45.000
So the CDR of it is
the value part.

00:33:45.000 --> 00:33:47.970
Finally, ASSQ is something
you've probably seen already.

00:33:47.970 --> 00:33:52.400
ASSQ takes a symbol and a list
of pairs, and if the list is

00:33:52.400 --> 00:33:53.760
empty, it's empty.

00:33:53.760 --> 00:33:57.850
If the symbol is the first
thing in the list--

00:33:57.850 --> 00:33:59.820
That's an error.

00:33:59.820 --> 00:34:04.160
That should be CAAR, C-A-A-R.
Everybody note that.

00:34:07.730 --> 00:34:08.980
Right there, OK?

00:34:13.121 --> 00:34:17.150
And in any case, if the symbol
is the CAAR of the A list,

00:34:17.150 --> 00:34:22.340
then I want the first, the first
pair, in the A list. So,

00:34:22.340 --> 00:34:26.300
in other words, if this is the
key matching the right entry,

00:34:26.300 --> 00:34:30.429
otherwise, I want to look up
that symbol in the rest. Sorry

00:34:30.429 --> 00:34:35.190
for producing a bug,
bugs appear.

00:34:35.190 --> 00:34:38.389
Well, in any case, you're
pretty much seeing

00:34:38.389 --> 00:34:39.639
the whole thing now.

00:34:41.880 --> 00:34:45.150
It's a very beautiful thing,
even though it's written in an

00:34:45.150 --> 00:34:49.600
ugly style, being the kernel
of every language.

00:34:49.600 --> 00:34:50.210
I suggest that we just--

00:34:50.210 --> 00:34:51.460
let's look at it for a while.

00:34:56.749 --> 00:35:49.750
[MUSIC PLAYING]

00:35:49.750 --> 00:35:51.000
Are there any questions?

00:36:01.180 --> 00:36:04.044
Alright, I suppose it's time
to take a small break then.

00:36:04.044 --> 00:36:56.780
[MUSIC PLAYING]

00:36:56.780 --> 00:36:59.390
OK, now we're just going to do
a little bit of practice

00:36:59.390 --> 00:37:03.470
understanding what it is
we've just shown you.

00:37:03.470 --> 00:37:05.700
What we're going to do is go
through, in detail, an

00:37:05.700 --> 00:37:09.720
evaluation by informally
substituting through the

00:37:09.720 --> 00:37:11.500
interpreter.

00:37:11.500 --> 00:37:14.160
And since we have no assignments
or definitions in

00:37:14.160 --> 00:37:18.470
this interpreter, we have no
possible side effects, and so

00:37:18.470 --> 00:37:23.200
the we can do substitution with
impunity and not worry

00:37:23.200 --> 00:37:25.330
about results.

00:37:25.330 --> 00:37:28.800
So the particular problem I'd
like to look at is it an

00:37:28.800 --> 00:37:30.690
interesting one.

00:37:30.690 --> 00:37:41.910
It's the evaluation of quote,
open, open, open, lambda of x,

00:37:41.910 --> 00:37:55.100
lambda of y plus x y, lambda,
lambda, applied to three,

00:37:55.100 --> 00:37:58.640
applied to four, in some
global environment

00:37:58.640 --> 00:37:59.890
which I'll call e0.

00:38:04.930 --> 00:38:07.900
So what we have here is a
procedure of one argument x,

00:38:07.900 --> 00:38:10.980
which produces as its value a
procedure of one argument y,

00:38:10.980 --> 00:38:14.300
which adds x to y.

00:38:14.300 --> 00:38:17.960
We are applying the procedure
of one argument x to three.

00:38:17.960 --> 00:38:21.400
So x should become three.

00:38:21.400 --> 00:38:23.590
And the result of that should
be procedure of one argument

00:38:23.590 --> 00:38:26.167
y, which will then apply to 4.

00:38:28.910 --> 00:38:31.480
And there is a very simple
case, they will

00:38:31.480 --> 00:38:34.790
then add those results.

00:38:34.790 --> 00:38:36.860
And now in order to do that, I
want to make a very simple

00:38:36.860 --> 00:38:37.660
environment model.

00:38:37.660 --> 00:38:41.200
And at this point, you should
already have in your mind the

00:38:41.200 --> 00:38:44.460
environments that
this produces.

00:38:44.460 --> 00:38:48.810
But we're going to start out
with a global environment,

00:38:48.810 --> 00:38:56.740
which I'll call e0,
which is that.

00:38:56.740 --> 00:39:00.550
And it's going to have in it
things, definitions for plus,

00:39:00.550 --> 00:39:07.390
and times, and--

00:39:07.390 --> 00:39:08.560
using Greek letters, isn't that

00:39:08.560 --> 00:39:11.290
interesting, for the objects--

00:39:11.290 --> 00:39:27.330
and minus, and quotient, and
CAR, and CDR, and CONS, and

00:39:27.330 --> 00:39:30.480
EQ, and everything else you
might imagine in a global

00:39:30.480 --> 00:39:31.270
environment.

00:39:31.270 --> 00:39:34.590
It's got something there for
each of those things,

00:39:34.590 --> 00:39:39.220
something the machine is
born with, that's e0.

00:39:39.220 --> 00:39:42.940
Now what does it mean to
do this evaluation?

00:39:42.940 --> 00:39:46.120
Well, we go through the set of
special forms. First of all,

00:39:46.120 --> 00:39:48.670
this is not a number.

00:39:48.670 --> 00:39:50.380
This is not a symbol.

00:39:53.210 --> 00:39:56.520
Gee, it's not a quoted
expression.

00:39:56.520 --> 00:40:00.080
This is a quoted expression,
but that's not what I

00:40:00.080 --> 00:40:00.600
interested in.

00:40:00.600 --> 00:40:02.700
The question is, whether or not
the thing which is quoted

00:40:02.700 --> 00:40:05.890
is quoted expression?

00:40:05.890 --> 00:40:07.960
I'm evaluating an expression.

00:40:07.960 --> 00:40:11.410
This just says it's this
particular expression.

00:40:11.410 --> 00:40:12.660
This is not a quoted
expression.

00:40:15.230 --> 00:40:19.120
It's not a thing that
begins with lambda.

00:40:19.120 --> 00:40:22.030
It's not a thing that
begins with COND.

00:40:22.030 --> 00:40:24.630
Therefore, it's an application
of its

00:40:24.630 --> 00:40:26.310
of an operated operands.

00:40:26.310 --> 00:40:28.570
It's a combination.

00:40:28.570 --> 00:40:35.230
The combination thus has this
as the operator and this is

00:40:35.230 --> 00:40:36.480
the operands.

00:40:40.130 --> 00:40:43.540
Well, that means that what I'm
going to do is transform this

00:40:43.540 --> 00:40:54.010
into apply of eval, of quote,
open, open lambda of

00:40:54.010 --> 00:40:58.180
x, lambda of y--

00:40:58.180 --> 00:40:59.980
I'm evaluating the operator--

00:40:59.980 --> 00:41:13.610
plus x y, in the environment,
also e0, with the operands

00:41:13.610 --> 00:41:16.330
that I'm going to apply this
to, the arguments being the

00:41:16.330 --> 00:41:24.450
result of EVLIST, the list
containing four, fin e0.

00:41:29.010 --> 00:41:33.010
I'm using this funny notation
here for e0 because this

00:41:33.010 --> 00:41:36.840
should be that environment.

00:41:36.840 --> 00:41:38.640
I haven't a name for it, because
I have no environment

00:41:38.640 --> 00:41:39.890
to name it in.

00:41:41.960 --> 00:41:44.630
So this is just a representation
of what would

00:41:44.630 --> 00:41:47.730
be a quoted expression,
if you will.

00:41:47.730 --> 00:41:53.040
The data structure, which is the
environment, goes there.

00:41:53.040 --> 00:41:55.850
Well, that's what we're
seeing here.

00:41:55.850 --> 00:41:57.370
Well in order to do this,
I have to do this, and

00:41:57.370 --> 00:41:59.610
I have to do that.

00:41:59.610 --> 00:42:03.770
Well this one's easy, so why
don't we do that one first.

00:42:03.770 --> 00:42:07.780
This turns into apply
of eval-- just

00:42:07.780 --> 00:42:09.520
copying something now.

00:42:09.520 --> 00:42:11.000
Most of the substitution
rule is copying.

00:42:18.530 --> 00:42:22.100
So I'm going to not say the
words when I copy, because

00:42:22.100 --> 00:42:23.350
it's faster.

00:42:26.100 --> 00:42:34.130
And then the EVLIST is going to
turn into a cons, of eval,

00:42:34.130 --> 00:42:36.160
of four, in e0--

00:42:38.780 --> 00:42:42.260
because it was not
an empty list--

00:42:42.260 --> 00:42:48.910
onto the result of EVLISTing,
on the empty list, in e0.

00:42:52.580 --> 00:42:54.550
And I'm going to start leaving
out steps soon, because it's

00:42:54.550 --> 00:42:55.800
going to get boring.

00:42:59.870 --> 00:43:05.025
But this is basically the same
thing as apply, of eval--

00:43:07.640 --> 00:43:10.230
I'm going to keep doing this--

00:43:10.230 --> 00:43:20.240
the lambda of x, the lambda of
y, plus xy, 3, close, e0.

00:43:20.240 --> 00:43:21.490
I'm a pretty good machine.

00:43:24.690 --> 00:43:27.410
Well, eval of four,
that's meets the

00:43:27.410 --> 00:43:28.790
question, is it a number.

00:43:28.790 --> 00:43:35.280
So that's cons, cons of 4.

00:43:35.280 --> 00:43:37.110
And EVLIST of the empty
list is the empty

00:43:37.110 --> 00:43:39.240
list, so that's this.

00:43:43.270 --> 00:43:46.170
And that's very simple to
understand, because that means

00:43:46.170 --> 00:43:48.710
the list containing
four itself.

00:43:48.710 --> 00:43:56.340
So this is nothing more than
apply of eval, quote, open,

00:43:56.340 --> 00:44:06.590
open, lambda of x, lambda of y,
plus x y, three applied to,

00:44:06.590 --> 00:44:11.678
e0, applied to the list four--

00:44:11.678 --> 00:44:13.940
bang.

00:44:13.940 --> 00:44:15.190
So that's that step.

00:44:18.100 --> 00:44:20.360
Now let's look at the next,
more interesting thing.

00:44:20.360 --> 00:44:23.070
What do I do to evaluate that?

00:44:23.070 --> 00:44:27.780
Evaluating this means
I have to evaluate--

00:44:27.780 --> 00:44:29.460
Well, it's not.

00:44:29.460 --> 00:44:31.680
It's nothing but
an application.

00:44:31.680 --> 00:44:33.570
It's not one of the
special things.

00:44:33.570 --> 00:44:37.660
If the application of this
operator, which we see here--

00:44:37.660 --> 00:44:40.270
here's the operator--

00:44:40.270 --> 00:44:46.570
applied to this operands,
that combination.

00:44:46.570 --> 00:44:51.390
But we know how to do that,
because that's the last case

00:44:51.390 --> 00:44:52.370
of the conditional.

00:44:52.370 --> 00:44:56.480
So substituting in for this
evaluation, it's apply of eval

00:44:56.480 --> 00:45:01.160
of the operator in the EVLIST
of the operands.

00:45:01.160 --> 00:45:12.100
Well, it's apply, of apply, of
eval, of quote, open, lambda

00:45:12.100 --> 00:45:23.780
of x, lambda of y, plus
x y, lambda, lambda,

00:45:23.780 --> 00:45:25.350
in environment e0.

00:45:30.520 --> 00:45:32.730
I'm going to short circuit the
evaluation of the operands ,

00:45:32.730 --> 00:45:35.230
because they're the same
as they were before.

00:45:35.230 --> 00:45:38.080
I got a list containing
three, apply that, and

00:45:38.080 --> 00:45:39.330
apply that to four.

00:45:42.780 --> 00:45:44.410
Well let's see.

00:45:44.410 --> 00:45:49.450
Eval of a lambda expression
produces a procedure object.

00:45:52.030 --> 00:46:04.530
So this is apply, of apply, of
the procedure object closure,

00:46:04.530 --> 00:46:09.420
which contains the body of the
procedure, x, which is

00:46:09.420 --> 00:46:12.130
lambda-- which binds
x [UNINTELLIGIBLE]

00:46:12.130 --> 00:46:17.230
the internals of the body, it
returns the procedure of one

00:46:17.230 --> 00:46:20.630
argument y, which adds x to y.

00:46:23.210 --> 00:46:27.930
Environment e0 is now captured
in it, because this was

00:46:27.930 --> 00:46:30.340
evaluated with respect to e0.

00:46:30.340 --> 00:46:33.040
e0 is part now of the
closure object.

00:46:33.040 --> 00:46:40.050
Apply that to open, three,
close, apply, to open, 4,

00:46:40.050 --> 00:46:41.300
close, apply.

00:46:47.390 --> 00:46:50.220
So going from this step to this
step meant that I made up

00:46:50.220 --> 00:46:55.060
a procedure object which
captured in it e0 as part of

00:46:55.060 --> 00:46:57.150
the procedure object.

00:46:57.150 --> 00:46:58.620
Now, we're going to pass
those to apply.

00:46:58.620 --> 00:47:00.480
We have to apply this procedure

00:47:00.480 --> 00:47:02.710
to that set of arguments.

00:47:02.710 --> 00:47:07.380
Well, but that procedure
is not primitive.

00:47:07.380 --> 00:47:10.500
It's, in fact, a thing which has
got the tag closure, and,

00:47:10.500 --> 00:47:13.710
therefore, what we have
to do is do a bind.

00:47:13.710 --> 00:47:15.830
We have to bind.

00:47:15.830 --> 00:47:21.850
A new environment is made at
this point, which has as its

00:47:21.850 --> 00:47:26.980
parent environment the one
over here, e0, that

00:47:26.980 --> 00:47:28.230
environment.

00:47:30.320 --> 00:47:31.570
And we'll call this one, e1.

00:47:34.620 --> 00:47:36.040
Now what's bound in there?

00:47:36.040 --> 00:47:38.620
x is bound to three.

00:47:38.620 --> 00:47:41.480
So I have x equal three.

00:47:41.480 --> 00:47:42.730
That's what's in there.

00:47:44.940 --> 00:47:46.240
And we'll call that e1.

00:47:46.240 --> 00:47:51.940
So what this transforms into
is an eval of the body of

00:47:51.940 --> 00:47:56.740
this, which is this, the body
of that procedure, in the

00:47:56.740 --> 00:48:00.290
environment that you just saw.

00:48:00.290 --> 00:48:11.480
So that's an apply, of eval,
quote, open, lambda of y, plus

00:48:11.480 --> 00:48:12.750
x y-- the body--

00:48:15.270 --> 00:48:16.520
in e1.

00:48:20.660 --> 00:48:26.040
And apply the result of that
to four, open, close, 4--

00:48:26.040 --> 00:48:28.680
list of arguments.

00:48:28.680 --> 00:48:31.600
Well, that's sensible enough
because evaluating a lambda, I

00:48:31.600 --> 00:48:33.110
know what to do.

00:48:33.110 --> 00:48:43.680
That means I apply, the
procedure which is closure,

00:48:43.680 --> 00:48:52.150
binds one argument y, adds x to
y, with e1 captured in it.

00:48:55.790 --> 00:48:57.800
And you should really
see this.

00:48:57.800 --> 00:49:00.140
I somehow manufactured
a closure.

00:49:00.140 --> 00:49:01.790
I should've put this here.

00:49:01.790 --> 00:49:03.040
There was one over here too.

00:49:06.230 --> 00:49:08.080
Well, there's one here now.

00:49:08.080 --> 00:49:13.710
I've captured e1, and this is
the procedure of one argument

00:49:13.710 --> 00:49:17.880
y, whatever this is.

00:49:17.880 --> 00:49:20.435
That's what that is there,
that closure.

00:49:23.040 --> 00:49:26.230
I'm going to apply
that to four.

00:49:30.690 --> 00:49:31.940
Well, that's easy enough.

00:49:36.830 --> 00:49:39.720
That means I have to make a
new environment by copying

00:49:39.720 --> 00:49:45.030
this pointer, which was the
pointer of the procedure,

00:49:45.030 --> 00:49:49.540
which binds y equal 4 with
that environment.

00:49:49.540 --> 00:49:52.460
And here's my new environment,
which I'll call e2.

00:49:55.870 --> 00:49:58.990
And, of course, this application
then is evaluate

00:49:58.990 --> 00:50:01.910
the body in e2.

00:50:01.910 --> 00:50:10.830
So this is eval, the body,
which is plus x y, in the

00:50:10.830 --> 00:50:13.710
environment e2.

00:50:13.710 --> 00:50:22.220
But this is an application, so
this is the apply, of eval,

00:50:22.220 --> 00:50:37.340
plus in e2, an EVLIST, quote,
open, x y, in e2.

00:50:44.880 --> 00:50:45.590
Well, but let's see.

00:50:45.590 --> 00:50:52.480
That is apply, the
object which is a

00:50:52.480 --> 00:50:54.190
result of that and plus.

00:50:54.190 --> 00:50:57.920
So here we are in e2, plus is
not here, it's not here, oh,

00:50:57.920 --> 00:51:01.780
yes, but's here as some
primitive operator.

00:51:01.780 --> 00:51:04.745
So it's the primitive operator
for addition.

00:51:08.490 --> 00:51:14.370
Apply that to the result of
evaluating x and y in e2.

00:51:14.370 --> 00:51:18.340
But we can see that x is
three and y is four.

00:51:18.340 --> 00:51:23.936
So that's a three
and four, here.

00:51:23.936 --> 00:51:26.280
And that magically produces
for me a seven.

00:51:30.520 --> 00:51:33.460
I wanted to go through this so
you would see, essentially,

00:51:33.460 --> 00:51:36.960
one important ingredient, which
is what's being passed

00:51:36.960 --> 00:51:40.470
around, and who owns what,
and what his job is.

00:51:40.470 --> 00:51:41.700
So what do we have here?

00:51:41.700 --> 00:51:46.520
We have eval, and we have apply,
the two main players.

00:51:49.370 --> 00:51:52.320
And there is a big loop the
goes around like this.

00:51:52.320 --> 00:52:00.780
Which is eval produces
a procedure and

00:52:00.780 --> 00:52:06.270
arguments for apply.

00:52:06.270 --> 00:52:09.710
Now some things eval
could do by itself.

00:52:09.710 --> 00:52:10.860
Those are little self
things here.

00:52:10.860 --> 00:52:12.700
They're not interesting.

00:52:12.700 --> 00:52:16.240
Also eval evaluates all of the
arguments, one after another.

00:52:16.240 --> 00:52:17.650
That's not very interesting.

00:52:17.650 --> 00:52:21.540
Apply can apply some procedures
like plus, not very

00:52:21.540 --> 00:52:22.300
interesting.

00:52:22.300 --> 00:52:25.520
However, if apply can't apply
a procedure like plus, it

00:52:25.520 --> 00:52:32.880
produces an expression and
environment for eval.

00:52:35.470 --> 00:52:39.770
The procedural arguments wrap up
essentially the state of a

00:52:39.770 --> 00:52:43.740
computation and, certainly, the
expression of environment.

00:52:43.740 --> 00:52:45.600
And so what we're actually going
to do next is not the

00:52:45.600 --> 00:52:47.570
complete state, because
it doesn't say

00:52:47.570 --> 00:52:48.820
who wants the answers.

00:52:51.280 --> 00:52:53.500
But what we're going to do--
it's always got something like

00:52:53.500 --> 00:52:56.580
an expression of environment or
procedure and arguments as

00:52:56.580 --> 00:52:58.970
the main loop that we're
going around.

00:52:58.970 --> 00:53:01.500
There are minor little sub
loops like eval through

00:53:01.500 --> 00:53:11.030
EVLIST, or eval through evcond,
or apply through a

00:53:11.030 --> 00:53:12.280
primitive apply.

00:53:16.140 --> 00:53:18.500
But they're not the
essential things.

00:53:18.500 --> 00:53:21.860
So that's what I wanted
you to see.

00:53:21.860 --> 00:53:23.110
Are there any questions?

00:53:25.930 --> 00:53:28.690
Yes.

00:53:28.690 --> 00:53:32.670
AUDIENCE: I'm trying to
understand how x got down to

00:53:32.670 --> 00:53:37.070
three instead of four.

00:53:37.070 --> 00:53:38.540
At the early part of the--

00:53:38.540 --> 00:53:41.310
PROFESSOR: Here.

00:53:41.310 --> 00:53:43.310
You want to know how x
got down to three?

00:53:43.310 --> 00:53:49.770
AUDIENCE: Because x is the outer
procedure, and x and y

00:53:49.770 --> 00:53:51.040
are the inner procedure.

00:53:51.040 --> 00:53:52.570
PROFESSOR: Fine.

00:53:52.570 --> 00:53:55.280
Well, I was very careful
and mechanical.

00:53:55.280 --> 00:53:57.350
First of all, I should write
those procedures again for

00:53:57.350 --> 00:54:00.610
you, pretty printed.

00:54:00.610 --> 00:54:02.260
First order of business, because
you're probably not

00:54:02.260 --> 00:54:03.830
reading them well.

00:54:03.830 --> 00:54:08.500
So I have here that
procedure of--

00:54:08.500 --> 00:54:11.280
was it x over there--

00:54:11.280 --> 00:54:12.690
which is--

00:54:12.690 --> 00:54:20.710
value of that procedure of y,
which adds x to y, lambda,

00:54:20.710 --> 00:54:25.380
lambda, applied that to three,
takes the result of that, and

00:54:25.380 --> 00:54:26.140
applied that to four.

00:54:26.140 --> 00:54:28.810
Is that not what I wrote?

00:54:28.810 --> 00:54:34.170
Now, you should immediately
see that here is an

00:54:34.170 --> 00:54:35.150
application--

00:54:35.150 --> 00:54:37.400
let me get a white
piece of chalk--

00:54:37.400 --> 00:54:40.735
here is an application,
a combination.

00:54:44.300 --> 00:54:48.270
That combination has this
as the operator

00:54:48.270 --> 00:54:51.040
and this as the operand.

00:54:51.040 --> 00:54:54.900
The three is going in
for the x here.

00:54:54.900 --> 00:54:58.720
The result of this is a
procedure of one argument y,

00:54:58.720 --> 00:55:01.530
which gets applied to four.

00:55:01.530 --> 00:55:04.190
So you just weren't reading
the expression right.

00:55:04.190 --> 00:55:11.580
The way you see that over here
is that here I have the actual

00:55:11.580 --> 00:55:13.340
procedure object, x.

00:55:13.340 --> 00:55:18.980
It's getting applied to three,
the list containing three.

00:55:18.980 --> 00:55:20.350
What I'm left over with
is something which

00:55:20.350 --> 00:55:24.080
gets applied to four.

00:55:24.080 --> 00:55:25.330
Are there any other questions?

00:55:28.600 --> 00:55:30.900
Time for our next small
break then.

00:55:30.900 --> 00:55:33.735
Thank you.

00:55:33.735 --> 00:56:08.410
[MUSIC PLAYING]

00:56:08.410 --> 00:56:14.730
Let's see, at this point, you
should be getting the feeling,

00:56:14.730 --> 00:56:16.630
what's this nonsense
this Sussman

00:56:16.630 --> 00:56:17.960
character is feeding me?

00:56:20.740 --> 00:56:24.800
There's an awful lot of
strange nonsense here.

00:56:24.800 --> 00:56:28.300
After all, he purported to
explain to me Lisp, and he

00:56:28.300 --> 00:56:30.892
wrote me a Lisp program
on the blackboard.

00:56:30.892 --> 00:56:33.560
The Lisp program was intended
to be interpreted for Lisp,

00:56:33.560 --> 00:56:35.280
but you need a Lisp interpreter
in order to

00:56:35.280 --> 00:56:38.370
understand that program.

00:56:38.370 --> 00:56:41.160
How could that program have told
me anything there is to

00:56:41.160 --> 00:56:44.150
be known about Lisp?

00:56:44.150 --> 00:56:45.795
How is that not completely
vacuous?

00:56:48.490 --> 00:56:50.990
It's a very strange thing.

00:56:50.990 --> 00:56:52.430
Does it tell me anything
at all?

00:56:56.070 --> 00:56:59.230
Well, you see, the whole thing
is sort of like these Escher's

00:56:59.230 --> 00:57:03.105
hands that we see
on this slide.

00:57:06.180 --> 00:57:11.750
Yes, eval and apply each sort
of draw each other and

00:57:11.750 --> 00:57:15.690
construct the real thing,
which can sit

00:57:15.690 --> 00:57:17.110
out and draw itself.

00:57:17.110 --> 00:57:19.300
Escher was a very brilliant man,
he just didn't know the

00:57:19.300 --> 00:57:20.550
names of these spirits.

00:57:23.910 --> 00:57:27.700
Well, I'm going to do now, is
I'm going to try to convince

00:57:27.700 --> 00:57:33.060
you that both this mean
something, and, as a aside,

00:57:33.060 --> 00:57:36.090
I'm going to show you why you
don't need definitions.

00:57:36.090 --> 00:57:38.760
Just turns out that that sort of
falls out, why definitions

00:57:38.760 --> 00:57:42.990
are not essential in a
mathematical sense for doing

00:57:42.990 --> 00:57:44.890
all the things we need
to do for computing.

00:57:49.070 --> 00:57:50.690
Well, let's see here.

00:57:50.690 --> 00:57:54.870
Consider the following small
program, what does it mean?

00:57:54.870 --> 00:57:57.035
This is a program for computing
exponentials.

00:58:07.270 --> 00:58:13.350
The exponential of x to
the nth power is if--

00:58:16.910 --> 00:58:22.070
and is zero, then the
result is one.

00:58:22.070 --> 00:58:29.520
Otherwise, I want the product
of x and the result of

00:58:29.520 --> 00:58:33.930
exponentiating x to the
n minus one power.

00:58:42.858 --> 00:58:46.630
I think I got it right.

00:58:46.630 --> 00:58:49.470
Now this is a recursive
definition.

00:58:49.470 --> 00:58:53.930
It's a definition of the
exponentiation procedure in

00:58:53.930 --> 00:58:56.410
terms of itself.

00:58:56.410 --> 00:59:00.710
And, as it has been mentioned
before, your high school

00:59:00.710 --> 00:59:03.010
geometry teacher probably
gave you a hard time

00:59:03.010 --> 00:59:05.650
about things like that.

00:59:05.650 --> 00:59:07.910
Was that justified?

00:59:07.910 --> 00:59:13.430
Why does this self referential
definition make any sense?

00:59:13.430 --> 00:59:15.060
Well, first of all, I'm going to
convince you that your high

00:59:15.060 --> 00:59:17.600
school geometry teacher was
I telling you nonsense.

00:59:20.370 --> 00:59:24.490
Consider the following set
of definitions here.

00:59:24.490 --> 00:59:33.070
x plus y equals three, and
x minus y equal one.

00:59:33.070 --> 00:59:36.170
Well, gee, this tells you x in
terms of y, and this one tells

00:59:36.170 --> 00:59:37.490
you y in terms of
x, presumably.

00:59:40.150 --> 00:59:42.950
And yet this happens to have a
unique solution in x and y.

00:59:55.910 --> 01:00:06.600
However, I could also write
two x plus two y is six.

01:00:06.600 --> 01:00:09.610
These two equations have an
infinite number solutions.

01:00:15.730 --> 01:00:21.520
And I could write you, for
example, x minus y equal 2,

01:00:21.520 --> 01:00:24.070
and these two equations
have no solutions.

01:00:29.820 --> 01:00:32.350
Well, I have here three sets
of simultaneous linear

01:00:32.350 --> 01:00:39.510
equations, this set, this
set, and this set.

01:00:39.510 --> 01:00:42.900
But they have different
numbers of solutions.

01:00:42.900 --> 01:00:45.760
The number of solutions is not
in the form of the equations.

01:00:45.760 --> 01:00:48.350
They all three sets have
the same form.

01:00:48.350 --> 01:00:50.205
The number of solutions
is in the content.

01:00:53.000 --> 01:00:55.510
I can't tell by looking at the
form of a definition whether

01:00:55.510 --> 01:00:59.660
it makes sense, only by
its detailed content.

01:00:59.660 --> 01:01:02.170
What are the coefficients,
for example, in the

01:01:02.170 --> 01:01:05.100
case of linear equations?

01:01:05.100 --> 01:01:07.440
So I shouldn't expect to be
able to tell looking at

01:01:07.440 --> 01:01:11.500
something like this, from some
simple things like, oh yes,

01:01:11.500 --> 01:01:16.030
EXPT is the solution of this
recursion equation.

01:01:16.030 --> 01:01:22.110
Expt is the procedure which
if substituted in here,

01:01:22.110 --> 01:01:26.040
gives me EXPT back.

01:01:26.040 --> 01:01:30.750
I can't tell, looking at this
form, whether or not there's a

01:01:30.750 --> 01:01:33.970
single, unique solution for
EXPT, an infinite number of

01:01:33.970 --> 01:01:37.200
solutions, or no solutions.

01:01:37.200 --> 01:01:38.930
It's got to be how it
counts and things

01:01:38.930 --> 01:01:40.490
like that, the details.

01:01:40.490 --> 01:01:42.900
And it's harder in programming
than linear algebra.

01:01:42.900 --> 01:01:45.210
There aren't too many theorems
about it in programming.

01:01:48.450 --> 01:01:50.990
Well, I want to rewrite these
equations a little

01:01:50.990 --> 01:01:53.970
bit, these over here.

01:01:53.970 --> 01:01:55.560
Because what we're
investigating is

01:01:55.560 --> 01:01:56.770
equations like this.

01:01:56.770 --> 01:01:58.820
But I want to play a little with
equations like this that

01:01:58.820 --> 01:02:02.050
we understand, just so we
get some insight into

01:02:02.050 --> 01:02:04.730
this kind of question.

01:02:04.730 --> 01:02:07.870
We could rewrite our equations
here, say these two, the ones

01:02:07.870 --> 01:02:17.070
that are interesting, as x
equals three minus y, and y

01:02:17.070 --> 01:02:19.380
equals x minus one.

01:02:22.010 --> 01:02:24.050
What do we call this
transformation?

01:02:24.050 --> 01:02:26.095
This is a linear transformation,
t.

01:02:29.430 --> 01:02:35.390
Then what we're getting here
is an equation x y

01:02:35.390 --> 01:02:37.370
equals t of x y.

01:02:42.990 --> 01:02:44.560
What am I looking for?

01:02:44.560 --> 01:02:47.040
I'm looking for a fixed
point of t.

01:02:47.040 --> 01:02:59.350
The solution is a fixed
point of t.

01:03:01.910 --> 01:03:04.830
So the methods we should have
for looking for solutions to

01:03:04.830 --> 01:03:09.230
equations, if I can do it by
fixed points, might be

01:03:09.230 --> 01:03:10.880
applicable.

01:03:10.880 --> 01:03:13.710
If I have a means of finding a
solution to an equations by

01:03:13.710 --> 01:03:15.690
fixed points--

01:03:15.690 --> 01:03:18.620
just, might not work--

01:03:18.620 --> 01:03:21.160
but it might be applicable to
investigating solutions of

01:03:21.160 --> 01:03:22.410
equations like this.

01:03:27.240 --> 01:03:30.260
But what I want you to feel is
that this is an equation.

01:03:30.260 --> 01:03:32.930
It's an expression with several
instances of various

01:03:32.930 --> 01:03:39.020
names which puts a constraint on
the name, saying what that

01:03:39.020 --> 01:03:42.770
name could have as its value,
rather than some sort of

01:03:42.770 --> 01:03:45.010
mechanical process of
substitution right now.

01:03:47.740 --> 01:03:51.220
This is an equation which I'm
going to try to solve.

01:03:51.220 --> 01:03:53.960
Well, let's play around
and solve it.

01:03:53.960 --> 01:03:57.800
First of all, I want to write
down the function which

01:03:57.800 --> 01:04:00.320
corresponds to t.

01:04:00.320 --> 01:04:02.670
First I want to write down the
function which corresponds to

01:04:02.670 --> 01:04:06.960
t whose fixed point is the
answer to this question.

01:04:11.950 --> 01:04:14.240
Well, let's consider the
following procedure f.

01:04:16.870 --> 01:04:19.340
I claim it computes
that function.

01:04:19.340 --> 01:04:26.860
f is that procedure of one
argument g, which is that

01:04:26.860 --> 01:04:33.430
procedure of two arguments
x and n.

01:04:33.430 --> 01:04:42.410
Which have the property that if
n is zero, then the result

01:04:42.410 --> 01:04:56.050
is one, otherwise, the result
is the product of x and g,

01:04:56.050 --> 01:05:00.690
applied to x, and minus n1.

01:05:03.370 --> 01:05:07.900
g, times, else, COND,
lambda, lambda--

01:05:11.900 --> 01:05:17.230
Here f is a procedure, which
if I had a solution to that

01:05:17.230 --> 01:05:23.640
equation, if I had a good
exponentiation procedure, and

01:05:23.640 --> 01:05:29.500
I applied f to that procedure,
then the result would be a

01:05:29.500 --> 01:05:30.930
good exponentiation procedure.

01:05:37.460 --> 01:05:39.420
Because, what does it do?

01:05:39.420 --> 01:05:44.200
Well, all it is is exposing g
were a good exponentiation

01:05:44.200 --> 01:05:48.010
procedure, well then this would
produce, as its value, a

01:05:48.010 --> 01:05:51.650
procedure to arguments x and n,
such that if n were 0, the

01:05:51.650 --> 01:05:53.360
result would be one, which
is certainly true of

01:05:53.360 --> 01:05:54.670
exponentiation.

01:05:54.670 --> 01:05:57.730
Otherwise, it will be the result
of multiplying x by the

01:05:57.730 --> 01:06:01.750
exponentiation procedure given
to me with x and n minus one

01:06:01.750 --> 01:06:03.470
as arguments.

01:06:03.470 --> 01:06:05.680
So if this computed the correct
exponentiation for n

01:06:05.680 --> 01:06:10.500
minus one, then this would be
the correct exponentiation for

01:06:10.500 --> 01:06:13.370
exponent n, so this would
have been the right

01:06:13.370 --> 01:06:14.620
exponentiation procedure.

01:06:17.500 --> 01:06:26.560
So what I really want to say
here is E-X-P-T is a fixed

01:06:26.560 --> 01:06:32.320
point of f.

01:06:37.550 --> 01:06:40.060
Now our problem is there might
be more than one fixed point.

01:06:40.060 --> 01:06:43.270
There might be no
fixed points.

01:06:43.270 --> 01:06:44.810
I have to go hunting for
the fixed points.

01:06:48.290 --> 01:06:49.540
Got to solve this equation.

01:06:52.160 --> 01:06:55.580
Well there are various ways
to hunt for fixed points.

01:06:55.580 --> 01:06:58.080
Of course, the one we played
with at the beginning of this

01:06:58.080 --> 01:07:00.815
term worked for cosine.

01:07:06.080 --> 01:07:09.235
Go into radians mode on your
calculator and push cosine,

01:07:09.235 --> 01:07:12.990
and just keep doing it, and you
get to some number which

01:07:12.990 --> 01:07:16.090
is about 0.73 or 0.74.

01:07:16.090 --> 01:07:17.340
I can't remember which.

01:07:22.900 --> 01:07:27.170
By iterating a function, whose
fixed point I'm searching for,

01:07:27.170 --> 01:07:32.090
it is sometimes the case that
that function will converge in

01:07:32.090 --> 01:07:33.770
producing the fixed point.

01:07:33.770 --> 01:07:39.910
I think we luck out in this
case, so let's look for it.

01:07:39.910 --> 01:07:48.030
Let's look at this slide.

01:07:48.030 --> 01:07:51.390
Consider the following sequence
of procedures.

01:07:56.400 --> 01:08:02.940
e0 over here is the procedure
which does nothing at all.

01:08:02.940 --> 01:08:05.390
It's the procedure which
produces an error for any

01:08:05.390 --> 01:08:07.780
arguments you give it.

01:08:07.780 --> 01:08:09.030
It's basically useless.

01:08:14.480 --> 01:08:20.080
Well, however, I can make
an approximation.

01:08:20.080 --> 01:08:22.930
Let's consider it the worst
possible approximation to

01:08:22.930 --> 01:08:26.990
exponentiation, because
it does nothing.

01:08:26.990 --> 01:08:34.170
Well, supposing I substituted e0
for g by calling f, as you

01:08:34.170 --> 01:08:37.380
see over here on e0.

01:08:37.380 --> 01:08:40.729
So you see over here,
have e0 there.

01:08:40.729 --> 01:08:43.859
Then gee, what's e1?

01:08:43.859 --> 01:08:47.189
e1 is a procedure which
exponentiate things to the 0th

01:08:47.189 --> 01:08:49.325
power, with no trouble.

01:08:49.325 --> 01:08:52.420
It gets the right answer,
anything to the zero is one,

01:08:52.420 --> 01:08:54.250
and it makes an error
on anything else.

01:08:57.390 --> 01:09:06.040
Well, now what if I take e1 and
I substitute if for g by

01:09:06.040 --> 01:09:07.310
calling f on e1?

01:09:10.500 --> 01:09:15.670
Oh gosh, I have here a procedure
of two arguments.

01:09:15.670 --> 01:09:18.250
Now remember e1 was appropriate
for taking

01:09:18.250 --> 01:09:24.200
exponentiations of 0, for
raising to the 0 exponent.

01:09:24.200 --> 01:09:27.910
So here, is n is 0, the result
is one, so this guy is good

01:09:27.910 --> 01:09:29.520
for that too.

01:09:29.520 --> 01:09:32.479
However, I can use something for
raising to the 0th power

01:09:32.479 --> 01:09:35.979
to multiply it by x to raise
something to the first power.

01:09:35.979 --> 01:09:39.670
So e2 is good for both
power 0 and one.

01:09:43.800 --> 01:09:47.899
And e3 is constructed from
e2 in the same way.

01:09:47.899 --> 01:09:52.240
And e3, of course, by the same
argument is good for powers 0,

01:09:52.240 --> 01:09:55.120
one, and two.

01:09:55.120 --> 01:10:00.140
And so I will assert for you,
without proof, because the

01:10:00.140 --> 01:10:02.520
proof is horribly difficult.

01:10:02.520 --> 01:10:04.050
And that's the sort of thing
that people called

01:10:04.050 --> 01:10:07.710
denotational semanticists do.

01:10:07.710 --> 01:10:10.265
This great idea was invented
by Scott and Strachey.

01:10:14.240 --> 01:10:17.110
They're very famous
mathematician types who

01:10:17.110 --> 01:10:21.030
invented the interpretation
for these programs that we

01:10:21.030 --> 01:10:24.240
have that I'm talking to
you about right now.

01:10:24.240 --> 01:10:28.950
And they proved, by topology
that there is such a fixed

01:10:28.950 --> 01:10:32.220
point in the cases
that we want.

01:10:32.220 --> 01:10:41.180
But the assertion is E-X-P-T
is limit as n goes

01:10:41.180 --> 01:10:43.680
to infinity of em.

01:10:43.680 --> 01:10:47.900
and And that we've constructed
this by the following way.

01:10:50.520 --> 01:10:57.530
--is Well, it's f of, f
of, f of, f of, f of--

01:10:57.530 --> 01:11:01.120
f applied to anything at all.

01:11:01.120 --> 01:11:04.070
It didn't matter what that was,
because, in fact, this

01:11:04.070 --> 01:11:05.320
always produces an error.

01:11:07.540 --> 01:11:08.790
Applied to this--

01:11:12.840 --> 01:11:16.380
That's by infinite
nesting of f's.

01:11:16.380 --> 01:11:19.760
So now my problem is to make
some infinite things.

01:11:22.590 --> 01:11:24.920
We need some infinite things.

01:11:24.920 --> 01:11:28.980
How am I going to nest up an f
an infinite number of times?

01:11:28.980 --> 01:11:32.380
I'd better construct this.

01:11:32.380 --> 01:11:32.930
Well, I don't know.

01:11:32.930 --> 01:11:34.810
How would I make an infinite
loop at all?

01:11:34.810 --> 01:11:37.090
Let's take a very simple
infinite loop, the simplest

01:11:37.090 --> 01:11:38.340
infinite loop imaginable.

01:11:43.550 --> 01:11:48.070
If I were to take that procedure
of one argument x

01:11:48.070 --> 01:11:57.580
which applies x to x and apply
that to the procedure of one

01:11:57.580 --> 01:12:05.320
argument x which applies
x to x, then this

01:12:05.320 --> 01:12:07.440
is an infinite loop.

01:12:07.440 --> 01:12:09.980
The reason why this is an
infinite loop is as follows.

01:12:09.980 --> 01:12:14.390
The way I understand this is I
substitute the argument for

01:12:14.390 --> 01:12:18.850
the formal parameter
in the body.

01:12:18.850 --> 01:12:22.590
But if I do that, I take for
each of these x's, I

01:12:22.590 --> 01:12:25.740
substitute one of these, making
a copy of the original

01:12:25.740 --> 01:12:28.410
expression I just started
with, the

01:12:28.410 --> 01:12:29.660
simplest infinite loop.

01:12:35.440 --> 01:12:40.750
Now I want to tell you about a
particular operator which is

01:12:40.750 --> 01:12:43.090
constructed by a perturbation
from this infinite loop.

01:12:47.040 --> 01:12:48.290
I'll call it y.

01:12:52.290 --> 01:12:56.680
This is called Curry's
Paradoxical Combinator of y

01:12:56.680 --> 01:13:00.510
after a fellow by the name of
Curry, who was a logician of

01:13:00.510 --> 01:13:04.480
the 1930s also.

01:13:04.480 --> 01:13:08.670
And if I have a procedure of
one argument f, what's it

01:13:08.670 --> 01:13:09.330
going to have in it?

01:13:09.330 --> 01:13:13.420
It's going to have a kind of
infinite loop in it, which is

01:13:13.420 --> 01:13:21.670
that procedure of one argument
x which applies f to x of x,

01:13:21.670 --> 01:13:25.820
applied to that procedure of one
argument x, which applies

01:13:25.820 --> 01:13:27.899
f to f of x.

01:13:32.300 --> 01:13:34.590
Now what's this do?

01:13:34.590 --> 01:13:42.950
Suppose we apply y to F. Well,
that's easy enough.

01:13:42.950 --> 01:13:46.910
That's this capital
F over here.

01:13:46.910 --> 01:13:48.670
Well, the easiest thing
to say there is, I

01:13:48.670 --> 01:13:49.920
substitute F for here.

01:13:55.320 --> 01:13:58.460
So that's going to give
me, basically--

01:13:58.460 --> 01:14:02.800
because then I'm going to
substitute this for x in here.

01:14:08.970 --> 01:14:10.810
Let me actually do it in steps,
so you can see it

01:14:10.810 --> 01:14:11.730
completely.

01:14:11.730 --> 01:14:15.020
I'm going to be very careful.

01:14:15.020 --> 01:14:27.510
This is open, open, lambda of
x , capital F, x, x, applied

01:14:27.510 --> 01:14:37.910
to itself, F of x of x.

01:14:37.910 --> 01:14:45.600
Substituting this for this in
here, this is F applied to--

01:14:45.600 --> 01:14:47.040
what is it--

01:14:47.040 --> 01:14:53.850
substituting this in here, open,
open, lambda of x, F, of

01:14:53.850 --> 01:15:08.910
x and x, applied to lambda of
x, F of x of x, F, lambda,

01:15:08.910 --> 01:15:11.510
pair, F.

01:15:11.510 --> 01:15:13.420
Oh, but what is this?

01:15:13.420 --> 01:15:17.490
This thing over here that
I just computed, is

01:15:17.490 --> 01:15:20.030
this thing over here.

01:15:20.030 --> 01:15:23.370
But I just wrapped another
F around it.

01:15:23.370 --> 01:15:27.850
So by applying y to F, I make
an infinite series of F's.

01:15:27.850 --> 01:15:30.520
If I just let this run forever,
I'll just keep making

01:15:30.520 --> 01:15:33.170
more and more F's outside.

01:15:33.170 --> 01:15:35.600
I ran an infinite loop which
is useless, but it doesn't

01:15:35.600 --> 01:15:36.855
matter that the inside
is useless.

01:15:40.220 --> 01:15:53.900
So y of F is F applied to y of
F. So y is a magical thing

01:15:53.900 --> 01:15:58.840
which, when applied to some
function, produces the object

01:15:58.840 --> 01:16:03.200
which is the fixed point of that
function, if it exists,

01:16:03.200 --> 01:16:04.450
and if this all works.

01:16:07.910 --> 01:16:10.380
Because, indeed, if I take y of
F and put it into F, I get

01:16:10.380 --> 01:16:11.630
y of F out.

01:16:16.240 --> 01:16:20.750
Now I want you to think this
in terms of the eval-apply

01:16:20.750 --> 01:16:23.860
interpreter for a bit.

01:16:23.860 --> 01:16:28.540
I wrote down a whole bunch of
recursion equations out there.

01:16:28.540 --> 01:16:30.210
They're simultaneous in
the same way these are

01:16:30.210 --> 01:16:31.470
simultaneous equations.

01:16:31.470 --> 01:16:33.310
Exponentiation was not a
simultaneous equation.

01:16:33.310 --> 01:16:38.150
It was only one variable I was
looking for a meaning for.

01:16:38.150 --> 01:16:41.210
But what Lisp is is the fixed
point of the process which

01:16:41.210 --> 01:16:44.740
says, if I knew what Lisp was
and substituted it in for

01:16:44.740 --> 01:16:47.780
eval, and apply, and so on, on
the right hand sides of all

01:16:47.780 --> 01:16:51.930
those recursion equations, then
if it was a real good

01:16:51.930 --> 01:16:55.340
Lisp, is a real one, then
the left hand side

01:16:55.340 --> 01:16:58.220
would also be Lisp.

01:16:58.220 --> 01:16:59.565
So I made sense of
that definition.

01:17:02.420 --> 01:17:05.410
Now whether or not there's an
answer isn't so obvious.

01:17:05.410 --> 01:17:07.740
I can't attack that.

01:17:07.740 --> 01:17:09.160
Now these arguments that
I'm giving you

01:17:09.160 --> 01:17:10.660
now are quite dangerous.

01:17:10.660 --> 01:17:13.570
Let's look over here.

01:17:13.570 --> 01:17:14.610
These are limit arguments.

01:17:14.610 --> 01:17:17.020
We're talking about limits, and
it's really calculus, or

01:17:17.020 --> 01:17:21.255
topology, or something like
that, a kind of analysis.

01:17:21.255 --> 01:17:23.380
Now here's an argument
that you all believe.

01:17:23.380 --> 01:17:27.010
And I want to make sure you
realize that I could be

01:17:27.010 --> 01:17:29.660
bullshitting you.

01:17:29.660 --> 01:17:30.910
What is this?

01:17:34.250 --> 01:17:40.300
u is the sum of 1/2, 1/4, and
1/8, and so on, the sum of a

01:17:40.300 --> 01:17:42.820
geometric series.

01:17:42.820 --> 01:17:44.820
And, of course, I could
play a game here.

01:17:44.820 --> 01:17:47.570
u minus one is 1/2, plus 1/4,
plus 1/8, and so on.

01:17:53.590 --> 01:17:56.190
What I could do here--

01:17:56.190 --> 01:17:56.680
oops.

01:17:56.680 --> 01:17:58.920
There is a parentheses
error here.

01:17:58.920 --> 01:18:02.740
But I can put here two times u
minus one is one plus 1/2,

01:18:02.740 --> 01:18:03.990
plus 1/4, plus 1/8.

01:18:07.570 --> 01:18:08.820
Can I fix that?

01:18:14.010 --> 01:18:16.125
Yes, well.

01:18:19.520 --> 01:18:27.850
But that gives me back two
times u minus one is u,

01:18:27.850 --> 01:18:30.300
therefore, we conclude
that u is two.

01:18:30.300 --> 01:18:31.830
And this actually is true.

01:18:31.830 --> 01:18:33.910
There's no problem like that.

01:18:33.910 --> 01:18:38.540
But supposing I did something
different.

01:18:38.540 --> 01:18:39.740
Supposing I start up with
something which

01:18:39.740 --> 01:18:41.470
manifestly has no sum.

01:18:41.470 --> 01:18:47.390
v is one, plus two, plus four,
plus 8, plus dot, dot, dot.

01:18:47.390 --> 01:18:49.560
Well, v minus one is surely two,
plus four, plus eight,

01:18:49.560 --> 01:18:52.010
plus dot, dot, dot.

01:18:52.010 --> 01:18:57.410
v minus one over two, gee,
that looks like v again.

01:18:57.410 --> 01:19:01.070
From that I should be able
to conclude that--

01:19:01.070 --> 01:19:03.070
that's also wrong, apparently.

01:19:03.070 --> 01:19:04.510
v equals minus one.

01:19:12.455 --> 01:19:15.280
That should be a minus one.

01:19:15.280 --> 01:19:16.735
And that's certainly
a false conclusion.

01:19:22.000 --> 01:19:27.300
So when you play with limits,
arguments that may work in one

01:19:27.300 --> 01:19:30.750
case they may not work
in some other case.

01:19:30.750 --> 01:19:32.240
You have to be very careful.

01:19:32.240 --> 01:19:35.752
The arguments have to
be well formed.

01:19:35.752 --> 01:19:40.790
And I don't know, in general,
what the story is about

01:19:40.790 --> 01:19:43.270
arguments like this.

01:19:43.270 --> 01:19:46.060
We can read a pile of topology
and find out.

01:19:46.060 --> 01:19:49.750
But, surely, at least you
understand now, why it might

01:19:49.750 --> 01:19:52.230
be some meaning to the things
we've been writing on the

01:19:52.230 --> 01:19:53.260
blackboard.

01:19:53.260 --> 01:19:56.480
And you understand what
that might mean.

01:19:56.480 --> 01:20:02.900
So, I suppose, it's almost about
time for you to merit

01:20:02.900 --> 01:20:05.720
being made a member of the
grand recursive order of

01:20:05.720 --> 01:20:09.320
lambda calculus hackers.

01:20:09.320 --> 01:20:10.820
This is the badge.

01:20:10.820 --> 01:20:14.540
Because you now understand, for
example, what it says at

01:20:14.540 --> 01:20:21.890
the very top, y F equals
F y F. Thank you.

01:20:21.890 --> 01:20:24.710
Are there any questions?

01:20:24.710 --> 01:20:25.150
Yes, Lev.

01:20:25.150 --> 01:20:28.250
AUDIENCE: With this, it seems
that then there's no need to

01:20:28.250 --> 01:20:31.330
define, as you imply,
to just remember a

01:20:31.330 --> 01:20:34.090
value, to apply it later.

01:20:34.090 --> 01:20:35.850
Defines were kind of
a side-effect it

01:20:35.850 --> 01:20:36.490
seemed in the language.

01:20:36.490 --> 01:20:37.075
[INTERPOSING]

01:20:37.075 --> 01:20:39.300
are order dependent.

01:20:39.300 --> 01:20:42.820
Does this eliminate the
side-effect from the

01:20:42.820 --> 01:20:43.150
[INTERPOSING]

01:20:43.150 --> 01:20:46.010
PROFESSOR: The answer is, this
is not the way these things

01:20:46.010 --> 01:20:49.180
were implemented.

01:20:49.180 --> 01:20:53.830
Define, indeed is implemented as
an operation that actually

01:20:53.830 --> 01:20:59.000
modifies an environment
structure, changes the frame

01:20:59.000 --> 01:21:03.690
that the define is
executed in.

01:21:03.690 --> 01:21:08.440
And there are many reasons for
that, but a lot of this has to

01:21:08.440 --> 01:21:11.340
do with making an interactive
system.

01:21:11.340 --> 01:21:14.750
What this is saying is that if
you've made a system, and you

01:21:14.750 --> 01:21:17.210
know you're not going to do any
debugging or anything like

01:21:17.210 --> 01:21:20.930
that, and you know everything
there is all at once, and you

01:21:20.930 --> 01:21:21.930
want to say, what is
the meaning of a

01:21:21.930 --> 01:21:24.090
final set of equations?

01:21:24.090 --> 01:21:25.790
This gives you a
meaning for it.

01:21:25.790 --> 01:21:27.740
But in order to make an
interactive system, where you

01:21:27.740 --> 01:21:29.430
can change the meaning of one
thing without changing

01:21:29.430 --> 01:21:33.580
everything else, incrementally,
you can't do

01:21:33.580 --> 01:21:35.000
that by implementing
it this way.

01:21:40.990 --> 01:21:41.860
Yes.

01:21:41.860 --> 01:21:44.650
AUDIENCE: Another question
on your danger slide.

01:21:44.650 --> 01:21:47.350
It seemed that the two examples
that you gave had to

01:21:47.350 --> 01:21:50.300
do with convergence and
non-convergence?

01:21:50.300 --> 01:21:53.380
And that may or may not have
something to do with function

01:21:53.380 --> 01:21:55.600
theory in a way which would
lead you to think of it in

01:21:55.600 --> 01:21:59.710
terms of linear systems, or
non-linear systems. How does

01:21:59.710 --> 01:22:03.140
this convergence relate to being
able to see a priori

01:22:03.140 --> 01:22:05.430
what properties of that
might be violated?

01:22:05.430 --> 01:22:07.680
PROFESSOR: I don't know.

01:22:07.680 --> 01:22:10.610
The answer is, I don't know
under what circumstances.

01:22:10.610 --> 01:22:13.660
I don't know how to translate
that into less than an

01:22:13.660 --> 01:22:16.910
hour of talk more.

01:22:16.910 --> 01:22:19.850
What are the conditions under
which, for which we know that

01:22:19.850 --> 01:22:22.720
these things converge?

01:22:22.720 --> 01:22:25.230
And v, all that was telling you
that arguments that are

01:22:25.230 --> 01:22:30.420
based on convergence are flaky
if you don't know the

01:22:30.420 --> 01:22:32.810
convergence beforehand.

01:22:32.810 --> 01:22:34.440
You can make wrong arguments.

01:22:34.440 --> 01:22:37.810
You can make deductions, as if
you know the answer, and not

01:22:37.810 --> 01:22:40.690
be stopped somewhere by some
obvious contradiction.

01:22:40.690 --> 01:22:43.635
AUDIENCE: So can we say then
that if F is a convergent

01:22:43.635 --> 01:22:46.230
mathematical expression,
then the recursion

01:22:46.230 --> 01:22:47.690
property can be--

01:22:47.690 --> 01:22:52.740
PROFESSOR: Well, I think there's
a technical kind of F,

01:22:52.740 --> 01:22:55.150
there is a technical description
of those F's that

01:22:55.150 --> 01:23:00.790
have the property that when
you iteratively apply them

01:23:00.790 --> 01:23:03.020
like this, you converge.

01:23:03.020 --> 01:23:08.470
Things that are monotonic,
and continuous, and

01:23:08.470 --> 01:23:09.370
I forgot what else.

01:23:09.370 --> 01:23:12.010
There is a whole bunch of little
conditions like that

01:23:12.010 --> 01:23:13.430
which have this property.

01:23:13.430 --> 01:23:15.820
Now the real problem is deducing
from looking at the

01:23:15.820 --> 01:23:19.020
F, its definition here, whether
not it has those

01:23:19.020 --> 01:23:22.010
properties, and that's
very hard.

01:23:22.010 --> 01:23:23.280
The properties are easy.

01:23:23.280 --> 01:23:24.580
You can write them down.

01:23:24.580 --> 01:23:26.930
You can look in a book
by Joe Stoy.

01:23:26.930 --> 01:23:28.660
It's a great book--

01:23:28.660 --> 01:23:29.910
Stoy.

01:23:31.780 --> 01:23:37.360
It's called, The Scott-Strachey
Method of

01:23:37.360 --> 01:23:41.800
Denotational Semantics, and it's
by Joe Stoy, MIT Press.

01:23:47.960 --> 01:23:50.630
And he works out all this in
great detail, enough to

01:23:50.630 --> 01:23:51.880
horrify you.

01:23:55.080 --> 01:23:56.330
But it really is readable.

01:24:09.150 --> 01:24:11.490
OK, well, thank you.

01:24:11.490 --> 01:24:13.780
Time for the bigger
break, I suppose.

