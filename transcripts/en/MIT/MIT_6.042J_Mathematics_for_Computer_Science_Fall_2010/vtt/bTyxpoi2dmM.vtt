WEBVTT
Kind: captions
Language: en

00:00:00.499 --> 00:00:02.830
The following content is
provided under a Creative

00:00:02.830 --> 00:00:04.340
Commons license.

00:00:04.340 --> 00:00:06.680
Your support will help
MIT OpenCourseWare

00:00:06.680 --> 00:00:11.050
continue to offer high-quality
educational resources for free.

00:00:11.050 --> 00:00:13.670
To make a donation or
view additional materials

00:00:13.670 --> 00:00:17.565
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.565 --> 00:00:18.190
at ocw.mit.edu.

00:00:22.387 --> 00:00:23.970
MARTEN VAN DIJK: So
today, we're going

00:00:23.970 --> 00:00:28.030
to talk about
communication networks.

00:00:28.030 --> 00:00:30.270
Communication networks
is a great application

00:00:30.270 --> 00:00:32.020
of graph theory.

00:00:32.020 --> 00:00:34.910
So what we're going
to study is, how

00:00:34.910 --> 00:00:38.030
do you route packets
through networks?

00:00:38.030 --> 00:00:40.900
So you have the internet,
which is a chaotic network.

00:00:40.900 --> 00:00:42.850
It's not organized.

00:00:42.850 --> 00:00:46.270
We are interested in
highly structured networks

00:00:46.270 --> 00:00:48.400
and you can find
them, for example,

00:00:48.400 --> 00:00:53.980
in parallel computers, where
you want to route the data flow.

00:00:53.980 --> 00:01:01.170
You can find them in certain
telephone switches networks

00:01:01.170 --> 00:01:02.620
and so on.

00:01:02.620 --> 00:01:06.920
So we are going to talk about
a few very special ones,

00:01:06.920 --> 00:01:09.870
binary trees, and then
slowly we will figure out

00:01:09.870 --> 00:01:12.960
what all these performance
measures really mean.

00:01:12.960 --> 00:01:14.400
This one has to do with latency.

00:01:14.400 --> 00:01:17.300
We have switches, their
size, the number of them,

00:01:17.300 --> 00:01:20.860
congestion, and then
we will slowly get down

00:01:20.860 --> 00:01:23.940
to Benes network, which is
a really beautiful network

00:01:23.940 --> 00:01:26.770
with beautiful parameters.

00:01:26.770 --> 00:01:29.510
And we are going to prove those.

00:01:29.510 --> 00:01:35.620
So let's start off with the
first one, the complete binary

00:01:35.620 --> 00:01:37.810
tree, and let me
draw it for you.

00:01:44.400 --> 00:01:49.930
In this network,
we will have a root

00:01:49.930 --> 00:01:57.410
and let me just draw it
first We have vertices that

00:01:57.410 --> 00:01:59.300
represent here the switches.

00:01:59.300 --> 00:02:04.370
So these circles-- let me
explain it over here-- actually

00:02:04.370 --> 00:02:07.120
represent a switch.

00:02:07.120 --> 00:02:15.040
And the idea is that these
actually direct packets

00:02:15.040 --> 00:02:16.140
through the network.

00:02:21.660 --> 00:02:25.430
And these packets are
fixed-size packets

00:02:25.430 --> 00:02:30.870
of data, so like, I don't
know, say 4,000 bytes or bits

00:02:30.870 --> 00:02:34.140
or whatever the network
wants you to comply to.

00:02:34.140 --> 00:02:38.090
So these are fixed-size
pieces of data.

00:02:38.090 --> 00:02:42.050
So what we want is we want to
be able from every terminal--

00:02:42.050 --> 00:02:45.500
and the terminal I will
denote by a square--

00:02:45.500 --> 00:02:47.710
from every terminal,
I want to be

00:02:47.710 --> 00:02:53.030
able to reach any
other terminal.

00:02:53.030 --> 00:02:54.040
So what is a terminal?

00:02:54.040 --> 00:02:58.610
A terminal is like a computer
or something like that.

00:02:58.610 --> 00:03:05.030
It's actually the source
and the destination of data.

00:03:12.880 --> 00:03:16.410
So what we are looking
for is how can we

00:03:16.410 --> 00:03:19.960
route-- how we can find
a network of switches

00:03:19.960 --> 00:03:22.980
that are connected through
wires, fibers, or-- yeah?

00:03:22.980 --> 00:03:24.129
What's the question?

00:03:24.129 --> 00:03:25.566
AUDIENCE: Can you
move down a bit

00:03:25.566 --> 00:03:27.961
the top of the-- how
it's getting cut off?

00:03:27.961 --> 00:03:28.919
No, the--

00:03:28.919 --> 00:03:29.710
That one.

00:03:29.710 --> 00:03:30.835
MARTEN VAN DIJK: Oh, sorry.

00:03:30.835 --> 00:03:32.272
AUDIENCE: All right.

00:03:32.272 --> 00:03:33.682
Thank you.

00:03:33.682 --> 00:03:35.140
MARTEN VAN DIJK:
So what we want is

00:03:35.140 --> 00:03:39.670
we want to route packets
that's come from any terminal

00:03:39.670 --> 00:03:41.320
to any other terminal.

00:03:41.320 --> 00:03:44.730
That is what our goal is
and we want to make sure

00:03:44.730 --> 00:03:47.080
that that is efficient.

00:03:47.080 --> 00:03:49.790
So the first one is
this binary tree.

00:03:49.790 --> 00:03:55.170
And let's see how this may work.

00:03:55.170 --> 00:04:06.060
We may have switches
that actually have

00:04:06.060 --> 00:04:08.245
inputs coming from terminals.

00:04:16.910 --> 00:04:21.060
And the switches may
also output to terminals,

00:04:21.060 --> 00:04:22.260
so here at the bottom.

00:04:22.260 --> 00:04:25.780
At this site, we have
a similar structure.

00:04:25.780 --> 00:04:27.510
this is the root of the tree.

00:04:27.510 --> 00:04:29.500
We have another
switch over here.

00:04:29.500 --> 00:04:35.260
We go down, we go up here,
and once more, like this.

00:04:35.260 --> 00:04:38.950
And again, we have-- oops.

00:04:38.950 --> 00:04:43.430
We have input coming in
or an output coming out

00:04:43.430 --> 00:04:44.685
to their respective terminals.

00:04:49.120 --> 00:04:52.910
So what is happening
here is that I

00:04:52.910 --> 00:04:59.570
would like to have an
input-- say input zero wants

00:04:59.570 --> 00:05:01.830
to travel all the
way over to say,

00:05:01.830 --> 00:05:04.280
the output that is
present over here.

00:05:04.280 --> 00:05:05.800
So let me label these.

00:05:05.800 --> 00:05:14.170
So we have the output zero,
input one, output one,

00:05:14.170 --> 00:05:23.940
input two and output two,
input three, and output four.

00:05:23.940 --> 00:05:29.100
So well, I can definitely
reach every single output

00:05:29.100 --> 00:05:31.470
from any input so that's great.

00:05:31.470 --> 00:05:34.540
So this looks like something
that you are familiar with,

00:05:34.540 --> 00:05:35.040
right?

00:05:35.040 --> 00:05:36.520
It's just a tree.

00:05:40.910 --> 00:05:42.870
It's a directed
graph, but these edges

00:05:42.870 --> 00:05:44.870
go in both directions, right?

00:05:44.870 --> 00:05:48.620
So I have an edge that goes from
here to here and back from here

00:05:48.620 --> 00:05:49.750
to here.

00:05:49.750 --> 00:05:53.840
So this is the kind of
layout that you could try out

00:05:53.840 --> 00:05:56.130
first to see whether
this type of network

00:05:56.130 --> 00:05:58.440
would lead to good performance.

00:05:58.440 --> 00:06:01.720
So let's have a look at
the different parameters

00:06:01.720 --> 00:06:04.670
and see how well this behaves.

00:06:04.670 --> 00:06:07.160
So here, we have
a few parameters

00:06:07.160 --> 00:06:09.100
that we will be talking about.

00:06:11.860 --> 00:06:16.390
So first of all, let's
talk about the latency

00:06:16.390 --> 00:06:18.690
in this particular network.

00:06:18.690 --> 00:06:21.680
So how are we going
to measure this?

00:06:21.680 --> 00:06:23.870
Well, we're going to
look at this graph

00:06:23.870 --> 00:06:26.650
and we're going to measure
it by the number of wires

00:06:26.650 --> 00:06:30.837
that you need to go through
from an input to an output.

00:06:30.837 --> 00:06:31.920
So let me write this down.

00:06:35.590 --> 00:06:48.520
So the latency is the time
that is required for a packet

00:06:48.520 --> 00:06:58.240
to travel from an
input to an output.

00:07:05.830 --> 00:07:08.087
And how are we going
to measure this?

00:07:08.087 --> 00:07:09.670
Well, we're just
going to measure this

00:07:09.670 --> 00:07:13.010
by the number of wires
that we need to go through.

00:07:13.010 --> 00:07:15.510
So this you have seen before.

00:07:15.510 --> 00:07:17.280
We can measure this
by the diameter

00:07:17.280 --> 00:07:19.330
of that particular graph.

00:07:19.330 --> 00:07:21.720
So here, we will define
it for a network.

00:07:21.720 --> 00:07:28.420
So the diameter of
a network is going

00:07:28.420 --> 00:07:46.700
to be the length of the
shortest path between the input

00:07:46.700 --> 00:07:56.950
and output that
are furthest apart.

00:07:56.950 --> 00:08:02.050
So let's have a look
at the graph above.

00:08:02.050 --> 00:08:07.270
So for example, we can clearly
see that, for example, input

00:08:07.270 --> 00:08:12.170
and output-- so say,
input zero and output one

00:08:12.170 --> 00:08:20.600
are connected by just going
up one step over here,

00:08:20.600 --> 00:08:24.370
but just going up
from here to here.

00:08:24.370 --> 00:08:27.880
Then, this switch forwards
the packet to this switch.

00:08:27.880 --> 00:08:31.740
This switch reroutes it,
forwards it over here,

00:08:31.740 --> 00:08:34.760
and then it goes back to
the output, output one.

00:08:34.760 --> 00:08:40.770
So for example, this particular
path only has 1, 2, 3, 4 edges.

00:08:40.770 --> 00:08:46.900
And what we are interested in
is sort of the worst-case time

00:08:46.900 --> 00:08:49.700
that it requires to go
from an input to an output.

00:08:49.700 --> 00:08:52.020
So that means that we are
interested in a diameter.

00:08:52.020 --> 00:08:56.590
And a diameter is in this
case, well, the shortest path

00:08:56.590 --> 00:09:01.560
that you can find from an input
to an output that are furthest

00:09:01.560 --> 00:09:02.060
apart.

00:09:02.060 --> 00:09:04.340
So what are those who
are furthest apart?

00:09:04.340 --> 00:09:06.780
Well, of course, you would
like to go through here, right?

00:09:06.780 --> 00:09:10.695
So if I connect the input
zero to say, output four,

00:09:10.695 --> 00:09:14.450
I will need to go all the
way up through the route

00:09:14.450 --> 00:09:16.400
down to the output.

00:09:16.400 --> 00:09:18.520
And how many edges
do we see here?

00:09:18.520 --> 00:09:23.530
1, 2, 3, 4, 5, 6--
so in this example,

00:09:23.530 --> 00:09:28.820
we have a diameter
that is equal to six.

00:09:28.820 --> 00:09:35.480
And in general, if you are
looking at n times n networks,

00:09:35.480 --> 00:09:37.030
what does it mean?

00:09:37.030 --> 00:09:41.390
n is the number of inputs and n
is also the number of outputs.

00:09:41.390 --> 00:09:45.600
So in this case, we have
a four times-- well,

00:09:45.600 --> 00:09:48.760
this is actually
three over here--

00:09:48.760 --> 00:09:52.180
we have four inputs
and four outputs.

00:09:52.180 --> 00:09:54.780
So this particular example
depicted on the board

00:09:54.780 --> 00:09:57.680
is a four times four network.

00:09:57.680 --> 00:10:03.730
So if you generalize this
for any size binary tree,

00:10:03.730 --> 00:10:09.190
say, an n times n
network, then what's

00:10:09.190 --> 00:10:12.380
the diameter of such
a general network?

00:10:12.380 --> 00:10:16.980
Well, if we have n
inputs and n outputs,

00:10:16.980 --> 00:10:19.170
well, we have to
go all the way up

00:10:19.170 --> 00:10:22.270
through towards the root
and all the way down.

00:10:22.270 --> 00:10:27.030
So we actually count the
length of a leaf to the root

00:10:27.030 --> 00:10:28.940
here twice.

00:10:28.940 --> 00:10:33.010
So in general, we have a
diameter that looks like this.

00:10:33.010 --> 00:10:39.740
It's 2 times 1 plus
the logarithm of n.

00:10:39.740 --> 00:10:48.550
So in this lecture, we will have
n is going to be a power of 2,

00:10:48.550 --> 00:10:51.030
just to make
calculations simple.

00:10:51.030 --> 00:10:56.170
And the logarithm is
always to the base two.

00:10:56.170 --> 00:11:01.330
So this is a diameter of
a general binary tree.

00:11:01.330 --> 00:11:05.460
And well, what are
the other parameters?

00:11:05.460 --> 00:11:07.320
So that does not look too bad.

00:11:07.320 --> 00:11:08.700
It's logarithmic in answer.

00:11:08.700 --> 00:11:10.420
That sounds pretty good.

00:11:10.420 --> 00:11:14.010
What about the switch sizes?

00:11:14.010 --> 00:11:16.400
Well, how do I measure those?

00:11:16.400 --> 00:11:18.615
It's like the number of
inputs that get into it

00:11:18.615 --> 00:11:20.240
and the number of
outputs that get out.

00:11:20.240 --> 00:11:24.600
So in this case, I will
have 1, 2 inputs that

00:11:24.600 --> 00:11:28.150
go into this switch and there
are two outputs coming out.

00:11:28.150 --> 00:11:31.290
So this is what we call
a two times two switch.

00:11:31.290 --> 00:11:33.600
So this will be a
two times two switch.

00:11:33.600 --> 00:11:35.630
But if you look at
this one, for example,

00:11:35.630 --> 00:11:41.950
we see one, two, three outgoing
edges and three ingoing edges.

00:11:41.950 --> 00:11:45.480
So this is actually a
three times three switch.

00:11:45.480 --> 00:11:49.970
And in a general
binary tree, we will

00:11:49.970 --> 00:11:53.060
see that all these intermediate
nodes over here, they

00:11:53.060 --> 00:11:54.660
are all three times
three switches.

00:11:54.660 --> 00:12:00.150
So approximately
half of the switches

00:12:00.150 --> 00:12:04.300
are actually three
times three switches.

00:12:04.300 --> 00:12:05.485
So that's the switch size.

00:12:10.350 --> 00:12:13.680
Now, you may say,
well, why don't I

00:12:13.680 --> 00:12:16.310
use a larger-sized switch?

00:12:16.310 --> 00:12:18.200
That would help me a lot, right?

00:12:18.200 --> 00:12:24.400
If I could use, say, a four
times four switch, then

00:12:24.400 --> 00:12:27.200
I would be able to have
more inputs coming in,

00:12:27.200 --> 00:12:30.770
more outputs coming
out, and I can actually

00:12:30.770 --> 00:12:34.070
maybe use a ternary tree
rather than a binary tree.

00:12:34.070 --> 00:12:37.260
In a binary tree,
every note at the level

00:12:37.260 --> 00:12:39.230
has two children, right?

00:12:39.230 --> 00:12:41.430
But we could design
a tree that has

00:12:41.430 --> 00:12:44.070
at every level three children.

00:12:44.070 --> 00:12:46.580
So then, they can use
four times four switches.

00:12:46.580 --> 00:12:51.220
But if you do that, then
the path from the leaf

00:12:51.220 --> 00:12:53.150
up to the root is
getting shorter

00:12:53.150 --> 00:12:54.780
and the diameter gets smaller.

00:12:54.780 --> 00:12:58.936
So if I increase the
switch size-- so rather

00:12:58.936 --> 00:13:00.810
than three times three,
we look at four times

00:13:00.810 --> 00:13:03.930
four or five times five, six
times six and so on-- then

00:13:03.930 --> 00:13:07.410
the diameter will
actually reduce.

00:13:07.410 --> 00:13:13.170
So what about having a monster
switch, like I have just one

00:13:13.170 --> 00:13:16.500
switch and I have my
input zero all the way up

00:13:16.500 --> 00:13:22.060
to input n minus 1 and
then I have my outputs

00:13:22.060 --> 00:13:22.810
on the other side?

00:13:28.960 --> 00:13:34.180
Well, of course, the
switch size is n times n

00:13:34.180 --> 00:13:37.320
but the diameter
is nothing, right?

00:13:40.400 --> 00:13:42.170
The diameter is reduced to one.

00:13:42.170 --> 00:13:44.230
You can immediately go
from an input to an output

00:13:44.230 --> 00:13:45.490
through the switch.

00:13:45.490 --> 00:13:47.240
But this, of course,
conceals the problem.

00:13:47.240 --> 00:13:50.510
So what we are interested
in is, well, we're

00:13:50.510 --> 00:13:53.960
actually really
interested in how

00:13:53.960 --> 00:13:56.900
to solve the problem of
routing all these inputs

00:13:56.900 --> 00:14:03.860
to these outputs using
smaller switches of size three

00:14:03.860 --> 00:14:05.800
times three or two times two.

00:14:05.800 --> 00:14:07.990
What we're really
interested in is,

00:14:07.990 --> 00:14:11.800
what is the internal structure
in this monster switch?

00:14:11.800 --> 00:14:14.450
I sort of have concealed the
problem by just saying, oh,

00:14:14.450 --> 00:14:15.990
I've got a big switch.

00:14:15.990 --> 00:14:20.190
But what we want
to solve today is

00:14:20.190 --> 00:14:25.640
how do we do the routing in this
case within the monster switch?

00:14:25.640 --> 00:14:30.780
So we want to use just
small switch sizes

00:14:30.780 --> 00:14:33.920
and build up a network
using these smaller ones,

00:14:33.920 --> 00:14:37.045
like three times three switches
or two times two switches.

00:14:39.950 --> 00:14:49.990
Now, so that brings us
to yet another parameter,

00:14:49.990 --> 00:14:52.240
because here, we'd like to
count the number or smaller

00:14:52.240 --> 00:14:54.490
switches that we
use and that relates

00:14:54.490 --> 00:14:58.570
to the cost of the network,
the amount of hardware

00:14:58.570 --> 00:15:00.100
that you need to put into it.

00:15:00.100 --> 00:15:06.145
So in this example, we
have the switch count.

00:15:09.477 --> 00:15:10.810
Well, it's pretty simple, right?

00:15:10.810 --> 00:15:16.920
It's 1, 2, 3, 4, 5, 6, 7--
we have seven switches.

00:15:16.920 --> 00:15:23.960
And in general, if we
have n inputs-- so 1,

00:15:23.960 --> 00:15:27.030
2, 3, 4 inputs-- then
the number of switches

00:15:27.030 --> 00:15:30.220
that we use in the binary
tree is 2 times the number

00:15:30.220 --> 00:15:33.680
of inputs minus 1.

00:15:33.680 --> 00:15:36.590
So let's write that down.

00:15:36.590 --> 00:15:40.080
So over here, we would
have 2 times n minus 1,

00:15:40.080 --> 00:15:42.330
which is the number of
switches that you actually use.

00:15:45.140 --> 00:15:47.360
So how can you
see that actually?

00:15:47.360 --> 00:15:57.310
So in general, we have 1 plus 2
plus 4 plus 8 and so on plus n.

00:15:57.310 --> 00:16:00.650
And it's a power of 2,
according to our assumptions.

00:16:00.650 --> 00:16:04.690
And if you add them all
up, I think you'll-- well,

00:16:04.690 --> 00:16:07.340
you can check for yourself that
this is actually equal to 2

00:16:07.340 --> 00:16:08.510
times n minus 1.

00:16:11.440 --> 00:16:13.260
So now, we have the switches.

00:16:13.260 --> 00:16:16.280
So so far, this looks
pretty good, actually.

00:16:16.280 --> 00:16:18.060
We use small switch sizes.

00:16:18.060 --> 00:16:21.440
The number of switches
is linear in n.

00:16:21.440 --> 00:16:24.430
The diameter is logarithmic
in n so that sounds good.

00:16:24.430 --> 00:16:25.780
So what about congestion?

00:16:25.780 --> 00:16:30.850
Do you any idea-- what's
the problem with this graph?

00:16:30.850 --> 00:16:34.700
What is the big,
big problem here?

00:16:34.700 --> 00:16:39.040
What can happen in a very
sort of worst-case scenario

00:16:39.040 --> 00:16:42.150
where the packets get routed
from inputs to the outputs?

00:16:42.150 --> 00:16:46.400
If they need to go
to certain locations,

00:16:46.400 --> 00:16:50.160
then they all may have to
travel through the root.

00:16:50.160 --> 00:16:52.620
So you get congestion over here.

00:16:52.620 --> 00:16:54.190
We don't like that.

00:16:54.190 --> 00:16:56.270
So this root is actually
then overloaded.

00:16:56.270 --> 00:16:59.640
Actually, you can
already see that say,

00:16:59.640 --> 00:17:04.500
this particular switch-- if this
switch fails, then actually,

00:17:04.500 --> 00:17:08.089
we will have two disjoint trees
that cannot even communicate

00:17:08.089 --> 00:17:09.490
to one another.

00:17:09.490 --> 00:17:15.349
So this brings us to
the idea of congestion.

00:17:15.349 --> 00:17:18.876
And in order to
define it better,

00:17:18.876 --> 00:17:20.209
you will need a few definitions.

00:17:24.210 --> 00:17:31.640
So to start, we will
define a permutation

00:17:31.640 --> 00:17:38.670
and we will use this to
stipulate the requirement

00:17:38.670 --> 00:17:43.130
that we want on how inputs
and outputs are related

00:17:43.130 --> 00:17:48.470
to another, which input needs
to communicate to which output.

00:17:48.470 --> 00:18:00.010
So permutation is a function
pi from the set 0 to n minus 1

00:18:00.010 --> 00:18:03.750
to the same set.

00:18:03.750 --> 00:18:15.880
And it is such
that no two numbers

00:18:15.880 --> 00:18:21.210
are mapped to more than once.

00:18:21.210 --> 00:18:26.050
So no two numbers are
mapped to the same value.

00:18:31.790 --> 00:18:34.760
So what we really want--
to put it in mathematics,

00:18:34.760 --> 00:18:41.600
we want that pi of i is
only equal to pi of j

00:18:41.600 --> 00:18:46.560
if and only if i is equal to j.

00:18:46.560 --> 00:18:52.480
So let's have an example to plug
into that picture over there.

00:18:52.480 --> 00:19:02.600
So a first example could be
pi of i equals, say, n minus 1

00:19:02.600 --> 00:19:03.230
minus i.

00:19:03.230 --> 00:19:05.880
This is a proper permutation.

00:19:05.880 --> 00:19:08.170
No two numbers map
to the same value.

00:19:08.170 --> 00:19:11.240
Another one could be the
identity permutation,

00:19:11.240 --> 00:19:15.730
like you map i to the same i.

00:19:15.730 --> 00:19:17.400
So that's another example.

00:19:17.400 --> 00:19:20.640
Now, how do we use
permutations to go

00:19:20.640 --> 00:19:22.310
towards the idea of congestion?

00:19:22.310 --> 00:19:26.569
So permutation can be used
to formulate the permutation

00:19:26.569 --> 00:19:27.235
routing problem.

00:19:29.860 --> 00:19:36.620
And the permutation routing
problem is defined like this.

00:19:42.170 --> 00:19:44.490
It's defined as follows.

00:19:44.490 --> 00:19:49.210
What we want is
that for each i, we

00:19:49.210 --> 00:20:04.940
want to direct the packet at
input i to output pi of i.

00:20:04.940 --> 00:20:07.166
So you want to do
that for all i.

00:20:07.166 --> 00:20:11.320
So let's have a look at this
particular example, where we

00:20:11.320 --> 00:20:13.700
look at identity permutation.

00:20:13.700 --> 00:20:19.150
So if you do that, we can
easily route this, right?

00:20:19.150 --> 00:20:23.610
So I want to send a packet
from input zero to output zero.

00:20:23.610 --> 00:20:27.040
So I can simply go
into this direction.

00:20:27.040 --> 00:20:28.770
I just go towards
this switch and it

00:20:28.770 --> 00:20:31.580
gets routed back to this one.

00:20:31.580 --> 00:20:38.170
I can go like this and
this one can go like this

00:20:38.170 --> 00:20:40.630
and this one goes like that.

00:20:40.630 --> 00:20:42.530
Now, if you look at
the other permutation,

00:20:42.530 --> 00:20:45.340
the picture looks
very different.

00:20:45.340 --> 00:20:53.200
Now, we want to route
input zero to output three.

00:20:53.200 --> 00:20:55.450
In order to do this,
I will actually

00:20:55.450 --> 00:21:04.660
need to go all the way through
here and then all the way down

00:21:04.660 --> 00:21:07.420
to this particular output.

00:21:07.420 --> 00:21:12.410
And now, the picture gets into a
big mess because for input one,

00:21:12.410 --> 00:21:16.600
we have to go to output two.

00:21:16.600 --> 00:21:20.500
So for input one, well, we
go all the way like this,

00:21:20.500 --> 00:21:23.210
we again go through
the root, and then

00:21:23.210 --> 00:21:28.740
we go down to this
particular output.

00:21:28.740 --> 00:21:32.620
And as you can see,
for input two, well,

00:21:32.620 --> 00:21:34.710
we need to connect
to output one.

00:21:34.710 --> 00:21:38.910
So again, we go all the way
up and we go all the way down.

00:21:38.910 --> 00:21:42.560
And for this one, we will
again go all the way up and all

00:21:42.560 --> 00:21:44.520
the way down to input zero.

00:21:44.520 --> 00:21:48.950
So now, you can see that this
particular switch over here

00:21:48.950 --> 00:21:55.110
has to serve packets
from all the inputs.

00:21:55.110 --> 00:21:57.650
All the four packets
have to travel

00:21:57.650 --> 00:22:00.160
through this
particular node here.

00:22:00.160 --> 00:22:03.490
So this leads us to the
following definition

00:22:03.490 --> 00:22:05.310
of congestion.

00:22:05.310 --> 00:22:14.940
So the congestion--
oh, before we continue,

00:22:14.940 --> 00:22:18.240
let me first define a path.

00:22:18.240 --> 00:22:23.300
So for i, we direct a packet
at input i to output pi of i.

00:22:23.300 --> 00:22:27.010
And the path that
corresponds to this route

00:22:27.010 --> 00:22:31.400
is actually denoted as follows.

00:22:31.400 --> 00:22:48.260
So the path taken is
denoted by P i pi i.

00:22:48.260 --> 00:22:50.740
So now, we can
define the congestion

00:22:50.740 --> 00:22:52.170
of a set of such paths.

00:22:52.170 --> 00:23:00.750
So the congestion of the
path corresponding to P zero

00:23:00.750 --> 00:23:04.480
to P pi zero and so on
and we go all the way up

00:23:04.480 --> 00:23:08.590
to the n minus 1
input that needs to be

00:23:08.590 --> 00:23:11.680
mapped to pi of n minus 1.

00:23:11.680 --> 00:23:23.910
So the congestion is now
defined as the largest

00:23:23.910 --> 00:23:43.650
number of paths that pass
through a single switch.

00:23:43.650 --> 00:23:50.330
So in our example, we saw that
in the case of the blue arrows

00:23:50.330 --> 00:23:53.520
here for the
identity permutation,

00:23:53.520 --> 00:23:58.320
well, this switch only
needs to transmit one packet

00:23:58.320 --> 00:24:00.550
and all those
actually zero packets.

00:24:00.550 --> 00:24:11.080
So actually, the congestion
here is equal to 1.

00:24:11.080 --> 00:24:14.370
And for this
particular permutation,

00:24:14.370 --> 00:24:18.260
well, we had to direct all
the packets through the root

00:24:18.260 --> 00:24:21.470
and it's the most
accessed switch.

00:24:21.470 --> 00:24:24.830
And that switch has
congestion four, right?

00:24:24.830 --> 00:24:31.850
So the congestion over
here is equal to 4.

00:24:34.520 --> 00:24:39.080
Now, this does not look so
good because for a binary tree,

00:24:39.080 --> 00:24:41.915
we always have this
vulnerable root that

00:24:41.915 --> 00:24:45.380
is right here in the center
connecting the left side

00:24:45.380 --> 00:24:46.420
to the right side.

00:24:46.420 --> 00:24:48.378
So we can always find a
permutation-- actually,

00:24:48.378 --> 00:24:50.680
this permutation over
here-- that leads

00:24:50.680 --> 00:24:54.110
to this worst-case congestion.

00:24:54.110 --> 00:24:59.470
So what we're interested in
is the maximum congestion,

00:24:59.470 --> 00:25:02.520
which is sort of the
worst-case scenario.

00:25:02.520 --> 00:25:09.150
And we'll define it as follows.

00:25:09.150 --> 00:25:11.720
The maximum
congestion is actually

00:25:11.720 --> 00:25:16.450
equal to the maximum
over all permutations pi.

00:25:16.450 --> 00:25:19.840
So this is kind of the
worst-case routing problem

00:25:19.840 --> 00:25:23.180
that I can imagine and
it may occur in practice.

00:25:23.180 --> 00:25:28.950
So in the worst case, how
can I solve it the best?

00:25:28.950 --> 00:25:37.440
So I want to find the
minimum of the congestion

00:25:37.440 --> 00:25:49.010
of a path over here
and the minimum

00:25:49.010 --> 00:25:50.750
is over these types of paths.

00:25:50.750 --> 00:25:54.840
So actually, this
is our solution

00:25:54.840 --> 00:25:56.480
to this routing problem.

00:25:56.480 --> 00:25:58.740
We want to find the
best kind of solution

00:25:58.740 --> 00:26:05.950
for this worst-case
scenario-- so

00:26:05.950 --> 00:26:18.750
the minimum over all
solutions for these paths

00:26:18.750 --> 00:26:25.420
So well, for this
particular tree structure,

00:26:25.420 --> 00:26:30.040
this permutation is really
the worst-case scenario

00:26:30.040 --> 00:26:33.150
that you can have because
every packet needs to be routed

00:26:33.150 --> 00:26:35.700
through the center over here.

00:26:35.700 --> 00:26:39.520
And it means that our maximum
congestion for an arbitrary

00:26:39.520 --> 00:26:42.310
tree is actually equal to n.

00:26:44.960 --> 00:26:49.950
So that looks really
bad, actually.

00:26:49.950 --> 00:26:53.650
So we don't like this at all.

00:26:53.650 --> 00:26:56.960
So let's find out where we
can do a little bit better

00:26:56.960 --> 00:27:01.350
and we come to look at
the two-dimensional array

00:27:01.350 --> 00:27:05.770
and see what that
would lead up to.

00:27:05.770 --> 00:27:09.755
And its structure is as follows.

00:27:13.920 --> 00:27:17.950
We essentially have
inputs on the left

00:27:17.950 --> 00:27:20.910
and the outputs
are on the bottom

00:27:20.910 --> 00:27:23.280
and they are in
a grid structure.

00:27:23.280 --> 00:27:30.700
So we have input zero, input
one, input two, input three.

00:27:30.700 --> 00:27:32.225
They all connect
to their terminals.

00:27:35.660 --> 00:27:44.810
We have switches, four of
those, and they are all

00:27:44.810 --> 00:27:46.320
connected in this grid.

00:27:49.660 --> 00:27:55.415
And at the very bottom, we will
have the outputs, the output

00:27:55.415 --> 00:27:55.915
terminals.

00:28:08.580 --> 00:28:12.730
So this is output
zero and here, we

00:28:12.730 --> 00:28:17.720
will have output one, output
two, and output three.

00:28:23.000 --> 00:28:27.000
So notice that my circle
start to resemble my squares,

00:28:27.000 --> 00:28:30.630
but these are all the switches
right here in the center.

00:28:30.630 --> 00:28:32.650
So how does this work?

00:28:32.650 --> 00:28:37.300
Well, do we have a
better parameter?

00:28:37.300 --> 00:28:39.280
So let's look at it together.

00:28:39.280 --> 00:28:41.890
So we need to
first of all figure

00:28:41.890 --> 00:28:43.390
out what the diameter is.

00:28:43.390 --> 00:28:48.310
So what's the diameter of
this particular network?

00:28:48.310 --> 00:28:54.750
So what's the shortest path
between the furthest input

00:28:54.750 --> 00:28:56.860
and output?

00:28:56.860 --> 00:28:59.880
So if you look at
that, we can see

00:28:59.880 --> 00:29:02.530
that if I go all
the way from here

00:29:02.530 --> 00:29:05.050
and I go all the way
down to this corner,

00:29:05.050 --> 00:29:07.770
that looks like the
largest path and I

00:29:07.770 --> 00:29:11.530
need to cross all these wires.

00:29:11.530 --> 00:29:16.100
And in general, for
any n, we will have

00:29:16.100 --> 00:29:20.760
that the diameter is 2 times n.

00:29:20.760 --> 00:29:23.629
Now, what about the switch size?

00:29:23.629 --> 00:29:25.170
It looks a little
bit smaller, right?

00:29:25.170 --> 00:29:27.530
Because over here, we had
three inputs coming in

00:29:27.530 --> 00:29:31.140
and three outputs coming
out but over here,

00:29:31.140 --> 00:29:33.030
we see that every
single switch is only

00:29:33.030 --> 00:29:35.270
two inputs and two outputs.

00:29:35.270 --> 00:29:38.440
So that makes the
size two times two.

00:29:41.950 --> 00:29:44.590
Now, the number of switches
is pretty bad, right,

00:29:44.590 --> 00:29:49.140
because we have n
squared switches.

00:29:49.140 --> 00:29:50.790
So that's really horrible.

00:29:50.790 --> 00:29:52.100
That's a lot.

00:29:52.100 --> 00:29:54.330
We would like to do much better.

00:29:54.330 --> 00:29:56.270
And what about the congestion?

00:29:56.270 --> 00:29:58.960
Do you have any idea
what the congestion could

00:29:58.960 --> 00:30:00.450
be in this particular case?

00:30:00.450 --> 00:30:03.020
We will prove a theorem on that.

00:30:07.190 --> 00:30:11.990
For any permutation,
is there a way to route

00:30:11.990 --> 00:30:15.060
the inputs to the outputs in
such a way that the switches

00:30:15.060 --> 00:30:17.790
get almost not congested?

00:30:17.790 --> 00:30:19.640
So in the binary tree,
we had a congestion

00:30:19.640 --> 00:30:23.080
of n, which is linear
in the switches.

00:30:23.080 --> 00:30:26.780
But over here, we
can do much better.

00:30:26.780 --> 00:30:45.210
We will show that the
congestion of an n-input array

00:30:45.210 --> 00:30:47.700
is actually equal to 2.

00:30:47.700 --> 00:30:49.590
So that's great.

00:30:49.590 --> 00:30:52.230
So I'll prove it in
a moment, but that

00:30:52.230 --> 00:30:53.960
looks really fantastic.

00:30:53.960 --> 00:30:58.930
And so it's way better
than the binary tree.

00:30:58.930 --> 00:31:02.030
Now, this is really not so good
and this is also much larger,

00:31:02.030 --> 00:31:09.440
but still-- we will
start to think next

00:31:09.440 --> 00:31:12.590
after we show this
particular property how

00:31:12.590 --> 00:31:15.770
to combine these two and
see how we can come up

00:31:15.770 --> 00:31:20.670
with another network that's
able to combine in some ways

00:31:20.670 --> 00:31:22.130
these two properties.

00:31:22.130 --> 00:31:25.107
And maybe we can find a
good solution that way.

00:31:25.107 --> 00:31:27.440
It turns out we will not
immediately be able to do that.

00:31:27.440 --> 00:31:29.310
We will need to
make another step

00:31:29.310 --> 00:31:31.700
and come to the last network.

00:31:31.700 --> 00:31:34.330
It really has good parameters.

00:31:34.330 --> 00:31:36.500
So what about the theorem?

00:31:36.500 --> 00:31:40.930
So if you prove this,
well, how do we start?

00:31:40.930 --> 00:31:44.627
You just start with
any permutation.

00:31:44.627 --> 00:31:46.710
If I want to prove something
about the congestion,

00:31:46.710 --> 00:31:49.775
it's defined as the maximum
of all permutations.

00:31:49.775 --> 00:31:53.670
So let's take one of them
and see what we can prove.

00:32:07.359 --> 00:32:11.305
So let us define the paths
for this permutation.

00:32:11.305 --> 00:32:14.530
So what we really want to do
is we take any permutation

00:32:14.530 --> 00:32:17.700
and we want to find a really
good solution for the routing.

00:32:17.700 --> 00:32:22.500
If that gives us a very low
congestion, we are very happy.

00:32:22.500 --> 00:32:28.270
So the way to do this is well,
maybe you have an idea already.

00:32:28.270 --> 00:32:30.120
So how would I route this?

00:32:30.120 --> 00:32:34.900
So I want to connect
an input i, say, 1, 2,

00:32:34.900 --> 00:32:38.580
output two, for example.

00:32:38.580 --> 00:32:39.680
How can I do this?

00:32:39.680 --> 00:32:41.640
Any suggestions?

00:32:41.640 --> 00:32:44.070
So of course, I
could go any path,

00:32:44.070 --> 00:32:48.000
but somehow, I want to have
some uniform structure that

00:32:48.000 --> 00:32:51.190
hopefully helps me to prove that
the congestion in every switch

00:32:51.190 --> 00:32:52.260
is very small.

00:32:52.260 --> 00:32:56.520
So how could I think about this?

00:32:56.520 --> 00:33:03.100
Well, if I make sure
that, say, a packet that

00:33:03.100 --> 00:33:06.230
goes from one to
output two is only

00:33:06.230 --> 00:33:09.400
going to be participating
in the wires

00:33:09.400 --> 00:33:15.510
off the i-th throw
and the P-i-th column,

00:33:15.510 --> 00:33:24.120
then I know that every wire will
only get traveled over twice

00:33:24.120 --> 00:33:24.780
by a packet.

00:33:24.780 --> 00:33:29.160
This could either be a packet
that goes into this direction

00:33:29.160 --> 00:33:32.650
or-- so a switch will be
accessed at most twice.

00:33:32.650 --> 00:33:36.160
A switch can either receive
a packet from this direction

00:33:36.160 --> 00:33:42.140
or receive a packet
from the upper part.

00:33:42.140 --> 00:33:44.090
So that will be a
really good idea.

00:33:44.090 --> 00:33:46.220
So let's define that.

00:33:46.220 --> 00:33:52.460
So we say that in our solution,
we will design it such

00:33:52.460 --> 00:33:57.020
that the path from
input i is actually

00:33:57.020 --> 00:34:08.139
going to be rightward
to column pi i

00:34:08.139 --> 00:34:19.250
and then downward to the
output-- so downward to output

00:34:19.250 --> 00:34:21.280
by i.

00:34:21.280 --> 00:34:28.870
So this is a really good
solution to the routing problem

00:34:28.870 --> 00:34:32.820
because now, we can continue
our proof as follows.

00:34:32.820 --> 00:34:43.440
We just say, well, if you
look at the switch in row i

00:34:43.440 --> 00:34:50.969
and column pi i, well,
this one actually

00:34:50.969 --> 00:35:03.260
transmits at most two packets
because a packet can only

00:35:03.260 --> 00:35:10.880
come from the left or it's
going to go from the top.

00:35:10.880 --> 00:35:15.810
So either one of the two--
at most, those two packets

00:35:15.810 --> 00:35:17.990
will go through the switch.

00:35:17.990 --> 00:35:24.050
So this shows that we have
a congestion of at most two

00:35:24.050 --> 00:35:25.990
for any permutation.

00:35:25.990 --> 00:35:28.360
And in order to prove
equality, because that's really

00:35:28.360 --> 00:35:30.060
what the theorem
says, we also have

00:35:30.060 --> 00:35:33.480
to show that there
exists a permutation that

00:35:33.480 --> 00:35:36.300
achieves a congestion of two.

00:35:36.300 --> 00:35:38.340
And that is pretty
straightforward.

00:35:38.340 --> 00:35:43.310
We can, for example use
a specific permutation

00:35:43.310 --> 00:35:51.980
that maps zero to zero and
maps n minus 1 to n minus 1.

00:35:51.980 --> 00:35:53.940
Well, for this
particular permutation,

00:35:53.940 --> 00:35:57.500
when we look at the
picture over here,

00:35:57.500 --> 00:36:03.630
we see that input zero
needs to go to output zero.

00:36:03.630 --> 00:36:09.370
We also see that this
lowest input, input three,

00:36:09.370 --> 00:36:12.370
needs to travel all
the way up to here.

00:36:12.370 --> 00:36:15.570
But it's clear that the packet
that needs to go over here

00:36:15.570 --> 00:36:23.140
needs to travel through that
switch in the lower left bottom

00:36:23.140 --> 00:36:24.360
corner.

00:36:24.360 --> 00:36:28.000
And the input three also
needs to travel through that.

00:36:28.000 --> 00:36:32.510
So here, we clearly see that we
you have a congestion of two.

00:36:32.510 --> 00:36:35.140
So now, the proof is
complete because we

00:36:35.140 --> 00:36:37.460
have shown this upper bound.

00:36:37.460 --> 00:36:41.170
So for any permutation, the
congestion is at most two

00:36:41.170 --> 00:36:48.170
and we see that this
specific permutation achieves

00:36:48.170 --> 00:36:49.840
this congestion.

00:36:49.840 --> 00:36:52.840
So this is the
end of this proof.

00:36:52.840 --> 00:36:54.070
So that's great.

00:36:54.070 --> 00:36:55.570
So now, what we'd
like to do is we'd

00:36:55.570 --> 00:36:58.660
like to combine
these two networks

00:36:58.660 --> 00:37:01.340
and see what we can
learn from both.

00:37:01.340 --> 00:37:09.910
So now, we'll be taking out
a lot of chalk over here.

00:37:09.910 --> 00:37:14.600
So the idea is to construct
a butterfly network

00:37:14.600 --> 00:37:19.930
and I will draw it in
such a way that you can

00:37:19.930 --> 00:37:21.200
see the recursive structure.

00:37:25.620 --> 00:37:34.630
The idea is to do
the following thing.

00:37:34.630 --> 00:37:39.532
So let me see how I
can do this the best.

00:37:39.532 --> 00:37:45.240
So I will just do the top line
first and I have the spacing.

00:37:45.240 --> 00:37:50.710
So we have input zero, a
terminal, we have a switch,

00:37:50.710 --> 00:37:58.230
we have a switch, we have
a switch, and another one,

00:37:58.230 --> 00:38:02.900
and here, we have
the output zero.

00:38:02.900 --> 00:38:06.860
So the whole idea
is that I'm going

00:38:06.860 --> 00:38:13.800
to combine every two outputs
by using a small butterfly

00:38:13.800 --> 00:38:15.820
structure.

00:38:15.820 --> 00:38:26.949
So we have two, output three,
output four-- actually,

00:38:26.949 --> 00:38:28.240
I need a little bit more space.

00:38:33.001 --> 00:38:46.460
Do it once more, output
one, two, three, four, five,

00:38:46.460 --> 00:38:49.340
six, and a last one, seven.

00:38:49.340 --> 00:38:51.900
This is going to be
pretty tight on the board.

00:38:51.900 --> 00:38:54.290
So what's happening is this.

00:38:54.290 --> 00:38:57.670
So these are all connected,
of course, to switches.

00:38:57.670 --> 00:38:59.050
The switches output those.

00:39:05.540 --> 00:39:11.490
And the idea is that we create
the following structure.

00:39:11.490 --> 00:39:14.340
This switch can either
forward it over here

00:39:14.340 --> 00:39:17.430
or it can cross it over
to this particular line.

00:39:17.430 --> 00:39:20.720
And this switch can either
forward it or cross it over

00:39:20.720 --> 00:39:21.410
to this line.

00:39:21.410 --> 00:39:24.180
So this is a very small
butterfly structure.

00:39:24.180 --> 00:39:27.980
Here, we have two
inputs and two outputs.

00:39:27.980 --> 00:39:31.340
And we will repeat this
process and we'll do the same

00:39:31.340 --> 00:39:33.420
on each of these other levels.

00:39:33.420 --> 00:39:44.160
So we forward those or
we cross them, like this.

00:39:48.460 --> 00:39:53.190
And now that we have constructed
all these smaller butterfly

00:39:53.190 --> 00:39:56.360
structures, we can start
to combine two butterfly

00:39:56.360 --> 00:39:59.020
structures together
in the bigger one.

00:39:59.020 --> 00:40:01.180
So here, we had two
outputs that we combined

00:40:01.180 --> 00:40:03.030
in a butterfly structure.

00:40:03.030 --> 00:40:04.700
Now, we use two
butterfly structures

00:40:04.700 --> 00:40:09.930
that we put into
a bigger version.

00:40:09.930 --> 00:40:11.580
So how do we do this?

00:40:11.580 --> 00:40:16.130
Well, we have that the
upper half over here

00:40:16.130 --> 00:40:21.300
can either forward those
packets or cross them over

00:40:21.300 --> 00:40:25.510
to the bottom part
butterfly structure.

00:40:25.510 --> 00:40:30.880
So for these, we can either
forward them straight on

00:40:30.880 --> 00:40:36.290
or we can go to
the top butterfly.

00:40:36.290 --> 00:40:40.650
So you see that these two
inputs, these two switches,

00:40:40.650 --> 00:40:46.330
either can forward packets
to this sub-butterfly network

00:40:46.330 --> 00:40:50.220
or to the top butterfly network.

00:40:50.220 --> 00:40:54.840
Now, we'll continue this
process and for these, you'll

00:40:54.840 --> 00:40:55.800
do the same.

00:40:55.800 --> 00:41:01.490
So we can either go
straight or we go down.

00:41:01.490 --> 00:41:03.520
And over here, we
can go straight

00:41:03.520 --> 00:41:08.320
or we can go to the
top butterfly network.

00:41:08.320 --> 00:41:15.520
Well, now we have the final part
where we combine essentially

00:41:15.520 --> 00:41:19.170
these two butterfly networks.

00:41:19.170 --> 00:41:23.110
We have two butterfly networks
created here now composed again

00:41:23.110 --> 00:41:24.710
of smaller ones
and these two are

00:41:24.710 --> 00:41:27.660
being composed to this
bigger butterfly network.

00:41:27.660 --> 00:41:32.410
Again, we take
these four switches.

00:41:32.410 --> 00:41:34.620
They can route their
packets forward

00:41:34.620 --> 00:41:40.250
to the top butterfly sub-network
or to the bottom one.

00:41:40.250 --> 00:41:43.650
So they can either
go straight ahead

00:41:43.650 --> 00:41:48.480
or this one can connect
to the first over here,

00:41:48.480 --> 00:41:53.410
this one to the second, to the
third, and this to the fourth.

00:41:53.410 --> 00:41:59.500
And in the same style, these can
forward them straight like this

00:41:59.500 --> 00:42:09.760
and then go up like this.

00:42:09.760 --> 00:42:12.210
And these are all connected
because in this example,

00:42:12.210 --> 00:42:15.300
let's just have an
eight by eight network,

00:42:15.300 --> 00:42:16.720
butterfly network.

00:42:16.720 --> 00:42:21.790
We have input zero to seven.

00:42:32.820 --> 00:42:34.304
So this is the
butterfly network.

00:42:34.304 --> 00:42:35.720
In a way, what you
can see here is

00:42:35.720 --> 00:42:38.950
you can see sort of the
two-dimensional structure,

00:42:38.950 --> 00:42:41.640
like we have rows and columns.

00:42:41.640 --> 00:42:46.330
At the same time, we can also
see this binary sort of tree

00:42:46.330 --> 00:42:51.860
feeling we get from it, which
is that a switch can forward

00:42:51.860 --> 00:42:58.040
sort of its packets to
either, say, the top butterfly

00:42:58.040 --> 00:42:59.420
or the bottom butterfly.

00:42:59.420 --> 00:43:01.900
So there's a split in two.

00:43:01.900 --> 00:43:03.270
The same for this one, right?

00:43:03.270 --> 00:43:07.020
This one goes either to
this butterfly network

00:43:07.020 --> 00:43:09.850
or it goes to this
butterfly network.

00:43:09.850 --> 00:43:12.200
So you have this tree
structure sort of

00:43:12.200 --> 00:43:16.000
embedded in this
two-dimensional structure.

00:43:16.000 --> 00:43:18.580
So what are the
properties of this one?

00:43:18.580 --> 00:43:28.690
So let me first define in
more formal mathematics

00:43:28.690 --> 00:43:31.660
how the switches
route their packets,

00:43:31.660 --> 00:43:35.630
so how the connections are.

00:43:35.630 --> 00:43:39.420
So in order to do that, we are
going to label each switch.

00:43:42.720 --> 00:43:46.880
And the idea is that we're
going to label it by its row

00:43:46.880 --> 00:43:48.480
and by its column.

00:43:48.480 --> 00:43:53.580
So we will have--
the columns are

00:43:53.580 --> 00:44:01.530
numbered by level zero, level
one, level two, level three,

00:44:01.530 --> 00:44:02.580
yes?

00:44:02.580 --> 00:44:06.625
And the rows are
these integers, but we

00:44:06.625 --> 00:44:09.930
are going to represent
them by binary numbers.

00:44:09.930 --> 00:44:22.210
So zero would be 000, 001,
010, 011-- oops-- 100, 101,

00:44:22.210 --> 00:44:29.320
and then we got 110 and 111.

00:44:29.320 --> 00:44:32.850
So for example, this particular
switch would be labeled

00:44:32.850 --> 00:44:38.040
by these three bits, 001,
and the integer number, 1.

00:44:38.040 --> 00:44:48.520
This one would be 011 and its
column is indexed by integer 2.

00:44:48.520 --> 00:45:04.010
So a switch is
uniquely identified

00:45:04.010 --> 00:45:09.130
by its row and column.

00:45:12.340 --> 00:45:18.820
We will have b1
up to b logarithm

00:45:18.820 --> 00:45:22.060
of n, which are
the number of bits

00:45:22.060 --> 00:45:25.670
to represent the row in
digits, and to finally

00:45:25.670 --> 00:45:31.300
have an integer l and this
we will call the level.

00:45:31.300 --> 00:45:37.480
So this particular switch either
directs or routes a packet

00:45:37.480 --> 00:45:43.790
to the switch that is
indexed by b one up to--

00:45:43.790 --> 00:45:48.590
and then we get b, l plus 1
and we take its complement.

00:45:48.590 --> 00:45:51.570
So instead of if b,
l plus n would be 1,

00:45:51.570 --> 00:45:53.280
we would have a 0 here.

00:45:53.280 --> 00:45:55.780
If it would be a 0, we
will have a 1 over here.

00:45:58.370 --> 00:46:05.030
But we repeat all the other
bits and we get to b log n.

00:46:05.030 --> 00:46:07.840
And it routes us back
to the next level.

00:46:07.840 --> 00:46:11.480
So we will have l plus 1.

00:46:11.480 --> 00:46:15.480
Another possibility because
there are two outgoing edges

00:46:15.480 --> 00:46:23.570
is if we have just b1 and
we just copy b, l plus 1,

00:46:23.570 --> 00:46:24.830
essentially.

00:46:24.830 --> 00:46:26.890
We route a packet
straightforward.

00:46:26.890 --> 00:46:29.330
We don't do anything special.

00:46:29.330 --> 00:46:33.300
We get b log n over here
and then to the next level.

00:46:33.300 --> 00:46:37.980
So for example, let's see where
we can see how this works.

00:46:37.980 --> 00:46:42.210
So for example, take
this particular switch.

00:46:42.210 --> 00:46:45.980
We have 010.

00:46:45.980 --> 00:46:48.670
So it can either go straight
on to the next level.

00:46:48.670 --> 00:46:52.300
It would go to 010 but
then instead of level one,

00:46:52.300 --> 00:46:58.070
we have level two, which is
the right edge over there.

00:46:58.070 --> 00:47:02.810
The other one is if
this one goes up, well,

00:47:02.810 --> 00:47:14.120
we will need to switch the
first bit over here, a 1.

00:47:14.120 --> 00:47:19.010
We swap it into 0 and then we
go to the three zeros over here

00:47:19.010 --> 00:47:21.120
and we go to the
next level and that

00:47:21.120 --> 00:47:24.350
would be this particular rule.

00:47:24.350 --> 00:47:29.650
So what we can do here is
to-- so when we see this,

00:47:29.650 --> 00:47:34.220
we can start to figure out
how we can direct inputs

00:47:34.220 --> 00:47:36.040
to outputs.

00:47:36.040 --> 00:47:38.390
So let's do this.

00:47:45.410 --> 00:47:55.950
So suppose I want to route a
packet from a certain input,

00:47:55.950 --> 00:48:04.430
one of these, all the way to
one of the outputs over here.

00:48:04.430 --> 00:48:09.900
So the way to do
this is as follows.

00:48:09.900 --> 00:48:15.610
We can just start-- for example,
I want to go from switch x1

00:48:15.610 --> 00:48:21.120
up to x log n comma 0.

00:48:21.120 --> 00:48:24.830
So I start completely
at the left over here

00:48:24.830 --> 00:48:28.780
and I want to go somewhere
of my choice to the right.

00:48:28.780 --> 00:48:36.660
So I want to somehow move all
the way to some other row, y1

00:48:36.660 --> 00:48:41.660
indexed by y by the bit
pattern, y1 up to y log n,

00:48:41.660 --> 00:48:46.670
but now at the very last
level, which is log n.

00:48:46.670 --> 00:48:48.980
Well, how do I do it?

00:48:48.980 --> 00:48:51.550
Well, this switch, I can
use that rule up there

00:48:51.550 --> 00:48:55.380
and simply change x1 to y1.

00:48:55.380 --> 00:48:59.600
I can either leave x1 as it
is if it's the same as y1

00:48:59.600 --> 00:49:01.840
or I can swap it
to its complement

00:49:01.840 --> 00:49:04.570
if that's the value of y1.

00:49:04.570 --> 00:49:10.540
So what I can do is I can
just simply route it to y1.

00:49:10.540 --> 00:49:13.950
And then, I leave all
the other bits the same,

00:49:13.950 --> 00:49:19.940
which are x2, x3, all
the way up to x log n.

00:49:19.940 --> 00:49:27.310
And we will have
reached the first level.

00:49:27.310 --> 00:49:30.930
Now, this one can go
to-- well, now I'm

00:49:30.930 --> 00:49:34.420
going to swap the second bit
into the bit of my choice.

00:49:34.420 --> 00:49:37.560
So I leave all the other
bits the same, y1 the same,

00:49:37.560 --> 00:49:39.470
x3, all the others the same.

00:49:39.470 --> 00:49:43.900
I just swap x2 into y2.

00:49:43.900 --> 00:49:50.100
So we leave all those equal
and we go to the second level.

00:49:50.100 --> 00:49:54.880
And then, we go all the
way to the final level

00:49:54.880 --> 00:49:56.934
and we one by one
swap all these bits.

00:49:56.934 --> 00:49:57.975
So let's have an example.

00:50:00.950 --> 00:50:04.030
Suppose I want to
connect, let's say,

00:50:04.030 --> 00:50:10.960
this one to for
example, well, let's say

00:50:10.960 --> 00:50:13.120
this particular output.

00:50:13.120 --> 00:50:19.570
So what's the
binary for this one?

00:50:19.570 --> 00:50:22.900
This is actually 101.

00:50:22.900 --> 00:50:29.030
So if the first bit is
different, I need to cross.

00:50:29.030 --> 00:50:32.760
And otherwise, I need
to pass straight on.

00:50:32.760 --> 00:50:35.260
So let's do this.

00:50:35.260 --> 00:50:37.530
So over here, I'm in 011.

00:50:37.530 --> 00:50:42.110
I need to go to 101 so we need
to change the zero into a one.

00:50:42.110 --> 00:50:45.444
So I need to go down.

00:50:45.444 --> 00:50:46.110
I need to cross.

00:50:51.150 --> 00:50:55.790
Now, if I look at
the second bit,

00:50:55.790 --> 00:51:00.190
I also need to change
it to a zero so again,

00:51:00.190 --> 00:51:05.020
I need to cross,
which is over here.

00:51:05.020 --> 00:51:10.240
Now, the third bit is equal
to 1 and it's the same.

00:51:10.240 --> 00:51:11.750
So now, I can go straight ahead.

00:51:11.750 --> 00:51:18.280
I do not cross and I
end up at this output.

00:51:18.280 --> 00:51:19.380
So what did I do?

00:51:19.380 --> 00:51:22.310
For every bit that
is different, I cross

00:51:22.310 --> 00:51:25.480
and for the bits that are the
same, I go straight ahead.

00:51:25.480 --> 00:51:28.796
So this is how I can route
packets from one input

00:51:28.796 --> 00:51:29.546
to another output.

00:51:34.860 --> 00:51:38.340
So let's look at the parameters.

00:51:38.340 --> 00:51:43.810
First of all, if you
look at the diameter,

00:51:43.810 --> 00:51:46.480
well, it turns out that
that's approximately

00:51:46.480 --> 00:51:51.800
equal to the number of levels,
which is the logarithm of n.

00:51:51.800 --> 00:51:55.210
And to be precise, it's
actually equal to 2

00:51:55.210 --> 00:51:57.600
plus the logarithm of n.

00:51:57.600 --> 00:51:59.734
So that's great.

00:51:59.734 --> 00:52:00.650
That's a good scaling.

00:52:00.650 --> 00:52:02.480
Again, it's back to
the logarithm of n.

00:52:02.480 --> 00:52:06.410
So we have the best of
these two parameters.

00:52:06.410 --> 00:52:10.790
The switches that we see have
two inputs and two outputs.

00:52:10.790 --> 00:52:15.710
So we again have a
two times two switch.

00:52:15.710 --> 00:52:18.380
The number of
switches is the number

00:52:18.380 --> 00:52:20.170
of rows times the
number of columns.

00:52:20.170 --> 00:52:22.790
The number of columns is the
logarithm of n and number

00:52:22.790 --> 00:52:26.369
of rows is equal to n.

00:52:26.369 --> 00:52:27.910
And to make it a
little bit, precise,

00:52:27.910 --> 00:52:31.050
it's 1 plus the logarithm of n.

00:52:31.050 --> 00:52:32.910
So that's somewhere
in between those two.

00:52:32.910 --> 00:52:34.520
But if you're thinking
about it, it's

00:52:34.520 --> 00:52:35.950
much better than n squared.

00:52:35.950 --> 00:52:40.510
It's almost linear except
for a logarithmic factor.

00:52:40.510 --> 00:52:42.410
For the congestion--
and we are not

00:52:42.410 --> 00:52:46.200
going to talk about it here,
but you have a problem set

00:52:46.200 --> 00:52:49.720
assignment that will
ask you to solve

00:52:49.720 --> 00:52:54.160
this-- is that
actually, the congestion

00:52:54.160 --> 00:52:59.650
is the square root of n or it's
equal to the square root of n

00:52:59.650 --> 00:53:04.300
over 2, depending on
whether n is an even power

00:53:04.300 --> 00:53:06.355
or n is an odd power.

00:53:06.355 --> 00:53:07.980
Now, we're not going
to prove that here

00:53:07.980 --> 00:53:10.860
because we want to step forward
to this particular network.

00:53:10.860 --> 00:53:12.620
It's very exciting.

00:53:12.620 --> 00:53:16.100
And you will prove this
in your problem set.

00:53:16.100 --> 00:53:18.750
So this one is somewhere
in between, somewhere

00:53:18.750 --> 00:53:20.810
in between these two extremes.

00:53:20.810 --> 00:53:25.100
Now, it will be really
fantastic if we can somehow

00:53:25.100 --> 00:53:28.580
transform this network
with a trick to,

00:53:28.580 --> 00:53:31.310
again, have a really
great congestion

00:53:31.310 --> 00:53:36.550
of just a constant, like two
or three or whatever or maybe

00:53:36.550 --> 00:53:37.910
even one.

00:53:37.910 --> 00:53:42.780
So for this particular
network, in the 1960s,

00:53:42.780 --> 00:53:46.320
Benes, a Bell Labs
researcher, had the great idea

00:53:46.320 --> 00:53:51.490
to use a butterfly network
and attach to it, again,

00:53:51.490 --> 00:53:55.680
a butterfly network,
back to back sort of.

00:53:55.680 --> 00:53:58.160
So what was his idea?

00:53:58.160 --> 00:54:02.910
His idea was to
do the following.

00:54:02.910 --> 00:54:10.500
So the butterfly network
as we have it right now

00:54:10.500 --> 00:54:14.080
is this particular
part over here.

00:54:14.080 --> 00:54:20.300
And the idea is now to start
up mixing all those outputs

00:54:20.300 --> 00:54:24.550
that we got here together
again using a similar rule.

00:54:24.550 --> 00:54:25.990
So what do we do?

00:54:25.990 --> 00:54:36.270
We are going to
essentially repeat

00:54:36.270 --> 00:54:41.030
this particular
structure on this side.

00:54:41.030 --> 00:54:43.090
So how do we do it?

00:54:43.090 --> 00:54:48.850
Well, we go either
straightforward

00:54:48.850 --> 00:54:51.070
or we start to mix them again.

00:54:51.070 --> 00:54:55.150
So it's like this output,
this particular switch,

00:54:55.150 --> 00:54:57.960
can either go straight
ahead or can cross

00:54:57.960 --> 00:55:01.940
to the lower part over here.

00:55:01.940 --> 00:55:03.860
It goes over here and
this one goes over.

00:55:03.860 --> 00:55:08.240
So as you can see, we
have repeated this part.

00:55:08.240 --> 00:55:12.040
It's exactly the same as
this structure over here.

00:55:12.040 --> 00:55:19.820
We'll do the same for this part.

00:55:19.820 --> 00:55:24.910
So we can either cross or
we can go straight ahead.

00:55:24.910 --> 00:55:27.390
Oh, we also have, of
course, that these switches

00:55:27.390 --> 00:55:31.470
can go straight ahead
or can cross to the top.

00:55:31.470 --> 00:55:33.400
I forgot about that.

00:55:33.400 --> 00:55:37.080
So we have this--
oops-- as well.

00:55:37.080 --> 00:55:39.320
So as you can see, this
particular structure

00:55:39.320 --> 00:55:41.960
repeats itself
again and we slowly

00:55:41.960 --> 00:55:45.820
start to build up in mixing
all the outputs again

00:55:45.820 --> 00:55:54.510
or the possibility, at least,
to route them to any other row.

00:55:54.510 --> 00:55:55.810
So how do we do this?

00:55:55.810 --> 00:55:57.920
Well, we continue this
particular structure now

00:55:57.920 --> 00:55:58.500
over here.

00:55:58.500 --> 00:56:01.850
So all these can either
go straight ahead.

00:56:07.435 --> 00:56:08.310
That's a possibility.

00:56:11.570 --> 00:56:15.330
Or they can go all down.

00:56:18.690 --> 00:56:20.850
So this switch can
either go straight ahead

00:56:20.850 --> 00:56:24.790
or can go to the lower half.

00:56:24.790 --> 00:56:26.610
And for these, we have
a similar structure.

00:56:26.610 --> 00:56:33.340
We can either go straight ahead
or such a switch can cross over

00:56:33.340 --> 00:56:36.630
to the top over here.

00:56:42.180 --> 00:56:43.480
So that's this.

00:56:43.480 --> 00:56:46.300
So this is Benes network and
then over here, of course,

00:56:46.300 --> 00:56:59.970
we have the outputs, zero, one,
and all the way down to seven.

00:57:11.340 --> 00:57:15.060
So as you can see over
here, the structure again

00:57:15.060 --> 00:57:17.980
has a recursive nature to it.

00:57:17.980 --> 00:57:24.340
You can see that this big
Benes network over here

00:57:24.340 --> 00:57:27.350
consists of two
smaller ones that

00:57:27.350 --> 00:57:30.390
are right here in the
middle, this one that

00:57:30.390 --> 00:57:33.560
goes all the way up to
here-- so maybe I should

00:57:33.560 --> 00:57:37.290
put a color boundary around it.

00:57:37.290 --> 00:57:44.280
Let me check I want
to do this-- right.

00:57:44.280 --> 00:57:52.150
So this particular
part, is again

00:57:52.150 --> 00:57:58.810
a Benes network and the top
part in the same picture,

00:57:58.810 --> 00:58:05.800
the top subnetwork is also
a Benes network, this part.

00:58:13.300 --> 00:58:15.880
And if you look
within those, we again

00:58:15.880 --> 00:58:20.600
see a top part
and a bottom part.

00:58:20.600 --> 00:58:25.830
And over here, we see a top
part and also a bottom part.

00:58:25.830 --> 00:58:31.500
So you see this recursive
nature again reappearing.

00:58:31.500 --> 00:58:33.930
It turns out that
with this trick,

00:58:33.930 --> 00:58:36.620
we can completely
eliminate congestion

00:58:36.620 --> 00:58:40.600
and we can get it to only one,
which is really surprising.

00:58:40.600 --> 00:58:42.800
And that what we're
going to prove here.

00:58:42.800 --> 00:58:45.690
So this is a great
invention at the time.

00:58:45.690 --> 00:58:48.870
It's really, really beautiful.

00:58:48.870 --> 00:58:51.880
So let me put in the
other parameters.

00:58:51.880 --> 00:58:54.080
So they stay
approximately the same

00:58:54.080 --> 00:58:57.240
up to that the diameter
is about twice as

00:58:57.240 --> 00:59:00.850
large because we added another
sort of whole butterfly

00:59:00.850 --> 00:59:02.520
structure to it.

00:59:02.520 --> 00:59:05.960
The switch size stays the same.

00:59:05.960 --> 00:59:11.190
We, again, have about
two times more switches

00:59:11.190 --> 00:59:16.080
so they sort of stay about the
same up to a linear factor,

00:59:16.080 --> 00:59:18.380
like a constant factor.

00:59:18.380 --> 00:59:22.210
And the congestion, however,
completely dropped down to one.

00:59:22.210 --> 00:59:24.490
So that's what we're
going to prove now.

00:59:24.490 --> 00:59:27.401
And in order to
get some intuition,

00:59:27.401 --> 00:59:29.150
well, let me first
write down the theorem.

00:59:32.330 --> 00:59:36.850
Actually, let me
put this over here.

00:59:43.840 --> 00:59:54.530
So in order to get
some insight into this,

00:59:54.530 --> 00:59:56.410
we are going to use
this recursive nature.

00:59:56.410 --> 00:59:58.118
So we're going to use
induction and we're

00:59:58.118 --> 01:00:03.100
going to say, oh,
for any permutation,

01:00:03.100 --> 01:00:07.910
I can find really good routing
for say, this red subnetwork

01:00:07.910 --> 01:00:09.870
and for this blue subnetwork.

01:00:09.870 --> 01:00:11.580
So I know that.

01:00:11.580 --> 01:00:17.960
So what I need to do is, if I
have my bigger Benes network,

01:00:17.960 --> 01:00:21.450
like this one, I would
need to somehow map

01:00:21.450 --> 01:00:25.330
these inputs-- I
need to route them

01:00:25.330 --> 01:00:29.360
to either the top and the bottom
subnetwork, one of the two,

01:00:29.360 --> 01:00:32.840
in such a way that
there will be absolutely

01:00:32.840 --> 01:00:35.080
no congestion, because
we want to keep this one.

01:00:35.080 --> 01:00:39.300
So a switch should only
see one packet coming in.

01:00:39.300 --> 01:00:42.460
So that means, for example--
and we'll come back to that--

01:00:42.460 --> 01:00:44.090
that for example,
for this switch,

01:00:44.090 --> 01:00:47.260
it should not receive a
packet from both this input

01:00:47.260 --> 01:00:49.080
and from this input.

01:00:49.080 --> 01:00:51.530
So the intuition that
we are going to create

01:00:51.530 --> 01:00:58.510
is we're going to list our
constraints, the constraints

01:00:58.510 --> 01:01:02.930
that we need to satisfy, like
the zero and the fourth input

01:01:02.930 --> 01:01:07.950
should not both be mapped to
this top subnetwork and so on.

01:01:07.950 --> 01:01:10.090
So we will get into
that and then we

01:01:10.090 --> 01:01:15.100
will gain a lot of intuition
on how to solve this.

01:01:15.100 --> 01:01:17.970
So what's the theorem?

01:01:17.970 --> 01:01:32.970
So the theorem is that the
congestion of the n-input Benes

01:01:32.970 --> 01:01:41.110
network is actually equal to 1.

01:01:41.110 --> 01:01:46.320
And we will prove this for
n equal to a power of 2.

01:01:46.320 --> 01:01:50.260
We have assumed
that at the start

01:01:50.260 --> 01:01:54.280
that we had with all the
other networks, as well.

01:01:54.280 --> 01:02:00.340
And in this case, we
will use induction on a.

01:02:00.340 --> 01:02:04.280
So that's the
method that we will

01:02:04.280 --> 01:02:06.790
do because that's also
the recursive structure

01:02:06.790 --> 01:02:09.150
of the Benes network itself.

01:02:09.150 --> 01:02:17.930
So we will use
induction on a and we

01:02:17.930 --> 01:02:21.150
are going to define the
induction hypothesis simply

01:02:21.150 --> 01:02:34.210
as, "The theorem is true for a."

01:02:34.210 --> 01:02:35.570
Now, let us do the base case.

01:02:35.570 --> 01:02:37.840
We always start
with the base case

01:02:37.840 --> 01:02:41.140
and that should be pretty
easy because this is

01:02:41.140 --> 01:02:44.240
the most basic Benes network.

01:02:44.240 --> 01:02:48.630
So n equals 2 to the power of 1.

01:02:48.630 --> 01:02:57.210
We essentially have two inputs,
an input zero and an input one.

01:02:57.210 --> 01:02:59.810
They are connected to these
switches over here that

01:02:59.810 --> 01:03:05.010
can either forward them
or can cross them over

01:03:05.010 --> 01:03:08.850
and then they go
directly to the output.

01:03:08.850 --> 01:03:10.250
Notice that in
this case, we just

01:03:10.250 --> 01:03:12.800
have the most elementary
butterfly network.

01:03:12.800 --> 01:03:14.780
It's the same.

01:03:14.780 --> 01:03:19.160
So we have output
zero and output one.

01:03:19.160 --> 01:03:21.270
So this corresponds
in this picture

01:03:21.270 --> 01:03:25.090
to these little small
things over here,

01:03:25.090 --> 01:03:28.620
this one and this one
and this one over here

01:03:28.620 --> 01:03:32.440
and the fourth one over here.

01:03:32.440 --> 01:03:34.630
So now, let's take
any permutation.

01:03:34.630 --> 01:03:37.300
We want to show that we
can route it in such a way

01:03:37.300 --> 01:03:40.910
that there's only a
congestion of one.

01:03:40.910 --> 01:03:41.890
So let's do this.

01:03:51.970 --> 01:03:54.620
So there are essentially
only two permutations.

01:03:54.620 --> 01:03:56.960
Either zero is mapped
to zero and one

01:03:56.960 --> 01:03:59.650
is mapped to one or
zero is mapped to one

01:03:59.650 --> 01:04:01.090
and one is mapped to zero.

01:04:04.280 --> 01:04:07.690
So in both cases, we
can just route them

01:04:07.690 --> 01:04:11.890
through their own switches.

01:04:11.890 --> 01:04:17.870
So we have that either pi
of 0 equals 0 and pi of 1

01:04:17.870 --> 01:04:23.460
equals 1, in which case we just
direct them straight through

01:04:23.460 --> 01:04:26.410
and we go straight through
and every switch only

01:04:26.410 --> 01:04:27.930
sees a packet once.

01:04:27.930 --> 01:04:30.310
So for this particular
permutation,

01:04:30.310 --> 01:04:32.810
we have a congestion of one.

01:04:32.810 --> 01:04:36.160
Now, the other permutation
that we can have

01:04:36.160 --> 01:04:40.660
is if zero is mapped to one
and if one is mapped to zero.

01:04:40.660 --> 01:04:44.110
Well, in that
case, we just route

01:04:44.110 --> 01:04:48.400
this cross over
to the bottom row

01:04:48.400 --> 01:04:51.650
and here we go from this
switch to the top row.

01:04:51.650 --> 01:04:55.490
Again, every switch
only sees a packet once.

01:04:55.490 --> 01:04:58.460
So in this case, in the
base case, we are done.

01:04:58.460 --> 01:04:59.330
We are happy.

01:04:59.330 --> 01:05:02.871
We have shown that the
congestion is equal to one.

01:05:02.871 --> 01:05:07.060
So now, it gets
to the harder part

01:05:07.060 --> 01:05:10.640
because for the
inductive step, we

01:05:10.640 --> 01:05:15.560
are going to assume,
of course, that it

01:05:15.560 --> 01:05:19.200
holds true for a
smaller Benes network.

01:05:19.200 --> 01:05:29.330
So we assume that P a
is true and well, let's

01:05:29.330 --> 01:05:32.980
try to gain some insight here.

01:05:32.980 --> 01:05:37.600
So we know from our
induction hypothesis,

01:05:37.600 --> 01:05:43.830
within each subnetwork, we
can solve any routing problem

01:05:43.830 --> 01:05:47.650
with congestion one and for
this subnetwork, the same.

01:05:47.650 --> 01:05:49.990
That's our induction hypothesis.

01:05:49.990 --> 01:05:51.390
So how do we go ahead?

01:05:51.390 --> 01:05:55.780
We need to somehow
map these inputs

01:05:55.780 --> 01:05:58.590
according to the
permutation of our choice.

01:05:58.590 --> 01:06:01.110
So that could be for
some input zero goes

01:06:01.110 --> 01:06:06.580
to output five or input one
goes to output two, et cetera.

01:06:06.580 --> 01:06:09.420
So somehow, we need
to choose where

01:06:09.420 --> 01:06:14.120
we are going to map this
particular input to.

01:06:14.120 --> 01:06:18.530
So packet zero that
comes from this input

01:06:18.530 --> 01:06:21.110
should either go
to the red network

01:06:21.110 --> 01:06:24.100
or it should go to
the blue network.

01:06:24.100 --> 01:06:27.999
And for each of these inputs,
we can make such a choice.

01:06:27.999 --> 01:06:29.540
But we have to be
very smart about it

01:06:29.540 --> 01:06:33.040
because we need to
avoid any congestion.

01:06:33.040 --> 01:06:34.970
So the intuition
is that we're going

01:06:34.970 --> 01:06:44.170
to set up a constraint graph,
a graph that represents all

01:06:44.170 --> 01:06:47.060
the constraints that we
need to satisfy in order

01:06:47.060 --> 01:06:49.990
to achieve congestion of one.

01:06:49.990 --> 01:06:52.720
So let's do an
example so that we

01:06:52.720 --> 01:06:54.910
can figure out what's going on.

01:06:54.910 --> 01:06:56.830
Actually, let me
put it over here.

01:06:59.540 --> 01:07:01.970
So just take an
example permutation

01:07:01.970 --> 01:07:03.970
and we'll go
through this example

01:07:03.970 --> 01:07:06.280
and then see how
the proof works.

01:07:09.240 --> 01:07:12.880
So let's as an example
have pi of zero maps

01:07:12.880 --> 01:07:22.710
to one, pi of one maps to
five, pi of two goes to four,

01:07:22.710 --> 01:07:30.826
input three goes to
seven, four maps to three,

01:07:30.826 --> 01:07:37.492
five to six, six to
zero, and seven to two.

01:07:37.492 --> 01:07:39.200
So this is just an
arbitrary permutation.

01:07:44.430 --> 01:07:46.060
So what do we see?

01:07:46.060 --> 01:07:50.820
We want to make sure that, for
example, this switch is only

01:07:50.820 --> 01:07:52.460
seeing one packet.

01:07:52.460 --> 01:07:57.490
So it cannot see a packet both
coming from input zero as well

01:07:57.490 --> 01:07:59.220
as from input four.

01:07:59.220 --> 01:08:00.670
I cannot see that.

01:08:00.670 --> 01:08:02.540
I do not want that to happen.

01:08:02.540 --> 01:08:04.260
Similarly, for
this one, I do not

01:08:04.260 --> 01:08:09.550
want to see a packet coming
from one or one from five.

01:08:09.550 --> 01:08:12.780
So let me define a constraint
graph that sort of represents

01:08:12.780 --> 01:08:14.500
this.

01:08:14.500 --> 01:08:22.029
So the constraint graph
that we are interested in

01:08:22.029 --> 01:08:23.080
is defined as follows.

01:08:27.479 --> 01:08:44.359
If two packets must pass
through different networks,

01:08:44.359 --> 01:08:56.569
subnetworks-- so in our case,
the red and blue subnetwork--

01:08:56.569 --> 01:09:00.600
then we'll actually have
an edge between those two.

01:09:00.600 --> 01:09:10.470
So then, there is an
edge between them.

01:09:10.470 --> 01:09:12.950
So for this example, we're
going to set up this constraint

01:09:12.950 --> 01:09:13.450
graph.

01:09:33.600 --> 01:09:37.029
So I was just talking about
this particular switch.

01:09:37.029 --> 01:09:41.020
It cannot see one coming from
four and a packet from zero.

01:09:41.020 --> 01:09:47.140
So what he have, we have an
edge between zero and four.

01:09:47.140 --> 01:09:52.539
In the same way, we have
an edge from one to five.

01:09:52.539 --> 01:09:53.390
Why?

01:09:53.390 --> 01:09:57.735
Because a packet that comes
from input one and a packet that

01:09:57.735 --> 01:10:02.150
comes from input five cannot
both be routed through

01:10:02.150 --> 01:10:05.370
the switch because then the
switch would see two packets

01:10:05.370 --> 01:10:08.220
and then the congestion would
not be one, but two, right?

01:10:08.220 --> 01:10:11.735
So one and five also
have an edge in between.

01:10:15.220 --> 01:10:20.760
And in the same way, we have
two and six and seven and three.

01:10:20.760 --> 01:10:28.520
So two and six is this
constraint, like two and six

01:10:28.520 --> 01:10:29.680
over here.

01:10:29.680 --> 01:10:32.250
And three and seven is
the other constraint.

01:10:32.250 --> 01:10:36.470
So if I have those constraints
in place, well then,

01:10:36.470 --> 01:10:41.540
I know that the routing
that goes from level zero

01:10:41.540 --> 01:10:46.580
to level one will not
violate my congestion of one.

01:10:46.580 --> 01:10:47.910
So that's great.

01:10:47.910 --> 01:10:51.110
Then, I hope to be able to
use the induction hypothesis

01:10:51.110 --> 01:10:54.160
and I get a proper routing
within the red subnetwork

01:10:54.160 --> 01:10:57.110
and one within the blue network.

01:10:57.110 --> 01:11:00.770
And then, I need to map
all these to these outputs.

01:11:00.770 --> 01:11:03.210
So I also have constraints
on these outputs

01:11:03.210 --> 01:11:09.490
because, well, For example,
take this particular switch.

01:11:09.490 --> 01:11:13.460
It should not see a packet
coming from this particular one

01:11:13.460 --> 01:11:15.220
and one from this one.

01:11:15.220 --> 01:11:16.460
So how do I code that up?

01:11:23.950 --> 01:11:27.070
So let me first write
out what we did here

01:11:27.070 --> 01:11:32.090
and then we'll do the same
for the last level over there.

01:11:32.090 --> 01:11:34.840
So-- oh no, that's
not really necessary.

01:11:41.770 --> 01:11:43.720
So at the output
side over here, we

01:11:43.720 --> 01:11:46.710
have similar constraints
as we did over here.

01:11:46.710 --> 01:11:51.800
And in this particular
example, just as an example,

01:11:51.800 --> 01:11:55.630
suppose we look
at the packet that

01:11:55.630 --> 01:12:04.827
is destined for output zero.

01:12:04.827 --> 01:12:05.910
Well, what is this packet?

01:12:05.910 --> 01:12:10.620
Well, I know that's
pi of 6 is equal to 0,

01:12:10.620 --> 01:12:12.320
according to my example.

01:12:12.320 --> 01:12:16.530
So packet six is destined
for this particular output

01:12:16.530 --> 01:12:23.540
zero over here and goes
through this particular switch.

01:12:23.540 --> 01:12:39.890
So this packet and
also the packet

01:12:39.890 --> 01:12:46.820
for output four, which is if
you look at the mapping, pi of 2

01:12:46.820 --> 01:12:48.420
is equal to 4.

01:12:48.420 --> 01:12:51.360
So that's packet number two.

01:12:51.360 --> 01:12:55.680
Well, both of these packets
cannot pass through the same

01:12:55.680 --> 01:12:56.180
subnetwork.

01:13:06.990 --> 01:13:08.320
So why is this?

01:13:08.320 --> 01:13:11.020
So let's look at this
particular example.

01:13:11.020 --> 01:13:18.680
So output zero, well,
comes from packet six,

01:13:18.680 --> 01:13:20.315
somewhere over there.

01:13:20.315 --> 01:13:25.780
Now suppose packet six was
routed through the red network

01:13:25.780 --> 01:13:29.907
and at the same moment
also, output four--

01:13:29.907 --> 01:13:31.990
the packet that is destined
for output four, which

01:13:31.990 --> 01:13:36.890
is packet number two--
suppose packet two was also

01:13:36.890 --> 01:13:40.010
going through the red network.

01:13:40.010 --> 01:13:46.720
Well, then I notice that
both of these packets

01:13:46.720 --> 01:13:51.260
must arrive at this particular
switch in order for one

01:13:51.260 --> 01:13:54.640
to be routed to output
zero and the other one

01:13:54.640 --> 01:13:57.890
to be routed to output four.

01:13:57.890 --> 01:14:01.470
So in order to avoid congestion
in this particular switch

01:14:01.470 --> 01:14:04.890
over here, we need
to have a constraint.

01:14:04.890 --> 01:14:11.150
The constraint says that the
packet for packets two and six,

01:14:11.150 --> 01:14:14.840
that those two cannot go
through the same subnetwork.

01:14:14.840 --> 01:14:18.200
So essentially have
another edge over here--

01:14:18.200 --> 01:14:23.640
we already had the constraint
but it's just the same edge.

01:14:23.640 --> 01:14:27.940
So let's look at the other
constraints that we have.

01:14:33.770 --> 01:14:35.960
Well, let's look at
a different example.

01:14:35.960 --> 01:14:41.110
So for example, if I
look at this switch,

01:14:41.110 --> 01:14:46.110
well, if a packet
goes through here

01:14:46.110 --> 01:14:49.110
that needs to end up
at one and a packet

01:14:49.110 --> 01:14:54.500
that's goes to five, if
those two packets are routed

01:14:54.500 --> 01:14:56.730
through the same
red subnetwork, they

01:14:56.730 --> 01:15:00.910
have to end up here in order to
go to both here and to there.

01:15:00.910 --> 01:15:02.520
So we have congestion of two.

01:15:02.520 --> 01:15:04.780
So what are those packets?

01:15:04.780 --> 01:15:09.810
Well, what does pi map
to to one and five?

01:15:09.810 --> 01:15:11.280
Let's look over here.

01:15:11.280 --> 01:15:19.250
We see that pi 0 is equal
to 1 and pi 1 is equal to 5.

01:15:19.250 --> 01:15:23.810
So packets zero and one are
actually mapped to output

01:15:23.810 --> 01:15:25.710
one and five and
they should not go

01:15:25.710 --> 01:15:29.490
both through the
same subnetwork.

01:15:29.490 --> 01:15:32.132
So we have another
edge over here.

01:15:32.132 --> 01:15:36.699
And now, we can continue this
and we have five and seven.

01:15:36.699 --> 01:15:37.990
So just have a look over there.

01:15:37.990 --> 01:15:42.320
See, five and seven, they map
to the outputs two and six.

01:15:42.320 --> 01:15:44.650
Again, we have two and six.

01:15:44.650 --> 01:15:47.900
If they are both mapped to
the same network, this one,

01:15:47.900 --> 01:15:51.260
for example, then I
will have a problem.

01:15:53.870 --> 01:15:57.950
So the other edge is over here.

01:16:00.580 --> 01:16:02.070
So what did we do here?

01:16:02.070 --> 01:16:05.810
We started to write out the
constraints on this side

01:16:05.810 --> 01:16:10.580
and we wrote out the
constraints on this side.

01:16:10.580 --> 01:16:12.770
So I only looked at
the red subnetwork.

01:16:12.770 --> 01:16:13.920
That's what I realize now.

01:16:13.920 --> 01:16:16.260
I could also have looked
at the blue network.

01:16:16.260 --> 01:16:19.390
So let's do that also just
to make the picture complete.

01:16:19.390 --> 01:16:24.010
So for example, let's look
at this particular example.

01:16:24.010 --> 01:16:26.770
The packet six and
two should not both

01:16:26.770 --> 01:16:29.560
be routed through
the blue network

01:16:29.560 --> 01:16:32.150
because then they
would both have

01:16:32.150 --> 01:16:34.980
to go through this
switch, one going up

01:16:34.980 --> 01:16:40.300
to output zero and one going
to the right to output four.

01:16:40.300 --> 01:16:43.670
So in order to avoid
congestion at all costs,

01:16:43.670 --> 01:16:45.950
we have this constraint graph.

01:16:45.950 --> 01:16:48.500
So now, we come to
the key insight.

01:16:48.500 --> 01:16:53.030
And the key insight is to use
a two-coloring of this graph.

01:16:57.060 --> 01:17:07.110
So the key insight
is a two-coloring

01:17:07.110 --> 01:17:12.950
of the constraint
graph, which will

01:17:12.950 --> 01:17:19.130
lead to a best solution
for the routing problem.

01:17:19.130 --> 01:17:22.270
So let's do this.

01:17:22.270 --> 01:17:25.220
So we will color this one blue.

01:17:25.220 --> 01:17:28.210
As you can see, this
is an even cycle,

01:17:28.210 --> 01:17:37.030
blue, red, blue, red,
and blue and red.

01:17:37.030 --> 01:17:40.920
We will make this one
blue and this one red.

01:17:40.920 --> 01:17:47.170
Well, it turns out that we can
now start our routing process.

01:17:47.170 --> 01:17:52.660
So for example, actually,
I will draw a new graph

01:17:52.660 --> 01:17:53.940
to make that really clear.

01:18:03.640 --> 01:18:07.740
So I have my blue and
my red chalk over here

01:18:07.740 --> 01:18:09.215
to demonstrate what I mean.

01:18:12.520 --> 01:18:13.590
So what do I do?

01:18:13.590 --> 01:18:19.970
I have zero, one, two, three,
four, five, six, and seven.

01:18:19.970 --> 01:18:22.410
I have the switches that
correspond to those.

01:18:26.390 --> 01:18:33.660
Well, if it's colored red-- so
zero over here is colored red--

01:18:33.660 --> 01:18:35.535
I will direct it to
the red subnetwork.

01:18:35.535 --> 01:18:38.810
So where is this red subnetwork?

01:18:38.810 --> 01:18:48.800
It's really contained over
here and the blue one--

01:18:48.800 --> 01:18:53.852
so this is the red one and
the blue one is right here.

01:19:02.120 --> 01:19:09.320
And over here, we have the
outputs ranging from zero, one,

01:19:09.320 --> 01:19:14.920
two, all the way to seven.

01:19:14.920 --> 01:19:17.505
So input zero is colored red.

01:19:17.505 --> 01:19:18.380
We go straight ahead.

01:19:18.380 --> 01:19:20.550
We want to go to
the red network.

01:19:20.550 --> 01:19:23.350
Input one is colored blue.

01:19:23.350 --> 01:19:27.000
It goes, therefore,
to the blue network.

01:19:27.000 --> 01:19:29.270
So this is the only
way how to do it.

01:19:29.270 --> 01:19:31.640
Input two is colored red.

01:19:31.640 --> 01:19:33.070
Go straight ahead.

01:19:33.070 --> 01:19:35.330
Input three is also colored red.

01:19:35.330 --> 01:19:36.670
Go straight ahead.

01:19:36.670 --> 01:19:42.180
Input five-- oh, input
four is colored blue--

01:19:42.180 --> 01:19:43.280
goes to the blue network.

01:19:43.280 --> 01:19:48.620
Input five goes up
to the red network

01:19:48.620 --> 01:19:52.680
and input six goes straight
ahead to the blue network.

01:19:52.680 --> 01:19:57.280
It's colored blue and input
seven is also colored blue.

01:19:57.280 --> 01:19:59.330
Let's look at the outputs.

01:19:59.330 --> 01:20:06.445
So for example, well, let's
have a look at output zero.

01:20:09.700 --> 01:20:15.650
so output zero-- which packet
is mapped to output zero?

01:20:15.650 --> 01:20:19.570
It's packet number six.

01:20:19.570 --> 01:20:23.830
So six was mapped
into the blue network

01:20:23.830 --> 01:20:27.300
and then it needs to be
mapped to output zero.

01:20:27.300 --> 01:20:29.380
So there's only
one edge that goes

01:20:29.380 --> 01:20:33.350
from the blue network
to output zero, which

01:20:33.350 --> 01:20:36.600
is this particular one.

01:20:36.600 --> 01:20:38.800
And then somehow,
this one needs to be

01:20:38.800 --> 01:20:42.490
mapped to this one over here.

01:20:42.490 --> 01:20:44.800
Now, we can continue like this.

01:20:44.800 --> 01:20:47.860
Output one should receives
a packet from-- let's look

01:20:47.860 --> 01:20:50.710
at the permutation-- from five.

01:20:50.710 --> 01:20:55.210
No, sorry, output one--
pi of 0 is equal to 1

01:20:55.210 --> 01:20:58.770
so packet zero needs to go
to this particular output.

01:20:58.770 --> 01:21:02.260
Now, packet zero is
in the red network

01:21:02.260 --> 01:21:06.020
so there's only one edge that
goes from the red network

01:21:06.020 --> 01:21:07.590
to this output.

01:21:07.590 --> 01:21:10.710
So we need to have a
connection over here.

01:21:10.710 --> 01:21:15.450
Now, we can continue this
and note and demonstrate--

01:21:15.450 --> 01:21:17.000
and you can test
it for yourself,

01:21:17.000 --> 01:21:19.880
too-- that output
four needs to receive

01:21:19.880 --> 01:21:21.890
a packet from the red network.

01:21:21.890 --> 01:21:25.180
Actually, it should be this
particular one, which happens

01:21:25.180 --> 01:21:27.580
to be packet number two.

01:21:27.580 --> 01:21:32.790
And then, we have
this one, right?

01:21:32.790 --> 01:21:34.810
So let me just finish it.

01:21:34.810 --> 01:21:47.350
We have this and we have these
two and we have this one.

01:21:47.350 --> 01:21:53.970
We have this one and
we have this one.

01:21:53.970 --> 01:21:57.480
This one goes straight ahead.

01:21:57.480 --> 01:22:01.920
This one goes all the way up and
this one goes all the way up.

01:22:01.920 --> 01:22:03.120
So what do we see?

01:22:03.120 --> 01:22:08.750
We see that packets over
here, that these switches only

01:22:08.750 --> 01:22:10.460
see a packet once
and these ones,

01:22:10.460 --> 01:22:14.100
as well, these ones also
and these ones also.

01:22:14.100 --> 01:22:19.890
So we have directed the
packets, routed the packets

01:22:19.890 --> 01:22:24.050
to the red and the blue
subnetworks in such a way

01:22:24.050 --> 01:22:29.920
that the congestion at the last
level and at the first level

01:22:29.920 --> 01:22:31.680
is still equal to one.

01:22:31.680 --> 01:22:34.150
Now, we use our
induction hypothesis

01:22:34.150 --> 01:22:39.324
and we conclude that we
can map the route that's

01:22:39.324 --> 01:22:41.240
going to have a routing
from packets from here

01:22:41.240 --> 01:22:44.690
to here such that the congestion
within the subnetworks

01:22:44.690 --> 01:22:50.930
is only one, so within the
blue as well as in the red.

01:22:50.930 --> 01:22:55.530
So this is the insight into
how this works and I notice

01:22:55.530 --> 01:22:56.950
I am running out of time.

01:22:56.950 --> 01:23:01.460
So the formal proof we will have
to postpone until recitation,

01:23:01.460 --> 01:23:05.890
but that's actually
really a very simple thing

01:23:05.890 --> 01:23:07.540
to do that right now.

01:23:07.540 --> 01:23:11.300
So just keep this
key insight and then

01:23:11.300 --> 01:23:15.910
you can easily
prove the theorem.

01:23:15.910 --> 01:23:18.820
But this is the real insight.

01:23:18.820 --> 01:23:20.670
Thank you.

