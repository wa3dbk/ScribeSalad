WEBVTT
Kind: captions
Language: en

00:00:00.780 --> 00:00:03.350
Good afternoon.

00:00:03.350 --> 00:00:06.300
So we're going to continue
our discussion about atomicity

00:00:06.302 --> 00:00:07.510
and how to achieve atomicity.

00:00:07.510 --> 00:00:09.030
And today the focus
is going to be

00:00:09.030 --> 00:00:11.860
on implementing this idea
called recoverability,

00:00:11.860 --> 00:00:15.440
which we just described
and defined the last time.

00:00:15.440 --> 00:00:18.710
So if you recall from
last time, the idea

00:00:18.710 --> 00:00:23.550
is that when you have modules
that interact with one another,

00:00:23.550 --> 00:00:27.590
and in this example M1 calls
M2, and M2 fails somewhere

00:00:27.590 --> 00:00:30.800
in the middle of this
invocation and it recovers,

00:00:30.800 --> 00:00:32.670
the goal here is
to try to make sure

00:00:32.670 --> 00:00:36.420
that the invoker of this
module, in this case M1,

00:00:36.420 --> 00:00:38.950
or all subsequent
invokers of M1,

00:00:38.950 --> 00:00:41.260
don't see any
partial results that

00:00:41.260 --> 00:00:45.670
were computed during this
execution when M2 failed.

00:00:45.670 --> 00:00:49.320
And this was the idea that
we called recoverability.

00:00:49.320 --> 00:00:50.900
And the definition
of recoverability

00:00:50.900 --> 00:00:54.100
was that an action,
which is made up

00:00:54.100 --> 00:00:56.340
of a composite
sequence of steps is

00:00:56.340 --> 00:00:59.380
recoverable from the point
of view of its invoker,

00:00:59.380 --> 00:01:03.480
if it looks to the invoker and
to all subsequent invokers as

00:01:03.480 --> 00:01:05.900
if this action either
completely occurred,

00:01:05.900 --> 00:01:08.770
or if it didn't completely
occur and aborted, it

00:01:08.770 --> 00:01:12.360
aborted in such a way that all
partial effects of that action

00:01:12.360 --> 00:01:14.770
were undone or backed out.

00:01:14.770 --> 00:01:16.270
So in other words,
recoverability is

00:01:16.270 --> 00:01:19.110
this idea that you
either do it all,

00:01:19.110 --> 00:01:21.730
either complete the action,
or do none of the action.

00:01:21.730 --> 00:01:23.560
But the effects
are as if you were

00:01:23.560 --> 00:01:26.850
able to back out of the action.

00:01:26.850 --> 00:01:29.510
And we use this
idea to then talk

00:01:29.510 --> 00:01:33.800
about a particular special
case of recoverability

00:01:33.800 --> 00:01:36.720
to implement a
recoverable sector, which

00:01:36.720 --> 00:01:39.680
is a single sector
of a disk where

00:01:39.680 --> 00:01:43.820
what we were able to do was to
ensure that everybody reading,

00:01:43.820 --> 00:01:46.710
we defined a put procedure
and a get procedure.

00:01:46.710 --> 00:01:48.820
So, readers would
invoke get.

00:01:48.820 --> 00:01:51.750
And we ensure that
everybody doing a get

00:01:51.750 --> 00:01:54.470
would never see the
partial results of any put.

00:01:54.470 --> 00:01:57.020
So, if a failure were to
happen in the middle of a put,

00:01:57.020 --> 00:02:01.060
people doing a get wouldn't
see these partial results.

00:02:01.060 --> 00:02:05.000
And, the main idea here
was to actually maintain

00:02:05.000 --> 00:02:08.509
what is more generally known as
a shadow version, or a shadow

00:02:08.509 --> 00:02:11.690
copy, or a shadow
object of the data,

00:02:11.690 --> 00:02:14.620
and we maintained two
versions of the data

00:02:14.620 --> 00:02:16.520
that we call D0 and D1.

00:02:16.520 --> 00:02:21.550
And, we maintain
a sector that we

00:02:21.550 --> 00:02:24.410
call the chooser sector to
choose between the two shadows.

00:02:24.410 --> 00:02:29.250
And, what we were able to argue
was that this chooser always

00:02:29.250 --> 00:02:32.090
points to the version that
you want people to get from

00:02:32.090 --> 00:02:35.510
to read from, and so
when someone does a put,

00:02:35.510 --> 00:02:38.000
the idea is first to write
to the version that's

00:02:38.000 --> 00:02:39.540
not currently being read from.

00:02:39.540 --> 00:02:40.800
So the chooser points to zero.

00:02:40.800 --> 00:02:45.927
Then the putter would put
data, write data into one.

00:02:45.927 --> 00:02:48.260
And if the failure happened
in the middle of that write,

00:02:48.260 --> 00:02:50.010
there's no problem
because people who read

00:02:50.010 --> 00:02:52.050
would still read from zero.

00:02:52.050 --> 00:02:53.630
And we reduce this
case of proving

00:02:53.630 --> 00:02:55.430
this algorithm
correct to the case

00:02:55.430 --> 00:02:58.201
when a failure happened in the
middle of writing the chooser

00:02:58.201 --> 00:02:58.700
sector.

00:02:58.700 --> 00:03:01.820
And we were able to argue
that as long as people,

00:03:01.820 --> 00:03:04.070
if a failure happened in
the middle of writing here,

00:03:04.070 --> 00:03:05.910
either of these
versions is correct

00:03:05.910 --> 00:03:07.730
because a failure
by definition didn't

00:03:07.730 --> 00:03:10.429
happen in the middle of writing
either of these two sectors.

00:03:10.429 --> 00:03:12.220
And therefore you could
pick either of them

00:03:12.220 --> 00:03:15.250
and read from it.

00:03:15.250 --> 00:03:17.740
And during this
process, we came up

00:03:17.740 --> 00:03:20.630
with this notion which
we're going to generalize

00:03:20.630 --> 00:03:21.990
today called a commit point.

00:03:27.220 --> 00:03:30.030
The commit point is the point
at which for any action,

00:03:30.030 --> 00:03:33.160
the results are visible
to subsequent actions.

00:03:33.160 --> 00:03:35.800
And if a failure happens
before the commit point,

00:03:35.800 --> 00:03:37.650
then the idea is,
in general, you

00:03:37.650 --> 00:03:41.190
would not want people not to
see the partial results that

00:03:41.190 --> 00:03:44.335
might have accumulated
before the failure occurred.

00:03:44.335 --> 00:03:46.210
And in this particular
case, the commit point

00:03:46.210 --> 00:03:49.770
is when the chooser sector gets
written to the current version

00:03:49.770 --> 00:03:50.420
of the data.

00:03:50.420 --> 00:03:54.050
And that call to writing
the chooser sector returns.

00:03:54.050 --> 00:03:58.250
And if it returns, then you
know that people doing a get

00:03:58.250 --> 00:04:00.360
will get from the version
that just got written.

00:04:00.360 --> 00:04:02.590
So, in the implementation
of recoverable put,

00:04:02.590 --> 00:04:05.960
the commit point was
when this call returned.

00:04:08.940 --> 00:04:13.750
So now, the question for today
is how we deal with larger

00:04:13.750 --> 00:04:16.899
actions --

00:04:20.200 --> 00:04:23.140
-- because this is a plan that
works pretty well for single

00:04:23.140 --> 00:04:24.660
sector puts and gets.

00:04:24.660 --> 00:04:27.680
So, we were able to make
individual sector reads

00:04:27.680 --> 00:04:29.450
and writes recoverable.

00:04:29.450 --> 00:04:32.760
But if you think about any
serious application or even any

00:04:32.760 --> 00:04:35.600
toy application, in most
cases you end up having more

00:04:35.600 --> 00:04:38.700
data than what fits
into one single sector.

00:04:38.700 --> 00:04:41.060
And, you might have
things touching data all

00:04:41.060 --> 00:04:41.920
over the place.

00:04:44.750 --> 00:04:50.360
And, our approach to doing this
is to actually first define

00:04:50.360 --> 00:04:53.120
what a programmer
must do, what somebody

00:04:53.120 --> 00:04:56.740
wishing to write a program
that is a recoverable action

00:04:56.740 --> 00:04:57.480
must do.

00:04:57.480 --> 00:04:59.859
And then we're going to
implement that underneath

00:04:59.859 --> 00:05:01.400
in a system so the
programmer doesn't

00:05:01.400 --> 00:05:04.760
have to worry about
implementing recoverability.

00:05:04.760 --> 00:05:07.940
So the idea here is
for the programmer

00:05:07.940 --> 00:05:11.410
of a recoverable action, to
start writing that action using

00:05:11.410 --> 00:05:15.660
a system call, a call that they
call begin recoverable action,

00:05:15.660 --> 00:05:19.230
and then discipline
herself or himself

00:05:19.230 --> 00:05:21.920
to write some software which
has a small number of rules

00:05:21.920 --> 00:05:25.120
as to what can go in here.

00:05:25.120 --> 00:05:27.190
And then, explicitly,
when they want

00:05:27.190 --> 00:05:29.680
to commit that
recoverable action,

00:05:29.680 --> 00:05:32.100
make its results visible
to subsequent actions,

00:05:32.100 --> 00:05:33.060
invoke commit.

00:05:36.870 --> 00:05:39.570
And then, they are allowed
to do a little bit more work,

00:05:39.570 --> 00:05:41.090
or a lot of work here.

00:05:41.090 --> 00:05:44.260
But, there's very
strict restrictions

00:05:44.260 --> 00:05:46.370
on what they can
do after a commit.

00:05:46.370 --> 00:05:52.289
And then, they can end using
end recoverable action.

00:05:52.289 --> 00:05:53.830
And this phase here
before the commit

00:05:53.830 --> 00:05:55.121
is called the pre-commit phase.

00:05:55.121 --> 00:05:56.680
This is the post-commit phase.

00:05:56.680 --> 00:05:59.200
And the idea here is
if a failure occurred

00:05:59.200 --> 00:06:04.730
here or an abort occurred before
the commit and this action

00:06:04.730 --> 00:06:06.920
was made to abort,
then the system

00:06:06.920 --> 00:06:09.980
must restore the state
of all of the variables,

00:06:09.980 --> 00:06:13.710
and all of the data that was
touched here to the same state

00:06:13.710 --> 00:06:15.770
before this action
even got invoked.

00:06:15.770 --> 00:06:17.270
OK, it's as if not
of this happened.

00:06:17.270 --> 00:06:20.970
So this is the not at all
part of this definition

00:06:20.970 --> 00:06:22.391
of recoverability.

00:06:22.391 --> 00:06:24.390
Once you reach this point
of the commit returns,

00:06:24.390 --> 00:06:26.056
the only thing you're
allowed to do here

00:06:26.056 --> 00:06:28.046
are things that cause
you to complete.

00:06:28.046 --> 00:06:29.420
You're not allowed
to abort here.

00:06:29.420 --> 00:06:30.920
You're not allowed
to back out here.

00:06:30.920 --> 00:06:33.420
So once you reach
the point, it means

00:06:33.420 --> 00:06:37.930
you're in the do it all part
of do it all or none at all.

00:06:37.930 --> 00:06:41.110
So you have to complete
all the way to the end.

00:06:41.110 --> 00:06:43.100
And what this really
means is that all

00:06:43.100 --> 00:06:45.342
of the data that you
want to manipulate,

00:06:45.342 --> 00:06:47.550
and all of the resources
that you want to accumulate,

00:06:47.550 --> 00:06:50.049
and we'll look at locks as a
resource that you would like to

00:06:50.049 --> 00:06:52.710
accumulate in order to
enforce isolation, which

00:06:52.710 --> 00:06:54.590
is a topic for
next time, all that

00:06:54.590 --> 00:06:57.050
has to happen here so that
once you reach this point

00:06:57.050 --> 00:06:59.540
and it ends, then even if
a failure occurs when it

00:06:59.540 --> 00:07:01.980
restarts, you just
have to crunch through

00:07:01.980 --> 00:07:03.900
and finish what
was going on here.

00:07:03.900 --> 00:07:04.970
And that can just happen.

00:07:04.970 --> 00:07:06.966
There's nothing to
acquire, no resources

00:07:06.966 --> 00:07:08.840
to get all of the data
variables have already

00:07:08.840 --> 00:07:13.500
been put in their correct
situation in the correct state.

00:07:13.500 --> 00:07:14.960
So the interesting
part really is

00:07:14.960 --> 00:07:17.260
what happens between the
begin recoverable action

00:07:17.260 --> 00:07:19.050
and until the commit finishes.

00:07:19.050 --> 00:07:22.610
And that's really what
we're going to focus on.

00:07:22.610 --> 00:07:25.370
Now in addition to commit,
there is another call

00:07:25.370 --> 00:07:27.950
that we have to explicitly
think about, and that's abort.

00:07:31.356 --> 00:07:32.980
And there's two or
three different ways

00:07:32.980 --> 00:07:34.700
in which abort may be invoked.

00:07:34.700 --> 00:07:38.590
The first is a program that
might herself or himself have

00:07:38.590 --> 00:07:40.030
abort in their code.

00:07:40.030 --> 00:07:42.360
For example, in that bank
transfer application,

00:07:42.360 --> 00:07:45.030
if you discover that your
savings account doesn't

00:07:45.030 --> 00:07:48.140
have enough funds to cover
a transfer, you read it,

00:07:48.140 --> 00:07:49.770
and then you maybe
write something,

00:07:49.770 --> 00:07:52.329
and then you discover that you
don't have the funds to cover

00:07:52.329 --> 00:07:52.870
the transfer.

00:07:52.870 --> 00:07:54.380
You might just abort.

00:07:54.380 --> 00:07:57.460
And the semantics of
abort are that once abort

00:07:57.460 --> 00:07:59.420
is called by the
programmer, they

00:07:59.420 --> 00:08:02.720
can be guaranteed that when
the next person invokes

00:08:02.720 --> 00:08:07.040
a recoverable action that
involves the same data items,

00:08:07.040 --> 00:08:11.470
those readers will see the same
state as if this action never

00:08:11.470 --> 00:08:12.431
started.

00:08:12.431 --> 00:08:14.180
So what this means is
that the system must

00:08:14.180 --> 00:08:16.510
have a plan of undoing
and backing out

00:08:16.510 --> 00:08:18.240
of any changes that
might have occurred

00:08:18.240 --> 00:08:21.162
before this abort is called.

00:08:21.162 --> 00:08:22.620
Another reason an
abort might occur

00:08:22.620 --> 00:08:26.650
is that you're in a, for
example, database application,

00:08:26.650 --> 00:08:28.490
and you're booking
all sorts of things

00:08:28.490 --> 00:08:32.240
like plane tickets, and
air tickets, and hotel

00:08:32.240 --> 00:08:33.640
reservations, and so on.

00:08:33.640 --> 00:08:35.970
And you book a few
of them and then

00:08:35.970 --> 00:08:38.808
you discover you can't get
one of the reservations

00:08:38.808 --> 00:08:39.490
that you want.

00:08:39.490 --> 00:08:42.480
You might as a user might
abort the whole transaction.

00:08:42.480 --> 00:08:45.970
And that causes all the
individual things that

00:08:45.970 --> 00:08:48.999
are in partial state to abort.

00:08:48.999 --> 00:08:50.540
Another reason why
abort might happen

00:08:50.540 --> 00:08:52.590
is that, and we'll see
this the next time when

00:08:52.590 --> 00:08:55.440
we talk about locking,
anytime you have locks,

00:08:55.440 --> 00:08:58.250
we already saw that
anytime you have locks you

00:08:58.250 --> 00:09:00.120
have the danger of deadlock.

00:09:00.120 --> 00:09:02.080
In one way in which
the system implementing

00:09:02.080 --> 00:09:06.780
these atomic actions, both for
isolation in particular, deals

00:09:06.780 --> 00:09:09.950
with deadlocks is when
two or more actions are

00:09:09.950 --> 00:09:12.940
waiting for each other, waiting
on locks that the others hold,

00:09:12.940 --> 00:09:15.430
you just abort one of them,
or abort as many of them

00:09:15.430 --> 00:09:17.160
as needed for
progress to happen.

00:09:17.160 --> 00:09:19.130
So the system might
unilaterally decide

00:09:19.130 --> 00:09:20.404
to abort certain actions.

00:09:20.404 --> 00:09:22.820
And, what that means is that
the systems' abort had better

00:09:22.820 --> 00:09:25.410
have a plan to undo all
partial changes that

00:09:25.410 --> 00:09:29.360
might have occurred before
it returns from abort.

00:09:32.090 --> 00:09:34.274
OK, so that's the general model.

00:09:34.274 --> 00:09:35.690
So what we're going
to do today is

00:09:35.690 --> 00:09:41.360
to understand what happens
when data variables are written

00:09:41.360 --> 00:09:44.270
inside one of these
recoverable actions:

00:09:44.270 --> 00:09:47.070
how come it's implemented,
and how abort is implemented.

00:09:47.070 --> 00:09:48.160
And that's the plan.

00:09:48.160 --> 00:09:49.636
And, once we do
that, we will have

00:09:49.636 --> 00:09:50.760
implemented recoverability.

00:09:50.760 --> 00:09:56.420
So we're going to study two
solutions to this problem.

00:09:56.420 --> 00:10:05.390
And the first solution uses an
idea called version histories.

00:10:05.390 --> 00:10:07.940
And version histories
really build on an idea

00:10:07.940 --> 00:10:11.970
that we did see last
time when we talked

00:10:11.970 --> 00:10:14.810
about recoverable sector,
which is this rule that we call

00:10:14.810 --> 00:10:17.250
the golden rule of
recoverability, which

00:10:17.250 --> 00:10:20.340
says never modify the only
copy because if you modify

00:10:20.340 --> 00:10:23.002
the only copy of something and
a failure occurs, then you don't

00:10:23.002 --> 00:10:24.460
really have a way
of backing it out

00:10:24.460 --> 00:10:27.920
because you don't know what
the original value was.

00:10:27.920 --> 00:10:29.560
Version histories
generalize the idea

00:10:29.560 --> 00:10:32.880
to say, never modify anything.

00:10:32.880 --> 00:10:35.140
So the idea is anytime you
want to write a variable,

00:10:35.140 --> 00:10:37.090
you don't actually
overwrite anything.

00:10:37.090 --> 00:10:38.870
You create another
version of the variable

00:10:38.870 --> 00:10:41.860
and somehow arrange
for the set of pointers

00:10:41.860 --> 00:10:44.740
that, for a variable
to point to all

00:10:44.740 --> 00:10:47.130
of the versions of
any given variable.

00:10:47.130 --> 00:10:50.480
And to understand that, we need
to understand the difference

00:10:50.480 --> 00:10:54.220
between conventional storage,
like a conventional variable

00:10:54.220 --> 00:10:59.380
that is also called a cell
store or a cell storage item,

00:10:59.380 --> 00:11:03.400
and a variable that allows you
to implement versions which

00:11:03.420 --> 00:11:08.740
we're going to call
a journal based storage.

00:11:08.740 --> 00:11:10.740
So, cell storage is
traditional storage.

00:11:10.750 --> 00:11:13.080
So if you have a variable,
X, that's cell storage

00:11:13.080 --> 00:11:18.250
and you set X to some value,
V, what ends up happening

00:11:18.250 --> 00:11:22.860
is that the cell that
contains X is you

00:11:22.860 --> 00:11:25.101
write the value, V, into X.

00:11:25.101 --> 00:11:27.600
In other words, you overwrite
whatever there is you know,

00:11:27.600 --> 00:11:28.957
and replace it with V.

00:11:28.957 --> 00:11:31.540
And, this overwriting really is
what causes the problem if you

00:11:31.540 --> 00:11:35.740
don't have another copy of this
variable somehow maintained,

00:11:35.740 --> 00:11:38.590
overwriting means that this
rule of recoverabilities

00:11:38.590 --> 00:11:41.570
is being violated.

00:11:41.570 --> 00:11:45.260
We're going to use the word
install for these writes.

00:11:45.260 --> 00:11:48.500
So we'll be installing
items into cell stores.

00:11:48.500 --> 00:11:52.370
So what that means is assigning
a value to a cell store

00:11:52.370 --> 00:11:52.870
variable.

00:11:56.730 --> 00:11:59.520
And the problem is this gets
in the way of the golden rule.

00:11:59.520 --> 00:12:06.620
So what were going to do is
use these cell storage items

00:12:06.620 --> 00:12:09.170
that we know how to build
that's the memory abstraction

00:12:09.170 --> 00:12:12.060
to build an expanded
version called a journal

00:12:12.060 --> 00:12:15.217
storage of generalized
storage in which nothing

00:12:15.217 --> 00:12:16.050
is ever overwritten.

00:12:18.615 --> 00:12:19.990
The way this works
is that if you

00:12:19.990 --> 00:12:26.960
have X, the very first time
you set X to some value,

00:12:26.960 --> 00:12:30.880
you end up creating a data
structure in cell storage

00:12:30.880 --> 00:12:33.550
that looks like this.

00:12:33.550 --> 00:12:35.480
You have a value of V1.

00:12:35.480 --> 00:12:38.830
And you also keep track of the
identifier of the action that

00:12:38.830 --> 00:12:39.460
created that.

00:12:39.460 --> 00:12:40.520
And, that'll turn
out to be useful

00:12:40.520 --> 00:12:42.810
for us to know the identifiers
of the actions that

00:12:42.810 --> 00:12:46.044
created any given variable.

00:12:46.044 --> 00:12:47.400
And how you get
these identifiers?

00:12:47.400 --> 00:12:52.040
When begin_ra is called,
it returns an ID, OK,

00:12:52.040 --> 00:12:53.160
and the system knows that.

00:12:53.170 --> 00:12:57.630
And this ID is available
to the program as well.

00:12:57.630 --> 00:13:00.880
Then the next version, if
X gets set by any action

00:13:00.880 --> 00:13:05.260
to a different value, what you
do is you created that as V2.

00:13:05.260 --> 00:13:08.740
And, you keep track of the
identifier that maintains that.

00:13:08.740 --> 00:13:10.939
And then you got V3,
and so on, all the way.

00:13:10.940 --> 00:13:12.730
And the current version,
the latest version

00:13:12.730 --> 00:13:16.920
might be Vn that
was written by idn.

00:13:16.920 --> 00:13:18.570
Now if the same
action repeatedly

00:13:18.570 --> 00:13:21.160
writes the same variable,
you just create new versions.

00:13:21.160 --> 00:13:23.440
So it isn't like there's
one version per action.

00:13:23.440 --> 00:13:25.640
It's just that there's
one version every time

00:13:25.640 --> 00:13:26.580
you write something.

00:13:26.580 --> 00:13:30.182
So literally, nothing
is overwritten.

00:13:30.182 --> 00:13:30.890
And so, that's X.

00:13:30.890 --> 00:13:35.580
So, X itself points to the
head version, the very latest

00:13:35.580 --> 00:13:36.700
version that was written.

00:13:36.700 --> 00:13:38.130
And, you could
imagine that there

00:13:38.130 --> 00:13:42.075
are these pointers pulling
you back like a link list.

00:13:42.075 --> 00:13:44.450
But the nice thing about it
is this is the journal store.

00:13:44.450 --> 00:13:46.550
So, X itself is
this whole thing.

00:13:50.580 --> 00:13:53.570
And, we'll implement two
calls that when you have,

00:13:53.570 --> 00:13:56.130
this is basically a
memory abstraction.

00:13:56.130 --> 00:13:59.020
So, you need to read
and you need to write.

00:13:59.020 --> 00:14:01.410
So, for write, we're
going to come up

00:14:01.410 --> 00:14:06.200
with a call called write
journal, which in the notes

00:14:06.200 --> 00:14:08.740
I think has a slightly
different name.

00:14:08.740 --> 00:14:10.640
I think they call
it write new value.

00:14:10.640 --> 00:14:14.410
But write journal makes it clear
that it's for journal store.

00:14:14.410 --> 00:14:16.280
And, this is easy.

00:14:16.280 --> 00:14:18.650
It's some data item, X.

00:14:18.650 --> 00:14:20.470
It's some value, V.

00:14:20.470 --> 00:14:24.620
And, it's the ID of the
action that's doing the write.

00:14:24.620 --> 00:14:26.080
And this is very
easy to implement.

00:14:26.080 --> 00:14:28.110
All you do is you
create a new version.

00:14:28.110 --> 00:14:32.250
And then you take the current
thing that X is pointing to,

00:14:32.250 --> 00:14:35.950
and make the current version's
next pointer point to that.

00:14:35.950 --> 00:14:38.210
And then you make X
point to the new version.

00:14:38.210 --> 00:14:42.080
So, it's just a
link list thing, OK?

00:14:42.080 --> 00:14:45.000
And, in addition
to write journal,

00:14:45.000 --> 00:14:48.750
we obviously need to
implement read journal.

00:14:55.430 --> 00:14:59.270
And read journal is going to
take a data item that you wish

00:14:59.270 --> 00:15:02.130
to read, X, and for reasons
that will become clearer

00:15:02.130 --> 00:15:04.810
in a minute, it also takes
the ID of the action that

00:15:04.810 --> 00:15:08.220
wants to do the read, OK?

00:15:08.220 --> 00:15:09.980
So if you want to
read something,

00:15:09.980 --> 00:15:13.250
the idea is going to be the
following: the idea is going

00:15:13.250 --> 00:15:17.340
to be that some of these
actions are actions;

00:15:17.340 --> 00:15:20.550
some of these versions are
going to have been written

00:15:20.550 --> 00:15:23.330
by actions that were committed.

00:15:23.330 --> 00:15:25.540
OK, and some of
these actions were

00:15:25.540 --> 00:15:27.570
going to have been
written by actions

00:15:27.570 --> 00:15:32.080
that started writing things and
then maybe failed or aborted.

00:15:32.080 --> 00:15:34.887
So they never committed.

00:15:34.887 --> 00:15:36.470
Now, clearly when
you do read journal,

00:15:36.470 --> 00:15:38.761
you don't want to see the
results of those actions that

00:15:38.761 --> 00:15:42.050
were never committed
because what you want

00:15:42.050 --> 00:15:44.280
to see from the definition
that we laid out

00:15:44.280 --> 00:15:46.370
are once you reach
the commit point,

00:15:46.370 --> 00:15:48.130
you want to see the
change is visible.

00:15:48.130 --> 00:15:50.832
Before that, you don't
want anything visible.

00:15:50.832 --> 00:15:52.540
So as long as you can
keep track of which

00:15:52.540 --> 00:15:55.270
of these actions committed, and
which of these didn't commit,

00:15:55.270 --> 00:15:58.480
you can implement read journal
by starting at the most

00:15:58.480 --> 00:16:01.660
recent version,
and going backwards

00:16:01.660 --> 00:16:05.340
until you find the first
version that corresponds

00:16:05.340 --> 00:16:10.400
to a value that was written by
an action that was committed.

00:16:10.400 --> 00:16:13.670
So what you need to do is start
from here and look at IDN.

00:16:13.670 --> 00:16:17.200
If IDN, you need to maintain
another table that tells you

00:16:17.200 --> 00:16:19.664
whether IDN committed or not.

00:16:19.664 --> 00:16:21.330
If it committed, then
return that value.

00:16:21.330 --> 00:16:23.140
If not, go back one.

00:16:23.140 --> 00:16:25.850
And, keep going until you
find the most recent version

00:16:25.850 --> 00:16:29.700
that was written by
a committed action.

00:16:29.700 --> 00:16:31.880
If you do that, then
read journal clearly

00:16:31.880 --> 00:16:35.220
returns to you what
you would want,

00:16:35.220 --> 00:16:36.860
which is the value
that was written

00:16:36.860 --> 00:16:39.832
by the last committed action.

00:16:39.832 --> 00:16:41.540
The only other tweak
that you want to do,

00:16:41.540 --> 00:16:44.040
and the reason why ID is
passed as an argument read

00:16:44.040 --> 00:16:46.629
journal is if the current
action has already written,

00:16:46.629 --> 00:16:48.420
so let's say you are
implementing an action

00:16:48.420 --> 00:16:51.750
and you set the
value of X to 17,

00:16:51.750 --> 00:16:53.750
then when you read
the value of X,

00:16:53.750 --> 00:16:55.369
you would want the
value that you set.

00:16:55.369 --> 00:16:57.660
I mean, you wouldn't want
the previous committed action

00:16:57.660 --> 00:17:00.800
that's one way of
defining read journal.

00:17:00.800 --> 00:17:05.180
So as you go from the most
recent version to the oldest

00:17:05.180 --> 00:17:08.510
version, you either look see
whether the value that you

00:17:08.510 --> 00:17:11.569
are reading now is a value that
you set, your own action set.

00:17:11.569 --> 00:17:13.079
And if it was, just return that.

00:17:13.079 --> 00:17:14.912
And then, it'll return
to you the last value

00:17:14.912 --> 00:17:16.592
that this action set.

00:17:16.592 --> 00:17:18.050
Otherwise, you keep
going until you

00:17:18.050 --> 00:17:22.300
find the value set by the
most recent committed action.

00:17:22.300 --> 00:17:25.550
And since we aren't dealing here
with concurrent actions at all,

00:17:25.550 --> 00:17:31.056
right, we've already said last
time that, until next Monday,

00:17:31.056 --> 00:17:33.430
we're only going to be dealing
with one action at a time.

00:17:33.430 --> 00:17:35.030
There's no concurrent actions.

00:17:35.030 --> 00:17:37.856
Clearly, this algorithm
will be correct.

00:17:37.856 --> 00:17:39.480
You start from the
most recent version,

00:17:39.480 --> 00:17:42.530
keep going until you find the
first version that was either

00:17:42.530 --> 00:17:44.740
done by this action
that's doing the read,

00:17:44.740 --> 00:17:49.820
or the first version that
was written by an action that

00:17:49.820 --> 00:17:51.720
committed.

00:17:51.720 --> 00:17:56.380
So, clearly what this means
is that you need a table

00:17:56.380 --> 00:17:59.000
that you have to maintain
that stores the status

00:17:59.010 --> 00:18:00.140
of these different actions.

00:18:00.140 --> 00:18:02.410
It needs to store which
actions committed,

00:18:02.410 --> 00:18:04.355
and which actions didn't commit.

00:18:04.355 --> 00:18:06.730
And that's going to be done
using a data structure called

00:18:06.730 --> 00:18:07.730
the commit record table.

00:18:12.000 --> 00:18:13.980
And this is a very simple table.

00:18:13.980 --> 00:18:16.990
It just has ID1,
ID2, all the way down

00:18:16.990 --> 00:18:18.300
to whatever ID's you have.

00:18:18.300 --> 00:18:22.130
Every time somebody calls begin
RA, you return them an ID,

00:18:22.130 --> 00:18:25.222
and then you create
this table that as soon

00:18:25.222 --> 00:18:27.680
as they create this action,
you set their state to pending,

00:18:27.680 --> 00:18:31.090
which I'll call P, OK?

00:18:31.090 --> 00:18:35.190
And, any time an action
commits, you replace this P

00:18:35.190 --> 00:18:38.160
with a C, which is
a commit record.

00:18:38.160 --> 00:18:41.960
OK, and once it's replaced
with a C for an action,

00:18:41.960 --> 00:18:47.130
this item is called the
commit record for an action.

00:18:47.130 --> 00:18:49.650
So now, when you want
to do read journal

00:18:49.650 --> 00:18:52.442
and you're looking to see
whether for any given action,

00:18:52.442 --> 00:18:54.400
things were committed,
the corresponding action

00:18:54.400 --> 00:18:56.460
is committed or not,
you look at this.

00:18:56.460 --> 00:18:57.360
You see its IDN.

00:18:57.360 --> 00:19:00.300
You look for IDN in this table,
C, if it's committed or not.

00:19:00.300 --> 00:19:02.980
If it's not committed, then
you go to the previous version

00:19:02.980 --> 00:19:04.310
and you do the same thing.

00:19:04.310 --> 00:19:10.400
If it's committed,
then you return it.

00:19:10.400 --> 00:19:12.910
Now, it's not actually clear
why you need this pending thing

00:19:12.910 --> 00:19:13.410
here.

00:19:13.410 --> 00:19:16.740
But it'll turn out that you will
require the pending thing when

00:19:16.740 --> 00:19:18.350
you deal with
isolation on Monday.

00:19:18.350 --> 00:19:20.530
So for now, you don't have
to worry about the fact

00:19:20.530 --> 00:19:24.350
that these pending
things are there, OK?

00:19:24.350 --> 00:19:28.990
Now, suppose an action
starts, and then it aborts.

00:19:28.990 --> 00:19:31.780
So I mentioned here that when
an action starts and it aborts,

00:19:31.780 --> 00:19:34.890
the system has to do some kind
of undoing of data in order

00:19:34.890 --> 00:19:36.560
for abort to be
correctly implemented.

00:19:36.560 --> 00:19:38.910
So, the state of the system's
restored to the state

00:19:38.910 --> 00:19:42.250
before the action even started.

00:19:42.250 --> 00:19:44.875
The nice thing about this way of
implementing version histories

00:19:44.875 --> 00:19:46.291
and read journal
is you don't have

00:19:46.291 --> 00:19:47.440
to do anything on an abort.

00:19:50.080 --> 00:19:53.250
If the application or
the system called abort,

00:19:53.250 --> 00:19:56.900
nothing has to be done because
read journal basically is just

00:19:56.900 --> 00:19:59.260
going scanning this
backward, looking

00:19:59.260 --> 00:20:01.770
for whether the version
was written by itself,

00:20:01.770 --> 00:20:05.080
that same action or looking for
whether the version was written

00:20:05.080 --> 00:20:06.750
by a committed action.

00:20:06.750 --> 00:20:09.350
So as long as you can
find for any given ID

00:20:09.350 --> 00:20:12.960
whether it was committed or
not, that's all you need.

00:20:12.960 --> 00:20:16.880
OK, but just for completeness,
and this will become useful

00:20:16.880 --> 00:20:22.960
the next time, all we'll do when
abort is called on an action,

00:20:22.960 --> 00:20:25.760
so abort takes the ID of
the action as an argument,

00:20:25.760 --> 00:20:29.940
all we'll do is we'll
replace, if ID7 aborts,

00:20:29.940 --> 00:20:32.340
we'll just replace the pending.

00:20:32.340 --> 00:20:35.510
We'll replace that
with an abort, OK?

00:20:35.510 --> 00:20:38.440
So, this commit
record table contains

00:20:38.440 --> 00:20:40.100
the status of the actions.

00:20:40.100 --> 00:20:44.990
And that status could either be
committed, pending, or aborted.

00:20:44.990 --> 00:20:46.270
When it starts, it's pending.

00:20:46.270 --> 00:20:51.350
And then it's pending as long as
either it aborts, in which case

00:20:51.350 --> 00:20:54.010
it aborted, or it's committed.

00:20:54.010 --> 00:20:56.832
Now, if it just fails and you
don't do anything about it,

00:20:56.832 --> 00:20:58.540
and there's no abort
call, it'll continue

00:20:58.540 --> 00:21:00.750
to remain in the pending state.

00:21:00.750 --> 00:21:02.870
But that's OK because
we're never really going

00:21:02.870 --> 00:21:04.896
to read the value
of anything that's

00:21:04.896 --> 00:21:07.270
the in the pending state that
was set by an action that's

00:21:07.270 --> 00:21:08.145
in the pending state.

00:21:12.210 --> 00:21:13.105
So is this clear?

00:21:16.280 --> 00:21:18.420
OK, this approach is
actually quite reasonable

00:21:18.420 --> 00:21:22.980
except that it has
a few problems.

00:21:22.980 --> 00:21:25.720
The first problem
it has is, well, it

00:21:25.720 --> 00:21:26.910
has two related problems.

00:21:26.910 --> 00:21:29.370
And that's the first class
of problems that it has is

00:21:29.370 --> 00:21:31.210
that although it looks
like we've really

00:21:31.210 --> 00:21:35.882
nailed this problem of achieving
recoverable storage using

00:21:35.882 --> 00:21:37.340
this journal storage
idea, building

00:21:37.340 --> 00:21:40.340
general recoverable actions so
that for any variable that's

00:21:40.340 --> 00:21:45.550
read inside here or read
inside a recoverable action,

00:21:45.550 --> 00:21:47.970
you use this general
storage idea.

00:21:47.970 --> 00:21:50.470
It's not quite correct
because you have to ask,

00:21:50.470 --> 00:21:55.840
what happens if the system
fails while the system is

00:21:55.840 --> 00:21:57.610
writing this commit record?

00:21:57.610 --> 00:21:59.260
So, the application
calls commit.

00:21:59.260 --> 00:22:01.910
The system's starting to
write this commit record

00:22:01.910 --> 00:22:04.620
and it fails.

00:22:04.620 --> 00:22:06.350
Or you might more
generally ask, what

00:22:06.350 --> 00:22:11.300
happens if I create this new
version in write journal,

00:22:11.300 --> 00:22:14.280
and as I'm creating a new
version of a variable,

00:22:14.280 --> 00:22:15.180
the system crashes.

00:22:15.180 --> 00:22:17.580
So some garbage
got written here.

00:22:17.580 --> 00:22:21.360
Or more likely, some garbage
got written not in here

00:22:21.360 --> 00:22:23.791
but as I was changing
this pointer for X

00:22:23.791 --> 00:22:25.290
to point to the
most recent version,

00:22:25.290 --> 00:22:26.190
some garbage got written.

00:22:26.190 --> 00:22:28.230
So, all subsequent reads
of X don't quite work.

00:22:31.730 --> 00:22:34.000
The answer to this
question is that we

00:22:34.000 --> 00:22:37.257
know how to solve this problem
because that question is

00:22:37.257 --> 00:22:38.090
basically identical.

00:22:38.090 --> 00:22:39.674
Both of these are identical.

00:22:39.674 --> 00:22:41.590
If we know how to solve
the problem of writing

00:22:41.590 --> 00:22:44.640
a single, recoverable sector,
a single, small item of data,

00:22:44.640 --> 00:22:47.070
then we know how to solve
these two problems because both

00:22:47.070 --> 00:22:50.520
of these are writing recoverably
a small amount of data.

00:22:50.520 --> 00:22:52.530
In one case, a
pointer that takes

00:22:52.530 --> 00:22:55.930
X to point to the most recent
version, in another case

00:22:55.930 --> 00:22:59.740
it's a single data
item that corresponds

00:22:59.740 --> 00:23:03.240
to the commit record in
this commit record table.

00:23:03.240 --> 00:23:08.140
And so this shows this
idea of bootstrap,

00:23:08.140 --> 00:23:11.600
that in order to build
this atomic action,

00:23:11.600 --> 00:23:13.940
this recoverable action, we end
up

00:23:13.940 --> 00:23:16.920
[SOUND OFF/THEN ON]

00:23:16.920 --> 00:23:19.200
...and then you bootstrap on...

00:23:21.520 --> 00:23:25.040
...and then you bootstrap on

00:23:25.040 --> 00:23:27.100
something that we know
already how to do

00:23:27.100 --> 00:23:29.600
because there are these cases
where you have to make sure

00:23:29.600 --> 00:23:31.320
that writes to
certain pointers,

00:23:31.320 --> 00:23:33.440
and some table items
are done atomically.

00:23:33.440 --> 00:23:36.540
And we know how to do that
because we just told you

00:23:36.540 --> 00:23:38.820
how to do recoverable sectors.

00:23:38.820 --> 00:23:41.420
And you could just take
shadowed objects

00:23:41.420 --> 00:23:43.520
for these items, and
[UNINTELLIGIBLE PHRASE]

00:23:43.520 --> 00:23:45.480
to get this bootstrap.

00:23:45.480 --> 00:23:50.980
So that's the first thing that...
the first step problem.

00:23:50.980 --> 00:23:53.620
There's another problem, not
so much a correctness problem,

00:23:53.620 --> 00:23:56.560
but a problem in general
using these version

00:23:56.560 --> 00:24:00.520
histories in order to
build recoverable actions.

00:24:00.520 --> 00:24:03.280
Any ideas on what that might be?

00:24:05.940 --> 00:24:07.840
Like, why would we
want to use this?

00:24:07.840 --> 00:24:09.520
Student: [UNINTELLIGIBLE]

00:24:09.520 --> 00:24:10.620
Is this a space?

00:24:10.620 --> 00:24:12.260
Student: [UNINTELLIGIBLE]

00:24:12.260 --> 00:24:14.460
Well, you kind of can't
really get around that.

00:24:14.460 --> 00:24:16.220
I mean, it's true that
there are these older

00:24:16.220 --> 00:24:17.860
versions that you keep forever.

00:24:17.860 --> 00:24:19.200
But, there are
optimizations you can

00:24:19.200 --> 00:24:20.100
bring to bear that are

00:24:20.100 --> 00:24:22.340
beneath these old versions that
you don't really care about

00:24:22.340 --> 00:24:24.380
anymore. Because really
the read only

00:24:24.380 --> 00:24:27.420
requires, at least for the way
we [UNINTELLIGIBLE]

00:24:27.420 --> 00:24:29.300
about this when we talk
about isolation tomorrow.

00:24:29.300 --> 00:24:30.820
But really, the
read only

00:24:30.820 --> 00:24:33.920
requires for a
single action case

00:24:33.920 --> 00:24:34.920
the last committed version.

00:24:34.920 --> 00:24:37.520
So, you could garbage collect
this stuff if you want.

00:24:37.520 --> 00:24:42.380
Student: [UNINTELLIGIBLE]

00:24:42.380 --> 00:24:44.920
Yeah, it's really slow.

00:24:44.920 --> 00:24:47.040
So, for applications
where you care

00:24:47.040 --> 00:24:49.500
about performance, or
reasonable performance,

00:24:49.500 --> 00:24:52.800
[UNINTELLIGIBLE]
this is really slow.

00:24:52.800 --> 00:24:54.920
And naturally, it's
not to say that this

00:24:54.920 --> 00:24:57.940
is a bad idea, an idea that
shouldn't be used at all.

00:24:57.940 --> 00:25:00.100
In fact, it's a perfectly
good idea for many cases

00:25:00.100 --> 00:25:02.040
where you might,
for various reasons,

00:25:02.040 --> 00:25:04.200
want to store restorative
records of old data

00:25:04.200 --> 00:25:06.740
and you don't care about fast
read or write performance.

00:25:06.740 --> 00:25:09.680
So it's perfectly good
for certain applications.

00:25:09.680 --> 00:25:13.280
But it's not good for
applications that want

00:25:13.280 --> 00:25:16.360
reasonably high-performance.

00:25:16.360 --> 00:25:18.960
And the reason that
this thing is small

00:25:18.960 --> 00:25:20.360
is because if you
think about it,

00:25:20.360 --> 00:25:25.180
it actually optimizes what you
might think of as uncommon case

00:25:25.180 --> 00:25:28.520
because what it ensures is that
when you fail and you recover,

00:25:28.520 --> 00:25:30.080
you have to do no work.

00:25:30.080 --> 00:25:32.140
So crash recovery is really
fast in this approach

00:25:32.150 --> 00:25:35.830
because there's nothing to
be done for crash recovery.

00:25:35.830 --> 00:25:39.482
But reads and writes are
slow because a read involves

00:25:39.482 --> 00:25:40.440
traversing the list.

00:25:40.440 --> 00:25:44.070
A write involves doing some
[UNINTELLIGIBLE  PHRASE].

00:25:44.070 --> 00:25:46.770
And so, it almost
optimizes the opposite

00:25:46.770 --> 00:25:47.730
of what you would want.

00:25:47.730 --> 00:25:49.105
If you want to
write performance,

00:25:49.105 --> 00:25:51.740
you want to form the principle
of optimizing the common case.

00:25:51.740 --> 00:25:54.580
And in order to optimize the
common case, what it means,

00:25:54.580 --> 00:25:56.960
what you want to do here is
to make the reads and writes

00:25:56.960 --> 00:26:01.120
really fast, and
maybe pay the penalty

00:26:01.120 --> 00:26:05.020
of a little bit of extra
timing in dealing with

00:26:05.020 --> 00:26:06.740
[UNINTELLIGIBLE PHRASE].

00:26:06.740 --> 00:26:09.000
[LAUGHTER]

00:26:09.000 --> 00:26:10.120
It's working now?

00:26:10.120 --> 00:26:13.060
[LAUGHTER]

00:26:13.660 --> 00:26:14.540
Hello?

00:26:20.720 --> 00:26:21.400
Technician: Sorry.

00:26:21.400 --> 00:26:23.520
All right, thanks.

00:26:26.600 --> 00:26:31.140
OK, so what you want to do
is optimize, whoa, it's loud.

00:26:31.140 --> 00:26:33.200
[LAUGHTER]

00:26:33.920 --> 00:26:37.120
So the integral of the volume
over time is correct.

00:26:43.660 --> 00:26:47.440
OK, so the solution
to this problem

00:26:47.450 --> 00:26:49.920
where we want to optimize
the common case of reads

00:26:49.920 --> 00:26:54.010
and writes, but we are
OK taking a bunch of time

00:26:54.010 --> 00:26:56.870
to do crash recovery is
an idea called logging.

00:27:04.890 --> 00:27:09.360
So the way to think of a log
is it's like a version history

00:27:09.360 --> 00:27:13.860
except you don't have a
version for each variable.

00:27:13.860 --> 00:27:17.930
You think of it as an Interleaf
version data structure

00:27:17.930 --> 00:27:21.520
that interleaves all the version
histories for all of the data

00:27:21.520 --> 00:27:24.860
that was ever written
during an action,

00:27:24.860 --> 00:27:27.100
during all of the
actions that ran.

00:27:27.100 --> 00:27:30.042
So what this means is that you
can write the log sequentially.

00:27:30.042 --> 00:27:31.750
And you've seen this
in yesterday's paper

00:27:31.750 --> 00:27:34.120
where they use logs for
a different application

00:27:34.120 --> 00:27:37.930
for high performance in a
file system for a system

00:27:37.930 --> 00:27:43.081
where writes normally
would incur a lot of seeks.

00:27:43.081 --> 00:27:44.330
But you can use the same idea.

00:27:44.330 --> 00:27:48.070
In this case, we're going to
use a log for crash recovery.

00:27:48.070 --> 00:27:50.670
But the fundamental property
of a log data structure

00:27:50.670 --> 00:27:53.760
is that it needs be
written only sequentially.

00:27:53.760 --> 00:27:56.090
And we know that disks
do that pretty fast.

00:27:56.090 --> 00:27:58.170
It's only when you have
to seek that and read

00:27:58.170 --> 00:28:00.600
small chunks of data with
seeks that you end up

00:28:00.600 --> 00:28:03.580
being really slow.

00:28:03.580 --> 00:28:08.360
So we're going to use cell
storage to satisfy our reads

00:28:08.360 --> 00:28:10.912
and writes.

00:28:10.912 --> 00:28:12.870
So all of those are going
to go to cell stores.

00:28:12.870 --> 00:28:14.911
You can read means
you just read a variable.

00:28:14.911 --> 00:28:16.930
You don't traverse any
link lists, and writes

00:28:16.930 --> 00:28:18.350
you don't create
any new versions.

00:28:18.350 --> 00:28:22.720
You just write into cell store.

00:28:22.720 --> 00:28:32.540
But then the log is going to be
stored on a nonvolatile medium

00:28:32.540 --> 00:28:33.620
such as a disk.

00:28:33.620 --> 00:28:36.690
And it's written sequentially.

00:28:45.500 --> 00:28:52.390
So once we have those two, our
plan is going to be as follows.

00:28:52.390 --> 00:28:55.440
And this plan is the
same plan that's adopted.

00:28:55.440 --> 00:28:58.450
Although there is
dozens of ways of doing

00:28:58.450 --> 00:29:01.340
log based crash recover,
they all essentially follow

00:29:01.340 --> 00:29:04.740
the same basic plan.

00:29:04.740 --> 00:29:07.180
You read and write
normally to cell storage.

00:29:07.180 --> 00:29:09.865
And you also write
a copy of what

00:29:09.865 --> 00:29:10.990
you're reading and writing.

00:29:10.990 --> 00:29:13.180
You write an encoding
of what you're writing,

00:29:13.180 --> 00:29:15.970
any updates that you
make into the log.

00:29:15.970 --> 00:29:18.130
OK, and we'll talk
in more detail

00:29:18.130 --> 00:29:20.050
about what you're exactly
right into the log

00:29:20.050 --> 00:29:22.530
and when you write
into the log, OK?

00:29:22.530 --> 00:29:25.460
So that allows us to follow this
golden rule of recoverability.

00:29:25.460 --> 00:29:28.050
It'll turn out that the
log is a copy of the data.

00:29:28.050 --> 00:29:30.800
So you always have two copies of
the data: one in cell storage,

00:29:30.800 --> 00:29:31.690
one on the log.

00:29:36.170 --> 00:29:39.340
So what happens when you fail?

00:29:39.340 --> 00:29:42.080
Well, when you fail, unlike in
the version history case where

00:29:42.080 --> 00:29:45.900
you could fail and restart, and
you don't have to do anything,

00:29:45.900 --> 00:29:52.750
here when you fail, the system
runs a recovery procedure.

00:29:52.750 --> 00:29:55.480
And that recovery procedure
recovers from the log

00:29:55.480 --> 00:29:57.384
that we have conveniently
arranged to write

00:29:57.384 --> 00:29:58.550
in the non-volatile storage.

00:29:58.550 --> 00:30:01.070
So, it remains
even after a crash,

00:30:01.070 --> 00:30:05.129
and it remains after
a crash recovers.

00:30:05.129 --> 00:30:07.670
And there are two things to do
while recovering from the log.

00:30:10.460 --> 00:30:15.819
For actions that didn't get to
finish the commit, for actions

00:30:15.819 --> 00:30:17.860
that were uncommitted,
which is this commit never

00:30:17.860 --> 00:30:21.230
return, what we have to
do is to look carefully

00:30:21.230 --> 00:30:26.100
to see whether the corresponding
cell store had any updates that

00:30:26.100 --> 00:30:27.360
were made to it.

00:30:27.360 --> 00:30:28.900
And it'll turn out
that the log is

00:30:28.900 --> 00:30:31.660
going to help us keep track
of what items were updated

00:30:31.660 --> 00:30:33.160
by any given action.

00:30:33.160 --> 00:30:35.220
And what we're going
to end up doing

00:30:35.220 --> 00:30:40.150
is for uncommitted actions,
we're going to back out.

00:30:43.969 --> 00:30:46.510
In other words, we're going to
undo any changes that it made,

00:30:46.510 --> 00:30:48.176
and the log is going
to help us do that.

00:30:51.470 --> 00:30:54.330
And conversely, for
committed actions,

00:30:54.330 --> 00:30:57.320
because the semantics we
want are that once committed,

00:30:57.320 --> 00:31:01.490
you would like the changes to
be visible to other people.

00:31:01.490 --> 00:31:03.610
For committed actions,
what you would like to do

00:31:03.610 --> 00:31:05.630
are to make sure
that the changes made

00:31:05.630 --> 00:31:07.820
by all committed
actions are in fact

00:31:07.820 --> 00:31:10.880
installed in the cell store.

00:31:10.880 --> 00:31:12.860
And what this means is
that if they turn out

00:31:12.860 --> 00:31:14.937
to not have been
installed, and we're

00:31:14.937 --> 00:31:17.520
going to use the log to tell us
whether they've been installed

00:31:17.520 --> 00:31:19.640
or not, we will
redo those actions.

00:31:25.720 --> 00:31:27.820
And, the second
thing we need to do

00:31:27.820 --> 00:31:31.720
is what happens if
an abort is called

00:31:31.720 --> 00:31:34.880
either by the application
or by the system.

00:31:34.880 --> 00:31:40.310
Well, in this case, what we
have to do is to use the log,

00:31:40.310 --> 00:31:41.780
and to keep track,
the log is going

00:31:41.780 --> 00:31:44.860
to help us keep track of the
changes made by this action

00:31:44.860 --> 00:31:46.760
to the cell store.

00:31:46.760 --> 00:31:49.459
The cell store itself doesn't
have an ocean of old or new

00:31:49.459 --> 00:31:50.500
because it's overwritten.

00:31:50.500 --> 00:31:52.270
So the log is going
to tell us that.

00:31:52.270 --> 00:31:53.890
And when abort is
called, we just

00:31:53.890 --> 00:31:58.120
want to back out by undoing the
changes of the current action.

00:32:04.447 --> 00:32:05.280
And that's the plan.

00:32:09.154 --> 00:32:10.820
So the first thing
we need to figure out

00:32:10.820 --> 00:32:12.070
is what this log looks like.

00:32:16.310 --> 00:32:18.180
So as we saw from
this discussion,

00:32:18.180 --> 00:32:21.120
the log is going to be required
for us to do two things.

00:32:21.120 --> 00:32:23.520
We're going to be undoing
things from the log,

00:32:23.520 --> 00:32:28.260
and we're going to be
redoing things from the log.

00:32:28.260 --> 00:32:32.440
So what that suggests is that
any time you update cell store,

00:32:32.440 --> 00:32:34.930
you change X from 17 to 25.

00:32:34.930 --> 00:32:36.980
What you'd really
like to maintain

00:32:36.980 --> 00:32:40.520
is what the value was before the
change was made so that you can

00:32:40.520 --> 00:32:43.280
undo if you need to,
and what the value

00:32:43.280 --> 00:32:46.940
is after the change was made so
that you can redo if you have

00:32:46.940 --> 00:32:50.230
to if by chance the
actual cell store didn't

00:32:50.230 --> 00:32:51.850
get written at the right time.

00:32:51.850 --> 00:32:54.450
So really the way to think
about logging base crash

00:32:54.450 --> 00:32:56.420
recover is that
the log is really

00:32:56.420 --> 00:32:59.100
the authoritative
version of the data.

00:32:59.100 --> 00:33:01.970
The cell store itself is you
should think of as a cache.

00:33:01.970 --> 00:33:03.424
And we've seen this idea before.

00:33:03.424 --> 00:33:05.340
The cell store you should
think of as a cache.

00:33:05.340 --> 00:33:07.630
If a failure happens,
you really have

00:33:07.630 --> 00:33:09.730
to be careful about
trusting the cell store.

00:33:09.730 --> 00:33:12.280
And, you don't trust
what's in the cell store.

00:33:12.280 --> 00:33:15.050
You start with a log,
and by selectively

00:33:15.050 --> 00:33:16.890
undoing certain
changes that were made

00:33:16.890 --> 00:33:19.090
and redoing certain
changes, you produce

00:33:19.090 --> 00:33:22.970
a more pristine, correct version
of the data, which corresponds

00:33:22.970 --> 00:33:25.430
to the changes made by all
the committed actions being

00:33:25.430 --> 00:33:29.120
visible, and the changes made
by all the uncommitted actions

00:33:29.120 --> 00:33:35.290
being wiped away to
the previous version.

00:33:35.290 --> 00:33:37.040
OK, so what does
the log look like?

00:33:37.040 --> 00:33:40.200
Well, as I've already said, a
log is like a version history

00:33:40.200 --> 00:33:41.900
except it interleaves
everything,

00:33:41.900 --> 00:33:42.960
and it's sequential.

00:33:42.960 --> 00:33:44.870
So it's really an
append-only data structure.

00:33:48.410 --> 00:33:58.240
And there's a few
different kinds of records

00:33:58.240 --> 00:34:00.110
that the log maintains.

00:34:00.110 --> 00:34:03.480
In particular, two are going
to be interesting to us.

00:34:03.480 --> 00:34:10.550
So there are two types of
records that we care about.

00:34:10.550 --> 00:34:14.860
The first type are
update records,

00:34:14.860 --> 00:34:18.750
which are written
to the log whenever

00:34:18.750 --> 00:34:22.050
a cell store item changes.

00:34:22.050 --> 00:34:25.860
So, if X goes from 17 to 25,
what you would write

00:34:25.860 --> 00:34:27.850
is an update record
that looks like this.

00:34:27.850 --> 00:34:31.989
You store the ID
of the transaction,

00:34:31.989 --> 00:34:35.560
sorry, ID of the recoverable
action that did the update.

00:34:35.560 --> 00:34:38.850
And then, you store two items.

00:34:38.850 --> 00:34:42.920
One of them is an undo item
or an undo action, actually.

00:34:42.920 --> 00:34:54.600
And, an undo that might
say  and a redo action.

00:34:54.600 --> 00:34:57.060
So what this means
here is that let's say

00:34:57.070 --> 00:34:59.550
that the actual
step of this action

00:34:59.550 --> 00:35:04.900
said X is assigned
to some value, new.

00:35:04.900 --> 00:35:06.500
In the log, what
you would write is

00:35:06.500 --> 00:35:09.220
keep track of old value,
the current value of X,

00:35:09.220 --> 00:35:12.021
and make that the undo step.

00:35:12.021 --> 00:35:14.020
And then, keep track of
the change that was made

00:35:14.020 --> 00:35:17.860
and make that the real step.

00:35:17.860 --> 00:35:21.600
So now, after doing this,
if the system were to fail,

00:35:21.600 --> 00:35:26.070
and this action 172 were
to never commit then

00:35:26.070 --> 00:35:28.250
you can systematically
start with the log,

00:35:28.250 --> 00:35:29.950
start with the latest
item in the log

00:35:29.950 --> 00:35:34.670
and go backwards, and
undo any changes made

00:35:34.670 --> 00:35:37.110
by actions that didn't commit.

00:35:37.110 --> 00:35:39.970
And conversely, and you might
need to do this as well,

00:35:39.970 --> 00:35:42.780
you might want to look at all
the actions that committed,

00:35:42.780 --> 00:35:45.480
and make sure that all those
actions, those individual steps

00:35:45.480 --> 00:35:48.735
in those actions are redone so
that once the crash recovers,

00:35:48.735 --> 00:35:50.360
you have a correct
version of the data.

00:35:53.240 --> 00:35:55.170
Now the other thing
that you will need,

00:35:55.170 --> 00:36:00.970
and you'll see why in a moment,
is another kind, a record

00:36:00.970 --> 00:36:07.214
and a log, which we're going
to call the outcome record.

00:36:07.214 --> 00:36:08.630
And this outcome
is the thing that

00:36:08.630 --> 00:36:11.554
keeps track of whether an
action committed or not.

00:36:11.554 --> 00:36:13.720
Remember I said you're going
to look through the log

00:36:13.720 --> 00:36:15.390
and figure out which
actions committed,

00:36:15.390 --> 00:36:16.580
and which didn't commit.

00:36:16.580 --> 00:36:18.220
You need to store
that somewhere.

00:36:18.220 --> 00:36:21.011
In particular, what that means
is that when an action commits,

00:36:21.011 --> 00:36:23.510
you had better make sure that
there is in it them in the log

00:36:23.510 --> 00:36:25.660
because the log really is
the only correct version

00:36:25.660 --> 00:36:26.900
of the data.

00:36:26.900 --> 00:36:29.100
So you have an outcome
record, and this

00:36:29.100 --> 00:36:31.490
has an ID of the action.

00:36:31.490 --> 00:36:34.470
It might be 174.

00:36:34.470 --> 00:36:39.550
And, there's a status
that might stay committed.

00:36:42.450 --> 00:36:45.230
And other values for the
status might be aborted

00:36:45.230 --> 00:36:49.250
is a possible value
of the status.

00:36:49.250 --> 00:36:50.770
Another is pending.

00:36:50.770 --> 00:36:56.770
So for various
reasons, what we will

00:36:56.770 --> 00:37:00.380
have is when begin recoverable
action returns with an ID,

00:37:00.380 --> 00:37:03.360
we will create a
log entry that says

00:37:03.360 --> 00:37:05.556
that this action has begun.

00:37:05.556 --> 00:37:06.930
So you might have
a begin record.

00:37:06.930 --> 00:37:10.200
It's not that important
to worry about for now.

00:37:10.200 --> 00:37:13.540
But the status of a committed
record and an aborted,

00:37:13.540 --> 00:37:17.300
and the update type are
important to understand.

00:37:20.220 --> 00:37:23.800
So once you have this
log structure understood,

00:37:23.800 --> 00:37:26.390
or the log data
structure understood,

00:37:26.390 --> 00:37:28.780
what you have to
think about our there

00:37:28.780 --> 00:37:31.520
are two questions that you
end up spending a lot of time

00:37:31.520 --> 00:37:35.430
thinking about in designing
these log-based protocols.

00:37:35.430 --> 00:37:37.830
The first one is when
to write the log.

00:37:45.040 --> 00:37:47.570
And the second one is,
you know, I sort of

00:37:47.570 --> 00:37:49.030
said you just look
through the log

00:37:49.030 --> 00:37:50.980
and undo the guys
who didn't commit,

00:37:50.980 --> 00:37:52.990
and redo the people
who committed.

00:37:52.990 --> 00:37:55.150
But you have to be very
careful about doing that.

00:37:55.150 --> 00:37:58.020
And that corresponds
to this question

00:37:58.020 --> 00:38:03.150
of exactly how to recover,
how to systematically recover

00:38:03.150 --> 00:38:05.920
so the state of the system is
as I have described before.

00:38:08.054 --> 00:38:09.970
So those are the questions
we're going to deal

00:38:09.970 --> 00:38:11.220
with for the next few minutes.

00:38:15.890 --> 00:38:18.580
Let's do this with
a specific example.

00:38:18.580 --> 00:38:20.190
And it will turn
out and to answer

00:38:20.190 --> 00:38:21.770
doesn't really depend
on the example.

00:38:21.770 --> 00:38:25.680
But the example is good to
give you the right intuition.

00:38:25.680 --> 00:38:28.690
And this example is actually
pretty common example

00:38:28.690 --> 00:38:30.140
of a disk-bound database.

00:38:34.800 --> 00:38:40.270
So a disk bound
database is one where

00:38:40.270 --> 00:38:43.930
you have applications
writing to a database, which

00:38:43.930 --> 00:38:47.000
is where the cell
storage is implemented.

00:38:47.000 --> 00:38:48.560
And the cell storage is on disk.

00:38:52.020 --> 00:38:57.680
So, you might have
writes of cell items, X,

00:38:57.680 --> 00:39:00.240
and they go to a database.

00:39:00.240 --> 00:39:03.510
And similarly, in any
disk bound database

00:39:03.510 --> 00:39:05.240
that you want
crash recovery for,

00:39:05.240 --> 00:39:06.600
you need to maintain a log.

00:39:06.600 --> 00:39:09.699
And for various reasons
having to do primarily

00:39:09.699 --> 00:39:11.990
with dealing with failures
of the disk hardware itself,

00:39:11.990 --> 00:39:15.020
it's very often useful
to an experience

00:39:15.020 --> 00:39:18.360
to maintain the log
on a different disk.

00:39:18.360 --> 00:39:20.230
So we'll maintain
for this example

00:39:20.230 --> 00:39:22.330
the log on a different disk.

00:39:22.330 --> 00:39:26.970
So whenever write X is done,
just looking at the log data

00:39:26.970 --> 00:39:31.030
structure, you need to
write an update record

00:39:31.030 --> 00:39:33.160
and append that to the log.

00:39:33.160 --> 00:39:36.530
So at some point you would
need to write this to the log.

00:39:36.530 --> 00:39:40.700
You need to log the update --

00:39:40.700 --> 00:39:47.650
-- that says that X change from
something to something else.

00:39:47.650 --> 00:39:52.049
So the question is, when
do you write both of these?

00:39:52.049 --> 00:39:54.340
So one approach might be that
it really doesn't matter.

00:39:54.340 --> 00:39:56.990
As long as the log gets
the data, you're fine.

00:39:56.990 --> 00:39:59.180
But that has a
couple of problems.

00:39:59.180 --> 00:40:02.140
In particular,
suppose you write X

00:40:02.140 --> 00:40:04.064
without writing the log entry.

00:40:04.064 --> 00:40:06.230
And as soon as you write
X, before you have a chance

00:40:06.230 --> 00:40:10.140
to write to the log,
you crash, or the system

00:40:10.140 --> 00:40:14.420
causes this program to abort,
or the program itself aborts.

00:40:14.420 --> 00:40:17.250
It writes X and then it
does some calculation

00:40:17.250 --> 00:40:20.300
and the it decides to abort.

00:40:20.300 --> 00:40:25.260
Now you are in trouble because
the log hasn't kept track yet

00:40:25.260 --> 00:40:27.360
the log hasn't had
a chance of keeping

00:40:27.360 --> 00:40:31.240
track of what the
old value was, which

00:40:31.240 --> 00:40:32.930
means that if you
really want to restore

00:40:32.930 --> 00:40:36.730
this database by
undoing this write to X,

00:40:36.730 --> 00:40:38.380
you have to do a
whole lot of work.

00:40:38.380 --> 00:40:40.110
And it might be
impossible to do it.

00:40:40.110 --> 00:40:42.900
If you didn't know, for example,
what the current value was,

00:40:42.900 --> 00:40:44.470
there was absolutely
no way for you

00:40:44.470 --> 00:40:48.890
to restore to the old value.

00:40:48.890 --> 00:40:52.910
So what this suggests is
that you better not write

00:40:52.910 --> 00:40:55.550
to the cell store before
you write to the log

00:40:55.550 --> 00:40:59.350
because if you wrote to
the cell store log write,

00:40:59.350 --> 00:41:03.190
and the system crashed right
after or failure about it,

00:41:03.190 --> 00:41:05.370
you won't really
have a way in general

00:41:05.370 --> 00:41:09.010
of reverting to the
version of the data item

00:41:09.010 --> 00:41:10.429
before this write.

00:41:10.429 --> 00:41:12.470
And you do need to revert
because it just aborted

00:41:12.470 --> 00:41:12.970
or fails.

00:41:12.970 --> 00:41:18.280
So you need to back out of
all changes that were made.

00:41:18.280 --> 00:41:21.630
So that suggests the
first part of our protocol

00:41:21.630 --> 00:41:23.615
which we are going to
call the wall protocol.

00:41:26.809 --> 00:41:29.100
Actually, that is the wall,
I mean, not the first part.

00:41:29.100 --> 00:41:30.474
This suggests this
wall protocol.

00:41:30.474 --> 00:41:32.090
Wall stands for
write-ahead logging.

00:41:38.940 --> 00:41:46.930
And the protocol says update
the log or append to the log

00:41:46.930 --> 00:41:50.570
before you write
to the cell store.

00:41:50.570 --> 00:41:51.630
It's what it says.

00:41:51.630 --> 00:41:58.440
Write ahead log says write the
log before you write the cell

00:41:58.440 --> 00:42:00.500
store.

00:42:00.500 --> 00:42:03.630
The advantage of writing the
log before you write to the cell

00:42:03.630 --> 00:42:09.930
store is that suppose now
you set X to some value

00:42:09.930 --> 00:42:12.110
and then you crashed.

00:42:12.110 --> 00:42:15.400
Then you're guaranteed that
if the cell store got written,

00:42:15.400 --> 00:42:21.080
the log got written, which
means that if this action didn't

00:42:21.080 --> 00:42:22.960
commit, you can
go through the log

00:42:22.960 --> 00:42:26.570
and undo that action because
you know that the log entry got

00:42:26.570 --> 00:42:29.550
written correctly before
the cell store got written.

00:42:29.550 --> 00:42:31.300
And if the log entry
didn't get written,

00:42:31.300 --> 00:42:32.520
then you know the
cell store didn't

00:42:32.520 --> 00:42:34.853
get written, which means you
don't have to undo anything

00:42:34.853 --> 00:42:36.810
for that particular data item.

00:42:36.810 --> 00:42:39.040
So either way you're fine.

00:42:39.040 --> 00:42:44.380
There is another
part of this protocol

00:42:44.380 --> 00:42:46.300
that we're going to need
to meet the semantics

00:42:46.300 --> 00:42:48.870
of a recoverable
action that we wanted,

00:42:48.870 --> 00:42:51.550
which is that once
you reach commit,

00:42:51.550 --> 00:42:54.110
you want the changes
made by that action

00:42:54.110 --> 00:42:55.990
to be visible to all
the other people,

00:42:55.990 --> 00:42:59.590
all of the other actions
that are subsequent actions.

00:42:59.590 --> 00:43:02.990
And what that means is
that before you return

00:43:02.990 --> 00:43:05.860
from the commit, you
had better make sure

00:43:05.860 --> 00:43:09.740
that the commit record for this
action is logged to the disk,

00:43:09.740 --> 00:43:15.950
is logged, because if you didn't
do that, and you just returned,

00:43:15.950 --> 00:43:23.150
then you can't be guaranteed
that all of the writes that

00:43:23.150 --> 00:43:25.270
were done to the cell
item were actually

00:43:25.270 --> 00:43:26.780
put on to the cell store.

00:43:26.780 --> 00:43:28.530
There's no guarantee
that these writes

00:43:28.530 --> 00:43:30.640
to the cell store actually
got written to the cell

00:43:30.640 --> 00:43:32.640
store because all you are
doing in this protocol

00:43:32.640 --> 00:43:34.600
is ensuring that the
writes to the log

00:43:34.600 --> 00:43:36.150
are being written before
the writes to the data.

00:43:36.150 --> 00:43:38.233
Nobody is saying when the
writes of the cell store

00:43:38.233 --> 00:43:39.880
really are happening
and finishing,

00:43:39.880 --> 00:43:45.080
which means if the
action commits,

00:43:45.080 --> 00:43:48.180
and you return committed to
the user to the application,

00:43:48.180 --> 00:43:50.280
then you had better have
a way of making sure

00:43:50.280 --> 00:43:51.660
that if the failure
now happened,

00:43:51.660 --> 00:43:54.290
the system when
it recovers knows

00:43:54.290 --> 00:43:58.070
that this action committed,
which means it follows, then,

00:43:58.070 --> 00:44:01.100
that if you want those
semantics that you'd better

00:44:01.100 --> 00:44:05.490
write the commit record, the
fact that this action committed

00:44:05.490 --> 00:44:08.200
to the log before
the commit returns.

00:44:08.200 --> 00:44:10.950
And really the only reason
you need that is that

00:44:10.950 --> 00:44:13.520
we've established; we've decided
that we wanted the semantics

00:44:13.520 --> 00:44:15.978
that a different action commits,
you want the results to be

00:44:15.978 --> 00:44:17.150
visible to everybody else.

00:44:17.150 --> 00:44:20.640
And later on, we'll see
that this is related

00:44:20.640 --> 00:44:23.730
to this notion of durability.

00:44:23.730 --> 00:44:30.620
So write commit record before --

00:44:35.120 --> 00:44:46.880
returning for commit.

00:44:46.880 --> 00:44:49.890
So two main ideas: write
ahead logging means

00:44:49.890 --> 00:44:52.060
make sure that you write
the log, append to the log

00:44:52.060 --> 00:44:54.070
before you write
to the cell store.

00:44:54.070 --> 00:44:57.400
And in order to make sure that
committed actions, the results

00:44:57.400 --> 00:45:00.010
of committed actions are
visible even after failure

00:45:00.010 --> 00:45:02.254
to subsequent actions,
log the commit record

00:45:02.254 --> 00:45:03.670
before you return
from the commit.

00:45:11.070 --> 00:45:12.570
So now we are
actually in good shape

00:45:12.570 --> 00:45:17.950
to specify this
recovery procedure

00:45:17.950 --> 00:45:20.870
that I've alluded to
before because the log is

00:45:20.870 --> 00:45:23.940
going to contain these update
records and these outcome

00:45:23.940 --> 00:45:25.390
records.

00:45:25.390 --> 00:45:27.830
And that's going to
allow us to decide

00:45:27.830 --> 00:45:30.496
what to do upon crash recovery.

00:45:30.496 --> 00:45:31.870
And actually the
only other piece

00:45:31.870 --> 00:45:35.299
we need is to decide
what happens on an abort.

00:45:35.299 --> 00:45:37.090
And that's actually
pretty straightforward.

00:45:37.090 --> 00:45:39.390
If the system calls abort,
or if the user application

00:45:39.390 --> 00:45:42.840
calls abort on an action,
what abort has to do

00:45:42.840 --> 00:45:44.500
is to look through the log.

00:45:44.500 --> 00:45:47.420
Remember that all of the
rights have been written.

00:45:47.420 --> 00:45:49.314
Any time a write happens,
you don't actually

00:45:49.314 --> 00:45:50.730
care about when
the write actually

00:45:50.730 --> 00:45:52.180
happens at the cell store.

00:45:52.180 --> 00:45:56.120
What you care about is that
the write happens to the log

00:45:56.120 --> 00:45:58.600
before the write happens
to the cell store.

00:45:58.600 --> 00:46:01.160
So, if an abort were
called, all you have to do

00:46:01.160 --> 00:46:03.890
is to ensure that
before abort returns,

00:46:03.890 --> 00:46:08.720
all of the actions done
by, all of the steps taken

00:46:08.720 --> 00:46:12.250
by this action around done, and
the corresponding cell values

00:46:12.250 --> 00:46:12.920
are on done.

00:46:15.860 --> 00:46:19.010
And that's all you have to
do when you implement abort.

00:46:22.550 --> 00:46:27.880
So one thing that I haven't
really specified very clearly

00:46:27.880 --> 00:46:30.310
is when the actual
writes happen to the disk

00:46:30.310 --> 00:46:31.960
or to any cell store.

00:46:31.960 --> 00:46:36.540
And it turns out that it
really doesn't matter.

00:46:36.540 --> 00:46:38.791
If there's no failure,
as long as you ensure,

00:46:38.791 --> 00:46:40.290
you could have
caches in the middle.

00:46:40.290 --> 00:46:41.498
You could have anything else.

00:46:41.498 --> 00:46:44.940
So, as long as you ensure that
if there's no concurrency,

00:46:44.940 --> 00:46:46.290
we'll deal with that next time.

00:46:46.290 --> 00:46:47.995
But as long as you
ensure that when

00:46:47.995 --> 00:46:50.120
you have actions that come
one after the other that

00:46:50.120 --> 00:46:53.390
are recoverable that
the values that are read

00:46:53.390 --> 00:46:57.810
are only the values that
were written by previously

00:46:57.810 --> 00:47:00.350
committed actions,
then it really

00:47:00.350 --> 00:47:03.750
doesn't matter when those
were actually written to disk.

00:47:03.750 --> 00:47:06.610
But for crash recover to work,
the main thing that matters is

00:47:06.610 --> 00:47:11.040
make sure that the log keeps
track exactly of all the things

00:47:11.040 --> 00:47:13.180
to undo for uncommitted actions.

00:47:13.180 --> 00:47:14.680
And for things
that got committed,

00:47:14.680 --> 00:47:19.610
to make sure that the log keeps
track of the commit record

00:47:19.610 --> 00:47:20.780
before the commit returns.

00:47:24.730 --> 00:47:27.430
So given the story, the
way the recovery procedure

00:47:27.430 --> 00:47:28.830
works as the following.

00:47:28.830 --> 00:47:31.676
The first step is the system
fails, and that it recovers.

00:47:31.676 --> 00:47:32.800
You scan the log backwards.

00:47:39.690 --> 00:47:41.820
And as you are scanning
the log backwards,

00:47:41.820 --> 00:47:45.430
you keep track of
two kinds of actions.

00:47:45.430 --> 00:47:50.490
You keep track of actions that
were either committed or were

00:47:50.490 --> 00:47:52.350
aborted, OK?

00:47:52.350 --> 00:47:55.620
And what that means
is that for actions

00:47:55.620 --> 00:47:58.600
that were committed or
aborted, the cell store

00:47:58.600 --> 00:48:01.400
for those actions is
in a certain state

00:48:01.400 --> 00:48:03.400
or needs to be in
a certain state.

00:48:03.400 --> 00:48:05.080
For committed actions,
it needs to be

00:48:05.080 --> 00:48:08.470
in a state that's the result of
finishing the committed action.

00:48:08.470 --> 00:48:10.410
And for the aborted
actions, what it means

00:48:10.410 --> 00:48:12.780
is that when the abort
returned and there

00:48:12.780 --> 00:48:15.310
was an aborted
action, abort already

00:48:15.310 --> 00:48:17.249
undid the state
of the cell store

00:48:17.249 --> 00:48:19.540
by definition by the definition
of the abort procedure.

00:48:19.540 --> 00:48:22.190
So what that means is
for log records that

00:48:22.190 --> 00:48:24.834
contain a type outcome
and the status abort

00:48:24.834 --> 00:48:26.250
that you don't
have to do anything

00:48:26.250 --> 00:48:29.050
because the changes are
already on done before

00:48:29.050 --> 00:48:31.400
that abort record was written.

00:48:31.400 --> 00:48:33.360
So what you do in
scanning the log backwards

00:48:33.360 --> 00:48:35.550
is you build up two
kinds of actions.

00:48:35.550 --> 00:48:38.140
You build up winners,
which are actions

00:48:38.140 --> 00:48:42.355
that were committed or aborted.

00:48:45.300 --> 00:48:51.182
And you build up a list of
losers that were none of these.

00:48:51.182 --> 00:48:52.890
In other words, they
were pending actions

00:48:52.890 --> 00:48:56.320
that kind of just during a
failure they were pending,

00:48:56.320 --> 00:48:57.340
so they didn't commit.

00:48:57.340 --> 00:48:58.506
And they were never aborted.

00:49:06.150 --> 00:49:08.160
And so the plan
now is to make sure

00:49:08.160 --> 00:49:10.820
that the cell store is correctly
restored to the state that

00:49:10.820 --> 00:49:16.010
was before the crash where
all of the committed actions'

00:49:16.010 --> 00:49:20.080
results are visible, and none
of the uncommitted actions,

00:49:20.080 --> 00:49:22.430
you know, all of
those are blown away.

00:49:22.430 --> 00:49:26.835
All you have to do is
to redo the winners that

00:49:26.835 --> 00:49:27.460
were committed.

00:49:27.460 --> 00:49:29.220
You don't have to do anything
for the aborted winners

00:49:29.220 --> 00:49:30.910
because they were
already undone.

00:49:30.910 --> 00:49:37.370
So you have to redo
committed winners,

00:49:37.370 --> 00:49:46.020
and you have to undo any
changes made by losers, right,

00:49:46.020 --> 00:49:47.680
because these
losers by definition

00:49:47.680 --> 00:49:50.320
were things that didn't
commit or didn't abort.

00:49:50.320 --> 00:49:53.350
And the reason you only redo the
committed winners rather than

00:49:53.350 --> 00:49:55.735
all winners is it makes no
sense to redo aborted winners.

00:49:55.735 --> 00:49:58.110
And you don't need to undo
them because they were already

00:49:58.110 --> 00:50:06.410
undone when the abort record
was written to the log.

00:50:06.410 --> 00:50:08.460
So this is the basic
idea for dealing

00:50:08.460 --> 00:50:11.350
with one of these databases.

00:50:11.350 --> 00:50:13.050
But there's five or
six optimizations

00:50:13.050 --> 00:50:16.875
that end up making this
kind of system go faster.

00:50:16.875 --> 00:50:18.750
You'll see some of these
optimizations buried

00:50:18.750 --> 00:50:22.190
inside the system R paper, which
is the discussion for tomorrow.

00:50:22.190 --> 00:50:25.750
But what I'll do on Monday,
I'll spend five minutes talking

00:50:25.750 --> 00:50:28.230
about the most
important optimizations,

00:50:28.230 --> 00:50:30.440
and I think the whole
story will become clear.

00:50:30.440 --> 00:50:32.660
So the plan for the subsequent
lectures on this topic

00:50:32.660 --> 00:50:34.850
are: on Monday we'll
deal with isolation,

00:50:34.850 --> 00:50:37.580
and on Wednesday we'll continue
to talk about isolation,

00:50:37.580 --> 00:50:41.140
and then talk about a
different issue of consistency.

