WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:19.790
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:19.790 --> 00:00:21.040
ocw.mit.edu.

00:00:23.520 --> 00:00:24.770
PROFESSOR: Good morning.

00:00:27.870 --> 00:00:29.510
This is 600.

00:00:29.510 --> 00:00:32.790
So I hope any of you who thought
this was a different

00:00:32.790 --> 00:00:36.810
course find where you
really belong.

00:00:36.810 --> 00:00:38.950
My name is John Guttag.

00:00:38.950 --> 00:00:43.650
And I'll be lecturing the
course all semester.

00:00:43.650 --> 00:00:45.690
OK.

00:00:45.690 --> 00:00:48.400
Today I want to accomplish
several things.

00:00:48.400 --> 00:00:51.290
Cover some of the administrative
details.

00:00:51.290 --> 00:00:53.550
Talk about the goals
of the course--

00:00:53.550 --> 00:00:55.510
what I hope you'll learn.

00:00:55.510 --> 00:00:58.430
And then begin talking
about the conceptual

00:00:58.430 --> 00:01:01.530
material in the course.

00:01:01.530 --> 00:01:04.000
It will seem a little bit slow,
because it will be a

00:01:04.000 --> 00:01:05.430
little bit slow.

00:01:05.430 --> 00:01:08.020
I promise starting on Thursday
we're going to pick up the

00:01:08.020 --> 00:01:10.120
pace considerably.

00:01:10.120 --> 00:01:13.305
So let's start with the
strategic goals of the course.

00:01:17.160 --> 00:01:21.420
The official introduction
to course 6 is 601.

00:01:21.420 --> 00:01:25.550
Historically, students who
arrive at MIT with little or

00:01:25.550 --> 00:01:30.930
no programming experience
find 601 an ordeal.

00:01:30.930 --> 00:01:33.650
And the point of this is
to prepare freshman and

00:01:33.650 --> 00:01:37.040
sophomores for entering
course 6--

00:01:37.040 --> 00:01:39.170
that's the Electrical
Engineering Computer Science

00:01:39.170 --> 00:01:40.210
department--

00:01:40.210 --> 00:01:43.070
in a gentler, kinder way.

00:01:43.070 --> 00:01:48.550
So that 601 is not so
much of a problem.

00:01:48.550 --> 00:01:51.270
I want to help students
feel justifiably--

00:01:51.270 --> 00:01:54.300
and I want to emphasize
the word justifiably--

00:01:54.300 --> 00:01:56.790
confident in their ability
to write small and

00:01:56.790 --> 00:01:59.050
medium sized programs.

00:01:59.050 --> 00:02:03.200
So at the end of the term, you
should all feel comfortable

00:02:03.200 --> 00:02:06.180
writing programs.

00:02:06.180 --> 00:02:08.900
The real theme of the course,
and what I spend most of the

00:02:08.900 --> 00:02:13.140
time on, is how to map
problems into a

00:02:13.140 --> 00:02:15.760
computational framework.

00:02:15.760 --> 00:02:18.190
There's going to be an emphasis
on scientific

00:02:18.190 --> 00:02:21.440
problems, rather than, say,
commercial problems.

00:02:21.440 --> 00:02:24.340
But there will be some talk
about some non-scientific

00:02:24.340 --> 00:02:26.090
problems as well.

00:02:26.090 --> 00:02:30.810
How to take a problem that may
not at first blush appear to

00:02:30.810 --> 00:02:34.690
be attackable with the program,
and show you how to

00:02:34.690 --> 00:02:38.090
formulate the problem in such
a way that you can use

00:02:38.090 --> 00:02:41.400
computation to get insight
into the problem.

00:02:41.400 --> 00:02:44.142
It should not take
you very long.

00:02:44.142 --> 00:02:47.750
All of the problem sets involve
programming in Python

00:02:47.750 --> 00:02:50.700
programming language, which I'll
say a little bit about

00:02:50.700 --> 00:02:52.700
later today.

00:02:52.700 --> 00:02:56.000
The first problem set,
basically, is getting Python

00:02:56.000 --> 00:02:58.880
installed on your
own computer.

00:02:58.880 --> 00:03:02.330
Most of the people will want to
just use whatever their own

00:03:02.330 --> 00:03:06.070
laptop is to do the
problem sets on.

00:03:06.070 --> 00:03:09.210
Don't get fooled by the first
two problem sets into thinking

00:03:09.210 --> 00:03:11.530
this is a gut course.

00:03:11.530 --> 00:03:12.950
It's not.

00:03:12.950 --> 00:03:17.610
It starts out gently
to lure you in.

00:03:17.610 --> 00:03:21.880
And then life gets pretty
hard pretty quickly.

00:03:21.880 --> 00:03:25.020
So don't be fooled.

00:03:25.020 --> 00:03:26.250
The quizzes--

00:03:26.250 --> 00:03:29.400
and there will be two evening
quizzes and a final--

00:03:29.400 --> 00:03:33.530
are open book open notes.

00:03:33.530 --> 00:03:36.480
When you get to be my age, you
get very sensitive about how

00:03:36.480 --> 00:03:39.140
difficult it is to
remember things.

00:03:39.140 --> 00:03:43.240
And so, we won't be asking
you to memorize stuff.

00:03:43.240 --> 00:03:46.530
The course is about solving
problems, knowing how to solve

00:03:46.530 --> 00:03:51.040
problems, not how much
you can remember.

00:03:51.040 --> 00:03:54.830
For many of you who are majoring
in biology or course

00:03:54.830 --> 00:03:58.420
20, it's going to be kind of a
shock that this course isn't

00:03:58.420 --> 00:04:01.910
about how much you can remember,
but it's about how

00:04:01.910 --> 00:04:04.220
well you can solve problems.

00:04:04.220 --> 00:04:06.200
And that's what the quizzes
are really going

00:04:06.200 --> 00:04:08.140
to be focused on.

00:04:08.140 --> 00:04:12.900
Probably the most unusual thing
about this course is the

00:04:12.900 --> 00:04:20.200
collaboration policy, which
is liberal in the extreme.

00:04:20.200 --> 00:04:23.770
You can collaborate with anybody
you want on any of the

00:04:23.770 --> 00:04:25.270
problem sets.

00:04:25.270 --> 00:04:26.570
Not on the quizzes.

00:04:26.570 --> 00:04:28.450
But on any of the
problem sets.

00:04:28.450 --> 00:04:32.090
You can work with each other,
which is what I recommend.

00:04:32.090 --> 00:04:35.020
You can work with your parents,
if one of them

00:04:35.020 --> 00:04:37.260
happens to be a software
engineer.

00:04:37.260 --> 00:04:39.690
You can work with friends
in course 6.

00:04:39.690 --> 00:04:42.780
Whatever you want to do.

00:04:42.780 --> 00:04:47.380
The goal of the problem sets
is to help you learn.

00:04:47.380 --> 00:04:51.750
What we've seen in the past is
people who are a little, shall

00:04:51.750 --> 00:04:55.500
I say too collaborative, i.e.
they just copy the problem set

00:04:55.500 --> 00:04:59.840
from somebody else, live in a
fool's paradise which comes

00:04:59.840 --> 00:05:03.150
crashing down at
the first quiz.

00:05:03.150 --> 00:05:06.130
People who don't spend enough
time thinking about the

00:05:06.130 --> 00:05:11.560
problem sets themselves cannot
take the quizzes successfully.

00:05:11.560 --> 00:05:15.510
So it's a fine line.

00:05:15.510 --> 00:05:19.570
But our goal is not
to be policemen.

00:05:19.570 --> 00:05:24.150
I tell my TAs, their job is to
help you learn, not to prevent

00:05:24.150 --> 00:05:26.540
you from, quote, cheating.

00:05:26.540 --> 00:05:29.480
So to solve that problem, we've
eliminated the concept

00:05:29.480 --> 00:05:31.580
of cheating on problem sets.

00:05:31.580 --> 00:05:34.230
There is no way to cheat
on problem sets.

00:05:34.230 --> 00:05:36.740
So just go and do them.

00:05:36.740 --> 00:05:38.830
There's no textbook.

00:05:38.830 --> 00:05:42.990
We will be posting readings
on the web.

00:05:42.990 --> 00:05:46.480
For the most part, these will
be pointers to websites.

00:05:46.480 --> 00:05:47.900
Occasionally we'll
post readings

00:05:47.900 --> 00:05:52.030
that we wrote ourselves.

00:05:52.030 --> 00:05:54.530
Doesn't mean you shouldn't
buy a textbook.

00:05:54.530 --> 00:05:58.690
In fact, there are a number
of Python texts.

00:05:58.690 --> 00:06:00.490
We'll recommend a few of them.

00:06:00.490 --> 00:06:04.020
It might make sense to buy one
and bring it to a quiz,

00:06:04.020 --> 00:06:06.250
because it will have an index
that will let you look things

00:06:06.250 --> 00:06:08.350
up quickly, that
sort of thing.

00:06:08.350 --> 00:06:11.320
But again, a lot of students
never buy a

00:06:11.320 --> 00:06:15.550
text and do just fine.

00:06:15.550 --> 00:06:17.780
We will not be handing
out class notes

00:06:17.780 --> 00:06:19.910
on a regular basis.

00:06:19.910 --> 00:06:23.680
A lot of studies have indicated
that students learn

00:06:23.680 --> 00:06:25.780
more when they take their own
notes than when they are

00:06:25.780 --> 00:06:27.400
handed out.

00:06:27.400 --> 00:06:30.600
And so, as a matter of what I
think is good pedagogy, we

00:06:30.600 --> 00:06:34.220
don't hand out detailed
lecture notes.

00:06:34.220 --> 00:06:39.360
We will be using, after today, a
lot of handouts with code on

00:06:39.360 --> 00:06:41.990
them, which we'll
make available.

00:06:41.990 --> 00:06:45.640
But it's not intended to make
any sense outside the context

00:06:45.640 --> 00:06:46.930
of lectures.

00:06:46.930 --> 00:06:48.710
It's not self-contained.

00:06:48.710 --> 00:06:52.120
The main purpose of this course
is to help you become

00:06:52.120 --> 00:06:55.220
skillful in making the
computer do what

00:06:55.220 --> 00:06:57.690
you want it to do.

00:06:57.690 --> 00:07:02.120
Once you acquire this skill,
your first instinct, when

00:07:02.120 --> 00:07:06.090
confronted with many tasks, will
be to write a program to

00:07:06.090 --> 00:07:09.370
do that task for you.

00:07:09.370 --> 00:07:13.030
I always tell people I became
a computer scientist in part

00:07:13.030 --> 00:07:15.010
because I'm lazy.

00:07:15.010 --> 00:07:18.230
And there was a lot of stuff
that I found it was easier to

00:07:18.230 --> 00:07:19.940
write a program to make
the computer do it,

00:07:19.940 --> 00:07:21.990
rather than do it myself.

00:07:21.990 --> 00:07:23.220
So I do that a lot.

00:07:23.220 --> 00:07:26.210
If I need to do something, I
say, can I just write a quick

00:07:26.210 --> 00:07:27.940
program to do it?

00:07:27.940 --> 00:07:30.810
And I'd like you to be able
to acquire that skill.

00:07:34.440 --> 00:07:39.020
And remember, that programming
is actually a lot of fun.

00:07:39.020 --> 00:07:41.810
So I should say that, in
addition to learning a lot in

00:07:41.810 --> 00:07:45.900
this course, I hope most of
you will find it fun.

00:07:45.900 --> 00:07:47.820
Kind of a strange thought.

00:07:47.820 --> 00:07:49.485
MIT course, fun.

00:07:52.070 --> 00:07:54.950
Maybe it's an oxymoron.

00:07:54.950 --> 00:07:56.540
But I don't think so.

00:07:56.540 --> 00:07:59.450
I really do think you can have
a lot of fun writing programs

00:07:59.450 --> 00:08:02.380
for this course.

00:08:02.380 --> 00:08:05.800
There are many people
who believe that--

00:08:05.800 --> 00:08:08.740
how shall I say this?

00:08:08.740 --> 00:08:10.660
Programming is the most
fun you can have with

00:08:10.660 --> 00:08:11.910
your clothes on.

00:08:15.880 --> 00:08:18.410
It really can be a lot of fun.

00:08:18.410 --> 00:08:21.200
So think of it that way.

00:08:21.200 --> 00:08:23.080
All right.

00:08:23.080 --> 00:08:26.430
So the primary knowledge you're
going to take away is

00:08:26.430 --> 00:08:29.720
computational problem solving.

00:08:29.720 --> 00:08:33.010
So to start with, we might
ask the question, what is

00:08:33.010 --> 00:08:35.210
computation?

00:08:35.210 --> 00:08:37.940
And to think about that--

00:08:37.940 --> 00:08:39.442
this is interesting.

00:08:39.442 --> 00:08:42.490
Ah, there's where
the chalk is.

00:08:42.490 --> 00:08:45.960
I was afraid I was going to be
confronted with a sea of black

00:08:45.960 --> 00:08:49.770
boards and erasers
and no chalk.

00:08:49.770 --> 00:08:52.840
But there is chalk.

00:08:52.840 --> 00:08:55.990
So if we think about it,
there are essentially

00:08:55.990 --> 00:08:57.240
two kinds of knowledge.

00:09:01.540 --> 00:09:03.520
Declarative--

00:09:03.520 --> 00:09:05.190
and you're going to see, I'm
not a great speller.

00:09:09.500 --> 00:09:10.750
And imperative.

00:09:18.750 --> 00:09:22.450
Declarative knowledge
is composed of

00:09:22.450 --> 00:09:25.120
statements of fact.

00:09:25.120 --> 00:09:29.260
For example, a good health care
plan improves the quality

00:09:29.260 --> 00:09:31.250
of medical care while
saving money.

00:09:33.750 --> 00:09:37.490
As we know from doings in
Washington, it's a lot easier

00:09:37.490 --> 00:09:41.680
to state that goal than to know
how to achieve that goal.

00:09:41.680 --> 00:09:44.090
So the key thing about
declarative knowledge is, it

00:09:44.090 --> 00:09:46.390
says something that is true.

00:09:46.390 --> 00:09:49.340
Otherwise it wouldn't be
knowledge, it would be

00:09:49.340 --> 00:09:50.900
misinformation.

00:09:50.900 --> 00:09:54.030
But doesn't tell you
how to do it.

00:09:54.030 --> 00:09:59.140
In a more mathematical sense,
say y is the square root of x

00:09:59.140 --> 00:10:04.600
if and only if y times
y equals x.

00:10:04.600 --> 00:10:05.560
All right?

00:10:05.560 --> 00:10:08.450
Perfectly clear statement of
what it means to be the square

00:10:08.450 --> 00:10:15.280
root, but it doesn't tell you
how to find the square root.

00:10:15.280 --> 00:10:20.230
Interestingly enough, it does
tell you how to test whether

00:10:20.230 --> 00:10:24.250
or not you have the answer
to the square root.

00:10:24.250 --> 00:10:29.670
And so if you had some way of
generating guesses, you can at

00:10:29.670 --> 00:10:32.780
least check whether
they're correct.

00:10:32.780 --> 00:10:36.710
And in fact, starting in the
next lecture, we'll talk about

00:10:36.710 --> 00:10:41.100
the fact that a lot of
computational techniques

00:10:41.100 --> 00:10:44.030
involve something called
guess and check.

00:10:44.030 --> 00:10:46.530
Where you have a way to generate
guesses and a way to

00:10:46.530 --> 00:10:47.780
check whether they're right.

00:10:52.230 --> 00:10:57.580
Imperative knowledge, in
contrast, tells you how to

00:10:57.580 --> 00:10:58.980
solve a problem.

00:10:58.980 --> 00:11:01.670
How to accomplish something.

00:11:01.670 --> 00:11:05.290
So you could think of it as like
a recipe in a cookbook.

00:11:05.290 --> 00:11:08.150
So it's one thing to say a
chocolate cake is something

00:11:08.150 --> 00:11:11.070
that tastes delicious
and is bad for you.

00:11:11.070 --> 00:11:13.830
That's declarative knowledge.

00:11:13.830 --> 00:11:16.380
But you can open a cookbook and
get a recipe that tells

00:11:16.380 --> 00:11:18.740
you how to make a
chocolate cake.

00:11:18.740 --> 00:11:22.130
That's imperative knowledge.

00:11:22.130 --> 00:11:28.700
Now, below, we have a recipe for
finding not a square root

00:11:28.700 --> 00:11:30.390
necessarily, but an

00:11:30.390 --> 00:11:33.280
approximation to a square root.

00:11:33.280 --> 00:11:37.830
And one of the themes of this
course is that a lot of

00:11:37.830 --> 00:11:43.300
problems we cannot solve
precisely, but we can find

00:11:43.300 --> 00:11:48.110
answers that are good enough
for practical purposes.

00:11:48.110 --> 00:11:51.840
And those are called
approximation algorithms.

00:11:51.840 --> 00:11:53.440
So here's a way--

00:11:53.440 --> 00:11:57.870
this is a very old method for
finding the square root.

00:11:57.870 --> 00:12:02.600
In fact, it's believed
that Heron was

00:12:02.600 --> 00:12:04.270
the one who did this.

00:12:04.270 --> 00:12:05.520
Heron of Alexandria.

00:12:08.680 --> 00:12:11.690
In the news much today,
Alexandria was the capital of

00:12:11.690 --> 00:12:12.940
ancient Egypt.

00:12:15.460 --> 00:12:17.300
He was the first one to
write this method

00:12:17.300 --> 00:12:21.200
down a long time ago.

00:12:21.200 --> 00:12:24.320
Though it's believed that even
before Heron, the Babylonians

00:12:24.320 --> 00:12:25.870
know how to do it.

00:12:25.870 --> 00:12:29.790
So you start with a guess, g.

00:12:29.790 --> 00:12:32.350
Any old guess will do.

00:12:32.350 --> 00:12:37.240
Then you say, is g times
g close enough to x?

00:12:37.240 --> 00:12:38.540
If so, you stop.

00:12:38.540 --> 00:12:43.370
Say OK, I've got a good enough
approximation of the answer.

00:12:43.370 --> 00:12:50.740
If it's not, you create a new
guess by averaging g and x

00:12:50.740 --> 00:12:52.810
divided by g.

00:12:52.810 --> 00:12:58.450
So g new is going to be
g old plus x divided

00:12:58.450 --> 00:13:01.690
by g old, over 2.

00:13:01.690 --> 00:13:07.390
And then using this new guess,
you go back to step 2.

00:13:07.390 --> 00:13:10.790
So let's quickly run through
an example of this.

00:13:10.790 --> 00:13:15.910
We can start with this
pretty easily.

00:13:15.910 --> 00:13:16.930
We'll take a guess.

00:13:16.930 --> 00:13:19.435
Let's say g equals 3.

00:13:23.090 --> 00:13:25.160
So we look at three times 3.

00:13:30.220 --> 00:13:31.210
9.

00:13:31.210 --> 00:13:34.910
And we say, is that
good enough?

00:13:34.910 --> 00:13:37.375
Well, let's say we're looking
for the root of 25.

00:13:41.120 --> 00:13:43.480
I guess I should have started
with the problem statement.

00:13:43.480 --> 00:13:45.580
Sorry about that.

00:13:45.580 --> 00:13:49.640
Well, 9 is probably not close
enough to 25 that we're happy.

00:13:49.640 --> 00:13:52.150
May be good enough for
government work, but not for

00:13:52.150 --> 00:13:54.570
most other purposes.

00:13:54.570 --> 00:14:09.100
So we'll reset g, and we'll
set g to 3 plus 25 over 3.

00:14:09.100 --> 00:14:10.350
All of that over 2.

00:14:12.810 --> 00:14:20.050
Which equals 5.6666 et cetera.

00:14:20.050 --> 00:14:20.420
All right.

00:14:20.420 --> 00:14:29.990
So now we'll multiply
that by itself.

00:14:29.990 --> 00:14:37.000
And that gets to
be about 32.04.

00:14:37.000 --> 00:14:39.070
Close enough to 25?

00:14:39.070 --> 00:14:40.320
Probably not.

00:14:42.730 --> 00:14:46.610
So we'll take another step.

00:14:46.610 --> 00:14:48.230
And we'll set g equal to--

00:14:52.210 --> 00:14:55.510
well, when we're done with it
all, I'm not going to bore you

00:14:55.510 --> 00:14:57.600
with writing the
formula again.

00:14:57.600 --> 00:15:00.980
It'll be 5.04.

00:15:00.980 --> 00:15:05.300
If we square that, it's 25.4.

00:15:05.300 --> 00:15:09.000
We decide that's close enough
to 25, and we're done.

00:15:13.940 --> 00:15:19.220
What we say at this point
is that the algorithm--

00:15:19.220 --> 00:15:20.470
and that's an important word.

00:15:30.260 --> 00:15:33.550
An algorithm is a description
of how to perform a

00:15:33.550 --> 00:15:34.800
computation.

00:15:50.980 --> 00:15:54.280
We say that the algorithm
has converged.

00:15:59.630 --> 00:16:02.205
Which is a fancy way
to say it's halted.

00:16:08.150 --> 00:16:14.150
What we've got here, if you
think about it, is a set of

00:16:14.150 --> 00:16:15.400
instructions.

00:16:21.270 --> 00:16:27.325
Steps that can be executed
and a flow of control.

00:16:33.120 --> 00:16:36.200
The order in which
we execute them.

00:16:36.200 --> 00:16:41.340
So if we look at this, there's a
default order of execution--

00:16:41.340 --> 00:16:43.490
1, 2, 3, 4.

00:16:43.490 --> 00:16:48.590
But then there's the go back
to step 2 and start over.

00:16:54.030 --> 00:16:57.905
And there's a termination
condition.

00:17:09.109 --> 00:17:12.849
It tells us when to stop.

00:17:12.849 --> 00:17:15.310
And of course, that's
important.

00:17:15.310 --> 00:17:18.240
I've always been amused, if you
look at a shampoo bottle,

00:17:18.240 --> 00:17:21.260
you'll see an algorithm that
says something like lather,

00:17:21.260 --> 00:17:23.660
rinse, repeat.

00:17:23.660 --> 00:17:25.829
And if you follow it
literally, you

00:17:25.829 --> 00:17:27.960
never get to stop.

00:17:27.960 --> 00:17:30.320
Which I suppose make sense if
you're selling shampoo,

00:17:30.320 --> 00:17:32.480
because people use
a lot of it.

00:17:32.480 --> 00:17:34.490
But really, there
ought to be some

00:17:34.490 --> 00:17:38.220
termination condition there.

00:17:38.220 --> 00:17:39.350
OK.

00:17:39.350 --> 00:17:43.130
So now, how do we capture this
idea of a recipe in a

00:17:43.130 --> 00:17:46.110
mechanical process?

00:17:46.110 --> 00:17:50.390
One way would be to design a
machine specifically to do

00:17:50.390 --> 00:17:53.490
square roots.

00:17:53.490 --> 00:17:58.460
So if I knew how to design
circuits, which I don't, I

00:17:58.460 --> 00:18:01.980
could sit down-- probably many
of you could sit down--

00:18:01.980 --> 00:18:03.340
and design a circuit that would

00:18:03.340 --> 00:18:04.590
implement this algorithm.

00:18:06.990 --> 00:18:10.410
And in fact, that's more or
less what you'll find in a

00:18:10.410 --> 00:18:14.080
cheap four function calculator
that does square roots.

00:18:14.080 --> 00:18:17.890
Not quite this algorithm, but
a similar algorithm is just

00:18:17.890 --> 00:18:23.220
part of the circuitry
to go compute that.

00:18:23.220 --> 00:18:26.830
And in fact, this used
to be the way that

00:18:26.830 --> 00:18:29.820
all computers worked.

00:18:29.820 --> 00:18:34.730
So the initial computers
were what are called

00:18:34.730 --> 00:18:36.123
fixed program computers.

00:18:44.160 --> 00:18:49.020
They were designed to do very
specific things, and that's

00:18:49.020 --> 00:18:51.220
what they did.

00:18:51.220 --> 00:18:54.680
So for example, one of the very
first computers, designed

00:18:54.680 --> 00:19:00.590
in 1941, by Atanasoff and
Berry, solved systems of

00:19:00.590 --> 00:19:05.750
linear equations for the purpose
of plotting artillery

00:19:05.750 --> 00:19:08.180
trajectories.

00:19:08.180 --> 00:19:10.540
And that's all it did.

00:19:10.540 --> 00:19:12.740
If you wanted to balance your
bank account with this

00:19:12.740 --> 00:19:14.440
computer, you couldn't do it.

00:19:14.440 --> 00:19:16.420
But you could figure
out how to drop an

00:19:16.420 --> 00:19:19.570
artillery shell somewhere.

00:19:19.570 --> 00:19:23.830
Also during World War II, Alan
Turing built a machine

00:19:23.830 --> 00:19:26.560
specifically designed
for breaking the

00:19:26.560 --> 00:19:28.810
German enigma code.

00:19:28.810 --> 00:19:33.680
Actually a fascinating story of
science how that was built.

00:19:33.680 --> 00:19:35.590
But again, that was
all it could do.

00:19:39.020 --> 00:19:43.780
These computers were useful,
but only in a

00:19:43.780 --> 00:19:46.370
very limited way.

00:19:46.370 --> 00:19:49.990
The big breakthrough, the thing
it made computation

00:19:49.990 --> 00:19:54.440
really important to society,
was the invention of the

00:19:54.440 --> 00:19:55.810
stored program computer.

00:20:09.590 --> 00:20:12.350
It took people quite a while
to figure this out.

00:20:12.350 --> 00:20:15.350
But once they did,
it seems obvious.

00:20:15.350 --> 00:20:20.580
The basic notion of a stored
program computer is that the

00:20:20.580 --> 00:20:25.600
instructions are the
same as data.

00:20:25.600 --> 00:20:28.770
So now, there is no distinction
between the

00:20:28.770 --> 00:20:33.980
program that implements the
algorithm and the data on

00:20:33.980 --> 00:20:37.830
which that program operates.

00:20:37.830 --> 00:20:46.130
So there's no difference between
the input of 25, part

00:20:46.130 --> 00:20:52.890
of the data, and the steps of
the algorithm used to do that.

00:20:55.540 --> 00:20:58.640
Once that was possible,
the machines

00:20:58.640 --> 00:21:02.460
became infinitely flexible.

00:21:02.460 --> 00:21:06.120
You could change the program
anytime you wanted.

00:21:06.120 --> 00:21:11.580
And furthermore, programs
could produce programs.

00:21:11.580 --> 00:21:14.660
Because programs can
produce data.

00:21:14.660 --> 00:21:17.440
And if program and data are
the same thing, that means

00:21:17.440 --> 00:21:19.850
programs can produce programs.

00:21:19.850 --> 00:21:21.980
And we were off and running.

00:21:21.980 --> 00:21:25.390
And that's really what made
computers what they are today.

00:21:28.260 --> 00:21:36.840
Once this became clear as the
paradigm for computers, people

00:21:36.840 --> 00:21:40.340
began to think of the computer
itself as a program.

00:21:43.220 --> 00:21:46.140
And in particular, as a kind
of program called an

00:21:46.140 --> 00:21:47.390
interpreter.

00:21:49.270 --> 00:21:53.560
And we'll get to more
on this later today.

00:21:53.560 --> 00:21:59.530
An interpreter is a program that
can execute any legal set

00:21:59.530 --> 00:22:02.290
of instructions.

00:22:02.290 --> 00:22:07.860
And consequently, can be used
to describe and accomplish

00:22:07.860 --> 00:22:10.890
anything you can do
with a computer.

00:22:10.890 --> 00:22:13.950
So roughly speaking, this is
what a stored program computer

00:22:13.950 --> 00:22:15.570
looks like.

00:22:15.570 --> 00:22:19.670
This is 6004 in 40 seconds.

00:22:19.670 --> 00:22:22.010
It's got memory.

00:22:22.010 --> 00:22:25.050
Lots of it today.

00:22:25.050 --> 00:22:29.680
A control unit that basically
tells it what to do.

00:22:29.680 --> 00:22:33.340
For example, fetch some data
from memory, put some data

00:22:33.340 --> 00:22:38.350
into memory, send some output
to a screen, all of those

00:22:38.350 --> 00:22:40.090
kinds of things.

00:22:40.090 --> 00:22:43.880
What for historical reasons we
call the arithmetic logic

00:22:43.880 --> 00:22:47.630
unit, this is, in some sense,
the brains of the computer.

00:22:47.630 --> 00:22:51.570
The thing that actually
does computations.

00:22:51.570 --> 00:22:54.390
An accumulator, which
is part of the

00:22:54.390 --> 00:22:56.710
ALU that stores results.

00:22:56.710 --> 00:22:59.820
And a bunch of input
and output devices.

00:22:59.820 --> 00:23:03.340
The things that we actually see
when we use a computer.

00:23:03.340 --> 00:23:05.380
And that's it.

00:23:05.380 --> 00:23:08.840
And again, the key thing to
notice is, there's only one

00:23:08.840 --> 00:23:10.130
kind of memory.

00:23:10.130 --> 00:23:13.100
There's not a memory for program
and a memory for data.

00:23:13.100 --> 00:23:14.840
There's just the memory.

00:23:18.160 --> 00:23:23.560
The nice thing to think about
here is, given a small set of

00:23:23.560 --> 00:23:28.130
instructions, you can
then build any kind

00:23:28.130 --> 00:23:29.870
of program you want.

00:23:29.870 --> 00:23:35.150
So typically, the computers have
a very small number of

00:23:35.150 --> 00:23:37.880
built-in instructions.

00:23:37.880 --> 00:23:41.880
Order of dozens,
and that's it.

00:23:41.880 --> 00:23:44.890
And by combining those
instructions in very clever

00:23:44.890 --> 00:23:49.890
ways, you can do arbitrarily
complex things.

00:23:49.890 --> 00:23:53.630
In much the same way a good
chef can take a very small

00:23:53.630 --> 00:23:56.885
number of ingredients, and from
those, produce a variety

00:23:56.885 --> 00:24:01.240
of interesting edibles.

00:24:01.240 --> 00:24:04.690
Alan Turing, in the 1930s--

00:24:04.690 --> 00:24:07.950
very famous British
mathematician of whom you will

00:24:07.950 --> 00:24:09.530
hear more--

00:24:09.530 --> 00:24:13.330
showed that, in fact, there
were six primitive

00:24:13.330 --> 00:24:15.630
instructions.

00:24:15.630 --> 00:24:21.330
Each of which operated on
one bit of information.

00:24:21.330 --> 00:24:24.610
And with those six primitive
instructions, you could do

00:24:24.610 --> 00:24:27.600
anything that could be
done with a computer.

00:24:27.600 --> 00:24:29.810
Kind of amazing.

00:24:29.810 --> 00:24:31.000
It was six instructions.

00:24:31.000 --> 00:24:36.100
There were things like
read, write, plus--

00:24:36.100 --> 00:24:37.110
I don't know, maybe minus.

00:24:37.110 --> 00:24:38.600
I forget what they were.

00:24:38.600 --> 00:24:39.220
And that was it.

00:24:39.220 --> 00:24:41.750
That's all you needed.

00:24:41.750 --> 00:24:44.210
We will not make you write
programs using only six

00:24:44.210 --> 00:24:44.520
instructions.

00:24:44.520 --> 00:24:47.240
We will give you a
much larger set.

00:24:47.240 --> 00:24:52.180
But still, it's really
quite remarkable.

00:24:52.180 --> 00:24:57.470
It's what makes programming
such an amazing endeavor.

00:24:57.470 --> 00:24:59.230
OK.

00:24:59.230 --> 00:25:02.590
So what instructions
will you be using?

00:25:02.590 --> 00:25:05.840
Well, that's what a programming
language does.

00:25:05.840 --> 00:25:11.000
So a programming language
provides a set of primitive

00:25:11.000 --> 00:25:13.630
instructions.

00:25:13.630 --> 00:25:18.660
A set of primitive control
structures.

00:25:18.660 --> 00:25:23.110
So instructions and mechanisms
for controlling the order in

00:25:23.110 --> 00:25:25.680
which they get executed.

00:25:25.680 --> 00:25:28.090
And that's all.

00:25:28.090 --> 00:25:30.620
And then you can do whatever
you want with them.

00:25:30.620 --> 00:25:33.330
And what distinguishes one
programming language from

00:25:33.330 --> 00:25:36.440
another is what these
things are.

00:25:36.440 --> 00:25:38.210
What are your instructions?

00:25:38.210 --> 00:25:40.520
What of your flow of control?

00:25:40.520 --> 00:25:42.810
And how do you combine them?

00:25:42.810 --> 00:25:45.780
What are the combining
mechanisms?

00:25:45.780 --> 00:25:48.530
And in fact, it's the combining
mechanisms more than

00:25:48.530 --> 00:25:52.080
anything else that separate
one language from another.

00:25:55.800 --> 00:26:00.000
The most amazing thing
about programming--

00:26:00.000 --> 00:26:03.270
and this has its good side and
its bad side, and it's

00:26:03.270 --> 00:26:06.900
something you need to remember
as you do the problem sets--

00:26:06.900 --> 00:26:11.730
is that the computer will always
do exactly what you

00:26:11.730 --> 00:26:14.020
tell what to do.

00:26:14.020 --> 00:26:15.300
It's remarkable.

00:26:15.300 --> 00:26:17.210
You don't have any friends
who will do whatever you

00:26:17.210 --> 00:26:19.920
tell them to do.

00:26:19.920 --> 00:26:22.110
I can tell you my children
certainly don't do whatever I

00:26:22.110 --> 00:26:23.980
tell them to do.

00:26:23.980 --> 00:26:27.610
And my wife doesn't either.

00:26:27.610 --> 00:26:30.090
Sometimes she probably
thinks I do whatever

00:26:30.090 --> 00:26:31.610
she tells me to do.

00:26:31.610 --> 00:26:35.540
But a computer will do what
you tell it to do.

00:26:35.540 --> 00:26:38.510
So that's very empowering.

00:26:38.510 --> 00:26:40.960
It's also very annoying.

00:26:40.960 --> 00:26:43.800
Because it means if your program
doesn't work, it's

00:26:43.800 --> 00:26:45.820
your own darn fault.

00:26:45.820 --> 00:26:49.040
You got nobody else to
blame but yourself.

00:26:49.040 --> 00:26:51.360
Because it's not the
computer's fault.

00:26:51.360 --> 00:26:54.060
You may want to curse the
computer, but you shouldn't.

00:26:54.060 --> 00:26:56.620
It's just doing what
you told it to.

00:26:56.620 --> 00:27:00.700
So be careful what
you wish for.

00:27:00.700 --> 00:27:01.250
All right.

00:27:01.250 --> 00:27:05.200
The programming language we're
going to use in 600 is Python.

00:27:18.130 --> 00:27:20.530
It's a relatively recent
addition to

00:27:20.530 --> 00:27:23.710
the universe of languages.

00:27:23.710 --> 00:27:27.020
I want to emphasize that
this course is not

00:27:27.020 --> 00:27:29.150
about learning Python.

00:27:29.150 --> 00:27:33.150
I will spend relatively little
time in the lectures telling

00:27:33.150 --> 00:27:35.270
you about Python.

00:27:35.270 --> 00:27:39.260
It's about computational
methods, is what this course

00:27:39.260 --> 00:27:40.420
is really about.

00:27:40.420 --> 00:27:42.660
And Python is merely
a teaching tool.

00:27:45.870 --> 00:27:49.910
Once you learn to program in
Python, it's easy to learn to

00:27:49.910 --> 00:27:51.370
program in another language.

00:27:51.370 --> 00:27:54.400
It's a very easily transferable
skill.

00:27:57.220 --> 00:28:03.060
If we think about what defines
any programming language, it's

00:28:03.060 --> 00:28:17.206
got a syntax, a static
semantics, and a semantics.

00:28:25.020 --> 00:28:26.445
Are any of you here linguistics
majors?

00:28:29.110 --> 00:28:29.640
Not a one.

00:28:29.640 --> 00:28:30.230
All right.

00:28:30.230 --> 00:28:32.710
Then I can make up whatever I
want about these terms and

00:28:32.710 --> 00:28:34.580
maybe you'll believe me.

00:28:34.580 --> 00:28:36.140
All right.

00:28:36.140 --> 00:28:43.510
So the syntax tells us which
sequences of characters and

00:28:43.510 --> 00:28:46.710
symbols constitute a
well-formed string.

00:28:52.220 --> 00:28:56.470
So it would tell us, maybe, that
we could write something

00:28:56.470 --> 00:29:03.875
like x equals 3 plus 4.

00:29:06.570 --> 00:29:09.070
And that's syntactically
correct.

00:29:09.070 --> 00:29:10.850
It's well-formed.

00:29:10.850 --> 00:29:16.920
It might also tell us that
x equals 3 blank 4 is not

00:29:16.920 --> 00:29:18.700
syntactically correct.

00:29:18.700 --> 00:29:20.175
It's not a legal string.

00:29:22.750 --> 00:29:28.340
So by analogy with English,
the syntax describes which

00:29:28.340 --> 00:29:31.995
strings of words constitute
well-formed sentences.

00:29:36.230 --> 00:29:38.010
Well-formed.

00:29:38.010 --> 00:29:41.270
Not necessarily meaningful.

00:29:41.270 --> 00:29:48.100
So it would tell you that some
sentence like Susan is

00:29:48.100 --> 00:29:52.130
building is syntactically
well-formed.

00:29:52.130 --> 00:29:53.445
It may not be very sensible.

00:29:57.180 --> 00:30:02.020
The static semantics tells
us which well-formed

00:30:02.020 --> 00:30:05.870
strings have a meaning.

00:30:05.870 --> 00:30:07.480
That are which strings
are meaningful.

00:30:11.530 --> 00:30:16.430
So you can think about that
as also making sense.

00:30:16.430 --> 00:30:24.790
So in Python, it might tell us
that some strings which are

00:30:24.790 --> 00:30:28.620
syntactically fine don't
mean anything.

00:30:28.620 --> 00:30:34.210
So for example, it might tell
us that the string 3 divided

00:30:34.210 --> 00:30:40.490
by the character string abc is
syntactically well-formed

00:30:40.490 --> 00:30:47.120
because it's value
operator value.

00:30:47.120 --> 00:30:49.960
Sort of like noun verb
noun is syntactically

00:30:49.960 --> 00:30:51.620
well-formed in English.

00:30:51.620 --> 00:30:54.370
But it would tell us
that there's no

00:30:54.370 --> 00:30:55.450
real meaning to this.

00:30:55.450 --> 00:31:00.070
Dividing a number by a string
doesn't mean anything.

00:31:00.070 --> 00:31:03.870
And so you would get an error
message saying the syntax is

00:31:03.870 --> 00:31:07.105
OK, but the static semantics
is broken.

00:31:10.710 --> 00:31:16.780
So for example, in English ,
the sentence I are big is

00:31:16.780 --> 00:31:20.520
somehow syntactically
well-formed--

00:31:20.520 --> 00:31:21.870
noun verb noun--

00:31:21.870 --> 00:31:26.880
but we might say it fails the
static semantic test.

00:31:26.880 --> 00:31:30.930
We don't want to assign
a meaning to it.

00:31:30.930 --> 00:31:35.300
The semantics of the language
looks only at the strings that

00:31:35.300 --> 00:31:39.350
are both syntactically correct
and static semantically

00:31:39.350 --> 00:31:44.880
correct, and assigns a
real meaning to them.

00:31:44.880 --> 00:31:50.440
In natural language, sentences
can be ambiguous.

00:31:50.440 --> 00:31:53.270
So one of my favorites, when I
have to write a recommendation

00:31:53.270 --> 00:31:56.560
letter for a student that maybe
I don't think is so

00:31:56.560 --> 00:31:59.710
good, I might say something
like I cannot praise this

00:31:59.710 --> 00:32:02.190
student too highly.

00:32:02.190 --> 00:32:06.390
Well, you can interpret
that however you want.

00:32:06.390 --> 00:32:10.990
It keeps me from getting sued,
but I can also claim, well, I

00:32:10.990 --> 00:32:13.270
don't like the student at all.

00:32:13.270 --> 00:32:15.930
And English is full
of those things.

00:32:15.930 --> 00:32:20.410
Programming languages, in
contrast, are designed so that

00:32:20.410 --> 00:32:26.170
every well-formed program
has exactly one meaning.

00:32:26.170 --> 00:32:27.420
There's no ambiguity.

00:32:29.790 --> 00:32:33.510
So you can't typically
talk of a program as

00:32:33.510 --> 00:32:34.935
having a semantic error.

00:32:37.660 --> 00:32:39.690
If it is well-formed, it
means something, and

00:32:39.690 --> 00:32:42.110
that's what it means.

00:32:42.110 --> 00:32:46.120
On the other hand, it's easy
to talk about a program

00:32:46.120 --> 00:32:49.730
meaning something other than
you wanted it to mean.

00:32:49.730 --> 00:32:53.220
And you will discover in the
problem sets, most of the time

00:32:53.220 --> 00:32:56.550
the programs don't mean what
you want them to mean.

00:32:56.550 --> 00:32:58.920
That is to say, when you run
them, they don't give you the

00:32:58.920 --> 00:33:00.580
correct answer.

00:33:00.580 --> 00:33:03.030
And then you will go through
this process of debugging them

00:33:03.030 --> 00:33:05.460
and learning how to do it.

00:33:05.460 --> 00:33:10.280
So what might happen when we
write a program that doesn't

00:33:10.280 --> 00:33:13.870
do what we want it to do?

00:33:13.870 --> 00:33:15.120
It might crash.

00:33:19.600 --> 00:33:23.660
By that, we mean stop running
and produce some palpable

00:33:23.660 --> 00:33:27.030
indication that it
has done so.

00:33:27.030 --> 00:33:30.830
So you've all used programs
that have crashed, right?

00:33:30.830 --> 00:33:35.400
You sat there using your email
program or Word, or

00:33:35.400 --> 00:33:37.150
PowerPoint, or something.

00:33:37.150 --> 00:33:38.940
And suddenly, it
just goes away.

00:33:38.940 --> 00:33:43.650
And you get a message on your
screen and an invitation to

00:33:43.650 --> 00:33:49.050
send Apple or Microsoft a file
explaining what went wrong so

00:33:49.050 --> 00:33:50.300
they can fix it.

00:33:53.820 --> 00:33:57.480
In a properly designed computing
system, when one

00:33:57.480 --> 00:34:00.915
program crashes, it does not
damage the overall system.

00:34:03.430 --> 00:34:06.500
So you'd like it to
just be local.

00:34:06.500 --> 00:34:09.050
What else might it do?

00:34:09.050 --> 00:34:10.600
It might never stop.

00:34:21.170 --> 00:34:24.449
Now, if you have no idea how
long a program is supposed to

00:34:24.449 --> 00:34:26.839
run, this can be hard
to diagnose.

00:34:29.710 --> 00:34:31.690
But again, I'm sure you've
all run into this.

00:34:31.690 --> 00:34:33.260
I've certainly run into it.

00:34:33.260 --> 00:34:35.560
Every once in a while I'll
say, try and write a

00:34:35.560 --> 00:34:37.300
PowerPoint file.

00:34:37.300 --> 00:34:39.830
And it'll just sit there.

00:34:39.830 --> 00:34:42.639
Or I'll try to read a file and
it'll just sit there and never

00:34:42.639 --> 00:34:44.449
finish the job.

00:34:44.449 --> 00:34:46.940
Or I don't have enough
patience.

00:34:46.940 --> 00:34:50.020
But probably it would never
have finished it.

00:34:50.020 --> 00:34:53.409
Again, you will all write
programs that do this.

00:34:53.409 --> 00:34:56.889
It's a good idea to know how
long you expect your programs

00:34:56.889 --> 00:35:00.380
to run, so that you can
recognize this.

00:35:00.380 --> 00:35:03.010
Typically, we say that these
programs have in them an

00:35:03.010 --> 00:35:04.260
infinite loop.

00:35:09.250 --> 00:35:13.090
And we'll talk about that when
we get to flow of control.

00:35:13.090 --> 00:35:28.530
Finally, a program might run to
completion and produce the

00:35:28.530 --> 00:35:29.780
wrong answer.

00:35:38.760 --> 00:35:42.680
These problems are kind of in
ascending order of badness.

00:35:46.310 --> 00:35:48.360
If it crashes, at least
you know that

00:35:48.360 --> 00:35:51.770
something has gone wrong.

00:35:51.770 --> 00:35:55.050
An infinite loop can be very
annoying, because you just

00:35:55.050 --> 00:35:56.530
wait for a long time.

00:35:56.530 --> 00:35:58.590
But the worst thing that happens
is when you think

00:35:58.590 --> 00:36:00.665
everything is good
and it's not.

00:36:03.230 --> 00:36:05.840
There have been lots of
examples of this.

00:36:05.840 --> 00:36:08.695
This is the sort of thing
that costs lives.

00:36:11.380 --> 00:36:15.780
There was a radiation therapy
machine that produced the

00:36:15.780 --> 00:36:21.650
wrong dosage of radiation and
actually killed quite a few

00:36:21.650 --> 00:36:25.270
people, because they put in
the correct input, and it

00:36:25.270 --> 00:36:28.220
would dose the patient
with radiation.

00:36:28.220 --> 00:36:32.120
And a fatal dose of radiation.

00:36:32.120 --> 00:36:35.000
That's a really bad mistake.

00:36:35.000 --> 00:36:37.710
There are buildings that
collapse because people run

00:36:37.710 --> 00:36:40.550
programs that do the structural
engineering, and

00:36:40.550 --> 00:36:43.520
the programs give the
wrong answer.

00:36:43.520 --> 00:36:45.770
Lots of bad things can happen.

00:36:45.770 --> 00:36:48.330
So one of the things we're going
to spend time on this

00:36:48.330 --> 00:36:53.750
term is, what you can do to
avoid writing programs that

00:36:53.750 --> 00:36:57.120
have this rather unpleasant
property.

00:36:57.120 --> 00:36:58.940
How do you test them?

00:36:58.940 --> 00:37:02.520
How do you write them in such
a way that this is the least

00:37:02.520 --> 00:37:04.420
likely event?

00:37:04.420 --> 00:37:06.280
That's not what you
want to happen.

00:37:09.220 --> 00:37:10.000
OK.

00:37:10.000 --> 00:37:14.620
Some programming languages
give you a lot of help in

00:37:14.620 --> 00:37:17.860
avoiding these things.

00:37:17.860 --> 00:37:21.980
Python is kind of mediocre
in that respect.

00:37:21.980 --> 00:37:23.080
It's not the best.

00:37:23.080 --> 00:37:24.920
It's not the worst.

00:37:24.920 --> 00:37:28.640
It's somewhere in the middle.

00:37:28.640 --> 00:37:33.500
Because what you'd like is a
program with very rigorous

00:37:33.500 --> 00:37:39.550
static semantics, such that if
you pass those tests, it has a

00:37:39.550 --> 00:37:44.120
high probability of behaving
as expected.

00:37:44.120 --> 00:37:47.990
So for example, it's a good
thing that Python doesn't

00:37:47.990 --> 00:37:51.290
allow you to do this.

00:37:51.290 --> 00:37:54.180
Because who knows what
that's going to do?

00:37:54.180 --> 00:37:55.520
Something weird.

00:37:55.520 --> 00:37:58.650
You'd rather be told no,
you can't write that.

00:37:58.650 --> 00:38:00.770
And then you have to write
something that's more

00:38:00.770 --> 00:38:02.390
obviously meaningful.

00:38:02.390 --> 00:38:06.510
Rather than it just making
up an interpretation.

00:38:06.510 --> 00:38:11.160
As we will see going forward,
Python is not, for example, as

00:38:11.160 --> 00:38:16.640
good as Java is at weeding
out meaningless things.

00:38:16.640 --> 00:38:19.680
Or things that have surprising
meanings.

00:38:19.680 --> 00:38:23.350
On the other hand, it's better
than C. So kind of in the

00:38:23.350 --> 00:38:27.370
middle as these programming
languages go.

00:38:27.370 --> 00:38:31.330
Why do we use Python in this
course if it's not the best in

00:38:31.330 --> 00:38:33.500
that respect?

00:38:33.500 --> 00:38:37.730
It's got several
good features.

00:38:37.730 --> 00:38:42.260
One of them is, it's
easy to learn.

00:38:42.260 --> 00:38:45.280
It's much less complicated
than, say, Java.

00:38:45.280 --> 00:38:47.390
So the learning curve
is much steeper.

00:38:47.390 --> 00:38:48.740
That's a good thing.

00:38:48.740 --> 00:38:51.910
You get up to speed faster.

00:38:51.910 --> 00:38:57.720
It's very widely used today in
a lot of areas of science,

00:38:57.720 --> 00:38:59.770
particularly the
life sciences.

00:38:59.770 --> 00:39:03.060
It has probably become the
most popular language in

00:39:03.060 --> 00:39:05.850
biology and the other
life sciences.

00:39:05.850 --> 00:39:08.220
And therefore, for those of you
who have careers in that

00:39:08.220 --> 00:39:12.830
area, it's the most useful
language to know.

00:39:12.830 --> 00:39:16.830
It's also widely used in
other areas as well.

00:39:16.830 --> 00:39:21.370
It is easier to debug
than most languages.

00:39:21.370 --> 00:39:25.380
And the reason it's easier to
debug than most languages, or

00:39:25.380 --> 00:39:29.960
than many, is it's an
interpreted language.

00:39:29.960 --> 00:39:33.050
So you'll remember, I talked
about a computer as an

00:39:33.050 --> 00:39:34.820
interpreter.

00:39:34.820 --> 00:39:39.330
Something that you feed in a
bunch of instructions, called

00:39:39.330 --> 00:39:41.620
the source code.

00:39:41.620 --> 00:39:43.780
You do some checking.

00:39:43.780 --> 00:39:46.470
And then it executes the
instructions, including the

00:39:46.470 --> 00:39:48.650
flow of control instructions.

00:39:48.650 --> 00:39:51.490
Produces some output.

00:39:51.490 --> 00:39:55.860
The nice thing that goes on
there is if something untoward

00:39:55.860 --> 00:40:00.690
happens, the interpreter can
describe in the language of

00:40:00.690 --> 00:40:04.260
the source code what
went wrong.

00:40:04.260 --> 00:40:07.700
The source code is the
code that you wrote.

00:40:07.700 --> 00:40:13.130
On the other hand, the way a
compiler works is, you take

00:40:13.130 --> 00:40:18.500
the source code, you check it,
but then you translate it into

00:40:18.500 --> 00:40:21.830
another language called
the object code.

00:40:21.830 --> 00:40:26.360
This is a language closer
to the language that the

00:40:26.360 --> 00:40:31.040
computer, the hardware, knows
how to interpret.

00:40:31.040 --> 00:40:35.520
Then the hardware interpreter
interprets the compiled code,

00:40:35.520 --> 00:40:39.050
the object code, and
produces output.

00:40:39.050 --> 00:40:43.960
And the problem here is if
something goes wrong, it wants

00:40:43.960 --> 00:40:48.190
to give you an error message in
terms of the object code,

00:40:48.190 --> 00:40:51.880
which you've never seen
in your life.

00:40:51.880 --> 00:40:54.720
And that can make
it very obscure.

00:40:54.720 --> 00:40:56.340
So the advantage?

00:40:56.340 --> 00:40:58.390
Why do we have compilers?

00:40:58.390 --> 00:41:00.930
Typically, compiled languages
are more efficient.

00:41:03.470 --> 00:41:07.700
Because they go through this
extra step, they take less

00:41:07.700 --> 00:41:11.040
time to run those programs.

00:41:11.040 --> 00:41:13.830
You can compile Python as well,
if you want to get an

00:41:13.830 --> 00:41:15.420
efficient version.

00:41:15.420 --> 00:41:19.420
But it's not designed under
that assumption.

00:41:19.420 --> 00:41:22.310
And so, it works well when
it's interpreted, which

00:41:22.310 --> 00:41:23.560
is why we use it.

