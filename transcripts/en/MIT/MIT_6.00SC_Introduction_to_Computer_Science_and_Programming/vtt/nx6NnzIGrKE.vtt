WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high-quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:17.890
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.890 --> 00:00:19.140
ocw.mit.edu.

00:00:23.490 --> 00:00:25.110
PROFESSOR: By way of review,
we're going to

00:00:25.110 --> 00:00:27.970
start off with loops.

00:00:27.970 --> 00:00:31.990
So, what are two loops that
we've covered in lecture or

00:00:31.990 --> 00:00:33.808
two types of loops?

00:00:33.808 --> 00:00:35.140
AUDIENCE: FOR and WHILE.

00:00:37.930 --> 00:00:38.430
PROFESSOR: OK.

00:00:38.430 --> 00:00:38.840
Yeah.

00:00:38.840 --> 00:00:39.760
FOR and WHILE.

00:00:39.760 --> 00:00:41.690
I'm going to start with WHILE
loops because that's what I

00:00:41.690 --> 00:00:42.940
have first.

00:00:44.770 --> 00:00:47.020
Can someone walk me through the
syntax of a WHILE loop?

00:00:52.700 --> 00:00:54.680
AUDIENCE: WHILE condition.

00:00:54.680 --> 00:00:57.540
PROFESSOR: WHILE condition and
what type is this condition?

00:00:57.540 --> 00:00:59.160
AUDIENCE: [INAUDIBLE]

00:00:59.160 --> 00:00:59.550
PROFESSOR: OK.

00:00:59.550 --> 00:01:01.710
And then I have--

00:01:01.710 --> 00:01:02.800
AUDIENCE: [INAUDIBLE]

00:01:02.800 --> 00:01:08.990
PROFESSOR: And then a block
of code, indicated by

00:01:08.990 --> 00:01:10.290
indentation.

00:01:10.290 --> 00:01:11.800
OK.

00:01:11.800 --> 00:01:15.347
Next question is, what
does this code do?

00:01:22.652 --> 00:01:25.590
AUDIENCE:Executes the loop and
returns Boolean values.

00:01:25.590 --> 00:01:25.870
PROFESSOR: Right.

00:01:25.870 --> 00:01:29.490
That's a little bit
too high level.

00:01:29.490 --> 00:01:31.902
Specifically, what does
this loop do?

00:01:31.902 --> 00:01:34.663
AUDIENCE: Prints the even
numbers from 2 to 10.

00:01:34.663 --> 00:01:35.913
PROFESSOR: Perfect.

00:01:44.570 --> 00:01:46.860
That's exactly the kind of
comment we're looking for.

00:01:46.860 --> 00:01:49.120
When you're doing your problem
sets or you're just coding in

00:01:49.120 --> 00:01:53.560
general, you want to have a
comment that describes in an

00:01:53.560 --> 00:01:56.250
abstract way what's going on
in the chunks of code.

00:01:56.250 --> 00:02:00.610
You don't want to have
a comment that says

00:02:00.610 --> 00:02:05.100
assigns 2 to a.

00:02:05.100 --> 00:02:09.340
Continues looping
until a is 10.

00:02:09.340 --> 00:02:11.100
Comments like that aren't really
helpful because you can

00:02:11.100 --> 00:02:13.040
get that by reading the code.

00:02:13.040 --> 00:02:15.080
So that's exactly right.

00:02:15.080 --> 00:02:15.860
It's perfect.

00:02:15.860 --> 00:02:19.980
I don't have candy to
pass out, though.

00:02:19.980 --> 00:02:21.695
Next question is what's the
decrementing function?

00:02:27.050 --> 00:02:29.080
The way to think of a
decrementing function is that

00:02:29.080 --> 00:02:33.400
it's a statement that moves
the loop closer to

00:02:33.400 --> 00:02:35.460
termination.

00:02:35.460 --> 00:02:36.640
In this case--

00:02:36.640 --> 00:02:37.890
AUDIENCE: 10 minus a.

00:02:41.800 --> 00:02:46.030
PROFESSOR: Yeah, 10 minus
a or a plus equal 2.

00:02:46.030 --> 00:02:47.985
As we're incrementing a, we're
getting closer and closer to

00:02:47.985 --> 00:02:50.038
10 and that's going to cause
us to kick out of the loop.

00:02:58.420 --> 00:02:59.980
Next thing.

00:02:59.980 --> 00:03:01.290
Is a a good variable name?

00:03:06.410 --> 00:03:10.510
The answer is no, otherwise,
I wouldn't have asked it.

00:03:10.510 --> 00:03:13.030
But a better variable name
might be even_number.

00:03:16.000 --> 00:03:20.140
Because, instead of just a being
an integer, now we know

00:03:20.140 --> 00:03:21.720
what it's supposed to represent
in the code.

00:03:24.550 --> 00:03:31.230
And it becomes clearer when we
go to execute it or run it.

00:03:37.180 --> 00:03:40.970
For loops, same thing.

00:03:40.970 --> 00:03:43.970
Could someone walk me through
the syntax for a FOR loop?

00:03:48.480 --> 00:03:51.930
And first question, does this
loop do the same thing as a

00:03:51.930 --> 00:03:53.180
WHILE loop?

00:03:59.010 --> 00:04:01.250
If this is our WHILE
loop, does this

00:04:01.250 --> 00:04:02.500
loop do the same thing?

00:04:05.758 --> 00:04:07.174
AUDIENCE: Yes.

00:04:07.174 --> 00:04:07.646
PROFESSOR: OK.

00:04:07.646 --> 00:04:08.850
Let's see.

00:04:08.850 --> 00:04:15.060
The WHILE loop printed out 4,
6,8,10 and 12; this is going

00:04:15.060 --> 00:04:19.820
to print out, 8 and 10.

00:04:19.820 --> 00:04:23.790
The reason is where we have
the increment, right?

00:04:23.790 --> 00:04:39.470
If we had done this, they would
print out both the same.

00:04:39.470 --> 00:04:40.900
A little aside.

00:04:40.900 --> 00:04:42.150
That was a bug I just caught.

00:04:44.900 --> 00:04:46.350
Someone walk me through the
syntax for a FOR loop.

00:04:53.028 --> 00:04:54.278
AUDIENCE: [INAUDIBLE]

00:04:57.130 --> 00:05:02.030
PROFESSOR: A FOR keyword and
then what do we have here?

00:05:02.030 --> 00:05:04.690
A variable of some sort.

00:05:04.690 --> 00:05:11.250
Then we have in keyword and then
we have this thing here.

00:05:11.250 --> 00:05:13.780
We're going to get to tuples
in a second, but this is a

00:05:13.780 --> 00:05:16.420
tuple literal.

00:05:16.420 --> 00:05:19.270
And for FOR loops, a FOR loop
requires something that is

00:05:19.270 --> 00:05:23.530
enumerable, which means that we
can take one element after

00:05:23.530 --> 00:05:26.350
the other and assign it
to the variable i.

00:05:30.030 --> 00:05:37.450
FOR loops iterate over
enumerable items.

00:05:37.450 --> 00:05:39.740
Thank you.

00:05:39.740 --> 00:05:40.950
That's exactly what I
was talking about.

00:05:40.950 --> 00:05:43.690
If I'm speaking too low, just
jack your thumbs up.

00:05:47.200 --> 00:05:50.310
This construction is
inconvenient though.

00:05:50.310 --> 00:05:53.520
If we wanted to list all
the numbers that

00:05:53.520 --> 00:05:54.630
we wanted to print--

00:05:54.630 --> 00:05:56.180
2 to 10 is not too hard.

00:05:56.180 --> 00:05:57.430
But let's say we wanted
all the even numbers

00:05:57.430 --> 00:05:59.910
between 2 and 100.

00:05:59.910 --> 00:06:04.360
I don't want to have to write
out all 50 of those.

00:06:04.360 --> 00:06:08.750
So we get to the
range function.

00:06:08.750 --> 00:06:09.770
You've seen this before.

00:06:09.770 --> 00:06:11.020
We just haven't ever
explained it.

00:06:13.450 --> 00:06:17.140
All the range function does is
it takes between one and three

00:06:17.140 --> 00:06:22.090
parameters and returns
a list of integers.

00:06:22.090 --> 00:06:25.580
So let's say that I pass
it one parameter.

00:06:25.580 --> 00:06:27.960
I'm going to give it
the integer 100.

00:06:27.960 --> 00:06:31.330
This is going to give
me nothing because I

00:06:31.330 --> 00:06:32.580
didn't print it out.

00:06:37.020 --> 00:06:42.255
This is going to give
me integers 0 to 99.

00:06:48.710 --> 00:06:51.110
If I give it two parameters,
what it's going

00:06:51.110 --> 00:06:52.410
to do is give me?

00:06:52.410 --> 00:07:00.400
The integers between
1 and 100.

00:07:00.400 --> 00:07:02.770
In this case, it starts off
at 1 and it gets to 99.

00:07:06.050 --> 00:07:08.120
One important point is that
when you give it two

00:07:08.120 --> 00:07:12.570
parameters, the first one is
inclusive and the second

00:07:12.570 --> 00:07:13.820
parameter is exclusive.

00:07:17.290 --> 00:07:18.640
Does everyone follow that?

00:07:21.580 --> 00:07:26.670
Finally, the third form is
with three parameters.

00:07:26.670 --> 00:07:32.070
I have a start, an end, start
inclusive, end exclusive, and

00:07:32.070 --> 00:07:34.400
then a step.

00:07:34.400 --> 00:07:46.030
This will give me all the odd
numbers between 1 and 100.

00:07:46.030 --> 00:07:49.530
We can also go in reverse.

00:07:49.530 --> 00:07:57.120
If I want to go count down from
100 to 1, I can give it a

00:07:57.120 --> 00:07:58.370
negative step.

00:08:02.570 --> 00:08:06.040
If you want help on using the
range function, there's a

00:08:06.040 --> 00:08:08.860
handy command called help,
which you can type in the

00:08:08.860 --> 00:08:10.110
interactive prompt.

00:08:14.940 --> 00:08:18.420
This gives you the syntax
for using range.

00:08:18.420 --> 00:08:21.680
You can do this for any
function in Python.

00:08:21.680 --> 00:08:25.590
It's going to tell you,
here's the name.

00:08:25.590 --> 00:08:27.010
Here's a parameter start.

00:08:27.010 --> 00:08:28.350
Here's a parameter stop.

00:08:28.350 --> 00:08:30.650
Here's a parameter step.

00:08:30.650 --> 00:08:33.940
This little arrow here means
this is what it returns, a

00:08:33.940 --> 00:08:35.190
list of integers.

00:08:37.600 --> 00:08:41.005
When you type help and you see
one of these square brackets

00:08:41.005 --> 00:08:43.499
that means the perimeter
is optional.

00:08:46.560 --> 00:08:47.680
A start is optional.

00:08:47.680 --> 00:08:49.390
Step is optional.

00:08:49.390 --> 00:08:51.880
Stop, we always have a stop.

00:08:51.880 --> 00:08:54.580
We always know when we're
stopping a range.

00:08:54.580 --> 00:08:58.815
That's why we can pass one,
two, or three parameters.

00:08:58.815 --> 00:09:02.010
Is anyone confused on that?

00:09:02.010 --> 00:09:05.370
AUDIENCE: If you only put stop,
it will start with 0?

00:09:05.370 --> 00:09:05.950
PROFESSOR: Right.

00:09:05.950 --> 00:09:10.150
If you only put one parameter,
then it will start from 0.

00:09:10.150 --> 00:09:11.870
So the start is implicit.

00:09:14.500 --> 00:09:15.750
Are we good on this?

00:09:28.100 --> 00:09:34.860
So, we can code our FOR loop
like that, which for five

00:09:34.860 --> 00:09:37.540
numbers is not too inconvenient,
or is

00:09:37.540 --> 00:09:38.150
convenient.

00:09:38.150 --> 00:09:43.440
But if we have 500 numbers, it
makes it a lot easier to just

00:09:43.440 --> 00:09:47.600
change one end point than
it is to type in

00:09:47.600 --> 00:09:48.850
500 numbers, right?

00:09:51.682 --> 00:09:52.932
OK.

00:10:00.628 --> 00:10:02.616
AUDIENCE: Can you create
a range for floats?

00:10:02.616 --> 00:10:06.095
So let's say you want to
do it by float size?

00:10:06.095 --> 00:10:07.160
PROFESSOR: That's
a good question.

00:10:07.160 --> 00:10:08.560
We should try it.

00:10:08.560 --> 00:10:09.986
Why don't we give it a shot?

00:10:15.160 --> 00:10:16.970
The question was can we make
a range of floats?

00:10:19.880 --> 00:10:28.200
Let's try 1.02 to 10.0.

00:10:28.200 --> 00:10:30.240
It'll give us an
answer, right?

00:10:30.240 --> 00:10:32.525
But it also gives
us a warning.

00:10:32.525 --> 00:10:36.150
It says that an integer
argument is expected.

00:10:36.150 --> 00:10:38.837
Let's say I do this.

00:10:42.250 --> 00:10:45.070
Will this work?

00:10:45.070 --> 00:10:46.370
What's it's going to
do is it's going to

00:10:46.370 --> 00:10:48.550
truncate the floats.

00:10:48.550 --> 00:10:51.150
It's going to truncate the start
to 1 and it's going to

00:10:51.150 --> 00:10:53.290
truncate the end to 10.

00:10:53.290 --> 00:10:57.000
Then it'll just return the
integers as required.

00:10:57.000 --> 00:10:59.760
So you can, but it doesn't
work the way

00:10:59.760 --> 00:11:01.010
you think it would.

00:11:05.970 --> 00:11:12.330
Moving on, you hit tuples
in lecture this week.

00:11:12.330 --> 00:11:18.080
So we're done with the
old review stuff.

00:11:18.080 --> 00:11:19.970
Can anyone tell me
what a tuple is?

00:11:27.800 --> 00:11:35.893
It's a non-scalar data type
that can hold many items.

00:11:38.940 --> 00:11:40.300
What does non-scalar mean?

00:11:45.260 --> 00:11:48.648
AUDIENCE: It's multiple elements
that you can search

00:11:48.648 --> 00:11:50.420
individually.

00:11:50.420 --> 00:11:51.590
AUDIENCE: It's a field that
you can hold only

00:11:51.590 --> 00:11:54.600
one value at a time.

00:11:54.600 --> 00:11:55.400
PROFESSOR: You're both right.

00:11:55.400 --> 00:11:58.130
A scalar can hold only one
element at a time.

00:11:58.130 --> 00:12:02.750
A non-scalar can hold more than
one element at a time.

00:12:02.750 --> 00:12:04.910
Tuples are actually the
second scalar data

00:12:04.910 --> 00:12:07.080
type that we've seen.

00:12:07.080 --> 00:12:08.350
A string is the first.

00:12:08.350 --> 00:12:10.255
A string can have multiple
characters.

00:12:13.250 --> 00:12:13.990
Tuples are flexible.

00:12:13.990 --> 00:12:15.240
We can have tuples of numbers.

00:12:18.130 --> 00:12:23.350
This syntax, the parentheses
with a set of elements

00:12:23.350 --> 00:12:26.200
separated by commas,
this is the literal

00:12:26.200 --> 00:12:29.390
syntax for a tuple.

00:12:29.390 --> 00:12:32.280
All we're saying is that my
tuple of numbers has the

00:12:32.280 --> 00:12:36.750
approximation of
pi, 2, 1, -100.

00:12:36.750 --> 00:12:39.230
We can have tuples of strings.

00:12:39.230 --> 00:12:42.600
We can have tuples of anything,
but you'll get to

00:12:42.600 --> 00:12:43.850
that in a second.

00:12:47.108 --> 00:12:50.590
AUDIENCE: Can you mix the data
types inside of that?

00:12:50.590 --> 00:12:52.050
PROFESSOR: Yes, we're going
to get to that.

00:12:55.390 --> 00:12:57.230
The question was, can
you mix data types?

00:12:57.230 --> 00:12:58.100
The answer is yes.

00:12:58.100 --> 00:13:02.140
We'll get to that in a second.

00:13:02.140 --> 00:13:05.870
To access individual elements
of a tuple, we do something

00:13:05.870 --> 00:13:07.670
called indexing.

00:13:07.670 --> 00:13:10.030
We specify an index by--

00:13:10.030 --> 00:13:14.350
if I have tuple_of_numbers, my
variable name, I have a left

00:13:14.350 --> 00:13:17.290
square bracket and a right
square bracket, and I have an

00:13:17.290 --> 00:13:20.440
integer in between.

00:13:20.440 --> 00:13:24.710
This would give me the item
in the tuple that

00:13:24.710 --> 00:13:27.490
exists at index 0.

00:13:27.490 --> 00:13:35.520
Tuples are indexed starting at
0 and in increments of 1.

00:13:35.520 --> 00:13:37.410
When I say tuple_of_numbers[0],
what

00:13:37.410 --> 00:13:40.590
should this print out?

00:13:40.590 --> 00:13:41.940
AUDIENCE: 3.14159.

00:13:41.940 --> 00:13:42.700
PROFESSOR: Right.

00:13:42.700 --> 00:13:45.900
It will print out 3.14159.

00:13:45.900 --> 00:13:49.292
Now if I change this to 1,
what will this print out?

00:13:49.292 --> 00:13:51.140
AUDIENCE: 2.

00:13:51.140 --> 00:13:53.320
PROFESSOR: Exactly.

00:13:53.320 --> 00:13:59.120
It doesn't matter what data type
is contained in tuple.

00:13:59.120 --> 00:14:04.340
If it's string, it'll just print
out whatever's here,

00:14:04.340 --> 00:14:07.510
which is 'what'.

00:14:07.510 --> 00:14:11.260
You can also use negative
indices.

00:14:11.260 --> 00:14:15.560
Negative indices tell Python
that I want to go to one past

00:14:15.560 --> 00:14:18.360
the end of the tuple.

00:14:18.360 --> 00:14:21.040
In this case, tuple_of_
strings, I'm out here

00:14:21.040 --> 00:14:24.260
somewhere, and then walk
back 1, or however

00:14:24.260 --> 00:14:26.700
many the integer is.

00:14:26.700 --> 00:14:28.840
I have here tuple_of_strings
minus 1.

00:14:28.840 --> 00:14:32.480
Python's going to go to
somewhere around here and then

00:14:32.480 --> 00:14:35.820
walk back one and
give me 'name'.

00:14:40.890 --> 00:14:44.090
Now what if I do minus 3?

00:14:46.910 --> 00:14:49.440
What's that going
to print out?

00:14:49.440 --> 00:14:50.690
Is.

00:14:57.220 --> 00:14:59.210
Let's see who is paying
attention.

00:14:59.210 --> 00:15:02.190
What's this going to do?

00:15:02.190 --> 00:15:03.440
AUDIENCE: [INAUDIBLE]

00:15:05.690 --> 00:15:09.490
AUDIENCE: My name,
or name, rather?

00:15:09.490 --> 00:15:13.002
PROFESSOR: Remember we index
tuples at 0, right?

00:15:13.002 --> 00:15:14.250
AUDIENCE: That's going
to give an error.

00:15:14.250 --> 00:15:15.460
PROFESSOR: Exactly.

00:15:15.460 --> 00:15:19.210
It's going to tell us
index out of range.

00:15:19.210 --> 00:15:24.210
We have four elements in
tuple strings 0, 1, 2,

00:15:24.210 --> 00:15:27.070
3, oops, we're off.

00:15:29.600 --> 00:15:32.040
You can get outside of a
tuple and get an error.

00:15:34.660 --> 00:15:36.526
To avoid that--

00:15:36.526 --> 00:15:37.024
sorry?

00:15:37.024 --> 00:15:39.020
AUDIENCE: The thing is when you
said for tuple_of_numbers,

00:15:39.020 --> 00:15:44.970
you said 1 and 3.141, number,
which would technically be 0

00:15:44.970 --> 00:15:46.225
in this case, wouldn't it?

00:15:46.225 --> 00:15:47.120
PROFESSOR: No, I switched it.

00:15:47.120 --> 00:15:47.860
AUDIENCE: You switched it.

00:15:47.860 --> 00:15:49.110
PROFESSOR: Yeah.

00:15:51.190 --> 00:15:54.030
Just to make you feel better--

00:15:54.030 --> 00:15:54.762
AUDIENCE: I see it now.

00:15:54.762 --> 00:15:56.080
PROFESSOR: You got it?

00:15:56.080 --> 00:15:57.330
OK.

00:16:01.610 --> 00:16:03.230
It's always possible that
I made an error.

00:16:07.280 --> 00:16:09.080
In your code, in order to avoid
that, you can check

00:16:09.080 --> 00:16:12.170
yourself by getting the length
of tuple_of_numbers.

00:16:12.170 --> 00:16:13.470
So there's a function len.

00:16:17.540 --> 00:16:18.630
It's going to tell us that

00:16:18.630 --> 00:16:20.250
tuple_of_numbers has 6 elements.

00:16:20.250 --> 00:16:24.800
We can count them:
1, 2, 3, 4, 5, 6.

00:16:24.800 --> 00:16:30.110
What's the last index
of this tuple?

00:16:30.110 --> 00:16:31.360
5, right?

00:16:36.500 --> 00:16:40.350
Back to your question, tuples
can hold different data types.

00:16:49.290 --> 00:16:52.595
They can hold data types that
are different from each other.

00:16:52.595 --> 00:16:56.390
I'm wording that improperly.

00:16:56.390 --> 00:16:59.280
So, here we have a float
and three strings.

00:16:59.280 --> 00:17:02.750
This is a heterogeneous
data structure.

00:17:02.750 --> 00:17:04.770
A homogeneous data structure
would be one that you would

00:17:04.770 --> 00:17:09.069
say only hold ints only
holds floats.

00:17:09.069 --> 00:17:10.810
But tuples are very flexible.

00:17:10.810 --> 00:17:13.339
So, we have a float here
and some strings.

00:17:13.339 --> 00:17:15.369
Then you could also
have tuples that

00:17:15.369 --> 00:17:16.619
contain other tuples.

00:17:20.030 --> 00:17:24.260
In this case, how many
elements does

00:17:24.260 --> 00:17:26.476
tuple_of_tuples have?

00:17:26.476 --> 00:17:28.448
AUDIENCE: 3.

00:17:28.448 --> 00:17:31.430
PROFESSOR: 3.

00:17:31.430 --> 00:17:36.740
The first element is a tuple,
the second element is 'got',

00:17:36.740 --> 00:17:38.470
and the third element
is 'real'.

00:17:41.240 --> 00:17:43.865
What should this print out?

00:17:43.865 --> 00:17:45.200
AUDIENCE: [INAUDIBLE]

00:17:45.200 --> 00:17:46.450
PROFESSOR: Yeah.

00:17:50.370 --> 00:17:52.538
I had to sanitize that quote.

00:17:52.538 --> 00:17:55.180
AUDIENCE: Why does it print
out the strings?

00:17:55.180 --> 00:17:59.270
PROFESSOR: Python's behavior,
when it sees a tuple data type

00:17:59.270 --> 00:18:02.980
and you call it with the print
statement, is it represents as

00:18:02.980 --> 00:18:06.180
a string a tuple the
way you would

00:18:06.180 --> 00:18:11.680
literally write out a tuple.

00:18:11.680 --> 00:18:14.010
'Stuff, just' is a tuple
with the two

00:18:14.010 --> 00:18:15.990
strings 'stuff' and 'just'.

00:18:15.990 --> 00:18:21.680
Python is going to print out the
literal representation of

00:18:21.680 --> 00:18:22.930
that tuple.

00:18:25.410 --> 00:18:32.640
Another way to try and explain
it, let's say that I print out

00:18:32.640 --> 00:18:34.480
the entire tuple.

00:18:34.480 --> 00:18:37.760
What should this look like?

00:18:37.760 --> 00:18:39.495
Well, It's going to be
just the literal

00:18:39.495 --> 00:18:40.745
representation of the tuple.

00:18:47.600 --> 00:18:50.645
What does it mean for the data
type to be immutable?

00:18:59.150 --> 00:19:00.110
AUDIENCE: You can't change it.

00:19:00.110 --> 00:19:02.050
You can't add another
element to it?

00:19:02.050 --> 00:19:03.930
PROFESSOR: You can't
change it.

00:19:03.930 --> 00:19:09.270
If I try to change the first
element of tuple_of_numbers,

00:19:09.270 --> 00:19:10.930
it's going to tell me
it doesn't support--

00:19:10.930 --> 00:19:12.750
or Python's going to tell me
it doesn't support item

00:19:12.750 --> 00:19:15.510
assignment.

00:19:15.510 --> 00:19:16.760
You'll see this error.

00:19:29.010 --> 00:19:33.860
Tuples support something called
slicing, which means

00:19:33.860 --> 00:19:38.060
that if I have a
tuple_of_numbers

00:19:38.060 --> 00:19:39.720
and I give it a--

00:19:39.720 --> 00:19:42.580
where I normally put just a
single integer for an index,

00:19:42.580 --> 00:19:47.150
if I give it a start index and
an end index, separated by

00:19:47.150 --> 00:19:54.060
this colon, Python's going to
get the item at index 1 to

00:19:54.060 --> 00:19:58.810
whatever this end element
is minus 1.

00:19:58.810 --> 00:20:02.180
It helps if I just
print it out.

00:20:02.180 --> 00:20:04.565
To make it a little bit
easier to follow.

00:20:12.260 --> 00:20:14.790
I've said I've told Python that
I want a slice out of

00:20:14.790 --> 00:20:18.640
this tuple from 1 to 3.

00:20:18.640 --> 00:20:23.960
What Python's going to go do is
look into tuple_of_numbers.

00:20:23.960 --> 00:20:25.970
This is element 0.

00:20:25.970 --> 00:20:29.490
This is index 1; it's
going to pull in 2.

00:20:29.490 --> 00:20:32.650
This is index 2; i it's
going to pull in 1.

00:20:32.650 --> 00:20:35.200
Then 3--

00:20:35.200 --> 00:20:40.730
in Python, we go 1 past the end
of the range that we want.

00:20:40.730 --> 00:20:43.320
It's going to return
a tuple of 2, 1.

00:20:43.320 --> 00:20:44.570
This is slicing a tuple.

00:20:48.340 --> 00:20:50.854
Anyone confused by that?

00:20:50.854 --> 00:20:51.750
No?

00:20:51.750 --> 00:20:53.000
Wow.

00:20:55.270 --> 00:20:57.980
There are many different ways
that we can slice a tuple.

00:20:57.980 --> 00:21:01.320
We can have an implicit start.

00:21:01.320 --> 00:21:06.520
If you see this, where there's
no number before the colon,

00:21:06.520 --> 00:21:09.010
that tells Python start
at index 0.

00:21:12.760 --> 00:21:19.820
Then, in complimentary fashion,
if you see this,

00:21:19.820 --> 00:21:23.170
where you have an integer on the
left side and nothing on

00:21:23.170 --> 00:21:27.120
the right side, it tells Python
go from index 1 all the

00:21:27.120 --> 00:21:28.430
way to the end of the tuple.

00:21:34.410 --> 00:21:38.253
What happens is I do this?

00:21:43.920 --> 00:21:46.920
What's that telling
Python to do?

00:21:46.920 --> 00:21:48.390
AUDIENCE: [INAUDIBLE]

00:21:48.390 --> 00:21:49.050
PROFESSOR: Yeah.

00:21:49.050 --> 00:21:52.960
It looks redundant but it will
become important to us when we

00:21:52.960 --> 00:21:56.840
get to lists and something
called aliasing.

00:21:56.840 --> 00:21:59.570
What this does is it tells
Python to take a slice that is

00:21:59.570 --> 00:22:00.820
the entire tuple.

00:22:04.250 --> 00:22:07.280
Then when we do these
slices, we can also

00:22:07.280 --> 00:22:09.530
use negative indices.

00:22:09.530 --> 00:22:15.220
This is going to tell Python
to go from 0 to the last

00:22:15.220 --> 00:22:18.400
element minus 1.

00:22:18.400 --> 00:22:19.650
It'll look like that.

00:22:25.000 --> 00:22:26.090
Everyone following?

00:22:26.090 --> 00:22:27.270
We good?

00:22:27.270 --> 00:22:29.065
AUDIENCE: It was minuses
from the end--

00:22:29.065 --> 00:22:29.420
PROFESSOR: Yeah.

00:22:29.420 --> 00:22:29.806
AUDIENCE: --of the tuple?

00:22:29.806 --> 00:22:32.060
PROFESSOR: Okay.

00:22:32.060 --> 00:22:34.240
I wonder if this would work?

00:22:34.240 --> 00:22:35.490
I don't know.

00:22:37.530 --> 00:22:41.530
No, it has unexpected
behavior.

00:22:41.530 --> 00:22:42.220
I don't know why.

00:22:42.220 --> 00:22:43.470
I'll have to look that up.

00:22:47.800 --> 00:22:50.670
Tuples are also--

00:22:50.670 --> 00:22:52.020
we already said earlier
that they were

00:22:52.020 --> 00:22:53.210
enumerable items, right?

00:22:53.210 --> 00:22:55.530
So we can use a FOR
loop with them.

00:22:55.530 --> 00:23:00.570
If I want to print out all the
numbers in tuple_of_numbers, I

00:23:00.570 --> 00:23:04.840
have my FOR loop, my variable,
in, and then

00:23:04.840 --> 00:23:06.090
my enumerable object.

00:23:10.800 --> 00:23:12.050
OK?

00:23:16.970 --> 00:23:18.220
I have a question now.

00:23:21.120 --> 00:23:23.350
Who thinks this will work?

00:23:23.350 --> 00:23:24.785
We know that tuples
are immutable.

00:23:33.427 --> 00:23:33.918
AUDIENCE: Yeah.

00:23:33.918 --> 00:23:35.890
But you have to change
the inside.

00:23:35.890 --> 00:23:37.840
PROFESSOR: Right.

00:23:37.840 --> 00:23:39.090
It's going to work.

00:23:41.633 --> 00:23:43.355
I still have print up here.

00:23:46.960 --> 00:23:49.540
What I'm doing is I'm taking
tuple_of_numbers and I'm

00:23:49.540 --> 00:23:51.480
printing before.

00:23:51.480 --> 00:23:55.740
Then what I'm doing here is
I'm telling Python to take

00:23:55.740 --> 00:24:02.130
this tuple and this tuple and
add them together and reassign

00:24:02.130 --> 00:24:03.380
it back to tuple_of_numbers.

00:24:06.630 --> 00:24:11.910
So, It looks like I'm
modifying the tuple.

00:24:11.910 --> 00:24:15.170
But in reality, what's
happening is I'm

00:24:15.170 --> 00:24:16.420
creating a new tuple.

00:24:20.130 --> 00:24:23.170
Let's say I have ton here.

00:24:23.170 --> 00:24:26.660
Ton is short for
tuple_of_numers.

00:24:26.660 --> 00:24:32.110
Originally, it's telling Python
that some chunk of

00:24:32.110 --> 00:24:39.320
memory has a tuple
of 1, 2, 3, 4.

00:24:39.320 --> 00:24:47.090
When I say a statement like
ton equal ton plus another

00:24:47.090 --> 00:24:51.740
tuple, what it's telling Python
to do is create another

00:24:51.740 --> 00:24:58.730
chunk of memory that includes
ton, whatever's in ton, and

00:24:58.730 --> 00:24:59.980
the other tuple.

00:25:03.730 --> 00:25:07.540
Then this assignment statement
tells Python that ton now

00:25:07.540 --> 00:25:10.965
points to this new object.

00:25:10.965 --> 00:25:13.857
You had a question?

00:25:13.857 --> 00:25:16.671
AUDIENCE:Does Python have
a garbage collector?

00:25:16.671 --> 00:25:19.350
PROFESSOR: It's an advanced
question.

00:25:19.350 --> 00:25:23.190
The question was, does Python
have a garbage collector to

00:25:23.190 --> 00:25:25.860
discard this memory that's
no longer being used.

00:25:25.860 --> 00:25:27.660
The answer is yes.

00:25:27.660 --> 00:25:29.740
If you don't know what a garbage
collector is, don't

00:25:29.740 --> 00:25:30.220
worry about it.

00:25:30.220 --> 00:25:31.230
You don't need to.

00:25:31.230 --> 00:25:34.230
But to answer your question,
yes, it does.

00:25:38.166 --> 00:25:40.668
I don't want to get
too far into it.

00:25:43.300 --> 00:25:45.870
Does everyone follow that?

00:25:45.870 --> 00:25:48.365
That also is going to be
important when we get to lists

00:25:48.365 --> 00:25:53.250
and aliasing, that type of
object creation modification.

00:25:57.350 --> 00:25:59.400
We won't get to that
for a while.

00:25:59.400 --> 00:26:00.410
Everyone's good with this?

00:26:00.410 --> 00:26:01.722
I can move on?

00:26:01.722 --> 00:26:02.972
All right.

00:26:04.850 --> 00:26:11.200
Python has what some might
consider a wart,

00:26:11.200 --> 00:26:13.840
when it comes to tuples.

00:26:13.840 --> 00:26:17.410
That is when you want to create
a tuple with a single

00:26:17.410 --> 00:26:18.660
element in it.

00:26:23.370 --> 00:26:28.680
People just starting out with
Python would sometimes mistake

00:26:28.680 --> 00:26:32.272
the tuple literal of a single
element to be this: So,

00:26:32.272 --> 00:26:34.730
parenthesis with a
single integer.

00:26:34.730 --> 00:26:37.850
The problem is that parentheses
are the grouping

00:26:37.850 --> 00:26:40.460
operatorS in Python,
but they're also

00:26:40.460 --> 00:26:41.940
used for making tuples.

00:26:41.940 --> 00:26:45.220
They serve a dual purpose.

00:26:45.220 --> 00:26:48.880
What Python will say is, oh,
I've got a number between two

00:26:48.880 --> 00:26:49.910
parentheses.

00:26:49.910 --> 00:26:52.530
Well, this person really wants
this integer to have high

00:26:52.530 --> 00:26:54.010
precedence.

00:26:54.010 --> 00:26:57.380
We're going to make an integer
50 and assign it to oopsie.

00:26:57.380 --> 00:26:59.880
But it's not what we want.

00:26:59.880 --> 00:27:04.660
We want a tuple with
50 as one element.

00:27:04.660 --> 00:27:09.780
The way you do that is you have
a lone comma after the

00:27:09.780 --> 00:27:11.030
first element.

00:27:13.600 --> 00:27:16.610
If we run this and we look at
what it prints out, you see

00:27:16.610 --> 00:27:20.900
that oopsie has the integer 50,
which is not what we want.

00:27:20.900 --> 00:27:22.150
We want what's in onesie.

00:27:34.460 --> 00:27:35.710
Anyone confused by that?

00:27:40.250 --> 00:27:41.675
We're zooming along here.

00:27:45.720 --> 00:27:51.990
Strings, they're actually
a lot like tuples.

00:27:51.990 --> 00:27:52.970
They're immutable.

00:27:52.970 --> 00:27:54.420
You can't change them.

00:27:54.420 --> 00:27:57.150
They're non-scalar.

00:27:57.150 --> 00:28:00.520
They have multiple characters
within them.

00:28:00.520 --> 00:28:03.310
If I printed out-- everyone's
seen this--

00:28:03.310 --> 00:28:05.850
I can get to individual
characters.

00:28:05.850 --> 00:28:10.650
If I want to get to the first
character in name, I use 0.

00:28:10.650 --> 00:28:13.080
If I want to get to the second
character, I can use 1.

00:28:23.940 --> 00:28:26.300
Then of course they're
immutable, so that's going to

00:28:26.300 --> 00:28:27.550
tell me that I can't do that.

00:28:36.650 --> 00:28:37.960
They also support iteration.

00:28:41.040 --> 00:28:45.430
So, if I want to print out all
the letters in name, one on

00:28:45.430 --> 00:28:48.410
each line, I can do this.

00:28:48.410 --> 00:28:54.010
Not too useful, but it works.

00:28:54.010 --> 00:28:56.224
You looked confused.

00:28:56.224 --> 00:28:58.880
AUDIENCE: How did that happen?

00:28:58.880 --> 00:29:00.130
PROFESSOR: How did
that happen?

00:29:03.450 --> 00:29:04.740
So, name is a string.

00:29:04.740 --> 00:29:06.320
Follow that?

00:29:06.320 --> 00:29:09.030
String is just a bunch
of characters.

00:29:13.170 --> 00:29:17.470
It is enumerable, meaning that
we can go one character at a

00:29:17.470 --> 00:29:19.410
time through the string.

00:29:24.320 --> 00:29:25.715
That's what the FOR loop does.

00:29:28.390 --> 00:29:30.810
AUDIENCE: Do spaces count
as characters?

00:29:30.810 --> 00:29:31.082
PROFESSOR: Good.

00:29:31.082 --> 00:29:33.600
The question was do spaces
count as characters.

00:29:33.600 --> 00:29:35.840
The answer is yes, they do.

00:29:35.840 --> 00:29:48.880
If I write spaces there and I
run this again, as I iterate

00:29:48.880 --> 00:29:52.830
through the string, I get a
space where I'm supposed to.

00:30:01.430 --> 00:30:03.370
Is everyone good with this?

00:30:03.370 --> 00:30:04.620
OK.

00:30:06.990 --> 00:30:09.370
Like tuples, you can
take slices.

00:30:15.330 --> 00:30:16.580
That's going to give me 'it'.

00:30:19.090 --> 00:30:24.495
Strings also have
many functions.

00:30:28.550 --> 00:30:32.110
This is an incomplete list of
functions that you can use on

00:30:32.110 --> 00:30:34.030
string objects.

00:30:34.030 --> 00:30:43.880
I can make everything uppercase,
lowercase.

00:30:49.920 --> 00:30:52.405
I can also find characters.

00:31:01.000 --> 00:31:05.570
What find does is it
finds the index of

00:31:05.570 --> 00:31:06.970
the left-most character.

00:31:06.970 --> 00:31:13.150
If I want to find i, it returns
1, because i is at

00:31:13.150 --> 00:31:16.320
index 1 in the string.

00:31:16.320 --> 00:31:19.540
I could also do something
like this.

00:31:19.540 --> 00:31:23.990
I can find an entire string.

00:31:23.990 --> 00:31:27.350
'tch', the substring,
starts at index 2.

00:31:33.110 --> 00:31:36.000
AUDIENCE: What does it return
if it can't find it?

00:31:36.000 --> 00:31:39.260
PROFESSOR: If it doesn't
find it--

00:31:39.260 --> 00:31:40.510
let's put in garbage--

00:31:43.850 --> 00:31:45.100
you get negative 1.

00:31:55.320 --> 00:31:57.420
We can also call a
replace function.

00:31:57.420 --> 00:31:59.530
If I want to replace
m with p--

00:32:02.510 --> 00:32:06.290
it doesn't make sense
anymore--

00:32:06.290 --> 00:32:07.255
I can do that.

00:32:07.255 --> 00:32:09.580
The question is, how would I use
this to change the string?

00:32:14.080 --> 00:32:18.410
Think back to how we
modified the tuple.

00:32:18.410 --> 00:32:21.040
We created a new object and
then we assigned it to a

00:32:21.040 --> 00:32:24.570
variable of the same name.

00:32:24.570 --> 00:32:26.970
If I know that replace is going
to return a string with

00:32:26.970 --> 00:32:36.625
m replaced, I can do that.

00:32:46.070 --> 00:32:47.320
Does everyone follow that?

00:32:49.750 --> 00:32:50.925
AUDIENCE: Is the version
that that

00:32:50.925 --> 00:32:52.570
captures your string function?

00:32:52.570 --> 00:32:54.500
PROFESSOR: That's
a good question.

00:32:54.500 --> 00:32:58.020
That also gives me a perfect
opportunity to demonstrate

00:32:58.020 --> 00:33:00.920
another command that you'll
find helpful.

00:33:00.920 --> 00:33:04.740
If you're working with an object
like string, you can

00:33:04.740 --> 00:33:07.650
use a command in the interactive
editor called dir.

00:33:07.650 --> 00:33:15.320
If you type dir str, it's going
to return all of the

00:33:15.320 --> 00:33:18.470
symbols that exist within
the str object.

00:33:18.470 --> 00:33:24.110
You can also type help str, and
it will give you a nicer

00:33:24.110 --> 00:33:25.360
version of this.

00:33:28.260 --> 00:33:30.347
AUDIENCE: In this case, the
first character indicates what

00:33:30.347 --> 00:33:32.236
you're trying to replace and
the second is what you're

00:33:32.236 --> 00:33:35.230
replacing it with?

00:33:35.230 --> 00:33:35.780
PROFESSOR: Right.

00:33:35.780 --> 00:33:41.350
We can do help str replace,
and it'll tell us.

00:33:41.350 --> 00:33:41.827
AUDIENCE: OK.

00:33:41.827 --> 00:33:44.689
So it did one.

00:33:44.689 --> 00:33:47.074
And then the count in this
case would be if you had

00:33:47.074 --> 00:33:49.460
multiple instances?

00:33:49.460 --> 00:33:49.940
PROFESSOR: Yes.

00:33:49.940 --> 00:33:50.082
AUDIENCE: OK.

00:33:50.082 --> 00:33:52.106
So like if you had your name
a couple times, you could

00:33:52.106 --> 00:33:53.940
replace it a few times.

00:33:53.940 --> 00:33:54.900
PROFESSOR: Right.

00:33:54.900 --> 00:33:58.720
If I were particularly
narcissistic that day, I could

00:33:58.720 --> 00:34:00.730
replace it multiple times.

00:34:00.730 --> 00:34:03.570
So let's demonstrate
that because some

00:34:03.570 --> 00:34:04.820
people might be confused.

00:34:07.150 --> 00:34:11.389
Let's say, I want
to replace t.

00:34:17.230 --> 00:34:18.480
I'm going to replace
it with r.

00:34:25.909 --> 00:34:27.650
Whoops.

00:34:27.650 --> 00:34:29.780
Well, why didn't it replace
these to t's here?

00:34:33.119 --> 00:34:35.510
AUDIENCE: [INAUDIBLE]

00:34:35.510 --> 00:34:36.850
PROFESSOR: Right.

00:34:36.850 --> 00:34:38.030
In strings, you differentiate
between

00:34:38.030 --> 00:34:39.280
lowercase and uppercase.

00:34:41.370 --> 00:34:44.780
If I wanted to get the behavior
that I was hoping

00:34:44.780 --> 00:34:48.810
for, I could do it this way.

00:34:55.659 --> 00:34:57.400
Now I have something that's
not even remotely

00:34:57.400 --> 00:34:59.600
looking like English.

00:34:59.600 --> 00:35:02.200
Or, I could do something
like this.

00:35:05.860 --> 00:35:11.640
I'm going to make everything
lowercase, and

00:35:11.640 --> 00:35:13.035
then replace the t.

00:35:16.674 --> 00:35:18.361
AUDIENCE: So that's
pretty exact that

00:35:18.361 --> 00:35:21.020
you have to be, lower--

00:35:21.020 --> 00:35:23.600
PROFESSOR: Remember what I said
first recitation that

00:35:23.600 --> 00:35:25.920
computers will do exactly what
you tell them to do and

00:35:25.920 --> 00:35:27.170
nothing more or less.

00:35:29.910 --> 00:35:31.962
There we go.

00:35:31.962 --> 00:35:32.870
AUDIENCE: It's good though.

00:35:32.870 --> 00:35:34.690
It figured out [INAUDIBLE]

00:35:34.690 --> 00:35:37.640
PROFESSOR: Python is a
very nice language.

00:35:37.640 --> 00:35:40.310
It's one of my favorite
languages right now.

00:35:40.310 --> 00:35:45.000
Because, it's not as fussy as
some other languages, like

00:35:45.000 --> 00:35:52.850
MATLAB or C or C++ or TCL.

00:35:52.850 --> 00:35:54.890
Anyone of those.

00:35:54.890 --> 00:35:57.490
Is everyone good on strings?

00:35:57.490 --> 00:35:58.930
I can move on?

00:35:58.930 --> 00:36:01.390
Just remember, if you need help
on any of these commands,

00:36:01.390 --> 00:36:03.609
just remember you have the help
command at your disposal.

00:36:03.609 --> 00:36:05.445
AUDIENCE: It'll automatically
default to do everything,

00:36:05.445 --> 00:36:08.660
unless you tell it something to
do like two of the letters.

00:36:08.660 --> 00:36:10.600
PROFESSOR: Yes.

00:36:10.600 --> 00:36:13.630
We didn't demonstrate that.

00:36:13.630 --> 00:36:15.460
Demonstrations are worth
a thousand words.

00:36:15.460 --> 00:36:19.030
If I wanted to, for whatever
reason, only replace the first

00:36:19.030 --> 00:36:22.230
two t's, I could tell it to only
replace two t's within

00:36:22.230 --> 00:36:23.480
the string.

00:36:26.570 --> 00:36:29.872
It leaves the other t alone.

00:36:29.872 --> 00:36:33.275
AUDIENCE: How would you pick
out the last field?

00:36:33.275 --> 00:36:34.525
PROFESSOR: That's
a good question.

00:36:37.560 --> 00:36:38.860
I don't have a ready
answer for you.

00:36:49.310 --> 00:36:55.610
You see these functions with
r in front of them?

00:36:55.610 --> 00:37:01.620
The string object often has
functions that will start from

00:37:01.620 --> 00:37:03.780
the right side as opposed
to the left side.

00:37:03.780 --> 00:37:09.390
The find command I showed you
has an rfind command as well.

00:37:09.390 --> 00:37:10.960
This guy right here.

00:37:10.960 --> 00:37:18.040
I'm pointing on if there is
the analog to replace.

00:37:18.040 --> 00:37:20.420
Can I get back to you?

00:37:20.420 --> 00:37:22.590
I don't want to spend all our
time searching for this and

00:37:22.590 --> 00:37:23.840
then fail spectacularly.

00:37:26.550 --> 00:37:28.870
I'll get back to you on that.

00:37:28.870 --> 00:37:29.780
Is it possible?

00:37:29.780 --> 00:37:30.120
Yeah.

00:37:30.120 --> 00:37:33.100
Is there a one-liner function?

00:37:33.100 --> 00:37:34.350
I can't tell you
at the moment.

00:37:39.960 --> 00:37:41.960
But again, that's why you
have dir and help.

00:37:41.960 --> 00:37:43.390
You can find this
out on your own.

00:37:49.940 --> 00:37:53.600
Next thing, BREAK.

00:37:53.600 --> 00:37:54.770
We're done with strings.

00:37:54.770 --> 00:37:56.480
We're done with tuples.

00:37:56.480 --> 00:37:58.430
We're still working on loops.

00:37:58.430 --> 00:38:01.200
Everyone's seen this function
before, right?

00:38:01.200 --> 00:38:09.030
This is our find-the-cube-ro
ot-of-a-perfect-cube function.

00:38:09.030 --> 00:38:13.510
If I give it 27, and I tell
Python to stop printing my

00:38:13.510 --> 00:38:25.440
name, that's what this does.

00:38:25.440 --> 00:38:31.180
As a toy example to illustrate
the BREAK statement--

00:38:31.180 --> 00:38:33.940
first of all, can someone tell
me in English what the BREAK

00:38:33.940 --> 00:38:35.810
statement does?

00:38:35.810 --> 00:38:39.830
AUDIENCE: Would it just
stop the program.

00:38:39.830 --> 00:38:41.520
PROFESSOR: Well, It doesn't stop
the program, but it kicks

00:38:41.520 --> 00:38:42.770
you out of the loop.

00:38:46.620 --> 00:38:54.630
We can rewrite the cube root
program to work like this.

00:38:54.630 --> 00:39:00.260
Instead of our stopping criteria
being answer cubed

00:39:00.260 --> 00:39:03.980
less than the absolute value
of the number, we're just

00:39:03.980 --> 00:39:10.540
going to tell the FOR loop to
go from a range 0 to the

00:39:10.540 --> 00:39:13.200
absolute value of the
input plus 1.

00:39:13.200 --> 00:39:14.841
Why do we have the
plus 1 there?

00:39:14.841 --> 00:39:17.550
AUDIENCE: So it goes to the
absolute value of x.

00:39:17.550 --> 00:39:17.980
PROFESSOR: Yeah.

00:39:17.980 --> 00:39:20.570
Because, otherwise, it would
go to 1 before the absolute

00:39:20.570 --> 00:39:22.800
value of x.

00:39:22.800 --> 00:39:27.850
Then we break out of this loop,
if answer cubed is equal

00:39:27.850 --> 00:39:28.970
to absolute value of x.

00:39:28.970 --> 00:39:33.590
As soon as we see that it's
equal to x, we're going to

00:39:33.590 --> 00:39:34.890
call BREAK.

00:39:34.890 --> 00:39:38.150
That's going to immediately kick
us out to here, without

00:39:38.150 --> 00:39:39.890
executing any more
of the FOR loop.

00:39:47.170 --> 00:39:49.240
Do people understand that?

00:39:49.240 --> 00:39:51.194
Are people good with that?

00:39:51.194 --> 00:39:51.634
AUDIENCE: Does it break you
of the innermost loop? or

00:39:51.634 --> 00:39:54.120
[INAUDIBLE]

00:39:54.120 --> 00:39:55.170
PROFESSOR: Yes.

00:39:55.170 --> 00:39:57.180
Good question.

00:39:57.180 --> 00:39:58.590
Does it break you out
of the innermost

00:39:58.590 --> 00:40:00.320
loop or all the loops?

00:40:00.320 --> 00:40:02.710
The answer is the
innermost loop.

00:40:02.710 --> 00:40:04.520
When he says innermost,
what he's talking

00:40:04.520 --> 00:40:06.040
about are nested loops.

00:40:06.040 --> 00:40:08.922
Let's say I have something
like this.

00:40:08.922 --> 00:40:17.110
I'm creating on the fly
now, so excuse my

00:40:17.110 --> 00:40:18.360
inability to type.

00:40:45.060 --> 00:40:47.420
What is this going to do?

00:40:47.420 --> 00:40:51.320
This is an example
of a nested loop.

00:40:51.320 --> 00:40:54.200
We have an outer loop
here, then we have

00:40:54.200 --> 00:40:55.450
an inner loop here.

00:40:58.110 --> 00:41:00.640
All the outer loop is doing is
it's going from the integers

00:41:00.640 --> 00:41:02.940
0, 1, 2, 3 to 9.

00:41:05.730 --> 00:41:08.700
And then we have an inner loop,
which looks like it

00:41:08.700 --> 00:41:13.190
should go from the integers
10 to 100.

00:41:13.190 --> 00:41:19.000
But we have the statement
in here if j mod 2--

00:41:19.000 --> 00:41:21.990
that's what the percent
sign is, modulus--

00:41:21.990 --> 00:41:23.460
is equal to 0.

00:41:23.460 --> 00:41:28.700
What we're saying is if j is
evenly divisible by 2, we're

00:41:28.700 --> 00:41:30.990
going to break.

00:41:30.990 --> 00:41:32.240
Now, the question is--

00:41:38.610 --> 00:41:46.130
this is obviously going
to break when j is 10.

00:41:46.130 --> 00:41:47.660
This loop is going
to execute once.

00:41:50.820 --> 00:42:02.045
The question is does it print
out only one set of i,j

00:42:02.045 --> 00:42:04.180
values, or does it
print out 10?

00:42:08.200 --> 00:42:09.920
I'm getting to the answer
to this question.

00:42:09.920 --> 00:42:12.820
If BREAK statement breaks out
of all the loops, then we

00:42:12.820 --> 00:42:16.710
would only see one printout
of i and j.

00:42:16.710 --> 00:42:19.350
But if it only breaks out of
this inner loop, then we

00:42:19.350 --> 00:42:25.180
should see 10, followed
by 'here'.

00:42:25.180 --> 00:42:28.080
So it breaks out of
the inner loop.

00:42:28.080 --> 00:42:29.330
Long answer, but
demonstration.

00:42:31.876 --> 00:42:33.195
Is anyone confused by that?

00:42:38.620 --> 00:42:39.900
Is so, anyone too
shy to admit it?

00:42:43.150 --> 00:42:44.400
There's office hours.

00:42:47.150 --> 00:42:48.400
Or, you can talk to
me afterwards.

00:42:58.030 --> 00:43:00.810
PROFESSOR: Now we're going to
get to functions, which are

00:43:00.810 --> 00:43:03.010
triple underlined and circled
over here because they're

00:43:03.010 --> 00:43:04.660
extraordinarily important
for you to understand.

00:43:07.280 --> 00:43:10.040
Can someone wing it and
tell me what they

00:43:10.040 --> 00:43:11.290
think a function is?

00:43:19.778 --> 00:43:21.236
AUDIENCE: It's a snippet of code
that takes some input,

00:43:21.236 --> 00:43:23.690
does something to it, and
returns some output.

00:43:23.690 --> 00:43:25.020
PROFESSOR: Perfect.

00:43:25.020 --> 00:43:26.780
It's a bit of code.

00:43:26.780 --> 00:43:28.810
It's named, so you
can refer to it.

00:43:28.810 --> 00:43:32.930
It takes input, does something
with it, and returns

00:43:32.930 --> 00:43:36.130
something, some value.

00:43:36.130 --> 00:43:42.240
The way that we define a
function in Python is like so.

00:43:42.240 --> 00:43:47.100
Let's say I have a
function cube.

00:43:47.100 --> 00:43:48.920
It consists of a few parts.

00:43:48.920 --> 00:43:52.330
We've got the DEF keyword.

00:43:52.330 --> 00:43:54.170
We've got a name, cube.

00:43:54.170 --> 00:43:55.950
The name should be meaningful
for functions.

00:43:55.950 --> 00:43:59.780
Like variables, the name should
mean something So, this

00:43:59.780 --> 00:44:03.720
would be a bad name
for this function.

00:44:03.720 --> 00:44:05.465
You want it to be meaningful.

00:44:05.465 --> 00:44:07.520
It has a set of parameters.

00:44:07.520 --> 00:44:10.270
In this case, it only
has one parameter.

00:44:10.270 --> 00:44:16.720
This is what we pass to the
function when we call it.

00:44:16.720 --> 00:44:18.932
We'll talk about that
in another second.

00:44:18.932 --> 00:44:20.710
It has this string.

00:44:20.710 --> 00:44:23.990
This is called a doc string.

00:44:23.990 --> 00:44:26.940
It's the specification
for this function.

00:44:26.940 --> 00:44:31.280
When you write functions, it's
good to have this string here.

00:44:31.280 --> 00:44:33.770
What it allows you to do is
describe what the function

00:44:33.770 --> 00:44:39.330
does, what it expects for
input, and what it

00:44:39.330 --> 00:44:40.580
gives you as output.

00:44:42.710 --> 00:44:45.140
In this case, it's
very simple.

00:44:45.140 --> 00:44:47.100
This is the body of
the function.

00:44:47.100 --> 00:44:52.030
Again we denote the block
by indenting.

00:44:52.030 --> 00:44:54.470
All it does is it takes a
number, which is passed into

00:44:54.470 --> 00:44:59.880
it and raises it to
the third power.

00:44:59.880 --> 00:45:03.620
This RETURN statement tells
Python to send that back to

00:45:03.620 --> 00:45:04.870
whoever called the function.

00:45:07.980 --> 00:45:18.610
As an example if this working,
let's look at

00:45:18.610 --> 00:45:20.060
this line of code.

00:45:20.060 --> 00:45:22.140
What it's doing is--

00:45:22.140 --> 00:45:23.170
we've seen the print
statement, so we

00:45:23.170 --> 00:45:25.190
know what it does.

00:45:25.190 --> 00:45:31.110
It's going to name cube and
it's going to call it.

00:45:31.110 --> 00:45:33.820
Python knows it's calling it
because it's got the name of

00:45:33.820 --> 00:45:36.830
the function with the
input parameters.

00:45:36.830 --> 00:45:47.140
So, 3 is being passed to cube
to be, well, cubed.

00:45:47.140 --> 00:45:51.230
What's going on here is that
Python is breaking out of its

00:45:51.230 --> 00:45:58.550
normal flow of execution,
sending 3, calling it number

00:45:58.550 --> 00:46:01.290
in the function, and then
raising it to the third power.

00:46:01.290 --> 00:46:04.135
If we run this, we see 27.

00:46:09.160 --> 00:46:15.720
We can pass it any number
that we want.

00:46:15.720 --> 00:46:19.596
Is anyone confused by this?

00:46:19.596 --> 00:46:21.255
AUDIENCE: The things you're
running between quotation

00:46:21.255 --> 00:46:23.870
marks, doesn't that kind of--

00:46:23.870 --> 00:46:25.860
PROFESSOR: They don't
do anything.

00:46:25.860 --> 00:46:30.340
The question was, this string
here between the quotation

00:46:30.340 --> 00:46:31.680
marks, this doesn't
do anything.

00:46:31.680 --> 00:46:32.750
No, this is a comment.

00:46:32.750 --> 00:46:35.770
This is so that you can tell
yourself, six months down the

00:46:35.770 --> 00:46:37.420
road, what you were thinking.

00:46:37.420 --> 00:46:39.730
Or so that you could tell
another programmer what this

00:46:39.730 --> 00:46:41.270
function does.

00:46:41.270 --> 00:46:44.950
It's a way of documenting
your code.

00:46:44.950 --> 00:46:46.180
AUDIENCE: So cube in this
case is something that

00:46:46.180 --> 00:46:48.400
is built to go around.

00:46:48.400 --> 00:46:48.760
PROFESSOR: Yeah.

00:46:48.760 --> 00:46:51.190
This is just a toy example.

00:46:51.190 --> 00:46:54.830
I wanted to keep it simple.

00:46:54.830 --> 00:46:58.240
I'm illustrating concepts.

00:46:58.240 --> 00:47:02.335
It wouldn't be too hard
just to do this.

00:47:09.070 --> 00:47:10.540
I'm going to move on.

00:47:10.540 --> 00:47:11.790
Everyone's good with
functions?

00:47:14.235 --> 00:47:15.485
AUDIENCE: [INAUDIBLE]

00:47:20.103 --> 00:47:22.548
Can you say x equals number--

00:47:22.548 --> 00:47:27.438
can you keep the number, and
just keep the number, and just

00:47:27.438 --> 00:47:29.394
make it into a variable without
the RETURN function.

00:47:31.928 --> 00:47:35.400
Do you have to use the RETURN
function on that?

00:47:35.400 --> 00:47:36.870
PROFESSOR: I was just
getting to that.

00:47:36.870 --> 00:47:39.670
The question is, do you have
to use a RETURN function.

00:47:39.670 --> 00:47:42.760
The answer is well, it depends
on what you want to do.

00:47:49.840 --> 00:47:52.810
So, let's take a look
at a new function.

00:47:52.810 --> 00:47:56.660
Can someone tell me
what this does?

00:47:56.660 --> 00:47:58.816
First, what does the
function do?

00:47:58.816 --> 00:48:00.066
Or what is it supposed to do?

00:48:02.788 --> 00:48:05.420
AUDIENCE: Takes the number
and doubles it.

00:48:05.420 --> 00:48:07.100
PROFESSOR: You got that by
reading the writing on the

00:48:07.100 --> 00:48:09.540
wall, right?

00:48:09.540 --> 00:48:12.910
Really, it's too easy.

00:48:12.910 --> 00:48:16.010
In the body of the function,
all it does is it creates a

00:48:16.010 --> 00:48:18.820
new variable, answer, and it
assigns number times 2 to it.

00:48:21.740 --> 00:48:22.990
What's going to print
out here?

00:48:27.450 --> 00:48:28.700
Why don't we run it and see?

00:48:31.240 --> 00:48:33.680
That's not doing
what we wanted.

00:48:33.680 --> 00:48:38.750
When you don't have a RETURN
statement, Python returns

00:48:38.750 --> 00:48:41.730
implicitly none to whoever
calls the function.

00:48:45.310 --> 00:48:45.390
Ok.

00:48:45.390 --> 00:48:47.660
In this case, this function
obviously doesn't have a

00:48:47.660 --> 00:48:52.180
RETURN statement Python
says, OK.

00:48:52.180 --> 00:48:53.660
I'm just going to return none.

00:48:53.660 --> 00:48:59.210
Whatever work it did in the
function is lost in this case.

00:48:59.210 --> 00:49:01.300
To get the right functionality,
we have to add

00:49:01.300 --> 00:49:02.550
a RETURN statement.

00:49:06.600 --> 00:49:09.520
And it works.

00:49:09.520 --> 00:49:11.095
Was that what you
were getting at?

00:49:11.095 --> 00:49:12.345
OK.

00:49:14.900 --> 00:49:15.640
Anyone confused?

00:49:15.640 --> 00:49:16.890
Can I move on?

00:49:25.700 --> 00:49:27.530
Functions have something
called variable scope.

00:49:31.630 --> 00:49:33.380
I apologize for the punning.

00:49:33.380 --> 00:49:35.790
I was getting tired
when I wrote this.

00:49:38.740 --> 00:49:40.740
In this chunk of code,
I define a

00:49:40.740 --> 00:49:41.990
global variable, all_hope.

00:49:44.890 --> 00:49:50.180
I also define a function that
takes a parameter, variables.

00:49:52.840 --> 00:49:55.120
It says it steals all the
variables, but I don't know

00:49:55.120 --> 00:49:57.420
how it does that
in a computer.

00:49:57.420 --> 00:50:00.690
It doesn't return anything.

00:50:00.690 --> 00:50:02.970
In the body of the function,
I create another variable,

00:50:02.970 --> 00:50:08.800
called my_variable, and
I assign it a string.

00:50:08.800 --> 00:50:10.980
I'm not actually returning
anything right because I've

00:50:10.980 --> 00:50:12.050
said I'm not returning
anything.

00:50:12.050 --> 00:50:15.040
All this is doing is it's
just printing stuff out.

00:50:15.040 --> 00:50:19.610
It's printing out what the
parameter passed into it was.

00:50:19.610 --> 00:50:22.610
It's printing out variables.

00:50:22.610 --> 00:50:25.540
It's printing out all_hope,
which is a global variable

00:50:25.540 --> 00:50:27.270
that we define up here.

00:50:27.270 --> 00:50:31.450
It's printing out my_variable,
which is a local variable in

00:50:31.450 --> 00:50:32.700
the function.

00:50:35.330 --> 00:50:40.440
Down here I'm defining a
variable, old_meme_is_old.

00:50:40.440 --> 00:50:41.690
I'm calling the function.

00:50:45.680 --> 00:50:48.970
It does what we expect
it to do.

00:50:48.970 --> 00:50:52.770
What I want to illustrate,
though is what

00:50:52.770 --> 00:50:54.020
happens if I do this?

00:51:03.010 --> 00:51:05.040
As you might expect,
it's going to give

00:51:05.040 --> 00:51:07.150
me an error, right?

00:51:07.150 --> 00:51:12.450
The reason is that my_variable
has local scope to this

00:51:12.450 --> 00:51:14.570
function, all
_your_vars_are_belong_to_us.

00:51:20.900 --> 00:51:22.290
Is anyone confused by this?

00:51:22.290 --> 00:51:25.070
No one's confused by this?

00:51:25.070 --> 00:51:26.320
OK.

00:51:29.910 --> 00:51:31.160
Let's try something else.

00:51:59.960 --> 00:52:03.230
Let's not do that.

00:52:03.230 --> 00:52:13.700
If I run this code, we can tell
from the function that

00:52:13.700 --> 00:52:16.410
it's taking one parameter.

00:52:16.410 --> 00:52:18.440
It's incrementing
that parameter.

00:52:18.440 --> 00:52:20.460
It's incrementing this
global int that

00:52:20.460 --> 00:52:22.200
we've defined up here.

00:52:22.200 --> 00:52:25.090
It's returning the parameter
that it's just incremented.

00:52:27.670 --> 00:52:31.660
Erase my corny humor.

00:52:47.260 --> 00:52:51.210
The question now is, let's say
that I have a variable y, and

00:52:51.210 --> 00:52:52.610
I give it a value of 10.

00:52:52.610 --> 00:52:54.950
I'm being completely
arbitrary.

00:52:54.950 --> 00:53:01.671
If I call the variable, inc_it,
on y, first of all,

00:53:01.671 --> 00:53:02.921
what's going to print?

00:53:07.500 --> 00:53:09.890
If I print out the value of
y, what's going to print?

00:53:12.510 --> 00:53:13.760
We want to run it.

00:53:22.310 --> 00:53:25.190
Uh-oh, I'm failing.

00:53:37.460 --> 00:53:39.790
I'm stepping on myself here.

00:53:39.790 --> 00:53:43.550
This is why you don't debug
code on the fly.

00:53:43.550 --> 00:53:49.681
If I have a global variable and
I need to reference it, I

00:53:49.681 --> 00:53:50.630
use a global keyword.

00:53:50.630 --> 00:53:51.980
You should never have
to do this.

00:53:55.940 --> 00:53:58.390
Ink_it is going to
return 11, right?

00:53:58.390 --> 00:54:02.320
Because it's taken y, which
is 10, and it's called x

00:54:02.320 --> 00:54:03.890
equal x plus 1.

00:54:03.890 --> 00:54:05.671
Then it's returned this x.

00:54:09.640 --> 00:54:15.490
If I look at what y is, after
I've run this, y is still 10.

00:54:15.490 --> 00:54:22.150
This is because when we've
passed in x here and we've

00:54:22.150 --> 00:54:25.440
called x equal x plus 1, it's
actually shadowing itself.

00:54:25.440 --> 00:54:28.570
It's overriding what's in
the local parameter.

00:54:28.570 --> 00:54:35.240
But it's not overriding the
actual variable, y.

00:54:35.240 --> 00:54:40.110
We'll get more into
this later on.

00:54:40.110 --> 00:54:42.500
The important thing to
understand in this case is

00:54:42.500 --> 00:54:45.440
that the changes that you make
to this parameter stay within

00:54:45.440 --> 00:54:47.760
the function.

00:54:47.760 --> 00:54:48.350
We good?

00:54:48.350 --> 00:54:49.310
All right.

00:54:49.310 --> 00:54:56.330
I need to move pretty quickly
now to gotchas.

00:54:59.180 --> 00:55:02.580
I guarantee you someone's going
to make this mistake.

00:55:02.580 --> 00:55:03.830
Print is not RETURN.

00:55:09.190 --> 00:55:12.230
When you call print
print_is_not_return, it's

00:55:12.230 --> 00:55:14.570
going to call this function.

00:55:14.570 --> 00:55:17.760
It will print out this
string, but it's not

00:55:17.760 --> 00:55:19.700
returning the string.

00:55:19.700 --> 00:55:21.040
What it's returning
is none, because

00:55:21.040 --> 00:55:24.000
there's no return statement.

00:55:24.000 --> 00:55:25.830
That's where this
none comes from.

00:55:29.150 --> 00:55:32.060
RETURN is not print.

00:55:32.060 --> 00:55:36.145
So, if I say print this return
value, it will print this; it

00:55:36.145 --> 00:55:37.470
will return a string.

00:55:37.470 --> 00:55:45.235
But if I just call this, it's
not going to print it again.

00:55:47.890 --> 00:55:49.140
It's going to print nothing.

00:55:55.170 --> 00:55:56.510
You'll just have to
make the mistake.

00:56:03.150 --> 00:56:07.240
One thing to be careful
of in Python--

00:56:07.240 --> 00:56:09.360
remember I said everything
is an object?

00:56:09.360 --> 00:56:10.540
Functions are no different.

00:56:10.540 --> 00:56:13.230
Functions are objects.

00:56:13.230 --> 00:56:20.670
If you just reference the
function's name, cube, which

00:56:20.670 --> 00:56:31.960
is not defined now, it's going
to print something out that

00:56:31.960 --> 00:56:33.210
looks like that.

00:56:36.990 --> 00:56:42.600
This is what the object
looks like to Python.

00:56:42.600 --> 00:56:45.400
In order to call it, you have
to have the parentheses with

00:56:45.400 --> 00:56:46.650
the parameters.

00:56:50.070 --> 00:56:51.040
Python's not going
to complain.

00:56:51.040 --> 00:56:52.980
Some programming languages
will complain.

00:56:52.980 --> 00:56:54.530
Python won't.

00:56:54.530 --> 00:56:56.660
It's possible when you're
running your code, if you're

00:56:56.660 --> 00:56:59.700
trying to call a function and
you forget the parentheses,

00:56:59.700 --> 00:57:02.700
and Python's just not
complaining, it will merrily

00:57:02.700 --> 00:57:06.590
do what you tell it to do.

00:57:06.590 --> 00:57:08.510
AUDIENCE: [INAUDIBLE]

00:57:08.510 --> 00:57:10.840
PROFESSOR: What's that?

00:57:10.840 --> 00:57:12.090
AUDIENCE: [INAUDIBLE]

00:57:16.600 --> 00:57:19.580
PROFESSOR: I'm sorry,
can you speak up?

00:57:19.580 --> 00:57:25.010
AUDIENCE: Print q open
parentheses [INAUDIBLE]

00:57:25.010 --> 00:57:26.590
PROFESSOR: OK.

00:57:26.590 --> 00:57:29.252
Is x defined?

00:57:29.252 --> 00:57:30.502
AUDIENCE: [INAUDIBLE]

00:57:34.400 --> 00:57:35.650
PROFESSOR: Yeah.

