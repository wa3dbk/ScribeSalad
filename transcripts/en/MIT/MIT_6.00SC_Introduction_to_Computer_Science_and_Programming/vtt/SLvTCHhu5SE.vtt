WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:18.440
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:18.440 --> 00:00:19.690
ocw.mit.edu.

00:00:22.800 --> 00:00:23.940
PROFESSOR: Good morning.

00:00:23.940 --> 00:00:25.400
AUDIENCE: Good morning.

00:00:25.400 --> 00:00:27.280
PROFESSOR: Thank you.

00:00:27.280 --> 00:00:28.440
OK.

00:00:28.440 --> 00:00:32.960
So we're about to launch into
learning some basic elements

00:00:32.960 --> 00:00:35.430
of Python today.

00:00:35.430 --> 00:00:39.220
The elements I'm going to talk
about are common to every

00:00:39.220 --> 00:00:44.030
programming language that I
know, at least in concept, and

00:00:44.030 --> 00:00:46.950
of course slightly different
in detail.

00:00:46.950 --> 00:00:49.560
But as I said last time,
everything you're going to

00:00:49.560 --> 00:00:53.125
learn about Python should
be readily transferable.

00:00:55.720 --> 00:01:03.390
I'll be using, for all of the
examples I present, something

00:01:03.390 --> 00:01:07.810
called an integrated development
environment, and

00:01:07.810 --> 00:01:13.775
in particular, one that's built
for Python called IDLE.

00:01:22.030 --> 00:01:25.185
Usually we talk about these
things as IDEs.

00:01:39.010 --> 00:01:45.160
I'm told, I don't know if it's
true, that the IDE for Python

00:01:45.160 --> 00:01:51.500
is called IDLE after Eric Idle
of Monty Python, which was

00:01:51.500 --> 00:01:53.800
also, I'm told, the inspiration
for the name of

00:01:53.800 --> 00:01:55.050
the programming language.

00:01:57.960 --> 00:02:00.860
So what is an integrated
programming environment?

00:02:00.860 --> 00:02:10.259
In this case, it includes a
specialized text editor that

00:02:10.259 --> 00:02:15.760
provides highlighting,
auto-completion, smart indent,

00:02:15.760 --> 00:02:19.020
and you'll see shortly why all
that's very important, and a

00:02:19.020 --> 00:02:23.220
few other amenities that make it
easier to use this to type

00:02:23.220 --> 00:02:28.690
Python than typing it into
a generic text editor.

00:02:28.690 --> 00:02:35.150
It includes something called
a shell, which is the

00:02:35.150 --> 00:02:39.245
environment that actually
interprets the Python code.

00:02:42.000 --> 00:02:46.950
And the nice thing about it
is it includes syntax

00:02:46.950 --> 00:02:48.200
highlighting.

00:02:50.150 --> 00:02:54.300
So the shell gives you some
information about the syntax,

00:02:54.300 --> 00:02:58.650
as does the text editor
of course.

00:02:58.650 --> 00:03:01.950
And finally, it includes
an integrated debugger.

00:03:05.640 --> 00:03:08.470
This could be useful in the
unlikely event that your

00:03:08.470 --> 00:03:12.940
programs have errors when
you write them.

00:03:12.940 --> 00:03:16.860
Though truth be told, I've been
programming in Python for

00:03:16.860 --> 00:03:20.760
years and I don't know that I've
ever used the debugger.

00:03:20.760 --> 00:03:23.200
It's not that I don't make
mistakes, it's just that I'm

00:03:23.200 --> 00:03:26.660
kind of a Luddite, and I
typically use print statements

00:03:26.660 --> 00:03:28.430
for debugging.

00:03:28.430 --> 00:03:31.800
And in fact, almost every
programmer that I know, when

00:03:31.800 --> 00:03:35.280
push comes to shove, ends up
using print statements.

00:03:35.280 --> 00:03:40.800
But the debugger is there,
should you care to take a try.

00:03:40.800 --> 00:03:41.690
All right.

00:03:41.690 --> 00:03:46.940
So you'll see on the screen
here an IDLE shell.

00:03:46.940 --> 00:03:50.800
In the shell, we can
type things.

00:03:50.800 --> 00:03:53.100
What are we going to type?

00:03:53.100 --> 00:03:58.681
Well the first thing to
understand is that at the core

00:03:58.681 --> 00:04:02.970
of Python, and probably the
most important thing to

00:04:02.970 --> 00:04:06.235
understand, are something
called objects.

00:04:10.380 --> 00:04:14.990
Everything in Python
is an object.

00:04:14.990 --> 00:04:18.579
So every kind of entity that you
can create in Python is an

00:04:18.579 --> 00:04:24.040
object, and in fact, Python
code itself is an object.

00:04:24.040 --> 00:04:26.830
You'll remember, we talked about
stored program computers

00:04:26.830 --> 00:04:31.480
last time, and the concept that
a program is data, just

00:04:31.480 --> 00:04:35.020
like a number is data.

00:04:35.020 --> 00:04:46.250
Each object has a type that
tells us the kind of object it

00:04:46.250 --> 00:04:52.910
is, and in particular, what
we can do with it.

00:04:52.910 --> 00:04:58.020
And then there's a built-in
function, called type, that

00:04:58.020 --> 00:05:00.370
can be used to find out
the type of an object.

00:05:04.520 --> 00:05:09.510
As we'll see, there are two
fundamental kinds of types.

00:05:13.500 --> 00:05:16.640
Scalar and non-scalar.

00:05:21.070 --> 00:05:25.330
We'll start with talking
about scalar types.

00:05:25.330 --> 00:05:29.030
And the key thing to think about
there is that they are

00:05:29.030 --> 00:05:30.280
indivisible.

00:05:33.660 --> 00:05:37.300
Think of them as the atoms of
the programming language.

00:05:37.300 --> 00:05:40.100
Now, I know that some of you
have studied physics and know

00:05:40.100 --> 00:05:44.210
that atoms are in principle
divisible, but of course, only

00:05:44.210 --> 00:05:48.020
at great expense and with
serious consequences.

00:05:48.020 --> 00:05:49.500
And we've seen the
same thing here.

00:05:49.500 --> 00:05:54.390
You can, if you're desperate,
chop up these scalar types,

00:05:54.390 --> 00:06:00.030
but it almost always leads
to something bad.

00:06:00.030 --> 00:06:00.380
All right.

00:06:00.380 --> 00:06:02.230
Well let's look at some.

00:06:02.230 --> 00:06:07.890
Well, the first one you'll see
is used to represent integers,

00:06:07.890 --> 00:06:10.100
and that's called int.

00:06:10.100 --> 00:06:14.140
For every type, or every
built-in type, there's the

00:06:14.140 --> 00:06:17.110
notion of a literal, which
is how we type it.

00:06:17.110 --> 00:06:24.470
So for example, we can type 3,
and that will now tell us it

00:06:24.470 --> 00:06:27.400
is the value 3.

00:06:27.400 --> 00:06:29.430
You'll note it's typed
it in blue.

00:06:29.430 --> 00:06:32.660
And I can ask what
the type of 3 is.

00:06:32.660 --> 00:06:35.940
So you'll notice as I type
things into the shell, it's

00:06:35.940 --> 00:06:38.660
using colors to give
me a hint.

00:06:38.660 --> 00:06:42.850
So it's this fuchsia color for
the word type, telling me

00:06:42.850 --> 00:06:46.320
that's a built-in function.

00:06:46.320 --> 00:06:50.370
And now if I ask it, it will
tell me that the type of the

00:06:50.370 --> 00:06:54.930
literal 3 is "int".

00:06:54.930 --> 00:06:57.930
So it's an integer.

00:06:57.930 --> 00:07:00.410
And I can use other
sorts of things.

00:07:06.430 --> 00:07:06.900
All right.

00:07:06.900 --> 00:07:10.930
There's also a type float.

00:07:10.930 --> 00:07:14.130
So those correspond to
the real numbers.

00:07:14.130 --> 00:07:18.470
So I can do something
like that.

00:07:18.470 --> 00:07:22.170
And we'll talk about this in a
second, but you'll notice if I

00:07:22.170 --> 00:07:26.210
do type of 3.2, it tells
me it's a float.

00:07:26.210 --> 00:07:31.980
And for that matter, I can do
type of 3.0, and it will tell

00:07:31.980 --> 00:07:35.060
me it's a float.

00:07:35.060 --> 00:07:37.996
So there's a difference
between 3 and 3.0.

00:07:37.996 --> 00:07:41.940
One is an int, and
one is a float.

00:07:41.940 --> 00:07:46.630
Now you'll notice something
kind of weird here.

00:07:46.630 --> 00:07:51.940
When the interpreter printed
back the value of the literal

00:07:51.940 --> 00:07:57.590
3.2, it gave me 3.2 and a bunch
of zeroes, and then this

00:07:57.590 --> 00:08:01.580
funny 2 standing at the end.

00:08:01.580 --> 00:08:06.040
In a few lectures, I'll explain
why it does this, but

00:08:06.040 --> 00:08:11.620
for now, you should just take
this as a warning that floats

00:08:11.620 --> 00:08:15.650
are not the same thing
as real numbers.

00:08:15.650 --> 00:08:18.490
You learned about reals,
presumably in middle school or

00:08:18.490 --> 00:08:21.390
high school.

00:08:21.390 --> 00:08:25.180
Floats are a computer
scientist's approximation to

00:08:25.180 --> 00:08:28.990
reals, but they're not
quite the same.

00:08:28.990 --> 00:08:32.780
The good news is almost all the
time, you can pretend that

00:08:32.780 --> 00:08:36.580
a floating point number is a
real, but as we'll see in a

00:08:36.580 --> 00:08:41.039
few lectures, every once in a
while it can really sit up and

00:08:41.039 --> 00:08:43.520
bite you, if you believe that.

00:08:43.520 --> 00:08:46.010
But for now, we'll just pretend
that they're reals.

00:08:51.660 --> 00:08:55.030
There's Booleans, a nice scalar
type of which there are

00:08:55.030 --> 00:08:56.280
only two values.

00:08:59.960 --> 00:09:03.200
One of them is true, and what
do you think the other

00:09:03.200 --> 00:09:04.895
Boolean value is?

00:09:04.895 --> 00:09:06.200
AUDIENCE: False?

00:09:06.200 --> 00:09:07.230
PROFESSOR: Thank you.

00:09:07.230 --> 00:09:08.570
So somebody said false.

00:09:08.570 --> 00:09:12.000
I have no idea who, but
whoever it is, there's

00:09:12.000 --> 00:09:14.300
probably some candy to be had.

00:09:14.300 --> 00:09:16.940
Oh, I managed to find the one
place in the room where there

00:09:16.940 --> 00:09:18.520
was an empty.

00:09:18.520 --> 00:09:21.220
I'm hoping that people will now
scramble and fight for it,

00:09:21.220 --> 00:09:25.070
like a foul ball at
a baseball game.

00:09:25.070 --> 00:09:27.320
No, people are too
polite thus far.

00:09:27.320 --> 00:09:28.520
All right.

00:09:28.520 --> 00:09:31.840
So we have true and false
as the type Booleans.

00:09:31.840 --> 00:09:33.870
And then we can do operations
on them.

00:09:33.870 --> 00:09:42.650
So for example, true and false
is false, as you might guess.

00:09:42.650 --> 00:09:49.650
Finally, there's this funny
value, none, which doesn't

00:09:49.650 --> 00:09:51.620
print anything when I type it.

00:09:51.620 --> 00:09:56.150
And if I look at the type
of none, we'll see

00:09:56.150 --> 00:09:59.130
it's the none type.

00:09:59.130 --> 00:10:01.070
Not very interesting.

00:10:01.070 --> 00:10:05.000
Fundamentally, as we'll see,
that gets used when you want

00:10:05.000 --> 00:10:06.700
to put in something temporary.

00:10:06.700 --> 00:10:09.760
When you don't yet know what its
value is going to be, you

00:10:09.760 --> 00:10:13.170
know it's going to eventually
have one, so maybe you start

00:10:13.170 --> 00:10:15.180
out calling it none.

00:10:15.180 --> 00:10:17.440
And then you can check,
and we'll see

00:10:17.440 --> 00:10:20.180
how we might do that.

00:10:20.180 --> 00:10:25.925
So those are the fundamental
scalar types,

00:10:25.925 --> 00:10:29.800
the indivisible ones.

00:10:29.800 --> 00:10:35.290
Interestingly enough, Python
does not have what is a common

00:10:35.290 --> 00:10:39.650
scalar type in every other
language called char, short

00:10:39.650 --> 00:10:41.740
for character.

00:10:41.740 --> 00:10:48.190
Instead, what it has is strings
that can be used to

00:10:48.190 --> 00:10:51.360
represent strings
of characters.

00:10:51.360 --> 00:10:58.500
So for example, I can write the
string "a", and if I ask

00:10:58.500 --> 00:11:03.200
for the type of it, it
tells me it's an

00:11:03.200 --> 00:11:05.485
str, short for string.

00:11:09.450 --> 00:11:12.770
Happens to be a string of
length 1, which we might

00:11:12.770 --> 00:11:15.730
usually think of as
a character, but

00:11:15.730 --> 00:11:17.510
there is no type char.

00:11:17.510 --> 00:11:19.080
So it's not a problem.

00:11:19.080 --> 00:11:21.920
We just have to remember it.

00:11:21.920 --> 00:11:28.270
Literals of type string can be
written with single quotes or

00:11:28.270 --> 00:11:29.520
with double quotes.

00:11:32.110 --> 00:11:34.720
There's no difference.

00:11:34.720 --> 00:11:39.250
Just convenient that you can do
it either way, and we can

00:11:39.250 --> 00:11:42.600
build strings of things.

00:11:42.600 --> 00:11:49.940
It's worth noting that the type
of, say, the string 123

00:11:49.940 --> 00:12:00.390
is str, whereas the type of 123
without the quotes is int.

00:12:00.390 --> 00:12:03.020
So we have to be a little bit
careful sometimes as to

00:12:03.020 --> 00:12:07.860
whether we're dealing with
strings or ints when we look

00:12:07.860 --> 00:12:09.110
at these literals.

00:12:11.530 --> 00:12:17.060
You can only get so far with
literals, things you can type.

00:12:17.060 --> 00:12:20.310
So of course, Python has in
it something called an

00:12:20.310 --> 00:12:21.870
expression.

00:12:21.870 --> 00:12:23.620
Again, this shouldn't
surprise anybody.

00:12:31.185 --> 00:12:40.830
And an expression
is a sequence of

00:12:40.830 --> 00:12:45.305
operands and operators.

00:12:50.950 --> 00:12:52.340
The operands are objects.

00:12:59.610 --> 00:13:05.900
So for example, we can write
the expression 3 plus 2.

00:13:05.900 --> 00:13:09.180
And when we type an expression
into IDLE, it automatically

00:13:09.180 --> 00:13:13.240
evaluates it and prints the
value of the expression.

00:13:13.240 --> 00:13:15.605
In this case, of
course it's 5.

00:13:18.230 --> 00:13:22.500
One thing to be a little careful
about is if I type the

00:13:22.500 --> 00:13:29.005
expression 3/2, slash is the
divide operator, I get 1.

00:13:32.150 --> 00:13:35.620
Whereas if I type the expression
3.0 divided

00:13:35.620 --> 00:13:43.310
by 2.0, I get 1.5.

00:13:43.310 --> 00:13:49.760
So dividing two integers
in Python 2.x gives you

00:13:49.760 --> 00:13:51.405
essentially a floor operator.

00:13:53.940 --> 00:13:59.120
In 3.0, by the way, integer
division is not allowed.

00:13:59.120 --> 00:14:01.780
It always converts it to floats
and does a floating

00:14:01.780 --> 00:14:03.670
point division.

00:14:03.670 --> 00:14:06.370
But for many of you this will
be something that will trip

00:14:06.370 --> 00:14:08.520
you up as a bug.

00:14:08.520 --> 00:14:12.970
If you want to get real
division, write

00:14:12.970 --> 00:14:15.030
floating point numbers.

00:14:15.030 --> 00:14:20.640
Otherwise, unpleasant
things may happen.

00:14:20.640 --> 00:14:24.240
Some other interesting things
I can type, just as I could

00:14:24.240 --> 00:14:32.050
type 3 plus 2, I can
type a plus b.

00:14:32.050 --> 00:14:33.300
What do you think
I'll get there?

00:14:37.160 --> 00:14:38.490
It does concatenation.

00:14:41.680 --> 00:14:49.190
So what we see here is that
the operator plus is

00:14:49.190 --> 00:14:50.440
overloaded.

00:14:59.060 --> 00:15:11.120
So overloaded operators have a
meaning that depends upon the

00:15:11.120 --> 00:15:12.370
type of the operands.

00:15:25.710 --> 00:15:28.170
And of course, we've already
seen that with the slash

00:15:28.170 --> 00:15:31.430
operator, which means one thing
for ints and another

00:15:31.430 --> 00:15:33.310
things for floats.

00:15:33.310 --> 00:15:35.585
And of course, we see the
same thing with plus.

00:15:39.700 --> 00:15:41.490
What do you think will
happen here?

00:15:41.490 --> 00:15:44.810
3 blank 3?

00:15:44.810 --> 00:15:46.060
Any guesses?

00:15:48.390 --> 00:15:50.120
I get a syntax error.

00:15:50.120 --> 00:15:52.810
Remember, we talked about
that on Tuesday.

00:15:52.810 --> 00:15:57.490
It's not a valid Python
expression,

00:15:57.490 --> 00:16:00.670
so we get an error.

00:16:00.670 --> 00:16:01.920
How about this one?

00:16:06.380 --> 00:16:09.400
That is syntactically valid.

00:16:09.400 --> 00:16:13.280
It's got operand, operator,
operand.

00:16:13.280 --> 00:16:17.830
What do you think it will do
when I hit Return here?

00:16:17.830 --> 00:16:20.040
Somebody?

00:16:20.040 --> 00:16:22.000
AUDIENCE: A static
semantics error?

00:16:22.000 --> 00:16:22.490
PROFESSOR: Pardon?

00:16:22.490 --> 00:16:24.450
AUDIENCE: A static
semantics error?

00:16:24.450 --> 00:16:26.410
PROFESSOR: A static
semantics error.

00:16:26.410 --> 00:16:26.900
And because of these--

00:16:26.900 --> 00:16:28.500
Wait, I can't see
who said that.

00:16:28.500 --> 00:16:29.995
Raise your hand?

00:16:29.995 --> 00:16:31.480
Oh, come on.

00:16:31.480 --> 00:16:33.955
All the way back there?

00:16:33.955 --> 00:16:34.945
All right.

00:16:34.945 --> 00:16:37.915
I have the most chance of
carrying with one of these.

00:16:43.870 --> 00:16:45.260
I'm going to lie.

00:16:45.260 --> 00:16:47.460
Those of you who are watching
OpenCourseWare, it was a

00:16:47.460 --> 00:16:48.710
perfect throw.

00:16:51.450 --> 00:16:52.210
OK.

00:16:52.210 --> 00:16:58.310
So indeed, we get a static
semantic error of a particular

00:16:58.310 --> 00:17:01.770
kind, called the type error,
saying you cannot concatenate

00:17:01.770 --> 00:17:04.440
an str and an int.

00:17:08.140 --> 00:17:12.345
Type errors are actually
good things.

00:17:15.190 --> 00:17:19.530
The language does type checking
in order to reduce

00:17:19.530 --> 00:17:22.450
the probability that a
programmer will write a

00:17:22.450 --> 00:17:28.980
program with a meaning that
will surprise its author.

00:17:28.980 --> 00:17:32.380
So it looks at it and says,
somebody might have a weird

00:17:32.380 --> 00:17:35.760
guess what this means, but just
to be safe, we're going

00:17:35.760 --> 00:17:38.560
to disallow it rather than--

00:17:38.560 --> 00:17:40.750
it could, of course, make
up some funny meaning

00:17:40.750 --> 00:17:42.600
if it wanted to.

00:17:42.600 --> 00:17:43.970
But it doesn't.

00:17:43.970 --> 00:17:48.740
And I think you'll find type
checking saves you from a lot

00:17:48.740 --> 00:17:55.020
of careless programming
errors as you go on.

00:17:55.020 --> 00:17:56.410
All right, let's continue.

00:17:56.410 --> 00:17:58.840
Let's look at some
other things.

00:17:58.840 --> 00:18:00.090
I can write this.

00:18:04.920 --> 00:18:07.450
Because that's just two
strings, and it just

00:18:07.450 --> 00:18:12.370
concatenates them, the string
a and the string 3.

00:18:12.370 --> 00:18:14.310
Or interestingly,
I can do this.

00:18:18.690 --> 00:18:22.530
So now what we're seeing is
that you can take any type

00:18:22.530 --> 00:18:29.260
name, use it as a conversion
function to attempt to convert

00:18:29.260 --> 00:18:31.950
one type to another.

00:18:31.950 --> 00:18:37.330
So this has now converted the
int 3 to the str "3".

00:18:41.690 --> 00:18:44.815
Similarly, I can do something
like this.

00:18:51.010 --> 00:18:56.430
And here, it's converted the
str "3" to the int 3.

00:19:00.250 --> 00:19:01.865
On the other hand,
I could do this.

00:19:12.280 --> 00:19:17.670
And it will tell me it's a
static semantic error.

00:19:17.670 --> 00:19:23.450
It can't convert 0.0
into an int.

00:19:23.450 --> 00:19:31.840
Similarly, it can't
convert 2.1.

00:19:31.840 --> 00:19:33.670
Or can it?

00:19:33.670 --> 00:19:37.460
So now I've given it the float
2.1, and I've tried to

00:19:37.460 --> 00:19:39.120
convert it to int.

00:19:39.120 --> 00:19:41.760
Not the string 2.1,
but the float.

00:19:41.760 --> 00:19:43.010
And it succeeds.

00:19:45.580 --> 00:19:49.110
And it succeeded by essentially
truncating it.

00:19:53.280 --> 00:19:55.280
Is this a good thing
or a bad thing?

00:19:57.960 --> 00:20:00.690
To me, it's kind
of a bad thing.

00:20:00.690 --> 00:20:04.050
If I've typed something like
that or I've evaluated some

00:20:04.050 --> 00:20:08.610
expression that happened to
work that way, more likely

00:20:08.610 --> 00:20:10.010
than not, I'm confused.

00:20:10.010 --> 00:20:13.660
And I would probably have
preferred to get a type error,

00:20:13.660 --> 00:20:17.180
rather than it deciding
how to do it.

00:20:17.180 --> 00:20:20.740
It's one of the things I don't
like about Python.

00:20:20.740 --> 00:20:22.600
It's too generous.

00:20:22.600 --> 00:20:24.760
It lets me get away with
stuff it shouldn't

00:20:24.760 --> 00:20:26.560
let me get away with.

00:20:26.560 --> 00:20:31.020
Other languages, for example
Java, are much stricter.

00:20:31.020 --> 00:20:35.310
This is a design decision and
it is the way it is, and we

00:20:35.310 --> 00:20:36.896
have to live with it.

00:20:36.896 --> 00:20:37.830
AUDIENCE: Professor?

00:20:37.830 --> 00:20:38.290
Yes?

00:20:38.290 --> 00:20:40.720
AUDIENCE: Is that the same
reason that 3 divided by 2

00:20:40.720 --> 00:20:42.664
turned into 1 up top?

00:20:42.664 --> 00:20:43.150
PROFESSOR: Yeah.

00:20:43.150 --> 00:20:44.620
Exactly.

00:20:44.620 --> 00:20:48.965
If it's the same reason that
that happens, this will never

00:20:48.965 --> 00:20:52.304
go that far.

00:20:52.304 --> 00:20:53.735
[UNINTELLIGIBLE].

00:20:53.735 --> 00:20:55.440
Yeah, exactly.

00:20:55.440 --> 00:20:56.590
It's the same reason.

00:20:56.590 --> 00:20:59.380
The question was, is it the same
reason that 3 divided by

00:20:59.380 --> 00:21:02.940
2 doesn't give you the
answer you would get

00:21:02.940 --> 00:21:03.880
with floating point.

00:21:03.880 --> 00:21:08.130
And it's because Python
has tried to help you.

00:21:08.130 --> 00:21:13.210
Again, Python 3.0 is a little
stricter about these things.

00:21:13.210 --> 00:21:15.590
We'll talk much more about
this during the term.

00:21:18.600 --> 00:21:22.370
This is close to the last time
you'll see me typing things

00:21:22.370 --> 00:21:24.940
directly into IDLE.

00:21:24.940 --> 00:21:28.220
For the most part, as you write
programs, you'll use the

00:21:28.220 --> 00:21:32.220
text editor to produce them
and then go to the

00:21:32.220 --> 00:21:34.080
shell to run them.

00:21:34.080 --> 00:21:36.180
But you want to--

00:21:36.180 --> 00:21:38.920
obviously, if I had a 100 line
program, I wouldn't want to

00:21:38.920 --> 00:21:42.690
sit here and retype it every
time I needed to change it.

00:21:42.690 --> 00:21:45.320
So instead, I use the editor
in IDLE to produce the

00:21:45.320 --> 00:21:49.320
programs, and then
I can run them.

00:21:49.320 --> 00:21:52.200
And that's what I wanted
to start doing.

00:21:52.200 --> 00:21:58.160
I should probably mention that
what most people call a

00:21:58.160 --> 00:22:03.650
program, some Python programmers
call a script.

00:22:07.130 --> 00:22:10.790
Think of those two things
as synonyms.

00:22:10.790 --> 00:22:15.020
But you will see people
use both of them.

00:22:15.020 --> 00:22:19.180
I will typically call
them a program.

00:22:19.180 --> 00:22:19.530
All right.

00:22:19.530 --> 00:22:22.790
Let's look at an example.

00:22:22.790 --> 00:22:27.450
So the first thing to say is
that things look a little bit

00:22:27.450 --> 00:22:30.950
different when they're executed
from a script than

00:22:30.950 --> 00:22:35.040
when you execute them directly
in the interpreter.

00:22:35.040 --> 00:22:37.825
So I happen to have
a script here.

00:22:40.900 --> 00:22:44.440
If a line in a script starts
with a sharp sign or a number

00:22:44.440 --> 00:22:47.360
sign, that makes it a comment.

00:22:47.360 --> 00:22:49.300
So it's not executed.

00:22:49.300 --> 00:22:53.365
So I've started here just by
commenting out everything.

00:22:57.070 --> 00:22:58.660
But now--

00:22:58.660 --> 00:22:59.910
whoops--

00:23:05.230 --> 00:23:08.250
what happens if I just put
the number 3 here?

00:23:08.250 --> 00:23:12.600
We saw when I typed it into
IDLE, it echoed it in some

00:23:12.600 --> 00:23:14.615
sense and gave me what it was.

00:23:14.615 --> 00:23:18.170
Or just to be clear, I'm
going to put in the

00:23:18.170 --> 00:23:21.630
expression type of 3.

00:23:21.630 --> 00:23:27.380
I'll save it, and then I'll
hit F5 to run it.

00:23:27.380 --> 00:23:28.840
And it does nothing.

00:23:28.840 --> 00:23:29.190
Right?

00:23:29.190 --> 00:23:30.470
You saw it move.

00:23:30.470 --> 00:23:32.360
It didn't print anything.

00:23:32.360 --> 00:23:34.770
So when you type an expression
into the shell,

00:23:34.770 --> 00:23:36.690
it prints the value.

00:23:36.690 --> 00:23:39.760
But when it executes a script
with an expression, it

00:23:39.760 --> 00:23:42.430
evaluates the expression
but does not

00:23:42.430 --> 00:23:45.590
display it on the screen.

00:23:45.590 --> 00:23:48.420
Well, so what do we
do about that?

00:23:48.420 --> 00:23:52.520
There is something called
a print command.

00:23:52.520 --> 00:24:01.260
So I can do this, Print type of
3, and now if I run it, it

00:24:01.260 --> 00:24:03.890
will actually appear.

00:24:03.890 --> 00:24:06.200
So whenever you want to get
something to appear, you have

00:24:06.200 --> 00:24:09.600
to use the Print command.

00:24:09.600 --> 00:24:11.315
Not a very complicated
concept.

00:24:16.220 --> 00:24:25.240
A program, or a script, is
a sequence of commands.

00:24:28.610 --> 00:24:33.100
Each one tells the interpreter
to do something.

00:24:33.100 --> 00:24:35.660
So a command is Print,
for example.

00:24:42.470 --> 00:24:42.930
OK.

00:24:42.930 --> 00:24:43.980
So that's there.

00:24:43.980 --> 00:24:44.960
That's kind of boring.

00:24:44.960 --> 00:24:46.210
I'll get rid of that.

00:24:49.480 --> 00:24:55.040
The next command is a really
interesting one.

00:24:55.040 --> 00:24:58.750
It's an assignment statement.

00:24:58.750 --> 00:25:04.850
A key concept in almost every
programming language is that

00:25:04.850 --> 00:25:06.100
of a variable.

00:25:08.570 --> 00:25:12.010
Different languages have
different notions of what a

00:25:12.010 --> 00:25:14.940
variable means.

00:25:14.940 --> 00:25:21.540
In Python, a variable is simply
a name for an object.

00:25:43.880 --> 00:25:47.520
And what an assignment statement
does in Python, is

00:25:47.520 --> 00:25:51.315
it binds the name
to an object.

00:26:05.860 --> 00:26:11.390
So the assignment stetement you
see here binds the name x

00:26:11.390 --> 00:26:12.715
to the object 3.

00:26:17.650 --> 00:26:22.750
The next statement rebinds the
name x to the value of the

00:26:22.750 --> 00:26:25.530
expression x times x.

00:26:25.530 --> 00:26:30.190
So it takes the old value of x,
evaluates the expression,

00:26:30.190 --> 00:26:33.200
and then binds the name
x to the new value.

00:26:33.200 --> 00:26:36.870
So at the end of the
second statement, x

00:26:36.870 --> 00:26:38.560
will be bound to 9.

00:26:38.560 --> 00:26:41.020
By the way, these are really
stupid comments

00:26:41.020 --> 00:26:43.320
I've written here.

00:26:43.320 --> 00:26:44.920
I put them in just to
show you what these

00:26:44.920 --> 00:26:46.390
statements are doing.

00:26:46.390 --> 00:26:49.210
For goodness sake, when you
write comments in your

00:26:49.210 --> 00:26:54.070
programs, assume that the reader
can read Python, and

00:26:54.070 --> 00:26:55.690
you don't have to explain
the programming

00:26:55.690 --> 00:26:58.310
language in your comments.

00:26:58.310 --> 00:27:01.360
That's not to say you shouldn't
write any comments.

00:27:01.360 --> 00:27:04.270
The purpose of a comment
is to make the

00:27:04.270 --> 00:27:08.030
program easier to read.

00:27:08.030 --> 00:27:11.390
And so typically, comments are
there to explain things.

00:27:13.950 --> 00:27:18.430
Not to explain the language or
its semantics, but to explain

00:27:18.430 --> 00:27:22.530
your thinking when you
wrote the program.

00:27:22.530 --> 00:27:26.450
What is the algorithm
you've used?

00:27:26.450 --> 00:27:29.950
And we'll see some useful
examples of comments, probably

00:27:29.950 --> 00:27:32.610
not today, but later.

00:27:32.610 --> 00:27:32.950
All right.

00:27:32.950 --> 00:27:34.570
So let's execute this script.

00:27:38.820 --> 00:27:41.890
Sure enough, it printed 9.

00:27:41.890 --> 00:27:43.365
Just what we would have hoped.

00:27:49.410 --> 00:27:49.770
All right.

00:27:49.770 --> 00:27:51.970
Now let's try some
other things.

00:27:57.220 --> 00:28:00.840
Print lets us output things.

00:28:00.840 --> 00:28:05.240
Raw input lets us
input things.

00:28:05.240 --> 00:28:10.070
Get things from the keyboard,
essentially.

00:28:10.070 --> 00:28:14.830
So this statement here is making
a request to whoever is

00:28:14.830 --> 00:28:17.280
using the program to
enter a number.

00:28:19.910 --> 00:28:26.100
There are two kinds of input
statements in Python 2.x.

00:28:26.100 --> 00:28:29.270
There's raw input, which is the
only one you will see me

00:28:29.270 --> 00:28:32.860
use, and input.

00:28:32.860 --> 00:28:38.770
Raw input, by the way, is the
only one that exists in 3.0.

00:28:38.770 --> 00:28:44.080
So please, just use raw input.

00:28:44.080 --> 00:28:48.710
The difference is, raw input
always expects, interprets

00:28:48.710 --> 00:28:52.690
what the user types
as a string.

00:28:52.690 --> 00:29:02.160
So it will see here, it says,
y equals float of raw input.

00:29:02.160 --> 00:29:03.600
Enter a number.

00:29:03.600 --> 00:29:06.750
So let's run it.

00:29:06.750 --> 00:29:12.220
So it's taken the argument to
raw input, the string enter a

00:29:12.220 --> 00:29:14.740
number asked me to
enter a number.

00:29:14.740 --> 00:29:15.990
I'll enter a number.

00:29:20.280 --> 00:29:28.390
And then it's converted
it to a float.

00:29:28.390 --> 00:29:29.845
Suppose I get rid of that.

00:29:32.600 --> 00:29:33.850
Suppose I do this.

00:29:50.560 --> 00:29:51.810
That should work.

00:30:06.170 --> 00:30:07.620
So now something has happened.

00:30:07.620 --> 00:30:11.140
It's printed both
of them as 3.0.

00:30:11.140 --> 00:30:14.480
It looks like they're
the same, but in

00:30:14.480 --> 00:30:17.880
fact, they're not.

00:30:17.880 --> 00:30:20.280
And this is something
to beware of.

00:30:20.280 --> 00:30:28.000
What we've seen here is when
it prints a string, it does

00:30:28.000 --> 00:30:31.760
not print the quotation marks.

00:30:31.760 --> 00:30:38.930
So even though, if I were to put
this in here, I'll put in

00:30:38.930 --> 00:30:40.480
two print types of y.

00:30:47.520 --> 00:30:50.590
And I'll comment this out
because I'm getting kind of

00:30:50.590 --> 00:30:51.950
tired of seeing 9.

00:31:03.230 --> 00:31:04.980
You'll note that one
is a string and

00:31:04.980 --> 00:31:07.860
the other is a float.

00:31:07.860 --> 00:31:10.130
Again, I point this out because
this is something that

00:31:10.130 --> 00:31:14.040
can confuse people when they're
debugging programs.

00:31:14.040 --> 00:31:16.530
Because you think it's
a float, when

00:31:16.530 --> 00:31:17.780
in fact it's a string.

00:31:20.750 --> 00:31:21.180
OK.

00:31:21.180 --> 00:31:24.830
Nothing deep, but these are the
things that sort of get

00:31:24.830 --> 00:31:27.650
people in trouble.

00:31:27.650 --> 00:31:32.590
Now the kinds of programs we've
been looking at so far

00:31:32.590 --> 00:31:34.730
are what are called straight
line programs.

00:31:43.740 --> 00:31:48.750
What distinguishes a straight
line program is it's a

00:31:48.750 --> 00:31:52.860
sequence of commands you execute
one after another.

00:31:52.860 --> 00:31:57.000
You execute every command
without making any deviations,

00:31:57.000 --> 00:32:00.340
without going back with any
loops to execute a command

00:32:00.340 --> 00:32:01.930
more than once.

00:32:01.930 --> 00:32:05.940
So in a straight line program,
every command gets executed

00:32:05.940 --> 00:32:07.235
exactly once.

00:32:10.430 --> 00:32:16.010
There is a very elegant, and
even useful theory that talks

00:32:16.010 --> 00:32:19.050
about different layers of,
levels of complexity of

00:32:19.050 --> 00:32:23.220
programs and says, for
example, what kind of

00:32:23.220 --> 00:32:27.380
functions can you compute with
straight line programs.

00:32:27.380 --> 00:32:30.290
We'll talk more about that
field, which is called

00:32:30.290 --> 00:32:34.240
complexity theory, later
in this semester.

00:32:34.240 --> 00:32:37.130
But for now, the thing to
realize is that straight line

00:32:37.130 --> 00:32:40.500
programs are just dead boring.

00:32:40.500 --> 00:32:45.010
You can't compute anything
interesting with one.

00:32:45.010 --> 00:32:47.240
Last time we talked about
a recipe as an

00:32:47.240 --> 00:32:50.700
analogy for a program.

00:32:50.700 --> 00:32:54.850
Imagine a recipe
with no tests.

00:32:54.850 --> 00:32:57.320
So every recipe, or almost
every recipe I

00:32:57.320 --> 00:33:00.700
know, has some decisions.

00:33:00.700 --> 00:33:03.240
Taste it and add salt
if you need it.

00:33:03.240 --> 00:33:06.640
Or poke at the meat and
see if it's done.

00:33:06.640 --> 00:33:08.770
Or cook it until the
thermometer says

00:33:08.770 --> 00:33:11.880
some degree on it.

00:33:11.880 --> 00:33:14.380
Those are the kinds of
tests we need to

00:33:14.380 --> 00:33:17.660
make interesting programs.

00:33:17.660 --> 00:33:22.630
The most primitive kind of test
we see is what's called a

00:33:22.630 --> 00:33:23.880
conditional statement.

00:33:31.940 --> 00:33:36.400
And those are written using the
word if, and optionally as

00:33:36.400 --> 00:33:44.800
we'll see, the words else or
elif, standing for else, if.

00:33:44.800 --> 00:33:46.770
So let's look at an
example here.

00:33:52.420 --> 00:33:54.030
Where'd my mouse,
oh there it is.

00:34:05.540 --> 00:34:06.790
Yes?

00:34:08.530 --> 00:34:09.850
Somebody has a question?

00:34:09.850 --> 00:34:11.600
Shout it out.

00:34:11.600 --> 00:34:11.989
AUDIENCE: Sorry.

00:34:11.989 --> 00:34:15.322
I was wondering, when the user's
prompted to put in the

00:34:15.322 --> 00:34:18.654
raw input, instead of putting
in a float, puts in string,

00:34:18.654 --> 00:34:21.462
could you define it as
a floating integer?

00:34:21.462 --> 00:34:23.040
How would you interpret
that input?

00:34:23.040 --> 00:34:25.270
PROFESSOR: I didn't
get the question.

00:34:25.270 --> 00:34:28.310
So this is an argument to
raw input, or their

00:34:28.310 --> 00:34:31.080
response to raw input.

00:34:31.080 --> 00:34:32.949
AUDIENCE: So yeah, for the
raw input where you

00:34:32.949 --> 00:34:34.280
define it as a quote--

00:34:34.280 --> 00:34:34.772
PROFESSOR: Yeah.

00:34:34.772 --> 00:34:36.248
AUDIENCE: It usually
puts in a string.

00:34:36.248 --> 00:34:38.710
How does Python interpret
that?

00:34:38.710 --> 00:34:40.600
PROFESSOR: It will interpret
it as a string containing

00:34:40.600 --> 00:34:42.606
quotation marks.

00:34:42.606 --> 00:34:43.020
AUDIENCE: OK.

00:34:43.020 --> 00:34:46.420
PROFESSOR: So typically you
don't type a string, because

00:34:46.420 --> 00:34:50.270
it interprets everything you
type as if it were a string.

00:34:50.270 --> 00:34:53.254
So don't bother typing
strings.

00:34:53.254 --> 00:34:54.179
Good question.

00:34:54.179 --> 00:34:57.045
Thank you.

00:34:57.045 --> 00:34:57.490
All right.

00:34:57.490 --> 00:34:58.740
So let's look at this.

00:35:03.670 --> 00:35:08.120
So here I'm going to get an
int, or at least a string.

00:35:08.120 --> 00:35:10.610
I'll convert it to an int.

00:35:10.610 --> 00:35:14.690
Then I'll say, if x remainder
two, that's what the percent

00:35:14.690 --> 00:35:17.980
sign is, it's a remainder
or a mod operator,

00:35:17.980 --> 00:35:21.100
is equal equal zero.

00:35:21.100 --> 00:35:22.460
That's important.

00:35:22.460 --> 00:35:29.100
You'll notice that we used an
equal sign to do assignments.

00:35:29.100 --> 00:35:33.580
If we want to do a comparison,
whether two objects have the

00:35:33.580 --> 00:35:36.710
same value, we don't write
a single equal.

00:35:36.710 --> 00:35:39.290
We write a double equal.

00:35:39.290 --> 00:35:42.930
So whenever you're testing for
equality of objects, you use

00:35:42.930 --> 00:35:45.590
double equal.

00:35:45.590 --> 00:35:51.040
So it says, if the object x mod
2 has the same value as

00:35:51.040 --> 00:35:55.520
the object zero, print even.

00:35:55.520 --> 00:35:58.700
Else, print odd.

00:35:58.700 --> 00:36:02.080
And then, just for fun, I'm
going to see whether or not

00:36:02.080 --> 00:36:04.150
it's divisible by three.

00:36:04.150 --> 00:36:06.010
Why did I do that?

00:36:06.010 --> 00:36:09.100
Just to show you that I can
nest conditionals inside

00:36:09.100 --> 00:36:11.190
conditionals.

00:36:11.190 --> 00:36:13.660
So in one of the branches of
the conditionals, I'm now

00:36:13.660 --> 00:36:16.090
doing a test.

00:36:16.090 --> 00:36:20.960
So what this does, is if comes
down, it does the test.

00:36:20.960 --> 00:36:27.250
If the value of the test is
true, it executes the block of

00:36:27.250 --> 00:36:33.090
code following the if, in
this case, just print.

00:36:33.090 --> 00:36:34.860
And then it skips the else.

00:36:34.860 --> 00:36:36.930
It does not execute the else.

00:36:36.930 --> 00:36:40.250
So it executes one
or the other.

00:36:40.250 --> 00:36:44.490
If the test is false, it skips
the block of code following

00:36:44.490 --> 00:36:49.870
the if and executes the block
of code following the else.

00:36:49.870 --> 00:36:53.441
So it does a or b,
but not both.

00:36:53.441 --> 00:36:57.280
The indentation is important.

00:36:57.280 --> 00:37:03.270
Python is very unusual in that
the way you indent things

00:37:03.270 --> 00:37:05.630
actually affects the
meaning of them.

00:37:09.460 --> 00:37:12.590
And you can tell that, if I
were to type this in the

00:37:12.590 --> 00:37:18.080
editor, you'll note here it's
on that line, but if I hit

00:37:18.080 --> 00:37:21.050
Return, it automatically
indents it.

00:37:21.050 --> 00:37:23.790
That's the auto indent feature
I mentioned earlier in the

00:37:23.790 --> 00:37:26.890
editor of IDLE.

00:37:26.890 --> 00:37:30.920
And this tells me how these
things line up.

00:37:30.920 --> 00:37:37.320
So the fact that this is here
tells me I execute it only as

00:37:37.320 --> 00:37:40.460
part of the else clause.

00:37:40.460 --> 00:37:43.580
The program would mean something
quite different if I

00:37:43.580 --> 00:37:44.830
wrote this.

00:37:48.520 --> 00:37:55.310
Then it would mean, if x mod
2 is zero, print even.

00:37:55.310 --> 00:37:57.340
Otherwise, print odd.

00:37:57.340 --> 00:38:00.370
And whether or not it was
even or odd, do this

00:38:00.370 --> 00:38:01.620
test in the if statement.

00:38:04.260 --> 00:38:08.440
So the indentation actually
affects the

00:38:08.440 --> 00:38:11.750
meaning of the program.

00:38:11.750 --> 00:38:15.120
Now a lot of other languages,
almost all other languages,

00:38:15.120 --> 00:38:16.500
don't do that.

00:38:16.500 --> 00:38:18.830
They have some punctuation.

00:38:18.830 --> 00:38:23.180
For example, c uses set braces
to designate what's called a

00:38:23.180 --> 00:38:24.430
block of code.

00:38:29.850 --> 00:38:34.720
If you look, however, at a
well-written piece of C code,

00:38:34.720 --> 00:38:38.820
or Java code, or any other
language that I know,

00:38:38.820 --> 00:38:43.440
programmers are trained to use
indentation to show the

00:38:43.440 --> 00:38:45.770
structure of the program.

00:38:45.770 --> 00:38:48.300
Even though you don't need, it
you could line up everything

00:38:48.300 --> 00:38:53.330
right at the left edge and
just use the punctuation.

00:38:53.330 --> 00:38:54.570
People don't do that.

00:38:54.570 --> 00:38:59.880
And the reason they don't do
that is programs are intended

00:38:59.880 --> 00:39:11.470
to be read, not just executed.

00:39:11.470 --> 00:39:14.630
Why are they intended
to be read?

00:39:14.630 --> 00:39:17.890
Because the only reason, the
only way you can debug a

00:39:17.890 --> 00:39:19.920
program is reading
the code in it.

00:39:23.920 --> 00:39:26.900
Typically, you want to write
your program so that if you

00:39:26.900 --> 00:39:31.220
look at it from a distance, the
visual structure of the

00:39:31.220 --> 00:39:35.710
program reflects the semantics
of the program.

00:39:35.710 --> 00:39:38.340
And that's why people use
indentation when they don't

00:39:38.340 --> 00:39:42.010
need to, so that you can see the
structure of the program

00:39:42.010 --> 00:39:46.850
by looking at it on your screen
and not having to parse

00:39:46.850 --> 00:39:49.790
each symbol.

00:39:49.790 --> 00:39:52.760
The authors of Python made what
I think is a very good

00:39:52.760 --> 00:39:54.260
design decision.

00:39:54.260 --> 00:39:56.680
They said, well, if that's the
way you ought to write your

00:39:56.680 --> 00:40:00.310
programs, let's force people to
write their programs that

00:40:00.310 --> 00:40:06.400
way and guarantee that the
visual structure of the

00:40:06.400 --> 00:40:10.970
program actually matches
the semantic structure.

00:40:10.970 --> 00:40:15.310
The problem with languages like
C and Java is that you

00:40:15.310 --> 00:40:19.970
can indent things and fool the
reader of the program by

00:40:19.970 --> 00:40:24.180
making it look like something is
under something else, when

00:40:24.180 --> 00:40:28.650
in fact it really isn't, because
of the punctuation.

00:40:28.650 --> 00:40:31.790
So here we have a guarantee
that the visual structure

00:40:31.790 --> 00:40:35.020
matches the semantic structure,
and I think that

00:40:35.020 --> 00:40:40.690
was one of the really good
design decisions in Python.

00:40:40.690 --> 00:40:43.630
OK, people see that?

00:40:43.630 --> 00:40:46.180
So we could execute
this program.

00:40:46.180 --> 00:40:50.780
Let me get back to what
it was before.

00:40:50.780 --> 00:40:53.080
Control z is the go back.

00:40:56.660 --> 00:41:00.900
And now we can enter an integer,
say 14, and it will

00:41:00.900 --> 00:41:04.150
tell us it's even.

00:41:04.150 --> 00:41:10.810
I can run it again, and now I'll
put 15 in, and it will

00:41:10.810 --> 00:41:14.140
tell me it's odd.

00:41:14.140 --> 00:41:17.770
We'll try it once more.

00:41:17.770 --> 00:41:20.290
We'll put in 17.

00:41:20.290 --> 00:41:25.160
It was odd and it's not
divisible by three.

00:41:25.160 --> 00:41:29.445
These kinds of programs are
called branching programs.

00:41:41.220 --> 00:41:43.380
And that's because the structure
of them, as you go

00:41:43.380 --> 00:41:46.690
down you execute some
statements, and then there's a

00:41:46.690 --> 00:41:51.200
branch which says execute these
statements or execute

00:41:51.200 --> 00:41:53.530
those statements.

00:41:53.530 --> 00:42:00.530
And then typically it comes back
together and continues.

00:42:00.530 --> 00:42:03.620
Of course, branches can
have sub-branches.

00:42:03.620 --> 00:42:09.460
We could do this and then
join further down,

00:42:09.460 --> 00:42:10.710
as we've seen here.

00:42:13.040 --> 00:42:16.820
Now branching programs are much
more interesting than

00:42:16.820 --> 00:42:19.090
straight line programs.

00:42:19.090 --> 00:42:24.450
We can do a lot of things with
them, but fundamentally

00:42:24.450 --> 00:42:28.130
nothing really interesting.

00:42:28.130 --> 00:42:33.190
And we can think about that by
thinking about how long it

00:42:33.190 --> 00:42:36.820
takes a branching
program to run.

00:42:36.820 --> 00:42:39.650
So let's first ask the question,
how long does it

00:42:39.650 --> 00:42:43.310
take a straight line
program to run?

00:42:43.310 --> 00:42:44.780
14 seconds?

00:42:44.780 --> 00:42:47.580
No, that's not the way
to think about it.

00:42:47.580 --> 00:42:50.260
How would we think about how
long it takes it to run?

00:42:50.260 --> 00:42:53.250
What governs the length
of time a straight

00:42:53.250 --> 00:42:56.135
line program can take?

00:42:56.135 --> 00:42:57.530
AUDIENCE: [INAUDIBLE].

00:42:57.530 --> 00:42:58.630
PROFESSOR: Exactly.

00:42:58.630 --> 00:43:02.610
The number of statements or
commands in the program.

00:43:02.610 --> 00:43:07.110
Since it executes every command
exactly once, if you

00:43:07.110 --> 00:43:11.350
have 100 command, it will
have 100 steps in it.

00:43:11.350 --> 00:43:14.190
Now there's some variation on
how long each step will be.

00:43:14.190 --> 00:43:18.400
Some commands might take longer
than others, but the

00:43:18.400 --> 00:43:21.320
length of time it can take
to run has nothing

00:43:21.320 --> 00:43:23.340
to do with its input.

00:43:23.340 --> 00:43:28.930
It has to do only with the
number of lines of code.

00:43:28.930 --> 00:43:34.230
And that tells us it's not very
useful because, well, we

00:43:34.230 --> 00:43:37.640
can only type so many lines
in our lifetime.

00:43:37.640 --> 00:43:40.180
Well branching programs
have the same problem.

00:43:42.890 --> 00:43:45.200
In a branching program,
each command is

00:43:45.200 --> 00:43:49.290
executed at most once.

00:43:49.290 --> 00:43:53.170
So again, the length of time
it takes to execute the

00:43:53.170 --> 00:43:59.820
program is governed strictly
by the size of the program.

00:43:59.820 --> 00:44:02.050
Why isn't that good enough?

00:44:02.050 --> 00:44:07.330
Well, think about a program,
say, to compute the GPA of all

00:44:07.330 --> 00:44:08.580
the students at MIT.

00:44:11.460 --> 00:44:13.590
Well how long is that
going to take?

00:44:16.720 --> 00:44:21.630
Think instead about a program to
compute the GPA of all the

00:44:21.630 --> 00:44:26.620
students at the University of
Michigan, which is probably 10

00:44:26.620 --> 00:44:28.730
times bigger than MIT.

00:44:28.730 --> 00:44:31.420
Well you would expect that
to take longer, right?

00:44:31.420 --> 00:44:35.270
Because you have to look
at more students.

00:44:35.270 --> 00:44:37.160
And in fact, it's true.

00:44:37.160 --> 00:44:40.390
Most programs that are
interesting, the amount of

00:44:40.390 --> 00:44:43.800
time they take to run should
depend not on the length of

00:44:43.800 --> 00:44:48.130
the program, but on the size of
the data that you want to

00:44:48.130 --> 00:44:51.190
evaluate using the program.

00:44:51.190 --> 00:44:54.500
So you would argue that the
amount of time taken to

00:44:54.500 --> 00:44:58.330
compute the GPA of the students
at MIT should be

00:44:58.330 --> 00:45:02.260
proportional to the number of
students, not proportional to

00:45:02.260 --> 00:45:05.890
the length of the program
used to do it.

00:45:05.890 --> 00:45:08.780
We'll talk a lot more about that
later in the term in a

00:45:08.780 --> 00:45:12.180
much more thorough way.

00:45:12.180 --> 00:45:18.110
But it's important to get that
as something you think about.

00:45:18.110 --> 00:45:21.820
So the fact that branching
programs are not proportional

00:45:21.820 --> 00:45:25.390
in time to the input means that
they're limited in what

00:45:25.390 --> 00:45:28.000
they can do.

00:45:28.000 --> 00:45:33.150
So that gets us to the final
concept we need to write every

00:45:33.150 --> 00:45:36.350
program that could ever be
written, or at least to

00:45:36.350 --> 00:45:41.650
compute every function that
could ever be computed.

00:45:41.650 --> 00:45:44.210
And that's some sort of
a looping construct.

00:45:56.600 --> 00:46:02.150
Once we add loops, we get to a
class of programming languages

00:46:02.150 --> 00:46:07.390
or programming constructs that's
called Turing Complete.

00:46:07.390 --> 00:46:10.650
And I mentioned this
last time.

00:46:10.650 --> 00:46:13.150
Any program that can be written,
or any function that

00:46:13.150 --> 00:46:17.140
can be computed, rather, can
be computed in a Turing

00:46:17.140 --> 00:46:20.100
Complete language.

00:46:20.100 --> 00:46:21.835
So let's look at an
example here.

00:46:24.410 --> 00:46:27.513
This concept, by the way,
is called iteration.

00:46:33.620 --> 00:46:40.850
And if we look at languages with
iteration, what we'll see

00:46:40.850 --> 00:46:44.130
is a more complicated
flow of control.

00:46:44.130 --> 00:46:47.280
You execute some statements,
maybe you do some

00:46:47.280 --> 00:46:48.530
branching if you want.

00:46:53.520 --> 00:46:59.480
But then you're allowed to go
back and execute statements

00:46:59.480 --> 00:47:02.060
you've already executed.

00:47:02.060 --> 00:47:04.045
Typically what you have
is another branch.

00:47:09.450 --> 00:47:11.480
One branch goes back
and one continues.

00:47:15.200 --> 00:47:20.570
So now we see we can execute
a statement more than once.

00:47:20.570 --> 00:47:25.820
Suddenly we have enormous
power at our disposal.

00:47:25.820 --> 00:47:27.660
So let's look at an
example of that.

00:47:43.640 --> 00:47:46.500
By the way, I'm skipping some
of the code in your handout,

00:47:46.500 --> 00:47:53.530
but that's probably fine because
it's there for you to

00:47:53.530 --> 00:47:54.370
be able to read.

00:47:54.370 --> 00:47:58.290
And what I would recommend by
the way, is that we will post

00:47:58.290 --> 00:48:02.880
the handouts on the web, but
at the end of every lecture

00:48:02.880 --> 00:48:06.560
within a few hours or a few days
at least, go through the

00:48:06.560 --> 00:48:11.150
handouts and make sure you
understand everything in.

00:48:11.150 --> 00:48:14.380
Because if you don't, you're
probably missing something

00:48:14.380 --> 00:48:16.350
you'll need to understand
to do the problem sets.

00:48:19.250 --> 00:48:22.860
So here's a little program that
finds the cube root of a

00:48:22.860 --> 00:48:25.200
perfect cube.

00:48:25.200 --> 00:48:28.280
This, by the way, is a useful
comment here, right?

00:48:28.280 --> 00:48:31.770
Tells you what the program
is intended to do.

00:48:31.770 --> 00:48:33.770
So we get an integer.

00:48:33.770 --> 00:48:36.830
We set the variable
ans to zero.

00:48:36.830 --> 00:48:41.820
And then while ans times ans
times ans is less than the

00:48:41.820 --> 00:48:45.810
absolute value of x,
we're going to set

00:48:45.810 --> 00:48:48.230
ans to ans plus 1.

00:48:48.230 --> 00:48:50.360
We could print where we are.

00:48:50.360 --> 00:48:54.180
I put those sort of things in
as debugging statements.

00:48:54.180 --> 00:48:59.570
If ans times ans times ans is
not equal to the absolute

00:48:59.570 --> 00:49:06.800
value of x when I finish the
loop, then I'll print x is not

00:49:06.800 --> 00:49:09.850
a perfect cube.

00:49:09.850 --> 00:49:12.050
Otherwise I have to do something
to deal with

00:49:12.050 --> 00:49:14.780
positive and negative values.

00:49:14.780 --> 00:49:20.620
Now I know that this was fast
and that most of you probably

00:49:20.620 --> 00:49:23.490
don't fully assimilate
this program.

00:49:23.490 --> 00:49:25.290
Do not worry.

00:49:25.290 --> 00:49:30.040
It will be discussed in
recitations tomorrow.

00:49:30.040 --> 00:49:34.010
So tomorrow, the recitations
will review the Python

00:49:34.010 --> 00:49:38.870
concepts we've discussed today,
but we'll start by

00:49:38.870 --> 00:49:41.570
emphasizing how these
loops work.

00:49:41.570 --> 00:49:42.320
OK.

00:49:42.320 --> 00:49:44.020
Thanks for coming.

00:49:44.020 --> 00:49:45.360
Enjoy recitation tomorrow.

