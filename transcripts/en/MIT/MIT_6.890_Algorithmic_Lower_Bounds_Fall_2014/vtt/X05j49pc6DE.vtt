WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:02.440
The following content is
provided under a Creative

00:00:02.440 --> 00:00:03.820
Commons license.

00:00:03.820 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.263
at ocw.mit.edu.

00:00:25.940 --> 00:00:27.440
PROFESSOR: All
right, so today we're

00:00:27.440 --> 00:00:30.810
going to think about
the-- well, also

00:00:30.810 --> 00:00:34.070
the low end of the
polynomial hierarchy.

00:00:34.070 --> 00:00:36.500
So most of this class
is about polynomial

00:00:36.500 --> 00:00:39.535
versus not polynomial and
various notions of hardness,

00:00:39.535 --> 00:00:41.610
[? NP ?] hardness, and worse.

00:00:41.610 --> 00:00:44.080
We look briefly at
P-completeness, which

00:00:44.080 --> 00:00:46.090
is about parallel computing.

00:00:46.090 --> 00:00:48.390
Today we're going to be
thinking about regular good old

00:00:48.390 --> 00:00:51.020
sequential computing, but trying
to distinguish linear time

00:00:51.020 --> 00:00:53.560
versus non-linear time,
and in particular,

00:00:53.560 --> 00:00:56.130
trying to find problems
that are quadratic

00:00:56.130 --> 00:01:00.090
or cubic in n for
sequential running times.

00:01:00.090 --> 00:01:03.440
And probably the most
popular attack on this

00:01:03.440 --> 00:01:09.330
is called 3SUM, which is
the following problem.

00:01:09.330 --> 00:01:11.485
You're given n integers.

00:01:14.480 --> 00:01:19.020
Let's say, and you want to know
do any three of them sum to 0?

00:01:25.620 --> 00:01:29.250
So of course, you can
solve this in cubic time

00:01:29.250 --> 00:01:33.380
by testing all triples,
whether they sum to 0.

00:01:33.380 --> 00:01:37.240
But you can also solve
it in quadratic time.

00:01:37.240 --> 00:01:39.292
So it's not an algorithms class.

00:01:39.292 --> 00:01:41.000
I won't ask you to
come up the algorithm.

00:01:41.000 --> 00:01:42.790
But they're quite easy.

00:01:42.790 --> 00:01:48.040
First order n squared
randomized is really easy.

00:01:48.040 --> 00:01:50.620
You take all pairwise sums.

00:01:50.620 --> 00:01:54.460
So first of all you, build
a dictionary, a hash table

00:01:54.460 --> 00:01:56.350
of all the integers.

00:01:56.350 --> 00:02:00.450
And then you look at
all pairwise sums.

00:02:00.450 --> 00:02:02.640
For each pairwise sum, you
see whether the negation

00:02:02.640 --> 00:02:04.970
is in the hash table
in constant time.

00:02:04.970 --> 00:02:08.410
So that gives you n
squared randomized,

00:02:08.410 --> 00:02:13.820
because if a plus
b plus c equals 0

00:02:13.820 --> 00:02:18.100
is the same thing as a
plus b equal minus c.

00:02:18.100 --> 00:02:20.080
So you look at
all pairwise sums,

00:02:20.080 --> 00:02:23.980
see whether the negation
is in the list of integers.

00:02:23.980 --> 00:02:28.130
OK, you can also do order
n squared deterministic.

00:02:28.130 --> 00:02:33.000
This a more fun puzzle.

00:02:33.000 --> 00:02:34.594
But I'll spoil
the answer for you

00:02:34.594 --> 00:02:37.135
just to give you intuition for
why this problem is n squared.

00:02:39.720 --> 00:02:43.070
For every possible
target sum minus c--

00:02:43.070 --> 00:02:44.850
so that's going to
happen n times--

00:02:44.850 --> 00:02:49.490
I'm going to run the following
linear time algorithm.

00:02:49.490 --> 00:02:52.540
So this is just two copies of
the integers in sorted order.

00:02:52.540 --> 00:02:54.030
I have n log n time to sort.

00:02:54.030 --> 00:02:55.340
So that's no problem.

00:02:55.340 --> 00:02:58.050
I'm going to start from
with my left finger

00:02:58.050 --> 00:03:00.950
here and my right
finger here and look

00:03:00.950 --> 00:03:02.990
at the sum of those two numbers.

00:03:02.990 --> 00:03:06.500
If it's too big-- I have a
particular targets, negative c,

00:03:06.500 --> 00:03:09.020
in mind-- if the sum
of these two numbers

00:03:09.020 --> 00:03:13.760
is smaller then negative c, then
I'm going to advance this one,

00:03:13.760 --> 00:03:15.540
because if this is
in sorted order that

00:03:15.540 --> 00:03:17.190
will make my sum larger.

00:03:17.190 --> 00:03:20.740
If the sum is too big, I will
advance this one backwards.

00:03:20.740 --> 00:03:24.260
So in general, I have my
right finger advancing

00:03:24.260 --> 00:03:26.590
left or my left finger
advancing right.

00:03:26.590 --> 00:03:29.220
In each step, one
of the two advances.

00:03:29.220 --> 00:03:31.700
And this will not miss--
and this will tell you

00:03:31.700 --> 00:03:34.520
whether that target sum
is among the pairwise sums

00:03:34.520 --> 00:03:35.450
from this thing.

00:03:35.450 --> 00:03:38.040
In linear time, we
do that n times, once

00:03:38.040 --> 00:03:39.320
for each target sum.

00:03:39.320 --> 00:03:42.420
So that's the fancy
quadratic algorithm.

00:03:42.420 --> 00:03:46.160
No fancy data
structures required.

00:03:46.160 --> 00:03:46.660
Cool.

00:03:46.660 --> 00:03:48.150
So 3SUM is quadratic.

00:03:48.150 --> 00:03:51.910
And the big conjecture is that
you can't solve it any faster.

00:03:51.910 --> 00:03:54.290
Well, you can.

00:03:54.290 --> 00:03:57.310
So it's not quite
the conjecture.

00:03:57.310 --> 00:04:05.110
The conjecture is that there
is no n to the 2 minus epsilon

00:04:05.110 --> 00:04:11.500
algorithm in general--
in the worst case.

00:04:11.500 --> 00:04:13.880
Let me tell you before
we get to-- and this is

00:04:13.880 --> 00:04:16.640
has led to a whole world of
lower bounds of 3SUM hardness.

00:04:16.640 --> 00:04:19.279
If your problem is
3SUM hard, then you

00:04:19.279 --> 00:04:22.720
expect it also has no n to
the 2 minus epsilon algorithm,

00:04:22.720 --> 00:04:24.390
because if it did, 3SUM would.

00:04:24.390 --> 00:04:30.920
And people generally believe
that's the case for 3SUM.

00:04:30.920 --> 00:04:32.230
But there are some exceptions.

00:04:32.230 --> 00:04:38.380
So one thing is that the
numbers have to be fairly large.

00:04:38.380 --> 00:04:43.070
If all of the integers are
in the range, let's say,

00:04:43.070 --> 00:04:49.580
minus u to u-- that's the
universe size-- then via FFT,

00:04:49.580 --> 00:04:53.990
you can solve the problem in
u log u time plus linear time.

00:04:53.990 --> 00:04:58.110
So your numbers better be at
least larger than n squared.

00:04:58.110 --> 00:05:00.275
And in fact, we'll
see n cube suffices.

00:05:00.275 --> 00:05:01.900
So they don't have
to be huge, but they

00:05:01.900 --> 00:05:04.180
do have to be bigger
than linear or quadratic.

00:05:07.520 --> 00:05:10.380
More generally,
there are a bunch

00:05:10.380 --> 00:05:13.475
of sub-quadratic, but only
slightly sub-quadratic,

00:05:13.475 --> 00:05:13.975
algorithms.

00:05:16.710 --> 00:05:22.800
The first one achieves a
roughly log squared savings.

00:05:22.800 --> 00:05:27.960
So a little bit less is a log
log squared in the denominator.

00:05:27.960 --> 00:05:32.910
This is a randomized algorithm
in a model of computation

00:05:32.910 --> 00:05:35.140
called the word RAM.

00:05:35.140 --> 00:05:37.572
So if you're interested
in the word RAM,

00:05:37.572 --> 00:05:39.280
you should take advanced
data structures.

00:05:39.280 --> 00:05:41.720
But basically you can
manipulate, let's say,

00:05:41.720 --> 00:05:44.187
log n bit words
in constant time.

00:05:44.187 --> 00:05:45.895
You can add them
together, multiply them,

00:05:45.895 --> 00:05:48.397
that sort of thing.

00:05:48.397 --> 00:05:49.980
And you assume that
the numbers you're

00:05:49.980 --> 00:05:51.234
dealing with fit in a word.

00:05:51.234 --> 00:05:52.900
Because if you're
going to compare them,

00:05:52.900 --> 00:05:55.800
you'd also need that assumption.

00:05:55.800 --> 00:05:58.070
So that's a reasonable model.

00:05:58.070 --> 00:06:01.200
And it essentially affords
a kind of logarithmic amount

00:06:01.200 --> 00:06:02.040
of parallelism.

00:06:02.040 --> 00:06:04.690
And so because it's a quadratic
problem, roughly speaking

00:06:04.690 --> 00:06:08.470
you get a quadratic amount in
the parallelism of the model.

00:06:08.470 --> 00:06:10.190
So it's a bit improved.

00:06:10.190 --> 00:06:15.810
This is by two former MIT
students, [? Eli ?] Barron

00:06:15.810 --> 00:06:19.480
and Mihai Petrescu and myself.

00:06:19.480 --> 00:06:24.020
And very recently,
this year, there's

00:06:24.020 --> 00:06:26.025
been another nice improvement.

00:06:40.470 --> 00:06:45.550
It's actually three algorithms,
depending on your model.

00:06:45.550 --> 00:06:47.220
But all based on a similar idea.

00:06:56.410 --> 00:06:57.940
Did I get these backwards?

00:06:57.940 --> 00:06:59.170
I think so.

00:07:17.380 --> 00:07:20.730
So first, these two
results-- so these

00:07:20.730 --> 00:07:23.070
are results by
[? Gourmand ?] and Petty.

00:07:23.070 --> 00:07:26.390
So that's Petty, gave a
talk here about it recently.

00:07:26.390 --> 00:07:28.440
In a real RAM model
of computation--

00:07:28.440 --> 00:07:30.470
this is a weaker
model of computation,

00:07:30.470 --> 00:07:32.950
so the result is stronger.

00:07:32.950 --> 00:07:37.720
In a real RAM, you still assume
the numbers you're given,

00:07:37.720 --> 00:07:39.047
you can add them.

00:07:39.047 --> 00:07:40.880
I think actually all
it needs is the ability

00:07:40.880 --> 00:07:44.400
to add them and compare them,
maybe subtract-- yeah, also

00:07:44.400 --> 00:07:45.440
subtract.

00:07:45.440 --> 00:07:48.550
But no multiplication
is really useful

00:07:48.550 --> 00:07:49.970
in that particular model.

00:07:49.970 --> 00:07:52.451
Because you can't extract
bits out of the thing,

00:07:52.451 --> 00:07:54.200
so you don't assume
that they're integers,

00:07:54.200 --> 00:07:55.699
you just treat them
as real numbers.

00:07:55.699 --> 00:07:58.000
And all you know how to
do is add a bunch of them

00:07:58.000 --> 00:08:01.050
and compare those additions.

00:08:01.050 --> 00:08:02.760
So that's a weaker
model of computation.

00:08:02.760 --> 00:08:05.620
And still they're able to
get a roughly logarithmic

00:08:05.620 --> 00:08:10.600
improvement, not quite as
strong as the quadratic analog.

00:08:10.600 --> 00:08:13.110
But one advance is that this
is the first deterministic

00:08:13.110 --> 00:08:15.330
algorithm to be n squared.

00:08:15.330 --> 00:08:18.880
So randomization isn't
necessary to achieve that.

00:08:18.880 --> 00:08:22.005
Though this is 2/3 power.

00:08:22.005 --> 00:08:23.380
But the other
advance is that you

00:08:23.380 --> 00:08:25.800
don't need to manipulate
the individual bits.

00:08:25.800 --> 00:08:30.060
So even in the randomized
model that's nice.

00:08:30.060 --> 00:08:35.620
And then the major thing,
and sort of the first thing

00:08:35.620 --> 00:08:38.740
to call into question the
3SUM conjecture, which

00:08:38.740 --> 00:08:44.700
is that conjecture,
is I wouldn't really

00:08:44.700 --> 00:08:45.820
call this an algorithm.

00:08:45.820 --> 00:08:50.765
But it's a thing which runs
n roughly n to the 1.5 time.

00:08:53.570 --> 00:08:57.120
But here it's a more powerful
model, a super powerful model,

00:08:57.120 --> 00:09:00.510
called the decision
tree model, where

00:09:00.510 --> 00:09:04.960
the idea is that an algorithm
is specified by an entire tree.

00:09:04.960 --> 00:09:07.410
The depth of the
tree is this big.

00:09:07.410 --> 00:09:11.120
Each node of the tree says,
add these five things,

00:09:11.120 --> 00:09:13.420
compare them to
these five things,

00:09:13.420 --> 00:09:16.450
and see which is
bigger, and then branch.

00:09:16.450 --> 00:09:18.260
There's a left branch,
and a right tree.

00:09:18.260 --> 00:09:20.343
If you've ever seen a
comparison tree, same thing.

00:09:20.343 --> 00:09:22.395
But the comparisons
are more interesting.

00:09:25.370 --> 00:09:27.600
But this is not an
algorithm, because we

00:09:27.600 --> 00:09:30.710
don't know how to compute
that tree efficiently.

00:09:30.710 --> 00:09:32.710
We can compute it in
probably polynomial time,

00:09:32.710 --> 00:09:36.690
but we don't know how to
compute it in sub-quadratic time

00:09:36.690 --> 00:09:38.360
or sub-this time.

00:09:38.360 --> 00:09:40.610
So it's kind of a
frustrating situation,

00:09:40.610 --> 00:09:44.910
because we know
that this thing is

00:09:44.910 --> 00:09:47.850
sort of out there, but
actually finding it is hard.

00:09:47.850 --> 00:09:51.270
And actually several problems
in computers since the '80s,

00:09:51.270 --> 00:09:54.240
I think, where we know
better decision trees

00:09:54.240 --> 00:09:55.880
than we know algorithms.

00:09:55.880 --> 00:10:00.800
So my sense would be that
decision tree model is strictly

00:10:00.800 --> 00:10:01.440
more powerful.

00:10:01.440 --> 00:10:05.910
The 3SUM conjecture is
true for regular algorithms

00:10:05.910 --> 00:10:08.207
if you define it
this way or this way.

00:10:08.207 --> 00:10:10.040
But in the decision to
model, obviously, you

00:10:10.040 --> 00:10:10.921
can do a lot better.

00:10:10.921 --> 00:10:11.420
Question?

00:10:11.420 --> 00:10:14.590
AUDIENCE: What's the reason
to believe the decision tree

00:10:14.590 --> 00:10:18.250
model is some bit that we
run polynomial algorithm,

00:10:18.250 --> 00:10:20.887
look at the bit and it
tells us the incident?

00:10:20.887 --> 00:10:22.220
PROFESSOR: You mean, why would--

00:10:22.220 --> 00:10:25.500
AUDIENCE: Why would you believe
this decision tree is there,

00:10:25.500 --> 00:10:29.740
like a model of computation
that we should care about?

00:10:29.740 --> 00:10:32.345
PROFESSOR: Oh,
no, you shouldn't.

00:10:32.345 --> 00:10:33.970
Decision tree is not
a model you should

00:10:33.970 --> 00:10:36.010
consider a reasonable computer.

00:10:36.010 --> 00:10:39.110
But it's interesting in that
it suggests-- it gives you

00:10:39.110 --> 00:10:41.010
this tantalizing
feeling that maybe you

00:10:41.010 --> 00:10:42.749
could turn this into
a real algorithm,

00:10:42.749 --> 00:10:43.790
you could run a computer.

00:10:43.790 --> 00:10:44.960
But, definitely,
yeah, you cannot--

00:10:44.960 --> 00:10:47.310
if you don't know what decision
tree is you can't run it

00:10:47.310 --> 00:10:48.470
on a computer directly.

00:10:48.470 --> 00:10:50.737
So it's not a model
of computation

00:10:50.737 --> 00:10:51.570
in the strict sense.

00:10:51.570 --> 00:10:53.110
It's especially
interesting-- I mean,

00:10:53.110 --> 00:10:55.060
it's always important to see
how the model of competition

00:10:55.060 --> 00:10:56.930
relates to bounds,
particularly if you're

00:10:56.930 --> 00:10:58.520
going to try to prove
the lower bound.

00:10:58.520 --> 00:11:01.430
There are some lower bounds of
n squared in restricted forms

00:11:01.430 --> 00:11:02.810
of the decision tree model.

00:11:02.810 --> 00:11:04.850
This says you can't
extend those lower bounds

00:11:04.850 --> 00:11:06.390
to arbitrary decision trees.

00:11:06.390 --> 00:11:09.360
Decision trees are traditionally
used as a lower bound model.

00:11:09.360 --> 00:11:10.910
If you can prove a
lower bound there,

00:11:10.910 --> 00:11:12.600
because it's a very
powerful model,

00:11:12.600 --> 00:11:15.560
that implies lower bounds in
something like the real RAM.

00:11:15.560 --> 00:11:17.644
So that's why people
care in some sense.

00:11:17.644 --> 00:11:19.310
This says you can't
prove a strong lower

00:11:19.310 --> 00:11:20.990
bound in that model,
which is annoying.

00:11:20.990 --> 00:11:22.576
Another question?

00:11:22.576 --> 00:11:24.112
AUDIENCE: What is
the tree that they

00:11:24.112 --> 00:11:25.649
found the structure and
the constants of the nodes,

00:11:25.649 --> 00:11:27.760
does it depend on the
values of the integer?

00:11:27.760 --> 00:11:29.660
Only the number?

00:11:29.660 --> 00:11:32.530
PROFESSOR: I'm pretty
sure in this model

00:11:32.530 --> 00:11:36.220
you have a constant number
of original integers.

00:11:36.220 --> 00:11:37.891
You add them together
and compare them

00:11:37.891 --> 00:11:39.640
to a constant number
of original integers.

00:11:39.640 --> 00:11:41.990
AUDIENCE: But what
was is-- I mean

00:11:41.990 --> 00:11:46.426
I can compute the tree in sum,
but what does it depend on?

00:11:46.426 --> 00:11:47.742
Like if I change the value--

00:11:47.742 --> 00:11:49.950
PROFESSOR: The tree, of
course, has exponential size.

00:11:49.950 --> 00:11:52.366
So you never would actually
want to compute it explicitly.

00:11:52.366 --> 00:11:54.640
What you want to
compute is after I've

00:11:54.640 --> 00:11:57.760
done some number of things,
what's the next operation that

00:11:57.760 --> 00:11:58.260
happens.

00:11:58.260 --> 00:11:59.884
AUDIENCE: That's
still not my question.

00:11:59.884 --> 00:12:02.131
So my question is what
changes the actual structure

00:12:02.131 --> 00:12:03.112
of the tree?

00:12:03.112 --> 00:12:04.070
Is it just the number--

00:12:04.070 --> 00:12:06.260
PROFESSOR: Oh, yeah, n.

00:12:06.260 --> 00:12:10.210
The decision tree
only depends on n.

00:12:10.210 --> 00:12:12.730
I mean in some sense the
decision tree's encoding

00:12:12.730 --> 00:12:14.577
an adaptive algorithm,
that depending

00:12:14.577 --> 00:12:16.160
on the results of
previous comparisons

00:12:16.160 --> 00:12:18.050
tells you what to do next about.

00:12:18.050 --> 00:12:19.660
If you think of it
as the entire tree

00:12:19.660 --> 00:12:20.784
that's only depending on n.

00:12:23.690 --> 00:12:28.017
But because it's so big, I
mean, that doesn't help us if.

00:12:28.017 --> 00:12:29.600
You could imagine
pre-computing for n,

00:12:29.600 --> 00:12:31.270
but there's no way to store it.

00:12:31.270 --> 00:12:34.790
And you couldn't really
afford that exponential time.

00:12:34.790 --> 00:12:39.260
OK, so that's a short story
about the known upper bounds

00:12:39.260 --> 00:12:41.620
and also the known
lower bounds on 3SUM.

00:12:41.620 --> 00:12:44.307
There are some weak lower
bounds in a particular version

00:12:44.307 --> 00:12:46.140
of the decision tree
model when you can only

00:12:46.140 --> 00:12:50.530
compare I think
sums of two items,

00:12:50.530 --> 00:12:52.300
then you can get an n
squared lower bound.

00:12:52.300 --> 00:12:53.841
But that's not
especially interesting

00:12:53.841 --> 00:12:59.120
given this result anymore.

00:12:59.120 --> 00:13:05.380
Let me tell you briefly
about k sum, which

00:13:05.380 --> 00:13:16.430
is the obvious generalization,
instead of 3, do any k of them

00:13:16.430 --> 00:13:18.450
sum to 0?

00:13:18.450 --> 00:13:21.120
Here, they're actually
stronger and lower bounds.

00:13:21.120 --> 00:13:24.692
So if 3SUM is the most
popular thing considered

00:13:24.692 --> 00:13:26.150
for proving quadratic
lower bounds,

00:13:26.150 --> 00:13:27.524
because a lot of
problems we care

00:13:27.524 --> 00:13:29.230
about are linear or
quadratic, so 3SUM

00:13:29.230 --> 00:13:31.020
gets a lot of the attention.

00:13:31.020 --> 00:13:32.830
K sum is a little
easier to argue about.

00:13:32.830 --> 00:13:35.950
In particular, it's NP
hard in general, right.

00:13:35.950 --> 00:13:40.410
This, in particular, encodes
something like partition.

00:13:40.410 --> 00:13:44.640
If you have n integers, and
they're overall sum is 0,

00:13:44.640 --> 00:13:46.480
and you want to know
whether any n/2 of them

00:13:46.480 --> 00:13:48.025
sum to 0 or something
like that, that

00:13:48.025 --> 00:13:50.420
would be roughly partition.

00:13:50.420 --> 00:13:52.500
So this is NP hard.

00:13:52.500 --> 00:13:56.510
So definitely it's got
to get hard for some k.

00:13:56.510 --> 00:13:59.390
In fact, you can show
fixed parameter hardness,

00:13:59.390 --> 00:14:01.950
W1 hardness, with respect to k.

00:14:05.000 --> 00:14:08.080
So in particular, if you
assume the exponential time

00:14:08.080 --> 00:14:11.930
hypothesis, then you
get some lower bounds.

00:14:11.930 --> 00:14:16.710
And the best lower
bound known so far

00:14:16.710 --> 00:14:24.270
is that there's no n to
the little of k algorithm,

00:14:24.270 --> 00:14:27.140
assuming regular ETH.

00:14:27.140 --> 00:14:31.530
For this, we need to assume k is
less than or equal to-- is not

00:14:31.530 --> 00:14:38.340
too giant, because, I guess,
if k equals n, for example,

00:14:38.340 --> 00:14:39.960
this problem is really easy.

00:14:39.960 --> 00:14:43.150
So it can't go all the way.

00:14:43.150 --> 00:14:46.620
So this says, well, maybe we
don't get the constant right,

00:14:46.620 --> 00:14:51.680
but there's some kind of n
to the roughly k dependence.

00:14:51.680 --> 00:14:55.760
So there's a reason that there's
a number here larger than 1.

00:14:55.760 --> 00:14:59.295
Although we don't know how
to prove that, the feeling is

00:14:59.295 --> 00:15:02.670
that 3SUM, k sum,
they require roughly n

00:15:02.670 --> 00:15:04.150
to some constant times k.

00:15:04.150 --> 00:15:05.900
You can debate about
what the constant is,

00:15:05.900 --> 00:15:08.580
but we have this theorem.

00:15:08.580 --> 00:15:14.930
And on the upper bound side--
and what people believe

00:15:14.930 --> 00:15:21.790
is the right answer-- is k/2
ceiling-- at least randomized.

00:15:21.790 --> 00:15:26.120
If you want deterministic,
you might get a log factor.

00:15:26.120 --> 00:15:27.620
But you can definitely
achieve this

00:15:27.620 --> 00:15:34.230
by the same kind of do all
k/2y sums twice, and then

00:15:34.230 --> 00:15:36.860
look for collisions
in the hash table.

00:15:36.860 --> 00:15:40.960
And so the ceiling
is what's making 3SUM

00:15:40.960 --> 00:15:43.140
into a quadratic thing.

00:15:43.140 --> 00:15:48.510
But 4 sum is just
as easy as 3SUM,

00:15:48.510 --> 00:15:51.590
because you can still
solve it in quadratic time.

00:15:51.590 --> 00:15:55.339
But 5 sum, the conjecture is
that requires n cube time.

00:15:55.339 --> 00:15:57.130
AUDIENCE: Sorry, I
didn't quite catch that.

00:15:57.130 --> 00:15:59.130
Is that a known result?

00:15:59.130 --> 00:16:02.220
PROFESSOR: This is an
upper bound is known.

00:16:02.220 --> 00:16:10.380
And then the conjecture
is that that's tight.

00:16:10.380 --> 00:16:17.740
There's no end to the ceiling
k/2 minus epsilon algorithm.

00:16:17.740 --> 00:16:20.090
That's what we don't know.

00:16:20.090 --> 00:16:23.580
But algorithm is easy.

00:16:23.580 --> 00:16:24.560
So that's k sum.

00:16:24.560 --> 00:16:26.790
And this gives you
some more intuition

00:16:26.790 --> 00:16:29.080
for why you should expect
these problems are hard.

00:16:29.080 --> 00:16:33.025
In particular, if you could
prove k sum requires-- I mean,

00:16:33.025 --> 00:16:34.400
if you can prove
this conjecture,

00:16:34.400 --> 00:16:38.190
you prove the exponential
time hypothesis.

00:16:38.190 --> 00:16:39.660
So you prove p
does not equal NP.

00:16:39.660 --> 00:16:42.118
And you may make $1 million
and lots of good things happen.

00:16:42.118 --> 00:16:46.200
So we should try to do this.

00:16:46.200 --> 00:16:48.710
Of course, as I
mentioned, 3SUM is the one

00:16:48.710 --> 00:16:53.470
we use the most in this world,
because for NP hard problems,

00:16:53.470 --> 00:16:55.990
usually we use NP hardness
and all the stuff we did.

00:16:55.990 --> 00:16:58.220
You could use k sum, but
that's basically partition.

00:17:03.340 --> 00:17:05.241
But this is sort of
motivation for why

00:17:05.241 --> 00:17:06.490
you should think 3SUM is hard.

00:17:06.490 --> 00:17:09.450
I'll leave it at that.

00:17:09.450 --> 00:17:12.185
So let me talk
about 3SUM hardness.

00:17:21.530 --> 00:17:29.310
So I'm going to call a problem
3SUM hard if that algorithm has

00:17:29.310 --> 00:17:37.960
an n to the two minus epsilon
time algorithm, then so

00:17:37.960 --> 00:17:38.460
does 3SUM.

00:17:42.080 --> 00:17:43.940
OK, this is what we want.

00:17:43.940 --> 00:17:45.630
If I say problem
is 3SUM is hard,

00:17:45.630 --> 00:17:48.070
it means it shouldn't
be solvable in less

00:17:48.070 --> 00:17:52.280
than quadratic time other
than this poly log stuff.

00:17:52.280 --> 00:17:54.840
So this is the formal meaning.

00:17:54.840 --> 00:17:58.000
If you could solve it
in sub-quadratic, truly

00:17:58.000 --> 00:18:01.140
sub-quadratic time this is
often called the minus epsilon,

00:18:01.140 --> 00:18:03.530
then 3SUM can be solved in
truly sub-quadratic time,

00:18:03.530 --> 00:18:05.237
contradicting the
3SUM conjecture.

00:18:05.237 --> 00:18:07.570
So if you believe this is the
3SUM conjecture that means

00:18:07.570 --> 00:18:09.920
this is not possible
for your problem.

00:18:09.920 --> 00:18:11.670
And the way we're going
to do that usually

00:18:11.670 --> 00:18:14.100
is with a 3SUM reduction.

00:18:20.990 --> 00:18:22.360
There are other ways to do it.

00:18:22.360 --> 00:18:24.890
You don't have to follow this
particular style reduction.

00:18:24.890 --> 00:18:28.750
But most of them do.

00:18:28.750 --> 00:18:32.960
So it's going to be a multi call
reduction, but in this world,

00:18:32.960 --> 00:18:35.340
we have to be careful
about polynomial factors.

00:18:35.340 --> 00:18:37.240
We don't want to call
your thing n times

00:18:37.240 --> 00:18:39.550
and say that was a
legitimate reduction.

00:18:39.550 --> 00:18:42.990
So let's say you can call--
if you're reducing from a to

00:18:42.990 --> 00:18:47.400
b, then that means you
could solve b using a.

00:18:47.400 --> 00:18:52.430
And you're going to make a
constant number of calls to a.

00:18:52.430 --> 00:18:53.950
Sorry, other way around.

00:18:53.950 --> 00:18:57.064
That means I can
solve a using b.

00:18:57.064 --> 00:18:58.480
Usually, we take
an instance here,

00:18:58.480 --> 00:18:59.730
reduce it to an instance here.

00:18:59.730 --> 00:19:00.704
That's OK.

00:19:00.704 --> 00:19:03.120
But because we're going to
want to solve not just decision

00:19:03.120 --> 00:19:05.390
problems, we're
going to say, OK,

00:19:05.390 --> 00:19:06.950
you take your instance of a.

00:19:06.950 --> 00:19:08.767
You can call an
oracle for solving

00:19:08.767 --> 00:19:11.350
b a constant number of times,
as long as the thing you call it

00:19:11.350 --> 00:19:13.080
with is also not much bigger.

00:19:16.000 --> 00:19:18.150
So the n prime that you
call this thing with

00:19:18.150 --> 00:19:21.690
should be linear in n.

00:19:21.690 --> 00:19:27.930
And the running time
of the reduction

00:19:27.930 --> 00:19:28.930
should be sub-quadratic.

00:19:32.940 --> 00:19:35.570
OK, pretty much all
reductions, it's like n,

00:19:35.570 --> 00:19:37.500
n log n, maybe n log squared n.

00:19:37.500 --> 00:19:40.280
But it should be strictly
less than n squared,

00:19:40.280 --> 00:19:43.600
otherwise the reduction doesn't
tell you much about weather

00:19:43.600 --> 00:19:46.130
the problem is quadratic or not.

00:19:46.130 --> 00:19:49.150
So with this much
running time, plausibly

00:19:49.150 --> 00:19:50.830
you could construct
a larger instance.

00:19:50.830 --> 00:19:53.650
But this constraint
says the instance

00:19:53.650 --> 00:19:56.440
of b that you called
should be linear in size,

00:19:56.440 --> 00:19:58.290
so the quadratic over
here is the same thing

00:19:58.290 --> 00:20:00.140
as quadratic over here.

00:20:00.140 --> 00:20:01.830
OK, so those are the
rules of the game.

00:20:01.830 --> 00:20:03.250
We're not going to have to
worry about these constraints

00:20:03.250 --> 00:20:04.070
too much.

00:20:04.070 --> 00:20:08.467
Most of our reductions are
constant factor blow up and run

00:20:08.467 --> 00:20:10.175
in a reasonable amount
of time, But we've

00:20:10.175 --> 00:20:12.180
got to be a little
careful here to make

00:20:12.180 --> 00:20:14.140
sure the running
time is not huge.

00:20:14.140 --> 00:20:17.280
Usually we're allowed
polynomial time.

00:20:17.280 --> 00:20:20.740
OK, so if you have a 3SUM
reduction from a to b,

00:20:20.740 --> 00:20:24.474
and you know a is 3SUM
hard, then b is 3SUM hard.

00:20:24.474 --> 00:20:25.349
AUDIENCE: [INAUDIBLE]

00:20:30.280 --> 00:20:32.780
PROFESSOR: N prime is the
size of the thing that

00:20:32.780 --> 00:20:34.790
you're-- the instance
you're calling with.

00:20:34.790 --> 00:20:37.560
So if you have an
instance x over here,

00:20:37.560 --> 00:20:39.430
you have some x prime over here.

00:20:39.430 --> 00:20:42.044
N prime is the size of x prime.

00:20:42.044 --> 00:20:43.460
There's a constant
number of them.

00:20:43.460 --> 00:20:46.630
But I want all of those
instances to be linear size.

00:20:56.430 --> 00:20:59.500
OK, so initially a
is going to be 3SUM.

00:20:59.500 --> 00:21:02.290
3SUM is 3SUM hard.

00:21:02.290 --> 00:21:05.870
Because if it as a sub-quadratic
algorithm, then so does itself.

00:21:05.870 --> 00:21:08.060
And so that's actually easy.

00:21:08.060 --> 00:21:09.590
NP harnessed,
that's not so easy.

00:21:12.420 --> 00:21:15.590
If we let b be
some other problem,

00:21:15.590 --> 00:21:17.660
then we'll prove hardness.

00:21:17.660 --> 00:21:21.350
In this world, because we
don't have any solid, lower

00:21:21.350 --> 00:21:23.350
bounds to work from, it's
also interesting to go

00:21:23.350 --> 00:21:24.821
in both directions.

00:21:24.821 --> 00:21:26.820
I'm not going to define
a notion of completeness

00:21:26.820 --> 00:21:29.030
here, just because
it hasn't been done.

00:21:29.030 --> 00:21:30.710
But you could define
3SUM completeness

00:21:30.710 --> 00:21:35.890
to mean you can reduce from
3SUM and you can reduce to 3SUM.

00:21:35.890 --> 00:21:39.110
We'll see a few problems
in that-- usually people

00:21:39.110 --> 00:21:41.940
call that equivalence,
sub-quadratic equivalence.

00:21:44.700 --> 00:21:50.450
OK, so let me start with
some base 3SUM hard problems

00:21:50.450 --> 00:21:53.020
to start from.

00:21:53.020 --> 00:21:57.280
A lot of this comes
from a paper--

00:21:57.280 --> 00:22:03.800
this paper-- by Gajentaan
and Overmars, 1995.

00:22:03.800 --> 00:22:06.560
And they had been
collecting over the years

00:22:06.560 --> 00:22:08.770
a whole bunch of mostly
computational geometry

00:22:08.770 --> 00:22:14.130
problems, which are 3SUM hard
in that you can reduce 3SUM

00:22:14.130 --> 00:22:16.010
to all of them.

00:22:16.010 --> 00:22:19.330
But in the center here is a
bunch of core problems, 3SUM,

00:22:19.330 --> 00:22:23.460
3SUM prime, which I would
call ABC version of 3SUM--

00:22:23.460 --> 00:22:26.210
we've seen a few ABC
problems in the past--

00:22:26.210 --> 00:22:28.300
and a geometric version of 3SUM.

00:22:28.300 --> 00:22:30.520
So let me tell you about those.

00:22:30.520 --> 00:22:38.590
First of all, 3SUM is 3SUM hard,
even when u is order n cubed.

00:22:38.590 --> 00:22:39.590
So that's nice to know.

00:22:39.590 --> 00:22:43.120
The integers you're working
with don't have to be giant.

00:22:43.120 --> 00:22:45.212
This is based on a
hashing argument,

00:22:45.212 --> 00:22:46.170
which we won't go into.

00:22:48.840 --> 00:22:52.160
OK, so what is 3SUM prime?

00:22:52.160 --> 00:23:01.440
3SUM prime you're given three
sets of integers, A, B, C--

00:23:01.440 --> 00:23:02.640
yeah?

00:23:02.640 --> 00:23:04.140
AUDIENCE: For these
reductions we're

00:23:04.140 --> 00:23:06.100
using only deterministic
reductions?

00:23:09.540 --> 00:23:12.250
PROFESSOR: Let's say we're only
using deterministic reductions,

00:23:12.250 --> 00:23:14.720
although randomized would
also be interesting,

00:23:14.720 --> 00:23:16.450
You just have to
weaken this statement.

00:23:16.450 --> 00:23:19.480
But here I'll say deterministic.

00:23:19.480 --> 00:23:22.844
AUDIENCE: Is the hashing
argument for why [INAUDIBLE]?

00:23:22.844 --> 00:23:25.010
PROFESSOR: Yeah, I'm pretty
sure you can derandomize

00:23:25.010 --> 00:23:25.940
that hashing scheme.

00:23:28.690 --> 00:23:34.395
I need to double check,
but, yeah, that's the claim.

00:23:34.395 --> 00:23:35.670
Yeah, that is good question.

00:23:54.740 --> 00:23:58.590
So this is the ABC
version of 3SUM.

00:23:58.590 --> 00:24:00.560
We just want the
three items to come

00:24:00.560 --> 00:24:03.117
from three particular sets.

00:24:03.117 --> 00:24:04.700
And traditionally,
this one is phrased

00:24:04.700 --> 00:24:07.320
as a plus b equals c,
although you could also

00:24:07.320 --> 00:24:09.460
say a plus b plus c equals 0.

00:24:09.460 --> 00:24:10.360
It's the same thing.

00:24:10.360 --> 00:24:12.050
You're just negating
all the c's.

00:24:12.050 --> 00:24:16.490
And in this world, because you
have one item from each set,

00:24:16.490 --> 00:24:20.930
actually it's really easy to
just negate one subset of them.

00:24:20.930 --> 00:24:23.840
So it doesn't matter whether you
put a minus sign here or not.

00:24:23.840 --> 00:24:27.280
But I will not, because that's
how 3SUM prime is usually

00:24:27.280 --> 00:24:29.700
defined.

00:24:29.700 --> 00:24:33.630
So I claim 3SUM
prime is 3SUM hard.

00:24:33.630 --> 00:24:34.850
Why?

00:24:34.850 --> 00:24:40.010
I let capital A-- if I'm
given a 3SUM instance,

00:24:40.010 --> 00:24:43.430
let's call it S. S is
a set of n integers.

00:24:43.430 --> 00:24:45.080
I'm going to let a
equal S. I'm going

00:24:45.080 --> 00:24:48.730
to let b equal S. I'm going
to let c equal negative s.

00:24:48.730 --> 00:24:49.530
Done.

00:24:49.530 --> 00:24:52.950
OK, so that's a
reduction from 3SUM.

00:24:52.950 --> 00:25:03.571
AUDIENCE: [INAUDIBLE]
like if 0 is in your list,

00:25:03.571 --> 00:25:06.430
the way the instance
you constructed,

00:25:06.430 --> 00:25:10.142
you might use some element
x of the list from a.

00:25:10.142 --> 00:25:14.590
The same element x from
b, and then y from c.

00:25:14.590 --> 00:25:21.058
And x plus x might be, I
guess, plus y would equal 0.

00:25:21.058 --> 00:25:26.180
In the original list
you didn't have x twice.

00:25:26.180 --> 00:25:28.930
I'm just getting the
example of choosing 0 three

00:25:28.930 --> 00:25:33.880
times as sort of a
convenient example of that.

00:25:33.880 --> 00:25:36.470
PROFESSOR: So that you
also detect a linear time.

00:25:36.470 --> 00:25:37.760
AUDIENCE: What do you mean?

00:25:37.760 --> 00:25:39.050
PROFESSOR: You can
detect whether there

00:25:39.050 --> 00:25:40.000
are any such triples.

00:25:40.000 --> 00:25:44.280
If you allow repetition,
then you answer the question.

00:25:44.280 --> 00:25:46.116
Your goal is to solve 3SUM.

00:25:46.116 --> 00:25:48.440
AUDIENCE: So you're
solving 3SUM by making

00:25:48.440 --> 00:25:50.890
oracle calls to 3SUM prime?

00:25:50.890 --> 00:25:53.750
PROFESSOR: Right, so if
you can 3SUM ahead of time,

00:25:53.750 --> 00:25:54.980
you're done.

00:25:54.980 --> 00:25:56.995
In linear time, you
can check whether there

00:25:56.995 --> 00:26:00.160
are any pairs that allow,
with some duplication,

00:26:00.160 --> 00:26:04.330
a solution to 3SUM instance.

00:26:04.330 --> 00:26:06.470
This is not addressed
in the paper, which

00:26:06.470 --> 00:26:11.810
makes me think that in
this definition of 3SUM,

00:26:11.810 --> 00:26:15.060
we allow the items
to-- basically,

00:26:15.060 --> 00:26:18.700
every item could be used three
times, up to three times.

00:26:18.700 --> 00:26:20.970
There's no requirement that
they're distinct items.

00:26:20.970 --> 00:26:22.627
So then this reduction is fine.

00:26:22.627 --> 00:26:23.960
I don't think that's a big deal.

00:26:23.960 --> 00:26:25.474
And you can get rid of it.

00:26:25.474 --> 00:26:28.260
But that must be how
it's normally defined.

00:26:28.260 --> 00:26:32.740
I didn't specify whether it
was three distinct items.

00:26:32.740 --> 00:26:35.750
But let's allow
multiplicity there.

00:26:35.750 --> 00:26:43.250
And then this reduction
is fine, because that's

00:26:43.250 --> 00:26:46.030
what the paper does.

00:26:46.030 --> 00:26:49.800
OK, with more effort, like
adding big integers and so on,

00:26:49.800 --> 00:26:51.800
you can reduce-- in
the other direction

00:26:51.800 --> 00:26:54.060
reduce from 3SUM prime to 3SUM.

00:26:56.910 --> 00:26:58.436
I won't cover that,
because I just

00:26:58.436 --> 00:27:00.310
want to prove the 3SUM
hardness about things.

00:27:00.310 --> 00:27:02.830
But in fact, all
these three problems

00:27:02.830 --> 00:27:04.681
are identical to each other.

00:27:04.681 --> 00:27:06.180
If any one of them
is sub-quadratic,

00:27:06.180 --> 00:27:08.040
then they all are.

00:27:08.040 --> 00:27:10.622
So that's nice, because
3SUM prime is really

00:27:10.622 --> 00:27:11.580
a special case of 3SUM.

00:27:18.200 --> 00:27:21.270
So our next problem is
the geometric problem.

00:27:32.230 --> 00:27:33.940
They call it geometric
base problem.

00:27:42.190 --> 00:27:44.480
So here we're in 2D.

00:27:44.480 --> 00:27:50.430
And we're given endpoints
whose y-coordinates are all

00:27:50.430 --> 00:27:51.990
0, 1, or 2.

00:27:51.990 --> 00:27:56.330
You can imagine why--
because there's three lists.

00:27:56.330 --> 00:28:02.840
And so they all live on
three horizontal lines.

00:28:02.840 --> 00:28:05.830
Here are the points.

00:28:05.830 --> 00:28:20.140
And we want to know is there a
non-horizontal line that passes

00:28:20.140 --> 00:28:30.095
through three points like this.

00:28:32.610 --> 00:28:37.500
OK, so our claim,
GeomBase is 3SUM hard.

00:28:37.500 --> 00:28:40.640
And this is their proof.

00:28:40.640 --> 00:28:44.910
On the first line, we put A.
On the last line, we put B.

00:28:44.910 --> 00:28:48.630
And in the middle line, we put
every item in C divided by 2.

00:28:51.340 --> 00:28:57.860
So if you look at-- sorry, this
is a reduction from 3SUM prime.

00:28:57.860 --> 00:28:59.260
So I have three integers.

00:28:59.260 --> 00:29:03.870
We want to know whether you
can every a plus b equals c.

00:29:03.870 --> 00:29:10.660
So the idea is if I
have two items, A and B,

00:29:10.660 --> 00:29:13.160
then this point-- I mean,
if I just draw the line

00:29:13.160 --> 00:29:15.930
and intersect it with
the y' equals 1 line,

00:29:15.930 --> 00:29:18.210
that point will be the
average of little a and little

00:29:18.210 --> 00:29:20.970
b-- so a plus b over 2.

00:29:20.970 --> 00:29:25.240
So if there's an item C
that matches a plus b,

00:29:25.240 --> 00:29:28.655
then the C/2 will equal
the a plus b over 2.

00:29:28.655 --> 00:29:30.780
So there's going to be a
line through three points,

00:29:30.780 --> 00:29:34.960
if and only if, 3SUM
prime had a yes answer.

00:29:34.960 --> 00:29:40.940
And you can reduce in the
reverse direction-- in fact,

00:29:40.940 --> 00:29:42.160
just like this.

00:29:42.160 --> 00:29:44.520
You just multiply all
these coordinates by 2.

00:29:44.520 --> 00:29:48.710
That gives you C.

00:29:48.710 --> 00:29:50.250
So those are our
starting points.

00:29:50.250 --> 00:29:52.440
And we're going to
use all of them.

00:29:52.440 --> 00:29:55.520
And I'm just going to run
through a bunch of examples

00:29:55.520 --> 00:29:56.650
of 3SUM hard problems.

00:29:56.650 --> 00:30:00.090
So all of them shouldn't have
sub-quadratic time algorithms

00:30:00.090 --> 00:30:03.160
unless 3SUM does.

00:30:03.160 --> 00:30:09.180
So the obvious
starting point here

00:30:09.180 --> 00:30:11.510
is what's called
degeneracy testing

00:30:11.510 --> 00:30:14.220
in computational geometry.

00:30:14.220 --> 00:30:15.894
So usually, we like
to assume that you

00:30:15.894 --> 00:30:17.060
have endpoints in the plane.

00:30:17.060 --> 00:30:20.180
They're in general position,
meaning no three are co-linear.

00:30:20.180 --> 00:30:23.300
So the problem is
given endpoints,

00:30:23.300 --> 00:30:25.030
are any three of them co-linear?

00:30:25.030 --> 00:30:25.530
Question?

00:30:25.530 --> 00:30:27.790
AUDIENCE: With 3SUM prime,
because those are integers,

00:30:27.790 --> 00:30:29.248
how do you deal
with them that way?

00:30:29.248 --> 00:30:31.740
PROFESSOR: Oh, integers
and rational, same thing,

00:30:31.740 --> 00:30:34.850
you just scale it, multiply.

00:30:34.850 --> 00:30:36.550
So everything
here-- because we're

00:30:36.550 --> 00:30:37.966
going to go into
geometry quite, I

00:30:37.966 --> 00:30:40.020
will use rationals quite a bit.

00:30:40.020 --> 00:30:45.720
So I can multiply everything
by 2 to make it integers again.

00:30:45.720 --> 00:30:47.480
But this problem does
not say integers,

00:30:47.480 --> 00:30:49.280
so that's why I'm
allowed to do that.

00:30:49.280 --> 00:30:50.320
I start with integers.

00:30:50.320 --> 00:30:52.390
And then I do this.

00:30:52.390 --> 00:30:54.560
But you can also
add integers here.

00:30:54.560 --> 00:30:57.580
It wouldn't make
a big difference.

00:30:57.580 --> 00:31:12.310
OK, so given endpoints in the
plane, are any three co-linear?

00:31:12.310 --> 00:31:14.150
I'm guessing this is
the original motivation

00:31:14.150 --> 00:31:14.900
for defining 3SUM.

00:31:18.980 --> 00:31:21.220
This is really a harder
version of the problem.

00:31:21.220 --> 00:31:22.640
This is kind of a special case.

00:31:22.640 --> 00:31:26.360
But in particular, it's
not exactly the same,

00:31:26.360 --> 00:31:28.370
because we forbid
horizontal lines.

00:31:28.370 --> 00:31:30.680
We had to construct a
very degenerate instance

00:31:30.680 --> 00:31:33.580
with lots of points on the
horizontal lines in order

00:31:33.580 --> 00:31:34.922
for this correspondence to work.

00:31:34.922 --> 00:31:36.630
So the question is
can you make something

00:31:36.630 --> 00:31:38.546
that is only degenerate,
only has three points

00:31:38.546 --> 00:31:44.130
co-linear, when the 3SUM
instance has a solution?

00:31:44.130 --> 00:31:47.205
And this reduction is
a little unsatisfying.

00:31:47.205 --> 00:31:49.700
And I don't have a
great intuition for it.

00:31:49.700 --> 00:31:51.110
But it's very simple.

00:31:51.110 --> 00:31:54.480
We're going to
take-- this is going

00:31:54.480 --> 00:32:01.520
to be a reduction from regular
old 3SUM, not 3SUM prime.

00:32:01.520 --> 00:32:05.330
So every number x, we're going
to map to the point x comma

00:32:05.330 --> 00:32:08.425
x cubed.

00:32:08.425 --> 00:32:12.420
Cubed because it's odd
and not 1 basically.

00:32:12.420 --> 00:32:19.690
And so we take our x values--
probably not a good idea

00:32:19.690 --> 00:32:22.010
to put 0 in there, but whatever.

00:32:22.010 --> 00:32:28.200
And we just project them onto
this x cubed curve, x 3 is odd,

00:32:28.200 --> 00:32:31.020
so it has this nice picture.

00:32:31.020 --> 00:32:35.320
And the claim is if you take
any two points here-- so

00:32:35.320 --> 00:32:38.997
here's an x-coordinate 1/4
and 3/4, and, of course,

00:32:38.997 --> 00:32:40.330
they would actually be integers.

00:32:40.330 --> 00:32:41.790
That's OK.

00:32:41.790 --> 00:32:43.630
You can scale.

00:32:43.630 --> 00:32:49.280
Then so the sum of those is 1.

00:32:49.280 --> 00:32:55.050
And if you look at
negative 1, that will--

00:32:55.050 --> 00:32:57.560
the cube of negative
1, which is 1,

00:32:57.560 --> 00:33:03.080
is exactly equal to where
these two cubed points would

00:33:03.080 --> 00:33:05.755
hit if you extend the line.

00:33:05.755 --> 00:33:06.254
Yes?

00:33:06.254 --> 00:33:07.628
AUDIENCE: Now we
have the problem

00:33:07.628 --> 00:33:10.210
that if you want to use
the version of 3SUM here,

00:33:10.210 --> 00:33:10.710
[INAUDIBLE].

00:33:14.090 --> 00:33:15.670
PROFESSOR: Yep, so
we definitely need

00:33:15.670 --> 00:33:17.174
that those guys are distinct.

00:33:17.174 --> 00:33:18.840
I'm sure that those
two versions of 3SUM

00:33:18.840 --> 00:33:20.870
are equivalent up to
sub-quadratic reductions.

00:33:20.870 --> 00:33:24.520
But I don't see how to
prove that off hand.

00:33:24.520 --> 00:33:29.390
OK, cool, now why is this true?

00:33:29.390 --> 00:33:30.100
I've checked it.

00:33:30.100 --> 00:33:31.860
It's true.

00:33:31.860 --> 00:33:35.080
Off the page of a
algebra and prove it.

00:33:35.080 --> 00:33:37.310
I don't have a great intuition
for why this is true.

00:33:37.310 --> 00:33:40.710
But there you go.

00:33:40.710 --> 00:33:43.120
It's easy enough to check
where this line should go.

00:33:43.120 --> 00:33:46.900
And it happens to go exactly to
the place where the sum goes.

00:33:46.900 --> 00:33:48.170
So sorry.

00:33:50.746 --> 00:33:52.870
I'm guessing it would also
work for x to the fifth.

00:33:52.870 --> 00:33:54.220
But I didn't check that.

00:33:58.240 --> 00:34:03.160
OK so those three
points on the line.

00:34:23.679 --> 00:34:29.310
OK, so an important life
lesson about geometry

00:34:29.310 --> 00:34:31.300
is something called duality.

00:34:31.300 --> 00:34:33.920
So here we're interested
whether there was one line that

00:34:33.920 --> 00:34:35.010
goes through three points.

00:34:35.010 --> 00:34:38.239
A complimentary problem is
I give you a bunch of lines,

00:34:38.239 --> 00:34:43.030
do any three of them pass
through a common point?

00:34:43.030 --> 00:34:47.070
Is there one intersection
between three or more lines?

00:34:47.070 --> 00:34:49.810
Is there a point that
is on three lines?

00:34:49.810 --> 00:34:52.580
If you know projective geometry,
this is totally obvious.

00:34:52.580 --> 00:34:54.949
It's the same problem as this.

00:34:54.949 --> 00:34:57.600
You just apply duality.

00:34:57.600 --> 00:34:59.470
Now, there are many
different dualities.

00:34:59.470 --> 00:35:02.750
I'll give you two today.

00:35:02.750 --> 00:35:09.260
First, my favorite
is projected duality

00:35:09.260 --> 00:35:11.610
and the sort of most
standard, at least, in math.

00:35:11.610 --> 00:35:14.160
If you have a point with
x-coordinate a and y-coordinate

00:35:14.160 --> 00:35:22.670
b, you map that to the line
ax plus by plus 1 equals 0.

00:35:22.670 --> 00:35:24.420
And vice versa.

00:35:24.420 --> 00:35:26.960
So if I have a line--
almost every line

00:35:26.960 --> 00:35:28.330
can be written this way.

00:35:28.330 --> 00:35:30.480
Everyone line that does
not go through the origin

00:35:30.480 --> 00:35:32.060
can be written like this.

00:35:32.060 --> 00:35:34.600
And then you can convert it
into the corresponding point.

00:35:34.600 --> 00:35:36.470
So if you give me
a bunch of lines,

00:35:36.470 --> 00:35:39.727
just translate so that none
of them go through the origin.

00:35:39.727 --> 00:35:41.810
And then convert into
corresponding set of points.

00:35:41.810 --> 00:35:43.600
And the nice thing
about this duality

00:35:43.600 --> 00:35:46.970
is it preserves
incidence, meaning

00:35:46.970 --> 00:35:52.130
if before I apply duality, I
have a point and a line that

00:35:52.130 --> 00:35:55.226
are touching, then after apply
duality, I will have a line

00:35:55.226 --> 00:35:56.350
and appointed are touching.

00:36:02.690 --> 00:36:07.210
So that's great,
because in particular,

00:36:07.210 --> 00:36:09.570
a three-way
intersection or a point

00:36:09.570 --> 00:36:12.300
is on three lines will
convert into a line

00:36:12.300 --> 00:36:13.870
that it goes through
three points.

00:36:13.870 --> 00:36:18.507
And so we get a reduction
from here to here.

00:36:18.507 --> 00:36:19.590
That's kind of like magic.

00:36:19.590 --> 00:36:24.220
But it works, essentially
because-- well,

00:36:24.220 --> 00:36:27.900
if you think of a line over here
as just a pair of coordinates,

00:36:27.900 --> 00:36:30.190
usually written a,
b, then we're just

00:36:30.190 --> 00:36:33.090
taking essentially a dot product
between those two things.

00:36:33.090 --> 00:36:33.840
It's a plus 1.

00:36:33.840 --> 00:36:35.714
But it doesn't matter
which one was the point

00:36:35.714 --> 00:36:37.390
and which one was the line.

00:36:37.390 --> 00:36:39.620
So that's very convenient.

00:36:39.620 --> 00:36:42.017
And you can use that to
convert a lot of line problems

00:36:42.017 --> 00:36:42.850
into point problems.

00:36:46.670 --> 00:36:49.650
I won't mention k sum very much.

00:36:49.650 --> 00:36:56.120
But obviously, the d dimensional
versions here are d plus 1 sum

00:36:56.120 --> 00:36:56.900
hard.

00:36:56.900 --> 00:37:01.560
So that's these are sort of the
more geometric versions of k

00:37:01.560 --> 00:37:02.060
sum.

00:37:09.710 --> 00:37:12.780
So let's do some more problems.

00:37:16.330 --> 00:37:17.670
Next one's called a separator.

00:37:33.370 --> 00:37:40.780
So let's say we're given n
line segments in the plane,

00:37:40.780 --> 00:37:43.950
is there a line
that separates them

00:37:43.950 --> 00:37:46.310
into any two non-empty groups?

00:38:01.860 --> 00:38:05.190
And that line is not allowed to
intersect any of the segments.

00:38:08.850 --> 00:38:13.350
So you're not allowed to split
a line segment into two parts.

00:38:13.350 --> 00:38:19.100
You just want to partition the
line segments into a left chunk

00:38:19.100 --> 00:38:22.150
and a right chunk.

00:38:22.150 --> 00:38:25.790
So there's actually two
versions of this problem.

00:38:25.790 --> 00:38:30.280
The first version allows half
infinite rays as segments.

00:38:30.280 --> 00:38:34.000
And then you can assume that
all the segments are horizontal.

00:38:34.000 --> 00:38:37.210
So I think that pretty
clearly expresses it.

00:38:37.210 --> 00:38:40.020
But we can in
particular think that we

00:38:40.020 --> 00:38:42.720
are reducing from GeomBase.

00:38:42.720 --> 00:38:44.460
We had this setup.

00:38:44.460 --> 00:38:46.630
We have points on three lines.

00:38:46.630 --> 00:38:48.677
We want to know whether
there's a line that

00:38:48.677 --> 00:38:49.510
passes through them.

00:38:49.510 --> 00:38:52.000
So I'm just going to take
the complement essentially

00:38:52.000 --> 00:38:56.600
of those lines, emit tiny
intervals wherever I had points

00:38:56.600 --> 00:38:57.470
before.

00:38:57.470 --> 00:38:59.660
And now there will be a
separating line, if and only

00:38:59.660 --> 00:39:02.444
if, the original points
have a line through them.

00:39:02.444 --> 00:39:03.860
If you make these
tiny enough, you

00:39:03.860 --> 00:39:07.415
won't be able to do
anything else-- oops, yeah--

00:39:07.415 --> 00:39:10.030
or you could just split
them into 1/3, 2/3, yeah.

00:39:10.030 --> 00:39:13.561
I definitely need here that
it's a non-horizontal line.

00:39:13.561 --> 00:39:14.060
Thanks.

00:39:24.450 --> 00:39:27.220
Now this requires having
these half infinite rays.

00:39:27.220 --> 00:39:32.280
Otherwise you could
make a line like this.

00:39:32.280 --> 00:39:34.650
So you're not allowed to
do that if these goes off

00:39:34.650 --> 00:39:37.780
to infinity, then you'd
be cutting those rays.

00:39:37.780 --> 00:39:39.530
OK, so maybe you
consider that reasonable.

00:39:39.530 --> 00:39:40.030
Maybe not.

00:39:40.030 --> 00:39:41.780
Depends on the application.

00:39:41.780 --> 00:39:44.289
If you don't consider half
infinite things reasonable,

00:39:44.289 --> 00:39:46.330
you can replace them with
some vertical segments.

00:39:46.330 --> 00:39:49.380
You build this little
box, essentially

00:39:49.380 --> 00:39:52.150
a box like a pinwheel pattern.

00:39:52.150 --> 00:39:53.760
So there's no way
to cut it up except

00:39:53.760 --> 00:39:56.870
to go through the center.

00:39:56.870 --> 00:40:00.940
So two versions-- version one,
we allow half infinite things.

00:40:00.940 --> 00:40:02.630
And every segment is horizontal.

00:40:02.630 --> 00:40:04.860
Version two, horizontal
and vertical segments

00:40:04.860 --> 00:40:06.680
are all finite length.

00:40:06.680 --> 00:40:10.560
We'll use this version to
reduce from a bunch of times.

00:40:10.560 --> 00:40:15.450
Or we will follow this kind
of reduction essentially.

00:40:15.450 --> 00:40:16.740
OK, next problem.

00:40:38.220 --> 00:40:41.520
OK, next problem is
called strips cover box.

00:40:47.169 --> 00:40:48.460
I like these names of problems.

00:40:48.460 --> 00:40:49.420
They're pretty clear.

00:40:52.920 --> 00:40:56.450
In fact, they're so
clear, here's a figure.

00:40:56.450 --> 00:41:00.470
We have a box, which means
axes align rectangle.

00:41:00.470 --> 00:41:01.780
And I have strips.

00:41:01.780 --> 00:41:05.330
Strips are-- I take
two parallel lines

00:41:05.330 --> 00:41:07.400
and take the lines
in between them.

00:41:07.400 --> 00:41:11.100
All these parallel lines between
here and here-- that's a strip.

00:41:11.100 --> 00:41:12.180
So I'm given n strips.

00:41:12.180 --> 00:41:13.030
I'm given a box.

00:41:13.030 --> 00:41:15.010
I want to know whether
there's an empty part

00:41:15.010 --> 00:41:16.850
or whether it covers.

00:41:16.850 --> 00:41:19.780
AUDIENCE: Can you [? use ?]
angle or just strips?

00:41:19.780 --> 00:41:23.350
PROFESSOR: Oh, yeah, sorry,
the strips are placed.

00:41:23.350 --> 00:41:25.050
I give you two lines
for each strip.

00:41:25.050 --> 00:41:27.700
And I mean the region
in between them.

00:41:27.700 --> 00:41:29.480
They're on the plane.

00:41:29.480 --> 00:41:30.980
You can't slide them around.

00:41:30.980 --> 00:41:33.540
That would be a
coverage problem.

00:41:33.540 --> 00:41:34.407
It's pretty easy.

00:41:34.407 --> 00:41:35.990
I just want to compute
whether there's

00:41:35.990 --> 00:41:39.320
any point in here is not hit
by any of the given strips.

00:41:42.780 --> 00:41:45.935
I should mention, all
of these problems,

00:41:45.935 --> 00:41:47.310
except where I
say otherwise, can

00:41:47.310 --> 00:41:49.630
be solved in quadratic time.

00:41:49.630 --> 00:41:51.970
And so this is showing that
that's essentially tight.

00:41:51.970 --> 00:41:54.490
So you can solve this
problem by computing

00:41:54.490 --> 00:41:56.490
the arrangement of these
lines in quadratic time

00:41:56.490 --> 00:41:58.990
and checking all the
cells, whether they're

00:41:58.990 --> 00:42:00.140
in all the strips.

00:42:00.140 --> 00:42:01.244
So that's not hard.

00:42:01.244 --> 00:42:02.910
But the claim is you
can't do any better

00:42:02.910 --> 00:42:05.050
than n squared if you
believe the 3SUM conjecture.

00:42:09.140 --> 00:42:11.880
And the reduction
is essentially this.

00:42:11.880 --> 00:42:14.600
But I'm going to
modify it a little bit.

00:42:22.080 --> 00:42:25.710
So remember, I rotated this
90 degrees for a reason,

00:42:25.710 --> 00:42:29.290
because I wanted to use a
particular kind of duality.

00:42:29.290 --> 00:42:32.410
The construction is going
to be the dual of this.

00:42:32.410 --> 00:42:36.520
But remember, here, the goal is
to find the line that does not

00:42:36.520 --> 00:42:40.115
hit any of these segments.

00:42:40.115 --> 00:42:42.100
And the segments are vertical.

00:42:42.100 --> 00:42:46.020
Or they might be infinite,
half infinite rays.

00:42:46.020 --> 00:42:49.100
OK, so I'm going to
start from there.

00:42:49.100 --> 00:42:53.170
And then I'm going to dualize,
using a different dualization.

00:42:53.170 --> 00:42:54.840
This is probably
the most popular one

00:42:54.840 --> 00:42:55.923
in computational geometry.

00:43:02.700 --> 00:43:05.690
I think because everyone
remembers y equals mx plus b.

00:43:05.690 --> 00:43:07.520
And so there's the
obvious conversion

00:43:07.520 --> 00:43:11.990
between a point, which has
b and m, to a line, which

00:43:11.990 --> 00:43:15.169
is mx plus b.

00:43:15.169 --> 00:43:16.710
You could argue
about which is which,

00:43:16.710 --> 00:43:18.860
but I think this
is the more common.

00:43:18.860 --> 00:43:23.830
So what this means is
I start with a point.

00:43:23.830 --> 00:43:27.110
The y-coordinate determines
the slope of my line.

00:43:27.110 --> 00:43:31.090
And the x-coordinate determines
the y-intercept of my line.

00:43:31.090 --> 00:43:33.420
It's b.

00:43:33.420 --> 00:43:36.821
And you can also convert
in the other direction.

00:43:36.821 --> 00:43:38.320
I don't think we'll
need to be here.

00:43:38.320 --> 00:43:40.420
And that will work for
all non-vertical lines.

00:43:40.420 --> 00:43:42.580
This will not represent
vertical lines.

00:43:42.580 --> 00:43:44.880
In case you're curious, if
you want vertical lines here

00:43:44.880 --> 00:43:49.180
or if you want lines going
through the origin here,

00:43:49.180 --> 00:43:50.450
you need points in infinity.

00:43:50.450 --> 00:43:52.000
That's the projective
thing here.

00:43:52.000 --> 00:43:55.000
But we don't need that here.

00:43:55.000 --> 00:43:57.680
Because we're just going
to take these points

00:43:57.680 --> 00:44:00.330
and convert each of them
to corresponding lines.

00:44:00.330 --> 00:44:02.390
So this is a segment,
I'm going to get

00:44:02.390 --> 00:44:04.660
an infinite number
of points-- sorry,

00:44:04.660 --> 00:44:06.410
there's an infinite
number of points here.

00:44:06.410 --> 00:44:08.785
So I'm going to convert into
an infinite number of lines.

00:44:08.785 --> 00:44:10.590
That's actually
OK, because these

00:44:10.590 --> 00:44:18.050
points all I have the
same-- sorry-- opposite.

00:44:20.800 --> 00:44:23.750
I really want the x-coordinate
to m and the y-coordinate

00:44:23.750 --> 00:44:27.290
to be b for this picture
to be the right picture.

00:44:27.290 --> 00:44:30.500
So all these points have
the same x-coordinate.

00:44:30.500 --> 00:44:32.900
So when I convert
them into lines,

00:44:32.900 --> 00:44:34.130
they all have the same slope.

00:44:34.130 --> 00:44:37.270
And they'll also be
right next to each other.

00:44:37.270 --> 00:44:39.810
Namely, they will be a strip.

00:44:39.810 --> 00:44:41.850
Isn't that cool?

00:44:41.850 --> 00:44:44.670
So when you do this
dualization, a vertical segment

00:44:44.670 --> 00:44:45.470
becomes a strip.

00:44:53.530 --> 00:44:56.030
I think the fancy
word would be here

00:44:56.030 --> 00:44:58.390
you have a pencil of points.

00:44:58.390 --> 00:45:01.040
And you convert that into
a pencil of parallel lines.

00:45:01.040 --> 00:45:04.960
A pencil of parallel
lines is strip.

00:45:04.960 --> 00:45:09.040
Pencil just means like
a continuous family.

00:45:09.040 --> 00:45:12.380
Now here, these
guys are infinite.

00:45:12.380 --> 00:45:14.530
So it's going to be a
strip that it goes off

00:45:14.530 --> 00:45:16.350
to infinity on one end.

00:45:16.350 --> 00:45:18.650
That's a half plane.

00:45:18.650 --> 00:45:22.170
So if we have a
ray, vertical ray,

00:45:22.170 --> 00:45:25.500
that's going to convert
into half plane.

00:45:25.500 --> 00:45:27.004
Half planes aren't
allowed, so we're

00:45:27.004 --> 00:45:28.670
going to have to do
something with them.

00:45:28.670 --> 00:45:29.878
But there's only six of them.

00:45:29.878 --> 00:45:34.180
There's three down
here and three up here.

00:45:34.180 --> 00:45:38.660
And we also haven't defined
what our target rectangle is.

00:45:38.660 --> 00:45:40.750
But at this point
what we would like

00:45:40.750 --> 00:45:46.220
to say-- so let's see, what
would it correspond to a line

00:45:46.220 --> 00:45:46.960
here?

00:45:46.960 --> 00:45:49.500
Notice, the line will
never be vertical.

00:45:49.500 --> 00:45:51.870
What would be a
line that happens

00:45:51.870 --> 00:45:53.430
not to hit any of these things?

00:45:53.430 --> 00:45:55.714
In the dual, that
line maps to a point.

00:45:55.714 --> 00:45:57.130
And so that's
saying that there is

00:45:57.130 --> 00:46:00.410
a point that is not covered
by any of these strips or half

00:46:00.410 --> 00:46:02.460
planes.

00:46:02.460 --> 00:46:04.870
So we want to know whether
the union of these things

00:46:04.870 --> 00:46:07.340
is the entire plane.

00:46:07.340 --> 00:46:10.420
So it's not quite the problem
we wanted to reduce do.

00:46:10.420 --> 00:46:12.620
But it's not hard to fix it.

00:46:12.620 --> 00:46:14.890
We essentially just need to
make a retake a really big

00:46:14.890 --> 00:46:15.795
rectangle.

00:46:15.795 --> 00:46:17.670
And then there'll be an
empty point in there,

00:46:17.670 --> 00:46:22.017
if and only if, there was
a line in this problem.

00:46:22.017 --> 00:46:23.600
How big does the
rectangle have to be?

00:46:23.600 --> 00:46:27.970
Well, conveniently, these
half planes essentially

00:46:27.970 --> 00:46:30.740
narrows down to a hexagon.

00:46:30.740 --> 00:46:34.800
So you have six of them.

00:46:34.800 --> 00:46:36.442
It might be less than a hexagon.

00:46:36.442 --> 00:46:37.660
But I'll just draw six.

00:46:37.660 --> 00:46:41.220
And we're saying all of
this stuff is covered.

00:46:41.220 --> 00:46:43.070
All the things
outside the hexagon

00:46:43.070 --> 00:46:44.532
are covered by
those half planes.

00:46:44.532 --> 00:46:46.240
So really it's just
a matter whether this

00:46:46.240 --> 00:46:47.560
has any empty points.

00:46:47.560 --> 00:46:51.460
So take the bounding
box of that hexagon.

00:46:51.460 --> 00:46:52.305
That's my box.

00:46:55.670 --> 00:46:59.590
And now I don't have to worry
about half planes anymore.

00:47:06.170 --> 00:47:07.520
I can restrict them.

00:47:10.770 --> 00:47:12.370
I can just say,
oh, well, now this

00:47:12.370 --> 00:47:15.510
is a strip, which
covers-- in particular,

00:47:15.510 --> 00:47:18.270
I need to cover this
part of the rectangle.

00:47:18.270 --> 00:47:20.560
I no longer need to
go off to infinity.

00:47:20.560 --> 00:47:24.781
So now, I have a bunch of
finite strips and a finite box.

00:47:24.781 --> 00:47:26.780
And it's just a matter
of whether that thing has

00:47:26.780 --> 00:47:27.940
any empty parts.

00:47:27.940 --> 00:47:28.440
Yes?

00:47:28.440 --> 00:47:31.000
AUDIENCE: [INAUDIBLE]

00:47:31.000 --> 00:47:33.460
PROFESSOR: Yes, there will be
an empty point, if and only

00:47:33.460 --> 00:47:37.460
if the original thing
had a yes answer.

00:47:37.460 --> 00:47:40.770
So they will cover, if and only
if, if you have a no answer.

00:47:45.290 --> 00:47:45.960
Any questions?

00:47:45.960 --> 00:47:48.803
AUDIENCE: Just nomenclature--
can have word [INAUDIBLE]

00:47:48.803 --> 00:47:50.490
that thing you just
put on the right,

00:47:50.490 --> 00:47:52.095
because it's actually a
special case of what you call

00:47:52.095 --> 00:47:52.595
[INAUDIBLE].

00:47:52.595 --> 00:47:54.950
PROFESSOR: Yeah,
right, so what they say

00:47:54.950 --> 00:47:57.720
is this a reduction
from GeomBase, mimicking

00:47:57.720 --> 00:48:00.370
the proof of separator 1.

00:48:00.370 --> 00:48:02.376
Yeah, I don't have
a name for it.

00:48:02.376 --> 00:48:02.875
Sorry.

00:48:05.990 --> 00:48:06.822
Yeah?

00:48:06.822 --> 00:48:07.697
AUDIENCE: [INAUDIBLE]

00:48:14.550 --> 00:48:18.840
PROFESSOR: Yes, this duality
also preserves incidence.

00:48:18.840 --> 00:48:20.870
I think it's a slightly
perturbed version

00:48:20.870 --> 00:48:22.520
of the regular
projector duality.

00:48:22.520 --> 00:48:25.740
It is also a projected
duality in a sense,

00:48:25.740 --> 00:48:28.820
but with an extra Mobius
transformation thrown in

00:48:28.820 --> 00:48:30.069
or something.

00:48:30.069 --> 00:48:31.485
But those also
preserve incidence.

00:48:35.380 --> 00:48:39.000
Yeah, we obviously need that.

00:48:39.000 --> 00:48:44.640
OK so to make this a little
more usable-- I mean,

00:48:44.640 --> 00:48:45.787
strips can be nice.

00:48:45.787 --> 00:48:47.120
We'll use it in some situations.

00:48:47.120 --> 00:48:50.500
But geometers tend to like
to think about triangles.

00:48:50.500 --> 00:48:54.240
So we can also convert this
into whether bunch of triangles

00:48:54.240 --> 00:48:55.790
cover a given triangle.

00:49:06.260 --> 00:49:09.100
Basically, so here we
are going to reduce

00:49:09.100 --> 00:49:11.130
from strips covering a box.

00:49:11.130 --> 00:49:13.080
We start with a box.

00:49:13.080 --> 00:49:18.210
And we're going to convert
that-- we'll draw on top of it

00:49:18.210 --> 00:49:19.760
so it's a little
clearer-- I'm going

00:49:19.760 --> 00:49:27.290
to take a really big triangle,
which contains that box.

00:49:27.290 --> 00:49:32.005
But then we'll triangulate
the exterior right here.

00:49:35.240 --> 00:49:37.530
And add those triangles
to my covering collection.

00:49:37.530 --> 00:49:40.320
So all of this stuff
is covered for free.

00:49:40.320 --> 00:49:43.390
And so now what remains-- in
order to cover this triangle,

00:49:43.390 --> 00:49:45.090
I just need to cover this box.

00:49:45.090 --> 00:49:48.620
OK so, that's one part of it.

00:49:48.620 --> 00:49:51.490
And then the other thing
is that we're given strips.

00:49:51.490 --> 00:49:54.490
So if I have a strip-- actually,
do I have a figure for this?

00:49:54.490 --> 00:49:58.520
No-- if I have a strip in
the original problem, which

00:49:58.520 --> 00:50:01.560
looks something like
this, I really only

00:50:01.560 --> 00:50:06.150
care about the portion of a
strip that hits the box here.

00:50:06.150 --> 00:50:11.000
So I will just
triangulate that part

00:50:11.000 --> 00:50:14.794
and say those triangles
are in my set.

00:50:14.794 --> 00:50:17.210
And then those triangles are
going to cover this triangle.

00:50:17.210 --> 00:50:19.300
The red triangles will
cover the red triangle,

00:50:19.300 --> 00:50:22.260
the big red triangle, if and
only if the white strips cover

00:50:22.260 --> 00:50:24.180
the white rectangle.

00:50:24.180 --> 00:50:26.016
Pretty easy-- all we
need is that these

00:50:26.016 --> 00:50:27.890
have constant complexity
so we're not blowing

00:50:27.890 --> 00:50:29.230
up more than a constant factor.

00:50:31.830 --> 00:50:34.140
Note here all of these
smaller triangles

00:50:34.140 --> 00:50:37.330
are contained inside
the big triangle.

00:50:37.330 --> 00:50:39.670
So you can even
assume that these guys

00:50:39.670 --> 00:50:41.310
are contained in this guy.

00:50:41.310 --> 00:50:47.950
We'll use that at some
point-- possibly very soon.

00:50:53.270 --> 00:50:57.595
So next problem.

00:51:21.620 --> 00:51:24.520
Hole in union-- I give
you a bunch of triangles.

00:51:24.520 --> 00:51:25.460
I take their union.

00:51:25.460 --> 00:51:28.170
I want to know whether that's
a simply connected polygon

00:51:28.170 --> 00:51:30.100
or whether it has a
hole in the center.

00:51:30.100 --> 00:51:30.975
AUDIENCE: [INAUDIBLE]

00:51:34.339 --> 00:51:36.130
PROFESSOR: Almost the
same as this problem.

00:51:36.130 --> 00:51:38.310
I do is to do a
little bit of work,

00:51:38.310 --> 00:51:42.420
because maybe you'd-- actually,
pretty much that reduction will

00:51:42.420 --> 00:51:45.870
work fine, as long as the outer
triangle is strictly bigger

00:51:45.870 --> 00:51:49.770
than the strip, then I'll always
have these outer red things,

00:51:49.770 --> 00:51:50.779
which make a region.

00:51:50.779 --> 00:51:52.320
And then there'll
be a hole in there,

00:51:52.320 --> 00:51:54.940
if and only if the rectangle
is not fully covered.

00:51:54.940 --> 00:51:58.280
So I just did to enlarge
that outer triangle slightly.

00:51:58.280 --> 00:52:01.800
Then I have proof that
this is 3SUM hard.

00:52:01.800 --> 00:52:04.180
Done.

00:52:04.180 --> 00:52:06.750
Here, we're also using that
the red triangles are contained

00:52:06.750 --> 00:52:09.050
inside the big red triangle.

00:52:09.050 --> 00:52:13.140
We don't go outside and possibly
make a hole in some other way.

00:52:13.140 --> 00:52:16.520
OK, another easy one--
triangle measure.

00:52:21.527 --> 00:52:22.860
I give you a bunch of triangles.

00:52:22.860 --> 00:52:25.960
What is the area of their union?

00:52:25.960 --> 00:52:28.440
Well, it's going to be the
area of the big triangle,

00:52:28.440 --> 00:52:30.660
if and only if the big
triangle's covered.

00:52:30.660 --> 00:52:35.000
So this is a reduction from
triangle covers triangle.

00:52:35.000 --> 00:52:36.045
OK, easy.

00:52:42.430 --> 00:52:45.665
Here's a somewhat different
problem-- point covering.

00:52:49.320 --> 00:52:57.890
So here I'm given a bunch
of half planes, n of them.

00:52:57.890 --> 00:53:02.536
I want to know is there
a k-way intersection?

00:53:09.834 --> 00:53:11.250
You can think of
this as a version

00:53:11.250 --> 00:53:13.790
of two-dimensional
linear programming.

00:53:13.790 --> 00:53:16.810
So this is all in 2D.

00:53:16.810 --> 00:53:19.040
You're given a bunch of
linear inequalities, which

00:53:19.040 --> 00:53:20.320
are half planes.

00:53:20.320 --> 00:53:22.570
You want to know-- not
can I satisfy all them,

00:53:22.570 --> 00:53:25.110
maybe that's not possible,
but can I satisfy at least k

00:53:25.110 --> 00:53:25.840
of them?

00:53:25.840 --> 00:53:28.090
So this is for approximating
linear programming.

00:53:28.090 --> 00:53:29.934
There a lot of algorithms
for doing that.

00:53:29.934 --> 00:53:31.350
You can do this
in quadratic time.

00:53:31.350 --> 00:53:33.040
But the claim is you
can't do it better

00:53:33.040 --> 00:53:37.610
unless if you believe
the 3SUM conjecture.

00:53:37.610 --> 00:53:45.720
OK, so this is-- I don't
have a figure-- no.

00:53:56.750 --> 00:54:00.075
So we're going to reduce
from strips cover box.

00:54:05.910 --> 00:54:08.480
So we're given a bunch--
this figure again--

00:54:08.480 --> 00:54:09.730
we're given a bunch of strips.

00:54:09.730 --> 00:54:11.250
We're given a rectangle.

00:54:11.250 --> 00:54:15.440
We want to convert that whether
the whole thing intersects

00:54:15.440 --> 00:54:18.350
to whether there's
a k-way intersection

00:54:18.350 --> 00:54:21.720
between infinite strips
on one side, half planes.

00:54:25.839 --> 00:54:27.130
So here's what I'm going to do.

00:54:27.130 --> 00:54:32.060
If I have a strip--
I should maybe really

00:54:32.060 --> 00:54:35.020
draw it this way--
bunch of parallel lines,

00:54:35.020 --> 00:54:37.470
finite segment of them.

00:54:37.470 --> 00:54:39.260
But the lines are
infinite in this is

00:54:39.260 --> 00:54:42.340
direction and this direction.

00:54:42.340 --> 00:54:47.260
I'm going to convert that into
the complement, a common trick

00:54:47.260 --> 00:54:48.040
here.

00:54:48.040 --> 00:54:50.420
So we have half plane over here.

00:54:50.420 --> 00:54:51.900
And we have a half
plane earlier.

00:54:54.450 --> 00:54:56.560
Obviously, you cannot be
in both of these at once,

00:54:56.560 --> 00:54:58.050
because they're disjoint.

00:54:58.050 --> 00:55:01.970
So the best you can hope for
is to be in one of them, which

00:55:01.970 --> 00:55:03.829
means you're not here.

00:55:03.829 --> 00:55:05.370
And remember, the
whole question here

00:55:05.370 --> 00:55:08.600
is whether there's a point that
is not in any of the strips.

00:55:08.600 --> 00:55:14.310
So you're going
to get one point--

00:55:14.310 --> 00:55:17.310
you're going to get a score
of 1 if you're here or here.

00:55:17.310 --> 00:55:20.570
You're going to get a score
of 0 locally if in the region

00:55:20.570 --> 00:55:23.830
that's already covered.

00:55:23.830 --> 00:55:27.650
Now we also need to represent
the rectangle in some way.

00:55:27.650 --> 00:55:32.400
So if I'm given a box.

00:55:32.400 --> 00:55:35.740
Draw this line, this line,
this line, and this line.

00:55:35.740 --> 00:55:37.826
And the half planes
I want are the ones

00:55:37.826 --> 00:55:38.950
that contain the rectangle.

00:55:47.020 --> 00:55:50.240
So the idea is you're going to
get four bonus points if you're

00:55:50.240 --> 00:55:52.330
in the rectangle.

00:55:52.330 --> 00:55:58.337
And now the question is-- I'm
going to set k to be n plus 4.

00:55:58.337 --> 00:56:00.170
I want to know are there
any points that are

00:56:00.170 --> 00:56:03.680
in n plus 4 of the half planes.

00:56:03.680 --> 00:56:05.620
To do that, you have
to be in all four

00:56:05.620 --> 00:56:07.900
of these-- in other
words, in the box--

00:56:07.900 --> 00:56:10.780
and in one of these
for every strip,

00:56:10.780 --> 00:56:13.100
because you can't be in both.

00:56:13.100 --> 00:56:15.220
It's just to achieve
that score of n plus 4.

00:56:15.220 --> 00:56:17.220
So that means you're
exterior to all the strips,

00:56:17.220 --> 00:56:18.660
but inside the rectangle.

00:56:18.660 --> 00:56:20.673
So that's the same problem.

00:56:20.673 --> 00:56:21.173
Cool.

00:56:29.850 --> 00:56:42.831
Next problem is a
visibility problem.

00:56:42.831 --> 00:56:44.705
So we've got a couple
of visibility problems.

00:56:54.020 --> 00:56:55.770
Both of these problems
are about something

00:56:55.770 --> 00:56:57.310
called weak visibility.

00:57:00.850 --> 00:57:03.870
If you have two geometric
objects, a and b,

00:57:03.870 --> 00:57:05.750
they are strongly
visible to each other,

00:57:05.750 --> 00:57:09.320
if every point over here can
see every point over here,

00:57:09.320 --> 00:57:17.022
meaning the visibility line
doesn't cross anything else.

00:57:17.022 --> 00:57:18.480
But what we're
talking about here's

00:57:18.480 --> 00:57:20.570
weak visibility,
which says there's

00:57:20.570 --> 00:57:24.010
some point over here which
can see some point over here.

00:57:24.010 --> 00:57:26.990
So I want to know, say, given
two segments, whether there's

00:57:26.990 --> 00:57:29.230
some point here, some
point here, where

00:57:29.230 --> 00:57:31.620
if I draw the connecting
visibility line,

00:57:31.620 --> 00:57:34.200
there's no other
segment blocking it.

00:57:34.200 --> 00:57:35.805
So this is a.

00:57:35.805 --> 00:57:37.040
And this is b.

00:57:37.040 --> 00:57:39.188
This would be an example
where a and b-- well, they

00:57:39.188 --> 00:57:41.354
do weakly see each other,
because there's that pair.

00:57:44.320 --> 00:57:46.476
So given n segments,
you can construct

00:57:46.476 --> 00:57:48.100
what's called a
visibility graph, which

00:57:48.100 --> 00:57:51.380
is all of these things
in quadratic time.

00:57:51.380 --> 00:57:54.430
If I want to know
whether this segment can

00:57:54.430 --> 00:57:59.082
see another segment in this
weak sense, that's 3SUM hard.

00:57:59.082 --> 00:57:59.790
Here's the proof.

00:58:03.281 --> 00:58:07.320
It's exactly the same thing,
just add two segments.

00:58:07.320 --> 00:58:09.330
This segment can
see that segment,

00:58:09.330 --> 00:58:10.910
if and only if there's a line.

00:58:13.740 --> 00:58:15.719
There are so many fun
little things you can do.

00:58:15.719 --> 00:58:17.510
But these are problems
that a lot of people

00:58:17.510 --> 00:58:18.390
have thought about.

00:58:18.390 --> 00:58:19.620
And they're always
wondering, can we

00:58:19.620 --> 00:58:20.790
do better than quadratic?

00:58:20.790 --> 00:58:25.610
Now we know they're all sort
of in the same bucket-- almost.

00:58:25.610 --> 00:58:28.755
OK, here's another problem.

00:58:48.850 --> 00:58:55.440
So the problem is I give you
a bunch of triangles in 3D.

00:58:55.440 --> 00:59:03.810
And let's see, and maybe I
give you a point up here.

00:59:03.810 --> 00:59:06.380
And I want to know whether
that point can weakly

00:59:06.380 --> 00:59:08.500
see a given triangle.

00:59:08.500 --> 00:59:10.461
And here all the
triangles are horizontal.

00:59:10.461 --> 00:59:11.460
Make it nice and simple.

00:59:11.460 --> 00:59:13.330
And it is possible to
solve this, I think,

00:59:13.330 --> 00:59:16.940
in n squared log n time--
maybe n squared time.

00:59:16.940 --> 00:59:21.640
You can construct the visibility
graph here in n squared,

00:59:21.640 --> 00:59:23.270
because they're all horizontal.

00:59:23.270 --> 00:59:27.250
So I'm given this point.

00:59:27.250 --> 00:59:28.910
I want to know can
it see any of t.

00:59:28.910 --> 00:59:31.620
Or is it completely
blocked by these triangles?

00:59:31.620 --> 00:59:33.510
Sound familiar?

00:59:33.510 --> 00:59:37.100
If we put that point way
up near or at infinity,

00:59:37.100 --> 00:59:39.800
depending on what you
allow me-- near infinity

00:59:39.800 --> 00:59:41.580
will be enough--
this will essentially

00:59:41.580 --> 00:59:44.720
be orthographic projection
of these triangles

00:59:44.720 --> 00:59:45.519
onto this triangle.

00:59:45.519 --> 00:59:47.310
And it's a question
whether these triangles

00:59:47.310 --> 00:59:48.870
cover this triangle.

00:59:48.870 --> 00:59:51.680
So this is a reduction from
triangles cover triangle

00:59:51.680 --> 00:59:54.179
to visible triangle.

00:59:54.179 --> 00:59:55.970
Pretty easy, just put
all these guys really

00:59:55.970 --> 00:59:58.500
close, slightly
different z-coordinates

00:59:58.500 --> 01:00:00.850
so they're not overlapping,
and put the point far away.

01:00:04.350 --> 01:00:07.420
So visible triangle
is 3SUM hard.

01:00:07.420 --> 01:00:10.330
All right, let's do
some motion planning,

01:00:10.330 --> 01:00:24.250
robot motion planning-- first in
2D-- so planar motion planning.

01:00:24.250 --> 01:00:26.070
I give you a segment.

01:00:26.070 --> 01:00:28.430
That's the robot.

01:00:28.430 --> 01:00:30.730
And I have-- so this
is the special arm,

01:00:30.730 --> 01:00:35.240
the robot-- then I have various
obstacles, which the robot is

01:00:35.240 --> 01:00:37.320
not allowed to penetrate.

01:00:37.320 --> 01:00:39.430
I give you a starting
position for the robot.

01:00:39.430 --> 01:00:42.010
And I give you a target
position for the robot.

01:00:42.010 --> 01:00:46.810
And want to know can I go from
here to here by some motion?

01:00:46.810 --> 01:00:50.460
And motion we'd allow
rotations and translations.

01:00:50.460 --> 01:00:52.790
So can I slide
this robot somehow

01:00:52.790 --> 01:00:56.360
through this obstacle
course, in here, just

01:00:56.360 --> 01:00:58.410
some parallel parking, whatever.

01:00:58.410 --> 01:01:00.680
You can do lots of tricks
to get from A to B.

01:01:00.680 --> 01:01:02.830
This problem can be
solved in quadratic time.

01:01:02.830 --> 01:01:06.070
Most 2D motion planning
problems with just rotation

01:01:06.070 --> 01:01:09.270
and translation can be
sold in n squared time.

01:01:12.040 --> 01:01:14.890
And that's tight,
because of this.

01:01:19.422 --> 01:01:21.630
We build these frames, which
are large enough that it

01:01:21.630 --> 01:01:22.747
doesn't concern the robot.

01:01:22.747 --> 01:01:24.330
The robot's big
enough that it's going

01:01:24.330 --> 01:01:27.120
to have to simultaneously
pierce all three lines here.

01:01:27.120 --> 01:01:29.106
And we're done.

01:01:29.106 --> 01:01:29.770
OK, great.

01:01:32.300 --> 01:01:37.140
All this build up for
very simple proofs.

01:01:37.140 --> 01:01:39.064
Cool, one more.

01:01:39.064 --> 01:01:43.150
AUDIENCE: Is that one
actually quadratic time?

01:01:43.150 --> 01:01:48.410
PROFESSOR: Yeah, you can
solve this in quadratic time.

01:01:48.410 --> 01:01:49.242
Cubic is obvious.

01:01:49.242 --> 01:01:50.700
There are three
degrees of freedom.

01:01:50.700 --> 01:01:53.750
But I think, in
fact, quadratic time.

01:01:53.750 --> 01:01:54.980
That's claim in the paper.

01:01:54.980 --> 01:01:58.430
I haven't studied motion
planning algorithms

01:01:58.430 --> 01:01:58.950
for a while.

01:01:58.950 --> 01:02:01.710
So I don't know
exactly how it goes.

01:02:01.710 --> 01:02:04.600
But in general, constant
dimensional motion planning

01:02:04.600 --> 01:02:07.510
with constant numbers of objects
can solved in polynomial time.

01:02:07.510 --> 01:02:13.776
But you can debate
about the constants,

01:02:13.776 --> 01:02:15.000
which do matter here.

01:02:15.000 --> 01:02:17.810
I think the claim is
tightness for that one.

01:02:17.810 --> 01:02:20.800
Here's another one which can be
solved in-- their claim here,

01:02:20.800 --> 01:02:24.930
they say n squared
log n they say.

01:02:24.930 --> 01:02:29.060
We can probably get n squared,
but n squared log n is enough.

01:02:29.060 --> 01:02:31.575
It's a particular version
of 3D motion planning.

01:02:38.950 --> 01:02:43.020
So we are given a
vertical segment.

01:02:43.020 --> 01:02:45.450
That's our robot.

01:02:45.450 --> 01:02:47.030
We're going to have triangles.

01:02:47.030 --> 01:02:48.840
Those are our obstacles,
because triangles

01:02:48.840 --> 01:02:49.870
we can make polyhedra.

01:02:49.870 --> 01:02:54.860
In this case, all the triangles
will lie in horizontal planes.

01:02:54.860 --> 01:02:58.000
And the segment position
will be vertical.

01:02:58.000 --> 01:02:59.920
And here you're only
allowed translation.

01:03:04.971 --> 01:03:07.220
With translation and rotation,
you could also do this.

01:03:07.220 --> 01:03:09.380
But they restrict
to translation only,

01:03:09.380 --> 01:03:11.611
because there they can get
a almost quadratic time

01:03:11.611 --> 01:03:12.110
algorithm.

01:03:12.110 --> 01:03:14.980
With rotation you have to
add a couple of factors of n

01:03:14.980 --> 01:03:16.000
probably.

01:03:16.000 --> 01:03:19.340
But this version, they can
solve in n squared log n.

01:03:19.340 --> 01:03:24.520
And it's 3SUM hard by
similar kind of structure

01:03:24.520 --> 01:03:28.670
to the triangles
covering triangle.

01:03:28.670 --> 01:03:31.540
Mainly, we build this cage--
the triangles aren't shaded in.

01:03:31.540 --> 01:03:34.750
But there's basically a
triangle of triangles here,

01:03:34.750 --> 01:03:35.960
and a bunch of them.

01:03:35.960 --> 01:03:37.290
The segment is a unit length.

01:03:37.290 --> 01:03:41.350
And so there's this many
to subdivide the space.

01:03:41.350 --> 01:03:43.190
They call this a cage.

01:03:43.190 --> 01:03:46.260
All of these triangles
live in horizontal planes.

01:03:46.260 --> 01:03:48.760
There's no way for this
vertical robot with translation

01:03:48.760 --> 01:03:51.060
only to get out.

01:03:51.060 --> 01:03:52.736
It's too long.

01:03:52.736 --> 01:03:54.110
And so the starting
configuration

01:03:54.110 --> 01:03:55.270
is going to be up here.

01:03:55.270 --> 01:03:57.140
The destination is
going to be down here.

01:03:57.140 --> 01:03:59.517
And in the middle
triangle here, we're

01:03:59.517 --> 01:04:01.600
going to put a whole bunch
of triangles like this.

01:04:01.600 --> 01:04:03.270
So just squish this down.

01:04:03.270 --> 01:04:04.304
Put them all in here.

01:04:04.304 --> 01:04:06.470
And you're going to be able
to penetrate if and only

01:04:06.470 --> 01:04:07.469
if there's a blank spot.

01:04:13.540 --> 01:04:15.630
End of this paper.

01:04:15.630 --> 01:04:19.190
I think we covered almost
all of these proofs.

01:04:19.190 --> 01:04:22.410
We started with the base
problems, 3SUM, 3SUM prime,

01:04:22.410 --> 01:04:25.189
GeomBase, two
versions of separator,

01:04:25.189 --> 01:04:27.480
which we weren't directly
reducing from but we mimicked

01:04:27.480 --> 01:04:28.850
a zillion times.

01:04:28.850 --> 01:04:31.914
We had the degeneracy
over here, strips

01:04:31.914 --> 01:04:33.330
covering a box,
triangles covering

01:04:33.330 --> 01:04:34.980
a triangle, hole in the
union, visible triangle.

01:04:34.980 --> 01:04:36.938
Those are actually all
identical to each other.

01:04:36.938 --> 01:04:38.830
You could reduce
in all directions.

01:04:38.830 --> 01:04:40.210
We talked about point cup.

01:04:40.210 --> 01:04:42.380
This was the linear programming.

01:04:42.380 --> 01:04:44.510
Motion planning,
3D motion planning

01:04:44.510 --> 01:04:50.100
happen to reduce here instead
of there, and visibility.

01:04:50.100 --> 01:04:51.570
Cool.

01:04:51.570 --> 01:04:53.700
Lot of fun, little
reductions, and it

01:04:53.700 --> 01:04:56.380
gives you a flavor for n
squared hard-ish problems.

01:04:56.380 --> 01:04:59.320
AUDIENCE: Are there
restrictions at all?

01:04:59.320 --> 01:05:02.260
PROFESSOR: I think all
the restrictions are open.

01:05:02.260 --> 01:05:05.150
I mean, you'd have to check
all the paper since 1995.

01:05:05.150 --> 01:05:07.420
But definitely in that
paper, they're open.

01:05:07.420 --> 01:05:10.417
And I haven't heard of any--
there isn't a ton of work

01:05:10.417 --> 01:05:11.500
going the other direction.

01:05:11.500 --> 01:05:15.600
But it would differently
nice to, especially

01:05:15.600 --> 01:05:19.930
if 3SUM-- it builds more if
3SUM is the right problem,

01:05:19.930 --> 01:05:22.300
if you can do reductions
in both directions.

01:05:26.910 --> 01:05:30.490
I want to show you a
couple more-- I'll show you

01:05:30.490 --> 01:05:34.060
one more reduction, which
relates to a problem

01:05:34.060 --> 01:05:38.690
to be proved was strongly
NP complete at some point

01:05:38.690 --> 01:05:40.330
way back when.

01:05:40.330 --> 01:05:42.980
This is about
fixed angle chains.

01:05:42.980 --> 01:05:44.750
You have this kind
of linkage structure.

01:05:44.750 --> 01:05:46.680
These are rigid bars.

01:05:46.680 --> 01:05:48.500
These are rigid angles.

01:05:48.500 --> 01:05:53.740
But you can still twist
one segment around another.

01:05:53.740 --> 01:05:56.440
So it preserves the angles
and the edge lengths.

01:05:56.440 --> 01:05:58.340
And so if I give you
a structure like this,

01:05:58.340 --> 01:06:02.160
I want to know if I
spin along this edge,

01:06:02.160 --> 01:06:04.090
if I take all this
stuff and rotate it out

01:06:04.090 --> 01:06:07.880
of plane around this edge,
does it hit anything?

01:06:07.880 --> 01:06:09.320
Or can it go all the way around?

01:06:09.320 --> 01:06:10.050
What about this edge?

01:06:10.050 --> 01:06:10.760
What about this edge?

01:06:10.760 --> 01:06:11.730
What about this edge?

01:06:11.730 --> 01:06:15.360
This is a polynomial time
fixed angle chain problem.

01:06:15.360 --> 01:06:18.750
I want to know for every edge,
which one's spinning causes

01:06:18.750 --> 01:06:20.940
a collision.

01:06:20.940 --> 01:06:23.790
In fact, if I just want to
know whether these guys cause

01:06:23.790 --> 01:06:28.630
a collision, because if
they do, a plus b equals c.

01:06:28.630 --> 01:06:32.320
I think that's maybe clear
enough with your negative B/2

01:06:32.320 --> 01:06:33.050
in the middle.

01:06:33.050 --> 01:06:35.735
In this case, we've
shifted-- the A,

01:06:35.735 --> 01:06:38.184
B, C is the x-coordinate
in this structure.

01:06:38.184 --> 01:06:40.350
And these are candidate
foldings here where we miss,

01:06:40.350 --> 01:06:43.390
here we collide.

01:06:43.390 --> 01:06:46.010
We separated things
out by taking

01:06:46.010 --> 01:06:48.870
every item of a, subtracting a
huge number from it to put it

01:06:48.870 --> 01:06:52.700
over here, and every item
of c, adding a huge number.

01:06:52.700 --> 01:06:54.596
And because we're in
the 3SUM prime problem,

01:06:54.596 --> 01:06:55.970
we know we get
one item for each,

01:06:55.970 --> 01:06:58.600
so adding and subtracting
and matching huge number

01:06:58.600 --> 01:07:03.400
will preserve all 3SUM
pairs, 3SUM triples.

01:07:03.400 --> 01:07:05.560
So that let's us separate
out this picture.

01:07:05.560 --> 01:07:07.520
And then you just have to check
this reflection corresponds

01:07:07.520 --> 01:07:09.603
to adding in the right
way, because of negation we

01:07:09.603 --> 01:07:12.200
divided by 2.

01:07:12.200 --> 01:07:13.641
That's it.

01:07:13.641 --> 01:07:16.670
So that's another.

01:07:16.670 --> 01:07:18.440
And there are a bunch
of other problems,

01:07:18.440 --> 01:07:19.979
like if I give you
two polygons, I

01:07:19.979 --> 01:07:22.020
want to know whether I
can translate this polygon

01:07:22.020 --> 01:07:23.144
to fit inside that polygon.

01:07:23.144 --> 01:07:24.510
That's also 3SUM hard.

01:07:24.510 --> 01:07:28.730
Proof is a little bit messy,
so I don't have it here.

01:07:28.730 --> 01:07:37.390
Let me mention me another more
recent use of 3SUM conjecture

01:07:37.390 --> 01:07:39.535
is some non-quadratic
lower bounds.

01:07:44.970 --> 01:07:47.940
So we're still going to
assume the 3SUM conjecture,

01:07:47.940 --> 01:07:50.040
but we're going to prove
that a problem requires

01:07:50.040 --> 01:07:52.490
some time other than n squared.

01:07:52.490 --> 01:07:56.280
So here are two problems
where this has been done.

01:08:01.540 --> 01:08:03.682
These are graph
problems, which is cool,

01:08:03.682 --> 01:08:05.182
because everything
we've seen so far

01:08:05.182 --> 01:08:06.390
has been a geometric problem.

01:08:18.060 --> 01:08:19.540
So the weighted,
undirected graph,

01:08:19.540 --> 01:08:21.630
I want to know whether
there's a three cycle,

01:08:21.630 --> 01:08:24.297
also called a triangle,
of given weight.

01:08:24.297 --> 01:08:26.880
So I want to know, for example,
is there triangle weight of 0.

01:08:30.420 --> 01:08:33.630
This can be done in
polynomial time, obviously.

01:08:33.630 --> 01:08:44.189
And the lower bound says is
the number of edges to the 1.5,

01:08:44.189 --> 01:08:49.100
instead of 2 or however you
want to think about this,

01:08:49.100 --> 01:08:52.060
minus epsilon.

01:08:52.060 --> 01:08:53.479
This is Mihai Petrescu.

01:08:53.479 --> 01:08:57.620
What he says is this problem,
finding this in this much time,

01:08:57.620 --> 01:09:00.779
is 3SUM hard, meaning
if this is possible,

01:09:00.779 --> 01:09:03.660
then 3SUM could be solved
in sub-quadratic time.

01:09:03.660 --> 01:09:07.334
So there's a gap between
this bound and 3SUM bound,

01:09:07.334 --> 01:09:08.500
introduced by the reduction.

01:09:17.220 --> 01:09:18.370
Here's another fun problem.

01:09:26.620 --> 01:09:29.189
Here we're given an unweighted
graph, undirected graph.

01:09:29.189 --> 01:09:32.649
And we just want to
find e triangles.

01:09:32.649 --> 01:09:36.370
Just list them form me please or
tell me there aren't that many.

01:09:38.990 --> 01:09:42.630
You cannot do that in any better
than e to the 4/3 minus epsilon

01:09:42.630 --> 01:09:46.760
times if you believe
the 3SUM conjecture.

01:09:46.760 --> 01:09:50.290
So these are both 3SUM
hard in a different sense

01:09:50.290 --> 01:09:52.634
from what we were using before.

01:09:52.634 --> 01:09:54.380
Before it was
quadratic quadratic.

01:09:54.380 --> 01:09:57.310
With graphs, also
there's v verses e.

01:09:57.310 --> 01:09:58.850
But neither of
these are quadratic

01:09:58.850 --> 01:10:00.070
no matter how you slice them.

01:10:00.070 --> 01:10:03.046
So there are different.

01:10:03.046 --> 01:10:05.170
So there are a small number
of pounds of that form.

01:10:05.170 --> 01:10:10.550
And that's kind of interesting
and relatively hot area.

01:10:10.550 --> 01:10:12.880
So a few people are
thinking about that.

01:10:12.880 --> 01:10:18.880
In particular, there's been
a recent surge of interest

01:10:18.880 --> 01:10:20.650
in thinking about
graph problems.

01:10:20.650 --> 01:10:23.860
Now for graph
problems, there isn't

01:10:23.860 --> 01:10:25.645
a ton of work
relating 3SUM, which

01:10:25.645 --> 01:10:28.120
is a very arithmetic
problem to graph problems,

01:10:28.120 --> 01:10:31.140
but this is the
beginning of that.

01:10:31.140 --> 01:10:32.530
But there are some
other problems

01:10:32.530 --> 01:10:35.280
which people think are hard.

01:10:35.280 --> 01:10:36.850
So let me give you some of them.

01:10:41.630 --> 01:10:48.490
Diameter-- so here we're given
a weighted, undirected graph.

01:10:48.490 --> 01:10:54.250
I want to know-- so delta v,
w-- this is like CRLS notation.

01:10:54.250 --> 01:10:57.330
This is the weight
of the minimum weight

01:10:57.330 --> 01:11:00.010
path from v to w.

01:11:00.010 --> 01:11:01.860
And I want to know the
max overall v to w.

01:11:01.860 --> 01:11:04.430
What is the longest
shortest path?

01:11:04.430 --> 01:11:05.130
That's diameter.

01:11:07.840 --> 01:11:22.670
Conjecture-- no V to
the 3 minus epsilon.

01:11:22.670 --> 01:11:27.730
So here there's a lot of
interest around cubic problems,

01:11:27.730 --> 01:11:30.460
because this
problem seems cubic.

01:11:30.460 --> 01:11:36.270
Another closely related problem
is all pair shortest paths.

01:11:36.270 --> 01:11:41.770
I want to know delta of
v, w for all v and w.

01:11:41.770 --> 01:11:44.210
This is, of course, a harder
problem than diameter.

01:11:44.210 --> 01:11:48.727
Also, this conjecture
implies conjecture over here.

01:11:48.727 --> 01:11:50.060
This one's a little more famous.

01:11:50.060 --> 01:11:53.130
The all pairs shortest path
conjecture is that you cannot

01:11:53.130 --> 01:11:56.110
solve this in truly
sub-cubic time.

01:11:56.110 --> 01:11:59.070
There are, again,
poly log improvements.

01:11:59.070 --> 01:12:04.600
But you cannot beat-- we
don't know how to beat by a v

01:12:04.600 --> 01:12:08.880
to the epsilon factor, n
to the epsilon factor over

01:12:08.880 --> 01:12:14.330
the standard algorithm, which
should be Floyd Warshall,

01:12:14.330 --> 01:12:15.340
the triply nested loop.

01:12:15.340 --> 01:12:20.947
Relax every edge n times is
the standard cubed algorithm.

01:12:20.947 --> 01:12:22.530
For sparse graphs
you could do better.

01:12:22.530 --> 01:12:26.874
For dense graphs, the claim
is that's the best you can do.

01:12:26.874 --> 01:12:29.040
And so there's a bunch of
problems that are all pair

01:12:29.040 --> 01:12:30.050
shortest path hard.

01:12:30.050 --> 01:12:34.320
There are some problems
that are diameter hard.

01:12:34.320 --> 01:12:37.150
Being diameter hard is
a little bit stronger.

01:12:37.150 --> 01:12:41.130
Obviously, diameter
can reduce to all pairs

01:12:41.130 --> 01:12:45.190
shortest paths via now we want
a sub-cubic reduction, something

01:12:45.190 --> 01:12:47.670
n to the 3 minus epsilon
time instead of n

01:12:47.670 --> 01:12:49.000
to the 2 minus epsilon.

01:12:49.000 --> 01:12:51.270
You can reduce diameter to
all pairs shortest paths.

01:12:51.270 --> 01:12:53.894
Big open problem is whether you
could reduce all pairs shortest

01:12:53.894 --> 01:12:55.620
paths to diameter.

01:12:55.620 --> 01:12:57.360
But you can reduce
all pairs shortest

01:12:57.360 --> 01:13:00.050
paths to some cool problems.

01:13:07.500 --> 01:13:12.190
I have an image of
some reductions.

01:13:12.190 --> 01:13:18.380
So negative triangle-- is there
a triangle of negative weight?

01:13:25.420 --> 01:13:27.910
Over here we wanted a
triangle of weight exactly 0.

01:13:27.910 --> 01:13:30.162
That helps you
find things faster.

01:13:30.162 --> 01:13:32.370
Over here we just want a
triangle of negative weight.

01:13:32.370 --> 01:13:34.090
There's more options for those.

01:13:34.090 --> 01:13:37.090
Finding that is all pairs
shortest paths hard.

01:13:37.090 --> 01:13:39.900
You can reduce all
pairs shortest path

01:13:39.900 --> 01:13:42.540
that problem-- kind of crazy.

01:13:42.540 --> 01:13:45.080
And here, the reduction
is not a single--

01:13:45.080 --> 01:13:47.150
or a constant number
of call reductions

01:13:47.150 --> 01:13:48.630
like we've been doing.

01:13:48.630 --> 01:13:50.260
This has a huge output.

01:13:50.260 --> 01:13:53.040
This only has a
yes or no output.

01:13:53.040 --> 01:13:54.830
So this reduction's
a little bit crazy.

01:13:54.830 --> 01:14:00.720
But basically you take
the sum over all calls

01:14:00.720 --> 01:14:03.060
for this reduction.

01:14:03.060 --> 01:14:07.334
And it just has to work
out that if you could solve

01:14:07.334 --> 01:14:09.250
negative triangle and
sub-cubic time, then you

01:14:09.250 --> 01:14:11.347
could also solve all
pairs shortest path

01:14:11.347 --> 01:14:13.410
in sub-cubic time.

01:14:13.410 --> 01:14:19.090
So if you take the
sum of the n primes

01:14:19.090 --> 01:14:22.420
to the power 3
minus epsilon, this

01:14:22.420 --> 01:14:25.570
should work out to
n to the 3 minus

01:14:25.570 --> 01:14:29.930
epsilon over the different
the different calls you

01:14:29.930 --> 01:14:31.180
make to the negative triangle.

01:14:31.180 --> 01:14:33.834
So it's a weaker notion
of reduction, which

01:14:33.834 --> 01:14:35.000
lets you prove these things.

01:14:35.000 --> 01:14:37.177
Kind of a big innovation
from just-- this one

01:14:37.177 --> 01:14:38.260
hasn't even published yet.

01:14:38.260 --> 01:14:39.860
It will be in [? Sodo ?] 2015.

01:14:39.860 --> 01:14:42.220
It's on the archive now.

01:14:42.220 --> 01:14:45.080
And there been a few papers
over the last few years doing

01:14:45.080 --> 01:14:46.204
these kinds of reductions.

01:14:46.204 --> 01:14:47.620
Actually the
negative triangle one

01:14:47.620 --> 01:14:51.420
is from an older paper
by Vassilevska Williams

01:14:51.420 --> 01:14:56.540
and Williams.

01:14:56.540 --> 01:15:00.440
It's a husband and
wife team, Stanford.

01:15:00.440 --> 01:15:16.350
OK, some more problems, radius--
for vertex v, the radius

01:15:16.350 --> 01:15:20.430
around v is how big a ball
do need to grow in order

01:15:20.430 --> 01:15:21.760
to cover all the vertices.

01:15:21.760 --> 01:15:27.240
I want to know what's the
farthest vertex w from v.

01:15:27.240 --> 01:15:29.520
And then the radius
of the graph is

01:15:29.520 --> 01:15:32.580
what is the best such vertex
that minimizes the radius,

01:15:32.580 --> 01:15:34.090
the vertex.

01:15:34.090 --> 01:15:35.270
So closely related to this.

01:15:35.270 --> 01:15:38.720
But it is equivalent
to negative triangle.

01:15:38.720 --> 01:15:42.220
Both of these are-- this
is a-- well, OK, of course,

01:15:42.220 --> 01:15:44.140
you could reduce negative
triangle to-- well,

01:15:44.140 --> 01:15:44.973
it's not so obvious.

01:15:44.973 --> 01:15:47.750
You can reduce radius to
all pairs shortest paths,

01:15:47.750 --> 01:15:49.770
because you have all the deltas.

01:15:49.770 --> 01:15:52.960
You can compute that
max-min in quadratic time.

01:15:52.960 --> 01:15:55.900
So that means all these problems
are equivalent to each other

01:15:55.900 --> 01:15:58.790
up to sub-cubic reductions.

01:15:58.790 --> 01:16:01.950
OK, median is another
problem-- very similar.

01:16:01.950 --> 01:16:05.830
I just replace this
max with a sum.

01:16:05.830 --> 01:16:10.130
So that's some other kind
of central located vertex.

01:16:10.130 --> 01:16:11.890
That's median.

01:16:11.890 --> 01:16:16.350
And that's also equivalent
to all these problems.

01:16:16.350 --> 01:16:19.770
So there's a growing
list of problems

01:16:19.770 --> 01:16:23.586
that are in this
sort of cubic space.

01:16:23.586 --> 01:16:25.460
All the problems are
conjectured to be cubic.

01:16:25.460 --> 01:16:27.350
And a lot of them are
equivalent to each other,

01:16:27.350 --> 01:16:29.165
though there's this
divide between diameter

01:16:29.165 --> 01:16:31.030
and all pairs shortest path.

01:16:31.030 --> 01:16:36.750
There are some bounds,
assuming strong ETH.

01:16:36.750 --> 01:16:45.560
So if you have strong
ETH, then there's

01:16:45.560 --> 01:16:50.799
no e to the 2 minus
epsilon algorithm.

01:16:50.799 --> 01:16:52.090
This is not quite what we want.

01:16:52.090 --> 01:16:54.300
We want to v to the
3 minus epsilon.

01:16:54.300 --> 01:16:59.510
This is a statement
about sparse graphs.

01:16:59.510 --> 01:17:01.580
You can beat this
for dense graphs.

01:17:01.580 --> 01:17:03.830
For sparse graphs
this is interesting.

01:17:03.830 --> 01:17:06.487
This is for the worst case
relationship between v and E.

01:17:06.487 --> 01:17:07.820
So you get somethings like this.

01:17:07.820 --> 01:17:10.880
You get this even if you
allow some approximatability.

01:17:10.880 --> 01:17:14.550
But we still don't have a way to
actually prove this conjecture.

01:17:14.550 --> 01:17:15.195
Yeah.

01:17:15.195 --> 01:17:17.320
AUDIENCE: Since you haven't
said anything about it,

01:17:17.320 --> 01:17:20.355
I assume that 3SUM
and this world, there

01:17:20.355 --> 01:17:22.149
is no bridge between them.

01:17:22.149 --> 01:17:24.190
PROFESSOR: I believe
there's no bridge currently.

01:17:24.190 --> 01:17:25.370
This is the closest thing.

01:17:25.370 --> 01:17:28.680
And they do seem similar.

01:17:28.680 --> 01:17:30.060
And also here we have cubic.

01:17:30.060 --> 01:17:31.840
There we have quadratic.

01:17:31.840 --> 01:17:32.900
So maybe you can do it.

01:17:32.900 --> 01:17:35.180
Maybe with 5 SUM you
could show some relation.

01:17:35.180 --> 01:17:35.850
I don't know.

01:17:35.850 --> 01:17:39.700
But there's no such theorem yet.

01:17:39.700 --> 01:17:43.010
These problems sound very
similar to these problems,

01:17:43.010 --> 01:17:45.510
in particular listing a
bunch of negative triangles

01:17:45.510 --> 01:17:47.160
is just as hard as finding one.

01:17:47.160 --> 01:17:49.749
And so there's some
similarity to over here.

01:17:49.749 --> 01:17:51.790
But the constraint on the
triangles is different.

01:17:51.790 --> 01:17:53.320
Here we want negative ones.

01:17:53.320 --> 01:17:57.690
Here any triangle or
triangle of 0 weight.

01:17:57.690 --> 01:18:00.200
So it's an interesting space.

01:18:00.200 --> 01:18:02.100
It's still very ongoing.

01:18:02.100 --> 01:18:04.770
All of these things-- this
stuff, and this stuff--

01:18:04.770 --> 01:18:07.410
is all within the
last four years.

01:18:07.410 --> 01:18:10.270
So it'll be interesting
to see how it develops.

01:18:10.270 --> 01:18:12.520
But these are the
current approaches

01:18:12.520 --> 01:18:14.710
to understanding n
squared, n cubed,

01:18:14.710 --> 01:18:17.890
and sort of the low end
of the polynomial spectra.

01:18:17.890 --> 01:18:20.117
I think it's pretty
interesting, but also where

01:18:20.117 --> 01:18:22.450
we know the least and have
the fewest general techniques

01:18:22.450 --> 01:18:23.670
for proving things.

01:18:23.670 --> 01:18:26.010
3SUM is a little
more established.

01:18:26.010 --> 01:18:29.810
And there's a bunch of proofs
like the one you've seen-- not

01:18:29.810 --> 01:18:32.470
too many out there actually.

01:18:32.470 --> 01:18:34.700
But they're quite accessible.

01:18:34.700 --> 01:18:37.870
This stuff is still,
I think, converging.

01:18:37.870 --> 01:18:39.860
But very exciting
things, relating

01:18:39.860 --> 01:18:42.510
all these algorithmic problems
to each other and kind

01:18:42.510 --> 01:18:43.995
of a nice way for us to end.

01:18:43.995 --> 01:18:48.190
This is my last
lecture for 6890.

01:18:48.190 --> 01:18:52.150
And the next two classes are
lectures by [? Acosis ?] about

01:18:52.150 --> 01:18:54.980
how [? arithmic ?] game theory
in a class called PPAD and PPAD

01:18:54.980 --> 01:18:57.350
hardness, which is
its own universe,

01:18:57.350 --> 01:19:00.260
but around economic game
theory and very cool stuff.

01:19:00.260 --> 01:19:02.890
He is the expert on it
and he's a professor here,

01:19:02.890 --> 01:19:05.280
so he graciously agreed
to do two lectures on it.

01:19:05.280 --> 01:19:05.910
Should be fun.

01:19:05.910 --> 01:19:07.460
I'm looking forward to it.

01:19:07.460 --> 01:19:09.010
Thanks.

