WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:02.579
NARRATOR: The following content
is provided under a Creative

00:00:02.579 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.060
Your support will help
MIT OpenCourseWare

00:00:06.060 --> 00:00:10.150
continue to offer high-quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.305
at ocw.mit.edu.

00:00:26.065 --> 00:00:26.940
PROFESSOR: All right.

00:00:26.940 --> 00:00:29.660
You guys ready for
some more games?

00:00:29.660 --> 00:00:34.650
Today, we will finish off
two-player games in particular.

00:00:34.650 --> 00:00:38.940
So last time, we were in this
world of two-player games

00:00:38.940 --> 00:00:42.290
with a polynomial-bounded
number of moves.

00:00:42.290 --> 00:00:46.740
We proved that Othello
reversi is PSPACE complete.

00:00:46.740 --> 00:00:49.950
All these games live in PSPACE.

00:00:49.950 --> 00:00:55.000
And we ended with constraint
logic in the two-player case.

00:00:55.000 --> 00:00:56.560
We proved that's
PSPACE complete.

00:00:56.560 --> 00:00:59.020
I'll just show you
that again in a moment.

00:00:59.020 --> 00:01:01.220
And then, in the
rest of today, we'll

00:01:01.220 --> 00:01:03.720
talk about various other games
that don't fit in this table,

00:01:03.720 --> 00:01:07.510
but in particular two-player
and unbounded number of moves.

00:01:07.510 --> 00:01:10.450
So exponential number of
moves, where you get x time

00:01:10.450 --> 00:01:13.150
completeness for
constraint logic

00:01:13.150 --> 00:01:18.670
and for various practical games
like checkers, chess, and go.

00:01:18.670 --> 00:01:21.220
But I won't prove all of this.

00:01:21.220 --> 00:01:27.570
So this is bounded to
player constraint logic.

00:01:27.570 --> 00:01:31.160
Remember, we could
simulate these formulas,

00:01:31.160 --> 00:01:35.270
where here the setup was you
can only flip each edge once.

00:01:35.270 --> 00:01:37.820
And in particular,
players could take

00:01:37.820 --> 00:01:40.570
turns deciding whether
to-- white player

00:01:40.570 --> 00:01:43.290
can set variables to true
by flipping these edges.

00:01:43.290 --> 00:01:46.140
Black player can set variables
false by flipping those edges.

00:01:46.140 --> 00:01:48.980
Then, if the formula
satisfied, white wins.

00:01:48.980 --> 00:01:51.640
And that was hard and in
particular constraint logic

00:01:51.640 --> 00:01:54.410
could simulate that problem.

00:01:58.450 --> 00:02:04.090
So what I want to show you
next is three real-life games

00:02:04.090 --> 00:02:07.360
that can be reduced from bounded
to player constraint logic.

00:02:07.360 --> 00:02:10.479
And for those, we'll need
two additional facts.

00:02:10.479 --> 00:02:13.020
One is that planar-bounded
two-player constraint

00:02:13.020 --> 00:02:16.210
logic is PSPACE complete
with this crossover gadget.

00:02:16.210 --> 00:02:21.120
We just need the addition
of a choice variable

00:02:21.120 --> 00:02:25.000
with three red edges,
two in, one out.

00:02:25.000 --> 00:02:26.800
This is what we will need.

00:02:26.800 --> 00:02:31.310
And also that we can
make protected ORs,

00:02:31.310 --> 00:02:33.620
an OR where you're guaranteed
at most one of these

00:02:33.620 --> 00:02:37.370
comes in by allowing an
additional gadget which

00:02:37.370 --> 00:02:38.530
is a free edge.

00:02:38.530 --> 00:02:41.120
So only one of our
constructions will use this.

00:02:41.120 --> 00:02:44.770
But in that setting,
we can make a free edge

00:02:44.770 --> 00:02:45.990
and we need the protected OR.

00:02:45.990 --> 00:02:47.880
So they go together well .

00:02:47.880 --> 00:02:52.320
And so this is review
from last class.

00:02:52.320 --> 00:02:55.580
So first real game
we're going to look at

00:02:55.580 --> 00:02:58.790
is called Amazons
from the late '80s

00:02:58.790 --> 00:03:02.250
but became popular in the
common material game theory

00:03:02.250 --> 00:03:05.560
world I think in the
mid-2000s, at least that's

00:03:05.560 --> 00:03:06.840
when I heard about it.

00:03:06.840 --> 00:03:10.320
So the usual game is played
on an 8x8 checkerboard--

00:03:10.320 --> 00:03:13.859
chessboard, I should say--
with four black queens and four

00:03:13.859 --> 00:03:14.400
white queens.

00:03:14.400 --> 00:03:15.820
Those are the Amazons.

00:03:15.820 --> 00:03:18.920
The Amazons, as you may
know, carry bows and arrows.

00:03:18.920 --> 00:03:25.010
So a move in this game is to
take a queen of your color,

00:03:25.010 --> 00:03:26.610
move it in a queen-like way.

00:03:26.610 --> 00:03:31.080
So in this example, we're moving
the clean up to this position.

00:03:31.080 --> 00:03:35.350
And then, you fire an arrow by
another queen move from there.

00:03:35.350 --> 00:03:38.710
So from here, we're
shooting an arrow

00:03:38.710 --> 00:03:42.330
to this position
diagonally visible.

00:03:42.330 --> 00:03:44.430
You're not allowed to
move through other players

00:03:44.430 --> 00:03:45.472
or through arrows.

00:03:45.472 --> 00:03:47.680
And you're not allowed to
shoot through other players

00:03:47.680 --> 00:03:49.050
or through arrows.

00:03:49.050 --> 00:03:52.794
So this the square
is destroyed forever.

00:03:52.794 --> 00:03:54.210
So this is clearly
a bounded game.

00:03:54.210 --> 00:03:56.040
Every move we destroy square.

00:03:56.040 --> 00:03:57.940
You have to do both
of those things,

00:03:57.940 --> 00:04:00.140
move between by
a non-zero amount

00:04:00.140 --> 00:04:02.760
and then shoot an arrow
somewhere other than yourself.

00:04:02.760 --> 00:04:06.530
You're never allowed to
land on a dead square.

00:04:06.530 --> 00:04:07.590
So a typical game.

00:04:07.590 --> 00:04:09.548
After you play it for a
while, it's really fun.

00:04:09.548 --> 00:04:10.380
You should try it.

00:04:10.380 --> 00:04:13.590
We'll end up the situation where
you've partitioned the queens

00:04:13.590 --> 00:04:16.050
into independent components.

00:04:16.050 --> 00:04:18.860
And so then, it's basically
a bunch of Hamiltonian cycle

00:04:18.860 --> 00:04:20.410
problems, or longest path.

00:04:20.410 --> 00:04:21.910
Now, these guys
have to walk around.

00:04:21.910 --> 00:04:24.060
It's a little bit weird, because
you can shoot not exactly where

00:04:24.060 --> 00:04:25.100
you're landing.

00:04:25.100 --> 00:04:27.090
But in particular, you could
shoot where you just came from.

00:04:27.090 --> 00:04:29.180
So if each of these
components-- usually they're

00:04:29.180 --> 00:04:31.590
Hamiltonian or have
a Hamiltonian path--

00:04:31.590 --> 00:04:33.560
and then with the queen moves.

00:04:33.560 --> 00:04:36.640
And then, you just
sum up the areas then,

00:04:36.640 --> 00:04:40.052
and whether white or black
has more area is the winner.

00:04:40.052 --> 00:04:42.510
Because in general, once you
can't move, you lose the game.

00:04:42.510 --> 00:04:45.600
The goal is to move last.

00:04:45.600 --> 00:04:48.120
So in general, your goal is
to partition up the space

00:04:48.120 --> 00:04:50.680
so you have more territory.

00:04:50.680 --> 00:04:55.340
So we're going to prove PSPACE
completeness of this game using

00:04:55.340 --> 00:04:57.220
bounded two-player
constraint logic.

00:05:00.300 --> 00:05:07.270
So here's the basic gadgets, in
particular the idea of a wire.

00:05:07.270 --> 00:05:10.430
We're imagining this is an
upward traveling signal.

00:05:10.430 --> 00:05:14.010
And for it to travel
up-- think of this

00:05:14.010 --> 00:05:15.860
as an edge reversing
from downward

00:05:15.860 --> 00:05:18.520
pointing to upward pointing.

00:05:18.520 --> 00:05:24.170
If the A queen has to move
down and also shoot down,

00:05:24.170 --> 00:05:27.750
so leaving two black squares,
in that situation B can

00:05:27.750 --> 00:05:30.760
move down and shoot down one or
move down two and shoot up one,

00:05:30.760 --> 00:05:32.260
either way consume
these two squares

00:05:32.260 --> 00:05:34.670
but leave two for the next guy.

00:05:34.670 --> 00:05:36.100
This is a parity shift.

00:05:36.100 --> 00:05:39.390
It also works if this guy
moves down, shoots down,

00:05:39.390 --> 00:05:40.480
leaving these two squares.

00:05:40.480 --> 00:05:43.510
Then, B can move down and
shoot diagonally and so on.

00:05:43.510 --> 00:05:44.540
So that's our wire.

00:05:44.540 --> 00:05:45.998
That's how we're
going to propagate

00:05:45.998 --> 00:05:50.090
the signal, because we only
need single-use gadgets you

00:05:50.090 --> 00:05:52.610
can do a turn, A moves
down, shoots down.

00:05:52.610 --> 00:05:54.860
B moves down, shoots down.

00:05:54.860 --> 00:05:57.170
C moves over, shoots diagonally.

00:05:57.170 --> 00:06:01.960
D moves over, shoots
diagonally, and so on.

00:06:01.960 --> 00:06:04.420
Variable gadget,
so this is what we

00:06:04.420 --> 00:06:06.620
had on the bottom
of the construction.

00:06:06.620 --> 00:06:09.882
This is a white or black edge.

00:06:09.882 --> 00:06:12.215
And we'll never have to connect
black edges to anything,

00:06:12.215 --> 00:06:14.200
so they're just hanging out.

00:06:14.200 --> 00:06:17.430
Here, if black moves first
here and obliterates these two

00:06:17.430 --> 00:06:21.600
squares, this wire's dead.

00:06:21.600 --> 00:06:26.370
If white moves first then, the
white can activate the chain.

00:06:26.370 --> 00:06:29.515
So that's going to simulate
the usual setup, where

00:06:29.515 --> 00:06:31.890
white and black are taking
turns, setting their variables

00:06:31.890 --> 00:06:33.060
the way they want them.

00:06:33.060 --> 00:06:36.550
And then, if white can succeed
and satisfy the formula--

00:06:36.550 --> 00:06:38.280
we have to get to
AND and OR gadgets.

00:06:38.280 --> 00:06:42.540
But if white can succeed
and this guy can move down,

00:06:42.540 --> 00:06:48.990
then B can move to this place
and shoot here, and then

00:06:48.990 --> 00:06:51.350
move over here and shoot
into this giant room.

00:06:51.350 --> 00:06:55.990
And then, we'll spend
tons of moves in here.

00:06:55.990 --> 00:06:59.510
And then, come back here,
shoot there, back there,

00:06:59.510 --> 00:07:03.500
shoot there, ther, shoot there,
and get to the other room

00:07:03.500 --> 00:07:07.674
But if this guy does
not move down first,

00:07:07.674 --> 00:07:09.340
this guy-- whichever
way he goes-- he'll

00:07:09.340 --> 00:07:13.880
have to either destroy
the room he is walking to

00:07:13.880 --> 00:07:16.620
or destroy the other room
that he could have gone.

00:07:16.620 --> 00:07:19.030
So you only get
half of the points

00:07:19.030 --> 00:07:20.640
if this is not activated.

00:07:20.640 --> 00:07:22.390
And we're going to set
it up so that black

00:07:22.390 --> 00:07:25.500
has a bunch of other moves and
some other room that's already

00:07:25.500 --> 00:07:26.650
been cut off.

00:07:26.650 --> 00:07:29.350
And it will be roughly
equal to one of these rooms.

00:07:29.350 --> 00:07:33.810
And so only if you get
both of them do you win.

00:07:33.810 --> 00:07:36.230
And because we can't
control which way B goes,

00:07:36.230 --> 00:07:38.757
these two rooms have
to be the same size.

00:07:38.757 --> 00:07:41.340
So you happen to win by a factor
of 2 and the number of moves.

00:07:41.340 --> 00:07:46.980
But that's not essential to
the proof, just for symmetry.

00:07:46.980 --> 00:07:48.380
So those are the basic gadgets.

00:07:48.380 --> 00:07:55.230
Now, we have AND and OR
and SPLIT and CHOICE.

00:07:57.790 --> 00:08:03.790
Usually, in NCL, we
think of AND and SPLIT

00:08:03.790 --> 00:08:05.520
as being the same thing.

00:08:05.520 --> 00:08:08.320
But in this setting, especially
in the bounded situation,

00:08:08.320 --> 00:08:09.840
they're really different.

00:08:09.840 --> 00:08:12.547
Remember, it corresponds
to whether initially

00:08:12.547 --> 00:08:15.130
the red things are pointing in
or the blue things are pointing

00:08:15.130 --> 00:08:18.230
in, red edges or the blue edge.

00:08:18.230 --> 00:08:21.420
And they behave quite
differently in this setting.

00:08:21.420 --> 00:08:24.390
So for the AND gate,
these are the two inputs.

00:08:24.390 --> 00:08:27.270
If both of them move out of
the way, then C can move here,

00:08:27.270 --> 00:08:28.380
shoot here.

00:08:28.380 --> 00:08:32.370
And D can move here
and shoot there.

00:08:32.370 --> 00:08:35.030
And if you only
move one of the two,

00:08:35.030 --> 00:08:36.200
you won't have enough room.

00:08:36.200 --> 00:08:36.824
AUDIENCE: Wait.

00:08:36.824 --> 00:08:37.595
Why?

00:08:37.595 --> 00:08:38.220
PROFESSOR: Why?

00:08:38.220 --> 00:08:41.150
If B moves out of the way,
C can move and shoot here.

00:08:41.150 --> 00:08:44.280
But D only has one one square.

00:08:44.280 --> 00:08:46.410
If A moves out if the
way, C can't move.

00:08:50.590 --> 00:08:55.000
On the other hand, an OR
gadget, these are the two inputs

00:08:55.000 --> 00:08:56.450
and this is the output.

00:08:56.450 --> 00:08:58.710
If either one of these
moves, we sort of already

00:08:58.710 --> 00:08:59.380
have one square.

00:08:59.380 --> 00:09:01.570
We just need a second
square for C to shoot into.

00:09:01.570 --> 00:09:02.659
It could be here or here.

00:09:02.659 --> 00:09:05.075
As long as one of them moves
out of the way, we are happy.

00:09:07.710 --> 00:09:14.080
As a CHOICE gadget, so this
is three blues coming in

00:09:14.080 --> 00:09:17.913
but the orientations
are different.

00:09:24.810 --> 00:09:28.700
So a CHOICE is we have an input
coming up from the bottom.

00:09:28.700 --> 00:09:32.810
And we want to activate one
of the two but only one.

00:09:32.810 --> 00:09:34.830
So that corresponds
to A moving out

00:09:34.830 --> 00:09:36.910
of the way leaving two squares.

00:09:36.910 --> 00:09:40.020
Either B can take it and hit
those two squares or C can

00:09:40.020 --> 00:09:42.460
take it, but only one of them.

00:09:42.460 --> 00:09:44.234
So the same gadget does both.

00:09:44.234 --> 00:09:45.650
That makes sense
because we're not

00:09:45.650 --> 00:09:49.770
really distinguishing between
red and blue very much here.

00:09:49.770 --> 00:09:52.774
SPLIT is a little bit trickier.

00:09:52.774 --> 00:09:53.690
Let's walk through it.

00:09:53.690 --> 00:09:55.840
A moves down.

00:09:55.840 --> 00:09:59.300
B moves over and shoots here.

00:09:59.300 --> 00:10:04.340
Then, C can move down
here and shoot here.

00:10:04.340 --> 00:10:10.960
And then, D can move over
here and shoot there.

00:10:10.960 --> 00:10:13.800
Using our queen
moves, so that leaves

00:10:13.800 --> 00:10:16.480
these four spaces unoccupied.

00:10:16.480 --> 00:10:19.080
Now, E can move down
here and shoot there.

00:10:19.080 --> 00:10:20.610
F can move here and shoot there.

00:10:20.610 --> 00:10:22.140
And now, we've got
the four squares

00:10:22.140 --> 00:10:26.960
necessary to trigger
both H and G.

00:10:26.960 --> 00:10:28.460
So that's a SPLIT.

00:10:28.460 --> 00:10:31.060
And that is Amazons.

00:10:31.060 --> 00:10:33.364
Therefore Amazons
is PSPACE complete.

00:10:33.364 --> 00:10:34.190
Done.

00:10:34.190 --> 00:10:34.911
Question.

00:10:34.911 --> 00:10:36.604
AUDIENCE: What is
CHOICE needed for?

00:10:36.604 --> 00:10:38.770
PROFESSOR: CHOICE is needed
for the crossover gadget

00:10:38.770 --> 00:10:40.910
in particular.

00:10:40.910 --> 00:10:43.252
Next game we'll look
at-- these proofs

00:10:43.252 --> 00:10:44.710
are going to start
to look similar.

00:10:44.710 --> 00:10:46.668
But I think it's helpful
to see a few examples.

00:10:46.668 --> 00:10:47.540
This is Konane.

00:10:47.540 --> 00:10:50.730
It's a very old game-- we
don't know how old-- invented

00:10:50.730 --> 00:10:52.970
by Hawaiian Polynesians.

00:10:52.970 --> 00:10:58.310
First documented in
1778 by Captain Cook.

00:10:58.310 --> 00:11:02.176
And this was a
world championship.

00:11:02.176 --> 00:11:02.675
No.

00:11:02.675 --> 00:11:05.620
This is a regional
championship in 2005

00:11:05.620 --> 00:11:07.350
that I probably lost at.

00:11:07.350 --> 00:11:11.940
But we like to play
it with go stones.

00:11:11.940 --> 00:11:13.590
That's not the
original formulation.

00:11:13.590 --> 00:11:16.360
But you have two colors of
stones on a square grid.

00:11:16.360 --> 00:11:22.050
And it's something like peg
solitaire, but with two colors.

00:11:22.050 --> 00:11:25.277
So let me maybe show
you a bigger image.

00:11:25.277 --> 00:11:26.860
The type of move you
can do, if you're

00:11:26.860 --> 00:11:31.060
white you can jump over a
sequence of black stones.

00:11:31.060 --> 00:11:32.670
You can only jump
over one at a time.

00:11:32.670 --> 00:11:35.437
So if I had two in a row, you
wouldn't be able to jump it.

00:11:35.437 --> 00:11:37.770
And furthermore, you're not
allowed to change directions

00:11:37.770 --> 00:11:38.580
in a single move.

00:11:38.580 --> 00:11:40.130
In a single move,
I could jump over

00:11:40.130 --> 00:11:45.320
any chain of black blank
blank blank things.

00:11:45.320 --> 00:11:46.400
And they are removed.

00:11:46.400 --> 00:11:48.080
I captured them.

00:11:48.080 --> 00:11:50.610
And it has to be
in a straight line.

00:11:50.610 --> 00:11:53.390
So that's the rules.

00:11:53.390 --> 00:11:55.870
And of course, every move
I make I capture somebody,

00:11:55.870 --> 00:11:59.760
so it's a polynomial-bounded
number of moves.

00:11:59.760 --> 00:12:03.920
This is the general
idea for a wire

00:12:03.920 --> 00:12:08.680
is that with white will be
doing most of the action here.

00:12:08.680 --> 00:12:11.580
And so white will
be jumping here.

00:12:11.580 --> 00:12:13.840
At this point, I have
to change directions.

00:12:13.840 --> 00:12:17.890
But luckily after I
obliterate those two pieces,

00:12:17.890 --> 00:12:20.720
black can't do anything to me.

00:12:20.720 --> 00:12:22.880
I'm safe between these
two black squares.

00:12:22.880 --> 00:12:25.590
So black will do something
else, and then white

00:12:25.590 --> 00:12:28.380
is free to start jumping in
the direction they want to.

00:12:31.130 --> 00:12:32.830
That will be critical.

00:12:32.830 --> 00:12:35.280
Here is a variable
where if black moves

00:12:35.280 --> 00:12:38.230
first in this scenario, it
can capture the white thing

00:12:38.230 --> 00:12:40.100
and prevent it from
activating this wire.

00:12:40.100 --> 00:12:43.130
If white moves first, they
can activate the wire.

00:12:43.130 --> 00:12:46.570
So whoever goes there
first sets the variable.

00:12:46.570 --> 00:12:48.870
AUDIENCE: What's the start
configuration for this game?

00:12:48.870 --> 00:12:50.370
PROFESSOR: Oh, in
the original game,

00:12:50.370 --> 00:12:53.980
the whole board is filled
where the color of your pieces

00:12:53.980 --> 00:12:56.110
equal the color of the
square of the checkerboard,

00:12:56.110 --> 00:12:59.650
except for the center
two places are blank.

00:12:59.650 --> 00:13:02.490
But we're not considering
it from the actual initial

00:13:02.490 --> 00:13:03.120
configuration.

00:13:03.120 --> 00:13:06.190
We're considering it from a
half-played configuration.

00:13:06.190 --> 00:13:08.090
Because the original
configuration,

00:13:08.090 --> 00:13:10.770
the answer is the function
of the board size.

00:13:10.770 --> 00:13:13.060
And that's not
enough information

00:13:13.060 --> 00:13:15.060
to be interesting from
a complexity standpoint.

00:13:15.060 --> 00:13:15.230
Yeah?

00:13:15.230 --> 00:13:16.646
AUDIENCE: Do you
have any problems

00:13:16.646 --> 00:13:19.342
that have significant
hardness results for sort

00:13:19.342 --> 00:13:21.907
of the standard start
but generalized?

00:13:21.907 --> 00:13:22.490
PROFESSOR: No.

00:13:22.490 --> 00:13:24.160
In general, none
of those problems

00:13:24.160 --> 00:13:28.370
can be hard in the sense that
we want, because they're sparse.

00:13:28.370 --> 00:13:31.600
They have very few
inputs of a given size,

00:13:31.600 --> 00:13:33.300
so there is no such result.

00:13:33.300 --> 00:13:35.880
Unless you have a
variable initial setup,

00:13:35.880 --> 00:13:38.400
like maybe games where
you-- what do you

00:13:38.400 --> 00:13:40.569
call it-- draft your
deck in the beginning.

00:13:40.569 --> 00:13:42.860
I mean, if you consider that
part of the initial setup,

00:13:42.860 --> 00:13:44.840
then that could be
much more interesting.

00:13:48.100 --> 00:13:48.870
Right.

00:13:48.870 --> 00:13:50.590
Haven't done the
OR and the CHOICE.

00:13:50.590 --> 00:13:55.870
So again if we--
let's do the OR.

00:13:55.870 --> 00:13:58.367
If we are activating from
here, we can just keep going.

00:13:58.367 --> 00:14:00.450
It'd be bad to stop here,
because then black could

00:14:00.450 --> 00:14:01.560
capture us.

00:14:01.560 --> 00:14:02.809
But we can go straight.

00:14:02.809 --> 00:14:04.850
On the other hand, if we
come from this position,

00:14:04.850 --> 00:14:06.810
we killed those two
guys who were safe

00:14:06.810 --> 00:14:09.420
and then we can go up.

00:14:09.420 --> 00:14:14.380
And a CHOICE gadget would
be coming-- the input

00:14:14.380 --> 00:14:16.120
for a CHOICE would be here.

00:14:16.120 --> 00:14:18.120
So you can jump here and
then you have a choice

00:14:18.120 --> 00:14:20.160
whether to go up or down.

00:14:20.160 --> 00:14:24.700
So again, same gadget
does OR and CHOICE.

00:14:24.700 --> 00:14:26.830
And here's one gadget
that does AND, SPLIT,

00:14:26.830 --> 00:14:31.460
and a SHIFT, which is convenient
for various ways to use it.

00:14:31.460 --> 00:14:33.670
But what if what
it really does is

00:14:33.670 --> 00:14:36.910
there's two traversal
paths, input 1 to output 1

00:14:36.910 --> 00:14:38.660
and input 2 to output 2.

00:14:38.660 --> 00:14:40.980
And they have to
happen in that order.

00:14:40.980 --> 00:14:45.417
If you try to activate path
2, you have to stop here.

00:14:45.417 --> 00:14:47.250
I mean, I guess you
could jump here and then

00:14:47.250 --> 00:14:48.500
be captured that way.

00:14:48.500 --> 00:14:51.400
If you stop here, you'll
be captured by that guy.

00:14:51.400 --> 00:14:52.960
So that's bad news.

00:14:52.960 --> 00:14:56.520
But if we first do the input
1 traversal-- this is safe--

00:14:56.520 --> 00:15:00.260
and then go to the output
traversal, this guy's gone.

00:15:00.260 --> 00:15:03.090
And so then we can
do input 2, pause,

00:15:03.090 --> 00:15:05.460
and then go up to output 2.

00:15:05.460 --> 00:15:09.570
So that's what the
gadget does by itself.

00:15:09.570 --> 00:15:13.940
If we ignore what
happens out here,

00:15:13.940 --> 00:15:17.240
then we can think of
this as an AND gate,

00:15:17.240 --> 00:15:21.850
where first this input has
to come in, kill that guy,

00:15:21.850 --> 00:15:26.470
and then go off Neverneverland.

00:15:26.470 --> 00:15:28.640
And then, if the
second input comes in,

00:15:28.640 --> 00:15:29.880
then we activate the output.

00:15:29.880 --> 00:15:31.840
So that would be the
output of the AND gate.

00:15:31.840 --> 00:15:33.390
That's garbage.

00:15:33.390 --> 00:15:35.140
And these are the two inputs.

00:15:35.140 --> 00:15:37.410
Now, there is an issue of
you have to make this one

00:15:37.410 --> 00:15:38.880
trigger before this one.

00:15:38.880 --> 00:15:41.550
But in all these setups,
we have these posits

00:15:41.550 --> 00:15:44.080
where the piece can wait.

00:15:44.080 --> 00:15:46.990
So if we have a turn gadget
right before the input,

00:15:46.990 --> 00:15:49.625
it can just sit there and wait
for the other input to the AND

00:15:49.625 --> 00:15:50.850
to activate.

00:15:50.850 --> 00:15:53.550
And then, this one can go ahead
and activate the second one.

00:15:53.550 --> 00:15:57.040
So we're very
flexible on timing.

00:15:57.040 --> 00:16:00.560
So we can make input 1 go
before input 2 for AND.

00:16:00.560 --> 00:16:06.600
For a SPLIT, we can just have
a white token sitting here

00:16:06.600 --> 00:16:10.130
ready to go in that's
in a safe position.

00:16:10.130 --> 00:16:13.209
And then, once this input
comes in, it gets output there.

00:16:13.209 --> 00:16:15.000
Then, this one can
trigger an output there.

00:16:15.000 --> 00:16:17.810
So we get both of the
outputs for one input.

00:16:17.810 --> 00:16:21.530
And for a SHIFT, we do
both of these things.

00:16:21.530 --> 00:16:23.070
We treat this is garbage.

00:16:23.070 --> 00:16:25.750
And we have a safe
white token here.

00:16:25.750 --> 00:16:28.170
So if this comes in,
then that can go out.

00:16:28.170 --> 00:16:29.460
So we end up shifting by one.

00:16:29.460 --> 00:16:32.870
And that fixes
any parity issues.

00:16:32.870 --> 00:16:34.240
Cool.

00:16:34.240 --> 00:16:37.200
So that's Konane
PSPACE complete.

00:16:37.200 --> 00:16:45.360
AUDIENCE: How do you guarantee
that black doesn't screw you?

00:16:45.360 --> 00:16:48.400
PROFESSOR: By checking
all the cases.

00:16:48.400 --> 00:16:51.410
In general, I mean,
there's a question

00:16:51.410 --> 00:16:55.060
of what black is doing.

00:16:55.060 --> 00:16:56.570
Basically, within
all these gadgets,

00:16:56.570 --> 00:16:59.020
we're preventing black
from doing anything.

00:16:59.020 --> 00:17:03.157
So the main place where we care
about black's motion is here.

00:17:03.157 --> 00:17:05.490
So there's going to be an
initial phase where everyone's

00:17:05.490 --> 00:17:06.240
setting variables.

00:17:06.240 --> 00:17:07.230
We're taking turns.

00:17:07.230 --> 00:17:08.569
And white's going
to set half of them.

00:17:08.569 --> 00:17:09.985
Black's going to
set half of them.

00:17:09.985 --> 00:17:12.980
Their black is screwing you,
but in a controlled fashion.

00:17:12.980 --> 00:17:16.720
After that, there's going
to be a pile of extra moves

00:17:16.720 --> 00:17:18.119
that black can just do.

00:17:18.119 --> 00:17:20.990
And black will always be forced
to do those extra useless

00:17:20.990 --> 00:17:23.300
moves.

00:17:23.300 --> 00:17:25.660
If we happen to satisfy
the final output

00:17:25.660 --> 00:17:28.339
to the overall thing,
then white will

00:17:28.339 --> 00:17:31.254
have a zillion free moves
and then white will win.

00:17:31.254 --> 00:17:31.920
That's the idea.

00:17:31.920 --> 00:17:35.640
But within these
gadgets, as long

00:17:35.640 --> 00:17:37.595
as we don't do
something intelligent

00:17:37.595 --> 00:17:39.720
like going here and then
getting captured by black,

00:17:39.720 --> 00:17:42.120
and therefore destroying
the whole construction.

00:17:42.120 --> 00:17:45.350
Then, white will lose, probably.

00:17:45.350 --> 00:17:47.810
We're always careful to go
to positions that are safe.

00:17:47.810 --> 00:17:50.700
Black cannot jump
us if we're there.

00:17:50.700 --> 00:17:52.610
So by checking all
those cases, you

00:17:52.610 --> 00:17:55.470
can guarantee black
doesn't hurt you.

00:17:55.470 --> 00:17:58.190
I didn't mention what's
black doing when we're not

00:17:58.190 --> 00:18:00.730
allowing it to play at all.

00:18:00.730 --> 00:18:01.230
Cool.

00:18:01.230 --> 00:18:03.740
So that's Konane.

00:18:03.740 --> 00:18:06.080
Next, is a game
called Cross Purposes.

00:18:06.080 --> 00:18:08.540
This is a fairly new
game by Michael Albert

00:18:08.540 --> 00:18:12.820
who's a fun guy in the common
material game theory scene.

00:18:12.820 --> 00:18:17.300
So again we're going
to play with go stones,

00:18:17.300 --> 00:18:19.730
but what you should imagine
is that black stones

00:18:19.730 --> 00:18:22.710
are towers of two blocks.

00:18:22.710 --> 00:18:25.360
And then, you can
push them over.

00:18:25.360 --> 00:18:28.100
So in this case, we took
this tower, pushed it up,

00:18:28.100 --> 00:18:31.006
and so it occupied
those two spots.

00:18:31.006 --> 00:18:32.880
But once it's pushed
over, it's kind of dead.

00:18:32.880 --> 00:18:34.650
So we draw it in white.

00:18:34.650 --> 00:18:37.620
And then, for example, we could
take this tower pop it over

00:18:37.620 --> 00:18:39.790
to the right and get those two.

00:18:39.790 --> 00:18:43.070
Now, to make this a fun
two-player game-- this

00:18:43.070 --> 00:18:45.715
would be a natural
enough solitaire game.

00:18:45.715 --> 00:18:47.090
But to make it a
two-player game,

00:18:47.090 --> 00:18:49.631
we're going to have two players,
one called horizontal, which

00:18:49.631 --> 00:18:54.060
can only do this type of
move, and another player

00:18:54.060 --> 00:18:57.950
called vertical, which can
only do this type of move.

00:18:57.950 --> 00:19:02.400
So what's fun here is that
it's the same black pieces used

00:19:02.400 --> 00:19:04.310
by both players.

00:19:04.310 --> 00:19:06.370
But one of them can
tip them left to right.

00:19:06.370 --> 00:19:09.560
And the other can
tip them up or down.

00:19:09.560 --> 00:19:12.020
But again it's bounded, because
once you top over a tower

00:19:12.020 --> 00:19:12.610
it's dead.

00:19:12.610 --> 00:19:15.370
So this is going to be
PSPACE complete by reduction

00:19:15.370 --> 00:19:18.700
from bounded two-player
constraint logic.

00:19:18.700 --> 00:19:20.400
So some-- question.

00:19:20.400 --> 00:19:22.215
AUDIENCE: What's the
goal of the game?

00:19:22.215 --> 00:19:24.220
PROFESSOR: The goal the
game is to move last.

00:19:24.220 --> 00:19:26.510
If you can't move, you lose.

00:19:26.510 --> 00:19:28.060
And that can be asymmetric.

00:19:28.060 --> 00:19:31.695
Some pieces are only going
to be flippable up or down.

00:19:31.695 --> 00:19:33.070
A lot of games
have that feature.

00:19:33.070 --> 00:19:36.140
It's called normal play,
in fact, it's so common.

00:19:36.140 --> 00:19:38.030
That the last
player to move wins.

00:19:38.030 --> 00:19:40.730
So a wire is going to
look something like this.

00:19:40.730 --> 00:19:43.746
In general, I think vertical
is the player that we're

00:19:43.746 --> 00:19:45.370
rooting for, and
we're trying to decide

00:19:45.370 --> 00:19:47.490
whether vertical can win.

00:19:47.490 --> 00:19:49.432
And we're going to
set up horizontal--

00:19:49.432 --> 00:19:51.890
unlike the previous game--
we're going to set up horizontal

00:19:51.890 --> 00:19:55.470
in a position that it never
has any moves except the one

00:19:55.470 --> 00:19:57.280
that you give it right then.

00:19:57.280 --> 00:20:00.320
So the idea is that as
soon as we move A down,

00:20:00.320 --> 00:20:04.530
then horizontal has a
move, namely the playing B.

00:20:04.530 --> 00:20:06.030
And then, we have
a move and so on.

00:20:06.030 --> 00:20:07.850
So that will trigger.

00:20:07.850 --> 00:20:09.940
That better not
stop at any point.

00:20:09.940 --> 00:20:13.250
We always want to set it up so
when we're switching gadgets,

00:20:13.250 --> 00:20:16.440
it's our turn to move,
because the horizontal player

00:20:16.440 --> 00:20:19.565
will never have
another move to make.

00:20:19.565 --> 00:20:20.940
This is what it
looks like after.

00:20:20.940 --> 00:20:22.356
I mean, things are
just filling in

00:20:22.356 --> 00:20:24.390
if you've partially
filled in this thing.

00:20:24.390 --> 00:20:26.740
Here's how we make a variable.

00:20:26.740 --> 00:20:28.780
So here in the initial
phase of the game,

00:20:28.780 --> 00:20:30.050
horizontal will have moves.

00:20:30.050 --> 00:20:32.540
Horizontal could play this,
filling those two squares,

00:20:32.540 --> 00:20:36.300
preventing us from
playing this wire.

00:20:36.300 --> 00:20:39.390
So whoever goes here first
will claim the thing.

00:20:39.390 --> 00:20:43.055
And if it's vertical, then
it triggers the true value.

00:20:45.900 --> 00:20:47.625
We can also terminate
a wire like this.

00:20:47.625 --> 00:20:49.030
This is always good for us.

00:20:49.030 --> 00:20:53.320
We can just trigger it
whenever we want as vertical.

00:20:53.320 --> 00:20:56.810
So we need that for
free edges, which

00:20:56.810 --> 00:21:00.930
we need for the protected OR.

00:21:00.930 --> 00:21:06.890
So to clarify or to fix what I
said before, for the initial n

00:21:06.890 --> 00:21:09.250
moves, horizontal
and vertical are

00:21:09.250 --> 00:21:13.440
going to exchange variables,
take turns picking them.

00:21:13.440 --> 00:21:15.930
At that point onwards,
horizontal has no moves

00:21:15.930 --> 00:21:18.330
except the one
right after-- we're

00:21:18.330 --> 00:21:21.400
forcing horizontal to
always play the way we want.

00:21:21.400 --> 00:21:24.720
So after this is done, then
as soon as you move this,

00:21:24.720 --> 00:21:26.200
then horizontal
has a unique move.

00:21:26.200 --> 00:21:27.900
So it will cooperate.

00:21:27.900 --> 00:21:32.200
Horizontal has to cooperate
with us to fill in wires.

00:21:32.200 --> 00:21:36.410
So here is a protected OR.

00:21:36.410 --> 00:21:39.415
So if we trigger this, then this
triggers, then this triggers,

00:21:39.415 --> 00:21:42.370
then this triggers, then
that triggers, and so on.

00:21:42.370 --> 00:21:44.220
So that's all good.

00:21:44.220 --> 00:21:51.590
The reason it's a
protected OR-- the trouble

00:21:51.590 --> 00:21:55.890
if we activated this twice, so
first we activate through here,

00:21:55.890 --> 00:21:58.440
and then we activate
here, and then here.

00:21:58.440 --> 00:22:00.980
And then, as vertical,
we move B down.

00:22:00.980 --> 00:22:02.885
Now, horizontal has no move.

00:22:02.885 --> 00:22:07.350
So that would be bad
news, if we sort of waste

00:22:07.350 --> 00:22:09.672
a trigger like that.

00:22:09.672 --> 00:22:11.380
And so that's why we
need a protected OR,

00:22:11.380 --> 00:22:15.680
where only at most one of
the two sides will trigger.

00:22:15.680 --> 00:22:18.014
CHOICE gadget is the same,
but rotated 90 degrees.

00:22:18.014 --> 00:22:20.680
And that makes a big difference,
because horizontal and vertical

00:22:20.680 --> 00:22:21.740
are flipped.

00:22:21.740 --> 00:22:27.120
So input is here.

00:22:27.120 --> 00:22:30.790
So if we trigger this, and
then this, and then this,

00:22:30.790 --> 00:22:31.840
and then this.

00:22:31.840 --> 00:22:33.839
Then, as vertical,
we get to choose

00:22:33.839 --> 00:22:35.880
whether this one activates
or this one activates.

00:22:35.880 --> 00:22:37.796
So it's important to
make it the right player.

00:22:41.110 --> 00:22:46.040
And here's the omega gadget
that does AND, SPLIT, and SHIFT.

00:22:46.040 --> 00:22:51.840
If we try to activate
input 2, these topple over.

00:22:51.840 --> 00:22:53.770
This topples down.

00:22:53.770 --> 00:22:56.020
And now, horizontal
gets a choice.

00:22:56.020 --> 00:22:58.260
And horizontal's going
to be mean and push B

00:22:58.260 --> 00:23:01.941
over and prevent this thing
from activating, because it

00:23:01.941 --> 00:23:04.190
wants to prevent you from
doing whatever you're doing.

00:23:04.190 --> 00:23:06.273
Because eventually, you're
going to get to a place

00:23:06.273 --> 00:23:09.330
where you win, where
you have a single move

00:23:09.330 --> 00:23:13.080
and then horizontal
doesn't have a move.

00:23:13.080 --> 00:23:16.100
So that's in horizontal's
interest to block you.

00:23:16.100 --> 00:23:18.250
But if you first did
all of these toppling,

00:23:18.250 --> 00:23:23.390
topple this down, over down,
over down, over down, over.

00:23:23.390 --> 00:23:25.590
Then, in particular, you
put a white token here

00:23:25.590 --> 00:23:27.630
and so B won't be
able to do that.

00:23:27.630 --> 00:23:30.840
So when you activate these
guys, D will have to go over

00:23:30.840 --> 00:23:33.660
and out you go.

00:23:33.660 --> 00:23:36.410
So and then, it's the
same thing either putting

00:23:36.410 --> 00:23:41.690
a free wire in input 2 and/or
ignoring the output from output

00:23:41.690 --> 00:23:43.920
1, we get AND, SPLIT, and SHIFT.

00:23:46.810 --> 00:23:49.961
And I think that's it
for Cross Purposes.

00:23:49.961 --> 00:23:50.460
Question.

00:23:50.460 --> 00:23:51.960
AUDIENCE: I probably
misinterpreted.

00:23:51.960 --> 00:23:53.400
Did you show TURN gadget?

00:23:53.400 --> 00:23:57.894
PROFESSOR: I maybe did
not show a TURN gadget.

00:23:57.894 --> 00:23:58.810
There's a TURN gadget.

00:23:58.810 --> 00:23:59.310
Good.

00:23:59.310 --> 00:24:00.700
I didn't talk about it.

00:24:00.700 --> 00:24:02.740
It works in the obvious way.

00:24:02.740 --> 00:24:04.940
But, yeah, it is
definitely a little tricky

00:24:04.940 --> 00:24:06.300
to make sure you can do it.

00:24:06.300 --> 00:24:07.620
But it works.

00:24:07.620 --> 00:24:10.844
AUDIENCE: Back to the
normal play condition,

00:24:10.844 --> 00:24:13.360
if you use games different
from the [INAUDIBLE]

00:24:13.360 --> 00:24:17.770
version of the rule set?

00:24:17.770 --> 00:24:19.870
PROFESSOR: In
general, those games

00:24:19.870 --> 00:24:25.560
are different when you
can't move then you win.

00:24:25.560 --> 00:24:27.960
But from a PSPACE
completeness perspective,

00:24:27.960 --> 00:24:28.880
it should be the same.

00:24:28.880 --> 00:24:31.420
It's really whether you are
starting the quantifying

00:24:31.420 --> 00:24:33.580
sequence with an
exists or a for all.

00:24:33.580 --> 00:24:35.740
And both end up with
the class PSPACE.

00:24:35.740 --> 00:24:38.640
So there may be a
way to distinguish.

00:24:38.640 --> 00:24:43.772
But at our level of granularity,
we're not distinguishing.

00:24:43.772 --> 00:24:44.736
Yeah.

00:24:44.736 --> 00:24:46.664
AUDIENCE: Do you know
whether it's PSPACE

00:24:46.664 --> 00:24:52.930
complete for arbitrary setups
with only black starting

00:24:52.930 --> 00:24:53.910
tokens?

00:24:53.910 --> 00:24:54.630
PROFESSOR: Oh.

00:24:54.630 --> 00:24:55.130
I see.

00:24:55.130 --> 00:24:55.672
No obstacles.

00:24:55.672 --> 00:24:57.546
AUDIENCE: It's a more
natural starting place,

00:24:57.546 --> 00:24:58.590
than starting with a--

00:24:58.590 --> 00:24:59.256
PROFESSOR: Yeah.

00:24:59.256 --> 00:25:00.730
That's definitely not known.

00:25:00.730 --> 00:25:04.700
I think it would be cool to
think about only black tokens,

00:25:04.700 --> 00:25:05.680
no initial whites.

00:25:08.310 --> 00:25:09.830
All right.

00:25:09.830 --> 00:25:13.940
So that's all I want
to say about PSPACE.

00:25:13.940 --> 00:25:15.560
I think we're done with PSPACE.

00:25:15.560 --> 00:25:19.870
We first did PSPACE here,
then PSPACE here last class,

00:25:19.870 --> 00:25:22.230
and then PSPACE here.

00:25:22.230 --> 00:25:25.590
So now we're going to move
up to EXPTIME, 2 players,

00:25:25.590 --> 00:25:27.490
unbounded number of moves.

00:25:27.490 --> 00:25:30.035
EXPTIME turns out to
be the right class.

00:25:33.310 --> 00:25:34.233
Oh.

00:25:34.233 --> 00:25:34.733
I lied.

00:25:37.284 --> 00:25:41.280
I have one more PSPACE class,
which I don't have slides for.

00:25:45.180 --> 00:25:48.680
This is a short topic,
but it's a cool one,

00:25:48.680 --> 00:25:52.620
I think something that
deserves more study.

00:25:52.620 --> 00:25:56.160
But at the moment there
are no natural games

00:25:56.160 --> 00:25:57.820
like real-life
games that have been

00:25:57.820 --> 00:26:02.260
shown to fall into this class
or to be complete in this class.

00:26:02.260 --> 00:26:04.050
So this is stochastic games.

00:26:04.050 --> 00:26:08.220
The idea is you're playing
against a random opponent.

00:26:08.220 --> 00:26:16.280
So you have two players, and
one of the players is random.

00:26:16.280 --> 00:26:18.590
So it's hard to identify
with randomness.

00:26:18.590 --> 00:26:20.240
So the other player is you.

00:26:20.240 --> 00:26:22.350
Your goal is to win the game.

00:26:22.350 --> 00:26:25.430
And you know that your player's
just flipping a coin every time

00:26:25.430 --> 00:26:27.130
and playing randomly,
say uniformly

00:26:27.130 --> 00:26:31.970
or some distribution
that's known to you.

00:26:31.970 --> 00:26:36.050
Think of games where you're
rolling dice, or drawing cards,

00:26:36.050 --> 00:26:38.790
or there's some random
aspect to the game.

00:26:38.790 --> 00:26:40.910
How hard are these games?

00:26:40.910 --> 00:26:44.700
Well, what's been studied--
this is a [INAUDIBLE] paper--

00:26:44.700 --> 00:26:48.870
is for bounded two-player
stochastic games.

00:26:48.870 --> 00:26:50.070
The answer is PSPACE again.

00:26:55.960 --> 00:27:02.160
So, for example, here's a game,
a formula game, stochastic SAT.

00:27:02.160 --> 00:27:04.320
We want to know is
there a move such

00:27:04.320 --> 00:27:07.790
that for a randomly chosen
move-- I like this notation.

00:27:07.790 --> 00:27:09.530
We have exist and for all.

00:27:09.530 --> 00:27:13.170
Backwards R is a
random quantifier.

00:27:13.170 --> 00:27:17.210
There exists an x3
such that a random x4,

00:27:17.210 --> 00:27:22.580
so this is uniform random over
0 and 1, the binary choice 01.

00:27:22.580 --> 00:27:26.200
We want the probability--
this gives a distribution.

00:27:26.200 --> 00:27:28.450
We want the probability of
the formula being satisfied

00:27:28.450 --> 00:27:30.014
being greater than a half.

00:27:30.014 --> 00:27:32.680
I'm guessing you could pump that
up to be with high probability.

00:27:32.680 --> 00:27:35.640
But just deciding
whether you could

00:27:35.640 --> 00:27:40.360
win by probability strictly more
than half, is PSPACE complete.

00:27:42.960 --> 00:27:44.205
So this is cool.

00:27:44.205 --> 00:27:46.680
And to me intuitively
randomness should be weaker

00:27:46.680 --> 00:27:49.010
than an adversarial
player, where

00:27:49.010 --> 00:27:50.460
you replace these with for all.

00:27:53.550 --> 00:27:56.820
But it turns out they behave
roughly the same essentially

00:27:56.820 --> 00:27:58.800
by a probability
amplification argument.

00:27:58.800 --> 00:28:01.500
It's a little too
detailed to go into here.

00:28:01.500 --> 00:28:03.560
And so far, there
are no reductions

00:28:03.560 --> 00:28:05.867
from this to what I
would call natural games.

00:28:05.867 --> 00:28:07.450
There are a few
examples in the paper,

00:28:07.450 --> 00:28:11.590
but none around rolling dice.

00:28:11.590 --> 00:28:14.540
I would love to apply this
to like playing Tetris,

00:28:14.540 --> 00:28:17.400
or in the paper they
mention backgammon

00:28:17.400 --> 00:28:19.420
as a candidate,
something like that,

00:28:19.420 --> 00:28:21.700
where you'd like to
get PSPACE completeness

00:28:21.700 --> 00:28:24.640
in a bounded setting.

00:28:24.640 --> 00:28:28.760
So throwing that out there is an
interesting direction to study,

00:28:28.760 --> 00:28:32.190
but I'll end it there.

00:28:32.190 --> 00:28:36.650
Now, we can go to EXPTIME,
two players, unbounded game,

00:28:36.650 --> 00:28:40.092
adversarial player,
no randomness.

00:28:40.092 --> 00:28:41.740
And we get EXPTIME completeness.

00:29:00.370 --> 00:29:02.570
So we're going to start
out with-- I guess,

00:29:02.570 --> 00:29:05.870
similar to what we do it down
here-- I'm going to start

00:29:05.870 --> 00:29:09.670
with some formula games
which are EXPTIME complete

00:29:09.670 --> 00:29:12.120
and then some graph games
that are EXPTIME complete,

00:29:12.120 --> 00:29:14.940
then constraint logic game
which is EXPTIME complete.

00:29:14.940 --> 00:29:18.340
And along the way will prove
something some hardness.

00:29:18.340 --> 00:29:20.730
There are fewer results here,
in general, I would say.

00:29:20.730 --> 00:29:22.950
In particular, I don't
have a good example

00:29:22.950 --> 00:29:27.586
of using constraint logic
to prove a fun game hard,

00:29:27.586 --> 00:29:28.710
though they probably exist.

00:29:28.710 --> 00:29:30.960
We just haven't
gotten there yet.

00:29:30.960 --> 00:29:34.530
So it's more open problems.

00:29:34.530 --> 00:29:38.290
But there are a lot of cool
base problems out there.

00:29:38.290 --> 00:29:42.360
And this field started by a
paper by Stockmeyer and Chandra

00:29:42.360 --> 00:29:44.689
in 1979.

00:29:44.689 --> 00:29:46.480
And it's been the basis
for pretty much all

00:29:46.480 --> 00:29:48.180
EXPTIME hardness proofs.

00:29:48.180 --> 00:29:50.020
EXPTIME hardness is
really cool, because it

00:29:50.020 --> 00:29:53.270
implies exponential time.

00:29:53.270 --> 00:29:56.490
Any problems EXPTIME hard
cannot be solved faster than

00:29:56.490 --> 00:29:58.020
exponential time.

00:29:58.020 --> 00:30:00.170
Whereas all these
other classes, we

00:30:00.170 --> 00:30:04.090
need to assume P does not equal
NP or P is not equal to PSPACE.

00:30:04.090 --> 00:30:06.600
P we know does
not equal EXPTIME.

00:30:06.600 --> 00:30:08.880
So these games require
exponential time.

00:30:12.219 --> 00:30:15.570
It's kind of fun.

00:30:15.570 --> 00:30:17.870
And I'm pretty sure the first
results in this category

00:30:17.870 --> 00:30:20.218
were these games.

00:30:20.218 --> 00:30:22.890
So it's power of games.

00:30:29.500 --> 00:30:32.160
So in general, we're going
to have some formula, maybe

00:30:32.160 --> 00:30:34.600
a couple formulas.

00:30:34.600 --> 00:30:36.944
But definitely we have
a variable assignment.

00:30:36.944 --> 00:30:38.360
And the state of
the game is going

00:30:38.360 --> 00:30:39.901
to be a variable
assignment and who's

00:30:39.901 --> 00:30:45.820
going to move next, player 1
or player 2, black or white.

00:30:45.820 --> 00:30:49.050
Again, we'll use that notation.

00:30:49.050 --> 00:30:51.647
And we're going to start
with some variable arbitrary

00:30:51.647 --> 00:30:52.480
variable assignment.

00:30:52.480 --> 00:30:55.820
That's part of the initial state
of the game, the board if you

00:30:55.820 --> 00:30:56.940
will.

00:30:56.940 --> 00:31:04.180
And in general, you can
set variables to 0 or 1

00:31:04.180 --> 00:31:05.275
as many times as you like.

00:31:07.800 --> 00:31:11.070
That's what distinguishes
this from bounded games.

00:31:11.070 --> 00:31:14.925
And all of these games
are going to be partisan,

00:31:14.925 --> 00:31:18.859
a term we used last
class, so meaning

00:31:18.859 --> 00:31:20.775
we're going to have black
and white variables.

00:31:26.780 --> 00:31:33.295
And I'm going to
cheat a little bit.

00:31:33.295 --> 00:31:34.920
There's going to be
one variable that's

00:31:34.920 --> 00:31:37.180
black and white, but
only in one of the games.

00:31:37.180 --> 00:31:38.744
So we'll get there.

00:31:38.744 --> 00:31:40.910
So black player can only
change the black variables.

00:31:40.910 --> 00:31:43.118
The white player can only
change the white variables,

00:31:43.118 --> 00:31:44.940
except for how I'm
going to cheat.

00:31:44.940 --> 00:31:47.757
So let's start.

00:31:47.757 --> 00:31:49.340
These games are very
creatively named.

00:31:49.340 --> 00:31:51.894
First one's called G1.

00:31:51.894 --> 00:31:53.810
And it's amazing how
consistent the literature

00:31:53.810 --> 00:31:57.020
is about the naming
of these games.

00:31:57.020 --> 00:32:01.674
So in G1, I move my
player is to set all

00:32:01.674 --> 00:32:02.840
the variables of your color.

00:32:05.940 --> 00:32:09.140
So if you're white, you're going
to set all the white variables.

00:32:09.140 --> 00:32:11.500
If black, you're going to
set all black variables.

00:32:11.500 --> 00:32:14.140
And set here means you get to
choose whether it's 0 or 1.

00:32:14.140 --> 00:32:16.710
So you're just going to
completely rewrite all

00:32:16.710 --> 00:32:18.730
of the variables of your color.

00:32:18.730 --> 00:32:20.090
And then, here's the cheat.

00:32:20.090 --> 00:32:23.070
We're also going to have
a single variable that's

00:32:23.070 --> 00:32:24.440
shared between black and white.

00:32:27.470 --> 00:32:29.000
Call it t.

00:32:29.000 --> 00:32:34.870
And it's going to be 0 if
it's a player 2's move,

00:32:34.870 --> 00:32:36.690
1 if it's player 1's move.

00:32:36.690 --> 00:32:38.240
I mean, it doesn't
really matter.

00:32:38.240 --> 00:32:41.580
But I guess 1 and 1 is nice.

00:32:41.580 --> 00:32:42.720
So that's the moves.

00:32:42.720 --> 00:32:45.040
What's the goal of the game?

00:32:45.040 --> 00:32:56.990
You're going to lose the
game if, by making your move,

00:32:56.990 --> 00:33:02.433
you satisfy a common between
the two players 4DNF formula.

00:33:09.132 --> 00:33:10.590
So there's one
formula in the game.

00:33:10.590 --> 00:33:13.492
It's DNF, which is very
simple to think about.

00:33:13.492 --> 00:33:14.700
It's just a bunch of options.

00:33:14.700 --> 00:33:15.870
If this happens, you lose.

00:33:15.870 --> 00:33:16.800
If this happens, you lose.

00:33:16.800 --> 00:33:17.883
If this happens, you lose.

00:33:17.883 --> 00:33:19.580
It's an OR with
various conditions.

00:33:19.580 --> 00:33:21.340
So you want to
move in such a way

00:33:21.340 --> 00:33:24.612
that you do not satisfy
that formula every time.

00:33:24.612 --> 00:33:26.820
And in each move, you can
rewrite all your variables.

00:33:26.820 --> 00:33:29.500
But this formula
does involve t, which

00:33:29.500 --> 00:33:32.220
lets you care about
who's turn it was.

00:33:32.220 --> 00:33:34.570
So that's cool, very clean.

00:33:34.570 --> 00:33:37.180
I mean, the players have
a lot of power here.

00:33:37.180 --> 00:33:41.135
This is the first
game proved hard.

00:33:41.135 --> 00:33:43.260
A little tricky to work
with, because in most games

00:33:43.260 --> 00:33:45.611
you can't set all the
variables at once.

00:33:45.611 --> 00:33:47.860
Generally, you're only setting
one variable at a time.

00:33:47.860 --> 00:33:49.443
So all the other
games are going to be

00:33:49.443 --> 00:33:52.840
setting one variable at a time.

00:33:52.840 --> 00:33:54.900
At this point,
we're just defining.

00:33:54.900 --> 00:33:59.170
Then, we'll use these games
to prove some hardness.

00:33:59.170 --> 00:34:05.090
G2, the next game, is
a move was going to be

00:34:05.090 --> 00:34:06.870
set one variable of your color.

00:34:12.980 --> 00:34:15.949
So in particular, if you set the
variable to its original value,

00:34:15.949 --> 00:34:17.030
that's like passing.

00:34:17.030 --> 00:34:18.900
So passing is
allowed in this game.

00:34:18.900 --> 00:34:20.480
Passing is also allowed here.

00:34:20.480 --> 00:34:22.389
You could not change
any of the variables.

00:34:22.389 --> 00:34:23.639
You wouldn't win in that case.

00:34:23.639 --> 00:34:26.810
You only win if your
opponent loses in this setup.

00:34:26.810 --> 00:34:31.171
When the question
is can you win.

00:34:31.171 --> 00:34:33.254
In this case, we're going
to have a win condition.

00:34:48.350 --> 00:34:49.960
In this case, white
and black have

00:34:49.960 --> 00:34:52.239
their own winning formulas.

00:34:52.239 --> 00:34:56.580
They're in 12DNF, still
DNF but a little bigger.

00:34:56.580 --> 00:35:00.460
And if you satisfy your formula
at the end of your turn,

00:35:00.460 --> 00:35:03.370
you win and vice versa.

00:35:03.370 --> 00:35:06.970
And move is just change
one variable at a time.

00:35:06.970 --> 00:35:10.980
So that's a very useful game.

00:35:10.980 --> 00:35:12.075
Next is G3.

00:35:15.160 --> 00:35:18.490
A slight variation
to G3, we're going

00:35:18.490 --> 00:35:22.530
to flip one variable
of your color.

00:35:27.670 --> 00:35:47.515
And then, we're going to lose if
you satisfy your 12DNF formula.

00:35:53.367 --> 00:35:54.450
One thing to keep in mind.

00:35:54.450 --> 00:35:56.120
Losing and winning
are quite different,

00:35:56.120 --> 00:35:58.550
because losing is essentially
negating the formula, which

00:35:58.550 --> 00:36:00.140
turns DNF into DNF.

00:36:00.140 --> 00:36:01.640
So you can think
of this as winning.

00:36:01.640 --> 00:36:03.515
In the CNF condition,
you could think of this

00:36:03.515 --> 00:36:04.910
as losing in a DNF condition.

00:36:04.910 --> 00:36:07.160
But they're not interchangeable.

00:36:07.160 --> 00:36:09.740
So here we flipped
between DNF and DNF.

00:36:09.740 --> 00:36:11.830
But we've also changed
the definition of a move.

00:36:11.830 --> 00:36:14.070
A flip, you're not
allowed to pass.

00:36:14.070 --> 00:36:17.120
You must change a variable
to its opposite value.

00:36:17.120 --> 00:36:19.286
Here, we're allowed
to just pass.

00:36:19.286 --> 00:36:21.160
So we changed the move
definition and the win

00:36:21.160 --> 00:36:22.210
condition.

00:36:22.210 --> 00:36:23.260
That is also hard.

00:36:23.260 --> 00:36:24.760
This is a common one.

00:36:24.760 --> 00:36:27.810
I would say most EXPTIME
hardness proofs use this one.

00:36:30.870 --> 00:36:31.370
G4.

00:36:38.290 --> 00:36:39.630
Move is going to be like this.

00:36:39.630 --> 00:36:42.130
You can set one
variable of your color.

00:36:46.270 --> 00:36:50.000
And here, we're going to
have a common win condition.

00:36:50.000 --> 00:36:51.710
This is nice.

00:36:51.710 --> 00:37:04.500
You win if satisfy a
common 12DNF formula.

00:37:04.500 --> 00:37:05.230
Whoops.

00:37:05.230 --> 00:37:07.146
13DNF.

00:37:07.146 --> 00:37:08.100
We need a little more.

00:37:11.440 --> 00:37:14.480
So every move,
we're both checking

00:37:14.480 --> 00:37:16.200
the same formula in this case.

00:37:16.200 --> 00:37:17.697
And here, the set
happens to win.

00:37:17.697 --> 00:37:18.780
So it's a variation of G2.

00:37:21.940 --> 00:37:23.680
G5 does not exist.

00:37:23.680 --> 00:37:28.400
G6-- there is a G5 in
the paper, but it's

00:37:28.400 --> 00:37:30.376
a generalization of G6.

00:37:30.376 --> 00:37:33.292
So I'll tell you
what is in a second.

00:37:33.292 --> 00:37:35.130
Not important.

00:37:35.130 --> 00:37:39.140
So G6, same thing for the move.

00:37:39.140 --> 00:37:45.120
You set one of your variables
to whatever you want.

00:37:45.120 --> 00:37:47.560
But we're going to make
it asymmetric in the sense

00:37:47.560 --> 00:37:52.040
that-- and this will be very
helpful for constraint logic--

00:37:52.040 --> 00:37:56.120
player 1 wins-- player 1 is
the one that we care about.

00:37:56.120 --> 00:38:01.680
We're trying to decide whether
they win-- if anyone satisfies

00:38:01.680 --> 00:38:02.660
a particular formula.

00:38:18.050 --> 00:38:19.275
So there's one CNF formula.

00:38:19.275 --> 00:38:21.740
If it's ever satisfied,
player 1 wins.

00:38:21.740 --> 00:38:24.560
If it's never satisfied,
you get a tie.

00:38:24.560 --> 00:38:27.800
And we want to know whether
player 1 can force a win.

00:38:27.800 --> 00:38:30.660
So this is very compatible
with this sort of thing

00:38:30.660 --> 00:38:33.670
we were doing before
with it was the game

00:38:33.670 --> 00:38:36.600
problem from last class, but in
particular the constraint logic

00:38:36.600 --> 00:38:37.230
games.

00:38:37.230 --> 00:38:39.280
So we'll use G6 for
constraint logic.

00:38:39.280 --> 00:38:40.930
G3 is most other proofs.

00:38:45.200 --> 00:38:49.430
So these are all EXPTIME
complete formula games.

00:38:49.430 --> 00:38:49.930
Yeah?

00:38:49.930 --> 00:38:49.980
AUDIENCE: All right.

00:38:49.980 --> 00:38:51.730
I'm a know; little
confused about G1.

00:38:51.730 --> 00:38:54.430
So I can pass by just setting
down any of my variables,

00:38:54.430 --> 00:38:55.345
right?

00:38:55.345 --> 00:38:55.970
PROFESSOR: Yes.

00:38:55.970 --> 00:38:57.678
AUDIENCE: So then,
how could I ever lose?

00:38:57.678 --> 00:38:58.324
Because if--

00:38:58.324 --> 00:39:02.276
AUDIENCE: You can lose if
the turn variable changed

00:39:02.276 --> 00:39:05.687
satisfies the [INAUDIBLE].

00:39:05.687 --> 00:39:06.228
AUDIENCE: Oh.

00:39:06.228 --> 00:39:06.728
Yeah.

00:39:06.728 --> 00:39:07.710
[INTERPOSING VOICES]

00:39:07.710 --> 00:39:08.700
AUDIENCE: Sorry.

00:39:08.700 --> 00:39:12.599
PROFESSOR: Well, it changes
every time so, yeah, right.

00:39:12.599 --> 00:39:14.890
I think you could set your
variables in such a way when

00:39:14.890 --> 00:39:17.610
it's the opponents turn,
no matter what they do,

00:39:17.610 --> 00:39:21.920
the formula becomes
satisfied and then they lose.

00:39:21.920 --> 00:39:22.772
Yeah.

00:39:22.772 --> 00:39:23.597
Good.

00:39:23.597 --> 00:39:25.680
AUDIENCE: But then it
became satisfied on my turn.

00:39:25.680 --> 00:39:26.400
Sorry.

00:39:26.400 --> 00:39:28.260
PROFESSOR: But t was
a different value.

00:39:28.260 --> 00:39:32.810
So when it's your turn, you
set t to 0 or set t to 1.

00:39:32.810 --> 00:39:35.050
And so then, maybe the
formula's not satisfied.

00:39:35.050 --> 00:39:37.260
When it's the opponents
turn, even if they pass,

00:39:37.260 --> 00:39:38.720
t is set to 0.

00:39:38.720 --> 00:39:40.619
Yes. t is part of the formula.

00:39:40.619 --> 00:39:42.118
AUDIENCE: Where
does the 12 come up?

00:39:42.118 --> 00:39:43.559
Is that from the previous?

00:39:43.559 --> 00:39:45.600
PROFESSOR: I think it's
from the previous result.

00:39:45.600 --> 00:39:46.099
Yeah.

00:39:46.099 --> 00:39:47.470
Didn't we have an 11 or 12?

00:39:47.470 --> 00:39:48.350
AUDIENCE: It was 12.

00:39:48.350 --> 00:39:49.160
PROFESSOR: Yeah.

00:39:49.160 --> 00:39:51.720
All right.

00:39:51.720 --> 00:39:55.510
In case, you prefer
real games, as I do.

00:39:55.510 --> 00:39:58.460
Here is a physical
instantiation--

00:39:58.460 --> 00:40:00.020
it could be many of the games.

00:40:00.020 --> 00:40:03.470
The one they chose
to highlight was G4.

00:40:03.470 --> 00:40:05.240
So this is a game called Peek.

00:40:05.240 --> 00:40:08.790
And that name has
been reappropriated

00:40:08.790 --> 00:40:11.850
for many other games, which
we'll talk about in a moment.

00:40:11.850 --> 00:40:14.130
But the idea is you
have a bunch of trays.

00:40:14.130 --> 00:40:16.410
Each tray has a
bunch of holes in it.

00:40:16.410 --> 00:40:18.820
Everybody knows where
all the holes are.

00:40:18.820 --> 00:40:20.520
Each tray has
exactly two positions

00:40:20.520 --> 00:40:22.970
in all the way and
out all the way.

00:40:22.970 --> 00:40:25.240
It's like here.

00:40:25.240 --> 00:40:31.290
And there are white
trays and black trays.

00:40:31.290 --> 00:40:35.390
So G4, white player can take any
of the trays of their variable,

00:40:35.390 --> 00:40:37.722
and if they want to,
toggle its state.

00:40:37.722 --> 00:40:39.930
They can either push it in
or pull it out or leave it

00:40:39.930 --> 00:40:42.020
as it is.

00:40:42.020 --> 00:40:47.020
And then, you're going to
win if, viewed from above,

00:40:47.020 --> 00:40:50.131
there's a hole that sees all
the way down to the ground.

00:40:50.131 --> 00:40:51.630
So you could put
something red here.

00:40:51.630 --> 00:40:55.640
And if you see red at
the top, then you've

00:40:55.640 --> 00:40:57.134
satisfied the DNF formula.

00:40:57.134 --> 00:40:58.300
It's common between the two.

00:40:58.300 --> 00:40:59.790
So the first player
to make a move

00:40:59.790 --> 00:41:01.660
where you could see a
hole the way through,

00:41:01.660 --> 00:41:03.880
that is expressing DNF formula.

00:41:03.880 --> 00:41:05.850
So that's kind of a
fun way, geometric way,

00:41:05.850 --> 00:41:07.715
to think about these games.

00:41:07.715 --> 00:41:09.590
And you could adapt it
to all of these games,

00:41:09.590 --> 00:41:12.320
just with slightly
different geometric setups.

00:41:12.320 --> 00:41:13.830
We'll see one in a little bit.

00:41:19.080 --> 00:41:20.230
Cool.

00:41:20.230 --> 00:41:22.550
I have here the next
thing to mention

00:41:22.550 --> 00:41:25.250
is why are all these
games in EXPTIME.

00:41:25.250 --> 00:41:28.070
I think that's
worth talking about.

00:41:33.330 --> 00:41:36.540
The idea is pretty simple.

00:41:36.540 --> 00:41:39.290
All these games-- I mean,
you can represent a state

00:41:39.290 --> 00:41:41.910
in a polynomial number of bits.

00:41:41.910 --> 00:41:45.080
It's just the current setting
of the variables and maybe

00:41:45.080 --> 00:41:47.220
whose turn it is.

00:41:47.220 --> 00:41:49.030
Therefore, there are
an exponential number

00:41:49.030 --> 00:41:51.170
of possible states.

00:41:51.170 --> 00:41:56.370
And the approach is basically
to build the entire state graph

00:41:56.370 --> 00:42:01.320
and then rank for each
position whether it's

00:42:01.320 --> 00:42:03.900
a win for one player or a
win for the other player.

00:42:03.900 --> 00:42:05.580
And I think the
easiest way to think

00:42:05.580 --> 00:42:08.370
about this is you start
with all the configurations

00:42:08.370 --> 00:42:11.570
that satisfy the win condition.

00:42:11.570 --> 00:42:13.760
You call those
mate-in-0 positions.

00:42:13.760 --> 00:42:23.540
And then, from there
in exponential time

00:42:23.540 --> 00:42:27.450
you can compute, find
all of the moves, where

00:42:27.450 --> 00:42:30.380
all the places where you can
make a move in any response

00:42:30.380 --> 00:42:31.920
lead you to a win position.

00:42:31.920 --> 00:42:34.040
And those are the
mate-in-1 positions.

00:42:34.040 --> 00:42:38.520
Or in two ply, one
move, one pair of moves.

00:42:38.520 --> 00:42:41.650
And so on and so forth.

00:42:41.650 --> 00:42:44.300
And so then, at
most you are going

00:42:44.300 --> 00:42:47.570
to be mate in exponential,
because they're only

00:42:47.570 --> 00:42:48.770
exponentially many states.

00:42:48.770 --> 00:42:51.100
So the longest mate path
is going to be exponential.

00:42:51.100 --> 00:42:58.850
So you can do like 4k equals 0
to the total number of states,

00:42:58.850 --> 00:43:04.730
which is an exponential
compute mate-in-k.

00:43:08.310 --> 00:43:11.750
And then, you've characterized
the whole state space

00:43:11.750 --> 00:43:14.030
in nearly exponential time.

00:43:14.030 --> 00:43:16.080
And now you know which
ones are winning states.

00:43:16.080 --> 00:43:18.410
And then, you check whether
yours is one of them.

00:43:18.410 --> 00:43:20.460
So there's probably
other ways to do it.

00:43:20.460 --> 00:43:22.874
You could probably start from
your initial configuration.

00:43:22.874 --> 00:43:25.290
But this makes it clear that
it's at most exponential time

00:43:25.290 --> 00:43:27.360
that you'll be spending.

00:43:27.360 --> 00:43:29.944
Not polynomial space, because
we're building the entire graph

00:43:29.944 --> 00:43:30.860
here for this to work.

00:43:30.860 --> 00:43:34.080
We have to remember for all
the states that we visited,

00:43:34.080 --> 00:43:37.354
so we can check for duplicates.

00:43:37.354 --> 00:43:39.770
So that's intuitively why we're
an exponential time bigger

00:43:39.770 --> 00:43:41.877
than PSPACE, assuming
PSPACE does not equal

00:43:41.877 --> 00:43:42.960
EXPTIME, which we believe.

00:43:47.880 --> 00:43:49.150
Cool.

00:43:49.150 --> 00:43:51.845
So let's do some
graph games next.

00:43:54.730 --> 00:43:58.100
I have two games to mention
and a proof for one of them.

00:44:13.280 --> 00:44:19.260
First game is based
on Hamiltonian cycle.

00:44:19.260 --> 00:44:21.010
So this is a funny kind of game.

00:44:25.335 --> 00:44:27.960
And the claim is that you can do
this for a lot of different NP

00:44:27.960 --> 00:44:28.790
complete problems.

00:44:28.790 --> 00:44:31.690
But in general, we have a graph.

00:44:31.690 --> 00:44:34.610
Every edge of the graph
is either black or white.

00:44:34.610 --> 00:44:37.085
And black player can
only play black edges.

00:44:37.085 --> 00:44:38.710
White player can only
play black edges.

00:44:38.710 --> 00:44:43.830
In addition, every edge
either in or out, in the graph

00:44:43.830 --> 00:44:47.490
or currently out of the graph.

00:44:47.490 --> 00:44:53.030
And that's what these variables
are going to correspond to.

00:44:53.030 --> 00:44:56.370
I mean, we're going to convert
into a corresponding game.

00:44:56.370 --> 00:45:01.520
In this case, it's going
to be a G6 style game.

00:45:01.520 --> 00:45:08.100
So the winning condition
is that the set of in edges

00:45:08.100 --> 00:45:11.910
form a Hamiltonian
cycle in the graph.

00:45:11.910 --> 00:45:14.330
So you could think in
means in the cycle,

00:45:14.330 --> 00:45:16.500
out means not in the cycle.

00:45:16.500 --> 00:45:20.210
If we ever get to a
state where the in edges

00:45:20.210 --> 00:45:22.640
form a Hamiltonian
cycle, player 1 wins.

00:45:22.640 --> 00:45:25.390
Player 2's goal is
to try to avoid that.

00:45:25.390 --> 00:45:27.690
Player 2 can only
control the black edges.

00:45:27.690 --> 00:45:29.770
Player 1 can only
control the white edges.

00:45:29.770 --> 00:45:33.420
At the end of each turn, you
can change, if you want to,

00:45:33.420 --> 00:45:36.060
one of the edges
between in and out

00:45:36.060 --> 00:45:38.780
and one of the
edges of your color.

00:45:38.780 --> 00:45:43.685
So I'm just going to leave it at
that, because the proof is not

00:45:43.685 --> 00:45:44.560
terribly interesting.

00:45:47.340 --> 00:45:51.310
No gadgets, but
this next game is

00:45:51.310 --> 00:45:54.810
I think a lot more fun,
more surprisingly hard.

00:45:54.810 --> 00:46:00.650
And it has a nice clean
reduction also from G3.

00:46:00.650 --> 00:46:01.565
So what's the game?

00:46:05.060 --> 00:46:09.325
We are given three graphs
on the same vertices.

00:46:12.590 --> 00:46:17.450
So really you can think of this
as a three-edge colored graph.

00:46:17.450 --> 00:46:20.040
There's the red graph, the
blue graph, the green graph,

00:46:20.040 --> 00:46:22.090
same set of vertices.

00:46:22.090 --> 00:46:27.350
And we are going to
have tokens on vertices.

00:46:30.100 --> 00:46:33.380
And we're going to have
at most one per vertex.

00:46:36.170 --> 00:46:37.965
There are white tokens
and black tokens.

00:46:40.610 --> 00:46:46.710
A move by a player
is going to, call it,

00:46:46.710 --> 00:47:06.970
slide a token, exactly one of
them, of your color along path

00:47:06.970 --> 00:47:08.030
in one of the graphs.

00:47:10.374 --> 00:47:11.290
There's three of them.

00:47:19.770 --> 00:47:23.030
And that slide has to
satisfy a few conditions.

00:47:25.780 --> 00:47:29.140
One condition which is
that the target vertex

00:47:29.140 --> 00:47:33.030
you get to and all intermediate
vertices that you follow

00:47:33.030 --> 00:47:37.200
along the path must be empty.

00:47:41.290 --> 00:47:42.415
They should have no tokens.

00:47:47.640 --> 00:47:49.900
So you pick up any
token of your color--

00:47:49.900 --> 00:47:51.970
you pick a color
red, green, or blue--

00:47:51.970 --> 00:47:54.830
and you follow a red path
or you follow a green path

00:47:54.830 --> 00:47:56.450
or you follow a blue path.

00:47:56.450 --> 00:47:58.990
As long as that path doesn't
hit any other tokens,

00:47:58.990 --> 00:48:01.300
then you drop your
token, erase it

00:48:01.300 --> 00:48:03.290
from where it was
originally, and you

00:48:03.290 --> 00:48:05.397
keep making moves like that.

00:48:05.397 --> 00:48:06.605
What about the win condition?

00:48:10.860 --> 00:48:14.100
We look at a player-- I'm going
to come the players 1 and 2.

00:48:14.100 --> 00:48:27.920
Player i will win if they
get one of their tokens

00:48:27.920 --> 00:48:32.500
to a node in the win set WI.

00:48:32.500 --> 00:48:36.250
So also we're going to color
the nodes as winning for white

00:48:36.250 --> 00:48:38.560
or winning for black.

00:48:38.560 --> 00:48:42.430
And if you ever get a token to
a winning spot for your color,

00:48:42.430 --> 00:48:43.000
games over.

00:48:43.000 --> 00:48:45.300
You win.

00:48:45.300 --> 00:48:48.190
So this is a pretty
natural token-sliding game.

00:48:48.190 --> 00:48:50.500
As EXPTIME complete, very hard.

00:48:53.020 --> 00:48:56.850
And this one we're
going to proof.

00:48:56.850 --> 00:48:58.880
So this is a variable gadget.

00:49:01.960 --> 00:49:03.547
So we're going to
reduce from G3.

00:49:03.547 --> 00:49:04.380
I think I said that.

00:49:04.380 --> 00:49:04.900
This one.

00:49:04.900 --> 00:49:08.040
So G3, a move
corresponds to you're

00:49:08.040 --> 00:49:10.980
forced to flip a
variable of your color.

00:49:10.980 --> 00:49:14.120
Although we could switch
that to the other version.

00:49:14.120 --> 00:49:20.060
And you're going to lose the
game if you satisfy your DNF

00:49:20.060 --> 00:49:20.710
formula.

00:49:20.710 --> 00:49:25.050
So there's lots of edges here.

00:49:25.050 --> 00:49:29.475
But in particular, there's
solid edges, dashed edges,

00:49:29.475 --> 00:49:30.350
and the dotted edges.

00:49:30.350 --> 00:49:32.240
That's red, green, and blue.

00:49:32.240 --> 00:49:35.230
This is before color journals.

00:49:35.230 --> 00:49:35.730
Question.

00:49:35.730 --> 00:49:37.438
AUDIENCE: I didn't
catch what the purpose

00:49:37.438 --> 00:49:39.240
of coloring the edges is.

00:49:39.240 --> 00:49:40.700
PROFESSOR: Oh.

00:49:40.700 --> 00:49:42.250
It's basically to
decompose the graph

00:49:42.250 --> 00:49:44.470
into a bunch of
different types of paths.

00:49:44.470 --> 00:49:47.980
So when you follow
a path, it must

00:49:47.980 --> 00:49:50.089
be a path of a single color.

00:49:50.089 --> 00:49:50.630
AUDIENCE: Oh.

00:49:50.630 --> 00:49:51.200
OK.

00:49:51.200 --> 00:49:51.550
PROFESSOR: Yes.

00:49:51.550 --> 00:49:54.120
So you can only follow the solid
path or follow a dashed path

00:49:54.120 --> 00:49:55.520
or follow a dotted path.

00:49:55.520 --> 00:49:59.025
You can't mix edges
of different colors.

00:49:59.025 --> 00:50:00.150
So that's the three graphs.

00:50:04.439 --> 00:50:05.230
So what's going on?

00:50:05.230 --> 00:50:07.700
We've got a white token
here, black token here,

00:50:07.700 --> 00:50:08.480
white token here.

00:50:08.480 --> 00:50:11.010
This is a win
position for white.

00:50:11.010 --> 00:50:13.292
These are win
positions for black.

00:50:13.292 --> 00:50:15.000
So there's a lot of
things going on here.

00:50:15.000 --> 00:50:20.070
But the main idea is that white
can move the token to here.

00:50:20.070 --> 00:50:22.250
That corresponds to
EXPTIME being false.

00:50:22.250 --> 00:50:23.500
Or it can move it to here.

00:50:23.500 --> 00:50:26.700
That corresponds to
EXPTIME being true.

00:50:26.700 --> 00:50:29.580
And that's essentially all
you can do in this picture.

00:50:29.580 --> 00:50:30.080
Why?

00:50:30.080 --> 00:50:35.109
Because if this guy moves
to here, for example,

00:50:35.109 --> 00:50:35.900
then black can win.

00:50:35.900 --> 00:50:39.500
Black can go along this
path and get to a win state.

00:50:39.500 --> 00:50:43.640
And symmetrically, if white
also goes off the track,

00:50:43.640 --> 00:50:45.840
then black can go
to the win state.

00:50:45.840 --> 00:50:49.550
Also, we had to put this vertex
here, put this token here,

00:50:49.550 --> 00:50:50.300
to make that true.

00:50:50.300 --> 00:50:52.220
You might worry,
maybe black tries

00:50:52.220 --> 00:50:55.840
to move out of that position to
there or to there or to there.

00:50:55.840 --> 00:50:58.190
But then white will
win by going like that.

00:50:58.190 --> 00:51:02.870
So under optimal play, if you
don't make silly losing moves,

00:51:02.870 --> 00:51:07.570
all you can do is move the white
token between here and here.

00:51:07.570 --> 00:51:10.050
And I didn't say it,
but the path here

00:51:10.050 --> 00:51:12.205
is supposed to be a
non-zero length path.

00:51:12.205 --> 00:51:14.460
So you have to move your token.

00:51:14.460 --> 00:51:16.480
And therefore, that
represents this constraint

00:51:16.480 --> 00:51:18.380
that you must put the variable.

00:51:18.380 --> 00:51:21.570
You must flip exactly one
variable of your color.

00:51:21.570 --> 00:51:23.450
So that's the variable gadget.

00:51:23.450 --> 00:51:26.209
And for a while, that's
just going to happen.

00:51:26.209 --> 00:51:28.125
But now we have to
implement the win condition

00:51:28.125 --> 00:51:31.120
or the lose condition.

00:51:31.120 --> 00:51:34.100
So that's this thing.

00:51:34.100 --> 00:51:36.570
This is a clause.

00:51:36.570 --> 00:51:38.380
This is a DNF clause.

00:51:38.380 --> 00:51:42.510
Is it x3 is false
and y5 is true.

00:51:42.510 --> 00:51:45.200
In that case, we
want to lose or win.

00:51:45.200 --> 00:51:46.700
It doesn't particularly
matter here.

00:51:46.700 --> 00:51:49.910
We want to lose, I guess.

00:51:49.910 --> 00:51:52.250
Obviously, black can't move
first in this configuration,

00:51:52.250 --> 00:51:54.250
because then white
could just win.

00:51:54.250 --> 00:51:56.810
So black can't move first, so
what can happen in this gadget

00:51:56.810 --> 00:51:59.480
is that white must move
here because you're not

00:51:59.480 --> 00:52:01.255
allowed to collide.

00:52:01.255 --> 00:52:03.130
Once you move there,
the threat is that white

00:52:03.130 --> 00:52:04.470
will win in the next turn.

00:52:04.470 --> 00:52:06.630
So black must move up.

00:52:06.630 --> 00:52:09.420
And then, if this is
empty, white can move here.

00:52:12.030 --> 00:52:15.010
It could actually move to
here, because that's a path.

00:52:15.010 --> 00:52:16.680
And then, the threat
is white will win.

00:52:16.680 --> 00:52:19.770
So black must move up.

00:52:19.770 --> 00:52:23.940
Also, there's a black win
there, but we'll get to that.

00:52:23.940 --> 00:52:25.120
Actually, I'll do it now.

00:52:25.120 --> 00:52:28.460
So if this was blocked by
x3, because x3 is currently

00:52:28.460 --> 00:52:32.030
set to true, then you won't
be able to move this way.

00:52:32.030 --> 00:52:34.060
So you'll basically
be stuck here.

00:52:34.060 --> 00:52:36.670
And then, black
can win like that.

00:52:36.670 --> 00:52:38.470
So you don't want to
activate this gadget

00:52:38.470 --> 00:52:39.820
unless this is clear.

00:52:39.820 --> 00:52:41.560
Similarly, we don't
want to activate it

00:52:41.560 --> 00:52:42.540
unless this is clear.

00:52:42.540 --> 00:52:45.100
So if we're up to
here, then white

00:52:45.100 --> 00:52:46.860
can move up, threatening to win.

00:52:46.860 --> 00:52:48.820
Therefore, black must move up.

00:52:48.820 --> 00:52:52.600
And then, if this is clear,
white can move up to there.

00:52:52.600 --> 00:52:56.030
And then, black has to go
there to prevent this win.

00:52:56.030 --> 00:52:58.740
But white can win that way.

00:52:58.740 --> 00:53:01.490
So white is going to
win if this clause was

00:53:01.490 --> 00:53:02.780
satisfied or unsatisfied.

00:53:02.780 --> 00:53:05.530
And I'm a little confused about
how many times we negated.

00:53:05.530 --> 00:53:08.710
But I think you get the spirit.

00:53:08.710 --> 00:53:16.440
And if this DNF clause is
satisfied, then white wins.

00:53:16.440 --> 00:53:18.690
And you can have a bunch of
these clauses just sitting

00:53:18.690 --> 00:53:19.780
around.

00:53:19.780 --> 00:53:22.680
These are all vertices
unique to the clause,

00:53:22.680 --> 00:53:25.000
except for these
guys, which are shared

00:53:25.000 --> 00:53:27.294
with the variable gadgets here.

00:53:27.294 --> 00:53:28.960
So those are the same
as these vertices.

00:53:28.960 --> 00:53:30.410
They're all glued together.

00:53:30.410 --> 00:53:31.310
No planarity here.

00:53:34.040 --> 00:53:34.650
Cool.

00:53:34.650 --> 00:53:38.470
So that's EXPTIME completeness
of this game called Block.

00:53:43.846 --> 00:53:44.345
All right.

00:53:47.280 --> 00:53:48.780
This is a little ambitious.

00:53:48.780 --> 00:53:50.520
But the next one
I'd like to prove

00:53:50.520 --> 00:53:54.800
is a real-life classic
game, namely checkers.

00:53:54.800 --> 00:53:57.160
This is most of the
proof in one slide.

00:53:57.160 --> 00:53:58.580
It's a little bit complicated.

00:53:58.580 --> 00:54:03.760
But let me give you
the high level idea.

00:54:03.760 --> 00:54:06.780
It's actually a
really cool proof.

00:54:06.780 --> 00:54:09.050
It's also from my birth years.

00:54:09.050 --> 00:54:11.440
So it's cool.

00:54:11.440 --> 00:54:14.230
So don't worry
about this too much,

00:54:14.230 --> 00:54:17.210
but our construction is going
to be this little square

00:54:17.210 --> 00:54:18.310
inside this little square.

00:54:18.310 --> 00:54:19.810
And then there's
this giant spiral

00:54:19.810 --> 00:54:22.250
outside that will cause
everything to self-destruct

00:54:22.250 --> 00:54:23.800
when the game ends.

00:54:23.800 --> 00:54:25.270
I'll talk about that later.

00:54:25.270 --> 00:54:27.120
Let's focus in first
on what's happening

00:54:27.120 --> 00:54:29.270
within this little square.

00:54:29.270 --> 00:54:31.940
But that will be the context,
and we'll get to that again.

00:54:31.940 --> 00:54:34.260
So inside the square
is this thing.

00:54:41.190 --> 00:54:44.200
So I mean, I think the
perspective is from white.

00:54:44.200 --> 00:54:46.010
So the goal is for white to win.

00:54:46.010 --> 00:54:49.560
And in checkers, there's
two types of pieces.

00:54:49.560 --> 00:54:52.280
And the circles are
going to be pieces

00:54:52.280 --> 00:54:55.377
that are going this way for
white and that way for black.

00:54:55.377 --> 00:54:56.960
And the squares are
going to be kings.

00:54:56.960 --> 00:54:59.360
They can move up or down.

00:54:59.360 --> 00:55:02.390
So white and has some
variables that it can set

00:55:02.390 --> 00:55:04.136
between true and false up here.

00:55:04.136 --> 00:55:05.510
Black has some
variables that can

00:55:05.510 --> 00:55:06.718
be set between true or false.

00:55:06.718 --> 00:55:10.640
I didn't mention, but we
are going to be playing G3.

00:55:10.640 --> 00:55:12.740
We are going to
be simulating G3.

00:55:12.740 --> 00:55:15.670
So a move is going to be
forcing to flip something.

00:55:15.670 --> 00:55:18.320
And we're going to lose
if the formula ends up

00:55:18.320 --> 00:55:19.880
being satisfied.

00:55:19.880 --> 00:55:23.030
So then there's this
computation done in the middle.

00:55:23.030 --> 00:55:24.680
Basically, each of
these boxes is going

00:55:24.680 --> 00:55:26.360
to correspond to a DNF clause.

00:55:26.360 --> 00:55:28.110
What makes it tricky
is each clause

00:55:28.110 --> 00:55:31.120
involves some black variables
and some white variables.

00:55:31.120 --> 00:55:33.120
And those are going to
behave quite differently.

00:55:33.120 --> 00:55:35.760
But this construction is
going to make that happen.

00:55:35.760 --> 00:55:39.620
And overall, let's see.

00:55:39.620 --> 00:55:41.080
Where to go?

00:55:41.080 --> 00:55:43.090
Let's start with
the variable gadget.

00:55:43.090 --> 00:55:45.804
So this is a white
variable gadget.

00:55:45.804 --> 00:55:47.220
Black variable
gadget is symmetric

00:55:47.220 --> 00:55:49.060
with all the colors
flipped I believe.

00:55:49.060 --> 00:55:49.730
Yeah.

00:55:49.730 --> 00:55:51.110
That should be fine.

00:55:51.110 --> 00:55:54.730
And the key actor is
this king right here.

00:55:54.730 --> 00:55:56.200
I've drawn it at
the intersection.

00:55:56.200 --> 00:55:59.510
But it could be on the t
position or the f position.

00:55:59.510 --> 00:56:01.645
t corresponds to
variables being said true.

00:56:01.645 --> 00:56:03.910
f corresponds to the
variables being set false.

00:56:03.910 --> 00:56:06.950
And so most of the game is going
to be all the players moving

00:56:06.950 --> 00:56:08.776
their kings back and
forth between these t

00:56:08.776 --> 00:56:10.040
and f positions.

00:56:10.040 --> 00:56:11.415
Those will correspond
to flipping

00:56:11.415 --> 00:56:14.030
a variable of your color.

00:56:14.030 --> 00:56:17.960
Now, constantly you're
worrying about the threats.

00:56:17.960 --> 00:56:22.960
These attack zones and
defend paths are the threats.

00:56:22.960 --> 00:56:28.150
And if ever a
threat is satisfied,

00:56:28.150 --> 00:56:29.230
somebody's going to win.

00:56:29.230 --> 00:56:31.040
And the game will end.

00:56:31.040 --> 00:56:35.470
So when that happens, players
in the variable position

00:56:35.470 --> 00:56:39.070
can choose to activate a
variable of their color.

00:56:39.070 --> 00:56:41.980
And the way you would
do that, a key rule

00:56:41.980 --> 00:56:44.800
which you may have
forgotten about checkers,

00:56:44.800 --> 00:56:47.990
is that if you can
capture you must capture.

00:56:47.990 --> 00:56:50.140
So that's how we're going
to force the opponent

00:56:50.140 --> 00:56:52.130
to do lots of things
we want them to do.

00:56:52.130 --> 00:56:56.870
If we move this white token up
and to the right, then suddenly

00:56:56.870 --> 00:56:58.590
this black token can capture.

00:56:58.590 --> 00:57:02.901
And it must capture along the
unique path boom, boom, boom,

00:57:02.901 --> 00:57:03.400
boom.

00:57:03.400 --> 00:57:06.810
Assuming that we're
in the true position,

00:57:06.810 --> 00:57:10.810
he must jump there, jump
there, jump there, and activate

00:57:10.810 --> 00:57:12.519
some stuff down here.

00:57:12.519 --> 00:57:14.310
Conversely, if we're
in the false position,

00:57:14.310 --> 00:57:16.780
we're going to move this
B guy up and to the left.

00:57:16.780 --> 00:57:19.740
And then, black token will have
to go off into this position.

00:57:22.550 --> 00:57:24.700
So far so good.

00:57:24.700 --> 00:57:29.720
Now, so this variable may occur
in several different clauses.

00:57:29.720 --> 00:57:34.270
There's one clause that matters,
because this is a DNF thing.

00:57:34.270 --> 00:57:37.530
We're just trying to prove that
one clause has been satisfied.

00:57:37.530 --> 00:57:41.190
So white's going to want to
send things that satisfy it.

00:57:41.190 --> 00:57:45.080
Black is going to want to
send its variables that

00:57:45.080 --> 00:57:46.880
cause it to be not satisfied.

00:57:46.880 --> 00:57:50.690
So there's going to be
some white variables

00:57:50.690 --> 00:57:53.190
and some black variables
involved in this one clause.

00:57:53.190 --> 00:57:56.900
But we need the ability to
send the copy of this variable

00:57:56.900 --> 00:57:58.980
to the clause that matters.

00:57:58.980 --> 00:58:02.290
So the threatening
player, white,

00:58:02.290 --> 00:58:05.110
is going to be sending their
thing to a particular cause.

00:58:05.110 --> 00:58:09.850
They do that using
this fork gadget.

00:58:09.850 --> 00:58:11.430
So if you're coming
from up here,

00:58:11.430 --> 00:58:15.660
you jump here, and jump here.

00:58:15.660 --> 00:58:17.050
Black jumps here.

00:58:17.050 --> 00:58:19.150
And that's the end
of black's turn.

00:58:19.150 --> 00:58:22.280
Now, white is going to move
this position to either H or I,

00:58:22.280 --> 00:58:25.940
forcing black to go
follow the next path.

00:58:25.940 --> 00:58:28.019
So white's always in
control for this path.

00:58:28.019 --> 00:58:29.810
There's going to be a
symmetric thing where

00:58:29.810 --> 00:58:30.643
black is in control.

00:58:30.643 --> 00:58:35.735
And black and send their token
to where they want it to go,

00:58:35.735 --> 00:58:36.610
one of these squares.

00:58:40.180 --> 00:58:42.160
Cool.

00:58:42.160 --> 00:58:45.810
Now, maybe at this
point I should

00:58:45.810 --> 00:58:51.780
mention that there are these
letters here, MWD and MBD.

00:58:51.780 --> 00:58:54.840
And this is relevant to
the overall architecture

00:58:54.840 --> 00:58:56.440
of the game.

00:58:56.440 --> 00:59:00.760
What we're essentially trying
to do is get free moves.

00:59:00.760 --> 00:59:03.290
Free moves will win
the game, because

00:59:03.290 --> 00:59:05.150
of the spiral on the outside.

00:59:05.150 --> 00:59:06.820
But before I get to
the spiral, here's

00:59:06.820 --> 00:59:08.028
a way to generate free moves.

00:59:08.028 --> 00:59:12.170
Suppose right here I'm going
to throw in a whole bunch--

00:59:12.170 --> 00:59:15.270
think of infinity-- copies of
this gadget, so-called white

00:59:15.270 --> 00:59:16.150
delay.

00:59:16.150 --> 00:59:19.422
So black is forced to jump here
and just keeps going through.

00:59:19.422 --> 00:59:20.630
There's no options for black.

00:59:20.630 --> 00:59:22.320
It just has to keep going.

00:59:22.320 --> 00:59:28.670
But after that move,
white has a penalty,

00:59:28.670 --> 00:59:31.940
because white is forced
to capture that token.

00:59:31.940 --> 00:59:34.689
So white essentially lost a
move sometime in the future.

00:59:34.689 --> 00:59:36.730
As long as there are still
capture moves it's OK.

00:59:36.730 --> 00:59:40.681
But that's kind
of bad for white.

00:59:40.681 --> 00:59:42.430
And there's a symmetric
version for black.

00:59:42.430 --> 00:59:45.490
I didn't bring the picture,
but it's pretty similar.

00:59:45.490 --> 00:59:50.310
And black will be forced
afterwards to jump.

00:59:50.310 --> 00:59:52.980
So the point is if we
essentially stopped

00:59:52.980 --> 00:59:56.740
here, black would win actually.

00:59:56.740 --> 00:59:58.440
Because there's
so many moves here

00:59:58.440 --> 01:00:01.000
that white is forced
to waste, they'll

01:00:01.000 --> 01:00:03.750
end up being able to win
the whole game in a way

01:00:03.750 --> 01:00:05.630
that I will get to.

01:00:05.630 --> 01:00:08.520
For that reason, you better
not trigger this thing

01:00:08.520 --> 01:00:10.640
unless the king is
in the right spot.

01:00:10.640 --> 01:00:14.650
Otherwise, black will stop
there and then black will win.

01:00:14.650 --> 01:00:19.190
But there's a matching
MBD down here for black.

01:00:19.190 --> 01:00:23.176
And so we're forced
to use both of them.

01:00:23.176 --> 01:00:24.550
Then, they cancel
each other out.

01:00:24.550 --> 01:00:26.810
Because if black
has n free moves

01:00:26.810 --> 01:00:28.805
and white as n
free moves, they'll

01:00:28.805 --> 01:00:32.150
just make all those captures
and then get back to the game.

01:00:32.150 --> 01:00:35.500
So, in general, the
gadgets use these things

01:00:35.500 --> 01:00:39.960
to force you to not stop in
the middle of the construction.

01:00:39.960 --> 01:00:44.130
The heart of the matter is
this gadget, the clause.

01:00:44.130 --> 01:00:46.390
So there's numbers here.

01:00:46.390 --> 01:00:49.010
If you look closely, these
are 1's and then these are

01:00:49.010 --> 01:00:53.150
2's and then these are 3's.

01:00:53.150 --> 01:00:55.020
So the idea is let's
suppose that there

01:00:55.020 --> 01:01:00.900
are three white variables
and two black variables

01:01:00.900 --> 01:01:02.920
in this clause that
you can generalize.

01:01:02.920 --> 01:01:04.870
That's what the figure shows.

01:01:04.870 --> 01:01:07.310
So the idea is that first
white's trying to win.

01:01:07.310 --> 01:01:10.200
So it's going to
send its variables

01:01:10.200 --> 01:01:14.381
of the appropriate truth
assignment into the one clause.

01:01:14.381 --> 01:01:15.880
It's going to
activate whichever one

01:01:15.880 --> 01:01:18.950
happens to be glued to the
one clause first or the one

01:01:18.950 --> 01:01:19.810
position.

01:01:19.810 --> 01:01:22.660
And what will happen is the
white token will go here.

01:01:22.660 --> 01:01:25.110
I forgot to mention
we've switched colors

01:01:25.110 --> 01:01:26.199
from white to black.

01:01:26.199 --> 01:01:27.740
That's because
there's a color change

01:01:27.740 --> 01:01:30.198
gadget, where you can convert
white wires into black wires.

01:01:30.198 --> 01:01:31.610
So don't worry about it.

01:01:31.610 --> 01:01:34.110
So now we have a white token
that captures all these pieces.

01:01:34.110 --> 01:01:35.735
Notice it captures
this one, which will

01:01:35.735 --> 01:01:37.900
enable the two path next time.

01:01:37.900 --> 01:01:39.340
So it is first you send in this.

01:01:39.340 --> 01:01:41.900
It just stops,
nothing to do there.

01:01:41.900 --> 01:01:43.410
Then, we send in the 2's.

01:01:43.410 --> 01:01:44.990
And if this has
been done already,

01:01:44.990 --> 01:01:47.700
so this is basically a
conjunction of 1 and 2.

01:01:47.700 --> 01:01:51.500
2 will be able to get here
if and only if both 1 and 2

01:01:51.500 --> 01:01:52.600
are set.

01:01:52.600 --> 01:01:55.110
Also capture this position
and this position,

01:01:55.110 --> 01:01:59.230
enabling both of these 3's.

01:01:59.230 --> 01:02:02.010
Basically, we have two
copies of the 3 wire

01:02:02.010 --> 01:02:05.530
just because the opponent
could mess things up

01:02:05.530 --> 01:02:07.830
for us by moving one of these.

01:02:07.830 --> 01:02:09.440
Black can move this over here.

01:02:09.440 --> 01:02:11.330
And then, we're kind of annoyed.

01:02:11.330 --> 01:02:13.010
But we have two
copies for redundancy.

01:02:13.010 --> 01:02:17.450
So even if black messes up
one of them, we'll be OK.

01:02:17.450 --> 01:02:20.880
The worry is after you activate
this thing black has a turn.

01:02:20.880 --> 01:02:23.580
And so maybe instead of
doing something else, black

01:02:23.580 --> 01:02:25.390
could just move this.

01:02:25.390 --> 01:02:27.810
But we have enough redundancy.

01:02:27.810 --> 01:02:29.000
That won't hurt us.

01:02:29.000 --> 01:02:33.090
Finally, if we can send
1, 2, and 3 together,

01:02:33.090 --> 01:02:37.180
then black will waste n moves.

01:02:37.180 --> 01:02:38.690
And so white is in the lead.

01:02:38.690 --> 01:02:40.440
And then, white will
win the game in a way

01:02:40.440 --> 01:02:42.280
that I haven't shown you.

01:02:42.280 --> 01:02:47.310
Conversely, black has a blocking
strategy, a defense strategy,

01:02:47.310 --> 01:02:55.910
which is after 2 has
activated, if black

01:02:55.910 --> 01:02:58.710
has either of these variable
set to the right value,

01:02:58.710 --> 01:03:01.300
they can trigger them with a
corresponding black variable

01:03:01.300 --> 01:03:02.020
gadget.

01:03:02.020 --> 01:03:05.620
And then, the white
token will come up here

01:03:05.620 --> 01:03:08.900
and hit this gadget MWD, which
is a whole bunch of these.

01:03:08.900 --> 01:03:10.299
And then, white is behind.

01:03:10.299 --> 01:03:11.840
And then, black will
immediately win.

01:03:11.840 --> 01:03:17.292
Before white gets to do
this, black will win.

01:03:17.292 --> 01:03:22.460
So overall structure make sense?

01:03:22.460 --> 01:03:27.190
Basically, this gadget
is active as soon

01:03:27.190 --> 01:03:30.500
as the white player
sends down the one thing

01:03:30.500 --> 01:03:32.280
and then sends
down the two thing.

01:03:32.280 --> 01:03:34.510
And then, if black happens
to have a response which

01:03:34.510 --> 01:03:36.524
blocks it, what
that corresponds to

01:03:36.524 --> 01:03:37.940
is that one of the
black variables

01:03:37.940 --> 01:03:40.270
is in the wrong setting
for this clause.

01:03:40.270 --> 01:03:42.790
Then, black will have a defense
strategy and win the game.

01:03:42.790 --> 01:03:44.490
And so you only want
to activate a thing

01:03:44.490 --> 01:03:46.698
if all the black variables
are in the correct setting

01:03:46.698 --> 01:03:48.360
currently and the
white variables

01:03:48.360 --> 01:03:51.000
in the correct setting, so you
could do the 1, 2, 3, and then

01:03:51.000 --> 01:03:52.530
win.

01:03:52.530 --> 01:03:55.360
And symmetrically, there are
things like this for black.

01:03:55.360 --> 01:03:57.380
But that is the game.

01:03:57.380 --> 01:03:58.970
Now, let me tell
you how once you

01:03:58.970 --> 01:04:01.950
have n free moves, how
you could win the game.

01:04:01.950 --> 01:04:04.470
This is the outer spiral.

01:04:04.470 --> 01:04:05.970
So everything
we're talking about

01:04:05.970 --> 01:04:09.530
was in here very far away from
the spiral, like n squared away

01:04:09.530 --> 01:04:10.790
or something.

01:04:10.790 --> 01:04:13.720
And the spiral in more
detail looks like this.

01:04:13.720 --> 01:04:18.840
We have a whole bunch of kings,
and white king, black king.

01:04:18.840 --> 01:04:21.005
And if you have a
bunch of free moves--

01:04:21.005 --> 01:04:22.880
you don't actually need
very many free moves.

01:04:22.880 --> 01:04:24.115
It's like five or something.

01:04:24.115 --> 01:04:25.740
But they didn't feel
like computing it,

01:04:25.740 --> 01:04:29.610
so they just called it x
and then figured out for x.

01:04:29.610 --> 01:04:32.090
You can make a few moves
and get from this position

01:04:32.090 --> 01:04:35.110
to this position.

01:04:35.110 --> 01:04:36.780
So far so good.

01:04:36.780 --> 01:04:38.150
Still have a free move.

01:04:38.150 --> 01:04:44.770
Iam going to move this A
king to the B position.

01:04:44.770 --> 01:04:46.597
At that point, black
has a forced jump.

01:04:46.597 --> 01:04:48.180
Now, they may have
other forced jumps.

01:04:48.180 --> 01:04:49.590
We'll just just sit
there and wait for them

01:04:49.590 --> 01:04:51.140
to do all their forced jumps.

01:04:51.140 --> 01:04:56.200
And then, black will have
to make this jump, capturing

01:04:56.200 --> 01:04:57.627
one of these kings.

01:04:57.627 --> 01:04:59.210
So this guy's basically
to prevent you

01:04:59.210 --> 01:05:00.500
from jumping that way.

01:05:00.500 --> 01:05:03.450
So this guy moves down, which
forces this guy to jump here.

01:05:03.450 --> 01:05:05.860
And then, from here, you
can jump here, here, here,

01:05:05.860 --> 01:05:07.640
here, here, so satisfying.

01:05:07.640 --> 01:05:10.180
Take all the black
kings on the outside.

01:05:10.180 --> 01:05:12.420
Now, you own the
entire spiral, which

01:05:12.420 --> 01:05:14.440
is a huge number of things.

01:05:14.440 --> 01:05:16.300
The number of
rings of the spiral

01:05:16.300 --> 01:05:20.420
is greater than the
number of pieces in there.

01:05:20.420 --> 01:05:24.070
And also, these things
are very far away.

01:05:24.070 --> 01:05:26.820
So you have plenty of moves.

01:05:26.820 --> 01:05:28.260
So whatever's
happening in here--

01:05:28.260 --> 01:05:30.600
chaos could be
happening-- you can

01:05:30.600 --> 01:05:35.050
rearrange the white spiral into
a bunch of white rectangles.

01:05:35.050 --> 01:05:38.870
And it's already been shown
conveniently that if you have

01:05:38.870 --> 01:05:43.205
n white rectangles
in this sense, less

01:05:43.205 --> 01:05:46.620
or equal to n
pieces, then you win.

01:05:46.620 --> 01:05:48.220
So it doesn't matter
what's in here.

01:05:48.220 --> 01:05:50.240
You can come in
and use each ring

01:05:50.240 --> 01:05:52.580
to destroy one black
token at a time.

01:05:52.580 --> 01:05:54.580
And game over.

01:05:54.580 --> 01:05:55.386
[LAUGHTER]

01:05:55.386 --> 01:05:58.770
PROFESSOR: Isn't that fun?

01:05:58.770 --> 01:06:01.000
So that's checkers
EXPTIME complete.

01:06:01.000 --> 01:06:01.980
A very cool proof.

01:06:01.980 --> 01:06:02.880
There are details I didn't show.

01:06:02.880 --> 01:06:04.671
There's a parity shift,
a few other things.

01:06:04.671 --> 01:06:07.460
But that's pretty
much everything.

01:06:07.460 --> 01:06:09.060
And that's the power of G3.

01:06:13.410 --> 01:06:16.820
I'll just show
pictures for chess.

01:06:16.820 --> 01:06:18.530
It's even more complicated.

01:06:18.530 --> 01:06:22.310
But chess is also
EXPTIME complete.

01:06:22.310 --> 01:06:24.210
Now, I mean, both
checkers and chess

01:06:24.210 --> 01:06:26.870
in the real game sometimes
in some versions of the rules

01:06:26.870 --> 01:06:29.530
it says you can make at
most 200 moves or 500

01:06:29.530 --> 01:06:30.420
moves or something.

01:06:30.420 --> 01:06:32.170
Those games are of
course PSPACE complete,

01:06:32.170 --> 01:06:35.650
if you add an artificial
move bound of n or something.

01:06:35.650 --> 01:06:37.400
But if you don't, the
natural game I think

01:06:37.400 --> 01:06:39.233
is when you don't bound
the number of moves,

01:06:39.233 --> 01:06:43.100
then they become
EXPTIME complete.

01:06:43.100 --> 01:06:44.910
This is also from G3.

01:06:44.910 --> 01:06:46.680
That's I'll say about chess.

01:06:46.680 --> 01:06:49.850
AUDIENCE: Do you know in
chess what pieces are used?

01:06:49.850 --> 01:06:53.160
PROFESSOR: I think it's just
pawns and bishops, which

01:06:53.160 --> 01:06:54.110
is pretty cool.

01:06:54.110 --> 01:06:55.027
One of these figures--

01:06:55.027 --> 01:06:55.568
AUDIENCE: Oh.

01:06:55.568 --> 01:06:56.350
It's on the left.

01:06:56.350 --> 01:06:56.540
PROFESSOR: Yeah.

01:06:56.540 --> 01:06:58.665
White pawn, black pawn,
white bishop, black bishop.

01:06:58.665 --> 01:07:00.960
I'm pretty sure
that's all of them.

01:07:00.960 --> 01:07:03.270
But it's a little hard to
tell him from this figure.

01:07:03.270 --> 01:07:05.561
I think you need a better
scan to know which are which.

01:07:08.500 --> 01:07:09.000
And

01:07:09.000 --> 01:07:12.770
This paper's a little hard to
find, but I got a scanned copy.

01:07:12.770 --> 01:07:15.990
Go is EXPTIME hard.

01:07:15.990 --> 01:07:19.431
So how many people know Go?

01:07:19.431 --> 01:07:19.930
Good.

01:07:19.930 --> 01:07:22.220
Almost everyone.

01:07:22.220 --> 01:07:25.017
So Go is a little
funny, because you might

01:07:25.017 --> 01:07:26.100
think it's a bounded game.

01:07:26.100 --> 01:07:30.110
Every time you place a
token, you consume area.

01:07:30.110 --> 01:07:37.250
But captures remove area, and
furthermore kos are the action.

01:07:37.250 --> 01:07:41.500
So kos are these threats that
when I capture and someone else

01:07:41.500 --> 01:07:43.457
can capture me back.

01:07:43.457 --> 01:07:45.915
And you can flip back and forth
from those types of states.

01:07:45.915 --> 01:07:49.260
There are actually
different rules for Go.

01:07:49.260 --> 01:07:53.120
The Japanese rule set
says that you are not

01:07:53.120 --> 01:07:56.580
allowed to repeat the
position you were just at.

01:07:56.580 --> 01:07:59.040
And this is the
subtlety of a ko.

01:08:06.770 --> 01:08:08.830
So this is the
canonical simplest ko.

01:08:08.830 --> 01:08:13.800
So if you move white here,
you capture this stone.

01:08:13.800 --> 01:08:15.300
And under Japanese
rules, you're not

01:08:15.300 --> 01:08:17.020
allowed to repeat the
previous position, which

01:08:17.020 --> 01:08:19.061
means you're not allowed
to immediately play back

01:08:19.061 --> 01:08:20.244
here and capture this stone.

01:08:20.244 --> 01:08:20.910
You can see why.

01:08:20.910 --> 01:08:23.451
It'd be kind of a boring game
if you just went back and forth

01:08:23.451 --> 01:08:24.510
capturing the same guy.

01:08:24.510 --> 01:08:26.710
But as long as you
play anywhere else,

01:08:26.710 --> 01:08:28.410
then you can come
back and capture.

01:08:28.410 --> 01:08:29.569
That's the ko threat.

01:08:33.069 --> 01:08:36.990
That game is in EXPTIME.

01:08:36.990 --> 01:08:39.890
And Go is EXPTIME complete
under Japanese rules.

01:08:43.899 --> 01:08:45.960
In some sense, because
the number of states

01:08:45.960 --> 01:08:47.422
is still only
exponential, you just

01:08:47.422 --> 01:08:49.380
need to remember the
current state and the very

01:08:49.380 --> 01:08:50.140
previous state.

01:08:50.140 --> 01:08:52.056
Because the ko rule is
that you're not allowed

01:08:52.056 --> 01:08:54.590
to repeat the previous state.

01:08:54.590 --> 01:08:57.367
In the USA and China, there
is something called a super ko

01:08:57.367 --> 01:08:58.950
rule, which is that
you're not allowed

01:08:58.950 --> 01:09:02.760
to repeat any previous
state of the game ever seen.

01:09:02.760 --> 01:09:06.370
That means that you are not
necessarily still in EXPTIME,

01:09:06.370 --> 01:09:09.060
because you might need to
remember all past states, which

01:09:09.060 --> 01:09:10.880
could be exponentially long.

01:09:10.880 --> 01:09:15.279
So it's like double
the exponential size.

01:09:15.279 --> 01:09:19.479
In general, you are in EXPSPACE.

01:09:19.479 --> 01:09:24.460
And it's an open problem
whether Go with super ko

01:09:24.460 --> 01:09:26.250
is EXPSPACE complete.

01:09:26.250 --> 01:09:29.250
Currently, best known lower
bound is EXPTIME hardness.

01:09:29.250 --> 01:09:31.870
I won't cover the gadgets here.

01:09:31.870 --> 01:09:34.199
I mean, it's even more subtle,
because you can't really

01:09:34.199 --> 01:09:34.740
be capturing.

01:09:34.740 --> 01:09:36.979
It's all about ko threats.

01:09:36.979 --> 01:09:38.851
Or you can't really
be adding pieces.

01:09:38.851 --> 01:09:40.350
You have to constantly
be capturing,

01:09:40.350 --> 01:09:41.830
because you must
conserve volume.

01:09:41.830 --> 01:09:44.202
You're running for
exponential time.

01:09:44.202 --> 01:09:46.160
It would be quite an
interesting game to watch.

01:09:46.160 --> 01:09:49.170
But it's a reduction
I think from G3 again.

01:09:53.939 --> 01:09:55.340
That's Go.

01:09:55.340 --> 01:09:58.480
Let me tell you a little
bit about constraint logic.

01:09:58.480 --> 01:10:00.051
So we got a question.

01:10:00.051 --> 01:10:00.717
AUDIENCE: Sorry.

01:10:00.717 --> 01:10:02.300
I was just wondering
if you're allowed

01:10:02.300 --> 01:10:05.690
to use superpolynomial
reductions for EXPTIME purpose.

01:10:05.690 --> 01:10:07.865
PROFESSOR: So in
fact, all the proofs

01:10:07.865 --> 01:10:11.280
I've seen in this world
use LOGSPACE, which is even

01:10:11.280 --> 01:10:13.402
stronger than polynomial time.

01:10:13.402 --> 01:10:14.110
I don't know why.

01:10:14.110 --> 01:10:15.401
Probably just because they can.

01:10:15.401 --> 01:10:16.570
And it's slightly better.

01:10:16.570 --> 01:10:19.410
It makes sense to use LOGSPACE
reductions for PSPACE hardness.

01:10:19.410 --> 01:10:21.810
But they ended up still
doing LOGSPACE reductions

01:10:21.810 --> 01:10:23.170
for EXPTIME hardness.

01:10:23.170 --> 01:10:26.220
For my purposes, I think
polynomial time would be fine.

01:10:26.220 --> 01:10:28.240
You could imagine using
a little bit more time.

01:10:28.240 --> 01:10:29.620
Definitely you don't want
to use exponential time,

01:10:29.620 --> 01:10:31.494
because that wouldn't
preserve a lower bound.

01:10:31.494 --> 01:10:33.800
But you could use
quasi-polynomial or polynomial

01:10:33.800 --> 01:10:36.450
spaces or some crazy thing.

01:10:36.450 --> 01:10:39.640
But all the claims
I've made don't even

01:10:39.640 --> 01:10:41.645
need polynomial time reductions.

01:10:41.645 --> 01:10:45.190
It's pretty strong.

01:10:45.190 --> 01:10:46.072
Yeah.

01:10:46.072 --> 01:10:51.080
AUDIENCE: That rule
confuses me a lot.

01:10:51.080 --> 01:10:54.247
So that means I can't ever
go in the erased area?

01:10:54.247 --> 01:10:55.080
PROFESSOR: Well, no.

01:10:55.080 --> 01:10:59.940
You could play here as long
as something else changed.

01:10:59.940 --> 01:11:03.090
You cannot repeat the
entire board configuration.

01:11:03.090 --> 01:11:06.790
So the local
configuration can repeat.

01:11:06.790 --> 01:11:08.660
So as long as something
else has changed,

01:11:08.660 --> 01:11:09.927
then you can play here.

01:11:09.927 --> 01:11:11.870
AUDIENCE: But then it's
the same rule, right?

01:11:11.870 --> 01:11:13.120
PROFESSOR: It's the same rule.

01:11:13.120 --> 01:11:16.504
But if you have five of
these, so in the ko rule,

01:11:16.504 --> 01:11:18.170
as long as you're
basically playing them

01:11:18.170 --> 01:11:20.450
in a different order, you
can keep playing around

01:11:20.450 --> 01:11:22.470
and ko, ko, ko.

01:11:22.470 --> 01:11:24.630
But in the super-ko
rule, at some point,

01:11:24.630 --> 01:11:26.300
you're going to run
out of ko patterns.

01:11:26.300 --> 01:11:29.077
And at some point, you won't
be able to repeat something.

01:11:29.077 --> 01:11:30.660
And that changes how
the game behaves.

01:11:30.660 --> 01:11:33.120
Of course, we don't have a
hardness proof for that case,

01:11:33.120 --> 01:11:36.150
or a stronger hardness proof.

01:11:36.150 --> 01:11:37.650
It's subtle.

01:11:37.650 --> 01:11:40.060
Two-player constraint
logic unbounded

01:11:40.060 --> 01:11:41.880
is also EXPTIME complete.

01:11:41.880 --> 01:11:45.040
This is a reduction from G6.

01:11:45.040 --> 01:11:47.930
You can set one of your
variables however you want.

01:11:47.930 --> 01:11:52.180
And player 1 is going to win
if we satisfy a CNF formula.

01:11:52.180 --> 01:11:56.130
So the formula is out
here or here or here.

01:11:56.130 --> 01:11:57.699
This is a white variable.

01:11:57.699 --> 01:11:58.740
This is a black variable.

01:11:58.740 --> 01:12:00.698
The only difference is
this edge is white here.

01:12:00.698 --> 01:12:02.666
This edge is black there.

01:12:02.666 --> 01:12:04.540
So the idea is this can
be set left to right.

01:12:04.540 --> 01:12:06.600
If it's left, that
corresponds to false.

01:12:06.600 --> 01:12:09.830
If it's to the right,
it corresponds to true.

01:12:09.830 --> 01:12:11.840
And so most of the
time, players are just

01:12:11.840 --> 01:12:14.430
going to be flipping their
edges back and forth.

01:12:14.430 --> 01:12:15.800
It'd be a pretty boring game.

01:12:15.800 --> 01:12:18.740
But at some point, there's
this constant threat network,

01:12:18.740 --> 01:12:23.490
which is if the
formula is satisfied,

01:12:23.490 --> 01:12:27.840
then the white player is
going to be able to win.

01:12:27.840 --> 01:12:30.050
How do they win?

01:12:30.050 --> 01:12:32.860
First thing they do
is lock a variable.

01:12:32.860 --> 01:12:36.244
So this is pointing to the
true state-- sorry, also left

01:12:36.244 --> 01:12:38.160
and right pictures are
symmetric, so symmetric

01:12:38.160 --> 01:12:39.826
that we didn't even
draw it in the book.

01:12:39.826 --> 01:12:43.300
So I reflected the image and
all the letters are backwards.

01:12:43.300 --> 01:12:46.040
So let's say the variable's
pointing to the right.

01:12:46.040 --> 01:12:49.060
So white is going to
lock the variable,

01:12:49.060 --> 01:12:52.650
prevent it from flipping
anymore, by flipping this edge.

01:12:52.650 --> 01:12:55.540
Now, we enter attack face.

01:12:55.540 --> 01:12:56.850
And lots of things happen.

01:12:56.850 --> 01:12:58.490
So this is a SPLIT gadget.

01:12:58.490 --> 01:13:00.200
So immediately,
for example, black

01:13:00.200 --> 01:13:02.380
could flip here and
start winning the game.

01:13:02.380 --> 01:13:04.170
There's a long path here.

01:13:04.170 --> 01:13:06.100
It's slow, so it's a long path.

01:13:06.100 --> 01:13:08.530
But eventually black
will win the game.

01:13:08.530 --> 01:13:10.920
The timer starts
ticking now potentially,

01:13:10.920 --> 01:13:13.230
if black chooses to
follow that path.

01:13:13.230 --> 01:13:16.270
Simultaneously, white is
going to flip this guy,

01:13:16.270 --> 01:13:18.020
then flip this guy,
and then flip this guy

01:13:18.020 --> 01:13:21.450
and activate the formula.

01:13:21.450 --> 01:13:25.080
Now, it's a little
awkward, because we

01:13:25.080 --> 01:13:30.130
needed 1, 2, 3, 4 moves
to trigger the formula.

01:13:30.130 --> 01:13:33.245
We basically want to
consume four moves of black

01:13:33.245 --> 01:13:35.140
so that things remain balanced.

01:13:35.140 --> 01:13:39.680
And that's this
1, 2, 3, 4 flips.

01:13:39.680 --> 01:13:43.620
If black does not
flip all these edges,

01:13:43.620 --> 01:13:46.810
then white can flip this
and then flip this and then

01:13:46.810 --> 01:13:49.170
flip this and then
instantly win.

01:13:49.170 --> 01:13:51.230
That's the fast win track.

01:13:51.230 --> 01:13:54.254
So to prevent that, black
must flip this edge.

01:13:54.254 --> 01:13:56.420
It can't flip this edge
until it's flipped this one.

01:13:56.420 --> 01:13:58.545
It can't flip this one
until it's flipped this one.

01:13:58.545 --> 01:14:00.830
So as soon as you
lock a variable,

01:14:00.830 --> 01:14:04.660
black must respond
with A. At that point,

01:14:04.660 --> 01:14:06.710
white can afford to flip here.

01:14:06.710 --> 01:14:09.570
And black must respond
with B. And then flip here,

01:14:09.570 --> 01:14:12.090
black must respond with
C. And then flip here,

01:14:12.090 --> 01:14:16.670
black must respond-- I guess,
flip here first and then

01:14:16.670 --> 01:14:19.410
flip B. And then you can
activate the formula.

01:14:19.410 --> 01:14:22.450
So then white and black
are balanced again.

01:14:22.450 --> 01:14:26.190
What's cool about that is it
means white cannot only lock

01:14:26.190 --> 01:14:28.930
this variable but lock
all of the variables.

01:14:28.930 --> 01:14:30.810
Every variable
behaves the same way.

01:14:30.810 --> 01:14:33.840
And the goal for white is to
get all the variables locked

01:14:33.840 --> 01:14:36.400
so it can start
triggering the formula.

01:14:36.400 --> 01:14:39.840
So every time you
lock a variable,

01:14:39.840 --> 01:14:43.090
black is forced to respond
in a particular way.

01:14:43.090 --> 01:14:47.520
And so after that, white can
lock the next variable, both

01:14:47.520 --> 01:14:50.240
the white ones and the black
ones, locks all of them.

01:14:50.240 --> 01:14:52.670
And now, the formula's
basically primed, ready to go.

01:14:52.670 --> 01:14:54.152
The variables can't
change anymore.

01:14:54.152 --> 01:14:55.610
And now, we're in
full attack mode.

01:14:59.491 --> 01:14:59.990
Cool.

01:14:59.990 --> 01:15:03.220
And then, the formula happens.

01:15:03.220 --> 01:15:06.610
Meanwhile, this slow win is
probably happening, fusing.

01:15:06.610 --> 01:15:11.630
And we set up the formula
so that if it's satisfied,

01:15:11.630 --> 01:15:16.110
you end up flipping the win edge
in a certain amount of time.

01:15:16.110 --> 01:15:17.520
And this is slightly longer.

01:15:17.520 --> 01:15:19.530
So if you don't end up
satisfying the formula,

01:15:19.530 --> 01:15:20.100
black wins.

01:15:20.100 --> 01:15:21.600
And then, it was
not a valid threat.

01:15:21.600 --> 01:15:26.200
You shouldn't have
triggered this attack mode.

01:15:26.200 --> 01:15:29.280
There's another threat
here, the slower win.

01:15:33.170 --> 01:15:35.870
So I assume that people
were flipping these edges.

01:15:35.870 --> 01:15:38.770
But it could be actually
black flips A early.

01:15:38.770 --> 01:15:40.840
If it does that, then
white will eventually

01:15:40.840 --> 01:15:41.980
win through that path.

01:15:41.980 --> 01:15:45.100
So this win path is just
to prevent A from flipping

01:15:45.100 --> 01:15:47.290
before it's locked.

01:15:47.290 --> 01:15:49.030
And the timing is
to setup right.

01:15:49.030 --> 01:15:50.620
Obviously, lots of
timing issues here,

01:15:50.620 --> 01:15:54.090
so we have to build an
equalizer gadget that ends up

01:15:54.090 --> 01:15:56.765
slowing down the traversal
of an edge basically

01:15:56.765 --> 01:15:57.700
in a particular way.

01:15:57.700 --> 01:16:00.680
And these are all of
the vertices need.

01:16:00.680 --> 01:16:04.569
It's a fair number, including
some white and black edges,

01:16:04.569 --> 01:16:05.860
which is a little bit annoying.

01:16:05.860 --> 01:16:07.970
It'd be nice to simplify
instead of gadgets.

01:16:07.970 --> 01:16:12.090
But that's the best
we have so far.

01:16:12.090 --> 01:16:17.400
And you can use the regular
NCL crossover appropriately,

01:16:17.400 --> 01:16:21.270
making everything else slower
so that crossover doesn't

01:16:21.270 --> 01:16:24.610
slow things down too much.

01:16:24.610 --> 01:16:25.780
Cool.

01:16:25.780 --> 01:16:27.880
A couple more minutes.

01:16:27.880 --> 01:16:29.930
I want to mention
a couple of games

01:16:29.930 --> 01:16:33.460
that do not fit into the table.

01:16:33.460 --> 01:16:35.480
In some sense, they are
higher than the table.

01:16:35.480 --> 01:16:37.970
So we have polynomial
bounded number of moves.

01:16:37.970 --> 01:16:42.760
And then, above that, we have
exponential number of moves.

01:16:42.760 --> 01:16:45.390
But if you take those
exponential number of moves

01:16:45.390 --> 01:16:54.420
and add an extra rule, so this
is entirely motivated by Go

01:16:54.420 --> 01:16:56.750
with super-ko rule.

01:16:56.750 --> 01:17:00.190
And you take any of these
games like G1 through G6.

01:17:03.550 --> 01:17:05.840
So you have the same win rule.

01:17:05.840 --> 01:17:08.367
But in addition you will lose
if you ever repeat a past game

01:17:08.367 --> 01:17:08.950
configuration.

01:17:08.950 --> 01:17:11.570
So it's forbidden to do that.

01:17:11.570 --> 01:17:17.070
Then, Robson, same guy who
proved Go is EXPTIME hard,

01:17:17.070 --> 01:17:20.320
proved that G1, G2, and
G3, and chess and checkers

01:17:20.320 --> 01:17:24.710
become EXPSPACE
complete, which is cool.

01:17:24.710 --> 01:17:27.120
That's a little harder.

01:17:27.120 --> 01:17:28.730
And it makes sense
they're in EXPSPACE

01:17:28.730 --> 01:17:32.420
because it can sort of walk
the graph in exponential space.

01:17:32.420 --> 01:17:36.100
But they actually
become that hard.

01:17:36.100 --> 01:17:39.180
And even crazier
to me is this rule.

01:17:39.180 --> 01:17:41.165
It seems almost the same.

01:17:41.165 --> 01:17:43.540
So we're going to have two
extra variables x and y, which

01:17:43.540 --> 01:17:45.660
can appear in the formula.

01:17:45.660 --> 01:17:47.680
And instead of
this lose rule, we

01:17:47.680 --> 01:17:51.450
add this lose rule which is
if you ever repeat a past game

01:17:51.450 --> 01:17:55.340
configuration-- and between
now and that past configuration

01:17:55.340 --> 01:17:59.500
at most one of x and y have
changed and that in turn-- then

01:17:59.500 --> 01:18:00.767
you lose.

01:18:00.767 --> 01:18:02.350
So if both of them
get changed, you're

01:18:02.350 --> 01:18:04.682
allowed to repeat it again.

01:18:04.682 --> 01:18:07.140
I don't have a great intuition
why this makes the game even

01:18:07.140 --> 01:18:10.550
harder, but it pushes it
up to the next level which

01:18:10.550 --> 01:18:13.640
is double the exponential time.

01:18:13.640 --> 01:18:15.160
AUDIENCE: This is
change and changed

01:18:15.160 --> 01:18:18.560
back [INAUDIBLE] configuration?

01:18:18.560 --> 01:18:21.080
PROFESSOR: Well, right.

01:18:21.080 --> 01:18:24.110
One of them will
have changed, x or y.

01:18:24.110 --> 01:18:25.492
Hm.

01:18:25.492 --> 01:18:26.950
You're repeating
the configuration.

01:18:26.950 --> 01:18:29.360
So you changed something--
it be some other variable z--

01:18:29.360 --> 01:18:30.360
and then change it back.

01:18:30.360 --> 01:18:32.800
As long as you didn't
also change both x and y,

01:18:32.800 --> 01:18:34.024
that's considered invalid.

01:18:34.024 --> 01:18:36.440
Once you change x and y, you
are free to repeat everything

01:18:36.440 --> 01:18:41.480
again, until the next time
something gets repeated.

01:18:41.480 --> 01:18:43.700
So I guess you have
to keep track of when

01:18:43.700 --> 01:18:44.870
the x and y changes are.

01:18:44.870 --> 01:18:47.890
So it's even harder to know
the history of the game,

01:18:47.890 --> 01:18:50.239
which repeats are valid
and which are invalid.

01:18:50.239 --> 01:18:51.780
In this case, all
that he could prove

01:18:51.780 --> 01:18:55.500
is the G1 becomes double
the exponential time.

01:18:58.501 --> 01:18:59.000
Cool.

01:19:01.810 --> 01:19:04.550
I could say a little more.

01:19:04.550 --> 01:19:09.710
In this world, it's probably
good to know this fun fact.

01:19:09.710 --> 01:19:11.960
Normally, when we think
of non-determinism,

01:19:11.960 --> 01:19:14.380
we think of an NP.

01:19:14.380 --> 01:19:16.760
We have existential
quantifiers on the guesses.

01:19:16.760 --> 01:19:19.550
If there's at least one branch
that works, then we're happy.

01:19:19.550 --> 01:19:21.050
Then, we return, yes.

01:19:21.050 --> 01:19:24.650
You could also think of
universal quantifiers, where

01:19:24.650 --> 01:19:28.160
if all of the paths going out
of here end up with yes, then

01:19:28.160 --> 01:19:28.990
we're happy.

01:19:28.990 --> 01:19:32.520
You can also think of an
alternating guess machine,

01:19:32.520 --> 01:19:38.110
or alternating lucky machine,
where every other time

01:19:38.110 --> 01:19:41.770
it's an existential guess
branch and the opposite times

01:19:41.770 --> 01:19:44.470
it's a universal guess branch.

01:19:44.470 --> 01:19:46.830
That corresponds to two-player
games in a natural way.

01:19:52.830 --> 01:20:00.400
Alternating polynomial time
thing corresponds to queue set.

01:20:00.400 --> 01:20:03.810
So that would give you PSPACE.

01:20:03.810 --> 01:20:07.110
Alternating polynomial time
gives you polynomial space.

01:20:07.110 --> 01:20:10.490
Alternating polynomial space
gives you exponential time.

01:20:10.490 --> 01:20:13.295
Alternating exponential time
gives you exponential space.

01:20:13.295 --> 01:20:14.920
Alternating exponential
space gives you

01:20:14.920 --> 01:20:16.740
double the exponential time.

01:20:16.740 --> 01:20:18.580
So in fact, this
result is stated

01:20:18.580 --> 01:20:21.290
as alternating exponential
space complete,

01:20:21.290 --> 01:20:23.310
which is the same as
double exponential time.

01:20:23.310 --> 01:20:27.320
So time and space are
interleaved in the natural way.

01:20:27.320 --> 01:20:29.080
And if you add
alternation to one layer,

01:20:29.080 --> 01:20:30.890
you get to the next layer.

01:20:30.890 --> 01:20:32.850
So it's just fun facts.

01:20:32.850 --> 01:20:35.260
And it's useful for
reasoning about these games.

01:20:35.260 --> 01:20:37.630
One more class.

01:20:37.630 --> 01:20:40.120
We've so far talked about
perfect information games,

01:20:40.120 --> 01:20:43.030
where everybody knows all the
states of all the variables.

01:20:43.030 --> 01:20:44.590
You can define a
private information

01:20:44.590 --> 01:20:47.322
game, where you can
see some but not

01:20:47.322 --> 01:20:48.530
all of your opponent's state.

01:20:48.530 --> 01:20:51.050
You know all of your
variable settings.

01:20:51.050 --> 01:20:53.789
In this setting, a slight
variation on G1 and G2.

01:20:53.789 --> 01:20:55.830
We have to generalize the
formula's a little bit,

01:20:55.830 --> 01:20:58.490
become double the exponential
time complete, just as hard

01:20:58.490 --> 01:21:01.510
as the weird repeat rule.

01:21:01.510 --> 01:21:05.630
Private information gives
you a very hard thing.

01:21:05.630 --> 01:21:09.060
A more restricted form is when
player 1 can't see anything

01:21:09.060 --> 01:21:09.840
about player 2.

01:21:09.840 --> 01:21:12.180
But player 2 can see a
little bit of player 1.

01:21:12.180 --> 01:21:14.580
This is sort of a
semi-blind game.

01:21:14.580 --> 01:21:18.430
In this case, G2 at least is
exponential space complete.

01:21:18.430 --> 01:21:20.890
That's weaker than here.

01:21:20.890 --> 01:21:24.360
So lots of weird
separations here.

01:21:24.360 --> 01:21:26.960
There are no well-known
games in these categories

01:21:26.960 --> 01:21:29.262
that have been proofed hard.

01:21:29.262 --> 01:21:30.595
But here is the version of Peek.

01:21:30.595 --> 01:21:33.134
You can redesign
the Peek structure.

01:21:33.134 --> 01:21:34.300
So you have some walls here.

01:21:34.300 --> 01:21:37.300
So you can't see whether this
guy's in or this guy's out.

01:21:37.300 --> 01:21:39.579
Player 0 can only
play on these guys.

01:21:39.579 --> 01:21:41.120
Player 1 can only
plan on these guys.

01:21:41.120 --> 01:21:42.850
Player 1 can see
all of this state,

01:21:42.850 --> 01:21:44.080
a little bit of the state.

01:21:44.080 --> 01:21:47.180
In the blind version, you can't
see anything to the right.

01:21:47.180 --> 01:21:50.840
And because they
couldn't do G4, this

01:21:50.840 --> 01:21:57.550
is the G2 version, which is
there's also a wall here.

01:21:57.550 --> 01:21:59.657
And you can only see
red through these holes.

01:21:59.657 --> 01:22:01.740
And your opponent can see
red through these holes.

01:22:01.740 --> 01:22:04.000
So you've got two
different win conditions.

01:22:04.000 --> 01:22:05.070
That's G2.

01:22:05.070 --> 01:22:09.100
And so that's a version of Peek.

01:22:09.100 --> 01:22:10.900
This one is double
the exponential time

01:22:10.900 --> 01:22:12.630
hard and complete.

01:22:12.630 --> 01:22:16.100
And this one is
exponential space complete.

01:22:16.100 --> 01:22:21.040
So these are like
way in the deep end.

01:22:21.040 --> 01:22:25.134
But next class we'll talk
about this category of team

01:22:25.134 --> 01:22:26.300
imperfect information games.

01:22:26.300 --> 01:22:27.930
And then, we even
get undecidability,

01:22:27.930 --> 01:22:31.070
which is the ultimate hardness.

01:22:31.070 --> 01:22:33.190
But that's all for today.

