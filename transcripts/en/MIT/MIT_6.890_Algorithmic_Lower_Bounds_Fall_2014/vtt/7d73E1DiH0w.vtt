WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.050
Your support will help
MIT OpenCourseWare

00:00:06.050 --> 00:00:10.150
continue to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.265
at ocw.mit.edu.

00:00:25.755 --> 00:00:26.630
PROFESSOR: All right.

00:00:26.630 --> 00:00:29.750
Welcome to 6.890,
Algorithmic Lower Bounds,

00:00:29.750 --> 00:00:31.030
Fun with Hardness Proofs.

00:00:31.030 --> 00:00:33.210
I am your host, Erik Demaine.

00:00:33.210 --> 00:00:40.100
We have on my left Jayson Lynch
and Sarah Eisenstat, your TAs.

00:00:40.100 --> 00:00:43.650
First question is what
is this class about?

00:00:43.650 --> 00:00:46.160
The tag line is
hardness made easy.

00:00:46.160 --> 00:00:49.620
In general, we're interested
in proving problems hard.

00:00:49.620 --> 00:00:52.420
Proving that there's no fast
algorithms to solve problems

00:00:52.420 --> 00:00:54.970
under certain assumptions.

00:00:54.970 --> 00:00:59.520
And the goal is to give
you a practical guide

00:00:59.520 --> 00:01:02.310
and give you lots of experience
in how to prove problems hard,

00:01:02.310 --> 00:01:04.640
to make that an easy process.

00:01:04.640 --> 00:01:06.170
There's a lot of
technique involved,

00:01:06.170 --> 00:01:09.270
and the more experience
you get improving hardness,

00:01:09.270 --> 00:01:11.670
it becomes relatively
straightforward to take

00:01:11.670 --> 00:01:14.260
whatever problem you're
interested in and prove it hard

00:01:14.260 --> 00:01:17.080
So the three of us
are pretty good at it,

00:01:17.080 --> 00:01:20.620
and our goal is to share
with you that expertise so

00:01:20.620 --> 00:01:23.570
that everyone's good at it.

00:01:23.570 --> 00:01:25.797
This is not a complexity class.

00:01:25.797 --> 00:01:27.880
Because there are lots of
computational complexity

00:01:27.880 --> 00:01:29.780
classes at MIT.

00:01:29.780 --> 00:01:32.670
So we're not going
to talk about lots

00:01:32.670 --> 00:01:35.740
of beautiful deep
mathematics about relations

00:01:35.740 --> 00:01:37.330
between complexity classes.

00:01:37.330 --> 00:01:39.680
We're just going to use
a lot of those results

00:01:39.680 --> 00:01:41.815
wholesale without proving them.

00:01:41.815 --> 00:01:44.190
And you can take one of the
many computational complexity

00:01:44.190 --> 00:01:45.840
classes to get that background.

00:01:45.840 --> 00:01:49.140
I will tell you everything you
need to know about complexity.

00:01:49.140 --> 00:01:50.800
So if you've taken
a complexity class,

00:01:50.800 --> 00:01:52.591
there will be a small
amount of repetition.

00:01:52.591 --> 00:01:54.870
Most of it will be contained
in today's lecture.

00:01:54.870 --> 00:01:58.330
But very little repetition, but
also no background required.

00:01:58.330 --> 00:02:01.110
I do expect you to have a
background in algorithms,

00:02:01.110 --> 00:02:04.410
because we take a kind of
algorithmic perspective.

00:02:04.410 --> 00:02:09.870
I call it an anti-algorithmic
perspective, if you like.

00:02:09.870 --> 00:02:13.250
And so, yeah.

00:02:13.250 --> 00:02:15.320
So that's what this class is.

00:02:15.320 --> 00:02:17.150
Why would you want
to take this class?

00:02:17.150 --> 00:02:18.100
Why prove hardness?

00:02:18.100 --> 00:02:20.990
Well, the main reason
is to show that you

00:02:20.990 --> 00:02:23.345
can't design algorithms
in whatever model

00:02:23.345 --> 00:02:24.220
you're interested in.

00:02:24.220 --> 00:02:27.149
That encourages you either
to change the problem, like

00:02:27.149 --> 00:02:28.690
to look for
approximation algorithms,

00:02:28.690 --> 00:02:30.197
or fixed parameter algorithms.

00:02:30.197 --> 00:02:32.280
That's, of course, the
topics of algorithms class.

00:02:32.280 --> 00:02:34.196
Our goal is to prove
when these things are not

00:02:34.196 --> 00:02:35.881
possible in this class.

00:02:35.881 --> 00:02:37.630
We're going to master
a lot of techniques.

00:02:37.630 --> 00:02:42.800
You'll see a lot of key problems
to reduce from to your problem.

00:02:42.800 --> 00:02:45.290
Get a lot of proof
styles that are

00:02:45.290 --> 00:02:47.380
quite common in the
literature, but unless you've

00:02:47.380 --> 00:02:48.910
done them and
experienced them, it's

00:02:48.910 --> 00:02:50.630
hard to know what to look for.

00:02:50.630 --> 00:02:53.729
And one of the big ideas
in this class is gadgets.

00:02:53.729 --> 00:02:55.270
And you may have
seen gadgets before,

00:02:55.270 --> 00:02:58.159
but we're going to explore
gadgets to their fullest.

00:02:58.159 --> 00:02:59.950
The idea of taking lots
of small components

00:02:59.950 --> 00:03:02.857
and combining them together.

00:03:02.857 --> 00:03:04.440
Even if you don't
care about hardness,

00:03:04.440 --> 00:03:06.920
I think this class is a
lot of fun for two reasons.

00:03:06.920 --> 00:03:08.790
Maybe three.

00:03:08.790 --> 00:03:10.705
One is that you see
lots of cool connections

00:03:10.705 --> 00:03:12.830
between different problems
that you might not think

00:03:12.830 --> 00:03:14.380
are related at first glance.

00:03:14.380 --> 00:03:15.870
Most of the problems
in this class

00:03:15.870 --> 00:03:17.450
are equivalent to each other.

00:03:17.450 --> 00:03:18.820
And it's all about proving that.

00:03:18.820 --> 00:03:21.380
That's the goal.

00:03:21.380 --> 00:03:23.850
We'll also study
lots of fun problems,

00:03:23.850 --> 00:03:25.050
like Super Mario Brothers.

00:03:25.050 --> 00:03:27.380
We'll NP-complete today.

00:03:27.380 --> 00:03:29.704
Tetris, we'll do in
a lecture or two.

00:03:29.704 --> 00:03:32.120
There are also serious problems,
so if you don't like fun,

00:03:32.120 --> 00:03:34.020
don't worry.

00:03:34.020 --> 00:03:36.800
And in general,
proving problems hard

00:03:36.800 --> 00:03:38.660
is really like solving a puzzle.

00:03:38.660 --> 00:03:39.920
And it's a lot of fun.

00:03:39.920 --> 00:03:42.030
And this is one
of the rare areas

00:03:42.030 --> 00:03:44.330
where you can basically
play with puzzles all day,

00:03:44.330 --> 00:03:46.650
and in the end have
publishable papers.

00:03:46.650 --> 00:03:48.750
So we're going to do
that in particular

00:03:48.750 --> 00:03:51.040
through an open problem
session, which is optional.

00:03:51.040 --> 00:03:53.200
If you want to
solve open problems

00:03:53.200 --> 00:03:54.970
that no one knows
the answer to, we

00:03:54.970 --> 00:03:56.880
will try to do it once a week.

00:03:56.880 --> 00:04:00.070
We'll be sending email
with a call for times when

00:04:00.070 --> 00:04:02.670
that's ideal for everybody.

00:04:02.670 --> 00:04:07.750
We talked about background
and requirements.

00:04:07.750 --> 00:04:09.160
So first requirement
of the class

00:04:09.160 --> 00:04:11.930
is to fill out the survey, which
is circulating Does anyone not

00:04:11.930 --> 00:04:13.060
have a survey?

00:04:13.060 --> 00:04:13.560
Good.

00:04:13.560 --> 00:04:14.490
Everyone has one.

00:04:14.490 --> 00:04:19.230
So fill that out, so
we know who you are.

00:04:19.230 --> 00:04:20.969
You should also join
the mailing list.

00:04:20.969 --> 00:04:22.760
By filling out that
survey, you should auto

00:04:22.760 --> 00:04:23.676
join the mailing list.

00:04:23.676 --> 00:04:25.780
But just in case, if you
haven't, the mailing list

00:04:25.780 --> 00:04:26.821
is on the course website.

00:04:29.300 --> 00:04:30.811
Yeah.

00:04:30.811 --> 00:04:32.950
Good.

00:04:32.950 --> 00:04:34.700
Another requirement
is to attend lectures.

00:04:34.700 --> 00:04:37.260
You're doing good
on that so far.

00:04:37.260 --> 00:04:39.720
And you'll have scribe--

00:04:39.720 --> 00:04:43.050
I would guess at
this scale, you'll

00:04:43.050 --> 00:04:45.340
scribe once, probably in a team.

00:04:45.340 --> 00:04:50.150
But we will figure that
out as time goes on.

00:04:50.150 --> 00:04:53.180
Again, they'll be email about
signing up for scribing.

00:04:53.180 --> 00:04:55.630
Scribing is taking
notes in the lecture

00:04:55.630 --> 00:04:58.142
so we have another
form of notes.

00:04:58.142 --> 00:04:59.600
There will be
something like five P

00:04:59.600 --> 00:05:01.220
sets every two to three weeks.

00:05:01.220 --> 00:05:05.450
The first one will go
out Tuesday is the plan.

00:05:05.450 --> 00:05:07.390
And then the big
part of the class

00:05:07.390 --> 00:05:11.210
is the project and presentation,
so the final project,

00:05:11.210 --> 00:05:13.360
you could do it on
almost anything related

00:05:13.360 --> 00:05:15.110
to the content of the class.

00:05:15.110 --> 00:05:18.870
Typical projects are do
something new theoretically,

00:05:18.870 --> 00:05:23.470
prove a problem hard, find
some nice open problems, survey

00:05:23.470 --> 00:05:26.620
existing material, something
that's not covered in class.

00:05:26.620 --> 00:05:27.900
You can code something.

00:05:27.900 --> 00:05:29.990
I think in this context,
the most natural thing

00:05:29.990 --> 00:05:32.860
to do is to visualize
cool proofs that we

00:05:32.860 --> 00:05:35.170
cover in class in a new way.

00:05:35.170 --> 00:05:36.890
You could contribute
to Wikipedia,

00:05:36.890 --> 00:05:38.870
or you could make
some art piece,

00:05:38.870 --> 00:05:40.850
like a sculpture,
or a performance,

00:05:40.850 --> 00:05:45.080
or whatever you want
related to hardness proofs.

00:05:45.080 --> 00:05:48.620
That's your project
possibilities.

00:05:48.620 --> 00:05:51.310
So what is in this class?

00:05:51.310 --> 00:05:55.940
I will look at what
specific topics are covered.

00:05:55.940 --> 00:05:57.320
This is on the website.

00:05:57.320 --> 00:05:59.500
So a lot of the class will
be about NP-completeness,

00:05:59.500 --> 00:06:02.440
which I will define in a bit.

00:06:02.440 --> 00:06:04.560
But we'll also look
at even harder--

00:06:04.560 --> 00:06:07.590
these are all notions of no
polynomial time algorithm.

00:06:07.590 --> 00:06:10.550
We'll do even harder notions
then NP, like PSPACE and X

00:06:10.550 --> 00:06:12.010
time, and so on.

00:06:12.010 --> 00:06:14.640
In particular, we'll be studying
those in the context of games

00:06:14.640 --> 00:06:17.750
and puzzles, and there's a whole
theory called games, puzzles,

00:06:17.750 --> 00:06:20.710
and computation, the
topic of this book,

00:06:20.710 --> 00:06:24.190
which we will talk
about at length.

00:06:24.190 --> 00:06:28.650
Then, we will go to
inapproximability.

00:06:28.650 --> 00:06:31.390
This is not necessarily in
order, so I should say then.

00:06:31.390 --> 00:06:34.340
But we'll talk about when you
cannot find good approximation

00:06:34.340 --> 00:06:37.490
algorithms, and what good means
depends on what sort of problem

00:06:37.490 --> 00:06:40.860
you're looking at, and when
you cannot find fixed parameter

00:06:40.860 --> 00:06:43.890
algorithms, which are fast
algorithms when the optimal

00:06:43.890 --> 00:06:46.570
solutions happens to be small.

00:06:46.570 --> 00:06:48.450
So that's all about
not polynomial.

00:06:48.450 --> 00:06:50.540
Then, there's a
small amount of work

00:06:50.540 --> 00:06:55.180
on understanding the polynomial
aspect for small polynomials,

00:06:55.180 --> 00:06:57.435
distinguishing almost
linear time from n

00:06:57.435 --> 00:06:59.590
squared time or n cubed time.

00:06:59.590 --> 00:07:00.925
That sort of thing.

00:07:00.925 --> 00:07:02.550
Then there are other
sorts of problems.

00:07:02.550 --> 00:07:04.714
We can think about less
common types of problems,

00:07:04.714 --> 00:07:06.880
like where you want to count
the number of solutions

00:07:06.880 --> 00:07:08.960
instead of just
find one, or tell

00:07:08.960 --> 00:07:10.850
whether the solution is unique.

00:07:10.850 --> 00:07:13.560
There's some economic
game theory stuff.

00:07:13.560 --> 00:07:15.220
This existential
theory, the reals,

00:07:15.220 --> 00:07:16.810
comes up in some
geometric settings.

00:07:16.810 --> 00:07:18.720
And if there's time,
we'll talk a little bit

00:07:18.720 --> 00:07:20.261
about undecidability,
although that's

00:07:20.261 --> 00:07:22.230
a pretty different world.

00:07:22.230 --> 00:07:25.250
That's where there's
no algorithm given

00:07:25.250 --> 00:07:28.630
any finite time bound.

00:07:28.630 --> 00:07:31.690
So that's in a nutshell
what's the entire class is.

00:07:31.690 --> 00:07:36.390
Today, we're going to do
a sort of crash course

00:07:36.390 --> 00:07:38.250
on computational complexity.

00:07:38.250 --> 00:07:41.780
Most of what you should need
for the entire course, I think,

00:07:41.780 --> 00:07:45.540
will fit in about 40 minutes.

00:07:45.540 --> 00:07:46.390
Maybe 50 minutes.

00:07:46.390 --> 00:07:47.150
Something.

00:07:47.150 --> 00:07:49.970
And that will serve
as a guideline.

00:07:49.970 --> 00:07:52.940
If anything's not clear, if I
go too fast, feel free to stop,

00:07:52.940 --> 00:07:57.110
ask questions during
class or after class.

00:07:57.110 --> 00:07:58.160
And let's see.

00:07:58.160 --> 00:08:01.120
So we have some--

00:08:01.120 --> 00:08:02.860
there's no real
textbook for the class,

00:08:02.860 --> 00:08:05.550
but there are two
recommended reading books.

00:08:05.550 --> 00:08:08.220
They are Garey and Johnson.

00:08:08.220 --> 00:08:09.977
Computers and
Intractability is the title.

00:08:09.977 --> 00:08:11.560
Most people call it
Garey and Johnson.

00:08:11.560 --> 00:08:14.640
This is an old book
from pretty much

00:08:14.640 --> 00:08:16.350
early on in the world
of NP completeness,

00:08:16.350 --> 00:08:18.460
but it's still a
really good book.

00:08:18.460 --> 00:08:21.180
So that's good to check out.

00:08:21.180 --> 00:08:24.270
And then there's my
book with Bob Hearn.

00:08:24.270 --> 00:08:27.150
This is Bob Hearn's PhD
thesis at MIT, Games, Puzzles,

00:08:27.150 --> 00:08:28.190
and Computation.

00:08:28.190 --> 00:08:31.090
This is available
electronically for free online

00:08:31.090 --> 00:08:32.456
to all MIT people.

00:08:32.456 --> 00:08:34.039
So if you look it
up in MIT libraries,

00:08:34.039 --> 00:08:37.600
it's actually linked right here.

00:08:37.600 --> 00:08:38.819
So you're seeing that base.

00:08:38.819 --> 00:08:40.110
You can get an electronic copy.

00:08:40.110 --> 00:08:43.539
If you want to buy one,
talk to me or order it.

00:08:46.150 --> 00:08:48.420
There's a couple other
links on the website.

00:08:48.420 --> 00:08:51.000
There was some followup
to the Garey and Johnson

00:08:51.000 --> 00:08:56.800
book by Johnson and some
other cool websites.

00:08:56.800 --> 00:08:58.520
All right.

00:08:58.520 --> 00:09:02.180
So I think that is the
administrative part.

00:09:02.180 --> 00:09:04.430
Now we can start the
fun part of the class.

00:09:04.430 --> 00:09:10.449
So let's do our crash
course on complexity.

00:09:10.449 --> 00:09:12.490
So if you've seen complexity
before, some of this

00:09:12.490 --> 00:09:13.990
will be review.

00:09:13.990 --> 00:09:22.060
We start with our favorite
class of problems that can

00:09:22.060 --> 00:09:23.930
be solved in polynomial time.

00:09:35.490 --> 00:09:37.865
Say on a RAM, I should
specify model of computation

00:09:37.865 --> 00:09:39.640
and exactly what a
problem is, but I'll

00:09:39.640 --> 00:09:41.050
be a little bit informal here.

00:09:41.050 --> 00:09:46.190
Polynomial time means
n to some constant,

00:09:46.190 --> 00:09:50.670
where n is the size of
the problem instance.

00:09:50.670 --> 00:09:52.090
And we will talk
a little bit more

00:09:52.090 --> 00:09:53.840
about subtleties in defining n.

00:09:53.840 --> 00:09:57.270
But usually, polynomial
time is pretty clear.

00:09:57.270 --> 00:09:59.150
This is what we consider
good algorithms.

00:09:59.150 --> 00:10:01.370
An example of something
we consider bad

00:10:01.370 --> 00:10:02.700
is exponential time.

00:10:02.700 --> 00:10:04.940
So x is going to be all
the problems that can

00:10:04.940 --> 00:10:07.050
be solved in exponential time.

00:10:11.470 --> 00:10:15.590
And exponential's a little
less a uniquely defined,

00:10:15.590 --> 00:10:17.330
but I'll define it this way.

00:10:17.330 --> 00:10:20.000
I think this is the
usual definition for x. .

00:10:20.000 --> 00:10:22.222
So 2 to a polynomial.

00:10:22.222 --> 00:10:24.520
Of course, it could
be 3 if you prefer.

00:10:24.520 --> 00:10:26.370
Any constant will
be the same here.

00:10:26.370 --> 00:10:29.950
This constant dwarfs
any constant there.

00:10:29.950 --> 00:10:33.350
So that is-- this is a
huge class, any problem you

00:10:33.350 --> 00:10:34.640
can in exponential time.

00:10:34.640 --> 00:10:36.530
Most problems can be
solved exponential time,

00:10:36.530 --> 00:10:39.480
though not all.

00:10:39.480 --> 00:10:42.930
Most problems we
encounter, I should say.

00:10:42.930 --> 00:10:45.530
And then I'll define
one more just for kicks.

00:10:45.530 --> 00:10:47.820
R is a recursively
enumerable problems,

00:10:47.820 --> 00:10:49.169
or recursive problems.

00:10:49.169 --> 00:10:51.710
These are all the problems that
can be solved in finite time.

00:10:56.330 --> 00:10:56.930
Always.

00:10:56.930 --> 00:10:59.990
And these are all
worst case bounds.

00:10:59.990 --> 00:11:03.790
So I'm going to have
a running picture.

00:11:03.790 --> 00:11:07.820
This is my favorite
picture to draw.

00:11:07.820 --> 00:11:13.750
We have on the x-axis
a somewhat vague notion

00:11:13.750 --> 00:11:17.356
of computational difficulty.

00:11:17.356 --> 00:11:20.610
What you might call
hardness colloquially.

00:11:20.610 --> 00:11:23.680
This is a bit informal,
but it's still a useful way

00:11:23.680 --> 00:11:24.920
to think about things.

00:11:24.920 --> 00:11:28.140
So this initial
chunk here is going

00:11:28.140 --> 00:11:31.500
to be P. I'm going to
leave in some space

00:11:31.500 --> 00:11:33.440
to fill in some other things.

00:11:33.440 --> 00:11:36.410
And probably go to here.

00:11:36.410 --> 00:11:43.840
And this part is
going to be EXP,

00:11:43.840 --> 00:11:51.830
and then everything to
the left of this line

00:11:51.830 --> 00:11:54.040
are the problems that are
solvable in finite time.

00:11:54.040 --> 00:11:55.540
Everything to the
right of that line

00:11:55.540 --> 00:11:57.150
is not solvable by algorithms.

00:11:57.150 --> 00:11:58.413
That would be undecidable.

00:11:58.413 --> 00:11:59.320
OK.

00:11:59.320 --> 00:12:02.440
So obviously, anything
we saw in polynomial time

00:12:02.440 --> 00:12:04.120
can also be solved
in exponential time.

00:12:04.120 --> 00:12:06.910
That's all that this is saying.

00:12:06.910 --> 00:12:07.410
Cool.

00:12:07.410 --> 00:12:10.980
So I have examples.

00:12:10.980 --> 00:12:14.990
I'll give you some
examples to think about.

00:12:14.990 --> 00:12:20.010
For example, n by n Chess.

00:12:20.010 --> 00:12:22.630
So this is, I give you a Chess
configuration on an n by n,

00:12:22.630 --> 00:12:25.000
and I want to know,
let's say, white to move.

00:12:25.000 --> 00:12:28.600
Can white force a win?

00:12:28.600 --> 00:12:34.790
This turns out to be
solvable in exponential time,

00:12:34.790 --> 00:12:41.520
and is not solvable
in polynomial time.

00:12:41.520 --> 00:12:46.160
So that's a nice result.
Something we will get to.

00:12:46.160 --> 00:12:52.020
Another example is Tetris,
suitably generalized.

00:12:52.020 --> 00:12:53.635
So we're thinking
about problems where

00:12:53.635 --> 00:12:54.680
you have all the information.

00:12:54.680 --> 00:12:56.410
Usually in Tetris, you
don't know all the pieces

00:12:56.410 --> 00:12:57.368
that are going to come.

00:12:57.368 --> 00:12:59.730
But supposing you knew
the future, I give you

00:12:59.730 --> 00:13:02.450
the entire sequence of pieces
that are going to come,

00:13:02.450 --> 00:13:03.520
sort of a Tetris puzzle.

00:13:03.520 --> 00:13:06.640
They used to publish these
in Nintendo Power Magazine.

00:13:06.640 --> 00:13:08.220
And you want to
know, can I survive

00:13:08.220 --> 00:13:09.340
from this board position?

00:13:09.340 --> 00:13:11.690
Can I survive this
sequence of pieces

00:13:11.690 --> 00:13:13.175
This is also in EXP.

00:13:13.175 --> 00:13:14.800
You can solve this
in exponential time.

00:13:14.800 --> 00:13:17.910
That's a little more obvious.

00:13:17.910 --> 00:13:23.940
But we don't know whether
it's in P. Probably it's not,

00:13:23.940 --> 00:13:25.320
and we'll see why in a moment.

00:13:31.140 --> 00:13:32.870
If you've taken an
algorithms class,

00:13:32.870 --> 00:13:34.480
you know tons of
examples of problems

00:13:34.480 --> 00:13:40.860
that are in P, like shortest
paths or lots of good things.

00:13:40.860 --> 00:13:45.790
Halting problem, you've
probably heard of.

00:13:45.790 --> 00:13:48.470
Kind of a classic.

00:13:48.470 --> 00:13:53.380
Halting problem is, given an
algorithm, does it terminate,

00:13:53.380 --> 00:13:55.780
or given some computer
code, does it terminate?

00:13:55.780 --> 00:13:58.450
This is not recursive,
meaning there's

00:13:58.450 --> 00:14:03.090
no algorithm to solve it in
finite time in the worst case.

00:14:03.090 --> 00:14:04.850
There's a more
depressing result,

00:14:04.850 --> 00:14:07.510
which is that in
fact, most problems--

00:14:07.510 --> 00:14:18.930
let's say most decision
problems are not in R.

00:14:18.930 --> 00:14:21.100
Most problems cannot be
solved by an algorithm.

00:14:21.100 --> 00:14:24.550
If you haven't seen that,
it's cool result. Basically,

00:14:24.550 --> 00:14:32.810
the proof is that the number
of problems in the universe

00:14:32.810 --> 00:14:37.510
is about 2 to the N. And
the number of algorithms

00:14:37.510 --> 00:14:41.020
is only about N. So if you
know set theory, great.

00:14:41.020 --> 00:14:44.450
Otherwise, ignore this sentence.

00:14:44.450 --> 00:14:47.180
So you could think of an
algorithm as a number.

00:14:47.180 --> 00:14:49.220
It's like, you take this
string and convert it

00:14:49.220 --> 00:14:50.880
to a giant number.

00:14:50.880 --> 00:14:53.420
So that's integers over here.

00:14:53.420 --> 00:14:55.130
You can think of
problems as a mapping

00:14:55.130 --> 00:14:57.500
from inputs to Yes or No.

00:14:57.500 --> 00:14:58.810
Yes or No is the 2.

00:14:58.810 --> 00:15:03.172
Inputs is the N. This is
the same as real numbers.

00:15:03.172 --> 00:15:05.630
This is the integers, and there
are a lot more real numbers

00:15:05.630 --> 00:15:06.213
than integers.

00:15:06.213 --> 00:15:07.440
You probably heard of that.

00:15:07.440 --> 00:15:09.981
So this means most problems have
no algorithm if an algorithm

00:15:09.981 --> 00:15:11.780
can only solve one problem.

00:15:11.780 --> 00:15:13.070
That's the sad news of life.

00:15:13.070 --> 00:15:15.650
Luckily, most of the
problems we tend to pose

00:15:15.650 --> 00:15:18.975
do have an algorithm, and
it's more about P versus EXP

00:15:18.975 --> 00:15:21.920
that this class is about.

00:15:21.920 --> 00:15:25.210
So let's go to more
interesting things.

00:15:29.900 --> 00:15:35.560
I'm going to define a class
NP, which is in between here.

00:15:35.560 --> 00:15:36.680
In between P and EXP.

00:15:44.630 --> 00:15:46.470
So as I said, decision
problems are problems

00:15:46.470 --> 00:15:47.740
where the answer is Yes or No.

00:15:51.670 --> 00:15:53.690
There are lots of possible
definitions of NP.

00:15:53.690 --> 00:15:54.980
I will cover two.

00:15:58.629 --> 00:16:00.170
I would like there
to be an algorithm

00:16:00.170 --> 00:16:01.836
to solve the problem
in polynomial time,

00:16:01.836 --> 00:16:05.470
but not in a regular
model of computation,

00:16:05.470 --> 00:16:08.760
But with something I
call a lucky algorithm.

00:16:13.980 --> 00:16:16.500
Lucky algorithm
comes to a decision,

00:16:16.500 --> 00:16:19.504
and it always makes
the right one.

00:16:19.504 --> 00:16:20.170
It's just lucky.

00:16:20.170 --> 00:16:22.628
It doesn't have any reason to
believe that's the right one.

00:16:22.628 --> 00:16:25.390
It just always makes the
right choice given the choice

00:16:25.390 --> 00:16:27.940
between two options, let's say.

00:16:27.940 --> 00:16:30.335
So this is, you
make lucky guesses.

00:16:30.335 --> 00:16:33.810
You always guess the right one.

00:16:33.810 --> 00:16:36.630
It's a little bit biased
in a way that I should say.

00:16:36.630 --> 00:16:38.930
So let me be a
little more precise.

00:16:38.930 --> 00:16:43.310
This is called a
non-deterministic model.

00:16:43.310 --> 00:16:47.570
And the N in NP is
non-deterministic.

00:16:53.090 --> 00:16:56.240
So the idea is
that the algorithm

00:16:56.240 --> 00:16:57.330
makes a series of guesses.

00:16:57.330 --> 00:16:59.288
It could do it at the
beginning, or could do it

00:16:59.288 --> 00:17:01.710
in the middle of
the computation.

00:17:01.710 --> 00:17:06.190
And eventually, it
outputs an answer.

00:17:06.190 --> 00:17:10.930
So it's going to say
either Yes or No.

00:17:10.930 --> 00:17:14.589
And what we guarantee in this
weird non-deterministic lucky

00:17:14.589 --> 00:17:20.660
model of computation is that
you will be led to a Yes answer

00:17:20.660 --> 00:17:22.750
if it's possible.

00:17:22.750 --> 00:17:24.410
So it guesses--
this is asymmetric.

00:17:41.640 --> 00:17:44.250
So what this means is say
you run your magical lucky

00:17:44.250 --> 00:17:45.820
algorithm, and it outputs No.

00:17:45.820 --> 00:17:49.920
That means no matter
what set of choices

00:17:49.920 --> 00:17:53.876
you made for each guess, you
would always get to a No.

00:17:53.876 --> 00:17:55.250
If you get a Yes
answer, you just

00:17:55.250 --> 00:17:57.880
know there's some set of guesses
that lead to a Yes answer.

00:17:57.880 --> 00:18:01.520
So one is an existential
quantifier, one's universal.

00:18:01.520 --> 00:18:04.310
So this is asymmetric.

00:18:04.310 --> 00:18:09.430
There is a notion of CoNP,
which is exactly the reverse.

00:18:09.430 --> 00:18:14.010
CoNP, you let's say
flip Yes with No.

00:18:14.010 --> 00:18:18.460
So CoNP, you prefer no
answers if you can get them.

00:18:18.460 --> 00:18:19.680
All right.

00:18:19.680 --> 00:18:25.390
So let me give another
definition of NP.

00:18:48.434 --> 00:18:50.600
Another way to think of the
same definition, really.

00:19:16.350 --> 00:19:17.850
So you can also
think of NP problems

00:19:17.850 --> 00:19:21.300
as problems that have solutions
that are relatively succinct

00:19:21.300 --> 00:19:23.490
and can be checked
in polynomial time.

00:19:23.490 --> 00:19:27.460
I guess really they need to
be checkable efficiently.

00:19:27.460 --> 00:19:31.070
So what you can think
of this as saying is,

00:19:31.070 --> 00:19:32.730
well, every time I
make a guess, I'll

00:19:32.730 --> 00:19:36.560
write down whether I went
left or went right in my maze,

00:19:36.560 --> 00:19:37.950
I guess.

00:19:37.950 --> 00:19:40.600
And so that you could
think of as a certificate.

00:19:40.600 --> 00:19:42.910
If you know what the right
sequence of guesses are,

00:19:42.910 --> 00:19:44.451
of course, you can
run the algorithm,

00:19:44.451 --> 00:19:46.790
because it's a polynomial
time algorithm.

00:19:46.790 --> 00:19:51.900
Conversely, if I don't have
the solution to the problem,

00:19:51.900 --> 00:19:55.070
yet I'm told that it exists,
at the top of my algorithm,

00:19:55.070 --> 00:19:58.470
I could just guess what that
solution is, and then check it.

00:19:58.470 --> 00:19:59.940
So if I'm given
such an algorithm,

00:19:59.940 --> 00:20:01.770
I can convert it into
a lucky algorithm.

00:20:01.770 --> 00:20:03.270
If I'm given a
lucky algorithm, I

00:20:03.270 --> 00:20:06.650
can convert it into one of
these checking algorithms.

00:20:06.650 --> 00:20:07.150
OK.

00:20:10.080 --> 00:20:13.275
So let's do an example.

00:20:18.170 --> 00:20:22.880
Let's say Tetris is in NP.

00:20:22.880 --> 00:20:28.070
So if I give you a board, and
I give you a sequence of pieces

00:20:28.070 --> 00:20:29.320
that are going to come.

00:20:29.320 --> 00:20:31.270
How would I prove to
you that I can survive

00:20:31.270 --> 00:20:32.311
those sequence of pieces?

00:20:34.840 --> 00:20:36.330
AUDIENCE: Say where they go?

00:20:36.330 --> 00:20:37.746
PROFESSOR: Just
say where they go.

00:20:37.746 --> 00:20:41.960
Say what sequence or moves I
press, and at what times say.

00:20:41.960 --> 00:20:44.560
Just where should
I drop each piece?

00:20:44.560 --> 00:20:47.230
So then all you need to do
for this definition is check

00:20:47.230 --> 00:20:49.219
that that's about
solution that you never

00:20:49.219 --> 00:20:50.760
have to push a piece
up, for example,

00:20:50.760 --> 00:20:55.100
to get it into the
right position.

00:20:55.100 --> 00:20:57.180
Or you can think
of the same thing

00:20:57.180 --> 00:20:58.910
as an algorithm
that says, oh, OK.

00:20:58.910 --> 00:21:01.590
Every time I have to press left,
or right, or wait a second,

00:21:01.590 --> 00:21:03.350
or push down, I'll
just guess which

00:21:03.350 --> 00:21:05.330
one to do, and then do that.

00:21:05.330 --> 00:21:09.570
So these are the same
algorithm, essentially.

00:21:09.570 --> 00:21:11.260
And that's why Tetris is in NP.

00:21:11.260 --> 00:21:13.870
In general, let's see.

00:21:13.870 --> 00:21:17.250
Every problem that I can
solve in polynomial time,

00:21:17.250 --> 00:21:19.730
of course, I can solve in
non-deterministic polynomial

00:21:19.730 --> 00:21:21.970
time, so that's
that containment.

00:21:21.970 --> 00:21:24.010
If I have an NP
problem and I want

00:21:24.010 --> 00:21:26.430
to solve it in
exponential time, well, I

00:21:26.430 --> 00:21:29.090
could just simulate all the
possible guessing paths,

00:21:29.090 --> 00:21:31.530
because I run for
only polynomial time.

00:21:31.530 --> 00:21:33.889
And so for each one,
maybe I have two choices.

00:21:33.889 --> 00:21:34.680
I'll just try both.

00:21:34.680 --> 00:21:36.640
I'll do this sort
of depth research.

00:21:36.640 --> 00:21:39.290
And yeah.

00:21:39.290 --> 00:21:42.390
I have exponential is
exactly 2 to that polynomial,

00:21:42.390 --> 00:21:45.330
so I can afford to branch
in both directions.

00:21:45.330 --> 00:21:47.490
So I guess my guesses
here are just binary.

00:21:47.490 --> 00:21:49.560
I could afford to branch
in both directions,

00:21:49.560 --> 00:21:52.394
and eventually see whether
any of them leads to a Yes.

00:21:52.394 --> 00:21:54.810
I could also figure out whether
any of them leads to a No.

00:21:54.810 --> 00:21:58.780
But in general, NP
is contained in EXP.

00:21:58.780 --> 00:22:01.400
Cool.

00:22:01.400 --> 00:22:03.995
Still not too interesting.

00:22:06.295 --> 00:22:07.670
Where it gets
interesting is when

00:22:07.670 --> 00:22:10.400
we start talking about
hardness, which is next.

00:22:10.400 --> 00:22:15.340
I should mention big open
question is whether there's

00:22:15.340 --> 00:22:18.400
any problem in
here in NP minus P.

00:22:18.400 --> 00:22:21.020
This is the same as P
equals NP open problem.

00:22:21.020 --> 00:22:26.140
Most sane people in the universe
believe P does not equal NP.

00:22:26.140 --> 00:22:32.570
What this means intuitively is
that you can't engineer luck.

00:22:32.570 --> 00:22:35.610
Luck shouldn't exist
in the real world.

00:22:35.610 --> 00:22:38.606
You can't just like,
go one way or the other

00:22:38.606 --> 00:22:39.980
and always make
the right choice.

00:22:39.980 --> 00:22:41.570
You could make a random choice.

00:22:41.570 --> 00:22:43.446
You could try both choices.

00:22:43.446 --> 00:22:45.820
But you shouldn't be able to
always make the right choice

00:22:45.820 --> 00:22:46.810
for all problems.

00:22:46.810 --> 00:22:48.099
That seems insane.

00:22:48.099 --> 00:22:50.390
So if you believe that, you
believe P does not equal NP

00:22:50.390 --> 00:22:52.920
and you believe there's some
things in between those two

00:22:52.920 --> 00:22:53.420
lines.

00:22:53.420 --> 00:22:56.820
But we don't know,
unfortunately.

00:22:56.820 --> 00:23:03.250
So let me talk about hardness.

00:23:03.250 --> 00:23:06.063
So if I have some
complexity class X,

00:23:06.063 --> 00:23:11.540
X could be NP, or
EXP at this point.

00:23:11.540 --> 00:23:12.662
P we won't talk about.

00:23:12.662 --> 00:23:13.870
P hardness is a little weird.

00:23:17.457 --> 00:23:19.790
I'm not going to define this
formally until a little bit

00:23:19.790 --> 00:23:21.760
later in today's class.

00:23:28.670 --> 00:23:31.270
So problem is X-hard if
it's sort of the hardest

00:23:31.270 --> 00:23:35.540
problem in the class X, if it's
as hard as every other problem

00:23:35.540 --> 00:23:38.970
in X. Actually, this
problem may not be in X,

00:23:38.970 --> 00:23:42.700
so I should say it's hard
as every problem in X.

00:23:42.700 --> 00:23:51.030
So what that means in this
picture is the following.

00:23:54.510 --> 00:23:58.380
So every problem from
here onward is EXP-hard.

00:24:02.880 --> 00:24:08.130
And every problem from
here onward is NP-hard.

00:24:12.090 --> 00:24:13.760
Whoops.

00:24:13.760 --> 00:24:16.259
Here.

00:24:16.259 --> 00:24:17.550
We won't talk about P hardness.

00:24:17.550 --> 00:24:20.505
That's a notion in
parallel computing.

00:24:20.505 --> 00:24:22.620
I mean, maybe we'll have
time to talk about it,

00:24:22.620 --> 00:24:24.920
but it's not
currently on the plan.

00:24:24.920 --> 00:24:28.517
So this is the lower
bound side, right?

00:24:28.517 --> 00:24:30.100
You're proving that
you're at least as

00:24:30.100 --> 00:24:32.790
hard as the very
hardest problem in NP,

00:24:32.790 --> 00:24:36.590
or you're at least as hard
as the problem in EXP.

00:24:36.590 --> 00:24:43.510
The reason, the only reason,
I know that Chess is not NP

00:24:43.510 --> 00:24:47.250
is because I know that
Chess is actually X-hard.

00:24:47.250 --> 00:24:49.830
I know it's at least as hard
as all problems solvable

00:24:49.830 --> 00:24:51.110
an exponential time.

00:24:51.110 --> 00:24:54.510
And there's a great theorem
called time hierarchy theorem

00:24:54.510 --> 00:24:58.000
that tells you that P does
not equal EXP in particular.

00:24:58.000 --> 00:25:01.090
So we know there are
some problems in EXP that

00:25:01.090 --> 00:25:04.200
are not in P. Some problems that
require exponential time can't

00:25:04.200 --> 00:25:05.940
be done in polynomial time.

00:25:05.940 --> 00:25:08.420
And we know that Chess is
as hard as all of them,

00:25:08.420 --> 00:25:12.882
so in particular, it also can't
be solved in polynomial time.

00:25:12.882 --> 00:25:15.340
Mind you, though, I haven't
defined what as hard as a means

00:25:15.340 --> 00:25:19.320
yet, but I will get there.

00:25:19.320 --> 00:25:23.680
Another good term to
know is X-completeness.

00:25:23.680 --> 00:25:29.090
This is just the and of two
things, being X-hard and being

00:25:29.090 --> 00:25:39.810
in X. So in my picture, this
dot right here is NP-complete.

00:25:44.080 --> 00:25:47.230
And this dot right here is--

00:25:47.230 --> 00:25:49.060
got to write it this way--

00:25:49.060 --> 00:25:50.120
is X-complete.

00:25:55.671 --> 00:25:56.170
OK.

00:25:56.170 --> 00:25:58.330
I already mentioned
that Chess is in EXP.

00:25:58.330 --> 00:26:00.920
So in fact, Chess is X-complete.

00:26:00.920 --> 00:26:03.420
It means there's an upper bound
saying that you can solve it

00:26:03.420 --> 00:26:04.277
in exponential time.

00:26:04.277 --> 00:26:06.360
There's a lower bound
saying that it's at least as

00:26:06.360 --> 00:26:07.926
hard as everything in EXP.

00:26:07.926 --> 00:26:10.550
And both are true, so you would
know you're kind of right here.

00:26:10.550 --> 00:26:12.770
From the resolution
of this picture,

00:26:12.770 --> 00:26:15.010
that's all you could
hope to know about Chess.

00:26:18.360 --> 00:26:21.310
So, good.

00:26:24.350 --> 00:26:28.120
One more class of problems
good to know about,

00:26:28.120 --> 00:26:34.870
and it will come up a lot in
games, is the notion of PSPACE.

00:26:34.870 --> 00:26:36.690
So so far, we've only
thought about time.

00:26:36.690 --> 00:26:38.140
But usually, we
measure algorithms

00:26:38.140 --> 00:26:39.300
in terms of time and space.

00:26:39.300 --> 00:26:42.520
How much memory does
your algorithm use?

00:26:42.520 --> 00:26:49.005
And so PSPACE is going to be, I
guess, say let's say problems.

00:26:58.185 --> 00:27:00.060
As you might guess, this
is problems solvable

00:27:00.060 --> 00:27:03.060
in polynomial space.

00:27:03.060 --> 00:27:05.560
In general, if you can solve
a problem in polynomial space,

00:27:05.560 --> 00:27:07.941
you can solve it in
exponential time,

00:27:07.941 --> 00:27:09.940
because there are only
exponentially many states

00:27:09.940 --> 00:27:12.600
of your machine if you
only have polynomial space.

00:27:12.600 --> 00:27:20.320
So PSPACE fits here
in between NP and EXP.

00:27:23.210 --> 00:27:34.154
And of course, there's
PSPACE-hard and

00:27:34.154 --> 00:27:34.820
PSPACE-complete.

00:27:41.190 --> 00:27:43.340
If you don't remember
anything from today

00:27:43.340 --> 00:27:46.740
except one blackboard,
remember this blackboard.

00:27:46.740 --> 00:27:49.590
It's like the cheat sheet
to everything we've defined.

00:27:49.590 --> 00:27:53.040
You just have to remember
what all the letters mean.

00:27:53.040 --> 00:27:54.670
But not too hard.

00:27:54.670 --> 00:27:57.350
So that's pretty much all
the classes we'll be using.

00:27:57.350 --> 00:27:59.060
There are a few others.

00:27:59.060 --> 00:27:59.560
I'm sorry.

00:27:59.560 --> 00:28:03.190
I'll give you one example to
go with our other examples.

00:28:03.190 --> 00:28:05.870
The problem we'll look
at today is Rush Hour.

00:28:08.750 --> 00:28:10.456
This is a one
player puzzle, where

00:28:10.456 --> 00:28:12.580
you're trying to move the
cars, and they could only

00:28:12.580 --> 00:28:15.210
go vertically or horizontally.

00:28:15.210 --> 00:28:21.110
This is in PSPACE, which
is maybe not so obvious.

00:28:21.110 --> 00:28:25.510
And actually, it's
PSPACE-complete.

00:28:25.510 --> 00:28:32.570
So this is from the
diagram, PSPACE-complete

00:28:32.570 --> 00:28:34.787
is harder than NP-complete.

00:28:34.787 --> 00:28:37.370
Now of course, we don't actually
know whether these two points

00:28:37.370 --> 00:28:38.904
are the same.

00:28:38.904 --> 00:28:39.820
It's kind of annoying.

00:28:39.820 --> 00:28:42.014
We don't know whether these
two points are the same.

00:28:42.014 --> 00:28:44.180
We don't know whether these
two points are the same.

00:28:44.180 --> 00:28:45.801
This whole thing could collapse.

00:28:45.801 --> 00:28:47.550
We do know these two
points are different.

00:28:47.550 --> 00:28:51.890
So somewhere here, or here, or
here, we have a positive range.

00:28:51.890 --> 00:28:56.109
Most people believe all of
these have problems in them,

00:28:56.109 --> 00:28:57.650
so none of these
things are the same.

00:28:57.650 --> 00:28:59.941
It could be NP-complete is
the same as PSPACE-complete.

00:28:59.941 --> 00:29:02.960
But again, most people
believe these are different.

00:29:02.960 --> 00:29:05.880
So in some sense, Rush
Hour, which is here,

00:29:05.880 --> 00:29:07.520
is harder than
Tetris, which is here.

00:29:10.730 --> 00:29:11.590
Cool.

00:29:11.590 --> 00:29:16.780
And if you believe that either
one of these is non-empty,

00:29:16.780 --> 00:29:19.460
then we know that Rush Hour
does not have a polynomial time

00:29:19.460 --> 00:29:19.960
algorithm.

00:29:19.960 --> 00:29:23.679
So to show that Rush Hour is
not in P, you have a choice.

00:29:23.679 --> 00:29:25.720
You could prove either
one of these as non-empty.

00:29:25.720 --> 00:29:28.050
For Tetris, you have
to prove this one.

00:29:28.050 --> 00:29:30.690
So you'd be less famous
if you prove this one.

00:29:30.690 --> 00:29:33.190
Still pretty famous, but you
wouldn't win the million dollar

00:29:33.190 --> 00:29:34.650
bounty that's on P versus NP.

00:29:37.380 --> 00:29:38.500
All right.

00:29:38.500 --> 00:29:40.735
There are bigger classes.

00:29:40.735 --> 00:29:42.110
We talked about
exponential time.

00:29:42.110 --> 00:29:44.282
You can, of course, talk
about exponential space.

00:29:44.282 --> 00:29:45.490
In general, these interleave.

00:29:45.490 --> 00:29:48.350
You go polynomial
time, polynomial space,

00:29:48.350 --> 00:29:51.440
exponential time, exponential
space, doubly exponential time,

00:29:51.440 --> 00:29:53.410
doubly exponential
space, and so on.

00:29:53.410 --> 00:29:57.280
That's the order in
which they occur.

00:29:57.280 --> 00:30:00.090
The only things we know
is that polynomial time is

00:30:00.090 --> 00:30:01.520
different from
exponential time is

00:30:01.520 --> 00:30:03.144
different from doubly
exponential time,

00:30:03.144 --> 00:30:05.460
or any function of time, really.

00:30:05.460 --> 00:30:07.860
And we know that
polynomial space

00:30:07.860 --> 00:30:10.360
is different from exponential
space is different from doubly

00:30:10.360 --> 00:30:11.510
exponential space.

00:30:11.510 --> 00:30:13.218
But we don't know
about the interrelation

00:30:13.218 --> 00:30:14.280
between time and space.

00:30:14.280 --> 00:30:16.460
That's one of the big questions.

00:30:16.460 --> 00:30:18.640
The other big question
is non-determinism.

00:30:18.640 --> 00:30:25.300
One fun fact you should know
is that PSPACE equals NPSPACE.

00:30:25.300 --> 00:30:28.420
This is a useful fact.

00:30:28.420 --> 00:30:31.830
NPSPACE is non-deterministic
polynomial space.

00:30:31.830 --> 00:30:33.806
So you take a lucky
algorithm, and you

00:30:33.806 --> 00:30:35.430
don't guarantee how
much time it takes,

00:30:35.430 --> 00:30:37.134
it will be a most
exponential time.

00:30:37.134 --> 00:30:39.050
You only guarantee the
amount of space it uses

00:30:39.050 --> 00:30:42.180
is, at most, polynomial.

00:30:42.180 --> 00:30:44.450
This is a theorem
called Savages Theorem,

00:30:44.450 --> 00:30:45.826
and it works for
any space bound.

00:30:45.826 --> 00:30:47.366
In general, the
space bound, I think,

00:30:47.366 --> 00:30:49.070
grows to the square
of its original,

00:30:49.070 --> 00:30:50.960
if you want to convert
non-deterministic

00:30:50.960 --> 00:30:51.980
to deterministic.

00:30:51.980 --> 00:30:55.191
This is useful for Rush Hour,
because to play a Rush Hour

00:30:55.191 --> 00:30:57.690
game, in general, the number
of moves you might have to make

00:30:57.690 --> 00:31:00.930
is exponential, so
it's not obviously

00:31:00.930 --> 00:31:03.020
in NP, because NP
would have to have

00:31:03.020 --> 00:31:05.200
a short polynomial-length
solution that you

00:31:05.200 --> 00:31:08.430
can check in polynomial time.

00:31:08.430 --> 00:31:10.726
But Rush Hour, you can
solve in polynomial space

00:31:10.726 --> 00:31:12.600
if you're really lucky
because you say, well,

00:31:12.600 --> 00:31:13.190
what move should I make?

00:31:13.190 --> 00:31:15.449
Well, I'll guess one,
then I'll make that move.

00:31:15.449 --> 00:31:16.240
Guess another move.

00:31:16.240 --> 00:31:17.190
Make the move.

00:31:17.190 --> 00:31:19.650
And just maintaining
the state of the board

00:31:19.650 --> 00:31:21.740
only takes polynomial space.

00:31:21.740 --> 00:31:24.630
So then if you solve
it, you're happy.

00:31:24.630 --> 00:31:27.660
If there's no way to solve
it, you will return No.

00:31:27.660 --> 00:31:29.150
I guess you have a timer.

00:31:29.150 --> 00:31:30.970
After you've made
exponentially many moves,

00:31:30.970 --> 00:31:33.790
if you still haven't solved
the puzzle, you can return No.

00:31:33.790 --> 00:31:35.960
And in the lucky
world, that means

00:31:35.960 --> 00:31:38.270
you will find a solution
if there is one.

00:31:38.270 --> 00:31:39.730
Conveniently, lucky
algorithms can

00:31:39.730 --> 00:31:41.860
be turned into
regular algorithms

00:31:41.860 --> 00:31:43.940
when you're only worried
about space bounds.

00:31:43.940 --> 00:31:47.730
And so that's how you prove
Rush Hour is in PSPACE.

00:31:47.730 --> 00:31:49.400
So that's a good fact to know.

00:31:52.130 --> 00:31:53.630
Cool.

00:31:53.630 --> 00:31:54.130
All right.

00:31:54.130 --> 00:31:56.910
There's one key thing
we haven't defined yet,

00:31:56.910 --> 00:31:59.220
which is as hard as.

00:31:59.220 --> 00:32:01.030
So let's get to that.

00:32:01.030 --> 00:32:05.669
This is really the
heart of the class.

00:32:05.669 --> 00:32:06.460
Let me go up there.

00:32:41.230 --> 00:32:44.910
So this class is really
all about one notion,

00:32:44.910 --> 00:32:47.040
and that notion is reductions.

00:32:47.040 --> 00:32:49.712
So if I have two
problems A and B, then

00:32:49.712 --> 00:32:51.670
there's this notion of
a reduction from A to B.

00:32:51.670 --> 00:32:53.740
This will be an algorithm.

00:32:53.740 --> 00:32:56.480
For us, almost all the time
it will be a polynomial time

00:32:56.480 --> 00:32:59.740
algorithm, although you could
put in a different adjective

00:32:59.740 --> 00:33:01.265
here than polynomial time.

00:33:01.265 --> 00:33:02.890
Most of the time,
that is what we want.

00:33:12.070 --> 00:33:16.480
And it's going to convert an
instance of the A problem--

00:33:16.480 --> 00:33:17.945
so instance just means input--

00:33:20.820 --> 00:33:23.190
and we'll convert it into an
instance of the B problem.

00:33:26.880 --> 00:33:35.770
And it's going to do so in a
way such that the solution to A

00:33:35.770 --> 00:33:42.410
equals the solution
to B. I mean,

00:33:42.410 --> 00:33:45.100
the solution of
that instance of A

00:33:45.100 --> 00:33:48.190
is the same as the solution
of the instance to B.

00:33:48.190 --> 00:33:50.760
So this is-- think
decision problems.

00:33:50.760 --> 00:33:53.085
The answer's either Yes or No.

00:33:53.085 --> 00:33:56.910
So we want to convert A into
an equivalent instance of B,

00:33:56.910 --> 00:34:00.130
equivalent meaning that
it has the same answer.

00:34:00.130 --> 00:34:01.300
Why do we care?

00:34:01.300 --> 00:34:07.890
Because let's suppose we
had an algorithm to solve B.

00:34:07.890 --> 00:34:09.120
That would be this arrow.

00:34:09.120 --> 00:34:16.870
So let's say if we
can solve B, then

00:34:16.870 --> 00:34:20.380
we can solve A by this diagram.

00:34:20.380 --> 00:34:23.969
Take an instance of A, convert
it into an equivalence of B,

00:34:23.969 --> 00:34:27.650
solve B, and then that solution
is equal to the solution to A,

00:34:27.650 --> 00:34:37.300
so we solved A.

00:34:37.300 --> 00:34:39.070
This is as hard as.

00:34:39.070 --> 00:34:51.550
So what we say is
B is as hard as A.

00:34:51.550 --> 00:34:54.400
That's a definition
of this hardness.

00:34:54.400 --> 00:34:56.929
In general, depending on
your definition of reduction,

00:34:56.929 --> 00:34:58.762
you'll get a different
notion of as hard as,

00:34:58.762 --> 00:35:02.680
but we will stick primarily
to polynomial time.

00:35:02.680 --> 00:35:04.120
Reductions.

00:35:04.120 --> 00:35:08.944
This is what you might
call a one call reduction.

00:35:08.944 --> 00:35:10.235
This is kind of a technicality.

00:35:13.690 --> 00:35:15.990
Also called a Karp
style reduction

00:35:15.990 --> 00:35:23.190
because Karp gave a whole bunch
of them in the '70s, '80s.

00:35:23.190 --> 00:35:27.120
So the idea is you only get to
call your solution to be once.

00:35:27.120 --> 00:35:29.330
In general, you could imagine
an algorithm that calls

00:35:29.330 --> 00:35:31.330
your solution to be many times.

00:35:31.330 --> 00:35:33.750
That would also be a
notion of as hard as.

00:35:33.750 --> 00:35:38.022
For the problems we'll look,
basically, these two notions

00:35:38.022 --> 00:35:39.480
don't seem very
helpful, let's say.

00:35:39.480 --> 00:35:41.040
So we'll stick to
one call reductions

00:35:41.040 --> 00:35:44.190
because they seem
sufficient for everything

00:35:44.190 --> 00:35:45.580
that we will cover
in this class.

00:35:45.580 --> 00:35:46.160
Probably.

00:35:46.160 --> 00:35:47.826
Maybe in some very
late lecture, we'll

00:35:47.826 --> 00:35:49.200
talk about multi-call
reductions.

00:35:49.200 --> 00:35:50.630
But they're not so prominent.

00:35:50.630 --> 00:35:54.480
One call reductions are the
bread and butter of hardness.

00:35:54.480 --> 00:35:57.700
So as you might imagine, this
is how you prove a problem hard.

00:35:57.700 --> 00:36:04.060
Basically, all hardness
proofs in the known universe

00:36:04.060 --> 00:36:05.540
are based on a reduction.

00:36:05.540 --> 00:36:07.061
You start from a
problem which you

00:36:07.061 --> 00:36:10.050
know is hard in whatever
class you care about,

00:36:10.050 --> 00:36:12.830
and you reduce from that
problem, the known hard

00:36:12.830 --> 00:36:15.840
problem, to your problem
that you're not sure about.

00:36:15.840 --> 00:36:17.930
If you can do that,
then you prove

00:36:17.930 --> 00:36:20.870
that your problem is as hard
as the original problem.

00:36:20.870 --> 00:36:23.460
If you know that one is
hard, than this one is hard.

00:36:23.460 --> 00:36:26.340
Don't get this backwards.

00:36:26.340 --> 00:36:29.230
You will anyway, but try
not to get it backwards.

00:36:29.230 --> 00:36:32.640
You're always reducing
from the known hard problem

00:36:32.640 --> 00:36:34.201
to your problem.

00:36:34.201 --> 00:36:34.700
OK.

00:36:34.700 --> 00:36:38.650
So usually say, our proof is
based on a reduction from--

00:36:38.650 --> 00:36:39.860
pick your favorite problem.

00:36:39.860 --> 00:36:41.220
Never two.

00:36:41.220 --> 00:36:45.420
Easy to get wrong, because
it's easy to make a sign error.

00:36:45.420 --> 00:36:46.340
But that's life.

00:36:46.340 --> 00:36:49.780
So good.

00:36:49.780 --> 00:36:51.260
Anything else?

00:36:51.260 --> 00:36:53.009
Now if you've taken
an algorithms class,

00:36:53.009 --> 00:36:54.300
you've seen lots of reductions.

00:36:54.300 --> 00:36:57.170
Reductions are a powerful
tool in algorithms too.

00:36:57.170 --> 00:37:01.510
For example, some
lame examples like,

00:37:01.510 --> 00:37:04.000
if you have an unweighted
shortest path problem,

00:37:04.000 --> 00:37:07.799
you can reduce that to a
weighted shortest path problem.

00:37:07.799 --> 00:37:08.590
How do you do that?

00:37:08.590 --> 00:37:09.798
You set all the weights to 1.

00:37:09.798 --> 00:37:11.180
Yay.

00:37:11.180 --> 00:37:12.130
Why would you do that?

00:37:12.130 --> 00:37:12.838
Well, never mind.

00:37:16.170 --> 00:37:18.180
It kind of illustrates
what's going on here.

00:37:18.180 --> 00:37:22.100
What we're showing is
that A is a special case

00:37:22.100 --> 00:37:24.750
of B. Unweighted shortest
paths is a special case

00:37:24.750 --> 00:37:26.070
of weighted shortest paths.

00:37:26.070 --> 00:37:28.250
In some sense, all
reductions are that,

00:37:28.250 --> 00:37:30.010
but they're usually
much less obvious

00:37:30.010 --> 00:37:32.620
than unweighted shortest paths
to weighted shortest paths.

00:37:32.620 --> 00:37:34.250
And the reason we
can say B is as hard

00:37:34.250 --> 00:37:37.734
as A is because [? modular ?]
this conversion algorithm

00:37:37.734 --> 00:37:40.320
A is a special case
of B. So of course,

00:37:40.320 --> 00:37:42.870
if B has more cases than
A, or maybe the same,

00:37:42.870 --> 00:37:45.550
but if it has at least as many
cases as A, then of course,

00:37:45.550 --> 00:37:46.950
B is at at least
as hard to solve

00:37:46.950 --> 00:37:50.000
as A in this formal sense.

00:37:50.000 --> 00:37:51.290
OK.

00:37:51.290 --> 00:37:52.130
Cool.

00:37:52.130 --> 00:37:53.140
There are more
interesting examples

00:37:53.140 --> 00:37:54.681
you've probably seen
in problem sets,

00:37:54.681 --> 00:37:58.250
like if you want in
the arbitrage problem,

00:37:58.250 --> 00:38:01.910
you want to find a path that
has the minimum product of all

00:38:01.910 --> 00:38:04.215
the values, to convert
products into a min.

00:38:04.215 --> 00:38:06.340
Some problem, you just take
logs of all the values.

00:38:06.340 --> 00:38:08.930
So the reduction is compute
logs and all the weights.

00:38:08.930 --> 00:38:11.630
So you've probably seen
lots of things like that.

00:38:11.630 --> 00:38:15.310
Some are more
complicated than others.

00:38:15.310 --> 00:38:20.380
What we're going to do in this
class is reduce instead of--

00:38:20.380 --> 00:38:22.540
so for algorithms, you
want to reduce to something

00:38:22.540 --> 00:38:24.330
you know how to solve.

00:38:24.330 --> 00:38:26.120
We're going to
reduce from something

00:38:26.120 --> 00:38:28.940
we know we can't solve
under certain assumptions.

00:38:28.940 --> 00:38:32.880
So assuming P does not
equal NP, if A is NP-hard

00:38:32.880 --> 00:38:38.820
and we reduce from A to B,
then we know the B is NP-hard.

00:38:38.820 --> 00:38:40.820
That's a theorem.

00:38:40.820 --> 00:38:45.700
So in this situation,
if we have a reduction,

00:38:45.700 --> 00:38:54.290
let's say if A reduces to
B, I'll be explicit, and A--

00:38:54.290 --> 00:38:55.207
better get this right.

00:38:55.207 --> 00:38:57.290
It would be pretty
embarrassing if I got it wrong,

00:38:57.290 --> 00:39:00.020
but I probably will get it wrong
at some point in this class.

00:39:00.020 --> 00:39:02.340
Hopefully not today.

00:39:02.340 --> 00:39:04.660
Then B is X-hard.

00:39:07.010 --> 00:39:07.510
OK.

00:39:07.510 --> 00:39:09.790
That's actually kind
of a trivial theorem

00:39:09.790 --> 00:39:11.454
if you read all the definitions.

00:39:11.454 --> 00:39:12.120
What did X-hard?

00:39:12.120 --> 00:39:16.170
It meant as hard as
every problem in X.

00:39:16.170 --> 00:39:19.470
And as hard as meant
there was a reduction.

00:39:19.470 --> 00:39:21.830
So that means-- get this right--

00:39:21.830 --> 00:39:26.640
there's reduction from every
problem in X to your problem.

00:39:26.640 --> 00:39:28.570
So if A is NP-hard
there's a reduction

00:39:28.570 --> 00:39:30.780
from every problem
to A, and we're

00:39:30.780 --> 00:39:33.330
saying now what if there's
also a reduction from A to B,

00:39:33.330 --> 00:39:34.746
well then, we can
just chain those

00:39:34.746 --> 00:39:37.820
are two reductions together,
convert any problem in X to A,

00:39:37.820 --> 00:39:41.050
then convert it to B. And so
we've shown every problem in X

00:39:41.050 --> 00:39:44.480
can be reduced to B,
where B is X-hard.

00:39:44.480 --> 00:39:46.920
This is an easy theorem.

00:39:46.920 --> 00:39:51.240
The converse would be if B
can be solved in class X,

00:39:51.240 --> 00:39:54.660
and X contains
polynomial time, then

00:39:54.660 --> 00:39:59.750
you could can also solve A
in the same complexity class.

00:39:59.750 --> 00:40:02.050
So for example,
if B is in PSPACE,

00:40:02.050 --> 00:40:03.880
then we learn that
A is in PSPACE.

00:40:03.880 --> 00:40:06.220
Something like that.

00:40:06.220 --> 00:40:08.550
Cool.

00:40:08.550 --> 00:40:11.814
Any questions at this point?

00:40:11.814 --> 00:40:12.715
AUDIENCE: Question.

00:40:12.715 --> 00:40:13.381
PROFESSOR: Yeah?

00:40:13.381 --> 00:40:15.494
AUDIENCE: You've talked
a lot about thi NP thing.

00:40:15.494 --> 00:40:17.952
Why don't you ever talk about
non-deterministic exponential

00:40:17.952 --> 00:40:19.989
orobelms or things like that.

00:40:19.989 --> 00:40:20.572
PROFESSOR: OK.

00:40:20.572 --> 00:40:23.040
Yeah, I didn't define
non-deterministic exponential

00:40:23.040 --> 00:40:24.960
problems, but that's
a valid thing.

00:40:24.960 --> 00:40:27.480
I think it's usually
written NEXP.

00:40:27.480 --> 00:40:31.390
And I believe there
is a class of games

00:40:31.390 --> 00:40:32.990
that naturally fits into NEXP.

00:40:32.990 --> 00:40:36.380
Its mainly an issue of
which classes commonly arise

00:40:36.380 --> 00:40:37.957
in problems that we care about.

00:40:37.957 --> 00:40:39.790
This is a pretty rare
one, but I think there

00:40:39.790 --> 00:40:41.670
might be one instance where--

00:40:41.670 --> 00:40:42.680
we might touch on this.

00:40:42.680 --> 00:40:44.250
Yeah, we definitely can.

00:40:44.250 --> 00:40:47.270
It's the same open problem
where EXP equals NEXP.

00:40:47.270 --> 00:40:48.687
I mean, it's another
open problem.

00:40:48.687 --> 00:40:49.936
I shouldn't say it's the same.

00:40:49.936 --> 00:40:51.872
I think you could solve
one without the other.

00:40:51.872 --> 00:40:53.580
Again, everyone believes
you can't do it.

00:40:53.580 --> 00:40:54.955
If you believe
you can't engineer

00:40:54.955 --> 00:40:58.440
luckiness, then of course,
NEXP doesn't equal EXP.

00:40:58.440 --> 00:41:03.370
But that would fit
right after EXP.

00:41:03.370 --> 00:41:05.730
If you get NEXP, and
then you get EXPSPACE.

00:41:05.730 --> 00:41:08.230
According to the things we've
written down and cared about,

00:41:08.230 --> 00:41:09.646
that would be the
order of things.

00:41:09.646 --> 00:41:12.450
Of course there are
classes in between these,

00:41:12.450 --> 00:41:14.290
but these are the ones
that appear normally.

00:41:14.290 --> 00:41:14.922
Yeah?

00:41:14.922 --> 00:41:17.130
AUDIENCE: Do we know how to
use hardness assumptions,

00:41:17.130 --> 00:41:19.080
for example, P not
equal to NP to say

00:41:19.080 --> 00:41:21.635
whether there exists problems
that are not in P nor NP

00:41:21.635 --> 00:41:23.474
complete?

00:41:23.474 --> 00:41:24.140
PROFESSOR: Yeah.

00:41:24.140 --> 00:41:27.290
That's another
big open question.

00:41:27.290 --> 00:41:29.480
Let's say P does not equal NP.

00:41:29.480 --> 00:41:31.400
Are there problems here?

00:41:31.400 --> 00:41:34.160
Which is to say strictly
in between being--

00:41:34.160 --> 00:41:37.110
so they're still not in P
to the right of this line,

00:41:37.110 --> 00:41:39.450
but they're also easier
than NP-complete problems.

00:41:39.450 --> 00:41:41.330
There are a couple
problems that are famously

00:41:41.330 --> 00:41:46.880
conjectured to live there, like
factoring integers and graph

00:41:46.880 --> 00:41:47.660
isomorphism.

00:41:47.660 --> 00:41:52.860
But I'm not aware of any
nice complexity class there.

00:41:52.860 --> 00:41:55.637
You can, of course, say--

00:41:55.637 --> 00:41:57.220
you can talk about
a class of problems

00:41:57.220 --> 00:42:01.170
that are as hard as graph
isomorphism in a certain sense,

00:42:01.170 --> 00:42:02.380
that if you believe--

00:42:02.380 --> 00:42:05.442
if you have a graph isomorphism
Oracle, what can you do?

00:42:05.442 --> 00:42:07.900
So there's a little bit of work
trying to chart that space,

00:42:07.900 --> 00:42:11.169
but I'd say in general, it's
been not super successful.

00:42:11.169 --> 00:42:12.460
Don't quote me on that, though.

00:42:12.460 --> 00:42:15.310
I also don't know the
literature super well there.

00:42:15.310 --> 00:42:18.832
So that's a big uncharted
territory, let's say.

00:42:18.832 --> 00:42:19.790
Could be a big project.

00:42:19.790 --> 00:42:23.080
Probably lots of
open problems there.

00:42:23.080 --> 00:42:23.870
Other questions?

00:42:23.870 --> 00:42:27.180
I think most people believe
there are things there.

00:42:27.180 --> 00:42:28.680
One thing you could
prove is there's

00:42:28.680 --> 00:42:31.870
a thing called exponential
time hypothesis, which

00:42:31.870 --> 00:42:35.510
would say that [? sat ?] has
no sub-exponential algorithm.

00:42:35.510 --> 00:42:37.210
Nothing to the
[? little o of ?] N.

00:42:37.210 --> 00:42:39.296
If you believe that,
then it's known

00:42:39.296 --> 00:42:40.670
there are some
things in between.

00:42:40.670 --> 00:42:42.355
You can pick your
favorite function, like N

00:42:42.355 --> 00:42:44.438
to Log [? Log ?] N. That's
bigger than polynomial,

00:42:44.438 --> 00:42:46.000
but smaller than exponential.

00:42:46.000 --> 00:42:49.267
And there are problems that are
in that class and not [? NP. ?]

00:42:49.267 --> 00:42:50.850
So definitely with
ETH, you can do it.

00:42:50.850 --> 00:42:51.961
Yeah.

00:42:51.961 --> 00:42:53.502
AUDIENCE: So regarding
that question,

00:42:53.502 --> 00:42:57.560
I think it has been proven
that if P not equal NP, then

00:42:57.560 --> 00:42:58.652
there is stuff in there.

00:42:58.652 --> 00:42:59.652
PROFESSOR: Oh, there is.

00:42:59.652 --> 00:43:00.500
Yeah.

00:43:00.500 --> 00:43:03.240
AUDIENCE: Or you can kind
of do a diagonalization.

00:43:03.240 --> 00:43:05.190
PROFESSOR: Other questions?

00:43:05.190 --> 00:43:05.690
Yeah?

00:43:05.690 --> 00:43:09.180
AUDIENCE: What's the decision
problem for the factoring?

00:43:09.180 --> 00:43:11.900
PROFESSOR: Decision
problem for factoring.

00:43:11.900 --> 00:43:16.090
I think one version is
I give you a number,

00:43:16.090 --> 00:43:18.190
and I give you a
bit position, and I

00:43:18.190 --> 00:43:21.280
want to know whether there
is a factor that has a 0 or 1

00:43:21.280 --> 00:43:22.537
in that position.

00:43:22.537 --> 00:43:24.870
So if you can solve the
problem, then by repeated calls,

00:43:24.870 --> 00:43:29.900
you could actually find
a factor that's not 1.

00:43:29.900 --> 00:43:32.025
I don't know if there's a
better version than that.

00:43:32.025 --> 00:43:34.191
You have to be careful, of
course, if you say, well,

00:43:34.191 --> 00:43:35.180
is the number prime?

00:43:35.180 --> 00:43:36.830
Then that's in polynomial time.

00:43:36.830 --> 00:43:39.080
That was a big result
a bunch of years ago.

00:43:39.080 --> 00:43:40.340
So, yeah.

00:43:43.670 --> 00:43:46.750
Most of the time, it's easy
to go from your optimization

00:43:46.750 --> 00:43:48.580
problem to a decision problem.

00:43:48.580 --> 00:43:53.876
But factoring is one
where it's less clear.

00:43:53.876 --> 00:43:54.500
More questions?

00:43:59.020 --> 00:44:01.350
That was a lot in a
small amount of time.

00:44:01.350 --> 00:44:03.600
But that's all you should
need from complexity theory.

00:44:03.600 --> 00:44:04.309
Yeah?

00:44:04.309 --> 00:44:04.850
AUDIENCE: OK.

00:44:04.850 --> 00:44:08.329
I guess I have a question
about the way you defined NP

00:44:08.329 --> 00:44:10.036
with the [INAUDIBLE] algorithms?

00:44:10.036 --> 00:44:10.660
PROFESSOR: Yup.

00:44:10.660 --> 00:44:12.201
AUDIENCE: So the
definition that I've

00:44:12.201 --> 00:44:15.542
seen before is in
terms of [INAUDIBLE]..

00:44:15.542 --> 00:44:16.250
PROFESSOR: Right.

00:44:16.250 --> 00:44:19.140
AUDIENCE: And there, it
specifically constrains

00:44:19.140 --> 00:44:22.638
every branch in the computation
to run polynomial time,

00:44:22.638 --> 00:44:27.136
whereas you can imagine a lucky
algorithm that avoids infinite

00:44:27.136 --> 00:44:29.387
looping just because it's lucky.

00:44:29.387 --> 00:44:29.970
PROFESSOR: Oh.

00:44:29.970 --> 00:44:30.330
OK.

00:44:30.330 --> 00:44:30.960
Yeah.

00:44:30.960 --> 00:44:33.240
I was a little vague here.

00:44:33.240 --> 00:44:35.340
For the definition of NP
, I said polynomial time

00:44:35.340 --> 00:44:36.780
in the worst case.

00:44:36.780 --> 00:44:39.140
Probably I need to say it's
polynomial time no matter

00:44:39.140 --> 00:44:42.470
what branch you take.

00:44:42.470 --> 00:44:44.160
Not sure it matters.

00:44:44.160 --> 00:44:46.880
Because maybe if you
know your algorithm's

00:44:46.880 --> 00:44:50.100
supposed to run in polynomial
time, you could have a timer,

00:44:50.100 --> 00:44:53.630
and if it ever exceeds
that time, just return no.

00:44:53.630 --> 00:44:56.250
So you might be able
to convert the weaker

00:44:56.250 --> 00:44:58.370
notion of polynomial
time to the stronger one.

00:44:58.370 --> 00:45:01.310
But it won't matter too much.

00:45:01.310 --> 00:45:04.160
I mean, in all the
algorithms we'll think about,

00:45:04.160 --> 00:45:06.340
every branch you could
possibly think of even,

00:45:06.340 --> 00:45:08.090
the non-lucky ones,
are polynomial time.

00:45:08.090 --> 00:45:10.339
So we will stick to that.

00:45:10.339 --> 00:45:12.130
We won't spend much
time in general proving

00:45:12.130 --> 00:45:13.931
that problems are
in NP or NPSPACE,

00:45:13.931 --> 00:45:15.930
only to check that this
is the right class we're

00:45:15.930 --> 00:45:17.180
supposed to be working in.

00:45:17.180 --> 00:45:19.950
We'll spend most of our time
proving the hardness cases,

00:45:19.950 --> 00:45:20.960
the lower bounds.

00:45:20.960 --> 00:45:22.014
Yeah?

00:45:22.014 --> 00:45:23.966
AUDIENCE: So you
mentioned that if you

00:45:23.966 --> 00:45:27.142
use different notions of a
reduction, different limit

00:45:27.142 --> 00:45:28.994
space equally on
the competition,

00:45:28.994 --> 00:45:31.167
you get different
measures of as hard as.

00:45:31.167 --> 00:45:31.793
PROFESSOR: Yes.

00:45:31.793 --> 00:45:33.458
AUDIENCE: So as your
classes get bigger,

00:45:33.458 --> 00:45:35.739
does it matter if you start
using more polynomial time

00:45:35.739 --> 00:45:36.488
in your reduction?

00:45:36.488 --> 00:45:38.720
Does it actually change?

00:45:38.720 --> 00:45:40.200
PROFESSOR: I'm sure it matters.

00:45:40.200 --> 00:45:43.980
But again, it's
beyond the classes

00:45:43.980 --> 00:45:46.750
that are usually considered
from an algorithmic standpoint.

00:45:46.750 --> 00:45:49.250
Bigger than these classes
don't seem to matter much.

00:45:49.250 --> 00:45:51.500
And in these, maybe
once I've seen like,

00:45:51.500 --> 00:45:54.990
a polynomial space reduction
to prove X-hardness,

00:45:54.990 --> 00:45:56.850
so it's a slightly
weaker notion than if you

00:45:56.850 --> 00:46:00.520
do a polynomial time
reduction, but if you

00:46:00.520 --> 00:46:04.040
believe PSPACE does not equal
X, but still a separation.

00:46:04.040 --> 00:46:06.280
So sometimes, things
like that happen.

00:46:06.280 --> 00:46:08.510
I think the most common is
just switching to a space

00:46:08.510 --> 00:46:10.832
measure over time measure.

00:46:10.832 --> 00:46:13.040
I don't think it will matter
in anything we see here.

00:46:13.040 --> 00:46:15.540
But it does arise
in the literature.

00:46:15.540 --> 00:46:17.000
Definitely.

00:46:17.000 --> 00:46:20.740
I think PSPACE or log space
are the two common ones.

00:46:20.740 --> 00:46:24.132
And of course, when you're doing
P-completeness, it's another.

00:46:24.132 --> 00:46:25.341
Yeah?

00:46:25.341 --> 00:46:27.340
AUDIENCE: You mentioned
setting it [INAUDIBLE],,

00:46:27.340 --> 00:46:29.850
and I'm curious how
you could do that.

00:46:29.850 --> 00:46:35.090
Because for any
instance of the problem,

00:46:35.090 --> 00:46:37.950
you can't say that I've
used exponential time.

00:46:37.950 --> 00:46:40.707
It could just be that there's
a bigger constant out front.

00:46:40.707 --> 00:46:41.290
PROFESSOR: OK.

00:46:41.290 --> 00:46:44.100
Yeah, so you need to know
what the polynomial is

00:46:44.100 --> 00:46:45.860
for it to have a timer.

00:46:45.860 --> 00:46:47.275
That's a small catch.

00:46:50.110 --> 00:46:50.610
Yeah.

00:46:50.610 --> 00:46:53.780
I don't see an easy
way to avoid that.

00:46:53.780 --> 00:46:54.280
Yeah.

00:46:54.280 --> 00:46:57.061
There's some few subtle
constructive issues there.

00:46:57.061 --> 00:46:58.560
If you don't know
what the bound is,

00:46:58.560 --> 00:46:59.927
then things get more annoying.

00:46:59.927 --> 00:47:01.760
None of those things
will happen in reality.

00:47:01.760 --> 00:47:04.390
So remember, this not
a complexity class.

00:47:04.390 --> 00:47:08.090
We're looking at
algorithms here.

00:47:08.090 --> 00:47:09.510
This part is actually easy.

00:47:09.510 --> 00:47:11.830
It's all about the reductions.

00:47:11.830 --> 00:47:14.520
That's where the meat
of this class will be.

00:47:14.520 --> 00:47:17.980
And for that, we need
to get NP-hardcore.

00:47:17.980 --> 00:47:20.370
AUDIENCE: [LAUGHING].

00:47:20.370 --> 00:47:23.600
PROFESSOR: I think all of
you soon will be NP-hardore,

00:47:23.600 --> 00:47:27.520
and we'll be able to prove
really hard problems really

00:47:27.520 --> 00:47:29.570
hard.

00:47:29.570 --> 00:47:32.830
So in the spirit
of NP-hardcoreness,

00:47:32.830 --> 00:47:36.250
we're going to take the classic
of hardcore video games, Super

00:47:36.250 --> 00:47:37.480
Mario Brothers.

00:47:37.480 --> 00:47:41.150
And our first proof will be
that Mario Brothers is NP-hard.

00:47:41.150 --> 00:47:43.290
This got lots of
press, like here's

00:47:43.290 --> 00:47:45.020
Kotaku saying, "Science
proves old video

00:47:45.020 --> 00:47:46.654
games were super hard."

00:47:46.654 --> 00:47:49.440
AUDIENCE: [LAUGHING].

00:47:49.440 --> 00:47:54.060
PROFESSOR: This is proving
the obvious, I guess.

00:47:54.060 --> 00:47:56.890
But anyway.

00:47:56.890 --> 00:48:00.720
So let me tell you a little
bit about how this proof goes,

00:48:00.720 --> 00:48:01.870
and then we will see it.

00:48:18.160 --> 00:48:19.270
All right.

00:48:19.270 --> 00:48:24.040
So we need a problem
to reduce from.

00:48:24.040 --> 00:48:25.410
The problem is 3SAT.

00:48:25.410 --> 00:48:28.074
This is probably the most
common problem to reduce from.

00:48:28.074 --> 00:48:29.740
We will spend a bunch
of lectures on it.

00:48:29.740 --> 00:48:31.710
It won't be our very
next class, but we

00:48:31.710 --> 00:48:32.905
will get to it pretty soon.

00:48:32.905 --> 00:48:34.530
This is also known
as 3-Satisfiability.

00:48:37.250 --> 00:48:39.380
If you're ever trying
to prove NP-hardness

00:48:39.380 --> 00:48:42.040
and you don't know where to
start from, the answer is 3SAT.

00:48:42.040 --> 00:48:44.005
Almost always, but not always.

00:48:47.647 --> 00:48:51.976
AUDIENCE: [LAUGHING]

00:48:51.976 --> 00:48:53.419
PROFESSOR: OK.

00:48:53.419 --> 00:48:54.880
Whatever.

00:48:54.880 --> 00:48:56.590
So what's the problem?

00:48:56.590 --> 00:49:00.320
You're given a 3CNF formula.

00:49:00.320 --> 00:49:06.330
This means something
like x5, or I'll

00:49:06.330 --> 00:49:14.180
be nice and write
English, or x3, or not x1.

00:49:17.120 --> 00:49:27.510
And another thing like
that. x7, or not x2, or x5.

00:49:27.510 --> 00:49:28.010
Whatever.

00:49:31.570 --> 00:49:35.590
So some key words
you should know.

00:49:35.590 --> 00:49:36.126
xI's.

00:49:36.126 --> 00:49:37.250
Those are called variables.

00:49:40.500 --> 00:49:42.690
xI or not xI.

00:49:42.690 --> 00:49:46.560
Those are called literals.

00:49:46.560 --> 00:49:47.490
You have two choices.

00:49:47.490 --> 00:49:49.410
You could either have
a positive variable

00:49:49.410 --> 00:49:51.400
or a negative variable.

00:49:51.400 --> 00:49:56.580
Then you always have
three literals per clause.

00:49:56.580 --> 00:49:57.830
These things are called--

00:49:57.830 --> 00:50:00.375
each row of this thing that
I drew is called a clause.

00:50:03.480 --> 00:50:05.600
The whole thing's
called a formula.

00:50:05.600 --> 00:50:09.740
And the question is, can
you make this formula true?

00:50:09.740 --> 00:50:13.020
So that's what you want to know.

00:50:13.020 --> 00:50:19.929
Do there exist xI's such
that the formula is true?

00:50:19.929 --> 00:50:21.095
That's the decision problem.

00:50:25.550 --> 00:50:26.570
And it's NP-complete.

00:50:29.277 --> 00:50:31.360
It is almost the first
problem proved NP-complete.

00:50:37.030 --> 00:50:40.220
It's like the second
problem that's NP-complete.

00:50:40.220 --> 00:50:44.730
The first one was without
this particular style.

00:50:44.730 --> 00:50:46.790
It was just a bunch of
ands and or's and nots

00:50:46.790 --> 00:50:48.760
in any combination.

00:50:48.760 --> 00:50:50.850
But this is also hard,
and it's usually easier

00:50:50.850 --> 00:50:52.600
to start from this situation.

00:50:52.600 --> 00:50:56.110
So what we want to do
is reduce from 3SAT

00:50:56.110 --> 00:50:58.361
to Super Mario Brothers.

00:50:58.361 --> 00:50:58.860
OK.

00:50:58.860 --> 00:51:03.060
So let's do it.

00:51:03.060 --> 00:51:05.465
So I should mention our proof
holds Super Mario Brothers

00:51:05.465 --> 00:51:09.044
1, Lost Levels, and 3.

00:51:09.044 --> 00:51:10.710
Super Mario Brothers
2 is another world.

00:51:10.710 --> 00:51:14.750
Also, Super Mario
Worlds, I think 1 and 2.

00:51:14.750 --> 00:51:18.810
But most the pictures will be
Super Mario Brothers Original.

00:51:18.810 --> 00:51:22.220
So what we're going to
do are build gadgets.

00:51:22.220 --> 00:51:24.450
Gadgets are in this
case little pieces

00:51:24.450 --> 00:51:26.810
of levels that we're
going to join together

00:51:26.810 --> 00:51:29.180
to make the actual reduction.

00:51:29.180 --> 00:51:31.595
So it's usually--
it's not typical

00:51:31.595 --> 00:51:35.190
that you look at the instance of
A, and just think really hard,

00:51:35.190 --> 00:51:39.020
and then just output an
instance of B from nowhere.

00:51:39.020 --> 00:51:42.860
You just say, well, OK, instance
of A has lots of little pieces.

00:51:42.860 --> 00:51:44.640
It's got variables,
and literals,

00:51:44.640 --> 00:51:46.257
and clauses, and a formula.

00:51:46.257 --> 00:51:48.340
I'm just going to take
each of those little pieces

00:51:48.340 --> 00:51:50.505
and convert them into a
little piece in my output,

00:51:50.505 --> 00:51:52.049
and then just string
them altogether

00:51:52.049 --> 00:51:54.465
in a usually fairly obvious
way, though sometimes, there's

00:51:54.465 --> 00:51:55.910
some subtleties there.

00:51:55.910 --> 00:51:58.270
Almost all of our proofs
will follow this structure.

00:51:58.270 --> 00:52:00.020
This is gadget
structure, and this is

00:52:00.020 --> 00:52:01.540
the thing you're here to learn.

00:52:01.540 --> 00:52:02.880
And it's super cool.

00:52:02.880 --> 00:52:05.870
Because once you know
that you want to do 3SAT,

00:52:05.870 --> 00:52:08.330
you're like, OK, I need
variables in closets.

00:52:08.330 --> 00:52:10.570
So here's the variable.

00:52:10.570 --> 00:52:12.450
Got Mario on the top.

00:52:12.450 --> 00:52:17.720
Mario has to decide should
he go left or right?

00:52:17.720 --> 00:52:19.680
I mean, you could
go back, but if you

00:52:19.680 --> 00:52:22.560
want to go through
this gadget, you

00:52:22.560 --> 00:52:24.470
can either fall
left or fall right.

00:52:24.470 --> 00:52:27.170
And all of these heights
are so large that once you

00:52:27.170 --> 00:52:29.420
make that decision, you can't
come back up because you

00:52:29.420 --> 00:52:32.120
have a limited jump height.

00:52:32.120 --> 00:52:32.790
OK.

00:52:32.790 --> 00:52:35.430
Here's the clause gadget.

00:52:35.430 --> 00:52:38.290
So the idea of variables
we're choosing,

00:52:38.290 --> 00:52:40.750
do I set x5 to be true or false?

00:52:40.750 --> 00:52:43.047
Let's say the left branch
corresponds to true,

00:52:43.047 --> 00:52:44.630
the right branch
corresponds to false.

00:52:44.630 --> 00:52:46.296
How that happens,
we'll see in a moment.

00:52:46.296 --> 00:52:48.790
That's about how the
gadgets fit together.

00:52:48.790 --> 00:52:51.390
Clause gadget has two parts.

00:52:51.390 --> 00:52:54.370
On the one hand, you have
these three entry points

00:52:54.370 --> 00:52:58.810
where your goal is to hit
koopas and bounce them around.

00:52:58.810 --> 00:53:02.030
And then the other part is down
here, is a bunch of bricks.

00:53:02.030 --> 00:53:05.200
And at the end of the level,
we're going to set it up

00:53:05.200 --> 00:53:08.820
so Mario has to go
through this part.

00:53:08.820 --> 00:53:11.230
And this will be
traversable if and only

00:53:11.230 --> 00:53:13.300
if these bricks
have been broken.

00:53:13.300 --> 00:53:16.200
So how would you do that?

00:53:16.200 --> 00:53:19.430
This brick-- well, various
things are in the way here,

00:53:19.430 --> 00:53:23.840
so what you need to do--

00:53:23.840 --> 00:53:24.717
interesting.

00:53:24.717 --> 00:53:26.800
But we're going to change
this gadget in a second.

00:53:26.800 --> 00:53:28.216
I already see some
issues with it.

00:53:28.216 --> 00:53:30.270
But this was our original.

00:53:30.270 --> 00:53:32.740
Original proof
didn't get published,

00:53:32.740 --> 00:53:36.340
and we ended up fixing it
before we submitted it.

00:53:36.340 --> 00:53:40.270
So the idea is what we want
Mario to do is come down here,

00:53:40.270 --> 00:53:43.135
hit the koopa, and then
knock the shell out here,

00:53:43.135 --> 00:53:44.760
and it will bounce
and eventually break

00:53:44.760 --> 00:53:45.850
all these bricks.

00:53:45.850 --> 00:53:46.870
Right?

00:53:46.870 --> 00:53:49.560
Well, no, that would be
Super Mario Brothers 3, where

00:53:49.560 --> 00:53:51.230
turtles actually break bricks.

00:53:51.230 --> 00:53:53.090
In Super Mario
Brothers 1, they don't.

00:53:53.090 --> 00:53:57.380
So we will use a
different gadget

00:53:57.380 --> 00:54:00.930
with fire bars and
question blocks

00:54:00.930 --> 00:54:04.010
with invincibility
stars in them.

00:54:04.010 --> 00:54:04.510
OK.

00:54:04.510 --> 00:54:06.210
So same idea.

00:54:06.210 --> 00:54:08.800
There are three
entrances down here.

00:54:08.800 --> 00:54:11.030
If you hit any one of
them, then the star

00:54:11.030 --> 00:54:13.170
will just float
around here forever.

00:54:13.170 --> 00:54:13.900
We tested it.

00:54:13.900 --> 00:54:16.550
It goes there for as long
as the level can last.

00:54:16.550 --> 00:54:20.480
Then later, if you come
here, lots of testing

00:54:20.480 --> 00:54:23.040
involved, of course.

00:54:23.040 --> 00:54:25.697
Later if you come into here,
and you can get the star,

00:54:25.697 --> 00:54:28.030
you have just enough time to
run through all these fire.

00:54:28.030 --> 00:54:30.630
Bars if you don't, you will die.

00:54:30.630 --> 00:54:31.130
OK?

00:54:31.130 --> 00:54:34.110
So that's the clause gadget.

00:54:34.110 --> 00:54:37.710
So if you visit in at least
one of these three places--

00:54:37.710 --> 00:54:39.480
you can visit all
of them, it doesn't

00:54:39.480 --> 00:54:42.160
help to have three stars
versus one in this case,

00:54:42.160 --> 00:54:45.270
because they don't
stack or anything--

00:54:45.270 --> 00:54:49.160
then and only then can you
go through the top part.

00:54:49.160 --> 00:54:51.610
This is what we might call
a traversal, and this is--

00:54:51.610 --> 00:54:55.079
you could call it setting
the gadget to True.

00:54:55.079 --> 00:54:56.370
How does this all fit together?

00:54:56.370 --> 00:54:58.520
This is sort of
the bigger issue.

00:54:58.520 --> 00:55:02.780
So we're going to take
this three set instance.

00:55:02.780 --> 00:55:05.780
It's got variables and clauses.

00:55:05.780 --> 00:55:09.040
And let's ignore the
negations for now.

00:55:09.040 --> 00:55:10.525
Am I going to ignore them?

00:55:10.525 --> 00:55:11.900
No, I'm not going
to ignore them.

00:55:11.900 --> 00:55:15.370
But on the one hand,
we have variables.

00:55:15.370 --> 00:55:16.830
On the other hand,
we have clauses.

00:55:16.830 --> 00:55:19.080
And we're going to
connect each variable

00:55:19.080 --> 00:55:21.470
to the clause that contains it.

00:55:21.470 --> 00:55:24.640
So this is an actual set
of four clauses here,

00:55:24.640 --> 00:55:26.220
and you can trace them all.

00:55:26.220 --> 00:55:29.640
So the claim is that
x in the positive form

00:55:29.640 --> 00:55:31.940
appears in the first clause
and the second clause.

00:55:31.940 --> 00:55:33.960
You can see there's an
x here and an x here.

00:55:33.960 --> 00:55:36.940
It appears in the negative
one-- this is not x--

00:55:36.940 --> 00:55:43.640
in clause three and four,
because here's not x and not x.

00:55:43.640 --> 00:55:44.339
And so on.

00:55:44.339 --> 00:55:46.630
So that's what all these
connections in the middle are.

00:55:46.630 --> 00:55:48.570
In general, it's kind
of a bipartite graph.

00:55:48.570 --> 00:55:50.640
You've got variables on
the one side, clauses

00:55:50.640 --> 00:55:52.740
on the other side,
and we happened

00:55:52.740 --> 00:55:56.110
to have coalesced
things in these groups.

00:55:56.110 --> 00:55:59.210
What these edges are now
going to be converted into

00:55:59.210 --> 00:56:01.470
are paths for Mario to follow.

00:56:01.470 --> 00:56:04.070
So this is the variable gadget.

00:56:04.070 --> 00:56:05.010
It's this thing.

00:56:05.010 --> 00:56:06.900
We're just going to
plug that in here.

00:56:06.900 --> 00:56:09.090
So the idea is you
enter from here,

00:56:09.090 --> 00:56:13.630
and then you have two
ways that you can go,

00:56:13.630 --> 00:56:16.470
either the true way
or the false way.

00:56:16.470 --> 00:56:18.320
If you set the
variable to True, you

00:56:18.320 --> 00:56:21.760
can then go and visit
the corresponding clauses

00:56:21.760 --> 00:56:26.240
that contain it and
get one of the stars.

00:56:26.240 --> 00:56:26.810
OK.

00:56:26.810 --> 00:56:28.985
Now, for each
variable, you only get

00:56:28.985 --> 00:56:30.360
to make one of
those choices then

00:56:30.360 --> 00:56:34.830
you satisfy all the causes
that contain that literal.

00:56:34.830 --> 00:56:37.470
And then when you're done, you
can walk to the next variable.

00:56:40.270 --> 00:56:43.300
So there's actually two
entrances to the variable.

00:56:43.300 --> 00:56:44.620
I guess that kind of matters.

00:56:44.620 --> 00:56:45.990
What we want in the variable--

00:56:45.990 --> 00:56:47.972
so you came from
the True setting,

00:56:47.972 --> 00:56:49.430
or you came from
the False setting,

00:56:49.430 --> 00:56:51.460
you don't want to be
able to run and jump over

00:56:51.460 --> 00:56:52.890
to the other side
and the satisfy

00:56:52.890 --> 00:56:54.880
the previous variable
both true and false.

00:56:54.880 --> 00:56:56.950
You only get to make one choice.

00:56:56.950 --> 00:56:59.140
Lots of things check here.

00:56:59.140 --> 00:57:01.250
Then in the end, at the
very end after you've

00:57:01.250 --> 00:57:03.650
set the last variable,
you have to traverse

00:57:03.650 --> 00:57:05.829
all of these clauses
through the fire bars.

00:57:05.829 --> 00:57:07.620
And that's going to be
possible if and only

00:57:07.620 --> 00:57:10.842
if every one of the
causes has a star in it.

00:57:10.842 --> 00:57:13.850
In other words, the variables
satisfy all the clauses.

00:57:13.850 --> 00:57:15.570
In other words, the
formula is true,

00:57:15.570 --> 00:57:18.520
because the clauses are
combined with an and.

00:57:18.520 --> 00:57:19.090
OK?

00:57:19.090 --> 00:57:21.110
That is in a nutshell the proof.

00:57:21.110 --> 00:57:22.868
Once you've made
this construction

00:57:22.868 --> 00:57:31.850
that the solution to 3SAT is
equal to the solution to Mario

00:57:31.850 --> 00:57:34.630
in general, you want to
prove on the one hand

00:57:34.630 --> 00:57:37.410
if the answer is yes
to 3SAT, if there's

00:57:37.410 --> 00:57:39.550
a valid setting
for the variables,

00:57:39.550 --> 00:57:42.130
then there is a solution
to this Mario instance.

00:57:42.130 --> 00:57:43.820
You can actually
solve the level.

00:57:43.820 --> 00:57:45.860
The decision question
here is, can I make it

00:57:45.860 --> 00:57:46.859
to the end of the level?

00:57:46.859 --> 00:57:48.950
There's a flag over there.

00:57:48.950 --> 00:57:52.820
And conversely, if there is an
actual solution to this puzzle,

00:57:52.820 --> 00:57:54.850
you want to show that
you can convert it

00:57:54.850 --> 00:57:58.180
into a valid setting for 3SAT
that satisfies the formula.

00:57:58.180 --> 00:57:59.300
You need to check both.

00:57:59.300 --> 00:58:02.930
That gives you
the equality here.

00:58:02.930 --> 00:58:04.192
Question?

00:58:04.192 --> 00:58:07.590
AUDIENCE: Don't you need
this graph to be planar?

00:58:07.590 --> 00:58:08.690
PROFESSOR: Good question.

00:58:08.690 --> 00:58:11.730
This graph is not planar, and
so there are these crossings.

00:58:11.730 --> 00:58:15.060
So there's one more gadget,
the crossover gadget.

00:58:15.060 --> 00:58:17.835
And this is on the poster,
so if you were analyzing it.

00:58:17.835 --> 00:58:19.335
There are many ways
to do crossover,

00:58:19.335 --> 00:58:21.780
and this one is kind of
overkill unless I tell you

00:58:21.780 --> 00:58:25.410
that Super Mario Brothers
has tons of hacks and cheats

00:58:25.410 --> 00:58:27.390
that you can play,
and run through walls,

00:58:27.390 --> 00:58:28.100
and crazy things.

00:58:28.100 --> 00:58:30.620
But never mind that.

00:58:30.620 --> 00:58:33.160
The idea here is
you are a big Mario.

00:58:33.160 --> 00:58:35.276
At the beginning of a
level, there's a mushroom.

00:58:35.276 --> 00:58:36.400
And you better not lose it.

00:58:36.400 --> 00:58:38.060
Otherwise, you're in trouble.

00:58:38.060 --> 00:58:40.900
So on the one hand, I can
go from left to right.

00:58:40.900 --> 00:58:42.580
It's a directional crossover.

00:58:42.580 --> 00:58:43.920
Or I can go from--

00:58:43.920 --> 00:58:46.310
this is the bottom to the top.

00:58:46.310 --> 00:58:47.910
But I can't go from
bottom to right.

00:58:47.910 --> 00:58:49.270
I can't go from bottom to left.

00:58:49.270 --> 00:58:51.380
All these sorts of things.

00:58:51.380 --> 00:58:52.630
Why?

00:58:52.630 --> 00:58:53.130
OK.

00:58:53.130 --> 00:58:55.460
Let's do the
positive case first.

00:58:55.460 --> 00:58:56.490
Say I'm from the bottom.

00:58:56.490 --> 00:58:57.140
I fall here.

00:58:57.140 --> 00:58:58.130
Can't go back.

00:58:58.130 --> 00:58:59.630
I can jump.

00:58:59.630 --> 00:59:02.090
If I'm big Mario, I can break
through a couple bricks,

00:59:02.090 --> 00:59:04.020
and then I can escape.

00:59:04.020 --> 00:59:04.770
OK?

00:59:04.770 --> 00:59:08.882
But I could run under here.

00:59:08.882 --> 00:59:11.340
For example, if you're good,
you can crouch slide, and then

00:59:11.340 --> 00:59:12.548
jump, jump, jump, jump, jump.

00:59:12.548 --> 00:59:13.590
You get to here.

00:59:13.590 --> 00:59:15.520
But you cannot get through this.

00:59:15.520 --> 00:59:17.750
Or maybe I need to
add one more wiggle.

00:59:17.750 --> 00:59:19.310
A little easier
to see over here.

00:59:19.310 --> 00:59:21.580
Maybe I can get
here and move over.

00:59:21.580 --> 00:59:23.580
But if you're in
this position, you

00:59:23.580 --> 00:59:27.300
have no momentum you
can gain, and so you

00:59:27.300 --> 00:59:29.180
can't crouch slide into there.

00:59:29.180 --> 00:59:33.510
So if you're here coming from
the bottom, you can't get out.

00:59:33.510 --> 00:59:37.960
Alternatively, if you
come from the left--

00:59:37.960 --> 00:59:39.960
it's so tempting
to kill the goomba.

00:59:39.960 --> 00:59:42.430
But instead of
killing him, you take

00:59:42.430 --> 00:59:44.660
damage, become small
Mario, then you

00:59:44.660 --> 00:59:46.445
can traverse through
here, because you

00:59:46.445 --> 00:59:47.570
don't need to crouch slide.

00:59:47.570 --> 00:59:48.630
You just jump.

00:59:48.630 --> 00:59:51.580
And there's another mushroom
for you to restore big Mario

00:59:51.580 --> 00:59:53.446
and restore the invariant.

00:59:53.446 --> 00:59:55.320
And you better take it
because otherwise, you

00:59:55.320 --> 00:59:57.910
can't get out through here.

00:59:57.910 --> 01:00:02.780
So you're almost forced to go
left to right or bottom to top.

01:00:02.780 --> 01:00:04.880
Now if you traverse
both of these gadgets

01:00:04.880 --> 01:00:07.900
in both directions,
then all bets are off.

01:00:07.900 --> 01:00:09.950
Then you can go from
anywhere to anywhere.

01:00:09.950 --> 01:00:11.420
That's OK.

01:00:11.420 --> 01:00:15.480
Because what we're
worried about in

01:00:15.480 --> 01:00:19.934
this reduction is whether
you can reach certain things.

01:00:19.934 --> 01:00:22.475
If you can reach something, I
don't care whether you reach it

01:00:22.475 --> 01:00:24.307
now or later.

01:00:24.307 --> 01:00:26.140
It's just you don't
want to be able to reach

01:00:26.140 --> 01:00:26.940
unreachable things.

01:00:26.940 --> 01:00:28.590
When you set the
variable to True,

01:00:28.590 --> 01:00:32.070
I don't want to be able to
visit this false vertex ever.

01:00:32.070 --> 01:00:34.670
And if you check
all the crossovers,

01:00:34.670 --> 01:00:38.500
it's enough to build this kind
of thing, which either you

01:00:38.500 --> 01:00:41.250
traverse left to right,
or bottom to top,

01:00:41.250 --> 01:00:44.010
or you can reach both
the left and the bottom,

01:00:44.010 --> 01:00:46.150
and then you can reach anything.

01:00:46.150 --> 01:00:47.822
And you never have
to go right to left.

01:00:47.822 --> 01:00:49.280
You never have to
go top to bottom.

01:00:49.280 --> 01:00:50.988
Because we always know
the order in which

01:00:50.988 --> 01:00:52.480
we're traversing
things and so on.

01:00:52.480 --> 01:00:52.980
OK.

01:00:52.980 --> 01:00:54.690
I think I've waved
my hands enough.

01:00:54.690 --> 01:00:57.252
There are details to check,
but if you're interested,

01:00:57.252 --> 01:00:59.460
you can wait 'til this part
of the class, where we'll

01:00:59.460 --> 01:01:06.600
cover the Legend of Zelda,
Pokemon, Metroid, and I'm

01:01:06.600 --> 01:01:07.820
missing one.

01:01:07.820 --> 01:01:09.300
Donkey Kong Country.

01:01:09.300 --> 01:01:11.340
Donkey Kong Country
is PSPACE-complete.

01:01:11.340 --> 01:01:12.710
That's a hard proof.

01:01:12.710 --> 01:01:14.950
No pun intended.

01:01:14.950 --> 01:01:17.220
So that was Super
Mario Brothers.

01:01:17.220 --> 01:01:18.840
Any more questions?

01:01:18.840 --> 01:01:20.320
You asked the right one.

01:01:20.320 --> 01:01:22.332
I would have gone
to it otherwise.

01:01:22.332 --> 01:01:23.550
Yes?

01:01:23.550 --> 01:01:23.876
AUDIENCE: Are you
sure we'll never have

01:01:23.876 --> 01:01:25.290
to go say, left to right twice?

01:01:29.800 --> 01:01:30.630
PROFESSOR: Yes.

01:01:30.630 --> 01:01:32.280
That's a good question.

01:01:32.280 --> 01:01:36.430
In this gadget, we are not
able to go left to right twice,

01:01:36.430 --> 01:01:39.130
but that's OK.

01:01:39.130 --> 01:01:43.610
What's not really drawn
here but should be is

01:01:43.610 --> 01:01:46.304
we're really taking an
Euler tour of this star,

01:01:46.304 --> 01:01:48.220
so we're going to go
sort of on the left path.

01:01:48.220 --> 01:01:51.006
There's actually two
paths down here maybe.

01:01:51.006 --> 01:01:52.380
We're going to go
down here, then

01:01:52.380 --> 01:01:54.550
we'll come back the other way.

01:01:54.550 --> 01:01:56.780
Here, there are
actual crossovers.

01:01:56.780 --> 01:01:59.360
When we come back, there are
different crossover gadgets.

01:01:59.360 --> 01:02:01.680
Or you could say there's two
crossover gadgets for each

01:02:01.680 --> 01:02:04.400
of these, one for going one
direction, one for coming back.

01:02:07.090 --> 01:02:08.930
Yeah.

01:02:08.930 --> 01:02:11.880
Four crossovers for
each intersection,

01:02:11.880 --> 01:02:14.330
for both directions
and both guys.

01:02:14.330 --> 01:02:16.394
AUDIENCE: I'm mostly
willing to believe you,

01:02:16.394 --> 01:02:18.810
but I just have this nagging
doubt that you can't actually

01:02:18.810 --> 01:02:21.210
arrange all these things
and make them fit together.

01:02:21.210 --> 01:02:21.793
PROFESSOR: OK.

01:02:21.793 --> 01:02:25.170
So there is a top level question
which is, in general, it's

01:02:25.170 --> 01:02:27.080
the gadget assembly problem.

01:02:27.080 --> 01:02:29.800
If I have all these gadgets, can
I actually put them together?

01:02:29.800 --> 01:02:33.300
And it's important,
the output instance

01:02:33.300 --> 01:02:35.570
should have polynomial size.

01:02:35.570 --> 01:02:37.820
I probably should
mention that here.

01:02:37.820 --> 01:02:39.880
It's important.

01:02:39.880 --> 01:02:44.330
Of polynomials.

01:02:44.330 --> 01:02:46.745
Oh, that's polynomial
time algorithm.

01:02:46.745 --> 01:02:47.910
Good, good, good.

01:02:47.910 --> 01:02:48.410
Yes.

01:02:48.410 --> 01:02:51.402
So this is in parentheses.

01:02:51.402 --> 01:02:53.110
Because it's a polynomial
time algorithm,

01:02:53.110 --> 01:02:55.100
you will generate a
polynomial size output,

01:02:55.100 --> 01:02:57.950
because our outputs have to
be represented explicitly

01:02:57.950 --> 01:03:00.020
for reduction.

01:03:00.020 --> 01:03:03.850
So the main issue
is, can you draw this

01:03:03.850 --> 01:03:06.119
in a grid of polynomial size?

01:03:06.119 --> 01:03:07.660
And the short answer
to your question

01:03:07.660 --> 01:03:11.250
is, use standard graph
drawing algorithms.

01:03:11.250 --> 01:03:16.570
If I give you a planar graph,
I can draw it with n vertices.

01:03:16.570 --> 01:03:20.697
I can draw it in a grid
that order n by order n.

01:03:20.697 --> 01:03:22.030
I forget what the best bound is.

01:03:22.030 --> 01:03:23.220
Maybe 6n by 6n.

01:03:23.220 --> 01:03:24.360
Doesn't matter here.

01:03:24.360 --> 01:03:25.770
Now this graph is not planar.

01:03:25.770 --> 01:03:29.227
But if you just add a vertex
for every intersection,

01:03:29.227 --> 01:03:31.060
and there's at most n
squared intersections,

01:03:31.060 --> 01:03:32.830
then I will have a planar graph.

01:03:32.830 --> 01:03:34.140
Then I apply that algorithm.

01:03:34.140 --> 01:03:35.590
It draws everything into a grid.

01:03:35.590 --> 01:03:38.370
I explode that grid
by a factor of 100,

01:03:38.370 --> 01:03:41.480
whatever the largest size of
this gadget is, plunk them in,

01:03:41.480 --> 01:03:43.260
and then I route the tunnels.

01:03:43.260 --> 01:03:45.830
So the only thing I
haven't really filled in

01:03:45.830 --> 01:03:48.380
is how do you route the tunnels
to make them traversable?

01:03:48.380 --> 01:03:50.046
Because if you go up,
you've got to have

01:03:50.046 --> 01:03:51.380
enough stairs along the way.

01:03:51.380 --> 01:03:54.042
But it's an exercise
for the reader.

01:03:54.042 --> 01:03:55.500
There are definitely
details there.

01:03:55.500 --> 01:03:57.580
And in some cases,
they are subtle.

01:03:57.580 --> 01:04:00.140
I'll tell you the most
annoying issue that

01:04:00.140 --> 01:04:02.770
can happen is a parity issue.

01:04:02.770 --> 01:04:03.981
Sometimes, these gadgets--

01:04:03.981 --> 01:04:06.230
I mean, you could make them
slightly wider or slightly

01:04:06.230 --> 01:04:06.540
taller.

01:04:06.540 --> 01:04:07.370
It doesn't matter.

01:04:07.370 --> 01:04:09.990
Sometimes they have to
be even size or odd size.

01:04:09.990 --> 01:04:11.960
And then things don't
always fit up well.

01:04:11.960 --> 01:04:14.900
And that's a pain to do.

01:04:14.900 --> 01:04:19.140
And I had a proof last
month, where I had,

01:04:19.140 --> 01:04:21.709
I think, three separate
parity issues in a row.

01:04:21.709 --> 01:04:23.750
I fixed one, and it's
like, yes, I got the proof.

01:04:23.750 --> 01:04:26.154
And it was like, uh-oh,
there's another parity problem.

01:04:26.154 --> 01:04:27.070
Then I fixed that one.

01:04:27.070 --> 01:04:29.070
And then, uh-oh, there's
another parity problem.

01:04:29.070 --> 01:04:31.930
And finally, the proof
is hopefully correct.

01:04:31.930 --> 01:04:33.950
And we might go through
that as an example.

01:04:33.950 --> 01:04:35.408
So there are
definitely issues that

01:04:35.408 --> 01:04:38.470
can come up in gadget
assembly, but this one

01:04:38.470 --> 01:04:40.163
I'm not worried
about, let's say.

01:04:40.163 --> 01:04:40.982
Yeah?

01:04:40.982 --> 01:04:42.940
AUDIENCE: Did the original
Super Mario Brothers

01:04:42.940 --> 01:04:43.790
allow you to go left?

01:04:43.790 --> 01:04:44.360
PROFESSOR: No.

01:04:44.360 --> 01:04:45.901
In the original
Super Mario Brothers,

01:04:45.901 --> 01:04:47.610
you cannot scroll
the screen left.

01:04:47.610 --> 01:04:48.790
Mario can go left.

01:04:48.790 --> 01:04:52.340
So this is all one screen.

01:04:52.340 --> 01:04:55.690
You always have to generalize
something in your problem.

01:04:55.690 --> 01:05:00.890
And if you say the size of
your screen, it's 320 by 240,

01:05:00.890 --> 01:05:03.160
or whatever in the
original is constant,

01:05:03.160 --> 01:05:05.070
then you can solve
Mario in polynomial time

01:05:05.070 --> 01:05:06.100
by dynamic programming.

01:05:06.100 --> 01:05:08.970
So that's not as interesting.

01:05:08.970 --> 01:05:09.680
Mario 1.

01:05:09.680 --> 01:05:12.460
Of course, any other
Mario, you can go left,

01:05:12.460 --> 01:05:16.300
except sometimes it forgets
the status of your monsters.

01:05:19.151 --> 01:05:21.650
Again, if you have that, you
can solve it in polynomial time

01:05:21.650 --> 01:05:23.320
by dynamic programming.

01:05:23.320 --> 01:05:25.210
So we're in the
sort of, we'll say,

01:05:25.210 --> 01:05:30.140
as intended model, which is
you can have a big level.

01:05:30.140 --> 01:05:31.630
4K is already happening.

01:05:31.630 --> 01:05:33.850
Imagine the future, you
have a giant screen,

01:05:33.850 --> 01:05:35.400
and you play a giant level.

01:05:35.400 --> 01:05:39.600
AUDIENCE: [LAUGHING]

01:05:39.600 --> 01:05:41.310
PROFESSOR: Other questions?

01:05:41.310 --> 01:05:46.070
Now, one question is is Mario
Brothers an NP conjecture?

01:05:46.070 --> 01:05:49.112
No, I think by now we
might have a proof that

01:05:49.112 --> 01:05:50.607
is PSPACE complete.

01:05:50.607 --> 01:05:52.690
But that's not published
yet, or even written yet.

01:05:52.690 --> 01:05:57.660
So it's certainly not
guaranteed, but we think so.

01:05:57.660 --> 01:05:59.290
OK.

01:05:59.290 --> 01:06:04.440
Last proof is Rush Hour.

01:06:04.440 --> 01:06:06.440
Before I get to Rush Hour,
I'm going to tell you

01:06:06.440 --> 01:06:11.110
about another source problem.

01:06:11.110 --> 01:06:15.950
So 3SAT is the most
common problem for--

01:06:15.950 --> 01:06:19.590
you might call
them short puzzles.

01:06:19.590 --> 01:06:21.279
Mario Brothers is
maybe a short puzzle.

01:06:21.279 --> 01:06:23.070
If you have a time
limit in Mario Brothers,

01:06:23.070 --> 01:06:25.236
then you're guaranteed
you're going to make at most,

01:06:25.236 --> 01:06:28.040
let's say, n moves, and
then the game is over.

01:06:28.040 --> 01:06:30.380
You either dire or you finish.

01:06:30.380 --> 01:06:33.640
And 3-Satisfiability is a
good representation of that.

01:06:33.640 --> 01:06:38.500
For longer games, another
model called constraint logic

01:06:38.500 --> 01:06:40.670
or constraint graphs is useful.

01:06:40.670 --> 01:06:43.080
So let me tell you this problem.

01:06:43.080 --> 01:06:44.700
It's in some sense
simpler than 3SATs.

01:06:44.700 --> 01:06:47.274
On a graph, you have red
edges and blue edges.

01:06:47.274 --> 01:06:48.690
Notice the blue
edges are thicker.

01:06:48.690 --> 01:06:52.030
That means they're twice
as heavy, so that you

01:06:52.030 --> 01:06:54.390
think of this as your machine.

01:06:54.390 --> 01:06:56.930
Now a state of the
machine is going

01:06:56.930 --> 01:06:59.130
to be an orientation
of the graph.

01:06:59.130 --> 01:07:00.920
So every edge is just
going to be oriented

01:07:00.920 --> 01:07:02.500
one way or the other.

01:07:02.500 --> 01:07:04.710
And the constraint--
in general, this

01:07:04.710 --> 01:07:06.470
is called a constrained graph.

01:07:06.470 --> 01:07:08.680
And the constraint
you have to satisfy

01:07:08.680 --> 01:07:11.780
is that at every vertex, you
have at least two units of flow

01:07:11.780 --> 01:07:13.147
pointed into the vertex.

01:07:13.147 --> 01:07:15.480
So here there's actually three
units of flow pointed in.

01:07:15.480 --> 01:07:17.890
There's the red single unit
and the blue double unit.

01:07:17.890 --> 01:07:20.510
Blue's always 2,
red is always 1.

01:07:20.510 --> 01:07:24.199
So if you get the Kindle
edition of this book,

01:07:24.199 --> 01:07:25.990
don't read it on a
black and white display.

01:07:28.700 --> 01:07:30.780
Or the PDF, whatever.

01:07:30.780 --> 01:07:33.950
So what you're allowed
to do in this game,

01:07:33.950 --> 01:07:36.160
the move you're allowed
to do, is reverse an edge.

01:07:36.160 --> 01:07:38.120
As long as you always
satisfy this invariant

01:07:38.120 --> 01:07:40.480
that at least two units
are in, then you're OK.

01:07:40.480 --> 01:07:43.274
So I think here, we're going
to reverse this one first.

01:07:43.274 --> 01:07:45.190
So now we have three
units of flow pointed in.

01:07:45.190 --> 01:07:47.398
You have to check that the
other vertice's satisfied,

01:07:47.398 --> 01:07:48.960
but this one's certainly OK.

01:07:48.960 --> 01:07:51.210
Now because there
are two red units,

01:07:51.210 --> 01:07:53.510
we can reverse the blue one.

01:07:53.510 --> 01:07:57.580
And we cannot reverse
the red ones right now,

01:07:57.580 --> 01:08:00.220
because that would leave only
one unit of flow inwards.

01:08:00.220 --> 01:08:03.110
There's always two.

01:08:03.110 --> 01:08:05.950
So in fact, this vertex that
I've drawn is in some sense

01:08:05.950 --> 01:08:07.455
an AND gate.

01:08:07.455 --> 01:08:09.510
We call it an AND
vertex, because it's not

01:08:09.510 --> 01:08:11.540
a regular gate.

01:08:11.540 --> 01:08:14.732
Over here, we're
going to think of--

01:08:14.732 --> 01:08:15.940
it's a little bit asymmetric.

01:08:15.940 --> 01:08:18.273
We're going to think of these
as the inputs to the gate,

01:08:18.273 --> 01:08:20.620
and this as the
output of the gate.

01:08:20.620 --> 01:08:23.060
And if the inputs are
pointing out, that's a false.

01:08:23.060 --> 01:08:25.069
If they're pointing
in, that's a true.

01:08:25.069 --> 01:08:27.465
And the output is reverse,
so if it's pointing in,

01:08:27.465 --> 01:08:28.090
that's a false.

01:08:28.090 --> 01:08:30.370
If it's pointing
out, it's a true.

01:08:30.370 --> 01:08:32.729
So here's one
state false, false.

01:08:32.729 --> 01:08:36.060
And so the AND of false
and false is false.

01:08:36.060 --> 01:08:38.580
Here's another state where
both inputs are true,

01:08:38.580 --> 01:08:40.521
and then the output can be true.

01:08:40.521 --> 01:08:41.770
It doesn't have to be, though.

01:08:41.770 --> 01:08:45.149
So in this example, let's
say we reverse this edge.

01:08:45.149 --> 01:08:47.290
So now, we have false and true.

01:08:47.290 --> 01:08:50.550
Still, we can't reverse this
because false and true is

01:08:50.550 --> 01:08:52.979
false, and because
there would only

01:08:52.979 --> 01:08:55.680
be one unit of incoming flow
before we can reverse this.

01:08:55.680 --> 01:08:59.990
If I could reverse it back, I
could reverse the other one.

01:08:59.990 --> 01:09:03.550
Only once I reverse
both of the inputs am

01:09:03.550 --> 01:09:05.040
I allowed to reverse the output.

01:09:05.040 --> 01:09:06.069
But I don't have.

01:09:06.069 --> 01:09:08.729
I could just let it sit there.

01:09:08.729 --> 01:09:10.380
It's not a gate in
the sense that it

01:09:10.380 --> 01:09:12.590
doesn't compute the answer.

01:09:12.590 --> 01:09:16.340
But what you know is that if
you have an output of true,

01:09:16.340 --> 01:09:18.160
you know that the
inputs must be true.

01:09:18.160 --> 01:09:21.740
So it's kind of an AND.

01:09:21.740 --> 01:09:24.340
We call it a
constraint logic AND.

01:09:24.340 --> 01:09:26.680
Now here, this I claim is an OR.

01:09:26.680 --> 01:09:29.410
Now if you look at this in a
graph, it's totally symmetric.

01:09:29.410 --> 01:09:30.609
It's just three blue edges.

01:09:30.609 --> 01:09:32.817
But if you think of these
two as inputs and these two

01:09:32.817 --> 01:09:35.819
as outputs, it's an OR.

01:09:35.819 --> 01:09:39.359
And so what's the point?

01:09:39.359 --> 01:09:42.880
Well, if I reverse any of the
edges, the incoming edges,

01:09:42.880 --> 01:09:44.660
the input edges I
should say, then

01:09:44.660 --> 01:09:46.420
I can reverse the bottom edge.

01:09:46.420 --> 01:09:48.310
I don't have to.

01:09:48.310 --> 01:09:51.420
And I could also do both true.

01:09:51.420 --> 01:09:55.298
This could still
be true, and so on.

01:09:55.298 --> 01:09:56.838
AUDIENCE: So if
it's symmetric, how

01:09:56.838 --> 01:09:58.716
do you constrain some of
them to be inputs and others

01:09:58.716 --> 01:09:59.460
to be outputs?

01:09:59.460 --> 01:10:01.293
PROFESSOR: The inputs
and output distinction

01:10:01.293 --> 01:10:03.610
is only in your head.

01:10:03.610 --> 01:10:05.930
The way that I
used it is I said,

01:10:05.930 --> 01:10:08.890
an input is true if
it's pointing in,

01:10:08.890 --> 01:10:12.850
an output is true if
it's pointing out.

01:10:12.850 --> 01:10:14.760
So that's asymmetric,
and it's just

01:10:14.760 --> 01:10:17.160
a way of interpreting what's
happening in the graph.

01:10:17.160 --> 01:10:20.460
the graph knows no difference.

01:10:20.460 --> 01:10:23.010
This is useful, of course,
because your output

01:10:23.010 --> 01:10:25.120
is the next vertex's
input probably

01:10:25.120 --> 01:10:28.440
if you're building a
bunch of ANDS and ORs.

01:10:28.440 --> 01:10:30.330
If you're building
a regular circuit.

01:10:30.330 --> 01:10:33.120
So you want that definition
to be asymmetric.

01:10:33.120 --> 01:10:35.772
It gets a little bit
confusing, and we

01:10:35.772 --> 01:10:37.730
will spend a lot more
time on constraint logic.

01:10:37.730 --> 01:10:40.260
This is more of a teaser.

01:10:40.260 --> 01:10:44.550
But that's just in
the naming of things.

01:10:44.550 --> 01:10:45.880
Naming of true and false.

01:10:45.880 --> 01:10:46.380
OK.

01:10:46.380 --> 01:10:51.780
So constraint logic, let's say,
what's the decision problem?

01:10:51.780 --> 01:10:54.480
I give you such a graph.

01:10:54.480 --> 01:10:58.810
Notice every vertex is either
an AND, two red and a blue,

01:10:58.810 --> 01:11:00.590
or an OR, three blues.

01:11:00.590 --> 01:11:04.090
And I want to know, can
I reverse that edge?

01:11:04.090 --> 01:11:07.230
This is actually a crossover
gadget if you're curious.

01:11:07.230 --> 01:11:08.840
In this world,
crossover gadgets,

01:11:08.840 --> 01:11:11.500
you can just build
using ANDs and ORs.

01:11:11.500 --> 01:11:12.930
There's no NOTs in this world.

01:11:12.930 --> 01:11:15.330
NOTs don't even make
sense because you

01:11:15.330 --> 01:11:16.790
can't force anything.

01:11:16.790 --> 01:11:21.250
But it turns out this
problem is PSPACE complete.

01:11:21.250 --> 01:11:25.560
So even harder than
3SAT, assuming NP

01:11:25.560 --> 01:11:28.310
does not equal PSPACE.

01:11:28.310 --> 01:11:31.690
And the cool thing is
once you have developed

01:11:31.690 --> 01:11:35.140
all that infrastructure, if you
want to take a puzzle like Rush

01:11:35.140 --> 01:11:35.810
Hour--

01:11:35.810 --> 01:11:36.870
so these are cars.

01:11:36.870 --> 01:11:39.355
Each car can slide in
the direction of the car,

01:11:39.355 --> 01:11:43.795
no turns allowed, and your
goal is to get some car out,

01:11:43.795 --> 01:11:47.290
or to move some car
at all, let's say,

01:11:47.290 --> 01:11:48.530
I need to do two things.

01:11:48.530 --> 01:11:52.490
I need to construct an AND
date and construct an OR gate,

01:11:52.490 --> 01:11:55.480
and then I need to check
that they fit together.

01:11:55.480 --> 01:11:58.100
So let me convince
you this is an AND

01:11:58.100 --> 01:11:59.920
with this kind of orientation.

01:11:59.920 --> 01:12:03.870
And yeah.

01:12:03.870 --> 01:12:07.320
So this is going to
feel a little backwards.

01:12:07.320 --> 01:12:11.070
Inward pointing means
that the block is out,

01:12:11.070 --> 01:12:14.190
and outward pointing
means the block is in.

01:12:14.190 --> 01:12:16.789
Ignore this picture
for the moment.

01:12:16.789 --> 01:12:18.330
What happens here
is that if you want

01:12:18.330 --> 01:12:21.210
to push C into this
gadget, imagine

01:12:21.210 --> 01:12:23.030
the dark gray blocks are rigid.

01:12:23.030 --> 01:12:24.330
They can't they can never move.

01:12:24.330 --> 01:12:26.070
That's going to be true.

01:12:26.070 --> 01:12:27.610
We'll see why in a moment.

01:12:27.610 --> 01:12:29.820
So then it's just about
these inner guys moving.

01:12:29.820 --> 01:12:32.140
If you want to
move C in one unit,

01:12:32.140 --> 01:12:34.910
that will be possible if
and only if A moves out

01:12:34.910 --> 01:12:37.730
and B moves out by one unit.

01:12:37.730 --> 01:12:40.210
A moves out by one unit,
B moves out by one unit,

01:12:40.210 --> 01:12:45.420
then this block can slide here,
this block can slide here.

01:12:45.420 --> 01:12:50.100
This block can slide one,
this block can slide two,

01:12:50.100 --> 01:12:52.800
and then C can move in one.

01:12:52.800 --> 01:12:56.250
On the other hand, this
is an OR gate, OR vertex.

01:12:56.250 --> 01:13:00.700
If A moves out one
or B moves out one,

01:13:00.700 --> 01:13:04.040
then either E can move down,
or this guy can move down.

01:13:04.040 --> 01:13:05.630
Once either of
those moves down, D

01:13:05.630 --> 01:13:07.629
can move all the way to
the right or all the way

01:13:07.629 --> 01:13:11.150
to the left, and then
C can move down one.

01:13:11.150 --> 01:13:13.610
This is called a protected Or.

01:13:13.610 --> 01:13:14.650
Small, subtle detail.

01:13:14.650 --> 01:13:17.690
If A and B move out, then
everything can fall apart.

01:13:17.690 --> 01:13:22.856
So basically, there's
a proof in this book

01:13:22.856 --> 01:13:24.730
that says you don't need
to worry about that.

01:13:24.730 --> 01:13:26.840
We can guarantee
that we'll never

01:13:26.840 --> 01:13:28.770
have both A and B move out.

01:13:28.770 --> 01:13:30.730
Only one of them will happen.

01:13:30.730 --> 01:13:33.350
That's the protected part.

01:13:33.350 --> 01:13:35.860
So that's basically the
proof of PSPACE-completeness

01:13:35.860 --> 01:13:36.866
in two pictures.

01:13:36.866 --> 01:13:38.740
This is the cool thing
about constraint logic

01:13:38.740 --> 01:13:41.010
you don't need a crossover
gadget because those always

01:13:41.010 --> 01:13:42.529
happen for free.

01:13:42.529 --> 01:13:45.070
You just need to check that you
can fit the gadgets together.

01:13:45.070 --> 01:13:47.870
And this is the intended
tiling to fit them together.

01:13:47.870 --> 01:13:51.850
And you can check that as long
the box only move at most one

01:13:51.850 --> 01:13:56.640
unit at any time, then
these gray regions are solid

01:13:56.640 --> 01:13:58.170
all the way through.

01:13:58.170 --> 01:14:00.820
I think I need to add
some more filler here.

01:14:00.820 --> 01:14:04.390
And therefore, the gray
blocks can never move.

01:14:04.390 --> 01:14:07.390
And so then, you can analyze
each gadget one at a time

01:14:07.390 --> 01:14:13.590
and construct any constraint
logic graph in this way.

01:14:16.410 --> 01:14:17.450
Questions?

01:14:17.450 --> 01:14:18.090
Yeah?

01:14:18.090 --> 01:14:23.420
AUDIENCE: So for that
graph orientation problem,

01:14:23.420 --> 01:14:25.510
I do not fully understand.

01:14:25.510 --> 01:14:27.116
So you're given a graph--

01:14:27.116 --> 01:14:29.240
PROFESSOR: You're given a
graph and an orientation,

01:14:29.240 --> 01:14:32.676
and you want to know, can
I reverse this one edge?

01:14:32.676 --> 01:14:34.050
So in this world,
it means you're

01:14:34.050 --> 01:14:37.570
given an initial placement
of all the blocks,

01:14:37.570 --> 01:14:40.170
and you know whether each thing
is in or out, because you know

01:14:40.170 --> 01:14:43.170
whether the edge is
pointed to the left

01:14:43.170 --> 01:14:44.170
or pointed to the right.

01:14:44.170 --> 01:14:46.770
And you want to know, can
I move this one block?

01:14:46.770 --> 01:14:47.510
AUDIENCE: OK.

01:14:47.510 --> 01:14:50.424
And then for this graph,
you satisfied the property

01:14:50.424 --> 01:14:53.710
that each vertex has at least
two units [? of input. ?]

01:14:53.710 --> 01:14:56.600
PROFESSOR: Yes, the
input-oriented graph

01:14:56.600 --> 01:14:58.780
should already
satisfy the invariant.

01:14:58.780 --> 01:15:02.490
And then at every
move you do, you

01:15:02.490 --> 01:15:04.721
have to also satisfy
the invariant.

01:15:04.721 --> 01:15:07.012
AUDIENCE: Can you give a
small example of a graph which

01:15:07.012 --> 01:15:08.250
satisfies that [INAUDIBLE]?

01:15:08.250 --> 01:15:10.590
PROFESSOR: A small example.

01:15:10.590 --> 01:15:13.860
Like this one?

01:15:13.860 --> 01:15:15.520
This is not a single graph.

01:15:15.520 --> 01:15:19.940
But if I connect this edge to
here, and this edge to here,

01:15:19.940 --> 01:15:23.680
that will satisfy the property.

01:15:23.680 --> 01:15:25.510
And it's one graph.

01:15:25.510 --> 01:15:27.120
I don't have a small
example offhand

01:15:27.120 --> 01:15:28.790
but I think you could make.

01:15:28.790 --> 01:15:32.610
One

01:15:32.610 --> 01:15:34.110
It's an interesting
question, what's

01:15:34.110 --> 01:15:36.660
the smallest satisfied graph?

01:15:36.660 --> 01:15:41.290
Probably 10 vertices or
something should suffice.

01:15:41.290 --> 01:15:43.850
I should put it on
the problem set.

01:15:43.850 --> 01:15:44.390
But later.

01:15:44.390 --> 01:15:46.265
We'll talk about constraint
logic more later.

01:15:48.730 --> 01:15:49.415
More questions?

01:15:52.680 --> 01:15:53.640
So we did a lot.

01:15:53.640 --> 01:15:55.970
We proved Mario is NP-complete.

01:15:55.970 --> 01:15:57.410
I mean, some hand
waving involved.

01:15:57.410 --> 01:16:01.630
We proved that Rush
Hour is PSPACE-complete

01:16:01.630 --> 01:16:04.240
if you believe that constraint
logic PSPACE-complete.

01:16:04.240 --> 01:16:07.180
In general, this whole
class is about reductions,

01:16:07.180 --> 01:16:08.730
about taking a
known hard problem

01:16:08.730 --> 01:16:11.290
and converting it
into your problem.

01:16:11.290 --> 01:16:17.570
We will see a ton of them, and
each kind of type of problem

01:16:17.570 --> 01:16:19.480
has a different flavor.

01:16:19.480 --> 01:16:22.800
There's a whole range of
different 3SAT proofs.

01:16:22.800 --> 01:16:24.320
This is not the
only form of 3SAT.

01:16:24.320 --> 01:16:27.380
There are probably
a dozen of them .

01:16:27.380 --> 01:16:29.890
But they all follow
the same pattern, which

01:16:29.890 --> 01:16:32.799
is come up with a clause gadget,
come up with a variable gadget,

01:16:32.799 --> 01:16:34.590
come up with ways to
connect them together.

01:16:34.590 --> 01:16:36.400
And that's a very
useful way of thinking

01:16:36.400 --> 01:16:38.330
about things for some problems.

01:16:38.330 --> 01:16:42.014
And then for other problems,
you might use things

01:16:42.014 --> 01:16:42.930
like constraint logic.

01:16:42.930 --> 01:16:44.635
Constraint logic
is most relevant

01:16:44.635 --> 01:16:46.520
when it's designed
around games and puzzles,

01:16:46.520 --> 01:16:48.992
but it comes up in
other scenarios too.

01:16:48.992 --> 01:16:52.030
I think in graph
labeling, there have

01:16:52.030 --> 01:16:53.670
been proofs of
PSPACE-completeness

01:16:53.670 --> 01:16:56.790
using constraint logic.

01:16:56.790 --> 01:16:58.852
Next class, we'll
talk about a problem

01:16:58.852 --> 01:17:01.310
called three partition, which
is really useful for problems

01:17:01.310 --> 01:17:04.940
that involve numbers and adding
up numbers, where 3SAT isn't

01:17:04.940 --> 01:17:09.244
really useful but three
partition turns out

01:17:09.244 --> 01:17:10.160
to be the right thing.

01:17:10.160 --> 01:17:13.520
So that will be next.

01:17:13.520 --> 01:17:16.040
And that's all for today.

