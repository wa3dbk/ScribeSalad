WEBVTT
Kind: captions
Language: en

00:00:00.790 --> 00:00:03.190
The following content is
provided under a Creative

00:00:03.190 --> 00:00:04.730
Commons license.

00:00:04.730 --> 00:00:07.030
Your support will help
MIT OpenCourseWare

00:00:07.030 --> 00:00:11.390
continue to offer high quality
educational resources for free.

00:00:11.390 --> 00:00:13.990
To make a donation or
view additional materials

00:00:13.990 --> 00:00:17.880
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.880 --> 00:00:18.840
at ocw.mit.edu.

00:00:31.140 --> 00:00:33.100
PROFESSOR: All right.

00:00:33.100 --> 00:00:35.120
Let's get started, everyone.

00:00:35.120 --> 00:00:37.340
So, good afternoon.

00:00:37.340 --> 00:00:42.470
Welcome to the second lecture
of 60001 and also of 600.

00:00:42.470 --> 00:00:46.000
So as always, if you'd like to
follow along with the lectures,

00:00:46.000 --> 00:00:48.190
please go ahead and download
the slides and the code

00:00:48.190 --> 00:00:53.270
that I'll provide at least an
hour before class every day.

00:00:53.270 --> 00:00:53.770
All right.

00:00:53.770 --> 00:00:56.420
So a quick recap of
what we did last time.

00:00:56.420 --> 00:01:00.610
So last time, we talked a little
bit about what a computer is.

00:01:00.610 --> 00:01:03.130
And I think the main takeaway
from the last lecture

00:01:03.130 --> 00:01:06.730
is really that a computer only
does what it is told, right?

00:01:06.730 --> 00:01:08.800
So it's not going to
spontaneously make

00:01:08.800 --> 00:01:10.090
decisions on its own.

00:01:10.090 --> 00:01:12.670
You, as the programmer,
have to tell it

00:01:12.670 --> 00:01:15.501
what you want it to do
by writing programs.

00:01:15.501 --> 00:01:16.000
OK.

00:01:16.000 --> 00:01:18.610
So we talked about
simple objects.

00:01:18.610 --> 00:01:22.000
And these objects were
of different types.

00:01:22.000 --> 00:01:25.060
So we saw integers,
floats, and Booleans.

00:01:25.060 --> 00:01:28.390
And then we did a couple of
simple operations with them.

00:01:28.390 --> 00:01:30.250
Today, we're going to
look at a different--

00:01:30.250 --> 00:01:33.850
a new type of object
called a string.

00:01:33.850 --> 00:01:35.230
And then we're
going to introduce

00:01:35.230 --> 00:01:42.120
some more powerful things
in our programming toolbox.

00:01:42.120 --> 00:01:44.710
So we're going to look at how
to branch within a program,

00:01:44.710 --> 00:01:47.440
and how to make things-- how
to make the computer repeat

00:01:47.440 --> 00:01:50.200
certain tasks
within our program.

00:01:50.200 --> 00:01:51.130
All right.

00:01:51.130 --> 00:01:53.530
So let's begin by
looking at strings.

00:01:53.530 --> 00:01:56.530
So strings are a
new object type.

00:01:56.530 --> 00:01:58.030
We've seen so far
integers, which

00:01:58.030 --> 00:02:02.380
were whole numbers, floats,
which were decimal numbers,

00:02:02.380 --> 00:02:05.910
and we have seen Booleans,
which were true and false.

00:02:05.910 --> 00:02:09.789
So strings are going to be
sequences of characters.

00:02:09.789 --> 00:02:11.680
And these characters
can be anything.

00:02:11.680 --> 00:02:14.840
They can be letters,
digits, special characters,

00:02:14.840 --> 00:02:17.050
and also spaces.

00:02:17.050 --> 00:02:20.560
And you tell Python that you're
talking about a string object

00:02:20.560 --> 00:02:23.320
by enclosing it in
quotation marks.

00:02:23.320 --> 00:02:29.860
So in this case, I'm creating an
object whose value is h-e-l-l-o

00:02:29.860 --> 00:02:32.674
space t-h-e-r-e.

00:02:32.674 --> 00:02:34.840
And Python knows it's a
string object, because we're

00:02:34.840 --> 00:02:36.387
enclosing it in quotations.

00:02:36.387 --> 00:02:38.470
They can be either double
quotes or single quotes,

00:02:38.470 --> 00:02:41.260
but as long as you're
consistent, it doesn't matter.

00:02:41.260 --> 00:02:46.740
And this object, we're binding
it to this variable named hi.

00:02:46.740 --> 00:02:49.210
And we're using that using
the equals sign, which

00:02:49.210 --> 00:02:51.540
is the assignment operator.

00:02:51.540 --> 00:02:55.320
So from now on, whenever we
refer to this variable hi,

00:02:55.320 --> 00:02:57.700
Python is going to say, oh,
I know what the value is,

00:02:57.700 --> 00:03:00.864
and it's that string
of characters.

00:03:00.864 --> 00:03:02.530
So we're going to
learn about two things

00:03:02.530 --> 00:03:05.260
that you can do on strings
today, two operations.

00:03:05.260 --> 00:03:07.150
One is to concatenate them.

00:03:07.150 --> 00:03:09.700
And concatenation is
really just a fancy word

00:03:09.700 --> 00:03:11.920
for using this plus
operator, which

00:03:11.920 --> 00:03:14.810
means put the strings together.

00:03:14.810 --> 00:03:18.640
So I have this original
variable named hi,

00:03:18.640 --> 00:03:20.920
and I create a new
variable called name.

00:03:20.920 --> 00:03:24.550
And in it, I'm going
to assign the string

00:03:24.550 --> 00:03:27.290
a-n-a to the variable name.

00:03:27.290 --> 00:03:31.060
And when I use the plus
operator in between hi and name,

00:03:31.060 --> 00:03:32.920
those two variables,
Python is going

00:03:32.920 --> 00:03:34.930
to look at the
values of those two,

00:03:34.930 --> 00:03:38.330
and it's going to just
put them together.

00:03:38.330 --> 00:03:39.810
OK.

00:03:39.810 --> 00:03:43.140
I'm going to switch to Spider.

00:03:43.140 --> 00:03:49.717
And this is just that
example from the slides.

00:03:49.717 --> 00:03:50.800
So let's see what happens.

00:03:50.800 --> 00:03:54.790
So I have the variable
hi, the variable name,

00:03:54.790 --> 00:03:57.250
and I'm just concatenating
those two together.

00:03:57.250 --> 00:03:59.480
And then I'm going
to print that out.

00:03:59.480 --> 00:04:05.450
So if I run the code, notice
it prints out "hello thereana."

00:04:05.450 --> 00:04:06.590
There's no space.

00:04:06.590 --> 00:04:09.660
And there's no space because
the concatenation operator,

00:04:09.660 --> 00:04:13.490
the plus, doesn't add
any spaces implicitly.

00:04:13.490 --> 00:04:16.430
So again, another example
of just computer just

00:04:16.430 --> 00:04:17.839
doing what it's told.

00:04:17.839 --> 00:04:20.570
If we want to add a space,
we'd have to actually insert

00:04:20.570 --> 00:04:22.370
the space manually.

00:04:22.370 --> 00:04:25.340
So that's this
line here, line 8.

00:04:25.340 --> 00:04:27.230
And in this line,
we're concatenating

00:04:27.230 --> 00:04:31.440
the value of the
variable hi with a space.

00:04:31.440 --> 00:04:33.800
Notice we're putting
it in quotation marks.

00:04:33.800 --> 00:04:34.850
Just a space.

00:04:34.850 --> 00:04:37.070
And then with name.

00:04:37.070 --> 00:04:41.520
So if we'll go ahead
and print that value,

00:04:41.520 --> 00:04:45.480
notice this was that
garbage greeting there.

00:04:45.480 --> 00:04:47.610
And now we have a
proper greeting, right?

00:04:52.850 --> 00:04:56.301
So that's the concatenation
between strings.

00:04:56.301 --> 00:04:57.800
And then the other
thing we're going

00:04:57.800 --> 00:05:04.190
to look at related to
strings is the star operator.

00:05:04.190 --> 00:05:07.250
So that's this one
here on line 10.

00:05:07.250 --> 00:05:09.760
So Python allows you to use
the star operator, which

00:05:09.760 --> 00:05:15.420
stands for multiplication,
between a string and a number.

00:05:15.420 --> 00:05:19.070
And when you do that,
Python interprets it

00:05:19.070 --> 00:05:25.500
as repeat that string
that many number of times.

00:05:25.500 --> 00:05:29.150
So in this case, I'm
creating a silly greeting,

00:05:29.150 --> 00:05:33.500
and I'm concatenating the value
of hi, which is "hello there"

00:05:33.500 --> 00:05:37.329
with the space plus the name.

00:05:37.329 --> 00:05:38.870
So notice here, I'm
using parentheses

00:05:38.870 --> 00:05:42.350
to tell Python, do this
operation first, and then

00:05:42.350 --> 00:05:48.200
multiply whatever the
result of this is by 3.

00:05:48.200 --> 00:05:51.750
So if I print that
out, it's going

00:05:51.750 --> 00:05:55.320
to multiply the space
with my name three times,

00:05:55.320 --> 00:05:58.080
and it's going to concatenate
that with "hello there."

00:05:58.080 --> 00:06:02.670
So that's exactly what
it printed out there.

00:06:02.670 --> 00:06:05.180
Last lecture, we talked
a little bit about print.

00:06:05.180 --> 00:06:09.070
Today, I'm going to talk about
some nuances related to print.

00:06:09.070 --> 00:06:12.700
So you use print to
interact with the user.

00:06:12.700 --> 00:06:15.720
It's cool to write programs that
print things out to the user.

00:06:15.720 --> 00:06:19.110
So the key word
here being print.

00:06:19.110 --> 00:06:22.080
And then you put
parentheses after print.

00:06:22.080 --> 00:06:25.230
And in the parentheses,
you put in whatever

00:06:25.230 --> 00:06:27.760
you want to show the user.

00:06:27.760 --> 00:06:30.150
So in this little
program, I have--

00:06:30.150 --> 00:06:31.980
I created a variable named x.

00:06:31.980 --> 00:06:35.790
I assigned it the value
1, and then I print 1.

00:06:35.790 --> 00:06:38.390
Here, I'm casting.

00:06:38.390 --> 00:06:40.860
So I'm taking the number
one, the integer 1,

00:06:40.860 --> 00:06:43.560
and I'm casting it to a string.

00:06:43.560 --> 00:06:46.170
And you'll see why in a moment.

00:06:46.170 --> 00:06:47.670
So I want to bring
to your attention

00:06:47.670 --> 00:06:48.670
a couple of things here.

00:06:48.670 --> 00:06:54.780
So in the first print, I'm
using commas everywhere here.

00:06:54.780 --> 00:06:56.550
And in the second
print, I'm using plus.

00:07:01.100 --> 00:07:04.340
So by definition, if
you-- you can use commas

00:07:04.340 --> 00:07:08.840
inside a print-- inside
the parentheses of print.

00:07:08.840 --> 00:07:13.760
And if you use a comma, Python
is going to automatically

00:07:13.760 --> 00:07:17.090
add a space in
between the two things

00:07:17.090 --> 00:07:20.100
that the comma is in
between, the values.

00:07:20.100 --> 00:07:23.490
So "my fav num is"
is the first thing.

00:07:23.490 --> 00:07:27.320
And the second thing is
whatever's after the comma.

00:07:27.320 --> 00:07:29.090
Let's take x.

00:07:29.090 --> 00:07:32.120
So if you use a comma, Python
is going to automatically insert

00:07:32.120 --> 00:07:34.580
a space for you.

00:07:34.580 --> 00:07:36.920
Sometimes, you might want
that, sometimes you might not.

00:07:36.920 --> 00:07:39.980
If you don't want that, you
can use the concatenation

00:07:39.980 --> 00:07:41.990
operation, the plus.

00:07:41.990 --> 00:07:44.390
And you can add all
of your little bits

00:07:44.390 --> 00:07:48.210
together to create
one big string.

00:07:48.210 --> 00:07:50.900
If you're using
commas, the items,

00:07:50.900 --> 00:07:52.340
the objects in
between the commas,

00:07:52.340 --> 00:07:54.350
do not all have to be strings.

00:07:54.350 --> 00:07:56.150
That's the plus side
of using commas.

00:07:56.150 --> 00:08:00.020
But the downside is you
get spaces everywhere.

00:08:00.020 --> 00:08:03.590
If you use plus
operator, the plus side

00:08:03.590 --> 00:08:06.890
is Python does exactly
what you tell it to do,

00:08:06.890 --> 00:08:09.320
but everything has to
be a string object.

00:08:09.320 --> 00:08:12.680
So "my fav num is"
is a string object.

00:08:12.680 --> 00:08:15.800
You have to convert all of
your numbers to string objects,

00:08:15.800 --> 00:08:18.330
and so on.

00:08:18.330 --> 00:08:29.740
So if we look at Spider--
This is the same-- almost

00:08:29.740 --> 00:08:30.940
the same code.

00:08:30.940 --> 00:08:34.070
So here, I don't
have spaces anywhere.

00:08:34.070 --> 00:08:37.780
So you can see that
the first line here

00:08:37.780 --> 00:08:39.590
has commas everywhere.

00:08:39.590 --> 00:08:43.120
So I'm going to have spaces in
between every one of the things

00:08:43.120 --> 00:08:47.310
that I'm printing out.

00:08:47.310 --> 00:08:50.970
This line here is sort of a
combination between commas

00:08:50.970 --> 00:08:54.250
and concatenation.

00:08:54.250 --> 00:08:56.600
So depending on where
I used the comma,

00:08:56.600 --> 00:08:58.020
I'm going to have
an extra space.

00:08:58.020 --> 00:09:02.100
And this line here just has
concatenation everywhere.

00:09:02.100 --> 00:09:08.240
So if I run this, notice this
very first line added spaces

00:09:08.240 --> 00:09:10.020
everywhere in between
all my objects.

00:09:10.020 --> 00:09:11.949
The second one added
spaces somewhere.

00:09:11.949 --> 00:09:14.240
And you can sort of trace
through and see exactly where

00:09:14.240 --> 00:09:16.360
the spaces were added.

00:09:16.360 --> 00:09:21.018
And the last line here
didn't add spaces anywhere.

00:09:33.220 --> 00:09:37.590
So printing things out
to the console is nice,

00:09:37.590 --> 00:09:40.860
but the second part of sort of
writing an interactive program

00:09:40.860 --> 00:09:43.170
is getting input from the user.

00:09:43.170 --> 00:09:45.510
And that's the more
interesting part.

00:09:45.510 --> 00:09:49.140
So if you've done problem set 0,
you might have sort of already

00:09:49.140 --> 00:09:50.710
tried to understand
this on your own.

00:09:50.710 --> 00:09:52.050
But here we are.

00:09:52.050 --> 00:09:55.650
So the way you get
input from the user

00:09:55.650 --> 00:10:00.030
is using this command
function called input.

00:10:00.030 --> 00:10:03.630
And inside the parentheses,
you type in whatever you'd

00:10:03.630 --> 00:10:07.810
like to prompt the user with.

00:10:07.810 --> 00:10:11.490
So in this case, in my
example here, I have input,

00:10:11.490 --> 00:10:14.070
and then here I said
"type anything."

00:10:14.070 --> 00:10:16.740
So the user is going
to see this text here,

00:10:16.740 --> 00:10:19.332
and then the program
is just going to stop.

00:10:19.332 --> 00:10:20.790
And it's going to
wait for the user

00:10:20.790 --> 00:10:23.760
to type in something
and hit Enter.

00:10:23.760 --> 00:10:27.120
As soon as the user
types in Enter,

00:10:27.120 --> 00:10:31.470
whatever the user types
in becomes a string.

00:10:31.470 --> 00:10:33.810
If a user types in a
number, for example,

00:10:33.810 --> 00:10:36.804
that becomes the
string of that number.

00:10:36.804 --> 00:10:38.220
So everything the
user types in is

00:10:38.220 --> 00:10:39.930
going to be made as a string.

00:10:43.180 --> 00:10:46.090
In this line right here,
whatever these the user types

00:10:46.090 --> 00:10:47.890
in becomes a string.

00:10:47.890 --> 00:10:50.770
And we're going to
bind that string object

00:10:50.770 --> 00:10:54.597
to this variable named text.

00:10:54.597 --> 00:10:56.680
So now, further in my
program, I could do whatever

00:10:56.680 --> 00:10:58.270
I want with this variable text.

00:10:58.270 --> 00:11:02.320
In this case, I'm
going to print 5*text.

00:11:02.320 --> 00:11:03.580
OK.

00:11:03.580 --> 00:11:07.120
So if the user, for
example, gave me "ha,"

00:11:07.120 --> 00:11:10.030
I'm going to print "ha" 5 times.

00:11:10.030 --> 00:11:13.609
If the user gave
me 5, what do you

00:11:13.609 --> 00:11:15.150
think the user is--
what do you think

00:11:15.150 --> 00:11:18.380
is going to be printed out?

00:11:18.380 --> 00:11:22.551
25 or 5 five times?

00:11:22.551 --> 00:11:23.050
Great.

00:11:23.050 --> 00:11:23.290
Yes.

00:11:23.290 --> 00:11:23.789
Exactly.

00:11:23.789 --> 00:11:24.718
5 five times.

00:11:28.270 --> 00:11:31.700
Oftentimes, you don't want to
work with numbers as strings,

00:11:31.700 --> 00:11:32.200
right?

00:11:32.200 --> 00:11:34.690
You want to work with
numbers as numbers, right?

00:11:34.690 --> 00:11:36.826
So you have to cast.

00:11:36.826 --> 00:11:38.200
And we learned
that last lecture.

00:11:38.200 --> 00:11:41.020
You cast by just putting
in this little bit

00:11:41.020 --> 00:11:43.304
right in front of the input.

00:11:43.304 --> 00:11:45.220
And you can cast it to
whatever type you want.

00:11:45.220 --> 00:11:48.310
Here I cast it to an int, but
you can also cast to a float

00:11:48.310 --> 00:11:50.620
if you want to work with floats.

00:11:50.620 --> 00:11:53.770
And that converts whatever
the user typed in,

00:11:53.770 --> 00:11:57.340
as long as it's some number that
Python knows how to convert,

00:11:57.340 --> 00:11:59.150
into the number itself.

00:11:59.150 --> 00:12:01.270
So in this case, if
the user gives me 5,

00:12:01.270 --> 00:12:07.190
I'm going to print out 5 times
5 instead of 5 five times.

00:12:07.190 --> 00:12:12.300
So that's the code here.

00:12:14.870 --> 00:12:16.570
So the first bit
is I'm going to get

00:12:16.570 --> 00:12:23.190
the user to type in anything,
and I'm going to put 555.

00:12:23.190 --> 00:12:25.680
And then when I type in the
number, since I'm casting it,

00:12:25.680 --> 00:12:27.920
I'm going to do operations
with the number.

00:12:27.920 --> 00:12:28.620
Yeah, question.

00:12:28.620 --> 00:12:29.574
AUDIENCE: [INAUDIBLE]

00:12:32.440 --> 00:12:37.510
PROFESSOR: Why do you
want to cast to-- oh.

00:12:37.510 --> 00:12:41.035
The question is why do you
want to cast to a string?

00:12:41.035 --> 00:12:42.910
Why do you want to cast
a string to a number?

00:12:42.910 --> 00:12:43.884
AUDIENCE: [INAUDIBLE]

00:12:46.810 --> 00:12:50.320
PROFESSOR: Oh, so
Python always--

00:12:50.320 --> 00:12:53.170
whatever you type
in, just by default,

00:12:53.170 --> 00:12:55.300
by definition of
the input command,

00:12:55.300 --> 00:12:58.030
Python always makes it a string.

00:12:58.030 --> 00:12:59.530
So if you want to
work with numbers,

00:12:59.530 --> 00:13:00.988
you have to explicitly
tell it, I'm

00:13:00.988 --> 00:13:03.200
going to work with a number.

00:13:03.200 --> 00:13:04.750
So even if you give
it the number 5,

00:13:04.750 --> 00:13:08.270
it's going to think
it's the string 5.

00:13:08.270 --> 00:13:09.120
Yeah.

00:13:09.120 --> 00:13:10.445
That's just how input works.

00:13:13.960 --> 00:13:18.190
The next thing we're
going to look at

00:13:18.190 --> 00:13:25.330
is ways that you can start
adding tests in your code.

00:13:25.330 --> 00:13:29.710
And before you can start
adding tests in your code,

00:13:29.710 --> 00:13:32.800
you need to be able to
do the actual tests.

00:13:32.800 --> 00:13:39.850
So this is where comparison
operators come in.

00:13:39.850 --> 00:13:44.650
So here, let's assume that
i and j are variables.

00:13:44.650 --> 00:13:48.070
The following comparisons are
going to give you a Boolean.

00:13:48.070 --> 00:13:51.500
So it's either going to say,
this is true or this is false.

00:13:51.500 --> 00:13:54.850
So that's going to be your test.

00:13:54.850 --> 00:13:56.830
So if i and j are
variables, you're

00:13:56.830 --> 00:13:58.390
allowed to compare
ints with ints,

00:13:58.390 --> 00:14:01.900
floats with floats,
strings with strings.

00:14:01.900 --> 00:14:03.340
And you're allowed
to compare ints

00:14:03.340 --> 00:14:05.500
and floats between
themselves, but you're not

00:14:05.500 --> 00:14:09.520
allowed to compare a
string with a number.

00:14:09.520 --> 00:14:13.330
In fact, if you even try to
do that in Python-- in Spider

00:14:13.330 --> 00:14:18.370
here, if I try to say, is
the letter a greater than 5?

00:14:18.370 --> 00:14:22.390
I get some angry
text right here.

00:14:22.390 --> 00:14:24.370
And this just tells
me Python doesn't

00:14:24.370 --> 00:14:26.320
understand the
meaning of-- how do I

00:14:26.320 --> 00:14:27.615
compare a string with a number?

00:14:30.900 --> 00:14:31.840
OK.

00:14:31.840 --> 00:14:36.120
So just like in math, we can
do these usual comparisons.

00:14:36.120 --> 00:14:38.220
We can say if something
is greater than something,

00:14:38.220 --> 00:14:41.160
greater or equal to, less
than, less than or equal to.

00:14:41.160 --> 00:14:44.410
I'd like to bring to your
attention the equality.

00:14:44.410 --> 00:14:46.801
So the single equals
sign is an assignment.

00:14:46.801 --> 00:14:48.300
So you're taking a
value, and you're

00:14:48.300 --> 00:14:49.424
assigning it to a variable.

00:14:49.424 --> 00:14:51.420
But when you're doing
the double equals sign,

00:14:51.420 --> 00:14:53.580
this is the test for equality.

00:14:53.580 --> 00:14:55.830
Is the value of
variable i the same

00:14:55.830 --> 00:14:58.262
as the value of the variable j?

00:14:58.262 --> 00:14:59.970
And that's, again,
also going to give you

00:14:59.970 --> 00:15:02.230
a Boolean either true or false.

00:15:02.230 --> 00:15:05.450
And you can also test for
inequality with the exclamation

00:15:05.450 --> 00:15:06.720
equal.

00:15:06.720 --> 00:15:09.290
So that means, is the
value of the variable i

00:15:09.290 --> 00:15:12.030
not equal to the value
of the variable j?

00:15:12.030 --> 00:15:13.890
True if yes, false if no.

00:15:16.760 --> 00:15:17.260
OK.

00:15:17.260 --> 00:15:19.470
So those are comparison
operators on integer,

00:15:19.470 --> 00:15:21.210
floats, and strings.

00:15:21.210 --> 00:15:25.620
On Booleans, you can do
some logic operators.

00:15:25.620 --> 00:15:30.610
And the simplest
is just inverting.

00:15:30.610 --> 00:15:35.760
So if a is a variable
that has a Boolean value,

00:15:35.760 --> 00:15:37.450
not a is just
going to invert it.

00:15:37.450 --> 00:15:42.620
So if a is true, then not
a is false, and vice versa.

00:15:42.620 --> 00:15:45.940
This is a table that sort of
represents what I've said here.

00:15:45.940 --> 00:15:49.750
So you can do-- you
can use and and or.

00:15:49.750 --> 00:15:52.060
These are key words in Python.

00:15:52.060 --> 00:15:54.700
You can use those two
key words on variables,

00:15:54.700 --> 00:15:57.850
on Boolean variables.

00:15:57.850 --> 00:16:01.870
And you get the result
a and b is only true

00:16:01.870 --> 00:16:04.720
if both a and b are true.

00:16:04.720 --> 00:16:11.020
And a or b is only false
if a and b are false.

00:16:11.020 --> 00:16:13.450
And this is the complete
table just in case

00:16:13.450 --> 00:16:14.570
you need to reference it.

00:16:17.220 --> 00:16:17.720
All right.

00:16:17.720 --> 00:16:21.290
So now that we have ways to do
logical-- question right there.

00:16:21.290 --> 00:16:22.214
AUDIENCE: [INAUDIBLE]

00:16:26.107 --> 00:16:27.440
PROFESSOR: Yeah, great question.

00:16:27.440 --> 00:16:29.690
So what does it mean to
compare a string with a string

00:16:29.690 --> 00:16:30.620
with the greater than?

00:16:30.620 --> 00:16:34.100
So that's just going to compare
them, lexicographically.

00:16:34.100 --> 00:16:37.350
So does it come first
in the alphabet?

00:16:37.350 --> 00:16:39.440
So we can even test that out.

00:16:39.440 --> 00:16:44.490
We can say, is a greater than b?

00:16:44.490 --> 00:16:45.115
And it's false.

00:16:48.070 --> 00:16:50.153
So b comes later in
the alphabet than a.

00:16:53.860 --> 00:16:54.430
OK.

00:16:54.430 --> 00:16:56.650
So now we have ways
to do the tests.

00:16:56.650 --> 00:17:02.650
So we can add some branching
to our programming toolbox

00:17:02.650 --> 00:17:05.140
now that we have
ways to do tests.

00:17:05.140 --> 00:17:06.829
This is a map of MIT.

00:17:06.829 --> 00:17:10.329
I'm going to go through
sort of a little example

00:17:10.329 --> 00:17:15.157
to motivate why we would want
to do branching in our code.

00:17:15.157 --> 00:17:17.740
And I think after this lecture,
you'll be able to sort of code

00:17:17.740 --> 00:17:20.140
up this algorithm that
I'm going to explain.

00:17:20.140 --> 00:17:21.910
So most of us see MIT as a maze.

00:17:21.910 --> 00:17:23.470
I first did when I came here.

00:17:26.780 --> 00:17:28.280
When I first came
here, obviously, I

00:17:28.280 --> 00:17:30.650
signed up for the free
food mailing list.

00:17:30.650 --> 00:17:34.340
And MIT, being a maze, I
had no idea where to go,

00:17:34.340 --> 00:17:37.140
what the shortest
path was to free food.

00:17:37.140 --> 00:17:40.990
So one way to think about
it is all I wanted to do

00:17:40.990 --> 00:17:44.630
was get to the free food.

00:17:44.630 --> 00:17:47.960
A very simple algorithm to
get there would be to say,

00:17:47.960 --> 00:17:49.340
OK, I'm going take
my right hand,

00:17:49.340 --> 00:17:51.631
and I'm going to make sure
that my right hand is always

00:17:51.631 --> 00:17:53.174
on a wall.

00:17:53.174 --> 00:17:55.340
And I'm going to go around
campus with my right hand

00:17:55.340 --> 00:17:56.900
always being at a wall.

00:17:56.900 --> 00:17:59.150
And eventually, I'll get
to where the free food is.

00:17:59.150 --> 00:18:00.800
There might not be
any left, right?

00:18:00.800 --> 00:18:03.170
But I'll be there.

00:18:03.170 --> 00:18:05.557
So the algorithm is as follows.

00:18:05.557 --> 00:18:07.390
If my right hand always
has to be on a wall,

00:18:07.390 --> 00:18:10.400
then I'm going to
say, if there's

00:18:10.400 --> 00:18:12.350
no wall to my right
side, then I'm

00:18:12.350 --> 00:18:14.420
going to go right
until I get to a wall.

00:18:17.840 --> 00:18:22.580
Then if there's a wall to my
right, and I can go forward,

00:18:22.580 --> 00:18:26.090
I'm just going to
keep going forward.

00:18:26.090 --> 00:18:28.400
If I keep going forward, and
there's a wall to my right

00:18:28.400 --> 00:18:31.700
and in front of me, I'm going
to turn around and go left.

00:18:31.700 --> 00:18:34.490
And then if there's a wall
to my right, in front of me,

00:18:34.490 --> 00:18:37.130
and to the left, then I'm going
to turn around and go back.

00:18:37.130 --> 00:18:40.550
So with this fairly
simple algorithm,

00:18:40.550 --> 00:18:46.840
I just follow the path always
keeping the wall to my right.

00:18:46.840 --> 00:18:50.090
And eventually, I would
end up where I need to be.

00:18:50.090 --> 00:18:54.110
So notice, I used, just in
plain English, a few key words.

00:18:54.110 --> 00:18:57.860
If, otherwise, things like that.

00:18:57.860 --> 00:19:01.640
So in programming, we have
those same constructs.

00:19:01.640 --> 00:19:03.830
And those same sort
of intuitive words

00:19:03.830 --> 00:19:07.250
can be used to tell
Python to do something

00:19:07.250 --> 00:19:11.300
or to do something else or to
choose from a different set

00:19:11.300 --> 00:19:14.690
of possibilities.

00:19:14.690 --> 00:19:16.370
And this way, we
can get the computer

00:19:16.370 --> 00:19:18.651
to make decisions for us.

00:19:18.651 --> 00:19:20.150
And you might be
thinking, well, you

00:19:20.150 --> 00:19:23.150
said that computers can't
make decisions on their own.

00:19:23.150 --> 00:19:24.035
It's not.

00:19:24.035 --> 00:19:26.600
You, as programmers, are
going to build these decisions

00:19:26.600 --> 00:19:28.520
into the program,
and all the computer

00:19:28.520 --> 00:19:31.950
is going to do is going to reach
the decision point and say,

00:19:31.950 --> 00:19:34.340
OK, this is a decision
point, should I go left

00:19:34.340 --> 00:19:35.270
or should I go right?

00:19:35.270 --> 00:19:36.890
Or which one do I pick?

00:19:36.890 --> 00:19:40.190
And these sort of decisions are
created by you as a programmer.

00:19:40.190 --> 00:19:42.290
And the computer just
has to make the decision

00:19:42.290 --> 00:19:43.730
and choose a path.

00:19:43.730 --> 00:19:45.080
OK.

00:19:45.080 --> 00:19:47.720
So in programming, there's
three sort of simple ways

00:19:47.720 --> 00:19:50.930
that you can add control
flow to your programs.

00:19:50.930 --> 00:19:53.480
And that's making one
decision and choosing

00:19:53.480 --> 00:19:57.990
whether to execute something
or execute something else.

00:19:57.990 --> 00:20:01.820
The first is a simple if.

00:20:01.820 --> 00:20:04.580
And given a program
that just linearly

00:20:04.580 --> 00:20:07.490
has statements
that get executed,

00:20:07.490 --> 00:20:11.650
whenever I reach
an if statement,

00:20:11.650 --> 00:20:13.947
you're going to
check the condition.

00:20:13.947 --> 00:20:15.530
The condition is
going to be something

00:20:15.530 --> 00:20:18.705
that's going to get evaluated
to either true or false.

00:20:21.700 --> 00:20:25.140
So I've reached
the condition here.

00:20:25.140 --> 00:20:26.830
And if the condition
is true, then I'm

00:20:26.830 --> 00:20:31.510
going to additionally execute
this extra set of expressions.

00:20:31.510 --> 00:20:33.160
But if the condition
is false, then I'm

00:20:33.160 --> 00:20:35.590
just going to keep going
through the program

00:20:35.590 --> 00:20:37.922
and not execute that
extra set of instructions.

00:20:41.590 --> 00:20:44.480
How does Python know which
instructions to execute?

00:20:44.480 --> 00:20:48.550
They're going to be inside
this what we call code block.

00:20:48.550 --> 00:20:51.689
And the code block is
denoted by indentation.

00:20:51.689 --> 00:20:53.230
So it's going to be
everything that's

00:20:53.230 --> 00:20:58.050
indented is part of
that if code block.

00:20:58.050 --> 00:21:01.500
Typically, four
spaces is indentation.

00:21:01.500 --> 00:21:02.520
OK.

00:21:02.520 --> 00:21:06.970
So that's how you
write code that

00:21:06.970 --> 00:21:10.950
decides whether to execute
this extra thing or not.

00:21:10.950 --> 00:21:14.410
Now let's say I don't just
want to execute an extra thing,

00:21:14.410 --> 00:21:17.500
I want to reach a
point where I say,

00:21:17.500 --> 00:21:22.510
I'll either go down this path
or I'll do something else.

00:21:22.510 --> 00:21:27.980
That's this right here.

00:21:27.980 --> 00:21:34.310
So this if else construct
says this is my code,

00:21:34.310 --> 00:21:37.100
I've reached my
decision point here,

00:21:37.100 --> 00:21:42.060
if the condition
inside the if is true,

00:21:42.060 --> 00:21:45.230
then I'm going to execute maybe
this set of statements here.

00:21:48.750 --> 00:21:50.890
But if the condition
is not true,

00:21:50.890 --> 00:21:53.860
then I'm not going to execute
that set of statements,

00:21:53.860 --> 00:22:00.790
and instead I'm going to
execute under whatever else is.

00:22:00.790 --> 00:22:02.400
So using this
construct, I'm either

00:22:02.400 --> 00:22:04.890
going to do one set of
expressions or the other,

00:22:04.890 --> 00:22:06.870
but never both.

00:22:06.870 --> 00:22:08.710
And after I've executed
one or the other,

00:22:08.710 --> 00:22:11.065
I'm going to continue on with
just the regular execution

00:22:11.065 --> 00:22:11.690
of the program.

00:22:20.010 --> 00:22:20.510
OK.

00:22:20.510 --> 00:22:22.250
So we're able to either
choose one thing,

00:22:22.250 --> 00:22:24.249
choose one thing or
another, but what if we want

00:22:24.249 --> 00:22:27.570
to have more than one choice?

00:22:27.570 --> 00:22:31.670
So if some number is equal
to zero, I want to do this.

00:22:31.670 --> 00:22:33.530
If it's equal to 1,
I want to do this.

00:22:33.530 --> 00:22:36.260
If it's equal to 2, I want
to do this, and so on.

00:22:36.260 --> 00:22:39.020
That's where this
last one comes in.

00:22:39.020 --> 00:22:45.740
And we introduced this other
key word here called elif.

00:22:45.740 --> 00:22:49.310
So that stands for
short form for else if.

00:22:49.310 --> 00:22:53.250
So first we check if
this condition is true.

00:22:53.250 --> 00:22:54.890
So we're going
through our program,

00:22:54.890 --> 00:22:56.990
we've reached our
decision point,

00:22:56.990 --> 00:22:59.900
if the condition is true,
we're going to execute maybe

00:22:59.900 --> 00:23:01.280
this set of instructions.

00:23:04.320 --> 00:23:06.480
If the condition is
not true, maybe we'll

00:23:06.480 --> 00:23:09.550
check-- if the
condition is not true,

00:23:09.550 --> 00:23:11.940
we will check this
next condition.

00:23:11.940 --> 00:23:14.802
That's part of the
elif right here.

00:23:14.802 --> 00:23:16.260
And if that one's
true, we're going

00:23:16.260 --> 00:23:18.720
to execute a different
set of instructions.

00:23:18.720 --> 00:23:21.264
You can have more than one elif.

00:23:21.264 --> 00:23:22.680
And depending on
which one's true,

00:23:22.680 --> 00:23:25.950
you're going to execute a
different set of instructions.

00:23:25.950 --> 00:23:28.470
And then this last else
is sort of a catch all

00:23:28.470 --> 00:23:31.510
where if none of the previous
conditions were true,

00:23:31.510 --> 00:23:35.100
then just do this last
set of expressions.

00:23:35.100 --> 00:23:38.190
So in this case, you're
going to choose between one

00:23:38.190 --> 00:23:40.680
of these three-- one
of these four roots,

00:23:40.680 --> 00:23:43.156
or however many you have.

00:23:43.156 --> 00:23:45.030
And then when you're
done making your choice,

00:23:45.030 --> 00:23:47.831
you're going to execute the
remaining set of instructions.

00:23:51.270 --> 00:23:54.390
So the way this works is if
more than one condition is true,

00:23:54.390 --> 00:23:57.960
you're actually just going
to enter one of them.

00:23:57.960 --> 00:24:01.020
And you're going to enter the
very first one that's true.

00:24:01.020 --> 00:24:02.940
So you're never going
to enter more than one

00:24:02.940 --> 00:24:05.640
of these code blocks.

00:24:05.640 --> 00:24:08.220
You always enter one, and
you enter the first one

00:24:08.220 --> 00:24:09.890
that evaluates to true.

00:24:15.840 --> 00:24:19.609
So notice that we denoted
code blocks using indentation.

00:24:19.609 --> 00:24:21.150
And that's actually
one of the things

00:24:21.150 --> 00:24:22.910
that I really like about Python.

00:24:22.910 --> 00:24:26.060
It sort of forces you to
write pretty code and nice

00:24:26.060 --> 00:24:31.880
looking code and just
code that's very readable.

00:24:31.880 --> 00:24:36.110
And that forces you to indent
everything that's a code block.

00:24:36.110 --> 00:24:39.020
So you can easily see sort of
where the flow of control is

00:24:39.020 --> 00:24:44.660
and where decision making
points are and things like that.

00:24:44.660 --> 00:24:49.490
So in this particular example,
we have one if statement here,

00:24:49.490 --> 00:24:51.525
and it checks if two
variables are equal.

00:24:55.320 --> 00:24:58.710
And we have an if, elif, else.

00:24:58.710 --> 00:25:01.290
And in this example, we're
going to enter either this code

00:25:01.290 --> 00:25:04.230
block or this one or
this one, depending

00:25:04.230 --> 00:25:06.120
on the variables of x and y.

00:25:06.120 --> 00:25:08.670
And we're only going
into one code block.

00:25:08.670 --> 00:25:13.510
And we'll enter the
first one that's true.

00:25:13.510 --> 00:25:16.020
Notice you can have
nested conditionals.

00:25:16.020 --> 00:25:19.060
So inside this first if,
we have another if here.

00:25:22.980 --> 00:25:28.860
And this inner if is only going
to be checked when we enter

00:25:28.860 --> 00:25:30.440
the first-- this outter if.

00:25:36.590 --> 00:25:39.220
I do want to make
one point, though.

00:25:39.220 --> 00:25:41.860
So sometimes, you might forget
to do the double equals sign

00:25:41.860 --> 00:25:46.210
when you are checking for
equality, and that's OK.

00:25:46.210 --> 00:25:48.190
If you just use one
equals sign, Python's

00:25:48.190 --> 00:25:50.950
going to give you an error.

00:25:50.950 --> 00:25:53.750
And it's going to
say syntax error,

00:25:53.750 --> 00:25:55.780
and it's going to
highlight this line.

00:25:55.780 --> 00:25:58.690
And then you're going to know
that there's a mistake there.

00:25:58.690 --> 00:26:00.340
And you should be
using equality,

00:26:00.340 --> 00:26:01.798
because it doesn't
make sense to be

00:26:01.798 --> 00:26:05.330
using-- to assign-- to be making
an assignment inside the if.

00:26:12.476 --> 00:26:13.850
So we've learned
about branching.

00:26:13.850 --> 00:26:17.150
And we know about conditionals.

00:26:17.150 --> 00:26:22.760
Let's try to apply
this to a little game.

00:26:22.760 --> 00:26:24.980
And spoiler, we
won't be able to.

00:26:24.980 --> 00:26:27.020
We'll have to learn
about a new thing.

00:26:27.020 --> 00:26:29.300
But back in the 1980s,
there was the Legend

00:26:29.300 --> 00:26:33.350
of Zelda-- cool
graphics-- where there was

00:26:33.350 --> 00:26:36.410
a scene with the lost woods.

00:26:36.410 --> 00:26:40.910
Oversimplification if
anyone's a Zelda die hard fan.

00:26:40.910 --> 00:26:45.230
But the basic idea was
if you entered the woods,

00:26:45.230 --> 00:26:47.520
you entered from the
left to the right.

00:26:47.520 --> 00:26:49.850
And then as long as
you kept going right,

00:26:49.850 --> 00:26:53.360
it would show you the same
screen over and over again.

00:26:53.360 --> 00:26:56.030
And the trick was you
just had to go backward,

00:26:56.030 --> 00:26:58.460
and then you'd exit the woods.

00:26:58.460 --> 00:27:00.290
So very simple.

00:27:00.290 --> 00:27:04.490
Using what we know so far, we
could sort of code this up.

00:27:04.490 --> 00:27:06.080
And we'd say
something like this.

00:27:06.080 --> 00:27:08.990
If the user exits right,
then set the background

00:27:08.990 --> 00:27:11.250
to the woods background.

00:27:11.250 --> 00:27:15.650
Otherwise, set the background
to the exit background.

00:27:15.650 --> 00:27:18.920
Now let's say the user-- and
then in the else, we're done.

00:27:18.920 --> 00:27:20.900
Let's say the user went right.

00:27:20.900 --> 00:27:22.850
Well, you'd show them
the woods background,

00:27:22.850 --> 00:27:25.340
and now ask them again,
where do they want to go?

00:27:25.340 --> 00:27:26.960
If they exit right,
set the background

00:27:26.960 --> 00:27:27.960
to the woods background.

00:27:27.960 --> 00:27:31.050
Otherwise, set the background to
the exit background, and so on.

00:27:31.050 --> 00:27:35.240
So you notice that there's
sort of no end to this, right?

00:27:35.240 --> 00:27:38.452
How many times-- do you
know how many times the user

00:27:38.452 --> 00:27:39.410
might keep going right?

00:27:39.410 --> 00:27:41.450
They might be really
persistent, right?

00:27:41.450 --> 00:27:44.210
And they'll be like maybe
if I go 1,000 times,

00:27:44.210 --> 00:27:45.760
I'll get out of the woods.

00:27:45.760 --> 00:27:47.660
Maybe 1,001?

00:27:47.660 --> 00:27:48.650
Maybe.

00:27:48.650 --> 00:27:56.210
So this would probably
be-- who knows how deep?

00:27:56.210 --> 00:27:57.492
These nested ifs.

00:27:57.492 --> 00:27:58.200
So we don't know.

00:28:00.737 --> 00:28:02.570
So with what we know
so far, we can't really

00:28:02.570 --> 00:28:04.790
code this cute little game.

00:28:04.790 --> 00:28:07.720
But enter loops.

00:28:07.720 --> 00:28:11.220
And specifically, a while loop.

00:28:11.220 --> 00:28:16.520
So this code here that could
be infinitely number of nested

00:28:16.520 --> 00:28:18.710
if statements deep
can be rewritten

00:28:18.710 --> 00:28:21.650
using these three lines.

00:28:21.650 --> 00:28:24.350
So we say while the
user exits right,

00:28:24.350 --> 00:28:26.990
set the background to
the woods background.

00:28:26.990 --> 00:28:28.370
And with a while
loop, it's going

00:28:28.370 --> 00:28:30.203
to do what we tell it
to do inside the loop,

00:28:30.203 --> 00:28:32.310
and then it's going to
check the condition again,

00:28:32.310 --> 00:28:34.370
and then it's
going to do what we

00:28:34.370 --> 00:28:36.860
say it should do
inside the code block,

00:28:36.860 --> 00:28:39.680
and it's going to check
the condition again.

00:28:39.680 --> 00:28:42.660
And then when the condition--
as long as a condition is true,

00:28:42.660 --> 00:28:45.329
it's going to keep doing
that little loop there.

00:28:45.329 --> 00:28:47.120
And as soon as the
condition becomes false,

00:28:47.120 --> 00:28:48.770
it's going to stop
doing the loop

00:28:48.770 --> 00:28:52.420
and do whatever's
right after the while.

00:28:52.420 --> 00:28:53.550
OK.

00:28:53.550 --> 00:28:57.510
So that's basically
how a while loop works.

00:28:57.510 --> 00:28:58.560
We have while.

00:28:58.560 --> 00:29:00.150
That's the key word.

00:29:00.150 --> 00:29:01.680
The condition is
something that gets

00:29:01.680 --> 00:29:03.910
evaluated to true or false.

00:29:03.910 --> 00:29:07.024
And once again, we have a
code block that's indented,

00:29:07.024 --> 00:29:08.940
and it tells Python,
these are the expressions

00:29:08.940 --> 00:29:11.300
I want to do as long as
the condition is true.

00:29:16.350 --> 00:29:18.770
So the condition is true,
you evaluate every expression

00:29:18.770 --> 00:29:19.580
in the code block.

00:29:19.580 --> 00:29:22.070
When you reach the end of the
expression-- end of the code

00:29:22.070 --> 00:29:24.170
block, you check
the condition again.

00:29:24.170 --> 00:29:27.230
If it's true still, you
keep doing the expressions.

00:29:27.230 --> 00:29:28.990
Check it again, and so on.

00:29:32.910 --> 00:29:35.570
So here's a little game.

00:29:35.570 --> 00:29:38.090
And with these lines
of code, we were

00:29:38.090 --> 00:29:43.160
able-- we can code up
the lost woods of Zelda.

00:29:43.160 --> 00:29:46.970
Even worse graphics, by the
way than the original Zelda

00:29:46.970 --> 00:29:48.980
is this one that
I coded up here.

00:29:48.980 --> 00:29:50.695
So I print out the
following things.

00:29:50.695 --> 00:29:51.820
"You're in the Lost Forest.

00:29:51.820 --> 00:29:54.500
Go left or right."

00:29:54.500 --> 00:29:57.120
And my program's going to say,
"You're in the Lost Forest.

00:29:57.120 --> 00:29:58.010
Go left or right."

00:29:58.010 --> 00:29:59.730
It's going to get user input.

00:29:59.730 --> 00:30:03.890
It's going to say while the
user keeps typing in right,

00:30:03.890 --> 00:30:07.280
show them this text,
and ask them again.

00:30:07.280 --> 00:30:11.267
So I'm asking them again by
just saying input here again.

00:30:11.267 --> 00:30:11.850
And that's it.

00:30:11.850 --> 00:30:15.020
That's going to just keep
getting input from the user.

00:30:15.020 --> 00:30:18.500
And if the user doesn't type in
right, and maybe types in left,

00:30:18.500 --> 00:30:21.230
you're going to exit out of
this loop, and print out,

00:30:21.230 --> 00:30:24.870
"You've got out of
the Lost Forest."

00:30:24.870 --> 00:30:28.620
So I have to show you this,
because I spent too much time

00:30:28.620 --> 00:30:30.750
on it.

00:30:30.750 --> 00:30:37.930
But I decided to improve on
the code that's in the slides.

00:30:37.930 --> 00:30:41.940
And I've written here ways that
you guys can also improve it.

00:30:41.940 --> 00:30:45.190
So if I run my code--
"You're in the Lost Forest.

00:30:45.190 --> 00:30:46.000
Go left or right."

00:30:46.000 --> 00:30:51.180
So if I say left, then yay,
I got out of the Lost Forest.

00:30:51.180 --> 00:30:56.430
But if I go right,
then I'm stuck, right?

00:30:56.430 --> 00:30:57.865
I took down some trees.

00:30:57.865 --> 00:30:59.490
You can see there's
no more trees here.

00:30:59.490 --> 00:31:01.786
I made a table, and
then I flipped it over.

00:31:04.920 --> 00:31:07.770
So the expansion to this
if you want to try it out--

00:31:07.770 --> 00:31:12.240
I put this in the comments
here-- is try to use a counter.

00:31:12.240 --> 00:31:14.820
If the user types in
right the first two times,

00:31:14.820 --> 00:31:17.506
just make that a sad face.

00:31:17.506 --> 00:31:19.380
But if the user types
in more than two times,

00:31:19.380 --> 00:31:24.419
make them cut down some trees
and build a table and flip it.

00:31:24.419 --> 00:31:25.960
That's a cute little
expansion if you

00:31:25.960 --> 00:31:29.050
want to test yourself to make
sure you are getting loops.

00:31:29.050 --> 00:31:30.550
OK.

00:31:30.550 --> 00:31:34.760
So so far, we've used while
loops to ask for user input.

00:31:34.760 --> 00:31:37.244
And that's actually somewhere
where it makes sense

00:31:37.244 --> 00:31:39.160
to use while loops,
because you don't actually

00:31:39.160 --> 00:31:43.360
know how many times the user
is going to type in something.

00:31:43.360 --> 00:31:47.120
You can use while loops
to keep sort of a counter

00:31:47.120 --> 00:31:52.470
and to write code
that counts something.

00:31:52.470 --> 00:31:55.200
If you do that, though,
there's two things

00:31:55.200 --> 00:31:56.340
you need to take care of.

00:31:56.340 --> 00:32:00.600
The first is the
first line here,

00:32:00.600 --> 00:32:03.551
which is sort of an
initialization of this loop

00:32:03.551 --> 00:32:04.050
counter.

00:32:06.860 --> 00:32:09.540
And the second is
this line here,

00:32:09.540 --> 00:32:11.815
which is incrementing
your loop counter.

00:32:15.630 --> 00:32:17.940
The reason why the
second one is important

00:32:17.940 --> 00:32:20.790
is because-- let's look
at our condition here.

00:32:20.790 --> 00:32:24.240
So while n is less than five.

00:32:24.240 --> 00:32:26.960
If you didn't have
this line here,

00:32:26.960 --> 00:32:29.250
you would never increment n.

00:32:29.250 --> 00:32:33.030
So every time through the loop,
you just keep printing zeros.

00:32:33.030 --> 00:32:34.830
And you would have
an infinite loop.

00:32:34.830 --> 00:32:37.170
I do want to show,
though, what--

00:32:37.170 --> 00:32:40.530
if you do have an infinite loop,
it's not the end of the world.

00:32:40.530 --> 00:32:53.370
So I can say something like--
so while true, print zero.

00:32:53.370 --> 00:32:57.180
So this is going to give me an
infinite loop in my program.

00:32:57.180 --> 00:32:58.350
And-- whoop.

00:33:06.970 --> 00:33:08.110
OK.

00:33:08.110 --> 00:33:12.452
So notice it's just printing the
letter p over and over again.

00:33:12.452 --> 00:33:13.910
And if I let it go
any longer, it's

00:33:13.910 --> 00:33:15.243
going to slow down the computer.

00:33:15.243 --> 00:33:18.640
So I'm going to hit
Control-C or Command-C maybe.

00:33:18.640 --> 00:33:22.600
And it's going to stop
the program from printing.

00:33:22.600 --> 00:33:24.730
So just in case you ever
enter infinite loops

00:33:24.730 --> 00:33:28.570
in your programs, just go to
the console and hit Control-C,

00:33:28.570 --> 00:33:31.030
and that's going to
stop it from sort

00:33:31.030 --> 00:33:34.681
of slowing down the computer.

00:33:34.681 --> 00:33:35.180
OK.

00:33:35.180 --> 00:33:36.750
So going back to
this example, I was

00:33:36.750 --> 00:33:40.560
saying that if you're using
counters-- variables in order

00:33:40.560 --> 00:33:42.450
to sort of count up
inside the while loop,

00:33:42.450 --> 00:33:44.400
you have to take
care to initialize

00:33:44.400 --> 00:33:46.680
a counter variable first.

00:33:46.680 --> 00:33:49.170
And then to increment
it, otherwise you'll

00:33:49.170 --> 00:33:51.330
enter an infinite loop.

00:33:51.330 --> 00:33:53.730
That feels a little bit tedious.

00:33:53.730 --> 00:33:57.790
And so there's a shortcut for
doing that exact same thing.

00:33:57.790 --> 00:34:00.330
So these four lines,
you can rewrite those

00:34:00.330 --> 00:34:04.290
into these two lines right here
using this new type of loop

00:34:04.290 --> 00:34:07.060
called a for loop.

00:34:07.060 --> 00:34:10.989
So the for loop says, for some
loop variable-- in this case,

00:34:10.989 --> 00:34:11.980
I named it n.

00:34:11.980 --> 00:34:13.979
You can name it
whatever you want.

00:34:13.979 --> 00:34:15.520
In range 5-- we're
going to come back

00:34:15.520 --> 00:34:18.350
to what range means in
a little bit-- print n.

00:34:22.000 --> 00:34:23.620
So every time through
the loop, you're

00:34:23.620 --> 00:34:26.920
going to print out
what the value of n is.

00:34:26.920 --> 00:34:31.210
Range 5 actually
creates internally

00:34:31.210 --> 00:34:33.940
a sequence of numbers
starting from 0

00:34:33.940 --> 00:34:36.949
and going to that
number 5 minus 1.

00:34:36.949 --> 00:34:41.949
So the sequence is going
to be 0, 1, 2, 3, and 4.

00:34:41.949 --> 00:34:44.199
The first time through the
loop, you're going to say n

00:34:44.199 --> 00:34:45.449
is equal to 0.

00:34:45.449 --> 00:34:47.080
Or internally, this
is what happens.

00:34:47.080 --> 00:34:48.760
N gets the value of 0.

00:34:48.760 --> 00:34:51.070
You're going to print n.

00:34:51.070 --> 00:34:53.840
Then you're going to
go back to the top.

00:34:53.840 --> 00:34:55.239
N gets the value 1.

00:34:55.239 --> 00:34:58.120
Then you're going to go
execute whatever is inside.

00:34:58.120 --> 00:35:00.232
So you're going to print 1.

00:35:00.232 --> 00:35:01.690
Then you're going
to increment that

00:35:01.690 --> 00:35:03.400
to the next value
in the sequence.

00:35:03.400 --> 00:35:07.600
You're going to print
out 2, and so on.

00:35:07.600 --> 00:35:12.000
So this is the general
look of a for loop.

00:35:12.000 --> 00:35:16.020
So we have for some
loop variable-- again,

00:35:16.020 --> 00:35:21.360
can be named whatever you
want-- in range some number.

00:35:21.360 --> 00:35:23.640
Do a bunch of stuff.

00:35:23.640 --> 00:35:26.880
And again, these are part
of this for loop code block.

00:35:26.880 --> 00:35:29.250
So you should indent
them to tell Python

00:35:29.250 --> 00:35:32.580
that these are the things
that you should do.

00:35:32.580 --> 00:35:34.350
So when you're using
range some number,

00:35:34.350 --> 00:35:38.835
you start out with variable
getting the value 0.

00:35:41.980 --> 00:35:44.410
With variable having
value 0, you're

00:35:44.410 --> 00:35:47.950
going to execute all
of these expressions.

00:35:47.950 --> 00:35:50.690
After all the expressions
in the code block are done,

00:35:50.690 --> 00:35:53.930
you're going to go
on to the next value.

00:35:53.930 --> 00:35:55.976
So 1.

00:35:55.976 --> 00:35:57.850
You're going to execute
all these expressions

00:35:57.850 --> 00:36:01.930
with the variable being
value 1, and then so on

00:36:01.930 --> 00:36:05.380
and so on until you go
to some num minus 1.

00:36:10.450 --> 00:36:13.030
That-- so using
range in that way

00:36:13.030 --> 00:36:16.330
is a little bit constraining,
because you're always

00:36:16.330 --> 00:36:18.520
going to get values
starting from 0

00:36:18.520 --> 00:36:21.570
and ending at some
num minus 1, whatever

00:36:21.570 --> 00:36:23.852
is in the parentheses in range.

00:36:23.852 --> 00:36:25.810
Sometimes you might want
to write programs that

00:36:25.810 --> 00:36:27.532
maybe start at a custom value.

00:36:27.532 --> 00:36:28.240
Don't start at 0.

00:36:28.240 --> 00:36:29.590
Maybe they start at 5.

00:36:29.590 --> 00:36:32.234
Maybe they start at minus 10.

00:36:32.234 --> 00:36:34.150
And sometimes you might
want to write programs

00:36:34.150 --> 00:36:37.630
that don't go with-- don't
expect the numbers by 1,

00:36:37.630 --> 00:36:39.280
but maybe skip
every other number,

00:36:39.280 --> 00:36:42.320
go every two numbers, or every
three numbers, and so on.

00:36:42.320 --> 00:36:47.570
So you can customize
range to your needs.

00:36:47.570 --> 00:36:50.230
The one thing you do need
to give it is the stop.

00:36:50.230 --> 00:36:52.420
So if you give it only one
value in the parentheses

00:36:52.420 --> 00:36:55.030
that stands for stop.

00:36:55.030 --> 00:36:57.550
And by default, start is
going to have the value 0,

00:36:57.550 --> 00:37:01.500
and step is going
to have the value 1.

00:37:01.500 --> 00:37:04.020
If you give it two things
in the parentheses,

00:37:04.020 --> 00:37:06.510
you're giving it start and stop.

00:37:06.510 --> 00:37:08.850
So the first being start,
the second being stop.

00:37:08.850 --> 00:37:12.905
And step gets this
value of 1 by default.

00:37:12.905 --> 00:37:15.030
And if you give it three
things in the parentheses,

00:37:15.030 --> 00:37:18.465
you're giving it start,
stop, and step in that order.

00:37:22.500 --> 00:37:26.130
And you're always going to
start at the start value

00:37:26.130 --> 00:37:30.270
and stop at-- or so you're going
to start at the start value,

00:37:30.270 --> 00:37:32.470
and you're going to
go until stop minus 1.

00:37:32.470 --> 00:37:34.200
So those are the
sequences of numbers.

00:37:36.900 --> 00:37:39.080
So in this first
code right here,

00:37:39.080 --> 00:37:40.910
my sum is going to
get the value 0.

00:37:40.910 --> 00:37:44.210
And you're going
to have a for loop.

00:37:44.210 --> 00:37:46.700
We're going to start
from 7, because we're

00:37:46.700 --> 00:37:47.965
giving it two numbers.

00:37:47.965 --> 00:37:49.340
And when you give
it two numbers,

00:37:49.340 --> 00:37:53.570
it represents start and
stop with step being 1.

00:37:53.570 --> 00:37:55.910
So we're starting at 7.

00:37:55.910 --> 00:38:00.174
If step is 1, the
next value is 8.

00:38:00.174 --> 00:38:01.340
What's the value after that?

00:38:05.100 --> 00:38:06.270
If we're incrementing by 1?

00:38:09.200 --> 00:38:09.700
9.

00:38:12.740 --> 00:38:17.430
And since we're going
until stop minus 1,

00:38:17.430 --> 00:38:21.350
we're not actually
going to pick up on 10.

00:38:21.350 --> 00:38:23.870
So this loop variable,
i, the very first time

00:38:23.870 --> 00:38:28.250
through the loop is going
to have the value 7.

00:38:28.250 --> 00:38:33.360
So my sum is going
to be 0 plus 7.

00:38:37.510 --> 00:38:40.730
That's everything that's
inside the code block.

00:38:40.730 --> 00:38:45.520
The next time through the
loop, i gets the value 8.

00:38:45.520 --> 00:38:52.900
So inside the for
loop, my sum gets

00:38:52.900 --> 00:38:58.150
whatever the previous value
was, which was 7, plus 8.

00:38:58.150 --> 00:39:00.440
OK.

00:39:00.440 --> 00:39:04.540
The next time through
the loop, my sum

00:39:04.540 --> 00:39:08.260
get the value 7 plus 8 plus 9.

00:39:08.260 --> 00:39:10.600
Obviously, replacing that
with the previous value.

00:39:10.600 --> 00:39:13.200
So 15.

00:39:13.200 --> 00:39:15.841
Since we're not going through
10, that's where we stop.

00:39:15.841 --> 00:39:17.590
And we're going to
print out my sum, which

00:39:17.590 --> 00:39:19.810
is going to be the value
of 7 plus 8 plus 9.

00:39:22.330 --> 00:39:24.790
Yeah?

00:39:24.790 --> 00:39:25.290
OK.

00:39:25.290 --> 00:39:26.568
Yeah.

00:39:26.568 --> 00:39:27.605
AUDIENCE: [INAUDIBLE]

00:39:27.605 --> 00:39:29.230
PROFESSOR: Do they
have to be integers?

00:39:32.591 --> 00:39:33.590
That's a great question.

00:39:33.590 --> 00:39:34.850
We can try that out.

00:39:34.850 --> 00:39:38.660
I'm not actually sure right
off the top of my head.

00:39:38.660 --> 00:39:46.530
So you can go on Spider and
say-- let's say in this example

00:39:46.530 --> 00:39:47.030
here.

00:39:52.100 --> 00:39:58.779
So we can say 7.1, 10.3-- yeah.

00:39:58.779 --> 00:39:59.945
So they have to be integers.

00:40:08.620 --> 00:40:09.250
OK.

00:40:09.250 --> 00:40:10.940
So that's that example.

00:40:10.940 --> 00:40:13.330
And let's erase that.

00:40:13.330 --> 00:40:16.510
In this particular example,
we have start, stop, and step.

00:40:16.510 --> 00:40:20.150
And here, we're going
every other value.

00:40:20.150 --> 00:40:22.300
So we're starting at 5.

00:40:22.300 --> 00:40:25.280
Tell me what the next
value is supposed to be.

00:40:25.280 --> 00:40:27.760
If we're taking every other one.

00:40:27.760 --> 00:40:35.020
7, and then 9, and then--
are we doing 11 or not?

00:40:35.020 --> 00:40:35.950
Excellent.

00:40:35.950 --> 00:40:36.460
Nice.

00:40:36.460 --> 00:40:37.570
Yeah.

00:40:37.570 --> 00:40:41.031
So we're going to
the end minus 1.

00:40:41.031 --> 00:40:41.530
OK.

00:40:41.530 --> 00:40:43.450
So it's possible
that sometimes you

00:40:43.450 --> 00:40:47.439
write code where you might want
to exit out of the loop early.

00:40:47.439 --> 00:40:49.480
You don't want to go
through all of the sequences

00:40:49.480 --> 00:40:51.040
of your numbers.

00:40:51.040 --> 00:40:53.290
Maybe there's a condition
inside there where you just

00:40:53.290 --> 00:40:55.409
want to exit the loop early.

00:40:55.409 --> 00:40:56.950
Inside the while
loop, maybe you want

00:40:56.950 --> 00:41:00.520
to exit the loop before the
condition becomes false.

00:41:00.520 --> 00:41:02.980
So that's where the
break statement comes in.

00:41:02.980 --> 00:41:06.020
So the break works like this.

00:41:06.020 --> 00:41:09.100
It's going to-- as soon
as Python sees this break

00:41:09.100 --> 00:41:13.090
statement, it's
going to say, OK,

00:41:13.090 --> 00:41:18.160
I'm going to look at whatever
loop I'm currently in.

00:41:18.160 --> 00:41:20.350
I'm not evaluating
any expression

00:41:20.350 --> 00:41:23.770
after it that comes
within my loop.

00:41:23.770 --> 00:41:26.180
And I'm going to
immediately exit the loop.

00:41:26.180 --> 00:41:28.870
So I'm going inside
this while, this while,

00:41:28.870 --> 00:41:30.610
I'm evaluating this
one expression,

00:41:30.610 --> 00:41:33.430
and I suddenly see a break.

00:41:33.430 --> 00:41:37.960
Expression b does
not get evaluated.

00:41:37.960 --> 00:41:39.970
And break is going
to immediately

00:41:39.970 --> 00:41:43.150
exit out of the innermost
loop that it's in.

00:41:43.150 --> 00:41:46.540
So this while loop that
has condition 2, that's

00:41:46.540 --> 00:41:50.950
the innermost loop that
the break is found in.

00:41:50.950 --> 00:41:54.670
So we're going to exit out
of this inner most loop here.

00:41:54.670 --> 00:41:57.070
And we're evaluating
expression c.

00:41:57.070 --> 00:41:58.900
And notice, we're
evaluating expression c,

00:41:58.900 --> 00:42:05.140
because it's-- expression c is
part of the outer while loop.

00:42:05.140 --> 00:42:08.470
It's at the same
level as this one.

00:42:08.470 --> 00:42:13.820
And these ones are part
of the inner while loop.

00:42:13.820 --> 00:42:14.480
OK.

00:42:14.480 --> 00:42:16.354
Last thing I want to
say is just a little bit

00:42:16.354 --> 00:42:18.410
of a comparison between
for and while loops.

00:42:18.410 --> 00:42:21.200
So when would you
use one or the other.

00:42:21.200 --> 00:42:23.109
This might be useful
in your problem sets.

00:42:23.109 --> 00:42:24.650
So for loops you
usually use when you

00:42:24.650 --> 00:42:27.530
know the number of iterations.

00:42:27.530 --> 00:42:29.910
While loops are very useful
when, for example, you're

00:42:29.910 --> 00:42:32.379
getting user input, and
user input is unpredictable.

00:42:32.379 --> 00:42:33.920
You don't know how
many times they're

00:42:33.920 --> 00:42:36.685
going to do a certain task.

00:42:36.685 --> 00:42:38.060
For both for and
while loops, you

00:42:38.060 --> 00:42:40.700
can end out of the loop
early using the break.

00:42:40.700 --> 00:42:42.470
The for loop uses this counter.

00:42:42.470 --> 00:42:45.380
It's inherent
inside the for loop.

00:42:45.380 --> 00:42:48.530
A while loop you can use a
counter in order-- you can use

00:42:48.530 --> 00:42:50.840
a while loop to count things.

00:42:50.840 --> 00:42:53.766
But you must initialize the
counter before the while loop.

00:42:53.766 --> 00:42:56.140
And you have to remember to
increment it within the loop.

00:42:56.140 --> 00:43:00.710
Otherwise, you maybe
lead to an infinite loop.

00:43:00.710 --> 00:43:04.190
We've seen as the very
first example of a for loop

00:43:04.190 --> 00:43:06.900
that the while--
the for loop could

00:43:06.900 --> 00:43:08.900
be rewritten as a while
loop, but the vice versa

00:43:08.900 --> 00:43:11.160
is not necessarily true.

00:43:11.160 --> 00:43:14.450
And the counterexample to
that is just user input.

00:43:14.450 --> 00:43:16.430
So you might not
know how many times

00:43:16.430 --> 00:43:18.730
you might do a certain task.

00:43:18.730 --> 00:43:19.460
All right.

00:43:19.460 --> 00:43:20.480
Great.

00:43:20.480 --> 00:43:22.420
That's all for today.

