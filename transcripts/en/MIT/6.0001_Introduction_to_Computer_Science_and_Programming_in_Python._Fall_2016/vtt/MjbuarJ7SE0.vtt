WEBVTT
Kind: captions
Language: en

00:00:00.790 --> 00:00:03.190
The following content is
provided under a Creative

00:00:03.190 --> 00:00:04.730
Commons license.

00:00:04.730 --> 00:00:07.030
Your support will help
MIT OpenCourseWare

00:00:07.030 --> 00:00:11.390
continue to offer high quality
educational resources for free.

00:00:11.390 --> 00:00:13.990
To make a donation or
view additional materials

00:00:13.990 --> 00:00:17.880
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.880 --> 00:00:18.840
at ocw.mit.edu.

00:00:31.056 --> 00:00:34.080
PROFESSOR: All right
everyone let's get started.

00:00:34.080 --> 00:00:37.290
All right good afternoon on
this rainy, rainy sad afternoon.

00:00:37.290 --> 00:00:39.900
So-- I'm glad we're
inside though-- all right

00:00:39.900 --> 00:00:44.630
so Lecture 4 of 6.0001 in 600.

00:00:44.630 --> 00:00:46.850
Quick, quick recap of
what we did last time.

00:00:46.850 --> 00:00:50.420
So last time we did a little
bit more string manipulations,

00:00:50.420 --> 00:00:53.630
and then we saw how you can
use for loops over strings

00:00:53.630 --> 00:00:54.380
directly.

00:00:54.380 --> 00:00:57.310
So instead of having for
loops that iterate over

00:00:57.310 --> 00:01:00.050
range-- so 0, 1, 2,
3, 4, and so on--

00:01:00.050 --> 00:01:02.600
you saw that it was more
powerful to sometimes use

00:01:02.600 --> 00:01:08.351
for loops that iterate over
string objects directly.

00:01:08.351 --> 00:01:10.100
So that was the first
half of the lecture.

00:01:10.100 --> 00:01:13.040
In the second half, we started
looking at different ways

00:01:13.040 --> 00:01:18.920
that you can implement the
different implementations

00:01:18.920 --> 00:01:19.820
to the same problem.

00:01:19.820 --> 00:01:22.880
So we saw the problem of
finding the cube root,

00:01:22.880 --> 00:01:25.970
and we saw some implementations.

00:01:25.970 --> 00:01:28.160
We saw the Guess
and Check method,

00:01:28.160 --> 00:01:30.170
and the approximation method.

00:01:30.170 --> 00:01:32.270
And then we looked
at what I thought

00:01:32.270 --> 00:01:35.334
was the most powerful method,
which was the bisection method.

00:01:35.334 --> 00:01:37.250
And this one, if you
remember, I played a game

00:01:37.250 --> 00:01:39.680
with someone in the
audience where I guessed

00:01:39.680 --> 00:01:42.170
a number between 0 and 100.

00:01:42.170 --> 00:01:44.660
And we saw that I was able
to guess that number really,

00:01:44.660 --> 00:01:47.120
really quickly using
the bisection method.

00:01:47.120 --> 00:01:48.754
And that's the
method that you're

00:01:48.754 --> 00:01:51.170
going to implement-- that you
are currently implementing--

00:01:51.170 --> 00:01:53.990
in your problem set.

00:01:53.990 --> 00:02:03.900
OK so today-- so that sort
of finishes introduction

00:02:03.900 --> 00:02:07.134
to some of the more basic
mechanisms in Python.

00:02:07.134 --> 00:02:08.759
And today we're going
to talk about how

00:02:08.759 --> 00:02:11.640
to structure your programs
such that you write

00:02:11.640 --> 00:02:15.660
nice, coherent code-- reusable
code-- by hiding away some

00:02:15.660 --> 00:02:17.867
of the details in your code.

00:02:17.867 --> 00:02:19.950
And to do that we're going
to look at these things

00:02:19.950 --> 00:02:22.860
called functions.

00:02:22.860 --> 00:02:25.450
All right so just
stepping back and sort

00:02:25.450 --> 00:02:28.870
of getting a high-level view of
how we write the code so far.

00:02:28.870 --> 00:02:32.440
So so far the way that
you've been writing code

00:02:32.440 --> 00:02:34.850
for your programs
is you open a file,

00:02:34.850 --> 00:02:37.760
you type some code to solve
a particular problem given,

00:02:37.760 --> 00:02:41.620
like in your problem
sets, each file

00:02:41.620 --> 00:02:45.680
contains some piece of code, you
have sequences of instructions

00:02:45.680 --> 00:02:49.040
that contain maybe assignments,
loops, conditionals,

00:02:49.040 --> 00:02:50.700
and so on and so on.

00:02:50.700 --> 00:02:54.350
But really you have one
file that contains each code

00:02:54.350 --> 00:02:58.190
and you write everything
in that particular file.

00:02:58.190 --> 00:03:01.035
But this is OK for
smaller problems

00:03:01.035 --> 00:03:02.660
that we've been seeing
so far, but when

00:03:02.660 --> 00:03:04.700
you're starting to write
large pieces of code

00:03:04.700 --> 00:03:07.520
it's going to get really
messy, really quickly.

00:03:07.520 --> 00:03:10.340
So think about if you
want to use a for loop

00:03:10.340 --> 00:03:12.754
in one part of
your code, and you

00:03:12.754 --> 00:03:14.420
find it useful to use
that same for loop

00:03:14.420 --> 00:03:16.700
in another part of your code.

00:03:16.700 --> 00:03:19.290
Some point in the future as
you're debugging your code,

00:03:19.290 --> 00:03:21.290
you might want to change
your original for loop,

00:03:21.290 --> 00:03:23.081
you have to figure out
all the other places

00:03:23.081 --> 00:03:27.020
where you've used that type
of for loop for example.

00:03:27.020 --> 00:03:30.440
So as you're scaling
your code, you'll

00:03:30.440 --> 00:03:32.985
find it harder to keep
track of these details.

00:03:32.985 --> 00:03:35.360
So this is where functions
will come into play in today's

00:03:35.360 --> 00:03:37.190
lecture-- will help you out.

00:03:40.490 --> 00:03:45.580
So if you want to be
considered a good programmer,

00:03:45.580 --> 00:03:49.420
a good programming style would
be to not necessarily add

00:03:49.420 --> 00:03:51.220
lots and lots of lines
of code, but really

00:03:51.220 --> 00:03:54.610
to add more functionality
to your programs.

00:03:54.610 --> 00:03:57.430
So how many different things--
how many different features--

00:03:57.430 --> 00:04:01.420
can your program do, rather
than how long can your code be.

00:04:01.420 --> 00:04:04.134
And that'll help you
later on look at your code

00:04:04.134 --> 00:04:05.550
if you need it for
a future class,

00:04:05.550 --> 00:04:07.841
and it'll help others if they
want to look at your code

00:04:07.841 --> 00:04:10.930
later on if they find it useful.

00:04:10.930 --> 00:04:13.930
So today we're introducing
this idea of functions.

00:04:13.930 --> 00:04:16.399
And functions are
mechanisms to achieve

00:04:16.399 --> 00:04:19.410
decomposition and abstraction.

00:04:19.410 --> 00:04:21.197
So these are two
key words here that

00:04:21.197 --> 00:04:22.780
are going to pop up
in today's lecture

00:04:22.780 --> 00:04:24.860
and also in future lectures.

00:04:24.860 --> 00:04:28.530
So before I introduce
decomposition and abstraction

00:04:28.530 --> 00:04:30.420
in the context of
functions, let's

00:04:30.420 --> 00:04:33.745
first take a look at just
sort of a real-life example.

00:04:33.745 --> 00:04:35.430
So let's take a projector.

00:04:35.430 --> 00:04:37.710
I'm using one right now.

00:04:37.710 --> 00:04:40.320
Quick show of hands.

00:04:40.320 --> 00:04:42.540
If I give you all of the
electronic components

00:04:42.540 --> 00:04:47.470
that are part of a projector--
resistors, a fan, a light bulb,

00:04:47.470 --> 00:04:51.330
a lens, the casing, all of
the different parts in it.

00:04:51.330 --> 00:04:57.430
Who here would be able
to build a projector?

00:04:57.430 --> 00:04:58.150
Do I see a hand?

00:04:58.150 --> 00:04:58.680
No?

00:04:58.680 --> 00:05:00.910
Ooh oh yeah nice!

00:05:00.910 --> 00:05:01.960
You can also lie.

00:05:01.960 --> 00:05:03.610
I won't know the difference.

00:05:03.610 --> 00:05:06.790
But if you can do that,
I'd be very impressed.

00:05:06.790 --> 00:05:10.300
All right so you can't really
put together a projector right?

00:05:10.300 --> 00:05:12.610
Another show of hands.

00:05:12.610 --> 00:05:15.526
If I gave you a projector
that's fully assembled

00:05:15.526 --> 00:05:17.150
and I gave you a
computer, for example,

00:05:17.150 --> 00:05:19.400
who would be able to maybe
figure out within let's say

00:05:19.400 --> 00:05:23.360
an hour how to make
them work together?

00:05:23.360 --> 00:05:25.730
Good, a fair bit of the class.

00:05:25.730 --> 00:05:26.790
That's perfect.

00:05:26.790 --> 00:05:29.930
That's exactly the answers
I was trying to get at here.

00:05:29.930 --> 00:05:34.630
So none of us really
know how a projector

00:05:34.630 --> 00:05:37.420
works-- the internals--
but a lot more of us

00:05:37.420 --> 00:05:40.720
know how to work a
projector, just given maybe

00:05:40.720 --> 00:05:45.160
a set of basic instructions
or just intuitively speaking.

00:05:45.160 --> 00:05:47.680
So you see the projector
as sort of a black box.

00:05:47.680 --> 00:05:51.270
You don't need to know how
it works in order to use it.

00:05:51.270 --> 00:05:55.150
You know maybe what inputs
it might take, what's it

00:05:55.150 --> 00:05:57.040
supposed to do at a high level.

00:05:57.040 --> 00:06:01.120
Take whatever's on my screen and
put it up on the large screen

00:06:01.120 --> 00:06:03.760
there, just magnify
it, but you don't

00:06:03.760 --> 00:06:06.980
know how it does it-- how
the components work together.

00:06:06.980 --> 00:06:09.050
So that's the idea
of abstraction.

00:06:09.050 --> 00:06:11.380
You don't need to know how
the projector works in order

00:06:11.380 --> 00:06:13.630
to use it.

00:06:13.630 --> 00:06:15.850
OK that's abstraction.

00:06:15.850 --> 00:06:19.150
The other half of that
was decomposition.

00:06:19.150 --> 00:06:22.750
So let's say that now,
given a projector,

00:06:22.750 --> 00:06:25.690
I want to project a very,
very large image down

00:06:25.690 --> 00:06:28.840
on a very large stage.

00:06:28.840 --> 00:06:31.690
For example, this is
from one of the Olympics.

00:06:31.690 --> 00:06:33.940
It's a stage of what,
like 10 football fields,

00:06:33.940 --> 00:06:35.340
something like that?

00:06:35.340 --> 00:06:36.090
Something massive.

00:06:36.090 --> 00:06:38.080
You could build one
projector that's

00:06:38.080 --> 00:06:39.760
able to project a
very large image,

00:06:39.760 --> 00:06:41.800
but that would be
really expensive

00:06:41.800 --> 00:06:43.920
and you'd have to build
this one projector that's

00:06:43.920 --> 00:06:47.432
used for this one time.

00:06:47.432 --> 00:06:48.890
So instead what
you could do is you

00:06:48.890 --> 00:06:52.850
can take a bunch of
smaller projectors

00:06:52.850 --> 00:06:56.785
and feed different inputs
to each one of them.

00:06:56.785 --> 00:06:58.410
And as you're feeding
different inputs,

00:06:58.410 --> 00:07:00.530
each one's going to
show a different output.

00:07:00.530 --> 00:07:01.850
And then you're going
to be able to have

00:07:01.850 --> 00:07:03.933
all of these different
projectors working together

00:07:03.933 --> 00:07:07.430
to solve this larger
problem of projecting

00:07:07.430 --> 00:07:11.920
this really cool image
on a very large stage.

00:07:11.920 --> 00:07:16.870
So that's the idea
of decomposition.

00:07:16.870 --> 00:07:21.970
You take the same projector,
feed it different inputs,

00:07:21.970 --> 00:07:24.010
it does the exact same
thing behind the scenes,

00:07:24.010 --> 00:07:25.593
but it will produce
a different output

00:07:25.593 --> 00:07:28.922
for each one of these
different inputs.

00:07:28.922 --> 00:07:31.130
So these different devices
are going to work together

00:07:31.130 --> 00:07:33.380
to achieve the same
common goal, and that's

00:07:33.380 --> 00:07:36.820
the idea of decomposition.

00:07:36.820 --> 00:07:40.950
So these is where I apply
to the problem of projecting

00:07:40.950 --> 00:07:43.320
large image, or a
projector in general,

00:07:43.320 --> 00:07:47.820
but we can apply these exact
same concepts to programming.

00:07:47.820 --> 00:07:51.180
So decomposition is
really just the problem

00:07:51.180 --> 00:07:53.230
of creating structure
in your code.

00:07:53.230 --> 00:07:55.890
In the projector example,
we have separate devices

00:07:55.890 --> 00:07:58.400
working together.

00:07:58.400 --> 00:08:01.410
In programming, to
achieve decomposition

00:08:01.410 --> 00:08:03.610
you're dividing your code
into smaller modules.

00:08:03.610 --> 00:08:05.550
These are going to
be self-contained,

00:08:05.550 --> 00:08:09.240
and you can think of them as
sort of little mini-programs.

00:08:09.240 --> 00:08:12.287
You feed in some input to
them, they do a little task,

00:08:12.287 --> 00:08:13.870
and then they give
you something back.

00:08:13.870 --> 00:08:15.660
They go off and do
their thing and then

00:08:15.660 --> 00:08:19.510
they give back a result.

00:08:19.510 --> 00:08:23.720
These modules can be used
to break up your code,

00:08:23.720 --> 00:08:26.670
and the important thing
is that they're reusable.

00:08:26.670 --> 00:08:28.880
So you write a module once--
a little piece of code

00:08:28.880 --> 00:08:33.128
that does something
once-- you debug it once,

00:08:33.128 --> 00:08:35.419
and then you can reuse it
many, many times in your code

00:08:35.419 --> 00:08:37.970
with different inputs.

00:08:37.970 --> 00:08:41.120
Benefit of this is it
keeps your code organized

00:08:41.120 --> 00:08:44.495
and it keeps your code coherent.

00:08:44.495 --> 00:08:47.960
So functions are going to be
used to achieve decomposition

00:08:47.960 --> 00:08:49.920
and to create
structure in our code.

00:08:49.920 --> 00:08:52.237
We're going to see functions
today in this lecture,

00:08:52.237 --> 00:08:54.320
and in a few weeks, you're
going to actually see--

00:08:54.320 --> 00:08:56.486
when we talk about object
oriented programming-- how

00:08:56.486 --> 00:08:59.600
you can achieve
decomposition with classes.

00:08:59.600 --> 00:09:02.510
And with classes you can
create your own object types

00:09:02.510 --> 00:09:03.682
like adding some floats.

00:09:03.682 --> 00:09:06.140
You can create your own object
types for whatever you want,

00:09:06.140 --> 00:09:08.630
but that's later.

00:09:08.630 --> 00:09:12.480
OK so decomposition is creating
structure in your code.

00:09:12.480 --> 00:09:15.630
And abstraction is the idea
of suppressing details.

00:09:15.630 --> 00:09:17.780
So in the projector example,
remember, abstraction

00:09:17.780 --> 00:09:20.450
was you didn't need to know
exactly how the projector

00:09:20.450 --> 00:09:21.850
worked in order to use it.

00:09:21.850 --> 00:09:24.500
And it's going to be the
same idea in programming.

00:09:24.500 --> 00:09:28.467
So once you write a piece of
code that does a little task,

00:09:28.467 --> 00:09:30.800
you don't need to rewrite
that piece of code many times.

00:09:30.800 --> 00:09:33.537
You've written it
once, and you write

00:09:33.537 --> 00:09:35.620
this thing called a function
specification for it,

00:09:35.620 --> 00:09:36.790
or a docstring.

00:09:36.790 --> 00:09:40.002
And this is a piece of
text that tells anyone

00:09:40.002 --> 00:09:42.460
else who would want to use it
in the future-- other people,

00:09:42.460 --> 00:09:46.270
maybe yourself-- it tells
them how to use this function.

00:09:46.270 --> 00:09:48.330
What inputs does it take?

00:09:48.330 --> 00:09:49.580
What's the type of the inputs?

00:09:49.580 --> 00:09:51.550
What is the function
supposed to do?

00:09:51.550 --> 00:09:54.800
And what is the output that
you're going to get out of it?

00:09:54.800 --> 00:09:57.050
So they don't need to know
exactly how you implemented

00:09:57.050 --> 00:09:57.710
the function.

00:09:57.710 --> 00:09:59.690
They just need to know
inputs, what it does,

00:09:59.690 --> 00:10:00.620
what's the output.

00:10:00.620 --> 00:10:04.360
Those three things.

00:10:04.360 --> 00:10:08.040
OK so these functions are
then reusable chunks of code.

00:10:08.040 --> 00:10:10.320
And we'll see in a few
examples in today's lecture

00:10:10.320 --> 00:10:15.424
how to write some and
how to call functions.

00:10:15.424 --> 00:10:17.090
And as we're going
through today's code,

00:10:17.090 --> 00:10:19.790
I want you to sort of
think about functions

00:10:19.790 --> 00:10:22.340
with two different hats on.

00:10:22.340 --> 00:10:26.150
The first hat is from someone
who's writing the function.

00:10:26.150 --> 00:10:27.650
So in the projector
example, someone

00:10:27.650 --> 00:10:29.510
had to build the
first projector.

00:10:29.510 --> 00:10:32.940
Someone had to know how to put
all these components together.

00:10:32.940 --> 00:10:35.490
So that's going to be
you writing a function,

00:10:35.490 --> 00:10:38.600
so you need to know how
to make the function work.

00:10:38.600 --> 00:10:41.720
And then the other hat
is you as someone--

00:10:41.720 --> 00:10:44.210
as a programmer-- who is
just using the function.

00:10:44.210 --> 00:10:47.180
You're assuming it's already
been implemented correctly,

00:10:47.180 --> 00:10:50.300
and now you're just
using it to do something.

00:10:54.680 --> 00:10:57.019
So these are some of the
function characteristics

00:10:57.019 --> 00:10:58.810
and we'll see an example
on the next slide.

00:10:58.810 --> 00:11:01.330
So a function's
going to have a name.

00:11:01.330 --> 00:11:02.752
You have to call it something.

00:11:02.752 --> 00:11:04.210
It's going to have
some parameters.

00:11:04.210 --> 00:11:06.040
These are the inputs
to the function.

00:11:06.040 --> 00:11:09.520
You can have 0 inputs or
as many as you'd like.

00:11:09.520 --> 00:11:11.590
Function should
have a docstring.

00:11:11.590 --> 00:11:13.257
This is how you
achieve abstraction.

00:11:13.257 --> 00:11:14.965
So it's optional, but
highly recommended,

00:11:14.965 --> 00:11:16.930
and this is how you
tell other people

00:11:16.930 --> 00:11:19.780
how to use your function.

00:11:19.780 --> 00:11:22.540
Function has a body, which
is the meat and potatoes

00:11:22.540 --> 00:11:24.760
of the function-- what it does.

00:11:24.760 --> 00:11:27.540
And a function's going
to return something.

00:11:27.540 --> 00:11:30.210
It computes its thing and
then it gives back-- spits

00:11:30.210 --> 00:11:32.360
back some answer.

00:11:32.360 --> 00:11:37.660
OK here's an example of
a function definition

00:11:37.660 --> 00:11:40.300
and a function call.

00:11:40.300 --> 00:11:42.970
Function definition is up here.

00:11:42.970 --> 00:11:46.600
I'll just draw it here.

00:11:46.600 --> 00:11:50.300
This is the function
definition up here.

00:11:50.300 --> 00:11:53.190
And this is the
function call down here.

00:11:53.190 --> 00:11:57.700
So remember, someone has
to write the function that

00:11:57.700 --> 00:11:58.910
does something to begin with.

00:11:58.910 --> 00:12:00.680
So this is how you
write the function.

00:12:00.680 --> 00:12:02.770
The first is
whoops-- the first is

00:12:02.770 --> 00:12:07.440
going to be this def keyword.

00:12:07.440 --> 00:12:10.180
And def stands for--
it tells Python

00:12:10.180 --> 00:12:13.760
I'm going to define a function.

00:12:13.760 --> 00:12:15.670
Next is the name
of the function.

00:12:15.670 --> 00:12:19.630
In this case, I'm calling
the function is_even.

00:12:19.630 --> 00:12:21.400
And the function
name should really

00:12:21.400 --> 00:12:23.200
be something descriptive.

00:12:23.200 --> 00:12:25.270
Whereas someone who is
just using this function

00:12:25.270 --> 00:12:27.340
or looking at it can
pretty much tell what

00:12:27.340 --> 00:12:31.716
it's supposed to do without
going a lot farther than that.

00:12:31.716 --> 00:12:33.090
They're just
looking at the name.

00:12:35.920 --> 00:12:39.280
And then in parentheses you give
it any parameters, also known

00:12:39.280 --> 00:12:40.450
as arguments.

00:12:40.450 --> 00:12:43.920
And these parameters are
the inputs to the function.

00:12:43.920 --> 00:12:44.957
And then you do colon.

00:12:48.160 --> 00:12:53.236
OK so this is the first line
of the function definition.

00:12:53.236 --> 00:12:54.610
And after this,
everything that's

00:12:54.610 --> 00:12:58.870
going to be part of the function
is going to be indented.

00:12:58.870 --> 00:13:01.096
The next part is going
to be the docstring,

00:13:01.096 --> 00:13:02.470
or the specification,
and this is

00:13:02.470 --> 00:13:07.210
how we achieve abstraction
using functions.

00:13:07.210 --> 00:13:10.481
Specification, or the docstring,
starts with triple quotes

00:13:10.481 --> 00:13:12.480
and ends with triple
quotes, and you can sort of

00:13:12.480 --> 00:13:15.430
think about this as
a multi-line comment.

00:13:15.430 --> 00:13:16.960
It's just going
to be text that's

00:13:16.960 --> 00:13:20.320
going to be visible to
whoever uses the function,

00:13:20.320 --> 00:13:23.140
and it should tell them
the following things: What

00:13:23.140 --> 00:13:25.460
are the inputs to the function?

00:13:25.460 --> 00:13:27.820
What is the function
supposed to do generally?

00:13:27.820 --> 00:13:30.550
And what is the function
going to give back

00:13:30.550 --> 00:13:31.718
to whoever called it?

00:13:35.550 --> 00:13:39.210
The next part is going to
be the body of the function.

00:13:39.210 --> 00:13:41.430
We'll talk about what's
inside it in the next slide.

00:13:44.170 --> 00:13:45.130
And that's it.

00:13:45.130 --> 00:13:47.880
That's all for the
function definition.

00:13:47.880 --> 00:13:52.740
def blah, blah, blah, indented,
everything inside the function.

00:13:52.740 --> 00:13:57.600
So this is you writing
the function definition.

00:13:57.600 --> 00:14:00.210
Once the function
definition's written,

00:14:00.210 --> 00:14:01.650
you can call the function.

00:14:01.650 --> 00:14:04.990
And that's this part down here.

00:14:04.990 --> 00:14:06.420
And here, when
you call function,

00:14:06.420 --> 00:14:10.284
you just say its name, and
then you give it parameters.

00:14:10.284 --> 00:14:11.700
And you give it
as many parameters

00:14:11.700 --> 00:14:13.980
as the function is expecting--
in this case, only one

00:14:13.980 --> 00:14:14.906
parameter.

00:14:23.000 --> 00:14:25.434
So what's inside
the function body?

00:14:25.434 --> 00:14:27.350
You can put anything
inside the function body.

00:14:27.350 --> 00:14:28.400
You remember,
think of a function

00:14:28.400 --> 00:14:30.650
as sort of a small procedure
or a little mini-program

00:14:30.650 --> 00:14:32.030
that does something.

00:14:32.030 --> 00:14:34.040
So you can do anything
inside the function

00:14:34.040 --> 00:14:37.250
that you can do in the regular
program-- print things,

00:14:37.250 --> 00:14:40.420
do mathematical
operations, and so on.

00:14:40.420 --> 00:14:42.880
The last line is the most
important part of the function

00:14:42.880 --> 00:14:44.950
though.

00:14:44.950 --> 00:14:47.900
And it's this return statement--
that's what we call it.

00:14:47.900 --> 00:14:50.610
So it's a line of code
that starts with return,

00:14:50.610 --> 00:14:52.910
which is a keyword.

00:14:52.910 --> 00:14:56.370
And then it's going
to be some value.

00:14:56.370 --> 00:14:58.340
Notice this is an
expression here--

00:14:58.340 --> 00:15:02.005
i%2 == 0 is an expression
that's going to evaluate to some

00:15:02.005 --> 00:15:02.505
value.

00:15:06.330 --> 00:15:08.990
And as long as this
part is something

00:15:08.990 --> 00:15:13.580
that evaluates some value,
it can be anything you want.

00:15:13.580 --> 00:15:16.850
And this line here return
something tells Python, OK

00:15:16.850 --> 00:15:19.040
after you have finished
executing everything

00:15:19.040 --> 00:15:24.280
inside the function, what
value should I return?

00:15:24.280 --> 00:15:26.780
And whoever called
the function is

00:15:26.780 --> 00:15:28.700
going to get back that
value, and the function

00:15:28.700 --> 00:15:32.253
call itself will be
replaced by that value.

00:15:32.253 --> 00:15:34.540
OK so let's look at an example.

00:15:39.370 --> 00:15:43.490
I'm going to introduce
the idea of scope now.

00:15:43.490 --> 00:15:49.830
And scope just means-- is
another word for environment.

00:15:49.830 --> 00:15:52.050
So if I told you that you
could think of functions

00:15:52.050 --> 00:15:55.610
as little mini-programs,
the scope of a function

00:15:55.610 --> 00:16:00.200
is going to be a completely
separate environment

00:16:00.200 --> 00:16:03.470
than the environment
of the main program.

00:16:03.470 --> 00:16:06.800
So as soon as you
make a function call,

00:16:06.800 --> 00:16:08.810
behind the scenes
what Python says is,

00:16:08.810 --> 00:16:12.170
OK I'm in the main program
but I see a function call.

00:16:12.170 --> 00:16:14.060
I'm going to step out
of this main program.

00:16:14.060 --> 00:16:16.880
I'm going to go off into
this new environment.

00:16:16.880 --> 00:16:19.820
I'm going to create entirely
new set of variables that just

00:16:19.820 --> 00:16:23.300
exist within this environment.

00:16:23.300 --> 00:16:25.240
I'm going to do
some computations.

00:16:25.240 --> 00:16:28.490
When I see the return, I'm going
to take this one return value.

00:16:28.490 --> 00:16:30.310
I'm going to exit
that environment,

00:16:30.310 --> 00:16:34.510
and then I'm going to come
back to the main program.

00:16:34.510 --> 00:16:37.150
So as you're entering
from one scope to another,

00:16:37.150 --> 00:16:40.850
you're sort of passing
these values back and forth.

00:16:40.850 --> 00:16:43.990
So when you're entering a scope,
you're passing a variable back

00:16:43.990 --> 00:16:46.455
into the function.

00:16:46.455 --> 00:16:47.830
And when the
function's finished,

00:16:47.830 --> 00:16:52.390
you're passing a value
back to whoever called it.

00:16:52.390 --> 00:16:56.050
So once again, this top part
is the function definition.

00:16:56.050 --> 00:16:59.200
And any arguments for
the function definition

00:16:59.200 --> 00:17:01.780
are called formal parameters.

00:17:01.780 --> 00:17:03.280
And they're called
formal parameters

00:17:03.280 --> 00:17:06.250
because notice they don't
actually have a value yet.

00:17:06.250 --> 00:17:08.079
In the function
definition, you're

00:17:08.079 --> 00:17:11.270
sort of writing the function
assuming that, in this case,

00:17:11.270 --> 00:17:13.609
x is going to have some value.

00:17:13.609 --> 00:17:16.630
But you don't know
what it is yet.

00:17:16.630 --> 00:17:19.690
You only know what
value x takes when you

00:17:19.690 --> 00:17:21.410
make a function call down here.

00:17:24.420 --> 00:17:25.920
So this is your
function definition,

00:17:25.920 --> 00:17:28.089
and then later on in
your main program,

00:17:28.089 --> 00:17:31.500
you might define some
variable x is equal to 3.

00:17:31.500 --> 00:17:33.660
And then you make
a function call.

00:17:33.660 --> 00:17:36.740
f of x here is
your function call.

00:17:39.350 --> 00:17:42.490
And it says, OK I'm
calling f with the value 3,

00:17:42.490 --> 00:17:45.610
because x takes the value 3,
and then I'm going to map 3

00:17:45.610 --> 00:17:46.420
into the function.

00:17:49.160 --> 00:17:51.651
The values that are passed
into the function call

00:17:51.651 --> 00:17:54.150
are called actual parameters,
because they're going actually

00:17:54.150 --> 00:17:54.710
have a value.

00:17:57.370 --> 00:18:00.340
So let's step through this
program-- this small program--

00:18:00.340 --> 00:18:03.880
and see what exactly happens
behind the scenes in the scope.

00:18:03.880 --> 00:18:05.670
And if you're just
starting to program,

00:18:05.670 --> 00:18:07.420
I think it would be
highly valuable if you

00:18:07.420 --> 00:18:11.140
take a piece of paper as you're
doing some of these exercises

00:18:11.140 --> 00:18:13.150
and you write down
something similar to what

00:18:13.150 --> 00:18:14.620
I'm going to go through here.

00:18:14.620 --> 00:18:16.870
I think it'll help
a lot, and you'll

00:18:16.870 --> 00:18:20.260
be able to see exactly
step-by-step what variables

00:18:20.260 --> 00:18:23.830
take what values and
which scope you're in.

00:18:23.830 --> 00:18:25.900
So here we go.

00:18:25.900 --> 00:18:27.760
When the program
first starts, we're

00:18:27.760 --> 00:18:29.730
creating this global scope.

00:18:29.730 --> 00:18:33.490
It's the main program scope.

00:18:33.490 --> 00:18:35.650
In the main program
scope, the first thing

00:18:35.650 --> 00:18:38.230
that Python is going
to see is this part

00:18:38.230 --> 00:18:44.740
here-- def f of x and
then some stuff inside.

00:18:44.740 --> 00:18:48.970
This tells Python I
have a function named x,

00:18:48.970 --> 00:18:52.450
but I don't care what's
inside the code yet.

00:18:52.450 --> 00:18:55.030
I don't care what's inside
the function definition

00:18:55.030 --> 00:18:59.570
yet, because I haven't
called the function yet.

00:18:59.570 --> 00:19:01.540
So to Python it's
just some code just

00:19:01.540 --> 00:19:04.155
sitting in the global scope.

00:19:07.480 --> 00:19:09.280
So whenever you see
def, you're just

00:19:09.280 --> 00:19:10.580
putting some code in there.

00:19:10.580 --> 00:19:13.390
Then you go onto the next
line-- x is equal to 3.

00:19:13.390 --> 00:19:17.980
So in the global scope, you now
have also a variable x is 3.

00:19:17.980 --> 00:19:20.230
And then the next
line-- z is equal to f

00:19:20.230 --> 00:19:22.750
of x is a function call.

00:19:22.750 --> 00:19:24.670
As soon as you hit
a function call,

00:19:24.670 --> 00:19:28.030
you create a new scope--
a new environment.

00:19:28.030 --> 00:19:31.651
So we're temporarily leaving
the global scope and sort

00:19:31.651 --> 00:19:35.740
of portaling into a
new scope, where we're

00:19:35.740 --> 00:19:38.530
going to try to figure out what
this function's going to do

00:19:38.530 --> 00:19:41.120
and what it's going to return.

00:19:41.120 --> 00:19:45.340
So the first thing you do
is you map the parameters.

00:19:45.340 --> 00:19:48.936
So x here-- I'm
calling f of x with 3--

00:19:48.936 --> 00:19:50.560
so first thing I'm
doing is I'm mapping

00:19:50.560 --> 00:19:53.780
every one of the parameters in
the definition to their values.

00:19:53.780 --> 00:19:56.182
So first thing I'm doing
is x gets the value 3.

00:19:59.690 --> 00:20:03.660
Next line here is x
is equal to x plus 1.

00:20:03.660 --> 00:20:06.120
So we're still inside
the function call f,

00:20:06.120 --> 00:20:07.490
so x gets the value 4.

00:20:10.260 --> 00:20:13.590
We're printing this and
then we're returning x.

00:20:13.590 --> 00:20:16.180
So in the scope of
f, x is equal to 4,

00:20:16.180 --> 00:20:18.060
so we're returning
that value back

00:20:18.060 --> 00:20:20.490
to whoever called it,
which was this function

00:20:20.490 --> 00:20:22.990
call within the global scope.

00:20:22.990 --> 00:20:25.590
So this part right here-- f
of x, which was the function

00:20:25.590 --> 00:20:28.590
call-- gets replaced with 4.

00:20:28.590 --> 00:20:33.780
So inside the main
program, z is equal to 4.

00:20:33.780 --> 00:20:36.860
And that's how we pass
parameters into the function,

00:20:36.860 --> 00:20:39.380
and we got a parameter
back from the function.

00:20:39.380 --> 00:20:42.210
As soon as the function
returns something,

00:20:42.210 --> 00:20:45.350
the scope that you were in
for the function gets erased.

00:20:45.350 --> 00:20:48.770
You forget about every variable
that was created in there,

00:20:48.770 --> 00:20:50.810
delete that scope, and
you're back to wherever

00:20:50.810 --> 00:20:53.900
you started calling it.

00:20:53.900 --> 00:20:55.520
One warning though.

00:20:55.520 --> 00:20:58.520
So what happens if there's
no return statement?

00:20:58.520 --> 00:21:02.540
I said that every function
has to return something.

00:21:02.540 --> 00:21:05.210
If you don't explicitly
put a return statement,

00:21:05.210 --> 00:21:07.520
Python is going to
add one for you.

00:21:07.520 --> 00:21:09.230
You don't have to do this.

00:21:09.230 --> 00:21:14.990
And it's going to actually
have return None-- N-o-n-e.

00:21:14.990 --> 00:21:18.620
And None is the
special type-- None

00:21:18.620 --> 00:21:22.510
is the value for a special
type called NoneType,

00:21:22.510 --> 00:21:24.260
and it represents the
absence of a value.

00:21:28.460 --> 00:21:29.170
What's that?

00:21:29.170 --> 00:21:30.310
Not a string.

00:21:30.310 --> 00:21:31.270
Not a--

00:21:31.270 --> 00:21:33.520
None is not a string.

00:21:33.520 --> 00:21:35.320
None is not a string, exactly.

00:21:35.320 --> 00:21:36.937
It's a special type.

00:21:40.070 --> 00:21:44.760
OK so before we go on, I wanted
to go through a small exercise

00:21:44.760 --> 00:21:46.930
in Spyder just to show
you the difference

00:21:46.930 --> 00:21:50.290
that None and printing
and returning makes.

00:21:50.290 --> 00:21:53.360
So here are two
functions that I wrote.

00:21:53.360 --> 00:21:55.240
One is is_even_with_return.

00:21:55.240 --> 00:21:58.790
That's its name, so
pretty descriptive.

00:21:58.790 --> 00:22:02.260
It's pretty much the same
code we saw in the slides.

00:22:02.260 --> 00:22:04.800
It just has this extra
little print thing.

00:22:04.800 --> 00:22:09.900
It gets the remainder
when i is divided by 2.

00:22:09.900 --> 00:22:13.330
And it returns whether the
remainder is equal to 0.

00:22:13.330 --> 00:22:18.320
So it'll either return a
true or a false-- a Boolean.

00:22:18.320 --> 00:22:23.490
OK so my function call is this:
I'm saying is_even_with_return

00:22:23.490 --> 00:22:26.910
with a value 3.

00:22:26.910 --> 00:22:29.310
When I make this
function call, this 3

00:22:29.310 --> 00:22:32.460
gets mapped into here--
this variable here--

00:22:32.460 --> 00:22:35.190
so i is equal to 3.

00:22:35.190 --> 00:22:37.320
I'm going to print with
return, and then I'm

00:22:37.320 --> 00:22:39.390
going to say remainder
is equal to 3 percent

00:22:39.390 --> 00:22:43.890
2, which comes out to value 1,
because there's a remainder 1.

00:22:43.890 --> 00:22:45.270
And I'm going to
return whether 1

00:22:45.270 --> 00:22:48.120
is equal to 0, which is false.

00:22:48.120 --> 00:22:51.660
So this line here
returns false, but am I

00:22:51.660 --> 00:22:53.400
doing anything with the false?

00:22:53.400 --> 00:22:54.660
Not really.

00:22:54.660 --> 00:22:57.510
It's just sort of
sitting in the code here.

00:22:57.510 --> 00:23:02.970
So this gets evaluated to false.

00:23:02.970 --> 00:23:03.829
I'm not printing it.

00:23:03.829 --> 00:23:05.370
I'm not doing any
operations with it.

00:23:05.370 --> 00:23:06.370
It's just sitting there.

00:23:06.370 --> 00:23:07.610
So it won't show up anywhere.

00:23:07.610 --> 00:23:09.360
If I want the result
to show up somewhere,

00:23:09.360 --> 00:23:10.390
then I have to print it.

00:23:10.390 --> 00:23:12.015
So that's what this
next line is doing.

00:23:15.540 --> 00:23:18.000
So that one should
be straightforward.

00:23:18.000 --> 00:23:19.960
is_even_without_return's
a little bit trickier,

00:23:19.960 --> 00:23:21.600
but not too bad.

00:23:21.600 --> 00:23:25.540
I have print,
without_return inside here,

00:23:25.540 --> 00:23:28.480
and then I'm going
to get a remainder is

00:23:28.480 --> 00:23:29.600
equal to i percent 2.

00:23:29.600 --> 00:23:32.620
And notice that I'm not--
I don't have any return.

00:23:32.620 --> 00:23:36.100
So implicitly, Python's going
to add a return None for me,

00:23:36.100 --> 00:23:36.809
like that.

00:23:36.809 --> 00:23:37.850
You don't have to add it.

00:23:40.760 --> 00:23:42.380
So when I make the
function call here,

00:23:42.380 --> 00:23:45.140
it's going to do the same thing,
except that return in this case

00:23:45.140 --> 00:23:46.370
is not going to be a Boolean.

00:23:46.370 --> 00:23:49.250
It's going to be
this special None.

00:23:49.250 --> 00:23:54.890
So this is going to
get evaluated to None.

00:23:54.890 --> 00:23:56.750
Again I'm not printing it out.

00:23:56.750 --> 00:23:59.150
It's just sitting there.

00:23:59.150 --> 00:24:03.670
If I were to print out
the result of that,

00:24:03.670 --> 00:24:06.820
you'd be printing out this
value None, which if I run it,

00:24:06.820 --> 00:24:11.770
you'll see here it just
prints it out right there.

00:24:11.770 --> 00:24:15.430
So as you're doing your next
p set, it's about functions

00:24:15.430 --> 00:24:18.370
and you're seeing these Nones
popping out in some places.

00:24:18.370 --> 00:24:20.980
Check to make sure that you've
actually returned something,

00:24:20.980 --> 00:24:24.260
as opposed to just printed
something inside the function

00:24:24.260 --> 00:24:24.970
like we did here.

00:24:29.352 --> 00:24:30.810
All right so that's
the difference.

00:24:30.810 --> 00:24:33.590
And the last thing I want to
mention about this is_even

00:24:33.590 --> 00:24:36.680
function is how
useful it can be.

00:24:36.680 --> 00:24:41.480
So notice this is the
function as in the slides,

00:24:41.480 --> 00:24:46.310
and once you write the
function once, you can use it

00:24:46.310 --> 00:24:48.140
many, many times in your code.

00:24:48.140 --> 00:24:51.740
So here I'm using
the function is_even

00:24:51.740 --> 00:24:54.650
to print the numbers
between 0 and 19, including

00:24:54.650 --> 00:24:57.900
and whether the
number is even or odd.

00:24:57.900 --> 00:25:00.020
So notice this
piece of code here,

00:25:00.020 --> 00:25:01.760
once I've written
this function is_even,

00:25:01.760 --> 00:25:05.270
looks really, really nice right?

00:25:05.270 --> 00:25:11.280
I have for all the numbers in
this range if the number i is

00:25:11.280 --> 00:25:16.710
even, this is going to
return a true or false

00:25:16.710 --> 00:25:20.130
for all the numbers
0, 1, 2, 3, 4.

00:25:20.130 --> 00:25:22.320
If it's true, then I'm
going to print out even,

00:25:22.320 --> 00:25:24.450
and otherwise I'm
going to print out odd.

00:25:24.450 --> 00:25:26.550
So if I run this,
it's going to do this.

00:25:26.550 --> 00:25:29.730
0 even, 1 odd, 2
even, and so on.

00:25:29.730 --> 00:25:34.159
So notice using functions makes
my code really nice looking.

00:25:34.159 --> 00:25:35.700
If I wasn't using
functions, I'd have

00:25:35.700 --> 00:25:40.796
to put these two lines
somewhere inside here

00:25:40.796 --> 00:25:42.420
and it would look a
little bit messier.

00:25:48.220 --> 00:25:50.000
So I've said this
maybe once or twice

00:25:50.000 --> 00:25:53.450
before: in Python
everything is an object.

00:25:56.660 --> 00:25:58.910
Might not have meant
anything back then,

00:25:58.910 --> 00:26:01.790
but I think you're
going to see what I mean

00:26:01.790 --> 00:26:04.470
using this particular example.

00:26:04.470 --> 00:26:09.320
So if in Python everything's an
object-- integers are objects,

00:26:09.320 --> 00:26:13.160
floats are objects, even
functions are objects.

00:26:13.160 --> 00:26:17.930
So as you can pass objects
as parameters back and forth

00:26:17.930 --> 00:26:21.140
as function parameters, you
can also pass other functions

00:26:21.140 --> 00:26:23.900
as parameters.

00:26:23.900 --> 00:26:25.550
Let's see what this means.

00:26:25.550 --> 00:26:29.420
So we have three function
definitions here-- func_a,

00:26:29.420 --> 00:26:33.050
func_b, and func_c.

00:26:33.050 --> 00:26:36.240
And then I have three lines of
code here in my main program.

00:26:36.240 --> 00:26:39.930
So I have one called a
func_a, one called a func_b,

00:26:39.930 --> 00:26:41.970
and one call to func_c.

00:26:41.970 --> 00:26:44.370
Let's trace through, just
like in the previous example,

00:26:44.370 --> 00:26:46.830
and see what exactly happens.

00:26:46.830 --> 00:26:50.010
First thing I create
is my global scope.

00:26:50.010 --> 00:26:52.249
And I have three
function definitions.

00:26:52.249 --> 00:26:53.790
Again I don't care
what's in the code

00:26:53.790 --> 00:26:56.160
yet, because I haven't
called the functions yet.

00:26:56.160 --> 00:26:59.160
Python just knows there's these
functions with these names that

00:26:59.160 --> 00:26:59.970
contain some code.

00:27:02.576 --> 00:27:04.950
After these definitions, I
come to this line here-- print

00:27:04.950 --> 00:27:06.100
func_a.

00:27:06.100 --> 00:27:08.125
As soon as I make
a function call,

00:27:08.125 --> 00:27:09.750
I'm going to create
a new scope and I'm

00:27:09.750 --> 00:27:11.970
going to hop into there.

00:27:11.970 --> 00:27:17.415
Inside func_a, I'm going to go
and look at what func_a does.

00:27:17.415 --> 00:27:18.960
It doesn't take
in the parameters,

00:27:18.960 --> 00:27:23.310
it just prints out
this message here.

00:27:23.310 --> 00:27:26.500
And then it leaves; it's done.

00:27:26.500 --> 00:27:30.460
There's no return,
so we return None.

00:27:30.460 --> 00:27:32.260
So func_a returns
None to whoever

00:27:32.260 --> 00:27:36.430
called it, which
was that line there,

00:27:36.430 --> 00:27:38.690
so that is going to be None.

00:27:42.950 --> 00:27:43.790
Next line.

00:27:43.790 --> 00:27:48.430
This one right here-- print
5 plus some function call.

00:27:48.430 --> 00:27:50.980
Again I'm going to hop
into func_b's scope

00:27:50.980 --> 00:27:52.150
and see what to do there.

00:27:52.150 --> 00:27:55.640
So first I'm going
to map my parameters.

00:27:55.640 --> 00:28:00.610
So 2-- whoops-- 2
gets mapped to y.

00:28:00.610 --> 00:28:03.275
So inside func_b's scope, y
is going to get the value 2.

00:28:03.275 --> 00:28:04.900
That's the very first
thing I'm doing--

00:28:04.900 --> 00:28:06.984
mapping all the parameters.

00:28:06.984 --> 00:28:08.650
Then I'm going to
print this thing here,

00:28:08.650 --> 00:28:10.960
and then I'm going to return y.

00:28:10.960 --> 00:28:13.120
So inside func_b,
y has the value 2,

00:28:13.120 --> 00:28:15.540
and I'm returning 2 back
to whoever called me.

00:28:18.480 --> 00:28:22.590
So this is the value
2 and I'm going

00:28:22.590 --> 00:28:24.130
to print 5 plus 2, which is 7.

00:28:26.830 --> 00:28:27.520
Last one.

00:28:27.520 --> 00:28:28.750
This is the trickiest.

00:28:28.750 --> 00:28:29.980
Oop, that popped up.

00:28:29.980 --> 00:28:31.900
If you think you've got
it, try that exercise.

00:28:31.900 --> 00:28:34.690
But otherwise follow along.

00:28:34.690 --> 00:28:38.620
print func_c func_a.

00:28:38.620 --> 00:28:45.100
So I see that I am going
to enter func_c's scope.

00:28:45.100 --> 00:28:48.120
So I'm going to look
at what func_c does.

00:28:48.120 --> 00:28:50.640
First thing I do is I'm
mapping all the parameters.

00:28:50.640 --> 00:28:52.380
Don't even worry about
the fact that this

00:28:52.380 --> 00:28:53.820
is a function right now.

00:28:53.820 --> 00:28:56.850
Just pretend it's
x or something.

00:28:56.850 --> 00:28:59.520
So you say func_a
is going to get

00:28:59.520 --> 00:29:03.390
mapped to the variable
z inside func_c.

00:29:03.390 --> 00:29:06.030
So z is func_c.

00:29:06.030 --> 00:29:10.190
Just mapping parameters
from actual to formal.

00:29:10.190 --> 00:29:11.810
Then what do we
do inside func_c?

00:29:11.810 --> 00:29:22.400
We print out inside func_c,
and then we return z.

00:29:22.400 --> 00:29:24.880
This is the cool part.

00:29:24.880 --> 00:29:29.170
Inside func_c, z is func_a.

00:29:29.170 --> 00:29:33.040
So if you replace z
with func_a, this here

00:29:33.040 --> 00:29:36.840
becomes return func_a
open close parentheses.

00:29:36.840 --> 00:29:38.710
Look familiar?

00:29:38.710 --> 00:29:40.960
We did that function
call right there right?

00:29:40.960 --> 00:29:42.520
So that's just
another function call.

00:29:48.222 --> 00:29:49.930
So with that being
another function call,

00:29:49.930 --> 00:29:51.670
you're going to
create another scope,

00:29:51.670 --> 00:29:53.500
and you're going to
pop into that one.

00:29:53.500 --> 00:29:57.050
So we're one, two, I
guess two scopes deep,

00:29:57.050 --> 00:29:59.480
and we're trying to figure
out where we're going.

00:29:59.480 --> 00:30:02.140
So func_a's scope is
going to be up here.

00:30:02.140 --> 00:30:03.400
So what does func_a do?

00:30:03.400 --> 00:30:06.700
It just prints out this,
and it returns None.

00:30:06.700 --> 00:30:08.380
So we're going to
return None to whoever

00:30:08.380 --> 00:30:12.210
called us, which was func_c.

00:30:12.210 --> 00:30:15.500
So this line here
becomes return None.

00:30:18.840 --> 00:30:20.810
And so this line here
is going to return None

00:30:20.810 --> 00:30:25.428
to whoever called it, which
was this line down here.

00:30:25.428 --> 00:30:28.860
Oops, I didn't mean
to cross that out.

00:30:28.860 --> 00:30:32.540
So that line here is
going to print None.

00:30:32.540 --> 00:30:35.600
So if you just go
step-by-step, it

00:30:35.600 --> 00:30:37.760
shouldn't be too
bad to try to map

00:30:37.760 --> 00:30:41.210
what happens with variable
names and formal parameters

00:30:41.210 --> 00:30:43.010
and actual parameters.

00:30:43.010 --> 00:30:48.020
That's why I highly recommend
pieces of paper and pens.

00:30:48.020 --> 00:30:51.590
One last thing I want
to mention about scope

00:30:51.590 --> 00:30:53.790
before we do another example.

00:30:53.790 --> 00:30:55.790
So there are three
sort of situations

00:30:55.790 --> 00:30:57.410
you might find yourself in.

00:30:57.410 --> 00:31:01.870
The first one is probably
the most typical,

00:31:01.870 --> 00:31:05.550
and this is when you
define a function.

00:31:05.550 --> 00:31:07.390
And it's using a
variable named x

00:31:07.390 --> 00:31:11.510
in this case that's also
defined outside of the function.

00:31:11.510 --> 00:31:16.480
And that doesn't matter
because of the idea of scopes.

00:31:16.480 --> 00:31:19.589
So inside the global scope,
you can have variables x.

00:31:19.589 --> 00:31:21.130
When you're inside
a different scope,

00:31:21.130 --> 00:31:23.830
you can have whatever
variable names you want.

00:31:23.830 --> 00:31:25.249
And when you're
inside that scope,

00:31:25.249 --> 00:31:27.040
Python's going to use
those variable names,

00:31:27.040 --> 00:31:30.530
so they don't interfere
with each other at all.

00:31:30.530 --> 00:31:33.340
So in this example, I've defined
a variable x is equal to 1,

00:31:33.340 --> 00:31:36.940
and then I incremented, and that
doesn't interfere with the fact

00:31:36.940 --> 00:31:40.360
that we have a
variable x outside.

00:31:40.360 --> 00:31:43.750
This one's a little
bit trickier.

00:31:43.750 --> 00:31:49.800
I define this function
g, and all g does

00:31:49.800 --> 00:31:52.110
is access a variable x.

00:31:52.110 --> 00:31:55.800
But notice inside g, I've
never actually declared

00:31:55.800 --> 00:31:58.620
or initialized a variable x.

00:31:58.620 --> 00:32:01.450
In this f, I said
x is equal to 1.

00:32:01.450 --> 00:32:05.720
But in here, I'm
just sort of using x.

00:32:05.720 --> 00:32:07.890
So this does not
give you an error.

00:32:07.890 --> 00:32:10.190
In fact it's OK for you
to do this in Python.

00:32:10.190 --> 00:32:11.930
Python says, OK
I'm in this scope,

00:32:11.930 --> 00:32:13.660
but I don't have
a variable named

00:32:13.660 --> 00:32:18.180
x, so let me just go into the
scope of whoever called me.

00:32:18.180 --> 00:32:21.050
So I'm going to just
temporarily hop out of the scope

00:32:21.050 --> 00:32:24.620
and see is there
variable x outside of me?

00:32:24.620 --> 00:32:26.390
And it'll find this
variable x here,

00:32:26.390 --> 00:32:28.992
and it's going to
print out its values.

00:32:28.992 --> 00:32:29.974
So that's OK.

00:32:33.420 --> 00:32:35.580
This last example here
is actually not allowed

00:32:35.580 --> 00:32:39.390
in Python-- similar to
this one-- except that I'm

00:32:39.390 --> 00:32:42.840
trying to increment
a value of x,

00:32:42.840 --> 00:32:45.150
but then I'm also
trying to reassign it

00:32:45.150 --> 00:32:47.730
to the same value of x.

00:32:47.730 --> 00:32:50.520
The problem with that is I
never actually initialized

00:32:50.520 --> 00:32:53.300
x inside h.

00:32:53.300 --> 00:32:58.230
So if I said-- if inside
h, I said x is equal to 1,

00:32:58.230 --> 00:33:00.440
and then I did x
plus equals to 1,

00:33:00.440 --> 00:33:03.650
then it would be this
example here-- f of y.

00:33:03.650 --> 00:33:05.280
But I didn't do that.

00:33:05.280 --> 00:33:10.580
I just tried to access
x and then incremented

00:33:10.580 --> 00:33:12.140
and then tried to reassign it.

00:33:12.140 --> 00:33:15.740
And that's actually
not allowed in Python.

00:33:15.740 --> 00:33:20.160
There is a way around it
using global variables.

00:33:20.160 --> 00:33:24.000
But it's actually frowned
upon to use global variables,

00:33:24.000 --> 00:33:26.240
though global variables
are part of the readings

00:33:26.240 --> 00:33:29.374
for this lecture.

00:33:29.374 --> 00:33:31.040
And the reason why
it's not a great idea

00:33:31.040 --> 00:33:34.700
to use global variables is
because global variables

00:33:34.700 --> 00:33:40.340
sort of give you this
loophole around scopes,

00:33:40.340 --> 00:33:45.530
so it allows you to write code
that can become very messy.

00:33:45.530 --> 00:33:48.530
So using global variables,
you can be inside a function

00:33:48.530 --> 00:33:50.960
and then modify a
variable that's defined

00:33:50.960 --> 00:33:53.310
outside of your function.

00:33:53.310 --> 00:33:55.910
And that sort of defeats
the purpose of functions

00:33:55.910 --> 00:33:59.370
and using them in writing
these coherent modules that

00:33:59.370 --> 00:34:00.370
are separate.

00:34:03.370 --> 00:34:07.880
That said, it might sometimes be
useful to use global variables,

00:34:07.880 --> 00:34:10.478
as you'll see in a
couple lectures from now.

00:34:13.110 --> 00:34:16.120
OK cool.

00:34:16.120 --> 00:34:19.449
So let's go on to the
last scope example.

00:34:19.449 --> 00:34:22.840
OK this slide is here,
and notice I've bolded,

00:34:22.840 --> 00:34:25.480
underlined, and italicized
the Python Tutor,

00:34:25.480 --> 00:34:28.246
because I find it
extremely helpful.

00:34:28.246 --> 00:34:29.870
So the Python Tutor--
as I've mentioned

00:34:29.870 --> 00:34:32.199
in one of the assignments--
it was actually developed

00:34:32.199 --> 00:34:34.250
by a grad student here,
or post-grad student

00:34:34.250 --> 00:34:36.260
slash post-doc here.

00:34:36.260 --> 00:34:41.889
And it allows you to go
through Python, paste a code,

00:34:41.889 --> 00:34:43.620
go through it step-by-step.

00:34:43.620 --> 00:34:45.489
Like with each
iteration, it'll show you

00:34:45.489 --> 00:34:48.760
exactly what values
each variable has,

00:34:48.760 --> 00:34:52.090
what scope you're in,
when scopes get created,

00:34:52.090 --> 00:34:55.760
when scopes get destroyed,
variables within each scope.

00:34:55.760 --> 00:34:57.460
So pretty much
every single detail

00:34:57.460 --> 00:35:00.360
you need to sort of
understand functions.

00:35:00.360 --> 00:35:02.990
As we're starting to-- you can
see we've had couple questions,

00:35:02.990 --> 00:35:05.297
and these were great questions.

00:35:05.297 --> 00:35:07.630
So if you're still trying to
understand what's going on,

00:35:07.630 --> 00:35:10.210
I would highly suggest
you take a piece of code

00:35:10.210 --> 00:35:11.740
and just run it in
the Python Tutor

00:35:11.740 --> 00:35:14.620
and you should be able to
see exactly what happens,

00:35:14.620 --> 00:35:19.900
in sort of a similar way
that I've drawn my diagrams.

00:35:19.900 --> 00:35:23.800
In all of the codes for
this particular lecture,

00:35:23.800 --> 00:35:25.617
I've put links to
the Python Tutor

00:35:25.617 --> 00:35:26.950
for each one of those exercises.

00:35:26.950 --> 00:35:29.140
So you can just copy
and paste those,

00:35:29.140 --> 00:35:30.730
and it'll automatically
populate it

00:35:30.730 --> 00:35:32.560
with that particular
example, so you just

00:35:32.560 --> 00:35:34.750
have to click, step, step, step.

00:35:34.750 --> 00:35:41.450
OK so having made my plug for
Python Tutor, let's go on.

00:35:41.450 --> 00:35:44.070
OK so here's an example.

00:35:44.070 --> 00:35:47.350
It's going to show
couple things.

00:35:47.350 --> 00:35:53.910
One is print versus return,
and also this idea of you

00:35:53.910 --> 00:35:55.452
can nest functions.

00:35:55.452 --> 00:35:57.160
So just like you could
have nested loops,

00:35:57.160 --> 00:35:59.700
nested conditionals-- you
can also nest functions

00:35:59.700 --> 00:36:02.530
within functions.

00:36:02.530 --> 00:36:07.320
So let's draw some diagrams
just like before of the scopes.

00:36:07.320 --> 00:36:09.960
First thing we're going to
do is when we have a program,

00:36:09.960 --> 00:36:11.790
we're going to create
the global scope

00:36:11.790 --> 00:36:14.725
and we're going to add
every variable that we have.

00:36:14.725 --> 00:36:16.350
And then when we
reach a function call,

00:36:16.350 --> 00:36:19.657
we're going to do
something about that.

00:36:19.657 --> 00:36:21.240
So the first thing
in the global scope

00:36:21.240 --> 00:36:25.140
is this function definition.

00:36:25.140 --> 00:36:28.740
Again in my global scope,
I just have g as some code

00:36:28.740 --> 00:36:31.290
because I have
not called it yet.

00:36:31.290 --> 00:36:34.660
I only go inside a function
when I make a function call.

00:36:34.660 --> 00:36:37.560
So g contains some code.

00:36:37.560 --> 00:36:41.820
So we're done with
75% of that code.

00:36:41.820 --> 00:36:45.390
Next line is x is equal to 3.

00:36:45.390 --> 00:36:48.330
So I'm making x be a variable
inside my global scope

00:36:48.330 --> 00:36:49.620
with value 3.

00:36:49.620 --> 00:36:54.090
And then I have this
z is equal to g of x.

00:36:54.090 --> 00:36:56.310
This is a function call.

00:36:56.310 --> 00:36:59.530
When I see a function call, I'm
going to create a new scope.

00:36:59.530 --> 00:37:00.920
So here is the scope of g.

00:37:03.510 --> 00:37:11.650
With the scope of g, I'm mapping
variables to actual parameters

00:37:11.650 --> 00:37:13.672
to formal parameters.

00:37:13.672 --> 00:37:15.130
So the first thing
I'm doing is I'm

00:37:15.130 --> 00:37:19.450
saying inside g what is the
value of actual parameter x?

00:37:19.450 --> 00:37:23.640
And x is going to be the
value 3, because I've called

00:37:23.640 --> 00:37:25.290
g of x with x is equal to 3.

00:37:29.880 --> 00:37:33.630
Next, what I see
inside this function--

00:37:33.630 --> 00:37:37.647
so this is the inside of the
function-- is this bit here.

00:37:40.390 --> 00:37:43.150
It's another
function definition.

00:37:43.150 --> 00:37:44.950
Again since I'm just
defining the function

00:37:44.950 --> 00:37:51.840
and I'm not calling it, all
Python sees is h is some code.

00:37:51.840 --> 00:37:53.420
I haven't called
the function h yet,

00:37:53.420 --> 00:37:57.420
because I'm just defining
it here with def.

00:37:57.420 --> 00:38:00.430
So that finishes this part here.

00:38:00.430 --> 00:38:04.630
The next line is x
is equal to x plus 1.

00:38:04.630 --> 00:38:08.640
So inside the scope of g,
I'm incrementing x to be 4.

00:38:08.640 --> 00:38:11.930
Then I'm printing out this line.

00:38:11.930 --> 00:38:15.030
And then I've reached here-- h.

00:38:15.030 --> 00:38:19.734
This is actually a function
call, and I'm calling h.

00:38:19.734 --> 00:38:21.150
As soon as I make
a function call,

00:38:21.150 --> 00:38:22.830
I'm creating another scope.

00:38:22.830 --> 00:38:25.660
So I'm temporarily going
out of the scope of g

00:38:25.660 --> 00:38:29.120
and going into the scope of h.

00:38:29.120 --> 00:38:31.320
So Python knows that
h contains some code,

00:38:31.320 --> 00:38:34.750
and now I can go inside h
and do whatever I need to do.

00:38:34.750 --> 00:38:38.090
So the first-- so h doesn't
have any parameters,

00:38:38.090 --> 00:38:42.350
so I don't need to populate
anything like that in there.

00:38:42.350 --> 00:38:48.820
h does define a variable called
x, which is abc; it's a string.

00:38:48.820 --> 00:38:53.110
And then that's all h does.

00:38:53.110 --> 00:38:54.155
What does it return?

00:38:57.240 --> 00:38:57.740
None.

00:38:57.740 --> 00:38:59.690
I heard murmuring,
but I think None

00:38:59.690 --> 00:39:00.980
was what you guys were saying.

00:39:00.980 --> 00:39:03.556
So since there's no
return statement,

00:39:03.556 --> 00:39:06.810
h is going to return None.

00:39:06.810 --> 00:39:09.400
So h returns None.

00:39:09.400 --> 00:39:13.790
Back to whoever called it,
which was this code inside g.

00:39:13.790 --> 00:39:15.620
So that gets
replaced with None--

00:39:15.620 --> 00:39:19.820
the thing that I've--
this circled red h here.

00:39:19.820 --> 00:39:22.004
As soon as h
returns, we're going

00:39:22.004 --> 00:39:24.170
to get rid of that scope--
all the variables created

00:39:24.170 --> 00:39:27.530
within it-- and
we're done with h.

00:39:27.530 --> 00:39:29.300
So now we're back into g.

00:39:29.300 --> 00:39:31.760
And we just finished
executing this

00:39:31.760 --> 00:39:34.860
and this got replaced with None.

00:39:34.860 --> 00:39:38.840
We're not printing it out, so
this doesn't show up anywhere;

00:39:38.840 --> 00:39:41.156
it's just there.

00:39:41.156 --> 00:39:42.530
So we're finished
with that line.

00:39:42.530 --> 00:39:43.810
And the next line is return x.

00:39:46.990 --> 00:39:50.650
So x inside g is 4,
so 4 gets returned

00:39:50.650 --> 00:39:54.970
back to whoever called it, which
was in the global scope here.

00:39:54.970 --> 00:39:56.830
So this gets replaced with 4.

00:39:59.660 --> 00:40:03.200
So once we've returned x,
we've completely exited out

00:40:03.200 --> 00:40:07.100
of the scope of g,
and we've come back

00:40:07.100 --> 00:40:10.520
to whoever called us,
which was global scope

00:40:10.520 --> 00:40:12.080
and we've replaced
z is equal to g

00:40:12.080 --> 00:40:14.420
of x and that completely
got replaced with 4-- the

00:40:14.420 --> 00:40:15.185
returned value.

00:40:18.060 --> 00:40:23.020
So that's sort of
showing nested functions.

00:40:23.020 --> 00:40:25.790
All right just circling back
to decomposition-abstraction.

00:40:25.790 --> 00:40:27.070
This is the last slide.

00:40:27.070 --> 00:40:30.910
You can see if you look
at the code associated

00:40:30.910 --> 00:40:33.557
with today's lecture, there
are some other examples

00:40:33.557 --> 00:40:35.140
where you can see
just how powerful it

00:40:35.140 --> 00:40:36.160
is to use functions.

00:40:36.160 --> 00:40:38.500
And you can write really
clean and simple code

00:40:38.500 --> 00:40:43.130
if you define your own functions
and then just use them later.

00:40:43.130 --> 00:40:45.040
And the beauty of defining
your own functions

00:40:45.040 --> 00:40:46.630
that you can use
multiple times later

00:40:46.630 --> 00:40:49.210
is you only have to debug
the function once right?

00:40:49.210 --> 00:40:51.122
I know debugging is not
your favorite thing,

00:40:51.122 --> 00:40:53.080
but you only have to
debug this one thing once,

00:40:53.080 --> 00:40:55.620
and then you can know that
it's right and it works well,

00:40:55.620 --> 00:40:58.090
and you can just use
it multiple times.

00:40:58.090 --> 00:41:00.990
All right thanks everyone.

