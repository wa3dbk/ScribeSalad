WEBVTT
Kind: captions
Language: en

00:00:00.790 --> 00:00:03.190
The following content is
provided under a Creative

00:00:03.190 --> 00:00:04.730
Commons license.

00:00:04.730 --> 00:00:07.030
Your support will help
MIT OpenCourseWare

00:00:07.030 --> 00:00:11.390
continue to offer high-quality,
educational resources for free.

00:00:11.390 --> 00:00:13.990
To make a donation, or
view additional materials

00:00:13.990 --> 00:00:17.880
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.880 --> 00:00:18.850
at ocw.mit.edu.

00:00:29.957 --> 00:00:30.790
ANA BELL: All right.

00:00:30.790 --> 00:00:33.100
Let's begin.

00:00:33.100 --> 00:00:35.830
As I mentioned
before, this lecture

00:00:35.830 --> 00:00:37.690
will be recorded for OCW.

00:00:37.690 --> 00:00:39.309
Again, in future
lectures, if you

00:00:39.309 --> 00:00:41.350
don't want to have the
back of your head show up,

00:00:41.350 --> 00:00:44.880
just don't sit in
this front area here.

00:00:44.880 --> 00:00:46.630
First of all, wow,
what a crowd, you guys.

00:00:46.630 --> 00:00:48.490
We're finally in 26-100.

00:00:48.490 --> 00:00:52.240
6.0001 made it big, huh?

00:00:52.240 --> 00:00:55.960
Good afternoon and welcome to
the very first class of 6.0001,

00:00:55.960 --> 00:00:58.960
and also 600, this semester.

00:00:58.960 --> 00:01:00.610
My name is Ana Bell.

00:01:00.610 --> 00:01:01.840
First name, Ana.

00:01:01.840 --> 00:01:03.250
Last name, Bell.

00:01:03.250 --> 00:01:06.460
I'm a lecturer in
the EECS Department.

00:01:06.460 --> 00:01:08.680
And I'll be giving some
of the lectures for today,

00:01:08.680 --> 00:01:13.030
along with later on in the term,
Professor Eric Grimson, who's

00:01:13.030 --> 00:01:15.820
sitting right down there, will
be giving some of the lectures,

00:01:15.820 --> 00:01:17.620
as well.

00:01:17.620 --> 00:01:21.550
Today we're going to go over
some basic administrivia,

00:01:21.550 --> 00:01:23.101
a little bit of
course information.

00:01:23.101 --> 00:01:24.850
And then, we're going
to talk a little bit

00:01:24.850 --> 00:01:26.164
about what is computation?

00:01:26.164 --> 00:01:27.580
We'll discuss at
a very high level

00:01:27.580 --> 00:01:29.860
what computers do just
to make sure we're all

00:01:29.860 --> 00:01:31.610
on the same page.

00:01:31.610 --> 00:01:34.180
And then, we're going to dive
right into Python basics.

00:01:34.180 --> 00:01:36.763
We're going to talk a little bit
about mathematical operations

00:01:36.763 --> 00:01:38.134
you can do with Python.

00:01:38.134 --> 00:01:40.300
And then, we're going to
talk about Python variables

00:01:40.300 --> 00:01:42.010
and types.

00:01:42.010 --> 00:01:43.907
As I mentioned in my
introductory email, all

00:01:43.907 --> 00:01:46.240
the slides and code that I'll
talk about during lectures

00:01:46.240 --> 00:01:48.250
will be up before
lecture, so I highly

00:01:48.250 --> 00:01:52.540
encourage you to download
them and to have them open.

00:01:52.540 --> 00:01:56.020
We're going to go through some
in-class exercises which will

00:01:56.020 --> 00:01:57.820
be available on those slides.

00:01:57.820 --> 00:01:59.830
And it's fun to do.

00:01:59.830 --> 00:02:07.420
And it's also great if could
take notes about the code just

00:02:07.420 --> 00:02:09.210
for future reference.

00:02:09.210 --> 00:02:10.210
It's true.

00:02:10.210 --> 00:02:12.220
This is a really
fast-paced course,

00:02:12.220 --> 00:02:14.110
and we ramp up really quickly.

00:02:14.110 --> 00:02:17.842
We do want to position you
to succeed in this course.

00:02:17.842 --> 00:02:19.300
As I was writing
this, I was trying

00:02:19.300 --> 00:02:21.160
to think about when
I was first starting

00:02:21.160 --> 00:02:24.580
to program what helped
me get through my very

00:02:24.580 --> 00:02:26.110
first programming course.

00:02:26.110 --> 00:02:29.470
And this is really a good list.

00:02:29.470 --> 00:02:31.840
The first thing was I just
read the psets as soon

00:02:31.840 --> 00:02:37.600
as they came out, made sure that
the terminology just sunk in.

00:02:37.600 --> 00:02:39.760
And then, during
lectures, if the lecturer

00:02:39.760 --> 00:02:42.967
was talking about something
that suddenly I remembered,

00:02:42.967 --> 00:02:45.550
oh, I saw that word in the pset
and I didn't know what it was.

00:02:45.550 --> 00:02:46.720
Well, hey, now I
know what it is.

00:02:46.720 --> 00:02:47.200
Right?

00:02:47.200 --> 00:02:48.158
So just give it a read.

00:02:48.158 --> 00:02:51.520
You don't need to start it.

00:02:51.520 --> 00:02:55.390
If you're new to programming, I
think the key word is practice.

00:02:55.390 --> 00:02:57.880
It's like math or reading.

00:02:57.880 --> 00:03:00.260
The more you practice,
the better you get at it.

00:03:00.260 --> 00:03:01.877
You're not going to
absorb programming

00:03:01.877 --> 00:03:04.210
by watching me write programs
because I already know how

00:03:04.210 --> 00:03:05.170
to program.

00:03:05.170 --> 00:03:07.966
You guys need to practice.

00:03:07.966 --> 00:03:09.340
Download the code
before lecture.

00:03:09.340 --> 00:03:10.090
Follow along.

00:03:10.090 --> 00:03:12.430
Whatever I type,
you guys can type.

00:03:12.430 --> 00:03:14.436
And I think, also,
one of the big things

00:03:14.436 --> 00:03:16.060
is if you're new to
programming, you're

00:03:16.060 --> 00:03:19.360
kind of afraid that you're
going to break your computer.

00:03:19.360 --> 00:03:24.400
And you can't really do that
just by running Anaconda

00:03:24.400 --> 00:03:26.485
and typing in some commands.

00:03:26.485 --> 00:03:28.360
So don't be afraid to
just type some stuff in

00:03:28.360 --> 00:03:29.480
and see what it does.

00:03:29.480 --> 00:03:31.230
Worst case, you just
restart the computer.

00:03:35.390 --> 00:03:36.411
Yeah.

00:03:36.411 --> 00:03:38.160
That's probably the
big thing right there.

00:03:38.160 --> 00:03:39.743
I should have probably
highlighted it,

00:03:39.743 --> 00:03:40.881
but don't be afraid.

00:03:40.881 --> 00:03:41.380
Great.

00:03:41.380 --> 00:03:46.780
So this is pretty much a
roadmap of all of 6.0001 or 600

00:03:46.780 --> 00:03:47.890
as I've just explained it.

00:03:47.890 --> 00:03:51.880
There's three big things we
want to get out of this course.

00:03:51.880 --> 00:03:54.130
The first thing is the
knowledge of concepts,

00:03:54.130 --> 00:03:56.650
which is pretty much true of
any class that you'll take.

00:03:56.650 --> 00:03:59.740
The class will teach you
something through lectures.

00:03:59.740 --> 00:04:02.500
Exams will test
how much you know.

00:04:02.500 --> 00:04:05.830
This is a class in programming.

00:04:05.830 --> 00:04:08.950
The other thing we want
you to get out of it

00:04:08.950 --> 00:04:10.841
is programming skills.

00:04:10.841 --> 00:04:12.340
And the last thing,
and I think this

00:04:12.340 --> 00:04:13.923
is what makes this
class really great,

00:04:13.923 --> 00:04:16.240
is we teach you how
to solve problems.

00:04:16.240 --> 00:04:18.730
And we do that
through the psets.

00:04:18.730 --> 00:04:21.010
That's really how I feel
the roadmap of this course

00:04:21.010 --> 00:04:22.600
looks like.

00:04:22.600 --> 00:04:25.300
And underlying all of
these is just practice.

00:04:25.300 --> 00:04:29.800
You have to just type some
stuff away and code a lot.

00:04:29.800 --> 00:04:33.490
And you'll succeed in
this course, I think.

00:04:33.490 --> 00:04:35.590
OK.

00:04:35.590 --> 00:04:38.800
So what are the things we're
going to learn in this class?

00:04:38.800 --> 00:04:41.650
I feel like the things we're
going learn in this class

00:04:41.650 --> 00:04:44.470
can be divided into basically
three different sections.

00:04:44.470 --> 00:04:50.290
The first one is related to
these first two items here.

00:04:50.290 --> 00:04:53.380
It's really about
learning how to program.

00:04:53.380 --> 00:04:55.330
Learning how to
program, part of it

00:04:55.330 --> 00:04:58.990
is figuring out what
objects to create.

00:04:58.990 --> 00:05:00.394
You'll learn about these later.

00:05:00.394 --> 00:05:02.560
How do you represent knowledge
with data structures?

00:05:02.560 --> 00:05:04.529
That's sort of the
broad term for that.

00:05:04.529 --> 00:05:06.070
And then, as you're
writing programs,

00:05:06.070 --> 00:05:08.830
you need to-- programs
aren't just linear.

00:05:08.830 --> 00:05:10.300
Sometimes programs jump around.

00:05:10.300 --> 00:05:11.260
They make decisions.

00:05:11.260 --> 00:05:13.690
There's some control
flow to programs.

00:05:13.690 --> 00:05:18.620
That's what the second
line is going to be about.

00:05:18.620 --> 00:05:20.900
The second big
part of this course

00:05:20.900 --> 00:05:24.590
is a little bit more
abstract, and it

00:05:24.590 --> 00:05:29.000
deals with how do you write
good code, good style,

00:05:29.000 --> 00:05:30.530
code that's readable.

00:05:30.530 --> 00:05:33.020
When you write code, you
want to write it such

00:05:33.020 --> 00:05:35.480
that-- you're in big company,
other people will read it,

00:05:35.480 --> 00:05:37.970
other people will
use it, so it has

00:05:37.970 --> 00:05:40.220
to be readable and
understandable by others.

00:05:40.220 --> 00:05:41.900
To that end, you
need to write code

00:05:41.900 --> 00:05:48.820
that's well organized,
modular, easy to understand.

00:05:48.820 --> 00:05:50.570
And not only that, not
only will your code

00:05:50.570 --> 00:05:53.577
be read by other people,
but next year, maybe,

00:05:53.577 --> 00:05:55.160
you'll take another
course, and you'll

00:05:55.160 --> 00:05:56.868
want to look back at
some of the problems

00:05:56.868 --> 00:05:58.320
that you wrote in this class.

00:05:58.320 --> 00:06:00.740
You want to be able
to reread your code.

00:06:00.740 --> 00:06:03.950
If it's a big mess, you might
not be able to understand--

00:06:03.950 --> 00:06:06.530
or reunderstand--
what you were doing.

00:06:06.530 --> 00:06:08.630
So writing readable
code and organizing code

00:06:08.630 --> 00:06:10.360
is also a big part.

00:06:10.360 --> 00:06:15.680
And the last section is going
to deal with-- the first two

00:06:15.680 --> 00:06:19.100
are actually part of the
programming in Introduction

00:06:19.100 --> 00:06:21.440
to Programming and
Computer Science in Python.

00:06:21.440 --> 00:06:26.000
And the last one deals mostly
with the computer science part

00:06:26.000 --> 00:06:29.540
in Introduction to Programming
and Computer Science in Python.

00:06:29.540 --> 00:06:31.970
We're going to talk about,
once you have learned

00:06:31.970 --> 00:06:33.650
how to write programs
in Python, how do

00:06:33.650 --> 00:06:35.540
you compare programs in Python?

00:06:35.540 --> 00:06:38.162
How do you know that one program
is better than the other?

00:06:38.162 --> 00:06:39.620
How do you know
that one program is

00:06:39.620 --> 00:06:41.084
more efficient than the other?

00:06:41.084 --> 00:06:42.500
How do you know
that one algorithm

00:06:42.500 --> 00:06:45.230
is better than the other?

00:06:45.230 --> 00:06:47.480
That's what we're going to
talk about in the last part

00:06:47.480 --> 00:06:48.850
of the course.

00:06:48.850 --> 00:06:50.250
OK.

00:06:50.250 --> 00:06:52.920
That's all for the
administrative part

00:06:52.920 --> 00:06:54.230
of the course.

00:06:54.230 --> 00:06:59.640
Let's start by talking at a high
level what does a computer do.

00:06:59.640 --> 00:07:03.130
Fundamentally, it
does two things.

00:07:03.130 --> 00:07:05.960
One, performs calculations.

00:07:05.960 --> 00:07:07.770
It performs a lot
of calculations.

00:07:07.770 --> 00:07:09.680
Computers these days
are really, really fast,

00:07:09.680 --> 00:07:15.240
a billion calculations per
second is probably not far off.

00:07:15.240 --> 00:07:16.920
It performs these
calculations and it

00:07:16.920 --> 00:07:18.550
has to store them somewhere.

00:07:18.550 --> 00:07:19.050
Right?

00:07:19.050 --> 00:07:21.030
Stores them in computer memory.

00:07:21.030 --> 00:07:24.070
So a computer also has
to remember results.

00:07:24.070 --> 00:07:26.280
And these days, it's not
uncommon to find computers

00:07:26.280 --> 00:07:30.390
with hundreds of
gigabytes of storage.

00:07:30.390 --> 00:07:34.457
The kinds of calculations
that computers do,

00:07:34.457 --> 00:07:35.290
there are two kinds.

00:07:35.290 --> 00:07:37.590
One are calculations that
are built into the language.

00:07:37.590 --> 00:07:39.450
These are the very
low level types

00:07:39.450 --> 00:07:41.890
of calculations,
things like addition,

00:07:41.890 --> 00:07:45.610
subtraction,
multiplication, and so on.

00:07:45.610 --> 00:07:47.790
And once you have
a language that

00:07:47.790 --> 00:07:53.070
has these primitive calculation
types, you, as a programmer,

00:07:53.070 --> 00:07:55.890
can put these types
together and then define

00:07:55.890 --> 00:07:57.680
your own calculations.

00:07:57.680 --> 00:08:00.210
You can create new
types of calculations.

00:08:00.210 --> 00:08:04.570
And the computer will be able
to perform those, as well.

00:08:04.570 --> 00:08:07.810
I think, one thing
I want to stress--

00:08:07.810 --> 00:08:09.930
and we're going to
come back to this

00:08:09.930 --> 00:08:12.300
again during this entire
lecture, actually--

00:08:12.300 --> 00:08:15.690
is computers only know
what you tell them.

00:08:15.690 --> 00:08:18.220
Computers only do what
you tell them to do.

00:08:18.220 --> 00:08:19.860
They're not magical.

00:08:19.860 --> 00:08:22.667
They don't have a mind.

00:08:22.667 --> 00:08:24.750
They just know how to
perform calculations really,

00:08:24.750 --> 00:08:26.340
really quickly.

00:08:26.340 --> 00:08:29.936
But you have to tell them
what calculations to do.

00:08:32.940 --> 00:08:34.500
Computers don't know anything.

00:08:34.500 --> 00:08:35.220
All right.

00:08:35.220 --> 00:08:36.050
We've come to that.

00:08:40.059 --> 00:08:44.320
Let's go into the
types of knowledge.

00:08:44.320 --> 00:08:48.220
The first type of knowledge
is declarative knowledge.

00:08:48.220 --> 00:08:50.730
And those are things
like statements of fact.

00:08:50.730 --> 00:08:53.080
And this is where my
email came into play.

00:08:53.080 --> 00:08:55.500
If you read it all
the way to the bottom,

00:08:55.500 --> 00:08:57.960
you would have entered a raffle.

00:08:57.960 --> 00:08:59.890
So a statement of fact
for today's lecture

00:08:59.890 --> 00:09:03.280
is, someone will win a
prize before class ends.

00:09:03.280 --> 00:09:06.820
And the prize was
a Google Cardboard.

00:09:06.820 --> 00:09:09.890
Google state-of-the-art
virtual reality glasses.

00:09:09.890 --> 00:09:11.474
And I have them right here.

00:09:14.400 --> 00:09:15.950
Yea.

00:09:15.950 --> 00:09:18.650
I delivered on my promise.

00:09:18.650 --> 00:09:20.770
That's a statement of fact.

00:09:20.770 --> 00:09:22.600
So pretend I'm a machine.

00:09:22.600 --> 00:09:23.480
OK?

00:09:23.480 --> 00:09:26.990
I don't know anything
except what you tell me.

00:09:26.990 --> 00:09:28.100
I don't know.

00:09:28.100 --> 00:09:30.320
I know that you tell
me this statement.

00:09:30.320 --> 00:09:31.847
I'm like, OK.

00:09:31.847 --> 00:09:33.930
But how is someone going
to win a Google Cardboard

00:09:33.930 --> 00:09:35.459
before class ends, right?

00:09:35.459 --> 00:09:37.250
That's where imperative
knowledge comes in.

00:09:37.250 --> 00:09:39.530
Imperative knowledge is
the recipe, or the how-to,

00:09:39.530 --> 00:09:42.230
or the sequence of steps.

00:09:42.230 --> 00:09:43.780
Sorry.

00:09:43.780 --> 00:09:47.210
That's just my
funny for that one.

00:09:47.210 --> 00:09:53.530
So the sequence of steps
is imperative knowledge.

00:09:53.530 --> 00:09:57.930
If I'm a machine,
you need to tell me

00:09:57.930 --> 00:10:00.910
how someone will win a Google
Cardboard before class.

00:10:00.910 --> 00:10:02.680
If I follow these
steps, then technically,

00:10:02.680 --> 00:10:06.460
I should reach a conclusion.

00:10:06.460 --> 00:10:08.950
Step one, I think we've
already done that.

00:10:08.950 --> 00:10:11.590
Whoever wanted to
sign up has signed up.

00:10:11.590 --> 00:10:13.180
Now I'm going to open my IDE.

00:10:13.180 --> 00:10:14.680
I'm just basically
being a machine

00:10:14.680 --> 00:10:17.740
and following the steps
that you've told me.

00:10:17.740 --> 00:10:21.631
The IDE that we're using in
this class is called Anaconda.

00:10:21.631 --> 00:10:25.330
I'm just scrolling
down to the bottom.

00:10:25.330 --> 00:10:28.660
Hopefully, you've installed
it in problem set zero.

00:10:28.660 --> 00:10:30.610
I've opened my IDE.

00:10:30.610 --> 00:10:34.012
I'm going to follow the
next set of instructions.

00:10:34.012 --> 00:10:36.220
I'm going to choose a random
number between the first

00:10:36.220 --> 00:10:39.460
and the nth responder.

00:10:39.460 --> 00:10:42.340
Now, I'm going to actually
use Python to do this .

00:10:42.340 --> 00:10:44.620
And this is also an
example of how just

00:10:44.620 --> 00:10:46.310
a really simple
task in your life,

00:10:46.310 --> 00:10:48.742
you can use computers or
programming to do that.

00:10:48.742 --> 00:10:50.200
Because if I chose
a random number,

00:10:50.200 --> 00:10:51.824
I might be biased
because, for example,

00:10:51.824 --> 00:10:53.860
I might like the number 8.

00:10:53.860 --> 00:10:57.399
To choose a random number,
I'm going to go and say, OK,

00:10:57.399 --> 00:10:58.690
where's the list of responders?

00:10:58.690 --> 00:10:59.800
It starts at 15.

00:10:59.800 --> 00:11:03.070
Actually, it starts at
16 because that's me.

00:11:03.070 --> 00:11:05.440
We're going to choose a
random number between 16

00:11:05.440 --> 00:11:09.210
and the end person 266.

00:11:09.210 --> 00:11:11.190
Oh, we just got-- oh.

00:11:11.190 --> 00:11:13.070
OK.

00:11:13.070 --> 00:11:13.570
OK.

00:11:13.570 --> 00:11:15.028
I'm going to cut
it off right here.

00:11:15.028 --> 00:11:15.541
271.

00:11:15.541 --> 00:11:16.040
OK.

00:11:16.040 --> 00:11:18.490
16 and 271.

00:11:18.490 --> 00:11:19.330
Perfect.

00:11:19.330 --> 00:11:20.380
OK.

00:11:20.380 --> 00:11:21.880
I'm going to choose
a random number.

00:11:21.880 --> 00:11:22.900
I'm going to go to my IDE.

00:11:22.900 --> 00:11:24.490
And you don't need to
know how to do this yet,

00:11:24.490 --> 00:11:26.115
but by the end of
this class, you will.

00:11:26.115 --> 00:11:29.191
I'm just going to use Python.

00:11:29.191 --> 00:11:31.690
I'm just going to get the random
number package that's going

00:11:31.690 --> 00:11:32.950
to give me a random number.

00:11:32.950 --> 00:11:35.820
I'm going to say random.randint.

00:11:35.820 --> 00:11:40.510
And I'm going to choose a random
number between 16 and 272,

00:11:40.510 --> 00:11:41.380
OK.

00:11:41.380 --> 00:11:42.440
75.

00:11:42.440 --> 00:11:43.690
OK.

00:11:43.690 --> 00:11:44.800
Great.

00:11:44.800 --> 00:11:45.880
I chose a random number.

00:11:45.880 --> 00:11:48.557
And I'm going to find the
number in the responder's sheet.

00:11:48.557 --> 00:11:49.640
What was the number again?

00:11:49.640 --> 00:11:51.040
Sorry.

00:11:51.040 --> 00:11:52.000
75.

00:11:52.000 --> 00:11:54.020
OK.

00:11:54.020 --> 00:11:56.080
Up we go.

00:11:56.080 --> 00:11:57.710
There we go.

00:11:57.710 --> 00:12:01.300
Lauren Z-O-V. Yeah.

00:12:01.300 --> 00:12:02.060
Nice.

00:12:02.060 --> 00:12:02.710
You're here.

00:12:14.180 --> 00:12:16.110
Awesome.

00:12:16.110 --> 00:12:17.810
All right.

00:12:17.810 --> 00:12:21.200
That's an example of me
being a machine and also,

00:12:21.200 --> 00:12:23.870
at the same time, using
Python in my everyday life,

00:12:23.870 --> 00:12:28.650
just lecturing, to
find a random number.

00:12:28.650 --> 00:12:30.350
Try to use Python
wherever you can.

00:12:30.350 --> 00:12:31.725
And that just
gives you practice.

00:12:34.580 --> 00:12:35.770
That was fun.

00:12:35.770 --> 00:12:37.190
But we're at MIT.

00:12:37.190 --> 00:12:39.110
We're MIT students.

00:12:39.110 --> 00:12:41.900
And we love numbers here at MIT.

00:12:41.900 --> 00:12:44.749
Here's a numerical
example that shows

00:12:44.749 --> 00:12:46.790
the difference between
declarative and imperative

00:12:46.790 --> 00:12:50.000
knowledge.

00:12:50.000 --> 00:12:51.470
An example of
declarative knowledge

00:12:51.470 --> 00:12:54.530
is the square root of a number
x is y such that y times y

00:12:54.530 --> 00:12:57.020
is equal to x.

00:12:57.020 --> 00:12:59.010
That's just a statement
of fact It's true.

00:13:02.300 --> 00:13:05.872
Computers don't know
what to do with that.

00:13:05.872 --> 00:13:07.830
They don't know what to
do with that statement.

00:13:07.830 --> 00:13:11.270
But computers do know
how to follow a recipe.

00:13:11.270 --> 00:13:13.250
Here's a well-known algorithm.

00:13:13.250 --> 00:13:16.550
To find the square
root of a number x,

00:13:16.550 --> 00:13:23.070
let's say x is originally
16, if a computer follows

00:13:23.070 --> 00:13:26.640
this algorithm, it's going
to start with a guess, g,

00:13:26.640 --> 00:13:28.620
let's say, 3.

00:13:28.620 --> 00:13:30.940
We're trying to find
the square root of 16.

00:13:30.940 --> 00:13:34.320
We're going to calculate
g times g is 9.

00:13:34.320 --> 00:13:36.120
And we're going to
ask is if g times g

00:13:36.120 --> 00:13:39.670
is close enough to x, then
stop and say, g is the answer.

00:13:39.670 --> 00:13:42.699
I'm not really happy with
9 being really close to 16.

00:13:42.699 --> 00:13:44.490
So I'm going to say,
I'm not stopping here.

00:13:44.490 --> 00:13:47.130
I'm going to keep going.

00:13:47.130 --> 00:13:48.690
If it's not close
enough, then I'm

00:13:48.690 --> 00:13:52.920
going to make a new guess
by averaging g and x over g.

00:13:52.920 --> 00:13:54.480
That's x over g here.

00:13:54.480 --> 00:13:57.150
And that's the
average over there.

00:13:57.150 --> 00:14:00.120
And the new average is
going to be my new guess.

00:14:04.320 --> 00:14:05.430
And that's what it says.

00:14:05.430 --> 00:14:07.680
And then, the last step
is using the new guess,

00:14:07.680 --> 00:14:08.790
repeat the process.

00:14:08.790 --> 00:14:11.610
Then we go back to the beginning
and repeat the whole process

00:14:11.610 --> 00:14:13.484
over and over again.

00:14:13.484 --> 00:14:15.150
And that's what the
rest of the rows do.

00:14:15.150 --> 00:14:16.590
And you keep doing
this until you decide

00:14:16.590 --> 00:14:17.631
that you're close enough.

00:14:23.340 --> 00:14:25.140
What we saw for the
imperative knowledge

00:14:25.140 --> 00:14:26.610
in the previous
numerical example

00:14:26.610 --> 00:14:31.604
was the recipe for how to
find the square root of x.

00:14:31.604 --> 00:14:33.270
What were the three
parts of the recipe?

00:14:33.270 --> 00:14:36.090
One was a simple
sequence of steps.

00:14:36.090 --> 00:14:39.270
There were four steps.

00:14:39.270 --> 00:14:42.660
The other was a flow of
control, so there were

00:14:42.660 --> 00:14:45.360
parts where we made decisions.

00:14:45.360 --> 00:14:46.980
Are we close enough?

00:14:46.980 --> 00:14:49.320
There were parts where
we repeated some steps.

00:14:49.320 --> 00:14:52.890
At the end, we said,
repeat steps 1, 2, 3.

00:14:52.890 --> 00:14:55.320
That's the flow of control.

00:14:55.320 --> 00:14:58.340
And the last part of the
recipe was a way to stop.

00:14:58.340 --> 00:15:00.660
You don't want a program
that keeps going and going.

00:15:00.660 --> 00:15:03.869
Or for a recipe, you don't want
to keep baking bread forever.

00:15:03.869 --> 00:15:05.160
You want to stop at some point.

00:15:05.160 --> 00:15:07.800
Like 10 breads is enough, right?

00:15:07.800 --> 00:15:10.230
So you have to have
a way of stopping.

00:15:10.230 --> 00:15:12.780
In the previous example,
the way of stopping

00:15:12.780 --> 00:15:15.240
was that we decided
we were close enough.

00:15:15.240 --> 00:15:20.261
Close enough was maybe
being within .01, .001,

00:15:20.261 --> 00:15:21.010
whatever you pick.

00:15:23.830 --> 00:15:26.550
This recipe is there
for an algorithm.

00:15:26.550 --> 00:15:29.248
In computer science speak,
it's going to be an algorithm.

00:15:29.248 --> 00:15:31.622
And that's what we're going
to learn about in this class.

00:15:34.532 --> 00:15:35.740
We're dealing with computers.

00:15:35.740 --> 00:15:37.990
And we actually want
to capture a recipe

00:15:37.990 --> 00:15:41.095
inside a computer, a computer
being a mechanical process.

00:15:49.640 --> 00:15:52.952
Historically, there were two
different types of computers.

00:15:55.540 --> 00:15:57.730
Originally, there
were these things

00:15:57.730 --> 00:15:59.800
called fixed-program computers.

00:15:59.800 --> 00:16:02.110
And I'm old enough to
have used something

00:16:02.110 --> 00:16:06.710
like this, where there's
just numbers and plus, minus,

00:16:06.710 --> 00:16:08.920
multiplication,
divide, and equal.

00:16:08.920 --> 00:16:11.350
But calculators these days
are a lot more complicated.

00:16:11.350 --> 00:16:15.280
But way back then, an example
of a fixed-program computer

00:16:15.280 --> 00:16:16.210
is this calculator.

00:16:16.210 --> 00:16:19.190
It only knows how to do
addition, multiplication,

00:16:19.190 --> 00:16:20.740
subtraction, division.

00:16:20.740 --> 00:16:22.480
If you want to plot
something, you can't.

00:16:22.480 --> 00:16:27.040
If you want to go on the
internet, send email with it,

00:16:27.040 --> 00:16:27.780
you can't.

00:16:27.780 --> 00:16:31.040
It can only do this one thing.

00:16:31.040 --> 00:16:33.610
And if you wanted to create a
machine that did another thing,

00:16:33.610 --> 00:16:37.360
then you'd have to create
another fixed-program computer

00:16:37.360 --> 00:16:39.970
that did a completely
separate test.

00:16:39.970 --> 00:16:41.890
That's not very great.

00:16:41.890 --> 00:16:45.910
That's when stored-program
computers came into play.

00:16:45.910 --> 00:16:47.710
And these were machines
that could store

00:16:47.710 --> 00:16:50.530
a sequence of instructions.

00:16:50.530 --> 00:16:54.729
And these machines could execute
the sequence of instructions.

00:16:54.729 --> 00:16:56.770
And you could change the
sequence of instructions

00:16:56.770 --> 00:17:00.220
and execute this different
sequence of instructions.

00:17:00.220 --> 00:17:03.490
You could do different
tasks in the same machine.

00:17:03.490 --> 00:17:07.930
And that's the computer
as we know it these days.

00:17:07.930 --> 00:17:11.119
The central processing unit is
where all of these decisions

00:17:11.119 --> 00:17:11.619
get made.

00:17:11.619 --> 00:17:16.339
And these are all
the peripherals.

00:17:16.339 --> 00:17:20.030
The basic machine architecture--
at the heart of every computer

00:17:20.030 --> 00:17:25.280
there's just this
basic architecture--

00:17:25.280 --> 00:17:28.760
and it contains, I
guess, four main parts.

00:17:28.760 --> 00:17:31.550
The first is the memory.

00:17:31.550 --> 00:17:34.700
Input and output
is the other one.

00:17:34.700 --> 00:17:39.980
The ALU is where all of
the operations are done.

00:17:39.980 --> 00:17:41.570
And the operations
that the ALU can do

00:17:41.570 --> 00:17:44.570
are really primitive operations,
addition, subtraction,

00:17:44.570 --> 00:17:46.460
and so on.

00:17:46.460 --> 00:17:52.610
What the memory contains
is a bunch of data

00:17:52.610 --> 00:17:54.854
and your sequence
of instructions.

00:18:00.540 --> 00:18:03.870
Interacting with the Arithmetic
Logic Unit is the Control Unit.

00:18:03.870 --> 00:18:07.110
And the Control Unit
contains one program counter.

00:18:07.110 --> 00:18:09.900
When you load a sequence
of instructions,

00:18:09.900 --> 00:18:12.630
the program counter starts
at the first sequence.

00:18:15.540 --> 00:18:18.510
It starts at the sequence,
at the first instruction.

00:18:18.510 --> 00:18:22.200
It gets what the instruction
is, and it sends it to the ALU.

00:18:22.200 --> 00:18:25.990
The ALU asks, what are we
doing operations on here?

00:18:25.990 --> 00:18:27.330
What's happening?

00:18:27.330 --> 00:18:29.150
It might get some data.

00:18:29.150 --> 00:18:31.400
If you're adding two numbers,
it might get two numbers

00:18:31.400 --> 00:18:33.300
from memory.

00:18:33.300 --> 00:18:34.680
It might do some operations.

00:18:34.680 --> 00:18:37.650
And it might store
data back into memory.

00:18:37.650 --> 00:18:41.517
And after it's done, the
ALU is going to go back,

00:18:41.517 --> 00:18:43.350
and the program counter
is going to increase

00:18:43.350 --> 00:18:45.360
by 1, which means
that we're going

00:18:45.360 --> 00:18:50.200
to go to the next sequence
in the instruction set.

00:18:50.200 --> 00:18:53.840
And it just goes linearly,
instruction by instruction.

00:18:53.840 --> 00:18:56.330
There might be one
particular instruction

00:18:56.330 --> 00:18:58.100
that does some sort of test.

00:18:58.100 --> 00:19:07.040
It's going to say, is
this particular value

00:19:07.040 --> 00:19:11.330
greater or equal to or the same
as this other particular value?

00:19:11.330 --> 00:19:13.200
That's a test, an
example of a test.

00:19:13.200 --> 00:19:17.630
And the test is going to
either return true or false.

00:19:17.630 --> 00:19:20.810
And depending on the
result of that test,

00:19:20.810 --> 00:19:24.530
you might either go to
the next instruction,

00:19:24.530 --> 00:19:26.150
or you might set
the program counter

00:19:26.150 --> 00:19:29.810
to go all the way back to
the beginning, and so on.

00:19:29.810 --> 00:19:32.262
You're not just
linearly stepping

00:19:32.262 --> 00:19:33.470
through all the instructions.

00:19:33.470 --> 00:19:35.300
There might be some
control flow involved,

00:19:35.300 --> 00:19:36.800
where you might
skip an instruction,

00:19:36.800 --> 00:19:39.730
or start from the
beginning, or so on.

00:19:39.730 --> 00:19:42.410
And after you're done,
when you finished

00:19:42.410 --> 00:19:44.540
executing the last
instruction, then you

00:19:44.540 --> 00:19:47.180
might output something.

00:19:47.180 --> 00:19:53.420
That's really the basic
way that a computer works.

00:19:53.420 --> 00:19:55.790
Just to recap, you have
the stored program computer

00:19:55.790 --> 00:19:59.140
that contains these
sequences of instructions.

00:19:59.140 --> 00:20:00.950
The primitive operations
that it can do

00:20:00.950 --> 00:20:06.050
are addition, subtraction,
logic operations, tests--

00:20:06.050 --> 00:20:08.840
which are something equal
to something else, something

00:20:08.840 --> 00:20:10.790
less than, and so
on-- and moving data,

00:20:10.790 --> 00:20:14.390
so storing data, moving data
around, and things like that.

00:20:14.390 --> 00:20:19.836
And the interpreter goes
through every instruction

00:20:19.836 --> 00:20:22.460
and decides whether you're going
to go to the next instruction,

00:20:22.460 --> 00:20:28.830
skip instructions, or repeat
instructions, and so on.

00:20:28.830 --> 00:20:30.570
So we've talked
about primitives.

00:20:30.570 --> 00:20:35.267
And in fact, Alan Turing, who
was a really great computer

00:20:35.267 --> 00:20:37.350
scientist, he showed that
you can compute anything

00:20:37.350 --> 00:20:38.880
using the six primitives.

00:20:38.880 --> 00:20:46.590
And the six primitives are move
left, move right, read, write,

00:20:46.590 --> 00:20:49.050
scan, and do nothing.

00:20:49.050 --> 00:20:54.390
Using those six instructions
and the piece of tape,

00:20:54.390 --> 00:20:57.330
he showed that you
can compute anything.

00:20:57.330 --> 00:21:00.390
And using those
six instructions,

00:21:00.390 --> 00:21:03.090
programming languages
came about that

00:21:03.090 --> 00:21:05.100
created a more convenient
set of primitives.

00:21:05.100 --> 00:21:08.520
You don't have to program
in only these six commands.

00:21:11.490 --> 00:21:16.080
And one interesting thing, or
one really important thing,

00:21:16.080 --> 00:21:19.230
that came about from
these six primitives

00:21:19.230 --> 00:21:22.290
is that if you can compute
something in Python,

00:21:22.290 --> 00:21:25.770
let's say-- if you write a
program that computes something

00:21:25.770 --> 00:21:28.950
in Python, then,
in theory, you can

00:21:28.950 --> 00:21:31.260
write a program that
computes the exact same thing

00:21:31.260 --> 00:21:32.610
in any other language.

00:21:32.610 --> 00:21:36.720
And that's a really
powerful statement.

00:21:36.720 --> 00:21:39.660
Think about that today when
you review your slides.

00:21:39.660 --> 00:21:40.860
Think about that again.

00:21:40.860 --> 00:21:41.910
That's really powerful.

00:21:45.240 --> 00:21:49.980
Once you have your
set of primitives

00:21:49.980 --> 00:21:53.839
for a particular language, you
can start creating expressions.

00:21:53.839 --> 00:21:55.380
And these expressions
are going to be

00:21:55.380 --> 00:22:00.510
combinations of the primitives
in the programming language.

00:22:00.510 --> 00:22:02.790
And the expressions are
going to have some value.

00:22:02.790 --> 00:22:05.740
And they're going up some
meaning in the programming

00:22:05.740 --> 00:22:08.440
language.

00:22:08.440 --> 00:22:10.630
Let's do a little bit of
a parallel with English

00:22:10.630 --> 00:22:14.020
just so you see what I mean.

00:22:14.020 --> 00:22:15.520
In English, the
primitive constructs

00:22:15.520 --> 00:22:17.230
are going to be words.

00:22:17.230 --> 00:22:19.190
There's a lot of words
in the English language.

00:22:19.190 --> 00:22:23.230
Programming languages-- in
Python, there are primitives,

00:22:23.230 --> 00:22:25.110
but there aren't
as many of them.

00:22:25.110 --> 00:22:28.900
There are floats,
Booleans, these

00:22:28.900 --> 00:22:31.660
are numbers, strings,
and simple operators,

00:22:31.660 --> 00:22:35.170
like addition,
subtraction, and so on.

00:22:35.170 --> 00:22:38.230
So we have primitive constructs.

00:22:38.230 --> 00:22:39.820
Using these
primitive constructs,

00:22:39.820 --> 00:22:48.167
we can start creating, in
English, phrases, sentences,

00:22:48.167 --> 00:22:49.750
and the same in
programming languages.

00:22:49.750 --> 00:22:54.370
In English, we can say
something like, "cat, dog, boy.

00:22:54.370 --> 00:22:58.360
That, we say, is not
syntactically valid.

00:22:58.360 --> 00:23:00.170
That's bad syntax.

00:23:00.170 --> 00:23:01.920
That's noun, noun, noun.

00:23:01.920 --> 00:23:05.160
That doesn't make sense.

00:23:05.160 --> 00:23:08.940
What does have good syntax in
English is noun, verb, noun.

00:23:08.940 --> 00:23:12.790
So, "cat, hugs boy" is
syntactically valid.

00:23:12.790 --> 00:23:14.680
Similarly, in a
programming language,

00:23:14.680 --> 00:23:18.195
something like this-- in
Python, in this case-- a word

00:23:18.195 --> 00:23:20.320
and then the number five
doesn't really make sense.

00:23:20.320 --> 00:23:22.000
It's not syntactically valid.

00:23:22.000 --> 00:23:28.030
But something like operator,
operand, operator is OK.

00:23:28.030 --> 00:23:34.480
So once you've created these
phrases, or these expressions,

00:23:34.480 --> 00:23:37.240
that are syntactically
valid, you

00:23:37.240 --> 00:23:41.730
have to think about the static
semantics of your phrase,

00:23:41.730 --> 00:23:45.130
or of your expression.

00:23:45.130 --> 00:23:51.280
For example, in English, "I
are hungry" is good syntax.

00:23:51.280 --> 00:23:55.330
But it's weird to say.

00:23:55.330 --> 00:23:58.270
We have a pronoun, a verb,
and an adjective, which

00:23:58.270 --> 00:23:59.770
doesn't really make sense.

00:23:59.770 --> 00:24:03.490
"I am hungry" is better.

00:24:03.490 --> 00:24:07.270
This does not have
good static semantics.

00:24:07.270 --> 00:24:09.010
Similarly, in
programming languages--

00:24:09.010 --> 00:24:11.440
and you'll get the
hang of this the more

00:24:11.440 --> 00:24:15.950
you do it-- something like
this, "3.2 times 5, is OK.

00:24:15.950 --> 00:24:17.390
But what does it mean?

00:24:17.390 --> 00:24:22.330
What's the meaning to have
a word added to a number?

00:24:22.330 --> 00:24:25.660
There's no meaning behind that.

00:24:25.660 --> 00:24:28.030
Its syntax is OK,
because you have

00:24:28.030 --> 00:24:30.120
operator, operand, operator.

00:24:30.120 --> 00:24:32.770
But it doesn't really make
sense to add a number to a word,

00:24:32.770 --> 00:24:33.300
for example.

00:24:36.640 --> 00:24:39.970
Once you have created
these expressions that

00:24:39.970 --> 00:24:44.940
are syntactically correct and
static, semantically correct,

00:24:44.940 --> 00:24:48.940
in English, for example, you
think about the semantics.

00:24:48.940 --> 00:24:50.760
What's the meaning
of the phrase?

00:24:50.760 --> 00:24:52.780
In English, you can
actually have more than one

00:24:52.780 --> 00:24:56.140
meaning to an entire phrase.

00:24:56.140 --> 00:25:01.284
In this case, "flying
planes can be dangerous"

00:25:01.284 --> 00:25:02.200
can have two meanings.

00:25:02.200 --> 00:25:04.990
It's the act of flying
a plane is dangerous,

00:25:04.990 --> 00:25:08.860
or the plane that is in
the air is dangerous.

00:25:08.860 --> 00:25:10.650
And this might be
a cuter example.

00:25:10.650 --> 00:25:12.490
"This reading lamp
hasn't uttered a word

00:25:12.490 --> 00:25:13.690
since I bought it.

00:25:13.690 --> 00:25:15.160
What's going on?"

00:25:15.160 --> 00:25:16.380
So that has two meanings.

00:25:16.380 --> 00:25:21.130
It's playing on the
word "reading lamp."

00:25:21.130 --> 00:25:21.880
That's in English.

00:25:21.880 --> 00:25:23.338
In English, you
can have a sentence

00:25:23.338 --> 00:25:25.140
that has more than
one meaning, that's

00:25:25.140 --> 00:25:28.150
syntactically correct and
static, semantically correct.

00:25:28.150 --> 00:25:31.180
But in programming languages,
the program that you write,

00:25:31.180 --> 00:25:34.085
the set of instructions that
you write, only has one meaning.

00:25:34.085 --> 00:25:35.710
Remember, we're coming
back to the fact

00:25:35.710 --> 00:25:40.120
that the computer only does
what you tell it to do.

00:25:40.120 --> 00:25:42.250
It's not going to
suddenly decide

00:25:42.250 --> 00:25:46.390
to add another variable
for some reason.

00:25:46.390 --> 00:25:49.060
It's just going to execute
whatever statements you've

00:25:49.060 --> 00:25:50.715
put up.

00:25:50.715 --> 00:25:52.840
In programming languages,
there's only one meaning.

00:25:52.840 --> 00:25:58.099
But the problem that comes into
play in programming languages

00:25:58.099 --> 00:25:59.890
is it's not the meaning
that you might have

00:25:59.890 --> 00:26:03.130
intended, as the programmer.

00:26:03.130 --> 00:26:05.926
That's where things
can go wrong.

00:26:05.926 --> 00:26:07.300
And there's going
to be a lecture

00:26:07.300 --> 00:26:10.010
on debugging a little
bit later in the course.

00:26:10.010 --> 00:26:12.880
But this is here
just to tell you

00:26:12.880 --> 00:26:16.090
that if you see an error
pop up in your program,

00:26:16.090 --> 00:26:18.410
it's just some text
that says, error.

00:26:21.160 --> 00:26:28.330
For example, if we do
something like this,

00:26:28.330 --> 00:26:30.900
this is syntactically correct.

00:26:30.900 --> 00:26:31.400
Incorrect.

00:26:31.400 --> 00:26:32.230
Syntactically incorrect.

00:26:32.230 --> 00:26:32.730
See?

00:26:32.730 --> 00:26:36.050
There's some angry
text right here.

00:26:36.050 --> 00:26:37.719
What is going on?

00:26:37.719 --> 00:26:39.260
The more you program,
the more you'll

00:26:39.260 --> 00:26:41.210
get the hang of
reading these errors.

00:26:41.210 --> 00:26:43.550
But this is basically
telling me the line

00:26:43.550 --> 00:26:45.890
that I wrote is
syntactically incorrect.

00:26:45.890 --> 00:26:49.190
And it's pointing to the exact
line and says, this is wrong,

00:26:49.190 --> 00:26:52.450
so I can go back and
fix it as a programmer.

00:26:55.480 --> 00:26:57.905
Syntax errors are actually
really easily caught by Python.

00:27:00.800 --> 00:27:02.870
That was an example
of a syntax error.

00:27:02.870 --> 00:27:04.640
Static semantic
errors can also be

00:27:04.640 --> 00:27:09.830
caught by Python as long as, if
your program has some decisions

00:27:09.830 --> 00:27:13.970
to make, as long as you've
gone down the branch where

00:27:13.970 --> 00:27:18.080
the static semantic
error happens.

00:27:18.080 --> 00:27:22.160
And this is probably going to
be the most frustrating one,

00:27:22.160 --> 00:27:23.767
especially as
you're starting out.

00:27:23.767 --> 00:27:25.850
The program might do
something different than what

00:27:25.850 --> 00:27:27.740
you expected it to do.

00:27:27.740 --> 00:27:32.300
And that's not because the
program suddenly-- for example,

00:27:32.300 --> 00:27:34.460
you expected the program
to give you an output of 0

00:27:34.460 --> 00:27:37.826
for a certain test case, and
the output that you got was 10.

00:27:37.826 --> 00:27:39.200
Well, the program
didn't suddenly

00:27:39.200 --> 00:27:42.350
decide to change
its answer to 10.

00:27:42.350 --> 00:27:45.410
It just executed the
program that you wrote.

00:27:48.710 --> 00:27:50.660
That's the case where
the program gave you

00:27:50.660 --> 00:27:53.210
a different answer
than expected.

00:27:53.210 --> 00:27:55.580
Programs might crash, which
means they stop running.

00:27:55.580 --> 00:27:57.800
That's OK.

00:27:57.800 --> 00:28:00.440
Just go back to your code and
figure out what was wrong.

00:28:00.440 --> 00:28:03.650
And another example
of a different meaning

00:28:03.650 --> 00:28:06.790
than what you intended was
maybe the program won't stop.

00:28:06.790 --> 00:28:07.580
It's also OK.

00:28:07.580 --> 00:28:10.070
There are ways to stop
it besides restarting

00:28:10.070 --> 00:28:12.950
the computer.

00:28:12.950 --> 00:28:17.770
So then Python
programs are going

00:28:17.770 --> 00:28:20.260
to be sequences of
definitions and commands.

00:28:20.260 --> 00:28:25.090
We're going to have expressions
that are going to be evaluated

00:28:25.090 --> 00:28:33.820
and commands that tell the
interpreter to do something.

00:28:33.820 --> 00:28:35.410
If you've done
problem set 0, you'll

00:28:35.410 --> 00:28:37.930
see that you can type
commands directly

00:28:37.930 --> 00:28:40.720
in the shell here, which is
the part on the right where

00:28:40.720 --> 00:28:44.500
I did some really
simple things, 2 plus 4.

00:28:44.500 --> 00:28:49.480
Or you can type commands up in
here, on the left-hand side,

00:28:49.480 --> 00:28:52.100
and then run your program.

00:28:52.100 --> 00:28:54.907
Notice that, well, we'll
talk about this-- I

00:28:54.907 --> 00:28:55.990
won't talk about this now.

00:28:55.990 --> 00:28:59.920
But these are-- on the
right-hand side, typically,

00:28:59.920 --> 00:29:01.870
you write very simple
commands just if you're

00:29:01.870 --> 00:29:03.076
testing something out.

00:29:03.076 --> 00:29:04.950
And on the left-hand
side here in the editor,

00:29:04.950 --> 00:29:10.105
you write more lines and
more complicated programs.

00:29:15.130 --> 00:29:18.700
Now we're going to start
talking about Python.

00:29:18.700 --> 00:29:20.710
And in Python, we're going
to come back to this,

00:29:20.710 --> 00:29:23.530
everything is an object.

00:29:23.530 --> 00:29:27.910
And Python programs
manipulate these data objects.

00:29:27.910 --> 00:29:30.880
All objects in Python
are going to have a type.

00:29:30.880 --> 00:29:34.000
And the type is going to tell
Python the kinds of operations

00:29:34.000 --> 00:29:37.630
that you can do
on these objects.

00:29:37.630 --> 00:29:39.950
If an object is the
number five, for example,

00:29:39.950 --> 00:29:42.749
you can add the number
to another number,

00:29:42.749 --> 00:29:45.040
subtract the number, take it
to the power of something,

00:29:45.040 --> 00:29:47.260
and so on.

00:29:47.260 --> 00:29:51.520
As a more general example,
for example, I am a human.

00:29:51.520 --> 00:29:52.930
So that's my type.

00:29:52.930 --> 00:29:55.700
And I can walk, speak
English, et cetera.

00:29:55.700 --> 00:29:59.860
Chewbacca is going
to be a type Wookie.

00:29:59.860 --> 00:30:02.834
He can walk, do that
sound that I can't do.

00:30:02.834 --> 00:30:04.000
He can do that, but I can't.

00:30:04.000 --> 00:30:06.683
I'm not even going
to try, and so on.

00:30:09.640 --> 00:30:11.200
Once you have these
Python objects,

00:30:11.200 --> 00:30:14.934
everything is an
object in Python.

00:30:14.934 --> 00:30:16.600
There are actually
two types of objects.

00:30:16.600 --> 00:30:18.100
One are scalar objects.

00:30:18.100 --> 00:30:21.370
That means these are very basic
objects in Python from which

00:30:21.370 --> 00:30:24.760
everything can be made.

00:30:24.760 --> 00:30:26.050
These are scalar objects.

00:30:26.050 --> 00:30:28.480
That can't be subdivided.

00:30:28.480 --> 00:30:31.210
The other type of object
is a non-scalar object.

00:30:31.210 --> 00:30:33.700
And these are objects that
have some internal structure.

00:30:33.700 --> 00:30:36.730
For example, the
number five is a scalar

00:30:36.730 --> 00:30:39.070
object because it
can't be subdivided.

00:30:39.070 --> 00:30:41.710
But a list of numbers,
for example, 5, 6,

00:30:41.710 --> 00:30:45.370
7,8, is going to be
a non-scalar object

00:30:45.370 --> 00:30:46.600
because you can subdivide it.

00:30:46.600 --> 00:30:53.120
You can subdivide it into--
you can find parts to it.

00:30:53.120 --> 00:30:55.130
It's made up of a
sequence of numbers.

00:30:58.700 --> 00:31:01.220
Here's the list of all of
the scalar objects in Python.

00:31:01.220 --> 00:31:05.870
We have integers, for example,
all of the whole numbers.

00:31:05.870 --> 00:31:10.130
Floats, which are all of
the real numbers, anything

00:31:10.130 --> 00:31:11.510
with a decimal.

00:31:11.510 --> 00:31:13.760
Bools are Booleans.

00:31:13.760 --> 00:31:16.100
There's only two
values to Booleans.

00:31:16.100 --> 00:31:18.500
That's True and False.

00:31:18.500 --> 00:31:23.060
Note the capitalization,
capital T and capital F.

00:31:23.060 --> 00:31:24.805
And this other thing
called NoneType.

00:31:24.805 --> 00:31:26.510
It's special.

00:31:26.510 --> 00:31:28.590
It has only one
value called None.

00:31:28.590 --> 00:31:30.500
And it represents the
absence of a type.

00:31:30.500 --> 00:31:34.640
And it sometimes comes in
handy for some programs.

00:31:34.640 --> 00:31:36.390
If you want to find
the type of an object,

00:31:36.390 --> 00:31:39.532
you can use this special
command called type.

00:31:39.532 --> 00:31:41.240
And then in the
parentheses, you put down

00:31:41.240 --> 00:31:44.840
what you want to
find the type of.

00:31:44.840 --> 00:31:47.480
You can write into
the shell "type of 5,"

00:31:47.480 --> 00:31:49.566
and the shell will tell
you, that's an integer.

00:31:52.990 --> 00:31:56.290
If you happen to want to convert
between two different types,

00:31:56.290 --> 00:31:58.180
Python allows you to do that.

00:31:58.180 --> 00:32:01.450
And to do that, you
put the type that you

00:32:01.450 --> 00:32:03.820
want to convert to
right before the object

00:32:03.820 --> 00:32:05.270
that you want to convert to.

00:32:05.270 --> 00:32:12.700
So float(3) will convert the
integer 3 to the float 3.0.

00:32:12.700 --> 00:32:16.870
And similarly, you can convert
any float into an integer.

00:32:16.870 --> 00:32:20.170
And converting to an
integer just truncates.

00:32:20.170 --> 00:32:22.180
It just takes away the
decimal and whatever's

00:32:22.180 --> 00:32:26.150
after it-- it does not round--
and keeps just the integer

00:32:26.150 --> 00:32:26.650
part.

00:32:30.119 --> 00:32:31.910
For this slide, I'm
going to talk about it.

00:32:31.910 --> 00:32:35.060
But if you'd like if
you have the slides up,

00:32:35.060 --> 00:32:37.200
go to go to this exercise.

00:32:37.200 --> 00:32:41.000
And after I'm done
talking about the slide,

00:32:41.000 --> 00:32:45.532
we'll see what people
think for that exercise.

00:32:45.532 --> 00:32:47.240
One of the most
important things that you

00:32:47.240 --> 00:32:51.280
can do in basically
any programming,

00:32:51.280 --> 00:32:55.520
in Python also, is
to print things out.

00:32:55.520 --> 00:33:00.292
Printing out is how you
interact with the user.

00:33:00.292 --> 00:33:02.250
To print things out, you
use the print command.

00:33:04.850 --> 00:33:07.560
If you're in the shell, if
you simply type "3 plus 2,"

00:33:07.560 --> 00:33:09.700
you do see a value here.

00:33:09.700 --> 00:33:11.720
Five, right?

00:33:11.720 --> 00:33:13.850
But that's not actually
printing something out.

00:33:13.850 --> 00:33:18.380
And that becomes apparent
when you actually

00:33:18.380 --> 00:33:19.640
type things into the editor.

00:33:19.640 --> 00:33:23.160
If you just do "3 plus 2," and
you run the program-- that's

00:33:23.160 --> 00:33:26.270
the green button here-- you see
on the right-hand side here,

00:33:26.270 --> 00:33:27.080
it ran my program.

00:33:27.080 --> 00:33:30.200
But it didn't actually
print anything.

00:33:30.200 --> 00:33:32.150
If you type this
into the console,

00:33:32.150 --> 00:33:33.920
it does show you this
value, but that's

00:33:33.920 --> 00:33:39.470
just like peeking into the
value for you as a programmer.

00:33:39.470 --> 00:33:41.412
It's not actually
printing it out to anyone.

00:33:41.412 --> 00:33:42.870
If you want to
print something out,

00:33:42.870 --> 00:33:47.990
you have to use the print
statement like that.

00:33:47.990 --> 00:33:50.630
In this case, this is actually
going to print this number

00:33:50.630 --> 00:33:52.290
five to the console.

00:33:58.296 --> 00:33:59.545
That's basically what it says.

00:33:59.545 --> 00:34:01.794
It just tells you it's an
interaction within the shell

00:34:01.794 --> 00:34:02.410
only.

00:34:02.410 --> 00:34:04.529
It's not interacting
with anyone else.

00:34:04.529 --> 00:34:06.070
And if you don't
have any "Out," that

00:34:06.070 --> 00:34:09.489
means it got printed
out to the console.

00:34:09.489 --> 00:34:09.989
All right.

00:34:09.989 --> 00:34:13.320
We talked a little
bit about objects.

00:34:13.320 --> 00:34:16.050
Once you have objects, you can
combine objects and operators

00:34:16.050 --> 00:34:17.170
to form these expressions.

00:34:17.170 --> 00:34:19.440
And each expression is
going to have a value.

00:34:19.440 --> 00:34:22.949
So an expression
evaluates to a value.

00:34:22.949 --> 00:34:24.600
The syntax for an
expression is going

00:34:24.600 --> 00:34:30.449
to be object, operator,
object, like that.

00:34:30.449 --> 00:34:34.409
And these are some operators
you can do on ints and floats.

00:34:34.409 --> 00:34:36.580
There's the typical ones,
addition, subtraction,

00:34:36.580 --> 00:34:38.710
multiplication, and division.

00:34:38.710 --> 00:34:43.104
If, for the first
three, the answer

00:34:43.104 --> 00:34:45.270
that you get-- the type of
the answer that you get--

00:34:45.270 --> 00:34:48.480
is going to depend on the
type of your variables.

00:34:48.480 --> 00:34:52.769
If both of the variables of
the operands are integers,

00:34:52.769 --> 00:34:55.060
then the result you're going
to get is of type integer.

00:34:55.060 --> 00:34:56.893
But if at least one of
them is a float, then

00:34:56.893 --> 00:34:58.940
the result you're going
to get is a float.

00:34:58.940 --> 00:35:02.340
Division is a little
bit special in that

00:35:02.340 --> 00:35:04.690
no matter what the
operands are, the result

00:35:04.690 --> 00:35:05.940
is always going to be a float.

00:35:09.760 --> 00:35:14.480
The other operations you can
do, and these are also useful,

00:35:14.480 --> 00:35:19.140
are the remainder,
so the percent sign.

00:35:19.140 --> 00:35:22.960
If you use the percent
sign between two operands,

00:35:22.960 --> 00:35:25.540
that's going to give you the
remainder when you divide i

00:35:25.540 --> 00:35:28.024
by j.

00:35:28.024 --> 00:35:30.190
And raising something to
the power of something else

00:35:30.190 --> 00:35:32.770
is using the star star operator.

00:35:32.770 --> 00:35:36.050
And i star stars j is going
to take i to the power of j.

00:35:41.390 --> 00:35:43.940
These operations have
the typical precedence

00:35:43.940 --> 00:35:47.060
that you might expect
in math, for example.

00:35:47.060 --> 00:35:49.075
And if you'd like
to put precedence

00:35:49.075 --> 00:35:50.450
toward some other
operations, you

00:35:50.450 --> 00:35:52.270
can use parentheses to do that.

00:36:01.490 --> 00:36:03.990
All right.

00:36:03.990 --> 00:36:07.050
So we have ways of
creating expressions.

00:36:07.050 --> 00:36:13.500
And we have operations
we can do on objects.

00:36:13.500 --> 00:36:19.140
But what's going to be useful
is to be able to save values

00:36:19.140 --> 00:36:21.390
to some name.

00:36:21.390 --> 00:36:24.780
And the name is going to
be something that you pick.

00:36:24.780 --> 00:36:27.840
And it should be a
descriptive name.

00:36:27.840 --> 00:36:32.310
And when you save
the value to a name,

00:36:32.310 --> 00:36:36.030
you're going to be able
to access that value later

00:36:36.030 --> 00:36:37.950
on in your program.

00:36:37.950 --> 00:36:40.440
And that's very useful.

00:36:40.440 --> 00:36:45.270
To save a value to a variable
name, you use the equal sign.

00:36:49.180 --> 00:36:51.520
And the equal sign
is an assignment.

00:36:51.520 --> 00:36:53.080
It assigns the
right-hand side, which

00:36:53.080 --> 00:36:55.540
is a value, to the
left-hand side, which

00:36:55.540 --> 00:36:56.898
is going to be a variable name.

00:36:59.500 --> 00:37:03.000
In this case, I assigned
the float 3.14159

00:37:03.000 --> 00:37:05.590
to the variable pi.

00:37:05.590 --> 00:37:08.200
And in the second
line, I'm going

00:37:08.200 --> 00:37:10.750
to take this expression,
22 divided by 7,

00:37:10.750 --> 00:37:13.090
I'm going to evaluate it.

00:37:13.090 --> 00:37:16.060
It's going to come up
with some decimal number.

00:37:16.060 --> 00:37:19.960
And I'm going to save it
into the variable pi_approx.

00:37:19.960 --> 00:37:21.520
values are stored in memory.

00:37:21.520 --> 00:37:22.960
And this assignment
in Python, we

00:37:22.960 --> 00:37:26.950
say the assignment binds
the name to the value.

00:37:26.950 --> 00:37:30.850
When you use that name
later on in your program,

00:37:30.850 --> 00:37:35.650
you're going to be referring
to the value in memory.

00:37:35.650 --> 00:37:37.879
And if you ever want
to refer to the value

00:37:37.879 --> 00:37:39.670
later on in your code,
you just simply type

00:37:39.670 --> 00:37:44.470
the name of the variable
that you've assigned it to.

00:37:44.470 --> 00:37:48.250
So why do we want to give
names to expressions?

00:37:48.250 --> 00:37:51.670
Well, you want to reuse the
names instead of the values.

00:37:51.670 --> 00:37:54.340
And it makes your
code look a lot nicer.

00:37:54.340 --> 00:37:56.830
This is a piece of
code that calculates

00:37:56.830 --> 00:37:59.390
the area of a circle.

00:37:59.390 --> 00:38:03.110
And notice, I've assigned
a variable pi to 3.14159.

00:38:03.110 --> 00:38:07.360
I've assigned another variable
called radius to be 2.2.

00:38:07.360 --> 00:38:09.700
And then, later on in my
code, I have another line

00:38:09.700 --> 00:38:12.940
that says area-- this
is another variable-- is

00:38:12.940 --> 00:38:15.400
equal to-- this
is an assignment--

00:38:15.400 --> 00:38:17.290
to this expression.

00:38:17.290 --> 00:38:23.080
And this expression is referring
to these variable names, pi

00:38:23.080 --> 00:38:24.490
and radius.

00:38:24.490 --> 00:38:26.410
And it's going look up
their values in memory.

00:38:26.410 --> 00:38:29.080
And it's going to replace
these variable names

00:38:29.080 --> 00:38:30.100
with those values.

00:38:30.100 --> 00:38:32.850
And it's going to do
the calculation for me.

00:38:32.850 --> 00:38:34.450
And in the end, this
whole expression

00:38:34.450 --> 00:38:36.402
is going to be
replaced by one number.

00:38:36.402 --> 00:38:37.693
And it's going to be the float.

00:38:40.420 --> 00:38:45.280
Here's another exercise, while
I'm talking about the slide.

00:38:45.280 --> 00:38:49.090
I do want to make a note
about programming versus math.

00:38:49.090 --> 00:38:55.320
In math, you're often
presented with a problem

00:38:55.320 --> 00:38:57.580
that says, solve for x.

00:38:57.580 --> 00:39:00.260
x plus y is equal to
something something.

00:39:00.260 --> 00:39:03.760
Solve for x, for example.

00:39:03.760 --> 00:39:09.550
That's coming back to the
fact that computers don't

00:39:09.550 --> 00:39:10.720
know what to do with that.

00:39:10.720 --> 00:39:12.659
Computers need to
be told what to do.

00:39:12.659 --> 00:39:14.450
In programming, if you
want to solve for x,

00:39:14.450 --> 00:39:18.530
you need to tell the computer
exactly how to solve for x.

00:39:18.530 --> 00:39:20.350
You need to figure
out what formula

00:39:20.350 --> 00:39:22.900
you need to give the
computer in order to be

00:39:22.900 --> 00:39:25.690
able to solve for x.

00:39:25.690 --> 00:39:29.530
That means always in programming
the right-hand side is

00:39:29.530 --> 00:39:33.040
going to be an expression.

00:39:33.040 --> 00:39:35.980
It's something that's going
to be evaluated to a value.

00:39:35.980 --> 00:39:39.099
And the left-hand side
is always a variable.

00:39:39.099 --> 00:39:40.390
It's going to be an assignment.

00:39:40.390 --> 00:39:43.900
The equal sign is
not like in math

00:39:43.900 --> 00:39:45.820
where you can have a lot
of things to the left

00:39:45.820 --> 00:39:47.380
and a lot of things to the
right of the equal sign.

00:39:47.380 --> 00:39:49.060
There's only one thing to
the left of the equal sign.

00:39:49.060 --> 00:39:50.770
And that's going
to be a variable.

00:39:50.770 --> 00:39:53.710
An equal sign stands
for an assignment.

00:39:53.710 --> 00:39:57.130
Once we've created expressions,
and we have these assignments,

00:39:57.130 --> 00:39:59.470
you can rebind variable
names using new assignment

00:39:59.470 --> 00:40:00.250
statements.

00:40:03.160 --> 00:40:05.020
Let's look at an
example for that.

00:40:05.020 --> 00:40:07.840
Let's say this is our memory.

00:40:07.840 --> 00:40:13.420
Let's type back in the example
with finding the radius.

00:40:13.420 --> 00:40:19.030
Let's say, pi is equal to 3.14.

00:40:19.030 --> 00:40:22.210
In memory, we're going to
create this value 3.14.

00:40:22.210 --> 00:40:28.180
We're going to bind it
to the variable named pi.

00:40:28.180 --> 00:40:31.180
Next line, radius
is equal to 2.2.

00:40:31.180 --> 00:40:35.200
In memory, we're
creating this value 2.2.

00:40:35.200 --> 00:40:40.630
And we're going to bind it
to the variable named radius.

00:40:40.630 --> 00:40:44.590
Then we have this
expression here.

00:40:44.590 --> 00:40:46.630
It's going to substitute
the values for pi

00:40:46.630 --> 00:40:49.950
from memory and the value
for radius from memory.

00:40:49.950 --> 00:40:54.730
It's going to calculate the
value that this expression

00:40:54.730 --> 00:40:56.310
evaluates to.

00:40:56.310 --> 00:40:57.940
It's going to pop
that into the memory.

00:40:57.940 --> 00:40:59.925
And it's going to
assign-- because we're

00:40:59.925 --> 00:41:01.300
using the equal
sign-- it's going

00:41:01.300 --> 00:41:05.630
to assign that value
to that variable area.

00:41:08.310 --> 00:41:14.940
Now, let's say we rebind
radius to be something else.

00:41:14.940 --> 00:41:21.540
Radius i is bound
to the value 2.2.

00:41:21.540 --> 00:41:24.540
But when we do this line, radius
is equal to radius plus 1,

00:41:24.540 --> 00:41:27.600
we're going to take
away the binding to 2.2.

00:41:27.600 --> 00:41:29.970
We're going to do
this calculation.

00:41:29.970 --> 00:41:31.320
The new value is 3.2.

00:41:31.320 --> 00:41:38.070
And we're going to rebind that
value to that same variable.

00:41:38.070 --> 00:41:40.110
In memory, notice
we're still going

00:41:40.110 --> 00:41:43.860
to have this value,
2.2, floating around.

00:41:43.860 --> 00:41:46.770
But we've lost
the handle for it.

00:41:46.770 --> 00:41:48.060
There's no way to get it back.

00:41:48.060 --> 00:41:52.050
It's just in memory
sitting there.

00:41:52.050 --> 00:41:55.080
At some point, it might
get collected by what

00:41:55.080 --> 00:41:56.550
we call the garbage collector.

00:41:56.550 --> 00:42:00.960
In Python, And it'll
retrieve these lost values,

00:42:00.960 --> 00:42:05.910
and it'll reuse them for new
values, and things like that.

00:42:05.910 --> 00:42:08.520
But radius now points
to the new value.

00:42:08.520 --> 00:42:13.800
We can never get back 2.2.

00:42:13.800 --> 00:42:16.340
And that's it.

00:42:16.340 --> 00:42:18.980
The value of area-- notice,
this is very important.

00:42:18.980 --> 00:42:20.450
The value of area
did not change.

00:42:23.150 --> 00:42:26.000
And it did not change because
these are all the instructions

00:42:26.000 --> 00:42:28.460
we told the computer to do.

00:42:28.460 --> 00:42:33.290
We just told it to change
radius to be radius plus 1.

00:42:33.290 --> 00:42:37.490
We never told it to
recalculate the value of area.

00:42:37.490 --> 00:42:41.600
If I copied that line down
here, then the value of area

00:42:41.600 --> 00:42:42.830
would change.

00:42:42.830 --> 00:42:44.430
But we never told it to do that.

00:42:44.430 --> 00:42:46.954
The computer only does
what we tell it to do.

00:42:46.954 --> 00:42:47.870
That's the last thing.

00:42:47.870 --> 00:42:51.150
Next lecture, we're going
to talk about adding control

00:42:51.150 --> 00:42:53.570
flow to our programs, so
how do you tell the computer

00:42:53.570 --> 00:42:55.550
to do one thing or another?

00:42:55.550 --> 00:42:57.160
All right.

