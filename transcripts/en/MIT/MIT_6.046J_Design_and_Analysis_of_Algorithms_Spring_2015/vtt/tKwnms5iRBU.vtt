WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high quality
educational resources for free.

00:00:10.730 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.217
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.217 --> 00:00:17.842
at ocw.mit.edu.

00:00:20.930 --> 00:00:23.190
ERIK DEMAINE: All right,
let's get started.

00:00:23.190 --> 00:00:28.520
Today, we have another cool
graph algorithm or problem.

00:00:28.520 --> 00:00:31.430
Actually, we'll
have two algorithms.

00:00:31.430 --> 00:00:34.350
The problem is called
minimum spanning tree.

00:00:34.350 --> 00:00:37.250
You can probably guess from the
title what it's trying to do.

00:00:37.250 --> 00:00:38.990
We'll see two
algorithms for doing it.

00:00:38.990 --> 00:00:42.200
Both of them are in the category
of greedy algorithms, which

00:00:42.200 --> 00:00:44.710
is something we've
seen a couple of times

00:00:44.710 --> 00:00:48.960
already in 6.046,
starting with lecture 1.

00:00:48.960 --> 00:00:51.430
This is the definition of
greedy algorithm from lecture 1,

00:00:51.430 --> 00:00:52.710
roughly.

00:00:52.710 --> 00:00:56.850
The idea is to always make
greedy choices, meaning

00:00:56.850 --> 00:00:59.130
the choice is locally best.

00:00:59.130 --> 00:01:02.360
For right now, it seems
like a good thing to do,

00:01:02.360 --> 00:01:06.540
but maybe in the future
it will screw you over.

00:01:06.540 --> 00:01:08.800
And if you have a
correct greedy algorithm,

00:01:08.800 --> 00:01:10.900
you prove that it
won't screw you over.

00:01:10.900 --> 00:01:13.400
So it's sort of like
Cookie Monster here, always

00:01:13.400 --> 00:01:15.670
locally seems like a good
idea to eat another cookie,

00:01:15.670 --> 00:01:19.020
but maybe it'll bite
you in the future.

00:01:19.020 --> 00:01:23.300
So today we will embrace
our inner Cookie Monster

00:01:23.300 --> 00:01:26.530
and eat as many-- eat
the largest cookie first,

00:01:26.530 --> 00:01:29.397
would be the standard
algorithm for Cookie Monster.

00:01:29.397 --> 00:01:31.480
I don't know if you learned
that in Sesame Street,

00:01:31.480 --> 00:01:34.470
but-- all right.

00:01:34.470 --> 00:01:36.720
So what's the problem?

00:01:36.720 --> 00:01:37.930
Minimum spanning tree.

00:01:37.930 --> 00:01:40.350
Can anyone tell
me what a tree is?

00:01:40.350 --> 00:01:44.240
Formally, not the outside thing.

00:01:44.240 --> 00:01:46.590
In graph land.

00:01:46.590 --> 00:01:47.730
Acyclic graph, close.

00:01:50.450 --> 00:01:52.912
Connected acyclic graph, good.

00:01:52.912 --> 00:01:53.620
That's important.

00:01:58.850 --> 00:02:07.900
This is 604.2 stuff.

00:02:07.900 --> 00:02:11.400
OK, so how about
a spanning tree?

00:02:15.331 --> 00:02:15.830
Sorry?

00:02:15.830 --> 00:02:17.110
AUDIENCE: It contains
all the vertices.

00:02:17.110 --> 00:02:18.901
ERIK DEMAINE: It contains
all the vertices.

00:02:18.901 --> 00:02:19.590
Yeah.

00:02:19.590 --> 00:02:21.705
So let me go over here.

00:02:27.350 --> 00:02:31.890
Spanning means it contains all
the vertices, so implicit here,

00:02:31.890 --> 00:02:34.210
I guess, is subtree or subgraph.

00:02:34.210 --> 00:02:35.810
You're given a graph.

00:02:35.810 --> 00:02:38.240
You want a spanning
tree of that graph.

00:02:44.210 --> 00:02:47.000
It's going to be a tree
that lives inside the graph.

00:02:47.000 --> 00:02:49.330
So we're going to take
some of the edges of G,

00:02:49.330 --> 00:02:52.390
make a tree out of them, make
a connected acyclic graph.

00:02:52.390 --> 00:02:56.320
And that tree should hit
all the vertices in G.

00:02:56.320 --> 00:03:00.700
So this is going to be a subset
of the edges, or subgraph.

00:03:06.060 --> 00:03:08.160
Those edges should form a tree.

00:03:13.520 --> 00:03:26.300
And, I'll say, hit
all vertices of G.

00:03:26.300 --> 00:03:28.280
OK, if I just said they
should form a tree,

00:03:28.280 --> 00:03:30.600
then I could say, well,
I'll take no edges,

00:03:30.600 --> 00:03:33.160
and here's a tree
with one vertex.

00:03:33.160 --> 00:03:34.594
That's not very interesting.

00:03:34.594 --> 00:03:36.260
You want a vertex--
you want, basically,

00:03:36.260 --> 00:03:38.660
the vertex set of the tree
to be the same as the vertex

00:03:38.660 --> 00:03:40.000
set of the graph.

00:03:40.000 --> 00:03:41.547
That's the spanning property.

00:03:41.547 --> 00:03:43.005
But you still want
it to be a tree,

00:03:43.005 --> 00:03:46.840
so you want it to be connected
and you want it to be acyclic.

00:03:46.840 --> 00:03:50.600
Now if G is disconnected,
this is impossible.

00:03:50.600 --> 00:03:52.690
And for that, you could
define a spanning forest

00:03:52.690 --> 00:03:55.260
to be like a maximal
thing like this,

00:03:55.260 --> 00:03:58.240
but we'll focus on the case
here as G is connected.

00:03:58.240 --> 00:03:59.900
That's the interesting case.

00:03:59.900 --> 00:04:03.170
And so we can get
a spanning tree.

00:04:03.170 --> 00:04:03.670
All right?

00:04:03.670 --> 00:04:06.090
So what is this minimum
spanning tree problem?

00:04:09.540 --> 00:04:11.370
Minimum spanning tree.

00:04:11.370 --> 00:04:22.400
We're given a weighted
graph, just like last time,

00:04:22.400 --> 00:04:23.380
with shortest paths.

00:04:23.380 --> 00:04:34.720
We have an edge weight function
W giving me a real number, say,

00:04:34.720 --> 00:04:36.970
for every edge.

00:04:36.970 --> 00:04:42.125
And we want to find a spanning
tree of minimum total weight.

00:04:56.330 --> 00:04:59.460
So I'm going to define
the weight of a tree T

00:04:59.460 --> 00:05:03.830
to be the sum over
all edges in T,

00:05:03.830 --> 00:05:07.250
because I'm viewing a spanning
tree as a set of edges,

00:05:07.250 --> 00:05:11.000
of the weight of that edge.

00:05:11.000 --> 00:05:13.070
OK, so pretty much
what you would expect.

00:05:13.070 --> 00:05:14.520
Minimum weight spanning tree.

00:05:17.050 --> 00:05:19.320
It's a relatively
simple problem,

00:05:19.320 --> 00:05:22.110
but it's not so easy
to find an algorithm.

00:05:22.110 --> 00:05:25.390
You need to prove a lot to
make sure that you really

00:05:25.390 --> 00:05:27.550
find the right tree.

00:05:27.550 --> 00:05:30.710
I guess the really
naive algorithm here

00:05:30.710 --> 00:05:35.480
would be to try
all spanning trees,

00:05:35.480 --> 00:05:37.580
compute the weight
of each spanning tree

00:05:37.580 --> 00:05:39.760
and return the minimum.

00:05:39.760 --> 00:05:40.830
That sounds reasonable.

00:05:40.830 --> 00:05:42.890
That's correct.

00:05:42.890 --> 00:05:54.620
But it's bad, because-- n to
the fourth, that would be nice.

00:05:54.620 --> 00:05:55.570
It's larger than that.

00:06:01.290 --> 00:06:05.850
Maybe not so obvious, but
it can be exponential.

00:06:05.850 --> 00:06:08.096
Here's a graph where the
number of spanning trees

00:06:08.096 --> 00:06:08.720
is exponential.

00:06:12.980 --> 00:06:16.690
This is a complete
bipartite graph

00:06:16.690 --> 00:06:21.190
with two vertices on one side
and n vertices on the other,

00:06:21.190 --> 00:06:24.990
and so you can-- let's
say we put these two

00:06:24.990 --> 00:06:26.910
edges into the spanning tree.

00:06:26.910 --> 00:06:30.230
And now, for each
of these vertices,

00:06:30.230 --> 00:06:32.460
we can choose whether it
connects to the left vertex

00:06:32.460 --> 00:06:33.320
or the right vertix.

00:06:33.320 --> 00:06:35.861
It can only do one, but it could
do either one independently.

00:06:35.861 --> 00:06:37.630
So maybe this guy
chooses the left one,

00:06:37.630 --> 00:06:39.172
this one chooses the right one.

00:06:39.172 --> 00:06:40.880
This one chooses the
left one, and so on.

00:06:40.880 --> 00:06:44.740
If I have n vertices down here,
I have 2 to the n different

00:06:44.740 --> 00:06:46.780
spanning trees.

00:06:46.780 --> 00:06:50.632
So there can be an
exponential number.

00:06:50.632 --> 00:06:52.480
So that algorithm
is not so good.

00:06:59.400 --> 00:07:00.630
Exponential bad.

00:07:00.630 --> 00:07:01.414
Polynomial good.

00:07:01.414 --> 00:07:03.580
So today, we're going to
get a polynomial algorithm.

00:07:03.580 --> 00:07:07.320
In fact, we will get an almost
linear time algorithm as fast

00:07:07.320 --> 00:07:08.740
as Dijkstra's algorithm.

00:07:08.740 --> 00:07:11.970
But we can't use
Dijkstra's algorithm,

00:07:11.970 --> 00:07:13.640
there's no shortest paths here.

00:07:13.640 --> 00:07:16.350
Plus, one of the algorithms will
actually look pretty similar.

00:07:19.410 --> 00:07:22.340
Two lectures ago, the
dynamic programming lecture,

00:07:22.340 --> 00:07:26.510
we saw an example where
we tried to do greedy,

00:07:26.510 --> 00:07:28.500
and it gave the
wrong answer, and so

00:07:28.500 --> 00:07:30.010
we fell back on
dynamic programming.

00:07:30.010 --> 00:07:33.330
Today, we're going to try
to do dynamic programming,

00:07:33.330 --> 00:07:36.590
it's going to fail, and we're
going to fall back on greedy.

00:07:36.590 --> 00:07:37.665
It's like the reverse.

00:07:37.665 --> 00:07:39.040
But the way it's
going to fail is

00:07:39.040 --> 00:07:41.700
we're going to get
exponential time initially,

00:07:41.700 --> 00:07:44.870
and then greedy will let
us get polynomial time.

00:07:44.870 --> 00:07:46.390
This is actually a bit unusual.

00:07:46.390 --> 00:07:49.250
I would say more typically,
dynamic programming

00:07:49.250 --> 00:07:51.890
can solve anything,
but, you know, with n

00:07:51.890 --> 00:07:54.599
to the seventh running
time, something slow.

00:07:54.599 --> 00:07:56.390
And then you apply
greedy, and you get down

00:07:56.390 --> 00:07:58.290
to like n or n log
n running time.

00:07:58.290 --> 00:07:59.560
So that's more common.

00:07:59.560 --> 00:08:01.435
But today, we're going
to go from exponential

00:08:01.435 --> 00:08:02.532
down to polynomial.

00:08:02.532 --> 00:08:03.490
And that's pretty nice.

00:08:07.280 --> 00:08:07.910
Cool.

00:08:07.910 --> 00:08:14.280
So let me tell you a little
bit about greedy algorithm

00:08:14.280 --> 00:08:15.375
theory, so to speak.

00:08:20.697 --> 00:08:21.780
This is from the textbook.

00:08:27.070 --> 00:08:32.159
If your problem can be
solved by greedy algorithm,

00:08:32.159 --> 00:08:34.200
usually you can
prove two properties

00:08:34.200 --> 00:08:36.880
about that algorithm.

00:08:36.880 --> 00:08:38.975
One of them is called
optimal substructure.

00:08:49.400 --> 00:08:51.700
And the other is called
the greedy choice property.

00:08:51.700 --> 00:08:59.850
Optimal substructure
should be familiar idea

00:08:59.850 --> 00:09:02.460
because it's essentially
an encapsulation

00:09:02.460 --> 00:09:03.515
of dynamic programming.

00:09:33.429 --> 00:09:34.970
Greedy algorithms
are, in some sense,

00:09:34.970 --> 00:09:36.635
a special form of
dynamic programming.

00:09:48.300 --> 00:09:50.000
So this is saying
something like,

00:09:50.000 --> 00:09:52.634
if you can solve
subproblems optimally,

00:09:52.634 --> 00:09:54.550
smaller subproblems, or
whatever, then you can

00:09:54.550 --> 00:09:56.480
solve your original problem.

00:09:56.480 --> 00:09:58.640
And this may happen
recursively, whatever.

00:09:58.640 --> 00:10:00.820
That's essentially
what makes a recurrence

00:10:00.820 --> 00:10:03.620
work for dynamic programming.

00:10:03.620 --> 00:10:09.470
And with dynamic programming,
for this to be possible,

00:10:09.470 --> 00:10:13.137
we need to guess some
feature of the solution.

00:10:13.137 --> 00:10:14.720
For example, in
minimum spanning tree,

00:10:14.720 --> 00:10:17.430
maybe you guess one of the edges
that's in the right answer.

00:10:20.290 --> 00:10:22.710
And then, once you do
that, you can reduce it

00:10:22.710 --> 00:10:24.636
to some other subproblems.

00:10:24.636 --> 00:10:26.260
And if you can solve
those subproblems,

00:10:26.260 --> 00:10:27.790
you combine them and
get an optimal solution

00:10:27.790 --> 00:10:28.748
to your original thing.

00:10:28.748 --> 00:10:30.930
So this is a familiar property.

00:10:30.930 --> 00:10:34.140
I don't usually think of it this
way for dynamic programming,

00:10:34.140 --> 00:10:39.002
but that is essentially what
we're doing via guessing.

00:10:39.002 --> 00:10:41.210
But with greedy algorithms,
we're not going to guess.

00:10:41.210 --> 00:10:43.020
We're just going to be greedy.

00:10:43.020 --> 00:10:44.490
Eat the largest cookie.

00:10:44.490 --> 00:10:46.795
And so that's the
greedy choice property.

00:10:58.990 --> 00:11:01.590
This says that eating
the largest cookie

00:11:01.590 --> 00:11:03.650
is actually a good thing to do.

00:11:10.546 --> 00:11:13.950
If we keep making
locally optimal choices,

00:11:13.950 --> 00:11:16.100
will end up with a
globally optimal solution.

00:11:25.650 --> 00:11:27.010
No tummy ache.

00:11:32.710 --> 00:11:35.310
This is something you wouldn't
expect to be true in general,

00:11:35.310 --> 00:11:38.382
but it's going to be true
for minimum spanning tree.

00:11:38.382 --> 00:11:40.300
And it's true for a
handful of other problems.

00:11:40.300 --> 00:11:42.258
You'll see a bunch more
in recitation tomorrow.

00:11:46.190 --> 00:11:48.330
This is sort of general
theory, but I'm actually

00:11:48.330 --> 00:11:51.650
going to have a theorem like
this for minimum spanning tree

00:11:51.650 --> 00:11:54.716
and a theorem like this
for minimum spanning tree.

00:11:54.716 --> 00:11:58.290
This is the prototype, but most
of today is all about minimum

00:11:58.290 --> 00:11:58.970
spanning tree.

00:12:02.202 --> 00:12:04.160
And for minimum spanning
tree, neither of these

00:12:04.160 --> 00:12:05.880
is very obvious.

00:12:05.880 --> 00:12:08.290
So I'm just going to
show you these theorems.

00:12:08.290 --> 00:12:12.324
They're fairly easy to prove,
in fact, but finding them

00:12:12.324 --> 00:12:13.490
is probably the tricky part.

00:12:26.880 --> 00:12:29.990
Actually, I guess optimal
substructure is probably

00:12:29.990 --> 00:12:34.496
the least intuitive or the
least obvious greedy choice.

00:12:34.496 --> 00:12:35.870
You're probably
already thinking,

00:12:35.870 --> 00:12:37.820
what are good greedy choices?

00:12:37.820 --> 00:12:41.100
Minimum weight edge seems
like a good starting point,

00:12:41.100 --> 00:12:43.160
which we will get to.

00:12:43.160 --> 00:12:45.260
But there's even
a stronger version

00:12:45.260 --> 00:12:47.100
of that, which we will prove.

00:12:47.100 --> 00:12:49.620
And first, optimal substructure.

00:12:49.620 --> 00:12:53.750
So here, I'm going to think
like a dynamic program.

00:12:53.750 --> 00:12:58.110
Let's suppose that we know an
edge that's in our solution.

00:12:58.110 --> 00:12:59.820
Suppose we know
an edge that lives

00:12:59.820 --> 00:13:01.650
in a minimum spanning tree.

00:13:01.650 --> 00:13:02.950
We could guess that.

00:13:02.950 --> 00:13:05.880
We're not going
to, but we could.

00:13:05.880 --> 00:13:11.850
Either way, let's just
suppose than an edge e--

00:13:11.850 --> 00:13:14.020
I should mention, I
guess I didn't say,

00:13:14.020 --> 00:13:16.250
this graph is undirected.

00:13:16.250 --> 00:13:18.460
A minimum spanning tree
doesn't quite make sense

00:13:18.460 --> 00:13:19.540
with directed graphs.

00:13:19.540 --> 00:13:21.164
There are other
versions of the problem

00:13:21.164 --> 00:13:24.090
but here, the graph
is undirected.

00:13:24.090 --> 00:13:28.032
So probably, I should write
this as a unordered set, u,

00:13:28.032 --> 00:13:41.416
v. And there are possibly
many minimum spanning trees.

00:13:41.416 --> 00:13:43.540
There could be many solutions
with the same weight.

00:13:43.540 --> 00:13:46.170
For example, if all of
these edges have weight 1,

00:13:46.170 --> 00:13:49.610
all of these trees
are actually minimum.

00:13:49.610 --> 00:13:51.790
If all the edges have weight
1, every spanning tree

00:13:51.790 --> 00:13:54.440
is minimum, because every
spanning tree has exactly

00:13:54.440 --> 00:13:55.315
n minus 1 edges.

00:13:57.840 --> 00:13:59.810
But let's suppose we
know an edge that's

00:13:59.810 --> 00:14:05.060
guaranteed to be in some minimum
spanning tree, at least one.

00:14:05.060 --> 00:14:09.400
What I would like to do is take
this, so let me draw a picture.

00:14:09.400 --> 00:14:12.070
I have a graph.

00:14:12.070 --> 00:14:16.400
We've identified some edge
in the graph, e, that lives

00:14:16.400 --> 00:14:18.970
in some minimum spanning tree.

00:14:18.970 --> 00:14:21.610
I'm going to draw some kind
of tree structure here.

00:14:29.400 --> 00:14:30.860
OK.

00:14:30.860 --> 00:14:33.185
The wiggly lines are the tree.

00:14:33.185 --> 00:14:34.644
There are some
other edges in here,

00:14:34.644 --> 00:14:37.226
which I don't want to draw too
many of them because it's ugly.

00:14:37.226 --> 00:14:38.900
Those are other
edges in the graph.

00:14:38.900 --> 00:14:39.941
Who knows where they are?

00:14:39.941 --> 00:14:43.130
They could be all
sorts of things.

00:14:43.130 --> 00:14:43.630
OK?

00:14:43.630 --> 00:14:48.230
But I've highlighted the
graph in a particular way.

00:14:48.230 --> 00:14:50.730
Because the minimum
spanning tree

00:14:50.730 --> 00:14:54.470
is a tree, if I delete
e from the tree, then

00:14:54.470 --> 00:14:56.850
I get two components.

00:14:56.850 --> 00:14:59.950
Every edge I remove--
I'm minimally connected.

00:14:59.950 --> 00:15:02.680
So if I delete an edge, I
disconnect into two parts,

00:15:02.680 --> 00:15:06.530
so I've drawn that as the left
circle and the right circle.

00:15:06.530 --> 00:15:08.780
It's just a general way
to think about a tree.

00:15:08.780 --> 00:15:11.160
Now there are other unused
edges in this picture,

00:15:11.160 --> 00:15:13.961
who knows where they live?

00:15:13.961 --> 00:15:14.460
OK?

00:15:14.460 --> 00:15:18.770
What I would like to do is
somehow simplify this graph

00:15:18.770 --> 00:15:22.045
and get a smaller problem,
say a graph with fewer edges.

00:15:25.820 --> 00:15:27.360
Any suggestions
on how to do that?

00:15:32.090 --> 00:15:34.790
I don't actually know where
all these white edges are,

00:15:34.790 --> 00:15:39.240
but what I'd like to do is--
I'm supposing I know where e is,

00:15:39.240 --> 00:15:41.810
and that's an edge in my
minimum spanning tree.

00:15:41.810 --> 00:15:44.800
So how could I get rid of it?

00:15:48.252 --> 00:15:48.752
Yeah.

00:15:48.752 --> 00:15:50.234
AUDIENCE: Find
the minimum weight

00:15:50.234 --> 00:15:51.720
spanning tree of the two edges.

00:15:51.720 --> 00:15:52.960
ERIK DEMAINE: I'd like
to divide and conquer.

00:15:52.960 --> 00:15:54.410
Maybe find the
minimum weight over

00:15:54.410 --> 00:15:55.701
here, minimum weight over here.

00:15:55.701 --> 00:15:58.330
Of course, I don't know
which nodes are in what side.

00:15:58.330 --> 00:16:00.180
So that's a little trickier.

00:16:00.180 --> 00:16:02.064
But what do I do but E itself?

00:16:02.064 --> 00:16:02.980
Let's start with that.

00:16:06.917 --> 00:16:07.417
Yeah.

00:16:07.417 --> 00:16:08.417
AUDIENCE: You remove it?

00:16:08.417 --> 00:16:09.882
ERIK DEMAINE: You
could remove it.

00:16:09.882 --> 00:16:10.868
That's a good idea.

00:16:10.868 --> 00:16:16.810
Doesn't work, but worth
a Frisbee nonetheless.

00:16:16.810 --> 00:16:19.520
If I delete this
edge, one problem

00:16:19.520 --> 00:16:22.540
is maybe none of these red
edges exist and then my graph

00:16:22.540 --> 00:16:23.860
is disconnected.

00:16:23.860 --> 00:16:26.740
Well, maybe that's
actually a good case.

00:16:26.740 --> 00:16:28.380
That probably would
be a good case.

00:16:28.380 --> 00:16:30.384
Then I know how to
divide and conquer.

00:16:30.384 --> 00:16:32.050
I just look at the
connected components.

00:16:32.050 --> 00:16:36.170
In general, if I
delete the edge,

00:16:36.170 --> 00:16:39.066
and I have these red
edges, then I maybe

00:16:39.066 --> 00:16:40.940
find a minimum spanning
tree on what remains.

00:16:43.750 --> 00:16:46.180
Maybe I'll end up including
one of these edges.

00:16:46.180 --> 00:16:49.660
Maybe this edge ends up
in the spanning tree,

00:16:49.660 --> 00:16:51.790
and then I can't put E in.

00:16:51.790 --> 00:16:53.700
So it's a little awkward.

00:16:53.700 --> 00:16:54.200
Yeah?

00:16:54.200 --> 00:16:56.158
AUDIENCE: Can you merge
the two nodes into one?

00:16:56.158 --> 00:16:57.560
Merge the two nodes into one.

00:16:57.560 --> 00:16:58.570
Yes.

00:16:58.570 --> 00:17:01.450
Purple Frisbee.

00:17:01.450 --> 00:17:02.920
Impressive.

00:17:02.920 --> 00:17:05.189
This is what we call
contracting the edge.

00:17:09.920 --> 00:17:13.260
It just means merge
the endpoints.

00:17:13.260 --> 00:17:23.249
Merge u and v. So I will draw
a new version of the graph.

00:17:29.840 --> 00:17:32.580
So this was u and v before.

00:17:32.580 --> 00:17:34.880
You've got to put
the label inside.

00:17:34.880 --> 00:17:39.310
And now we have a new
vertex here, which is uv.

00:17:39.310 --> 00:17:42.040
Or you can think it
as the set u, v. We

00:17:42.040 --> 00:17:44.680
won't really need to
keep track of names.

00:17:44.680 --> 00:17:50.120
And whatever edges
you had over here,

00:17:50.120 --> 00:17:52.930
you're going to have over here.

00:17:52.930 --> 00:17:53.430
OK?

00:17:53.430 --> 00:17:56.223
Just collapse u and v.
The edge e disappears.

00:17:59.910 --> 00:18:03.180
And one other thing can happen.

00:18:03.180 --> 00:18:08.280
Let me-- go over here.

00:18:14.040 --> 00:18:17.420
We could end up with duplicate
edges by this process.

00:18:17.420 --> 00:18:21.750
So for example, suppose
we have u and v,

00:18:21.750 --> 00:18:24.050
and they have a common neighbor.

00:18:24.050 --> 00:18:27.280
Might have many common
neighbors, who knows.

00:18:27.280 --> 00:18:31.160
Add some other edges,
uncommon neighbors.

00:18:31.160 --> 00:18:40.250
When I merge, I'd
like to just have

00:18:40.250 --> 00:18:44.065
a single edge to that vertex and
a single edge to that vertex.

00:18:44.065 --> 00:18:45.440
And what I'm going
to do is, if I

00:18:45.440 --> 00:18:49.070
have some weights on these
edges, let's say a and b,

00:18:49.070 --> 00:18:52.700
and c and d, I'm just
going to take the minimum.

00:18:57.780 --> 00:19:00.420
Because what I'm about to do is
compute a minimum spanning tree

00:19:00.420 --> 00:19:02.810
in this graph.

00:19:02.810 --> 00:19:04.700
And if I take the minimum
spanning tree here,

00:19:04.700 --> 00:19:07.250
and I had multiple
edges-- one weight a,

00:19:07.250 --> 00:19:10.150
one weight b-- do you think I
would choose the larger weight

00:19:10.150 --> 00:19:11.170
edge?

00:19:11.170 --> 00:19:12.870
It does-- they're
exactly the same edge,

00:19:12.870 --> 00:19:13.927
but one is higher weight.

00:19:13.927 --> 00:19:16.010
There's no point in keeping
the higher weight one,

00:19:16.010 --> 00:19:18.840
so I'm just going to throw
away the higher weight one.

00:19:18.840 --> 00:19:20.500
Take them in.

00:19:20.500 --> 00:19:26.300
So this is a particular form
of edge contraction and graphs.

00:19:26.300 --> 00:19:30.180
And I claim it's a good
thing to do, in the sense

00:19:30.180 --> 00:19:32.190
that if I can find a
minimum spanning tree

00:19:32.190 --> 00:19:34.470
in this new graph--
this is usually

00:19:34.470 --> 00:19:41.190
called a G slash e, slash
instead of negative, to remove

00:19:41.190 --> 00:19:41.983
e.

00:19:41.983 --> 00:19:44.552
I'm contracting e.

00:19:44.552 --> 00:19:46.680
So this is G slash e.

00:19:46.680 --> 00:19:52.150
This is G. If I can find a
minimum spanning tree in G

00:19:52.150 --> 00:19:57.570
slash e, I claim I can find
one in the original graph G

00:19:57.570 --> 00:20:00.680
just by adding the edge e.

00:20:00.680 --> 00:20:08.690
So I'm going to
say if G prime is

00:20:08.690 --> 00:20:14.350
a minimum spanning
tree, of G slash e,

00:20:14.350 --> 00:20:29.630
then T prime union e is a
minimum spanning tree of G.

00:20:29.630 --> 00:20:31.270
So overall, you
can think of this

00:20:31.270 --> 00:20:33.620
as a recurrence in
a dynamic program,

00:20:33.620 --> 00:20:36.010
and let me write down
that dynamic program.

00:20:39.130 --> 00:20:41.200
It won't be very
good dynamic program,

00:20:41.200 --> 00:20:42.350
but it's a starting point.

00:20:52.880 --> 00:20:55.010
This is conceptually
what we want to do.

00:20:55.010 --> 00:21:00.340
We're trying to guess
an edge e that's

00:21:00.340 --> 00:21:03.960
in a minimum spanning tree.

00:21:03.960 --> 00:21:05.600
Then we're going to
contract that edge.

00:21:10.030 --> 00:21:13.720
Then we're going to recurse,
find the minimum spanning tree

00:21:13.720 --> 00:21:18.310
on what remains, and then we
find the minimum spanning tree.

00:21:18.310 --> 00:21:20.750
Then we want to
decontract the edge,

00:21:20.750 --> 00:21:24.670
put it back, put the
graph back the way it was.

00:21:24.670 --> 00:21:27.150
And then add e to the
minimum spanning tree.

00:21:31.700 --> 00:21:35.217
And what this lemma
tells us, is that this

00:21:35.217 --> 00:21:36.175
is a correct algorithm.

00:21:39.110 --> 00:21:41.990
If you're lucky-- and we're
going to force luckiness

00:21:41.990 --> 00:21:44.710
by trying all edges-- but if
we start with an edge that

00:21:44.710 --> 00:21:48.140
is guaranteed to be in some
minimum spanning tree, call it

00:21:48.140 --> 00:21:51.630
a safe edge, and
we contract, and we

00:21:51.630 --> 00:21:53.710
find a minimum spanning
tree on what remains,

00:21:53.710 --> 00:21:56.760
then we can put e
back in at the end,

00:21:56.760 --> 00:22:00.230
and we'll get a minimum spanning
tree of the original graph.

00:22:00.230 --> 00:22:03.780
So this gives us correctness
of this algorithm.

00:22:03.780 --> 00:22:06.380
Now, this algorithm's
bad, again,

00:22:06.380 --> 00:22:08.360
from a complexity standpoint.

00:22:08.360 --> 00:22:11.166
The running time is
going to be exponential.

00:22:11.166 --> 00:22:13.540
The number of sub problems we
might have to consider here

00:22:13.540 --> 00:22:14.960
is all subsets of edges.

00:22:14.960 --> 00:22:18.940
There's no particular way--
because at every step,

00:22:18.940 --> 00:22:22.240
we're guessing an arbitrary
edge in the graph,

00:22:22.240 --> 00:22:23.530
there's no structure.

00:22:23.530 --> 00:22:25.860
Like, we can't say well,
it's the first k edges,

00:22:25.860 --> 00:22:27.890
or some substring of edges.

00:22:27.890 --> 00:22:30.210
It's just going to be
some subset of edges.

00:22:30.210 --> 00:22:33.080
There's exponentially
many subsets, 2 to the e,

00:22:33.080 --> 00:22:34.090
so this is exponential.

00:22:39.370 --> 00:22:42.980
But we're going to
make a polynomial

00:22:42.980 --> 00:22:44.794
by removing the guessing.

00:22:44.794 --> 00:22:46.460
This is actually a
really good prototype

00:22:46.460 --> 00:22:47.910
for a greedy algorithm.

00:22:47.910 --> 00:22:50.400
If instead of guessing,
trying all edges,

00:22:50.400 --> 00:22:52.440
if we could find a
good edge to choose

00:22:52.440 --> 00:22:55.870
that's guaranteed to be in
a minimum spanning tree,

00:22:55.870 --> 00:22:58.290
then we could actually
follow this procedure,

00:22:58.290 --> 00:23:01.750
and this would be like
an iterative algorithm.

00:23:01.750 --> 00:23:04.610
If you-- you don't
guess-- you correctly

00:23:04.610 --> 00:23:08.090
choose a good-- you
take the biggest cookie,

00:23:08.090 --> 00:23:11.014
you contract it, and then
you repeat that process

00:23:11.014 --> 00:23:12.680
over and over, that
would be a prototype

00:23:12.680 --> 00:23:14.760
for a greedy algorithm and
that's what's going to work.

00:23:14.760 --> 00:23:16.440
There's different ways to
choose this greedy edge,

00:23:16.440 --> 00:23:18.398
and we're going to get
two different algorithms

00:23:18.398 --> 00:23:19.232
accordingly.

00:23:19.232 --> 00:23:20.440
But that's where we're going.

00:23:20.440 --> 00:23:22.736
First, I should prove
this claim, cause,

00:23:22.736 --> 00:23:25.010
you know, where did edge
contraction come from?

00:23:25.010 --> 00:23:25.820
Why does it work?

00:23:29.422 --> 00:23:31.970
It's not too hard to prove.

00:23:31.970 --> 00:23:32.550
Let's do it.

00:23:46.000 --> 00:23:47.070
Question?

00:23:47.070 --> 00:23:47.990
Oh.

00:23:47.990 --> 00:23:50.290
All right.

00:23:50.290 --> 00:23:53.670
I should be able to do
this without looking.

00:23:53.670 --> 00:23:55.550
So--

00:23:55.550 --> 00:23:57.500
Proof of optimal substructure.

00:23:57.500 --> 00:23:58.630
So we're given a lot.

00:23:58.630 --> 00:24:01.200
We're told that e belongs
to a minimize spanning tree.

00:24:01.200 --> 00:24:03.780
Let's give that
spanning tree a name.

00:24:03.780 --> 00:24:10.700
Say we have a minimum spanning
tree T star, which contains e.

00:24:10.700 --> 00:24:15.090
So we're assuming that
exists, then we contract e.

00:24:15.090 --> 00:24:16.600
And then we're
given T prime, which

00:24:16.600 --> 00:24:20.450
is a minimum spanning
tree of G slash e.

00:24:20.450 --> 00:24:22.250
And then we want to
analyze this thing.

00:24:22.250 --> 00:24:24.280
So I want to claim
that this thing is

00:24:24.280 --> 00:24:26.410
a minimum spanning
tree, in other words,

00:24:26.410 --> 00:24:29.360
that the weight of
that spanning tree

00:24:29.360 --> 00:24:32.310
is equal to the weight
of this spanning tree,

00:24:32.310 --> 00:24:34.600
because this one is minimum.

00:24:34.600 --> 00:24:38.710
This is a minimum spanning
of G. And this is also

00:24:38.710 --> 00:24:44.680
supposed to be a minimum
spanning tree of G.

00:24:44.680 --> 00:24:46.460
OK.

00:24:46.460 --> 00:24:49.920
Sounds easy, right?

00:24:49.920 --> 00:24:51.130
I'm going to cheat, sorry.

00:25:00.330 --> 00:25:00.900
I see.

00:25:00.900 --> 00:25:01.400
Right.

00:25:01.400 --> 00:25:03.050
Duh.

00:25:03.050 --> 00:25:04.640
Easy, once you know how.

00:25:04.640 --> 00:25:09.744
So what we're going to do is
think about contracting e.

00:25:09.744 --> 00:25:11.160
OK, we already
know we're supposed

00:25:11.160 --> 00:25:13.760
to be thinking about
contracting e in the graph.

00:25:13.760 --> 00:25:16.880
Let's look at how it changes
that given minimum spanning

00:25:16.880 --> 00:25:17.720
tree.

00:25:17.720 --> 00:25:20.240
So we have T star,
minimum spanning

00:25:20.240 --> 00:25:25.900
tree of the whole graph, and
then I'm going to contract e.

00:25:25.900 --> 00:25:28.060
What I mean is, if
that edge happens

00:25:28.060 --> 00:25:31.640
to be in the spanning
tree-- it is, actually.

00:25:31.640 --> 00:25:33.540
We assumed that e is in there.

00:25:33.540 --> 00:25:38.090
So I'm basically removing,
I'm just deleting that edge,

00:25:38.090 --> 00:25:40.220
maybe I should call it minus e.

00:25:43.160 --> 00:25:53.930
Then that should be a
spanning tree of G slash e.

00:25:53.930 --> 00:25:56.580
So when I contract
the edge in the graph,

00:25:56.580 --> 00:25:59.440
if I throw away the edge
from this spanning tree,

00:25:59.440 --> 00:26:00.950
I should still have
a spanning tree,

00:26:00.950 --> 00:26:02.750
and I don't know
whether it's minimum.

00:26:02.750 --> 00:26:06.080
Probably, it is, but we
won't prove that right now.

00:26:08.930 --> 00:26:11.105
I claim it's still
a spanning tree.

00:26:11.105 --> 00:26:11.980
What would that take?

00:26:11.980 --> 00:26:17.720
It still hits all the vertices,
because if I removed the edge,

00:26:17.720 --> 00:26:19.520
things would not be
connected together.

00:26:19.520 --> 00:26:23.780
But this edge was in
the spanning tree,

00:26:23.780 --> 00:26:26.600
and then I fused those
two vertices together,

00:26:26.600 --> 00:26:29.390
so whatever spanning-- I
mean, whatever was connected

00:26:29.390 --> 00:26:30.820
before is still connected.

00:26:30.820 --> 00:26:33.994
Contraction generally
preserves connectivity.

00:26:33.994 --> 00:26:36.410
If these things were already
connected directly by an edge

00:26:36.410 --> 00:26:39.270
when I contract, I still
have a connected structure,

00:26:39.270 --> 00:26:42.000
so I'm still hitting
all the vertices.

00:26:42.000 --> 00:26:45.260
And also, the number of
edges is still exactly right.

00:26:45.260 --> 00:26:47.517
Before, I had n minus 1 edges.

00:26:47.517 --> 00:26:49.350
Afterwards, I'll still
have n minus 1 edges,

00:26:49.350 --> 00:26:51.660
because I removed one edge
and I removed one vertex,

00:26:51.660 --> 00:26:52.990
in terms of the count.

00:26:52.990 --> 00:26:55.870
So that proves that it's
still a spanning tree,

00:26:55.870 --> 00:26:57.410
using properties of trees.

00:27:00.330 --> 00:27:02.370
Cool.

00:27:02.370 --> 00:27:07.390
So that means the minimum
spanning tree, this thing,

00:27:07.390 --> 00:27:10.690
T prime, the minimum
spanning tree of G slash e,

00:27:10.690 --> 00:27:13.077
has a smaller weight
than this one.

00:27:13.077 --> 00:27:14.910
Because this is a
spanning tree, the minimum

00:27:14.910 --> 00:27:16.990
is smaller than
all spanning trees.

00:27:16.990 --> 00:27:19.600
So we know the
weight of T prime is

00:27:19.600 --> 00:27:25.350
less than or equal to the
weight of T star minus e.

00:27:29.850 --> 00:27:31.340
Cool.

00:27:31.340 --> 00:27:37.310
And now we want to know about
this thing, the weight of T

00:27:37.310 --> 00:27:41.020
prime plus e.

00:27:41.020 --> 00:27:46.650
Well, that's just the weight of
T prime plus the weight of e,

00:27:46.650 --> 00:27:48.560
because the weight
of a tree is just

00:27:48.560 --> 00:27:50.670
the sum of the
weights of the edges.

00:27:50.670 --> 00:27:53.293
So this is less
than or equal to w

00:27:53.293 --> 00:28:02.130
of T star minus e plus e, which
is just the weight of T star.

00:28:05.390 --> 00:28:08.640
So we proved that the weight
of our proposed spanning tree

00:28:08.640 --> 00:28:10.820
is less than or equal to
the weight of the minimum

00:28:10.820 --> 00:28:15.180
spanning tree in G, and
therefore, T prime union

00:28:15.180 --> 00:28:17.170
e actually is a
minimum spanning tree.

00:28:17.170 --> 00:28:17.670
OK?

00:28:17.670 --> 00:28:18.720
This is really easy.

00:28:28.527 --> 00:28:30.610
It actually implies that
all of these inequalities

00:28:30.610 --> 00:28:32.030
have to be
equalities, because we

00:28:32.030 --> 00:28:33.321
started with something minimum.

00:28:35.810 --> 00:28:36.530
Clear?

00:28:36.530 --> 00:28:38.260
That's the easier half.

00:28:38.260 --> 00:28:38.760
The

00:28:38.760 --> 00:28:41.218
More interesting property is
going to be this greedy choice

00:28:41.218 --> 00:28:42.560
property.

00:28:42.560 --> 00:28:45.040
This is sort of where the
action is for greedy algorithms,

00:28:45.040 --> 00:28:47.020
and this is usually
the heart of proving

00:28:47.020 --> 00:28:48.649
greedy algorithms are correct.

00:28:48.649 --> 00:28:50.190
We don't yet have
a greedy algorithm,

00:28:50.190 --> 00:28:51.930
but we're thinking about it.

00:28:51.930 --> 00:28:56.540
We need some way to
intelligently choose an edge e,

00:28:56.540 --> 00:28:58.580
and I'm going to give
you a whole bunch of ways

00:28:58.580 --> 00:29:00.060
to intelligently
choose an edge e.

00:29:41.130 --> 00:29:42.720
So here's a really
powerful lemma,

00:29:42.720 --> 00:29:44.928
and we're going to make it
even stronger in a moment.

00:30:01.100 --> 00:30:04.210
So I'm going to introduce
the notion of a cut, that's

00:30:04.210 --> 00:30:07.900
going to be a similar
picture to what I had before.

00:30:07.900 --> 00:30:09.760
I'm going to look at
some set of vertices.

00:30:09.760 --> 00:30:14.080
S here is a subset
of the vertices,

00:30:14.080 --> 00:30:17.100
and that leaves in the
graph, everything else.

00:30:17.100 --> 00:30:21.640
This would be V minus
S. OK, so there's

00:30:21.640 --> 00:30:25.650
some vertices over here,
some vertices over here,

00:30:25.650 --> 00:30:27.390
there's some edges
that are purely

00:30:27.390 --> 00:30:30.610
inside one side of the cut.

00:30:30.610 --> 00:30:32.280
And then what I'm
interested in are

00:30:32.280 --> 00:30:33.960
the edges that cross the cut.

00:30:38.380 --> 00:30:40.430
OK, whatever they look
like, these edges.

00:30:40.430 --> 00:30:44.540
If an edge has one vertex in
V and one vertex not in V,

00:30:44.540 --> 00:30:46.500
I call that edge
a crossing edge.

00:30:51.680 --> 00:31:09.160
OK, so let's suppose that e is
a least-weight edge crossing

00:31:09.160 --> 00:31:09.660
the cut.

00:31:15.160 --> 00:31:24.120
So let's say, let me be
specific, if e is uv,

00:31:24.120 --> 00:31:28.046
then I want one of the
endpoints, let's u, to be in S,

00:31:28.046 --> 00:31:31.400
and I want the other
one to be not in S,

00:31:31.400 --> 00:31:35.140
so it's in capital
V minus S. And that

00:31:35.140 --> 00:31:37.810
would be a crossing edge, and
among all the crossing edges,

00:31:37.810 --> 00:31:41.360
I want to take one
of minimum weight.

00:31:41.360 --> 00:31:46.140
There might be many,
but pick any one.

00:31:46.140 --> 00:31:49.090
Then I claim that edge is
in a minimum spanning tree.

00:32:00.030 --> 00:32:02.320
This is our golden
ticket, right?

00:32:02.320 --> 00:32:05.590
If we can guarantee an edge is
in the minimum spanning tree,

00:32:05.590 --> 00:32:07.210
then we plug that in here.

00:32:07.210 --> 00:32:09.950
Instead of guessing, we'll
just take that edge--

00:32:09.950 --> 00:32:12.370
we know it's in a
minimum spanning tree--

00:32:12.370 --> 00:32:15.650
and then we'll contract it
and repeat this process.

00:32:15.650 --> 00:32:19.310
So the tricky part-- I mean, it
is true that the minimum weight

00:32:19.310 --> 00:32:22.950
edge is in a minimum spanning
tree, I'll give that away.

00:32:22.950 --> 00:32:25.335
But the question is,
what you do then?

00:32:28.220 --> 00:32:29.820
And I guess you
contract and repeat

00:32:29.820 --> 00:32:32.640
but, that will be
Kruskal's algorithm.

00:32:32.640 --> 00:32:36.720
But this is, in some
sense, a more general tool

00:32:36.720 --> 00:32:38.940
that will let us identify
edges that are guaranteed

00:32:38.940 --> 00:32:40.398
to be in the minimum
spanning tree,

00:32:40.398 --> 00:32:42.900
even after we've already
identified some edges as being

00:32:42.900 --> 00:32:46.820
in the minimum spanning tree,
so it's a little more powerful.

00:32:46.820 --> 00:32:51.260
Let's prove this claim.

00:32:51.260 --> 00:32:53.750
This is where things
get particularly cool.

00:33:09.714 --> 00:33:11.630
And this is where we're
going to use something

00:33:11.630 --> 00:33:13.020
called a c and paste argument.

00:33:19.200 --> 00:33:20.770
And if you are ever
trying to prove

00:33:20.770 --> 00:33:22.890
a greedy algorithm
correct, the first thing

00:33:22.890 --> 00:33:25.895
that should come to your
mind is cut and paste.

00:33:25.895 --> 00:33:29.080
This is almost universally how
you prove greedy algorithms

00:33:29.080 --> 00:33:34.530
to be correct, which is, suppose
you have some optimal solution

00:33:34.530 --> 00:33:36.590
which doesn't have
the property you want,

00:33:36.590 --> 00:33:38.810
like that it includes e here.

00:33:38.810 --> 00:33:41.330
And then you modify it,
usually by cutting out

00:33:41.330 --> 00:33:43.820
one part of the solution and
pasting in a different part,

00:33:43.820 --> 00:33:48.180
like e, and prove that you
still have an optimal solution,

00:33:48.180 --> 00:33:50.580
and therefore, there
is an optimal solution.

00:33:50.580 --> 00:33:56.150
There is an MST that has
the property you want.

00:33:56.150 --> 00:33:59.620
OK, so we're going to do that
by starting from an arbitrary

00:33:59.620 --> 00:34:02.130
minimum spanning tree.

00:34:02.130 --> 00:34:10.330
So let T star be a minimum
spanning tree of G,

00:34:10.330 --> 00:34:13.000
and if the edge e is
in there, we're done.

00:34:13.000 --> 00:34:17.770
So presumably, e is not in
that minimum spanning tree.

00:34:20.420 --> 00:34:24.389
We're going to modify
T star to include e.

00:34:24.389 --> 00:34:25.870
So again, let me draw the cut.

00:34:28.672 --> 00:34:32.770
There's S and V minus
S. We have some edge e

00:34:32.770 --> 00:34:37.530
which crosses the
cut, goes from u to v,

00:34:37.530 --> 00:34:39.300
that's not in the
minimum spanning tree.

00:34:39.300 --> 00:34:44.350
Let's say in blue, I draw
the minimum spanning tree.

00:34:44.350 --> 00:34:46.520
So you know, the
minimum spanning tree

00:34:46.520 --> 00:34:48.025
connects everything
together here.

00:34:51.750 --> 00:34:56.774
I claim it's got to have some
edges that cross the cut,

00:34:56.774 --> 00:34:58.690
because if it has no
edges that cross the cut,

00:34:58.690 --> 00:35:02.030
it doesn't connect vertices over
here with vertices over here.

00:35:02.030 --> 00:35:06.910
So it may not use e, but some
of the edges must cross the cut.

00:35:06.910 --> 00:35:13.290
So here's a possible
minimum spanning tree.

00:35:13.290 --> 00:35:15.900
It happens to have sort of
two components over here

00:35:15.900 --> 00:35:16.600
in S, maybe.

00:35:16.600 --> 00:35:19.420
Who knows?

00:35:19.420 --> 00:35:24.150
But there's got to be at least
one edge the crosses over.

00:35:24.150 --> 00:35:31.760
In fact, the minimum
spanning tree, T star,

00:35:31.760 --> 00:35:37.890
has to connect vertex
u to vertex v, somehow.

00:35:37.890 --> 00:35:40.710
It doesn't use e, but there's
got to be-- it's a tree,

00:35:40.710 --> 00:35:43.610
so in fact, there has to
be a unique path from u

00:35:43.610 --> 00:35:50.710
to v in the minimum
spanning tree.

00:35:50.710 --> 00:35:55.130
And now u is in S, v is not in
S. So if you look at that path,

00:35:55.130 --> 00:35:56.630
for a while, you
might stay in S,

00:35:56.630 --> 00:35:59.410
but eventually you
have to leave S, which

00:35:59.410 --> 00:36:03.650
means there has to be an
edge like this one, which

00:36:03.650 --> 00:36:08.060
I'll call it e prime,
which transitions

00:36:08.060 --> 00:36:11.000
from S to V minus S.

00:36:11.000 --> 00:36:20.950
So there must be an edge e prime
in the minimum spanning tree

00:36:20.950 --> 00:36:30.000
that crosses the cut, because
u and v are connected by a path

00:36:30.000 --> 00:36:32.650
and that path starts in S,
ends not in S, so it's got

00:36:32.650 --> 00:36:34.190
to transition at least once.

00:36:34.190 --> 00:36:36.570
It might transition many
times, but there has

00:36:36.570 --> 00:36:38.600
to be at least one such edge.

00:36:38.600 --> 00:36:42.420
And now what I'm going
to do is cut and paste.

00:36:42.420 --> 00:36:47.230
I'm going to remove e
prime and add an e instead.

00:36:47.230 --> 00:36:55.985
So I'm going to look at T
star minus e prime plus e.

00:36:59.510 --> 00:37:02.440
I claim that is a
minimum spanning tree.

00:37:02.440 --> 00:37:05.940
First I want to claim, this is
maybe the more annoying part,

00:37:05.940 --> 00:37:07.420
that it is a spanning tree.

00:37:16.590 --> 00:37:20.130
This is more of a
graph theory thing.

00:37:20.130 --> 00:37:22.930
I guess one comforting
thing is that you've

00:37:22.930 --> 00:37:26.080
preserved the number of
edges, so it should still

00:37:26.080 --> 00:37:29.090
be if you get one
property, you get

00:37:29.090 --> 00:37:32.180
the other, because I remove
one edge, add in one edge,

00:37:32.180 --> 00:37:34.960
I'm still going to
have n minus 1 edges.

00:37:34.960 --> 00:37:37.520
The worry, I guess, is that
things become disconnected

00:37:37.520 --> 00:37:41.490
when you do that, but
that's essentially not

00:37:41.490 --> 00:37:43.240
going to happen
because if I think

00:37:43.240 --> 00:37:46.680
of removing e prime, again, that
disconnects the tree into two

00:37:46.680 --> 00:37:48.290
parts.

00:37:48.290 --> 00:37:53.860
And I know, by this path, that
one part contains this vertex,

00:37:53.860 --> 00:37:55.530
another part
contains this vertex,

00:37:55.530 --> 00:37:58.300
and I know that this
vertex is connected to u

00:37:58.300 --> 00:38:00.380
and this vertex is connected
to v. Maybe I should

00:38:00.380 --> 00:38:03.220
call this u prime and v prime.

00:38:03.220 --> 00:38:06.030
I know u and u prime
are connected by a path.

00:38:06.030 --> 00:38:08.380
I know v and v prime
are connected by a path.

00:38:08.380 --> 00:38:10.160
But I know that by
deleting e prime,

00:38:10.160 --> 00:38:12.900
u prime and v prime are not
connected to each other.

00:38:12.900 --> 00:38:15.300
Therefore, u and v are not
connected to each other,

00:38:15.300 --> 00:38:16.970
after removing e prime.

00:38:16.970 --> 00:38:20.750
So when I add in e, I newly
connect u and v again,

00:38:20.750 --> 00:38:24.382
and so everything's
connected back together.

00:38:24.382 --> 00:38:26.090
I have exactly the
right number of edges.

00:38:26.090 --> 00:38:27.790
Therefore, I'm a spanning tree.

00:38:30.300 --> 00:38:31.910
So that's the graph
three theory part.

00:38:31.910 --> 00:38:33.910
Now the interesting part
from a greedy algorithm

00:38:33.910 --> 00:38:39.840
is to prove to this is minimum,
that the weight is not too big.

00:38:39.840 --> 00:38:41.290
So let's do that over here.

00:38:50.500 --> 00:39:02.430
So I have the weight of T
star minus e plus-- minus e

00:39:02.430 --> 00:39:04.500
prime plus e.

00:39:04.500 --> 00:39:07.210
By linearity, this
is just the weight

00:39:07.210 --> 00:39:13.170
of T star minus the weight e
prime plus the weight of e.

00:39:16.492 --> 00:39:18.200
And now we're going
to use this property,

00:39:18.200 --> 00:39:21.850
we haven't that yet, e is a
least-weight edge crossing

00:39:21.850 --> 00:39:23.190
the cut.

00:39:23.190 --> 00:39:26.295
So e prime crosses
the cut, so does e,

00:39:26.295 --> 00:39:28.100
but e is the smallest
possible weight you

00:39:28.100 --> 00:39:29.590
could have crossing the cut.

00:39:29.590 --> 00:39:34.880
That means that-- I'll put that
over here-- the weight of e

00:39:34.880 --> 00:39:37.350
is less than or equal
to the weight of e

00:39:37.350 --> 00:39:40.960
prime, because e prime is
a particular edge crossing

00:39:40.960 --> 00:39:43.620
the cut, e was the
smallest weight of them.

00:39:43.620 --> 00:39:47.610
So that tells us
something about this.

00:39:47.610 --> 00:39:51.850
Signs are so difficult.
I think that means

00:39:51.850 --> 00:39:53.720
that this is negative or zero.

00:39:56.820 --> 00:40:02.630
So this should be less than
or equal to w of T star,

00:40:02.630 --> 00:40:04.240
and that's what I
want, because that

00:40:04.240 --> 00:40:06.530
says the weight of this
spanning tree is less than

00:40:06.530 --> 00:40:09.424
or equal to the optimum
weight, the minimum weight.

00:40:09.424 --> 00:40:11.340
So that means, actually,
this must be minimum.

00:40:14.960 --> 00:40:17.310
So what I've done is I've
constructed a new minimum

00:40:17.310 --> 00:40:17.910
spanning tree.

00:40:17.910 --> 00:40:22.554
It's just as good as T star,
but now it includes my edge e,

00:40:22.554 --> 00:40:23.970
and that's what I
wanted to prove.

00:40:23.970 --> 00:40:25.820
There is a minimum
spanning tree that

00:40:25.820 --> 00:40:28.987
contains e, provided e
is the minimum weight

00:40:28.987 --> 00:40:29.820
edge crossing a cut.

00:40:33.110 --> 00:40:37.900
So that proves this
greedy choice property.

00:40:37.900 --> 00:40:43.680
And I'm going to observe one
extra feature of this proof,

00:40:43.680 --> 00:40:46.610
which is that-- so
we cut and paste,

00:40:46.610 --> 00:40:50.060
in the sense that we removed
one thing, which was e prime,

00:40:50.060 --> 00:40:53.760
and we added a
different thing, e.

00:40:53.760 --> 00:41:00.420
And a useful feature is that
the things that we change only

00:41:00.420 --> 00:41:03.010
are edges that cross the cut.

00:41:03.010 --> 00:41:11.870
So we only, let's say, modified
edges that cross the cut.

00:41:22.860 --> 00:41:24.576
I'm going to use that later.

00:41:24.576 --> 00:41:27.200
We removed one edge that crossed
the cut, and we put in the one

00:41:27.200 --> 00:41:29.548
that we wanted.

00:41:29.548 --> 00:41:31.330
OK so far?

00:41:31.330 --> 00:41:34.692
There's a bunch of lemmas.

00:41:34.692 --> 00:41:37.025
Now we actually get to do
algorithms using these lemmas.

00:41:39.930 --> 00:41:44.790
We'll start with maybe the
less obvious algorithm,

00:41:44.790 --> 00:41:47.480
but it's nice because it's
very much like Dijkstra.

00:41:47.480 --> 00:41:50.810
It follows very closely
to the Dijkstra model.

00:41:50.810 --> 00:41:53.021
And then we'll get to
the one that we've all

00:41:53.021 --> 00:41:55.270
been thinking about, which
was choose a minimum weight

00:41:55.270 --> 00:41:57.460
edge, contract, and repeat.

00:41:57.460 --> 00:42:03.790
That doesn't-- well, that does
work, but the obvious way is,

00:42:03.790 --> 00:42:05.400
maybe, slow.

00:42:05.400 --> 00:42:07.870
We want to do it in
near linear time.

00:42:20.075 --> 00:42:21.950
Let's start with the
Dijkstra-like algorithm.

00:42:26.130 --> 00:42:27.340
This is Prim's algorithm.

00:42:36.410 --> 00:42:38.485
Maybe I'll start by
writing down the algorithm.

00:42:38.485 --> 00:42:39.760
It's a little long.

00:42:43.080 --> 00:42:46.710
In general, the idea-- we want
to apply this greedy choice

00:42:46.710 --> 00:42:47.210
property.

00:42:47.210 --> 00:42:48.710
To apply the greedy
choice property,

00:42:48.710 --> 00:42:51.570
you need to choose a cut.

00:42:51.570 --> 00:42:54.800
With Prim, we're going to start
out with an obvious cut, which

00:42:54.800 --> 00:42:56.490
is a single vertex.

00:42:56.490 --> 00:42:59.310
If we have a single
vertex S, and we

00:42:59.310 --> 00:43:02.976
say that is our set
capital S, then you know,

00:43:02.976 --> 00:43:05.100
there's some images
coming out of it.

00:43:05.100 --> 00:43:08.900
There's basically S
versus everyone else.

00:43:08.900 --> 00:43:10.040
That's a cut.

00:43:10.040 --> 00:43:11.910
And so I could take
the minimum weight edge

00:43:11.910 --> 00:43:15.280
coming out of that
cut and put that

00:43:15.280 --> 00:43:17.160
in my minimum spanning tree.

00:43:17.160 --> 00:43:22.420
So when I do that, I put it
in my minimum spanning tree

00:43:22.420 --> 00:43:24.810
because I know it's in
some minimum spanning tree.

00:43:24.810 --> 00:43:28.890
Now, I'm going to make capital
S grow a little bit to include

00:43:28.890 --> 00:43:32.100
that vertex, and repeat.

00:43:32.100 --> 00:43:34.310
That's actually also a
very natural algorithm.

00:43:34.310 --> 00:43:37.780
Start with a tiny s and just
keep growing it one by one.

00:43:37.780 --> 00:43:41.660
At each stage use this lemma to
guarantee the edge I'm adding

00:43:41.660 --> 00:43:45.040
is still in the
minimum spanning tree.

00:43:45.040 --> 00:43:48.640
So to make that work
out, we're always

00:43:48.640 --> 00:43:52.630
going to need to choose the
minimum weight edge that's

00:43:52.630 --> 00:43:56.550
coming out of the cut.

00:43:56.550 --> 00:44:01.690
And we'll do that
using a priority queue,

00:44:01.690 --> 00:44:02.920
just like we do in Dijkstra.

00:44:07.820 --> 00:44:11.460
So for every vertex
that's in V minus S,

00:44:11.460 --> 00:44:15.380
we're going to have that
vertex in the priority queue.

00:44:15.380 --> 00:44:21.870
And the question is, what is
the key value of that node

00:44:21.870 --> 00:44:24.360
stored in the priority queue?

00:44:24.360 --> 00:44:29.760
So the invariant I'm going
to have is that the key of v

00:44:29.760 --> 00:44:36.070
is the minimum of the
weights of the edges

00:44:36.070 --> 00:44:41.600
that cross the cut into
v. So for vertex v,

00:44:41.600 --> 00:44:43.360
I want to look at
the-- I'm not going

00:44:43.360 --> 00:44:46.270
to compute this every time,
I'm only going to maintain it.

00:44:46.270 --> 00:44:49.885
I want the minimum weight
of an edge that starts in S

00:44:49.885 --> 00:44:54.870
and goes to v, which is not in
S because v in Q-- Q only stores

00:44:54.870 --> 00:44:58.740
vertices that are not in
S-- I want the key value

00:44:58.740 --> 00:45:00.760
to be that minimum
weight so if I choose

00:45:00.760 --> 00:45:03.790
the overall minimum
vertex, that gives me

00:45:03.790 --> 00:45:06.610
the edge of minimum weight
that crosses the cut.

00:45:06.610 --> 00:45:07.110
OK?

00:45:07.110 --> 00:45:12.610
I've sort of divided this
minimum vertex by vertex.

00:45:12.610 --> 00:45:15.790
For every vertex
over here, I'm going

00:45:15.790 --> 00:45:18.740
to say, what's the minimum
incoming weight from somebody

00:45:18.740 --> 00:45:19.750
over here?

00:45:19.750 --> 00:45:21.230
What's the minimum
incoming weight

00:45:21.230 --> 00:45:23.040
from someone over here to there?

00:45:23.040 --> 00:45:24.716
To here?

00:45:24.716 --> 00:45:26.112
Take the minimum
of those things.

00:45:26.112 --> 00:45:27.570
And of course, the
min of all those

00:45:27.570 --> 00:45:29.595
will be the min of
all those edges.

00:45:29.595 --> 00:45:32.450
OK, that's how I'm
dividing things up.

00:45:32.450 --> 00:45:35.090
And this will be easier
to maintain, but let me

00:45:35.090 --> 00:45:37.055
first initialize everything.

00:45:46.484 --> 00:45:48.400
OK, I guess we're going
to actually initialize

00:45:48.400 --> 00:45:54.580
with S being the empty set,
so Q will store everybody,

00:45:54.580 --> 00:45:59.790
except I'm going to get
things started by setting

00:45:59.790 --> 00:46:02.430
for particular vertex little s.

00:46:02.430 --> 00:46:03.830
I'm going to set
its key to zero.

00:46:07.310 --> 00:46:11.210
It doesn't matter
who little s is.

00:46:11.210 --> 00:46:12.490
That's just your start vertex.

00:46:15.960 --> 00:46:19.750
Just pick one vertex
and set its key to zero.

00:46:19.750 --> 00:46:22.350
That will force it
to be chosen first

00:46:22.350 --> 00:46:32.180
because for everyone else,
for v not equal to S,

00:46:32.180 --> 00:46:36.380
I'm going to set
the key to infinity,

00:46:36.380 --> 00:46:40.304
because we haven't yet seen
any edges that go in there,

00:46:40.304 --> 00:46:41.720
but we'll change
that in a moment.

00:46:56.930 --> 00:47:01.050
OK, so that was the
initialization, now

00:47:01.050 --> 00:47:03.020
we're going to do a loop.

00:47:03.020 --> 00:47:06.010
We're going to keep going
until the Q is empty,

00:47:06.010 --> 00:47:10.550
because when the Q is empty,
that means S is everybody,

00:47:10.550 --> 00:47:12.660
and at that point, we'll
have a spanning tree

00:47:12.660 --> 00:47:16.005
on the whole graph, and
it better be minimum.

00:47:16.005 --> 00:47:21.210
OK, and we're going to
do that by extracting

00:47:21.210 --> 00:47:29.520
the minimum from
our priority Q. When

00:47:29.520 --> 00:47:41.390
we remove Q-- we remove
vertex u from the queue Q,

00:47:41.390 --> 00:47:44.920
this means that we're
adding u to S. OK,

00:47:44.920 --> 00:47:48.030
by taking it out of Q,
that means it enters S,

00:47:48.030 --> 00:47:51.070
by the invariant at the top.

00:47:51.070 --> 00:47:55.585
So now we need to
update this invariant,

00:47:55.585 --> 00:47:57.520
that all the key
values are correct.

00:47:57.520 --> 00:47:59.940
As soon as we move
a vertex into S,

00:47:59.940 --> 00:48:05.490
now there are new edges we have
to consider from S to not S,

00:48:05.490 --> 00:48:12.840
and we do that just by looking
at all of the neighbors of u.

00:48:12.840 --> 00:48:14.490
I haven't written
this in a long time,

00:48:14.490 --> 00:48:17.200
but this is how it's
usually written in Dijkstra,

00:48:17.200 --> 00:48:20.560
except in Dijkstra, these
are the outgoing edges from u

00:48:20.560 --> 00:48:21.730
and v are the neighbors.

00:48:21.730 --> 00:48:23.700
Here, it's an undirected
graph, so these are

00:48:23.700 --> 00:48:25.580
all of the neighbors v of u.

00:48:25.580 --> 00:48:28.630
This as an adjacency list.

00:48:28.630 --> 00:48:38.039
OK, so we're looking at u,
which has just been added to S,

00:48:38.039 --> 00:48:39.330
and we're looking at the edges.

00:48:39.330 --> 00:48:42.830
We want to look at the edge
as they go to V minus S, only

00:48:42.830 --> 00:48:44.040
those ones.

00:48:44.040 --> 00:48:48.390
And then for those vertices v,
we need to update their keys,

00:48:48.390 --> 00:48:52.050
because it used to just
count all of these edges that

00:48:52.050 --> 00:48:54.860
went from the rest of S to
v. And now we have a new edge

00:48:54.860 --> 00:49:01.240
uv that v needs to consider,
because u just got added to S.

00:49:01.240 --> 00:49:05.020
So the first thing I'm
going say is if v in in Q.

00:49:05.020 --> 00:49:09.020
So we're just going to store
a Boolean for every vertex

00:49:09.020 --> 00:49:11.196
about whether it's
in the queue, and so

00:49:11.196 --> 00:49:12.570
when I extract it
from the queue,

00:49:12.570 --> 00:49:14.850
I just set that
Boolean to false.

00:49:14.850 --> 00:49:17.530
Being in the queue is the
same as being not in S,

00:49:17.530 --> 00:49:20.286
this is what Q represents.

00:49:20.286 --> 00:49:24.000
So Q is over here, kind of.

00:49:24.000 --> 00:49:31.560
So if we're in the queue,
same as saying v is not in S,

00:49:31.560 --> 00:49:33.970
then we're going
to do a check which

00:49:33.970 --> 00:49:35.440
lets us compute the minimum.

00:49:35.440 --> 00:49:37.370
This is going to look a
lot like a relaxation.

00:49:44.117 --> 00:49:44.617
Sorry.

00:50:02.120 --> 00:50:03.800
A couple things
going on because I

00:50:03.800 --> 00:50:05.244
want to compute
not just the value

00:50:05.244 --> 00:50:06.910
of the minimum spanning
tree, I actually

00:50:06.910 --> 00:50:08.535
want to find the
minimum spanning tree,

00:50:08.535 --> 00:50:11.350
so I'm going to store
parent pointers.

00:50:11.350 --> 00:50:13.180
But this is just
basically taking a min.

00:50:13.180 --> 00:50:14.967
I say, if the
weight of this edge

00:50:14.967 --> 00:50:16.800
is smaller than what's
currently in the key,

00:50:16.800 --> 00:50:20.410
then update the key, because the
key is supposed to be the min.

00:50:20.410 --> 00:50:23.561
OK, that's all we need to do to
maintain this invariant, this

00:50:23.561 --> 00:50:24.060
for loop.

00:50:24.060 --> 00:50:27.830
After the for loop, this
property will be restored,

00:50:27.830 --> 00:50:30.750
v dot key will be that minimum.

00:50:30.750 --> 00:50:33.370
And furthermore, we kept track
of where the minimums came

00:50:33.370 --> 00:50:38.260
from, so when you end
up extracting a vertex,

00:50:38.260 --> 00:50:42.810
you've already figured
out which edge you

00:50:42.810 --> 00:50:45.530
added to put that into the set.

00:50:45.530 --> 00:50:50.140
So in fact, u
already had a parent,

00:50:50.140 --> 00:50:56.810
this would be u
dot parent, and we

00:50:56.810 --> 00:51:00.770
want to add that edge into
the minimum spanning tree

00:51:00.770 --> 00:51:07.950
when we add u to S. Overall, let
me write why this is happening.

00:51:10.810 --> 00:51:15.030
At the end of the algorithm,
for every vertex v,

00:51:15.030 --> 00:51:16.450
we want the v dot parent.

00:51:22.710 --> 00:51:25.317
And that will be our
minimum spanning tree.

00:51:25.317 --> 00:51:27.650
Those are the edges that form
the minimum spanning tree.

00:51:33.460 --> 00:51:37.745
Let's prove that this works.

00:51:52.995 --> 00:51:54.245
Actually, let's do an example.

00:51:57.472 --> 00:51:59.995
We've done enough
proofs for a while.

00:51:59.995 --> 00:52:01.190
Let's do it over here.

00:52:10.350 --> 00:52:12.280
I need a little break.

00:52:12.280 --> 00:52:16.420
Examples are fun, though easy
to make mistakes, so correct me

00:52:16.420 --> 00:52:18.780
if you see me making a mistake.

00:52:18.780 --> 00:52:22.035
And let me draw a graph.

00:52:41.174 --> 00:52:42.920
OK, weights.

00:52:42.920 --> 00:52:53.890
14, 3, 8, 5, 6, 12, 7, 9, 15.

00:52:57.706 --> 00:52:58.206
10.

00:53:01.550 --> 00:53:03.580
OK.

00:53:03.580 --> 00:53:06.180
Colors.

00:53:06.180 --> 00:53:09.580
So I want to start
at this vertex

00:53:09.580 --> 00:53:12.470
just because I know it
does an interesting thing,

00:53:12.470 --> 00:53:14.490
or it's a nice example.

00:53:14.490 --> 00:53:16.360
Here's my weighted
undirected graph.

00:53:16.360 --> 00:53:18.340
I want to compute
minimum spanning tree.

00:53:18.340 --> 00:53:21.950
I'm going to start
with a capital

00:53:21.950 --> 00:53:27.030
S being-- well actually, I start
with capital S being nothing,

00:53:27.030 --> 00:53:30.040
and all of the weights--
all of the key values

00:53:30.040 --> 00:53:31.260
are initially infinity.

00:53:31.260 --> 00:53:34.520
So I'm going to write
the key values in blue.

00:53:34.520 --> 00:53:45.230
So initially everything is
infinity for every vertex,

00:53:45.230 --> 00:53:48.000
except for S the value is zero.

00:53:50.720 --> 00:53:53.530
So all of these things
are in my priority queue,

00:53:53.530 --> 00:53:58.490
and so when I extract from the
queue, I of course get S. OK,

00:53:58.490 --> 00:54:00.990
that's the point of that set up.

00:54:00.990 --> 00:54:04.640
So that's when I draw the red
circle containing little s.

00:54:04.640 --> 00:54:08.480
The red circle here is
supposed to be capital S.

00:54:08.480 --> 00:54:12.160
So at this point, I've
added capital S-- little s

00:54:12.160 --> 00:54:19.560
to capital S, and then I look
at all of the neighbors v of S.

00:54:19.560 --> 00:54:22.870
And I make sure that they are
outside of S. In this case,

00:54:22.870 --> 00:54:23.500
they all are.

00:54:23.500 --> 00:54:27.885
All three neighbors, these
three guys, are not in S.

00:54:27.885 --> 00:54:30.130
And then I look at the
weights of the edges.

00:54:30.130 --> 00:54:31.920
Here I have a weight 7 edge.

00:54:31.920 --> 00:54:33.990
That's smaller than
infinity, so I'm

00:54:33.990 --> 00:54:36.970
going to cross out
infinity and write 7.

00:54:36.970 --> 00:54:39.430
And 15 is smaller
than infinity, so I'm

00:54:39.430 --> 00:54:41.674
going to cross out
infinity and write 15.

00:54:41.674 --> 00:54:45.139
And 10, surprise, is
smaller than infinity.

00:54:45.139 --> 00:54:46.930
So I'm going to cross
out infinity rate 10.

00:54:46.930 --> 00:54:51.070
So now I've updated the key
values for those three nodes.

00:54:51.070 --> 00:54:53.500
I should mention in
the priority queue,

00:54:53.500 --> 00:54:58.210
to do that, that is a
decrease-key operation.

00:54:58.210 --> 00:55:01.445
This thing here
is a decrease-key.

00:55:01.445 --> 00:55:03.320
You need to update the
priority queue to say,

00:55:03.320 --> 00:55:07.090
hey look, the key of
this node changed.

00:55:07.090 --> 00:55:09.920
And so you're going to have
to move it around in the heap,

00:55:09.920 --> 00:55:12.400
or whatever.

00:55:12.400 --> 00:55:14.610
Just like Dijkstra,
same thing happens.

00:55:14.610 --> 00:55:16.860
OK, so I've decreased the
key of those three nodes.

00:55:16.860 --> 00:55:18.230
Now I do another iteration.

00:55:18.230 --> 00:55:20.450
I look at all of the
key values stored.

00:55:20.450 --> 00:55:27.200
The smallest one is 7, because
this node's no longer in there.

00:55:27.200 --> 00:55:30.840
So I'm going to add
this node to capital S.

00:55:30.840 --> 00:55:34.920
So capital S is going to
grow to include that node.

00:55:34.920 --> 00:55:36.800
I've extracted it
from the queue.

00:55:36.800 --> 00:55:39.570
And now I look at all the
neighbors of that node.

00:55:39.570 --> 00:55:42.520
So, for example,
here's a neighbor.

00:55:42.520 --> 00:55:46.670
9 is less than
infinity, so I write 9.

00:55:46.670 --> 00:55:47.630
Here's a neighbor.

00:55:47.630 --> 00:55:51.160
12 is less than
infinity, so I write 12.

00:55:51.160 --> 00:55:53.810
5 is less than
infinity, so I write 5.

00:55:53.810 --> 00:55:57.030
Here's a neighbor,
but s is in big S,

00:55:57.030 --> 00:55:59.210
so we're not going
to touch that edge.

00:55:59.210 --> 00:56:01.790
I'm not going to touch s.

00:56:01.790 --> 00:56:02.460
OK?

00:56:02.460 --> 00:56:06.070
I will end up looking at every
edge twice, so no big deal.

00:56:06.070 --> 00:56:07.770
Right now, who's smallest?

00:56:07.770 --> 00:56:09.390
5, I think.

00:56:09.390 --> 00:56:12.440
It's the smallest blue key.

00:56:12.440 --> 00:56:14.530
So we're going to
add 5 to the set.

00:56:17.730 --> 00:56:20.430
Sorry, add this
vertex to the set S,

00:56:20.430 --> 00:56:24.370
and then look at all of the
outgoing edges from here.

00:56:24.370 --> 00:56:28.720
So 6 is actually less
than 12, so this edge

00:56:28.720 --> 00:56:31.200
is better than that one was.

00:56:31.200 --> 00:56:33.391
Then, what's that, an 8?

00:56:33.391 --> 00:56:34.990
8 Is less than 10.

00:56:37.820 --> 00:56:40.670
14 is definitely
less than infinity.

00:56:40.670 --> 00:56:43.020
And we look at this
edge, but that edge

00:56:43.020 --> 00:56:46.840
stays inside the red set,
so we forget about it.

00:56:46.840 --> 00:56:50.280
Next smallest value is 6.

00:56:50.280 --> 00:56:59.240
So 6, we add this guy in.

00:56:59.240 --> 00:57:01.390
We look at the edges
from that vertex,

00:57:01.390 --> 00:57:03.940
but actually nothing happens
because all those vertices

00:57:03.940 --> 00:57:08.700
are inside capital S, so we
don't care about those edges.

00:57:08.700 --> 00:57:20.350
Next one is 8, so we'll
add in this vertex.

00:57:20.350 --> 00:57:23.830
And there's only one edge that
leaves the cut, so that's 3,

00:57:23.830 --> 00:57:27.074
and 3 is indeed better than 14.

00:57:27.074 --> 00:57:31.700
So never mind.

00:57:31.700 --> 00:57:34.470
Stop.

00:57:34.470 --> 00:57:38.757
So good, now I think
the smallest key is 3.

00:57:38.757 --> 00:57:40.590
Notice smallest key is
smaller than anything

00:57:40.590 --> 00:57:43.390
we've seen before, other
than 0, but that's OK.

00:57:43.390 --> 00:57:47.260
I'll just add it in,
and there's no edges

00:57:47.260 --> 00:57:48.920
leaving the cut from there.

00:57:48.920 --> 00:57:51.140
And then over here,
we have 9 and 15.

00:57:51.140 --> 00:57:53.320
So first we'll add 9.

00:57:53.320 --> 00:57:54.570
There's no edges there.

00:57:54.570 --> 00:57:55.670
Then we add 15.

00:57:55.670 --> 00:57:56.701
OK, now s is everything.

00:57:56.701 --> 00:57:57.200
We're done.

00:57:57.200 --> 00:57:58.544
Q is empty.

00:57:58.544 --> 00:57:59.960
Where's the minimal
spanning tree?

00:57:59.960 --> 00:58:02.980
I forgot to draw it.

00:58:02.980 --> 00:58:06.200
Luckily, all of the edges
here have different numbers

00:58:06.200 --> 00:58:07.010
as labels.

00:58:07.010 --> 00:58:09.780
So when I have a 3
here, what I mean is,

00:58:09.780 --> 00:58:11.970
include 3 in the
minimum spanning tree,

00:58:11.970 --> 00:58:13.650
the edge that was labeled 3.

00:58:13.650 --> 00:58:16.670
OK, so this will be a
minimum spanning tree edge.

00:58:16.670 --> 00:58:19.560
5 will be a minimum
spanning tree edge.

00:58:19.560 --> 00:58:21.230
These are actually
the parent pointers.

00:58:21.230 --> 00:58:24.020
6 will be a minimum
spanning tree edge.

00:58:24.020 --> 00:58:31.645
7, 9, 15, and 8.

00:58:34.720 --> 00:58:37.460
Every vertex except
the starting one

00:58:37.460 --> 00:58:40.030
will have a parent, which means
we'll have exactly n minus 1

00:58:40.030 --> 00:58:42.880
edges, that's a good sign.

00:58:42.880 --> 00:58:45.320
And in fact, this will be
a minimum spanning tree.

00:58:45.320 --> 00:58:49.460
That's the claim, because
every time we grew the circle

00:58:49.460 --> 00:58:51.350
to include a bigger
thing, we were

00:58:51.350 --> 00:58:55.970
guaranteed that this edge was
in the minimum spanning tree

00:58:55.970 --> 00:59:00.100
by applying this
property with that cut.

00:59:02.710 --> 00:59:04.250
Let me just write that down.

00:59:13.430 --> 00:59:15.030
OK, to prove
correctness, you need

00:59:15.030 --> 00:59:19.750
to prove an invariant that this
key, the key of every vertex,

00:59:19.750 --> 00:59:21.840
always remains this minimum.

00:59:21.840 --> 00:59:22.847
So this is an invariant.

00:59:22.847 --> 00:59:24.305
You should prove
that by induction.

00:59:33.770 --> 00:59:34.810
I won't prove it here.

00:59:37.820 --> 00:59:44.280
But we have another invariant,
a more interesting one

00:59:44.280 --> 00:59:46.146
from an MST
perspective, you know,

00:59:46.146 --> 00:59:49.680
it's just a sort of algorithm
implementation detail,

00:59:49.680 --> 00:59:59.640
that the tree T sub S,
within S is always contained

00:59:59.640 --> 01:00:05.615
in a minimum spanning
tree of G. So over here,

01:00:05.615 --> 01:00:07.740
we have this way of computing
minimum spanning tree

01:00:07.740 --> 01:00:10.360
for all vertices v,
but what I'd like

01:00:10.360 --> 01:00:12.470
to do is just look
at v that's currently

01:00:12.470 --> 01:00:15.680
in S. By the end, that
will be the whole thing,

01:00:15.680 --> 01:00:19.460
but if I look at v in S, and I
always look at the edge from v

01:00:19.460 --> 01:00:24.580
to v dot parent, that
gives me this tree TS.

01:00:24.580 --> 01:00:27.590
I claim it will be contained
in a minimum spanning tree

01:00:27.590 --> 01:00:32.850
of the entire graph,
proof by induction.

01:00:32.850 --> 01:00:39.840
So by induction, let's assume--
induction hypothesis will

01:00:39.840 --> 01:00:45.430
be that, let's say there is
a minimum spanning tree T

01:00:45.430 --> 01:00:50.010
star, which contains
T sub S, and then what

01:00:50.010 --> 01:00:54.020
the algorithm does, is it
repeatedly grows S by adding

01:00:54.020 --> 01:01:05.240
this vertex u to S. So let's
suppose that it adds u to S.

01:01:05.240 --> 01:01:08.230
So I'm actually going to look
at the edge that it adds.

01:01:18.990 --> 01:01:27.630
So we have S and V minus S, and
we do this thing, like we just

01:01:27.630 --> 01:01:30.060
saw, of growing by one.

01:01:30.060 --> 01:01:34.370
We add one new vertex
over here to S,

01:01:34.370 --> 01:01:39.240
and that vertex has a parent
edge, has a parent pointer.

01:01:39.240 --> 01:01:41.320
So this edge, I'm
going to call e.

01:01:41.320 --> 01:01:44.620
So we're adding some vertex u
that we extract at the minimum,

01:01:44.620 --> 01:01:49.230
and we also added an
edge e to this TS,

01:01:49.230 --> 01:01:52.780
because we grew S by 1.

01:01:52.780 --> 01:01:56.680
OK, when I do that,
all I do is say, look,

01:01:56.680 --> 01:01:58.980
greedy choice
property guarantees

01:01:58.980 --> 01:02:03.160
there's a minimum spanning
tree that contains e.

01:02:03.160 --> 01:02:05.480
Because we extracted
the min from the queue,

01:02:05.480 --> 01:02:08.320
and the key values are this,
as I was arguing before,

01:02:08.320 --> 01:02:13.180
that is the minimum overall
edge that crosses the cut.

01:02:13.180 --> 01:02:15.600
e is a minimum weight
edge that crosses the cut,

01:02:15.600 --> 01:02:29.370
and so by greedy
choice property,

01:02:29.370 --> 01:02:35.010
there is some minimum
spanning tree that contains e.

01:02:35.010 --> 01:02:37.250
But actually, I need that
the minimum spanning tree

01:02:37.250 --> 01:02:41.400
not only contains e, but also
contains all the other spanning

01:02:41.400 --> 01:02:46.050
tree edges that we had
already said were in T star.

01:02:46.050 --> 01:02:50.460
OK, so here's where I'm going
to use the stronger property.

01:02:50.460 --> 01:03:05.960
I can modify T star to
include e and T sub S.

01:03:05.960 --> 01:03:09.400
So we already assumed that T
star includes T sub S. I just

01:03:09.400 --> 01:03:11.860
don't want to break that.

01:03:11.860 --> 01:03:14.760
And if you remember the proof
of this greedy choice property,

01:03:14.760 --> 01:03:19.360
we said, well all we need to do
is remove one edge that crosses

01:03:19.360 --> 01:03:22.045
the cut and replace it with e.

01:03:22.045 --> 01:03:23.920
So here what I'm saying
is there's some edge,

01:03:23.920 --> 01:03:27.480
yeah, maybe there's some
edge over here in T star

01:03:27.480 --> 01:03:30.850
that we had to remove,
and then we put e in.

01:03:30.850 --> 01:03:34.170
And then we get a minimum
spanning tree again,

01:03:34.170 --> 01:03:36.760
T star prime.

01:03:36.760 --> 01:03:42.530
OK, this edge that I remove
cannot be one of the TS edges

01:03:42.530 --> 01:03:45.660
because the TS edges
are all inside S.

01:03:45.660 --> 01:03:49.270
So because I'm only removing
an edge that crosses the cut,

01:03:49.270 --> 01:03:50.910
I'm not disturbing TS.

01:03:50.910 --> 01:03:56.230
TS will remain inside T star,
but then I get the new property

01:03:56.230 --> 01:04:02.615
that e is inside T star, and so
I prove this invariant holds.

01:04:02.615 --> 01:04:03.115
OK?

01:04:03.115 --> 01:04:06.180
I keep changing T star, but I
always preserve the property

01:04:06.180 --> 01:04:09.110
that all of the spanning
tree edges that are inside S

01:04:09.110 --> 01:04:12.255
are contained in some minimum
spanning tree of G. Maybe

01:04:12.255 --> 01:04:13.630
I'll add in some for emphasis.

01:04:17.520 --> 01:04:18.630
Cool?

01:04:18.630 --> 01:04:20.430
So that's how we use
the greedy choice

01:04:20.430 --> 01:04:24.640
property to get correctness
of Prim's algorithm.

01:04:26.895 --> 01:04:28.728
What's the running time
of Prim's algorithm?

01:04:36.050 --> 01:04:37.690
Same as Dijkstra, good answer.

01:04:41.190 --> 01:04:43.645
I guess it depends what
priority queue you use,

01:04:43.645 --> 01:04:46.500
but whatever priority queue you
use, it's the same as Dijkstra.

01:04:55.790 --> 01:04:58.430
And so in particular, if we
use Fibonacci heaps, which,

01:04:58.430 --> 01:05:09.646
again, we're not covering, we
get V log V plus E. In general,

01:05:09.646 --> 01:05:11.520
for every edge, we have
to do a decrease-key.

01:05:11.520 --> 01:05:14.160
Actually, for every edge we do
two decrease-key operations,

01:05:14.160 --> 01:05:16.720
potentially, if
you think about it.

01:05:16.720 --> 01:05:21.780
But this for loop over
the adjacency, the cost

01:05:21.780 --> 01:05:23.790
of this stuff is constant.

01:05:23.790 --> 01:05:30.530
The cost of this is the
degree of the vertex u.

01:05:30.530 --> 01:05:32.910
And so we're basically
doing the sum

01:05:32.910 --> 01:05:36.650
of the degrees of
the vertices, which

01:05:36.650 --> 01:05:38.580
is the number of edges times 2.

01:05:38.580 --> 01:05:40.080
That's the handshaking lemma.

01:05:40.080 --> 01:05:42.310
So for every edge,
we're potentially

01:05:42.310 --> 01:05:44.340
doing one decrease-key
operation,

01:05:44.340 --> 01:05:46.880
and with Fibonacci heaps,
that's constant time.

01:05:46.880 --> 01:05:50.207
But we're also doing V extract
mins those cost log V time,

01:05:50.207 --> 01:05:51.790
cause the size of
the queue is at most

01:05:51.790 --> 01:05:55.150
V, and so that is actually
the right running time.

01:05:55.150 --> 01:05:57.700
Just like Dijkstra, so
easy formula to remember.

01:06:00.630 --> 01:06:07.020
All right, let's do one more
algorithm, Kruskal's algorithm.

01:06:41.280 --> 01:06:44.860
Kruskal's algorithm is a
little bit weirder from the S

01:06:44.860 --> 01:06:48.132
perspective, I guess.

01:06:48.132 --> 01:06:52.802
We'll see what cuts
we're using in a moment,

01:06:52.802 --> 01:06:54.260
but it's based
around this idea of,

01:06:54.260 --> 01:06:56.220
well, the globally
minimum weight

01:06:56.220 --> 01:07:01.390
edge is the minimum weight edge
for all cuts that cross it,

01:07:01.390 --> 01:07:03.760
or for all cuts that it crosses.

01:07:03.760 --> 01:07:07.160
The globally minimum weight edge
is going to be a valid choice,

01:07:07.160 --> 01:07:08.650
and so, by this
theorem, you pick

01:07:08.650 --> 01:07:13.050
some S that partitions
the endpoints of e,

01:07:13.050 --> 01:07:14.800
therefore e is in a
minimum spanning tree.

01:07:14.800 --> 01:07:18.510
So let's choose that one
first, and then repeat.

01:07:18.510 --> 01:07:21.680
Conceptually, what we want to
do is that DP idea of contract

01:07:21.680 --> 01:07:24.390
the vertex, sorry,
contract the edge

01:07:24.390 --> 01:07:27.580
and then find the minimum
weight edge that remains.

01:07:27.580 --> 01:07:30.400
But the way I'm going to phrase
it doesn't explicitly contract,

01:07:30.400 --> 01:07:33.960
although implicitly,
it's doing that.

01:07:33.960 --> 01:07:36.820
And there's a catch.

01:07:39.800 --> 01:07:47.444
The catch is suppose I've
picked some edges out to be

01:07:47.444 --> 01:07:48.610
in my minimum spanning tree.

01:07:48.610 --> 01:07:50.160
Suppose this was
the minimum weight

01:07:50.160 --> 01:07:52.065
and this was the next minimum,
next minimum, next minimum,

01:07:52.065 --> 01:07:52.810
next minimum.

01:07:52.810 --> 01:07:56.450
Suppose that the next
lar-- at this point,

01:07:56.450 --> 01:07:59.710
after contracting those
edges, the minimum weight edge

01:07:59.710 --> 01:08:02.740
is this one.

01:08:02.740 --> 01:08:06.180
Do I want to put this edge
in my minimum spanning tree?

01:08:06.180 --> 01:08:07.380
No.

01:08:07.380 --> 01:08:08.340
That would add a cycle.

01:08:08.340 --> 01:08:10.710
Cycles are bad.

01:08:10.710 --> 01:08:12.560
This is the tricky
part of this algorithm.

01:08:12.560 --> 01:08:16.560
I have to keep track of
whether I should actually

01:08:16.560 --> 01:08:19.590
add an edge, in other
words, whether this vertex

01:08:19.590 --> 01:08:23.840
and this vertex have already
been connected to each other.

01:08:23.840 --> 01:08:26.189
And it turns out you've
already seen a data structure

01:08:26.189 --> 01:08:27.630
to do that.

01:08:27.630 --> 01:08:30.229
This is what I call
union-find and the textbook

01:08:30.229 --> 01:08:32.090
calls it disjoint-set
data structure.

01:08:37.609 --> 01:08:40.700
So it's in recitation.

01:08:40.700 --> 01:08:41.535
Recitation 3.

01:08:48.430 --> 01:08:51.120
So I want to maintain
for my MST so far,

01:08:51.120 --> 01:08:53.090
so I'm adding edges
one at a time.

01:08:53.090 --> 01:08:55.600
And I have some tree-- well,
it's actually a forest,

01:08:55.600 --> 01:08:59.550
but I'm still
going to call it T,

01:08:59.550 --> 01:09:05.740
and I'm going to maintain it
in a union-find structure,

01:09:05.740 --> 01:09:08.770
disjoint-set set data structure.

01:09:08.770 --> 01:09:12.770
Remember, this had three
operations, make set, union,

01:09:12.770 --> 01:09:14.100
and find set.

01:09:14.100 --> 01:09:19.539
Tell me given an item which
set does it belong to?

01:09:19.539 --> 01:09:21.330
We're going to use
that, the sets are going

01:09:21.330 --> 01:09:23.560
to be the connected components.

01:09:23.560 --> 01:09:27.664
So after I've added these edges,
these guys, these vertices

01:09:27.664 --> 01:09:29.330
here, will form one
connected component,

01:09:29.330 --> 01:09:31.315
and, you know,
everybody else will just

01:09:31.315 --> 01:09:33.740
be in its own
separate component.

01:09:33.740 --> 01:09:40.500
So to get started, I'm not going
to have any edges in my tree,

01:09:40.500 --> 01:09:43.890
and so every vertex is in
its own connected component.

01:09:43.890 --> 01:09:51.420
So I represent that by calling
make-set v for all vertices.

01:09:51.420 --> 01:09:56.000
So every vertex lives in
its own singleton set.

01:09:56.000 --> 01:10:00.245
OK, now I'd like to do the
minimum weight edge, and then

01:10:00.245 --> 01:10:02.620
the next minimum weight edge,
and the next minimum weight

01:10:02.620 --> 01:10:03.120
edge.

01:10:03.120 --> 01:10:05.450
That's also known
as sorting, so I'm

01:10:05.450 --> 01:10:16.210
going to sort E by
weight, increasing weight,

01:10:16.210 --> 01:10:20.080
so I get to start with
the minimum weight edge.

01:10:30.690 --> 01:10:43.010
So now I'm going to do a
for-loop over the edges,

01:10:43.010 --> 01:10:44.520
increasing order by weight.

01:10:49.640 --> 01:10:53.360
Now I want to know--
I have an edge,

01:10:53.360 --> 01:10:55.610
it's basically the minimum
weight edge among the edges

01:10:55.610 --> 01:10:58.740
that remain, and so I want to
know whether I should add it.

01:10:58.740 --> 01:11:01.894
I'm going to add it provided
the endpoints of the edge

01:11:01.894 --> 01:11:03.560
are not in the same
connected component.

01:11:06.890 --> 01:11:09.160
How can I find out
whether two vertices

01:11:09.160 --> 01:11:11.548
are in the same connected
component, given this setup?

01:11:16.528 --> 01:11:17.364
Yeah?

01:11:17.364 --> 01:11:19.030
AUDIENCE: Call find-set
twice and then--

01:11:19.030 --> 01:11:20.738
ERIK DEMAINE: Call
find-set twice and see

01:11:20.738 --> 01:11:23.110
whether they're equal, exactly.

01:11:23.110 --> 01:11:23.880
Good answer.

01:11:26.840 --> 01:11:38.520
So if you find-set of u
is from find-set of v,

01:11:38.520 --> 01:11:41.394
find-set just returns
some identifier.

01:11:41.394 --> 01:11:43.060
We don't really care
what it is, as long

01:11:43.060 --> 01:11:45.547
as it returns the same
thing for the same set.

01:11:45.547 --> 01:11:47.630
So if u and v are in the
same set, in other words,

01:11:47.630 --> 01:11:48.810
they're in the same
connected component,

01:11:48.810 --> 01:11:51.290
then find-set will return
the same thing for both.

01:11:51.290 --> 01:11:53.410
But provided they're
not equal, then

01:11:53.410 --> 01:12:01.890
we can add this
edge into our tree.

01:12:01.890 --> 01:12:06.330
So we add e to the
set T, and then

01:12:06.330 --> 01:12:08.150
we have to represent
the fact that we just

01:12:08.150 --> 01:12:10.590
merged the connected
components of u and v,

01:12:10.590 --> 01:12:12.360
and we do that
with a union call.

01:12:17.336 --> 01:12:18.710
And if you're ever
wondering what

01:12:18.710 --> 01:12:22.270
the heck do we use union-find
for, this is the answer.

01:12:22.270 --> 01:12:24.640
The union-find data structure
was invented in order

01:12:24.640 --> 01:12:27.710
to implement Kruskal's
algorithm faster, OK?

01:12:27.710 --> 01:12:29.110
In fact, a lot of
data structures

01:12:29.110 --> 01:12:31.210
come from graph algorithms.

01:12:31.210 --> 01:12:34.200
The reason Fibonacci
heaps were invented

01:12:34.200 --> 01:12:35.970
was because there was
Dijkstra's algorithm

01:12:35.970 --> 01:12:37.450
and we wanted it to run fast.

01:12:37.450 --> 01:12:40.700
So same deal here, you just
saw it in the reverse order.

01:12:40.700 --> 01:12:41.780
First you saw union-find.

01:12:41.780 --> 01:12:43.710
Now, union-find, you
know you can solve v

01:12:43.710 --> 01:12:46.570
in alpha of n time, the
inverse Ackermann function,

01:12:46.570 --> 01:12:49.770
super, super tiny, slow growing
function, smaller than log

01:12:49.770 --> 01:12:51.370
log log log log log log.

01:12:53.940 --> 01:12:55.560
Really small.

01:12:55.560 --> 01:12:58.000
But we have this sorting,
which is kind of annoying.

01:12:58.000 --> 01:13:00.395
So the overall
running time-- we'll

01:13:00.395 --> 01:13:02.740
worry about correctness
in a moment.

01:13:02.740 --> 01:13:09.940
We have to sort--
to sort E by weight.

01:13:09.940 --> 01:13:12.430
So I'll just call
that's sort of E.

01:13:12.430 --> 01:13:15.900
Then we have to do some unions.

01:13:15.900 --> 01:13:20.420
I guess for every edge,
potentially, we do a union.

01:13:20.420 --> 01:13:29.280
I'll just write E times alpha
of v. And then we have to do,

01:13:29.280 --> 01:13:31.765
well, we also have to
find-sets, but same deal.

01:13:31.765 --> 01:13:34.990
So find-set and union
cost alpha amortized,

01:13:34.990 --> 01:13:36.960
so the total cost for
doing this for all edges

01:13:36.960 --> 01:13:40.340
is going to be the number
of edges times alpha,

01:13:40.340 --> 01:13:45.700
and then there's like plus v,
I guess, but that's smaller.

01:13:45.700 --> 01:13:47.230
That's a connected graph.

01:13:47.230 --> 01:13:51.000
So other than the sorting time,
this algorithm is really good.

01:13:51.000 --> 01:13:53.910
It's faster.

01:13:53.910 --> 01:13:57.120
But if you're sorting
by an n log n algorithm,

01:13:57.120 --> 01:14:00.070
this is not so great.

01:14:00.070 --> 01:14:01.030
That's how it goes.

01:14:01.030 --> 01:14:04.720
I think you can reduce this to
sorting just v things, instead

01:14:04.720 --> 01:14:07.490
of E things, with a
little bit of effort,

01:14:07.490 --> 01:14:09.060
like doing a select operation.

01:14:09.060 --> 01:14:11.690
But when this algorithm
is really good

01:14:11.690 --> 01:14:14.240
is if your weights are integers.

01:14:14.240 --> 01:14:23.540
If You have weights, let's
say weight of e is 0 or 1

01:14:23.540 --> 01:14:27.330
or, say, n to the c,
for some constant c,

01:14:27.330 --> 01:14:31.340
then I can use rate x
sort, linear time sorting,

01:14:31.340 --> 01:14:32.920
and then this will
be linear time,

01:14:32.920 --> 01:14:34.950
and I'm only paying
E times alpha.

01:14:34.950 --> 01:14:38.100
So if you have
reasonably small weights,

01:14:38.100 --> 01:14:39.620
Kruskal's algorithm is better.

01:14:39.620 --> 01:14:44.920
Otherwise, I guess you
prefer Prim's algorithm.

01:14:44.920 --> 01:14:45.730
But either away.

01:14:48.870 --> 01:14:51.660
I actually used a variation
of this algorithm recently.

01:14:51.660 --> 01:14:54.270
If you want to generate
a random spanning tree,

01:14:54.270 --> 01:14:56.800
then you can use exactly
the same algorithm.

01:14:56.800 --> 01:14:59.880
You pick a random manage that
you haven't picked already, you

01:14:59.880 --> 01:15:03.240
see, can I add this
edge with this test?

01:15:03.240 --> 01:15:04.981
If you can, add it and repeat.

01:15:04.981 --> 01:15:06.730
That will give you a
random spanning tree.

01:15:06.730 --> 01:15:10.990
It will generate all spanning
trees uniform leap likely.

01:15:10.990 --> 01:15:16.080
So that's a fun fact,
useful thing for union-find.

01:15:16.080 --> 01:15:17.850
Let me tell you briefly
about correctness.

01:15:34.012 --> 01:15:35.970
Again, we proved correctness
with an invariant.

01:15:50.720 --> 01:15:53.070
Claim that at all
times the tree T

01:15:53.070 --> 01:15:54.920
of edges that
we've picked so far

01:15:54.920 --> 01:16:00.790
is contained in some minimum
spanning tree, T star.

01:16:00.790 --> 01:16:03.480
T start is going to
change, but I always

01:16:03.480 --> 01:16:06.680
want the edges I've chosen to be
inside a minimum spanning tree.

01:16:06.680 --> 01:16:09.000
Again, we can prove
this by induction.

01:16:09.000 --> 01:16:15.000
So assume by induction
that this is true

01:16:15.000 --> 01:16:21.910
so far, and then suppose that
we're adding an edge here.

01:16:21.910 --> 01:16:27.770
So we're converting T into
T prime, which is T union e.

01:16:31.650 --> 01:16:34.690
By the data structural
setup, I know

01:16:34.690 --> 01:16:36.880
that the endpoints
of e, u, and v

01:16:36.880 --> 01:16:40.470
are in different
connected components.

01:16:40.470 --> 01:16:42.230
In general, what my
picture looks like,

01:16:42.230 --> 01:16:44.610
is I have some various
connected components,

01:16:44.610 --> 01:16:48.320
maybe there's a single
vertex, whatever.

01:16:48.320 --> 01:16:50.780
I've built a minimum
spanning tree for each one.

01:16:50.780 --> 01:16:53.430
I built some tree,
and I actually

01:16:53.430 --> 01:16:56.520
know that these trees are
contained in one global minimum

01:16:56.520 --> 01:16:59.445
spanning tree.

01:16:59.445 --> 01:17:01.750
OK, and now we're
looking at an edge that

01:17:01.750 --> 01:17:05.330
goes from some vertex u
in one connected component

01:17:05.330 --> 01:17:08.450
to some vertex v in a
different connected component.

01:17:08.450 --> 01:17:11.000
This is our edge e.

01:17:11.000 --> 01:17:13.170
That's our setup.

01:17:13.170 --> 01:17:14.947
Because the union-find
data structure

01:17:14.947 --> 01:17:16.530
maintains connected
components, that's

01:17:16.530 --> 01:17:18.570
another invariant to prove.

01:17:18.570 --> 01:17:21.360
We're considering adding
this edge, which connects two

01:17:21.360 --> 01:17:23.490
different connected components.

01:17:23.490 --> 01:17:29.850
So I want to use the greedy
choice property with some S.

01:17:29.850 --> 01:17:31.210
What should S be?

01:17:51.710 --> 01:17:55.929
I want e to cross a cut,
so what's a good cut?

01:18:03.913 --> 01:18:04.911
Yeah?

01:18:04.911 --> 01:18:06.286
AUDIENCE: The
connected component

01:18:06.286 --> 01:18:07.785
of u and then everything else.

01:18:07.785 --> 01:18:09.160
ERIK DEMAINE:
Connected component

01:18:09.160 --> 01:18:10.770
of u and everything else?

01:18:10.770 --> 01:18:11.440
AUDIENCE: Yeah.

01:18:11.440 --> 01:18:12.939
ERIK DEMAINE: That
would work, which

01:18:12.939 --> 01:18:15.550
is also the opposite of the
connected component containing

01:18:15.550 --> 01:18:18.570
v. There are many
choices that work.

01:18:18.570 --> 01:18:20.899
I could take basically
this cut, which

01:18:20.899 --> 01:18:22.940
is the connected component
of you with everything

01:18:22.940 --> 01:18:25.250
else versus the
connected component of v.

01:18:25.250 --> 01:18:28.340
I could take this cut, which
is the connected component of u

01:18:28.340 --> 01:18:30.690
only versus everybody else.

01:18:30.690 --> 01:18:32.730
Either of those will work.

01:18:32.730 --> 01:18:33.230
Good.

01:18:36.370 --> 01:18:40.030
Good curve, all right.

01:18:40.030 --> 01:18:44.470
So let's say S equals the
connected component of u,

01:18:44.470 --> 01:18:48.820
or connected component of v.
e crosses that, all right?

01:18:48.820 --> 01:18:51.870
Because it goes from u to
v, and u is on one side,

01:18:51.870 --> 01:18:55.110
v is on the other side.

01:18:55.110 --> 01:18:57.500
I wanted to include an
entire connected component

01:18:57.500 --> 01:19:00.840
because when I apply the
greedy choice property,

01:19:00.840 --> 01:19:03.140
I modify T star,
and I don't want

01:19:03.140 --> 01:19:06.410
to modify, I don't want to
delete any of these edges that

01:19:06.410 --> 01:19:08.380
are already in my
connected components,

01:19:08.380 --> 01:19:10.330
that I've already put in there.

01:19:10.330 --> 01:19:13.280
But if I choose my
cut to just be this,

01:19:13.280 --> 01:19:15.950
I know that the edge
that I potentially remove

01:19:15.950 --> 01:19:17.524
will cross this
cut, which means it

01:19:17.524 --> 01:19:19.440
goes between connected
components, which means

01:19:19.440 --> 01:19:22.060
I haven't added that yet to T.

01:19:22.060 --> 01:19:25.290
So when I apply this
greedy choice property,

01:19:25.290 --> 01:19:30.470
I'm not deleting anything
from T. Everything that

01:19:30.470 --> 01:19:33.680
was in T is still in T star.

01:19:33.680 --> 01:19:43.730
So that tells me that T prime
is contained in T star prime.

01:19:43.730 --> 01:19:48.150
The new T star that I get
when I apply the cut and paste

01:19:48.150 --> 01:19:50.350
argument, I modify
T star potentially

01:19:50.350 --> 01:19:53.120
by removing one edge
and putting e in.

01:19:53.120 --> 01:19:54.600
And the edge that
I remove was not

01:19:54.600 --> 01:19:58.850
already in T, which means
I preserve this part,

01:19:58.850 --> 01:20:02.580
but I also get that
my new edge e is

01:20:02.580 --> 01:20:04.360
in the minimum spanning tree.

01:20:04.360 --> 01:20:07.220
And so that's how you prove
by induction that at all times

01:20:07.220 --> 01:20:11.600
the edges that you've
chosen so far are in T star.

01:20:11.600 --> 01:20:14.270
Actually, to apply the
greedy choice property,

01:20:14.270 --> 01:20:17.710
I need not only that e is cut--
sorry, that e crosses the cut,

01:20:17.710 --> 01:20:19.650
I also need that e
is the minimum weight

01:20:19.650 --> 01:20:21.470
edge crossing the cut.

01:20:21.470 --> 01:20:26.590
That's a little more
argument to prove.

01:20:26.590 --> 01:20:29.642
The rough idea is
that if you forget

01:20:29.642 --> 01:20:31.350
about the edges we've
already dealt with,

01:20:31.350 --> 01:20:34.240
e is the globally
minimum weight edge.

01:20:34.240 --> 01:20:36.870
OK, but what about the edges
we've already dealt with?

01:20:36.870 --> 01:20:40.160
Some of them are in the tree.

01:20:40.160 --> 01:20:43.411
The edges that are in
these-- that are in T, those

01:20:43.411 --> 01:20:44.660
obviously don't cross the cut.

01:20:44.660 --> 01:20:46.200
That's how we designed the cut.

01:20:46.200 --> 01:20:48.260
The cup was designed
not to cross,

01:20:48.260 --> 01:20:50.870
not two separate any of
these connected components.

01:20:50.870 --> 01:20:54.730
So all the edges that we've
added to T, those are OK.

01:20:54.730 --> 01:20:59.650
They're not related to the
edges that cross this cut.

01:20:59.650 --> 01:21:02.590
But we may have already
considered some lower weight

01:21:02.590 --> 01:21:08.334
edges that we didn't add to T.
If we didn't add an edge to T,

01:21:08.334 --> 01:21:10.500
that means actually they
were in the same set, which

01:21:10.500 --> 01:21:17.000
means also those are-- I'm going
to use my other color, blue.

01:21:17.000 --> 01:21:19.540
Those are extra
edges in here that

01:21:19.540 --> 01:21:23.290
are inside a
connected component,

01:21:23.290 --> 01:21:25.050
have smaller weight
than e, but they're

01:21:25.050 --> 01:21:26.400
inside the connected component.

01:21:26.400 --> 01:21:28.580
So again, they're not crossed.

01:21:28.580 --> 01:21:31.640
So they don't cross
the cut, rather.

01:21:31.640 --> 01:21:34.240
So e is basically the
first edge that we're

01:21:34.240 --> 01:21:36.050
considering that
crosses this cut,

01:21:36.050 --> 01:21:39.240
because otherwise we would have
added that other edge first.

01:21:39.240 --> 01:21:42.910
So here, we have to do sort
of the greedy argument again,

01:21:42.910 --> 01:21:45.520
considering edges
by weight and e

01:21:45.520 --> 01:21:47.370
is going to be the
first edge that

01:21:47.370 --> 01:21:49.160
crosses this
particular cut, which

01:21:49.160 --> 01:21:52.090
is this connected component
versus everyone else.

01:21:52.090 --> 01:21:54.640
So e has to be the minimum
weight edge crossing the cut,

01:21:54.640 --> 01:21:56.290
so the greedy choice
property applies.

01:21:56.290 --> 01:21:59.700
So we can put e in the
minimum spanning tree,

01:21:59.700 --> 01:22:01.560
and this algorithm is correct.

01:22:01.560 --> 01:22:02.060
OK?

01:22:02.060 --> 01:22:05.730
So we've used that lemma
a zillion times by now.

01:22:05.730 --> 01:22:09.430
That's minimum spanning
tree and nearly linear time.

