WEBVTT
Kind: captions
Language: en

00:00:00.090 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high quality
educational resources for free.

00:00:10.730 --> 00:00:13.340
To make a donation or
view additional materials

00:00:13.340 --> 00:00:17.217
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.217 --> 00:00:17.842
at ocw.mit.edu.

00:00:20.872 --> 00:00:22.680
LING REN: All right,
welcome everyone.

00:00:22.680 --> 00:00:25.832
This is 6046 presentation.

00:00:25.832 --> 00:00:27.540
Just make sure you're
in the right place.

00:00:30.670 --> 00:00:32.050
My name is Ling Ren.

00:00:32.050 --> 00:00:36.570
I'm one of the 10
TAs for this class.

00:00:36.570 --> 00:00:39.860
We do have a second
TA for this section.

00:00:39.860 --> 00:00:41.840
I think he is not
here right now,

00:00:41.840 --> 00:00:44.920
but, basically,
[INAUDIBLE] and I will

00:00:44.920 --> 00:00:48.840
be switching every other week.

00:00:48.840 --> 00:00:51.500
I want to remind
you, just a heads up,

00:00:51.500 --> 00:00:55.500
this section is recorded
for OCW purpose.

00:00:55.500 --> 00:01:01.110
But I think he's only
recording us, the TAs.

00:01:01.110 --> 00:01:02.710
You're not in a camera.

00:01:08.040 --> 00:01:10.140
All right, so, the only
purpose we are here

00:01:10.140 --> 00:01:13.060
is to help you learn this very
interesting, and also very

00:01:13.060 --> 00:01:14.320
useful, class.

00:01:14.320 --> 00:01:17.810
So don't hesitate
to ask any questions

00:01:17.810 --> 00:01:20.170
or give us any feedback,
like whether I'm

00:01:20.170 --> 00:01:24.360
going too fast or too slow,
whether you want us to cover

00:01:24.360 --> 00:01:28.370
something that's not
in the posted schedule,

00:01:28.370 --> 00:01:32.390
or just anything we can help.

00:01:32.390 --> 00:01:34.930
All right, so let's get started.

00:01:34.930 --> 00:01:38.640
The two lectures in this
week, in the first week,

00:01:38.640 --> 00:01:40.220
focus on divide and conquer.

00:01:49.610 --> 00:01:53.170
It is a class of algorithm
that usually involves recursion

00:01:53.170 --> 00:01:55.960
in the algorithm description.

00:01:55.960 --> 00:02:02.220
And Professor Devadas worked
through several algorithms,

00:02:02.220 --> 00:02:04.800
including weighted
interval scheduling

00:02:04.800 --> 00:02:07.949
and a bunch of others, and he
left several open problems.

00:02:20.920 --> 00:02:24.460
So we will answer those open
questions in this section,

00:02:24.460 --> 00:02:27.810
and we'll also show
you a new algorithm,

00:02:27.810 --> 00:02:32.080
and analyze a bunch
of other algorithms.

00:02:32.080 --> 00:02:35.520
So just to remind everyone what
weighted interval scheduling

00:02:35.520 --> 00:02:36.020
is.

00:02:40.230 --> 00:02:52.490
In this problem, we are
given a bunch of requests,

00:02:52.490 --> 00:02:55.230
each with a start time
and a finish time.

00:02:55.230 --> 00:03:01.480
And our goal is to find a subset
of them that are compatible,

00:03:01.480 --> 00:03:04.750
meaning they do not
overlap, and that

00:03:04.750 --> 00:03:07.640
have a largest combined weight.

00:03:07.640 --> 00:03:08.680
OK, are we clear?

00:03:08.680 --> 00:03:10.760
Everyone clear about that?

00:03:10.760 --> 00:03:14.260
So an easier case
is when the problem

00:03:14.260 --> 00:03:18.980
is unweighted, meaning that
every task has the same weight.

00:03:18.980 --> 00:03:24.120
In that case, we can just solve
it using our greedy algorithm.

00:03:24.120 --> 00:03:26.360
But when the problem
becomes weighted,

00:03:26.360 --> 00:03:29.860
we have to use dynamic
programming, or recursion,

00:03:29.860 --> 00:03:35.560
and Srini introduced a
simple one, a basic version,

00:03:35.560 --> 00:03:36.560
in a class.

00:03:36.560 --> 00:03:41.395
Can someone remind us
how that algorithm works?

00:03:41.395 --> 00:03:42.020
Any volunteers?

00:03:53.645 --> 00:03:58.359
AUDIENCE: [INAUDIBLE]

00:03:58.359 --> 00:03:59.650
LING REN: Can you speak louder?

00:03:59.650 --> 00:04:02.750
AUDIENCE: [INAUDIBLE]
so we find that it's

00:04:02.750 --> 00:04:04.154
not conflicting [INAUDIBLE].

00:04:09.330 --> 00:04:10.597
LING REN: So what's your name?

00:04:10.597 --> 00:04:15.749
AUDIENCE: [INAUDIBLE]

00:04:15.749 --> 00:04:17.790
LING REN: Yeah, I think
the version you described

00:04:17.790 --> 00:04:19.360
is for the unweighted case.

00:04:19.360 --> 00:04:22.230
In unweighted case,
we just schedule

00:04:22.230 --> 00:04:24.270
the 1 with the
earliest finish time,

00:04:24.270 --> 00:04:27.040
and, then, we remove all
the incompatible ones,

00:04:27.040 --> 00:04:28.500
and we keep going, right?

00:04:28.500 --> 00:04:30.990
That solved the
unweighted version.

00:04:30.990 --> 00:04:34.495
If it's the weighted version,
we need to use recursion.

00:04:34.495 --> 00:04:39.970
And remember, we break the
problem into many sub-problems,

00:04:39.970 --> 00:04:43.997
and each one can potentially
be an optimal solution.

00:04:43.997 --> 00:04:45.080
Does anyone remember that?

00:04:48.010 --> 00:04:49.398
Care to give it a try?

00:04:49.398 --> 00:04:50.862
AUDIENCE: Sure.

00:04:50.862 --> 00:04:53.790
So we break it into subproblems.

00:04:53.790 --> 00:04:57.694
We took the best solution
from a certain point,

00:04:57.694 --> 00:05:00.622
and then we calculate
that subproblem

00:05:00.622 --> 00:05:03.062
starting at all the
different finish times.

00:05:03.062 --> 00:05:05.804
[INAUDIBLE]

00:05:05.804 --> 00:05:06.470
LING REN: Great.

00:05:06.470 --> 00:05:07.516
What is your name?

00:05:07.516 --> 00:05:10.090
AUDIENCE: [? Amin. ?]

00:05:10.090 --> 00:05:11.210
LING REN: [? Amin? ?] OK.

00:05:11.210 --> 00:05:14.700
[? Amin ?] said, let's
just try every one

00:05:14.700 --> 00:05:18.775
as our potential first request.

00:05:22.250 --> 00:05:28.890
So if we request the j as
our first, we get its weight.

00:05:28.890 --> 00:05:31.900
And then, we're going
to solve a subproblem.

00:05:31.900 --> 00:05:33.930
So let me call the
original problem.

00:05:33.930 --> 00:05:41.040
We did interval scheduling
with all the incoming requests.

00:05:41.040 --> 00:05:44.480
Now, we choose j,
request as our first.

00:05:44.480 --> 00:05:51.800
Now, we are left with a
subproblem that starts

00:05:51.800 --> 00:05:54.250
after request to j finishes.

00:05:54.250 --> 00:05:59.330
So I'll write that
as Rj, Where I

00:05:59.330 --> 00:06:06.350
define Rj to be the set of
requests where their stop

00:06:06.350 --> 00:06:15.170
time is later than the finish
time of the j-th request.

00:06:18.450 --> 00:06:23.180
OK, so just to repeat,
we choose a request,

00:06:23.180 --> 00:06:26.060
has the potential to
be the first request,

00:06:26.060 --> 00:06:29.510
and then, we look at all the
requests that start after it,

00:06:29.510 --> 00:06:34.090
and solve a subproblem
of that case.

00:06:34.090 --> 00:06:43.880
Then, we take a max of
all the candidate we have,

00:06:43.880 --> 00:06:47.164
and that's going to give
us the optimal solution.

00:06:47.164 --> 00:06:48.580
Any question about
this algorithm?

00:06:54.980 --> 00:06:57.640
So this algorithm
runs in n square time.

00:07:05.560 --> 00:07:09.120
Now, we're going to try to
optimize that, and come up

00:07:09.120 --> 00:07:12.460
with a better algorithm.

00:07:12.460 --> 00:07:18.330
So in order to improve
anything, we first

00:07:18.330 --> 00:07:22.650
want to identify the
inefficiency in this algorithm.

00:07:22.650 --> 00:07:25.960
So which part in
the algorithm do you

00:07:25.960 --> 00:07:29.191
think is inefficient,
or silly, unnecessary?

00:07:29.191 --> 00:07:29.690
Go ahead.

00:07:29.690 --> 00:07:31.594
AUDIENCE: So it's
inefficient to look

00:07:31.594 --> 00:07:36.584
through every previous
subproblem, when we're trying

00:07:36.584 --> 00:07:42.890
to find maximum [INAUDIBLE].

00:07:42.890 --> 00:07:44.390
LING REN: I was
saying that we don't

00:07:44.390 --> 00:07:48.428
need to go through
every of this case.

00:07:48.428 --> 00:07:51.400
AUDIENCE: Yeah,
we shouldn't Well,

00:07:51.400 --> 00:07:58.090
we should be able to efficiently
query for the right one.

00:07:58.090 --> 00:08:01.910
LING REN: OK, I think you
are definitely correct.

00:08:01.910 --> 00:08:05.230
So let me just go through what
this algorithm does, and it

00:08:05.230 --> 00:08:06.770
will be more clear.

00:08:06.770 --> 00:08:12.510
So what this means is, I'll
choose the first request.

00:08:12.510 --> 00:08:14.820
I'll request 1 as
my first request.

00:08:14.820 --> 00:08:18.090
Then, I'm going to consider
only the requests that

00:08:18.090 --> 00:08:20.100
start after 1 finishes, right?

00:08:20.100 --> 00:08:22.680
That only leaves request a 5.

00:08:22.680 --> 00:08:25.710
Potentially some other's
already been drawn there.

00:08:25.710 --> 00:08:28.592
That's my first
candidate in that max.

00:08:28.592 --> 00:08:34.169
My second candidate is actually
request 2 as my first request.

00:08:34.169 --> 00:08:38.049
Then, I have to remove request
1, because it starts too early,

00:08:38.049 --> 00:08:40.510
and then, I'm left with
all the remaining requests.

00:08:40.510 --> 00:08:42.380
I'll solve that subproblem.

00:08:42.380 --> 00:08:43.880
That's candidate 2.

00:08:43.880 --> 00:08:50.190
Candidate 3, I chose request
3 as my first request,

00:08:50.190 --> 00:08:52.460
and then I have
to remove 1 and 2,

00:08:52.460 --> 00:08:54.810
because they start too early.

00:08:54.810 --> 00:08:55.817
Oh, 4 as well.

00:08:55.817 --> 00:08:57.150
It also starts too early, right?

00:08:57.150 --> 00:08:58.750
Before 3 finishes.

00:08:58.750 --> 00:09:00.080
Everyone following that?

00:09:00.080 --> 00:09:04.170
So we're left with
the remaining request.

00:09:04.170 --> 00:09:05.070
Is it more clear now?

00:09:08.790 --> 00:09:09.290
Go ahead.

00:09:09.290 --> 00:09:12.720
AUDIENCE: So candidate, if
you start with 3, that's

00:09:12.720 --> 00:09:16.140
actually a subproblem of 2.

00:09:16.140 --> 00:09:16.640
[INAUDIBLE]

00:09:20.070 --> 00:09:22.462
LING REN: Great point.

00:09:22.462 --> 00:09:23.170
What's your name?

00:09:23.170 --> 00:09:24.990
AUDIENCE: Andrew.

00:09:24.990 --> 00:09:27.370
LING REN: Andrew said,
we can potentially

00:09:27.370 --> 00:09:32.590
be solving many repeated
subproblems, like this.

00:09:32.590 --> 00:09:34.370
We definitely don't
want to do that.

00:09:34.370 --> 00:09:39.340
And that's actually the core
idea, the one crisp idea

00:09:39.340 --> 00:09:41.720
of dynamic programming.

00:09:41.720 --> 00:09:43.880
Andrew, can you tell me
what's the definition

00:09:43.880 --> 00:09:46.016
of dynamic programming?

00:09:46.016 --> 00:09:46.970
You remember?

00:09:46.970 --> 00:09:49.846
Anyone remember that?

00:09:49.846 --> 00:09:50.700
Go ahead.

00:09:50.700 --> 00:09:53.940
AUDIENCE: Just memorize
subproblems, then look them up.

00:09:53.940 --> 00:09:54.830
LING REN: Exactly.

00:09:54.830 --> 00:10:00.060
So dynamic programming says,
we will break a problem

00:10:00.060 --> 00:10:01.920
into subproblems,
and subproblems

00:10:01.920 --> 00:10:05.370
into even more subproblems,
but whenever we solve one,

00:10:05.370 --> 00:10:09.220
we should memorize, or
just remember its result

00:10:09.220 --> 00:10:10.450
and store it somewhere.

00:10:10.450 --> 00:10:12.780
And if you need it again,
we'll just retrieve it,

00:10:12.780 --> 00:10:14.115
without resolving the problem.

00:10:16.830 --> 00:10:19.240
That's definitely a great point.

00:10:19.240 --> 00:10:24.050
So we can analyze the
complexity of this algorithm

00:10:24.050 --> 00:10:26.560
later, because I want
to touch on this more

00:10:26.560 --> 00:10:28.080
efficient algorithm first.

00:10:28.080 --> 00:10:31.070
And we'll see that, even
after Andrew's optimization,

00:10:31.070 --> 00:10:33.030
its runtime is n square.

00:10:33.030 --> 00:10:34.920
So without that
observation, if we

00:10:34.920 --> 00:10:36.580
are solving repeated
subproblems,

00:10:36.580 --> 00:10:40.105
these will be a lot
worse than that.

00:10:40.105 --> 00:10:40.730
Yeah, go ahead.

00:10:40.730 --> 00:10:44.062
AUDIENCE: You can also trim
ones that get to the same place,

00:10:44.062 --> 00:10:46.387
so you don't need to
explore two paths.

00:10:46.387 --> 00:10:47.720
LING REN: Sorry, say that again?

00:10:47.720 --> 00:10:49.710
AUDIENCE: You don't need
to explore two paths that

00:10:49.710 --> 00:10:50.918
[INAUDIBLE] both exploring 3.

00:10:50.918 --> 00:10:53.246
Once they're both looking
at 3, then you only

00:10:53.246 --> 00:10:56.360
need to do the ones more
efficient to that point.

00:10:56.360 --> 00:10:57.420
LING REN: OK, cool.

00:10:57.420 --> 00:10:59.318
Go ahead.

00:10:59.318 --> 00:11:00.525
Oh, same thing?

00:11:00.525 --> 00:11:02.316
AUDIENCE: Well, I have
another one as well.

00:11:02.316 --> 00:11:05.020
So I think to get
better than n squared,

00:11:05.020 --> 00:11:13.140
we need to make the observation
that it's always fine to start

00:11:13.140 --> 00:11:15.830
a subproblem later.

00:11:15.830 --> 00:11:17.522
So if you've decided
you're taking

00:11:17.522 --> 00:11:19.896
a certain sequence of intervals
from your first interval,

00:11:19.896 --> 00:11:22.840
and then you want to see
how to compute from there,

00:11:22.840 --> 00:11:31.708
it's always valid to start
later than, maybe, you had to.

00:11:31.708 --> 00:11:35.575
So that means that
if we can efficiently

00:11:35.575 --> 00:11:36.968
starting at any
particular point,

00:11:36.968 --> 00:11:42.956
query for the maximum of any
of the subproblems starting

00:11:42.956 --> 00:11:45.460
after that point, then
we can [INAUDIBLE]..

00:11:45.460 --> 00:11:47.050
LING REN: OK, great.

00:11:47.050 --> 00:11:48.740
I think we are on the same page.

00:11:48.740 --> 00:11:53.420
So when I describe the
steps of this algorithm,

00:11:53.420 --> 00:11:56.110
remember this third candidate.

00:11:56.110 --> 00:11:59.440
I choose this as
my first, right?

00:11:59.440 --> 00:12:03.230
It makes zero sense,
because, if I do that,

00:12:03.230 --> 00:12:06.410
I might as well
put in 2, as well.

00:12:06.410 --> 00:12:10.117
Doesn't hurt, right?

00:12:10.117 --> 00:12:13.500
Everyone get that?

00:12:13.500 --> 00:12:22.120
So the idea is that we
shouldn't try every possible W

00:12:22.120 --> 00:12:24.340
request as my first.

00:12:24.340 --> 00:12:27.000
Some requests are
just better, more

00:12:27.000 --> 00:12:29.425
suited to be the first request.

00:12:29.425 --> 00:12:32.150
And how we're going to do that?

00:12:32.150 --> 00:12:34.130
So, apparently,
1 can potentially

00:12:34.130 --> 00:12:35.020
be the first request.

00:12:35.020 --> 00:12:36.780
2 can also be.

00:12:36.780 --> 00:12:40.350
But it doesn't make any
sense for any requests

00:12:40.350 --> 00:12:44.110
come after that, because
there's and earlier request.

00:12:44.110 --> 00:12:48.330
So the efficient
algorithm, let's

00:12:48.330 --> 00:12:52.370
first sort them by
their start time.

00:12:52.370 --> 00:12:56.600
We're going to consider the
request that comes early first.

00:13:02.128 --> 00:13:05.350
So I have my entire
problem, here.

00:13:08.710 --> 00:13:10.890
Now, I'm going to
ask a question.

00:13:10.890 --> 00:13:15.750
Should I include request
1 in my solution or not?

00:13:15.750 --> 00:13:16.710
That's only two cases.

00:13:22.180 --> 00:13:28.440
So if I do not select 1 in
my solution, what subproblem

00:13:28.440 --> 00:13:29.230
am I left with?

00:13:34.700 --> 00:13:37.640
Any idea?

00:13:37.640 --> 00:13:42.690
If I decide I will not
include 1 in my solution.

00:13:42.690 --> 00:13:43.911
AUDIENCE: [INAUDIBLE].

00:13:43.911 --> 00:13:44.910
LING REN: Yeah, exactly.

00:13:47.660 --> 00:13:49.410
There's no conflicts anywhere.

00:13:49.410 --> 00:13:52.560
I'll solve a
subproblem from 2 to n.

00:13:52.560 --> 00:13:57.090
If I do decide to put my
request 1 in a solution,

00:13:57.090 --> 00:13:58.610
I get this weight.

00:13:58.610 --> 00:14:00.910
So what's the subproblem
I'm left with?

00:14:09.520 --> 00:14:12.330
Yeah, in this
example, it's five.

00:14:12.330 --> 00:14:12.830
Correct.

00:14:12.830 --> 00:14:13.663
But more generally--

00:14:16.850 --> 00:14:23.100
AUDIENCE: [INAUDIBLE] So every
request that starts afterward.

00:14:23.100 --> 00:14:29.000
LING REN: Exactly, every request
that starts after 1 finishes.

00:14:29.000 --> 00:14:31.720
Now, suddenly, we are not
breaking the original problem

00:14:31.720 --> 00:14:32.990
into n subproblems.

00:14:32.990 --> 00:14:34.310
We only have two subproblems.

00:14:40.050 --> 00:14:41.880
So let me draw a
recursion tree, which

00:14:41.880 --> 00:14:45.830
is a powerful tool in
analyzing these sort of things.

00:14:49.800 --> 00:14:56.780
So we start with our original
problem, from 1 to n,

00:14:56.780 --> 00:15:02.760
and we have two subproblems,
2 to n and R1 to n.

00:15:02.760 --> 00:15:06.800
This one, we'll also break
them into subproblems.

00:15:06.800 --> 00:15:07.645
So what is this one?

00:15:12.590 --> 00:15:15.890
OK, I have my sub
problem 2 to n,

00:15:15.890 --> 00:15:25.856
and I need to further
reapply the same trick

00:15:25.856 --> 00:15:26.772
AUDIENCE: [INAUDIBLE].

00:15:32.103 --> 00:15:35.350
The max of Wi has to be--

00:15:35.350 --> 00:15:36.380
LING REN: Oh, sorry.

00:15:39.660 --> 00:15:41.710
These are the two cases.

00:15:44.590 --> 00:15:48.650
Either I do not schedule
my first, or I schedule it,

00:15:48.650 --> 00:15:50.970
and this is my first request.

00:15:50.970 --> 00:15:53.550
Now, here, I'm left
with this problem.

00:15:53.550 --> 00:15:56.880
Either I do not schedule
it, or I schedule it

00:15:56.880 --> 00:15:58.470
as my first request.

00:15:58.470 --> 00:15:59.390
So what is this one?

00:16:05.102 --> 00:16:08.440
AUDIENCE: Probably
be 3 to the n.

00:16:08.440 --> 00:16:10.540
LING REN: 3 to n,
because now I'm

00:16:10.540 --> 00:16:12.560
asking the same question for 2.

00:16:12.560 --> 00:16:20.140
And, here, I'll have R2
to n, so on and so forth.

00:16:20.140 --> 00:16:27.700
Now, let me point out the big
difference for this version,

00:16:27.700 --> 00:16:29.380
and for the basic version.

00:16:29.380 --> 00:16:33.820
So I'm starting with the
request that starts first.

00:16:33.820 --> 00:16:37.940
If I do not do
that, say, if here,

00:16:37.940 --> 00:16:42.870
I am asking the question for
5, do I schedule 5 as my first

00:16:42.870 --> 00:16:44.150
or not?

00:16:44.150 --> 00:16:47.250
Then, what happens?

00:16:47.250 --> 00:16:51.400
Then, these two branches
do not cover all the cases,

00:16:51.400 --> 00:16:55.100
because I can
potentially schedule it,

00:16:55.100 --> 00:16:59.840
but not as my first, in
the optimal solution,

00:16:59.840 --> 00:17:03.650
if I'm asking a question
for a random request.

00:17:03.650 --> 00:17:08.970
However, if I start with the
first request, first meaning it

00:17:08.970 --> 00:17:11.710
starts earliest, it will
either be not scheduled,

00:17:11.710 --> 00:17:14.040
or it will be scheduled,
and as the first.

00:17:14.040 --> 00:17:16.956
Because it cannot be the
second request in my solution.

00:17:20.432 --> 00:17:21.890
Any questions about
this algorithm?

00:17:31.230 --> 00:17:34.820
OK, now, this is the algorithm.

00:17:34.820 --> 00:17:37.930
Let's analyze its complexity.

00:17:37.930 --> 00:17:41.130
So what's the
overall complexity.

00:17:41.130 --> 00:17:42.710
when we go all the
way down, solve

00:17:42.710 --> 00:17:45.710
the entire original problem?

00:17:45.710 --> 00:17:46.850
Any guesses?

00:17:49.480 --> 00:17:50.230
What do you think?

00:17:55.040 --> 00:17:57.450
What do you think?

00:17:57.450 --> 00:17:59.286
Go ahead.

00:17:59.286 --> 00:18:02.484
AUDIENCE: It should be log
n, because [INAUDIBLE] sort

00:18:02.484 --> 00:18:07.158
the intervals, and we're going
to need to, for every interval,

00:18:07.158 --> 00:18:13.800
find the next interval
that starts after it,

00:18:13.800 --> 00:18:16.985
and do that for [INAUDIBLE].

00:18:16.985 --> 00:18:17.610
LING REN: Cool.

00:18:17.610 --> 00:18:21.990
So the first step is
sorting, which is n log n.

00:18:25.930 --> 00:18:32.890
Now, after I sort everything,
the question I need to answer

00:18:32.890 --> 00:18:37.020
is, how many unique
subproblems are there,

00:18:37.020 --> 00:18:38.480
in this entire recursion tree?

00:18:38.480 --> 00:18:42.270
So I'm not going to solve
the same problem twice.

00:18:42.270 --> 00:18:44.840
How many unique
problems exist, here?

00:18:47.420 --> 00:18:48.500
n of them, right?

00:18:48.500 --> 00:18:50.780
Just this left branch.

00:18:50.780 --> 00:18:54.280
All the others will
be one of these.

00:18:54.280 --> 00:18:59.430
So I can start from the bottom
of the tree and work my way up,

00:18:59.430 --> 00:19:04.470
and when I want
to take this step,

00:19:04.470 --> 00:19:07.690
I'll look up the
result of this in one

00:19:07.690 --> 00:19:10.100
of the subproblems
I've already solved.

00:19:10.100 --> 00:19:16.972
So, actually, the recursion
itself is only O of n.

00:19:16.972 --> 00:19:18.555
AUDIENCE: I missed
when you said, what

00:19:18.555 --> 00:19:22.080
is the sorting referring to?

00:19:22.080 --> 00:19:27.960
LING REN: OK, so we need to
start with the request that

00:19:27.960 --> 00:19:30.180
starts first, right?

00:19:30.180 --> 00:19:33.710
We need to decide whether
we schedule it or not.

00:19:33.710 --> 00:19:37.400
And, then, we need to do the
same thing for this request 2.

00:19:37.400 --> 00:19:40.880
It's the start earliest
request in this subset.

00:19:40.880 --> 00:19:44.210
We always need to do that
for all the subproblems.

00:19:47.890 --> 00:19:52.710
So the overall
complexity is n log n.

00:19:56.510 --> 00:19:59.540
But if we only focus
on this recursion step,

00:19:59.540 --> 00:20:01.770
our improvement is
actually larger than that,

00:20:01.770 --> 00:20:10.490
because it went from
n square to O of n.

00:20:10.490 --> 00:20:14.160
So why is the original
algorithm n squared?

00:20:14.160 --> 00:20:17.920
I think it also has only n
unique subproblems, right?

00:20:22.340 --> 00:20:24.460
So do you agree that the
original algorithm is n

00:20:24.460 --> 00:20:27.430
squared, or do you
think it's also O of n?

00:20:27.430 --> 00:20:28.810
Just focus on the
recursion step.

00:20:33.720 --> 00:20:35.684
AUDIENCE: Didn't the
original algorithm

00:20:35.684 --> 00:20:39.612
solve some subproblems
up to n times?

00:20:39.612 --> 00:20:42.067
So that's why it's
still of n squared,

00:20:42.067 --> 00:20:44.784
because it solved
the same thing?

00:20:44.784 --> 00:20:46.200
LING REN: But
assuming I do not do

00:20:46.200 --> 00:20:48.250
that, assuming, whenever
I solve it once,

00:20:48.250 --> 00:20:53.100
I store the result somewhere,
and I directly get it.

00:20:53.100 --> 00:20:55.330
Assuming I do that,
what's the complexity?

00:21:01.006 --> 00:21:02.900
Go ahead.

00:21:02.900 --> 00:21:03.726
AUDIENCE: O of n.

00:21:03.726 --> 00:21:06.960
LING REN: You think it's O of n?

00:21:06.960 --> 00:21:09.230
So anyone think it's n squared?

00:21:09.230 --> 00:21:10.980
Because I think Srini
said it's n squared.

00:21:10.980 --> 00:21:12.456
Go ahead.

00:21:12.456 --> 00:21:14.424
AUDIENCE: I think the
original algorithm isn't

00:21:14.424 --> 00:21:16.228
[INAUDIBLE] squared,
because we're still

00:21:16.228 --> 00:21:19.360
doing [INAUDIBLE] for every
subproblem [INAUDIBLE]..

00:21:19.360 --> 00:21:21.620
LING REN: Exactly right.

00:21:21.620 --> 00:21:24.130
So, here, whenever
we go up one step,

00:21:24.130 --> 00:21:26.420
I'm doing constant
number of work.

00:21:26.420 --> 00:21:29.940
Just comparing two numbers
and taking the max.

00:21:29.940 --> 00:21:31.970
However, in the
original algorithm,

00:21:31.970 --> 00:21:36.510
which is here, whenever
I want to go one step up,

00:21:36.510 --> 00:21:40.720
there are n branches
of the tree.

00:21:40.720 --> 00:21:46.410
So my total amount of work is
1 plus 2 plus 3 plus n, right?

00:21:46.410 --> 00:21:48.940
Every step becomes
harder when I go up.

00:21:48.940 --> 00:21:51.400
And this is n squared.

00:22:02.459 --> 00:22:03.500
Any questions about that?

00:22:10.192 --> 00:22:14.690
OK, this is so much for our
weighted interval scheduling.

00:22:14.690 --> 00:22:16.830
Now, I'm going to transition
into the next topic.

00:22:16.830 --> 00:22:21.180
So any question on
the side, in general,

00:22:21.180 --> 00:22:22.395
for the scheduling problem?

00:22:26.021 --> 00:22:27.914
Do you have a question?

00:22:27.914 --> 00:22:29.210
No?

00:22:29.210 --> 00:22:37.490
OK, now, let's turn to a second
topic of this section, which

00:22:37.490 --> 00:22:38.555
is Strassen algorithm.

00:22:42.270 --> 00:22:44.750
Strassen algorithm is
an efficient algorithm

00:22:44.750 --> 00:22:48.970
for matrix multiplication,
and matrix multiplication

00:22:48.970 --> 00:22:51.630
is a really useful primitive.

00:22:51.630 --> 00:22:56.690
It has applications in almost
every area I can think of.

00:22:56.690 --> 00:23:00.410
Circuit simulation,
climate simulation,

00:23:00.410 --> 00:23:03.760
and physics,
basically everything.

00:23:03.760 --> 00:23:06.830
Now, I actually
had some experience

00:23:06.830 --> 00:23:10.250
with matrix multiplication,
because my undergrad research

00:23:10.250 --> 00:23:13.090
was improving matrix algorithms.

00:23:13.090 --> 00:23:15.040
And, actually, many
matrix algorithms,

00:23:15.040 --> 00:23:17.840
including inversion,
solving equations,

00:23:17.840 --> 00:23:21.090
they all use multiplication
as a primitive.

00:23:21.090 --> 00:23:23.530
So it actually comes
down to improving

00:23:23.530 --> 00:23:25.400
matrix multiplication.

00:23:25.400 --> 00:23:31.000
And I tried very hard to just
optimize this basic matrix

00:23:31.000 --> 00:23:32.170
multiplication.

00:23:32.170 --> 00:23:34.360
We'll take a row,
you take a column,

00:23:34.360 --> 00:23:39.200
and then you get your
answer for this spot.

00:23:39.200 --> 00:23:41.690
Everyone's familiar
with that, right?

00:23:41.690 --> 00:23:43.370
I tried very hard,
but it's still

00:23:43.370 --> 00:23:46.980
100 x slower than the
best algorithm out there.

00:23:46.980 --> 00:23:50.990
So I finally look it up, and
I was completely mind-blown

00:23:50.990 --> 00:23:55.860
when I know that matrix
algorithm complexity is not

00:23:55.860 --> 00:23:57.850
n cubic.

00:23:57.850 --> 00:23:59.360
It's actually smaller than that.

00:24:03.790 --> 00:24:06.440
Is this a surprise to you?

00:24:06.440 --> 00:24:07.540
Anyone expect that before?

00:24:12.210 --> 00:24:15.790
And the technique the more
efficient algorithm uses

00:24:15.790 --> 00:24:18.180
is, exactly, Strassen algorithm.

00:24:18.180 --> 00:24:20.180
Now that we're talking
about divide and conquer,

00:24:20.180 --> 00:24:23.770
you can guess it must be a
divide and conquer algorithm.

00:24:23.770 --> 00:24:26.540
And, so, does
anyone have an idea

00:24:26.540 --> 00:24:28.230
how to divide the
original problem?

00:24:34.322 --> 00:24:35.530
Anyone want to give it a try?

00:24:41.490 --> 00:24:45.760
So are you familiar with
tiled matrix multiplication,

00:24:45.760 --> 00:24:48.686
or blocked matrix
multiplication?

00:24:48.686 --> 00:24:51.265
OK, can you tell
us what that is?

00:24:51.265 --> 00:24:51.890
AUDIENCE: Yeah.

00:24:51.890 --> 00:24:54.830
You can break it
into [INAUDIBLE]..

00:25:01.200 --> 00:25:05.890
LING REN: OK, so say
this is our A and B,

00:25:05.890 --> 00:25:10.330
and we want C. We can break
each matrix into four parts.

00:25:10.330 --> 00:25:16.710
I'll call this
A11, A12, A21, A22.

00:25:16.710 --> 00:25:20.820
B11, B12, B21, B22.

00:25:24.750 --> 00:25:29.390
Same thing for C.

00:25:29.390 --> 00:25:36.880
Now, I would like someone
to tell me, what is C11,

00:25:36.880 --> 00:25:37.485
in this case?

00:25:41.755 --> 00:25:42.255
Yes.

00:25:42.255 --> 00:25:43.338
AUDIENCE: A11 [INAUDIBLE].

00:25:49.590 --> 00:25:52.300
LING REN: A12, B21, yep.

00:25:52.300 --> 00:25:57.280
And C12 is--

00:25:57.280 --> 00:26:01.150
Just speak up, don't be shy.

00:26:01.150 --> 00:26:04.650
This is also my first
section ever, in my life,

00:26:04.650 --> 00:26:05.619
teaching a recitation.

00:26:05.619 --> 00:26:06.910
I'm more nervous than you guys.

00:26:09.681 --> 00:26:10.180
What is C12?

00:26:16.288 --> 00:26:19.620
AUDIENCE: A11, B12?

00:26:19.620 --> 00:26:23.180
LING REN: A11, B12.

00:26:25.800 --> 00:26:28.152
A12, B22, right?

00:26:28.152 --> 00:26:31.000
So the rule is the
same as before.

00:26:31.000 --> 00:26:32.040
Matrix multiplication.

00:26:32.040 --> 00:26:34.400
Compute this, we take
this row, this column,

00:26:34.400 --> 00:26:35.614
and it gives us this.

00:26:35.614 --> 00:26:37.280
AUDIENCE: So the
first one [INAUDIBLE]..

00:26:41.040 --> 00:26:42.400
LING REN: Right, thank you.

00:26:47.060 --> 00:26:47.680
A12, B21.

00:26:50.370 --> 00:26:51.680
OK.

00:26:51.680 --> 00:26:53.530
And, same thing,
C21, we're going

00:26:53.530 --> 00:26:56.655
to take this row
and this column.

00:26:56.655 --> 00:27:07.840
A21 B11 plus A22 B21.

00:27:07.840 --> 00:27:18.151
C11 is A21 B12 plus A22 B22.

00:27:18.151 --> 00:27:18.650
OK.

00:27:24.260 --> 00:27:26.562
And everyone understands this?

00:27:26.562 --> 00:27:28.090
OK, great.

00:27:28.090 --> 00:27:30.490
So, now, we've broken
up the original problem

00:27:30.490 --> 00:27:32.600
into several subproblems.

00:27:32.600 --> 00:27:36.600
We only need to do matrix
multiplication here

00:27:36.600 --> 00:27:37.280
eight times.

00:27:39.900 --> 00:27:44.520
And each of this
matrix is half in size.

00:27:44.520 --> 00:27:47.120
If the original
algorithm is n cubic,

00:27:47.120 --> 00:27:50.530
now each sub problem
is half n cubic.

00:27:50.530 --> 00:27:55.860
Then we have eight of them,
so the complexity is still

00:27:55.860 --> 00:27:57.170
n cubic.

00:27:57.170 --> 00:27:58.640
No improvement at all.

00:28:01.860 --> 00:28:05.880
So, actually, to
be more precise,

00:28:05.880 --> 00:28:10.640
we can further break up these
matrices into smaller blocks.

00:28:10.640 --> 00:28:13.800
So, to be precise,
its complexity

00:28:13.800 --> 00:28:16.430
should be given by a recursion.

00:28:20.740 --> 00:28:26.180
Eight subproblems, each
one half the size, plus--

00:28:26.180 --> 00:28:27.540
can anyone tell me?

00:28:27.540 --> 00:28:33.560
What's the merging complexity,
once I get all this?

00:28:38.494 --> 00:28:38.994
[INAUDIBLE]

00:28:44.428 --> 00:28:45.310
Go ahead.

00:28:45.310 --> 00:28:48.232
AUDIENCE: Is it just constant
because you're adding?

00:28:48.232 --> 00:28:49.690
LING REN: Yeah,
because I'm adding.

00:28:49.690 --> 00:28:52.191
But is it constant?

00:28:52.191 --> 00:28:53.440
I'm adding these two matrices.

00:28:56.000 --> 00:28:58.852
AUDIENCE: [INAUDIBLE].

00:28:58.852 --> 00:29:00.160
LING REN: Pardon?

00:29:00.160 --> 00:29:03.060
AUDIENCE: For each
level it can base case?

00:29:03.060 --> 00:29:05.560
LING REN: Yeah, for base case,
it's, of course, constant.

00:29:05.560 --> 00:29:07.180
OK, so maybe I'm not
clear about this.

00:29:07.180 --> 00:29:09.110
What's the subproblem,
in this case?

00:29:09.110 --> 00:29:13.100
It's this multiplication
operation, OK?

00:29:13.100 --> 00:29:17.270
And, so, these are the eight
subproblems I will solve.

00:29:17.270 --> 00:29:20.590
After solving them, I
need to add them together.

00:29:20.590 --> 00:29:27.520
And adding two matrices,
and each is size ha;f of n.

00:29:27.520 --> 00:29:28.580
The complexity is--

00:29:28.580 --> 00:29:30.670
AUDIENCE: n squared 2 over 2?

00:29:30.670 --> 00:29:34.300
LING REN: Yeah, it's n squared.

00:29:34.300 --> 00:29:35.770
Basically, n squared.

00:29:35.770 --> 00:29:40.790
So, to get a precise complexity,
we should solve this recursion,

00:29:40.790 --> 00:29:43.530
but it will end up being the
same thing as this intuition,

00:29:43.530 --> 00:29:46.090
n cubic.

00:29:46.090 --> 00:29:48.470
OK, so now, this is the magic.

00:29:48.470 --> 00:29:52.800
So Strassen, in 1969, came
up with this algorithm.

00:29:55.104 --> 00:29:56.020
AUDIENCE: [INAUDIBLE].

00:30:00.820 --> 00:30:05.768
LING REN: Each of these is
a half n by half n matrix.

00:30:05.768 --> 00:30:06.684
AUDIENCE: [INAUDIBLE].

00:30:10.380 --> 00:30:13.270
LING REN: So Strassen came
up with this algorithm.

00:30:13.270 --> 00:30:20.620
He somehow defined M1
through M7, seven matrices,

00:30:20.620 --> 00:30:22.820
in this way.

00:30:22.820 --> 00:30:25.280
I can't provide any
intuition, because I

00:30:25.280 --> 00:30:26.570
didn't come up with this.

00:30:26.570 --> 00:30:30.580
And, somehow, with
those seven matrices,

00:30:30.580 --> 00:30:35.110
he can reconstruct, he
can compute all the four

00:30:35.110 --> 00:30:38.680
submatrices in C.

00:30:38.680 --> 00:30:40.770
And it's not very just
interesting to check it,

00:30:40.770 --> 00:30:43.470
because the algorithm
is definitely correct.

00:30:43.470 --> 00:30:45.150
But let's just do one of them.

00:30:45.150 --> 00:30:46.740
OK, how about this one.

00:30:46.740 --> 00:30:49.270
So C21 is M2 plus M4.

00:30:49.270 --> 00:30:52.190
So M2 plus M4.

00:30:52.190 --> 00:30:58.830
So M2 will have
A12 B11, A22 B11.

00:30:58.830 --> 00:31:03.920
So M4, there's A22 minus
B11, so that cancels out.

00:31:03.920 --> 00:31:09.000
So we're left with
A21 B11 plus A22 B21.

00:31:12.180 --> 00:31:15.370
That's the correct answer.

00:31:15.370 --> 00:31:18.400
So this, I guess, is a
very clever algorithm.

00:31:18.400 --> 00:31:20.670
You have to work in
that area for 10 years

00:31:20.670 --> 00:31:23.220
to come up with this so
that's not our concern.

00:31:23.220 --> 00:31:27.620
Our goal is to analyze
this algorithm.

00:31:27.620 --> 00:31:29.050
What's the complexity of it?

00:31:33.760 --> 00:31:37.200
So does anyone understand
this recursion?

00:31:37.200 --> 00:31:41.400
Can someone tell me, what's
the recursion for this part,

00:31:41.400 --> 00:31:42.610
for this Strassen algorithm?

00:31:47.860 --> 00:31:56.780
We have the original
problem, and we have some--

00:31:56.780 --> 00:31:57.280
go ahead.

00:31:57.280 --> 00:32:00.703
AUDIENCE: So since each
of the M 1 through 7

00:32:00.703 --> 00:32:03.148
only require one
multiplication, you'll

00:32:03.148 --> 00:32:09.749
need to solve seven subproblems,
so 7T n over 2 plus O n

00:32:09.749 --> 00:32:11.630
squared.

00:32:11.630 --> 00:32:13.130
LING REN: That's
absolutely correct.

00:32:16.220 --> 00:32:18.040
Everyone gets this?

00:32:18.040 --> 00:32:22.730
So what Strassen did, is he
came up with the seven matrices.

00:32:22.730 --> 00:32:27.600
Each one requires only
one multiplication.

00:32:27.600 --> 00:32:31.340
So we have seven subproblems,
instead of eight,

00:32:31.340 --> 00:32:34.810
and that's going to give us
a benefit, an improvement.

00:32:38.290 --> 00:32:41.370
So the question now becomes,
how do I solve this recursion?

00:32:41.370 --> 00:32:44.000
Given this recursion, how
do I know its complexity?

00:32:44.000 --> 00:32:45.150
And same question there.

00:32:49.160 --> 00:32:50.368
Anyone want to give it a try?

00:32:54.200 --> 00:33:14.070
So that's going to be covered
in a third topic, which

00:33:14.070 --> 00:33:15.307
is Master Theorem.

00:33:21.770 --> 00:33:25.840
So Master Theorem
does exactly that.

00:33:25.840 --> 00:33:38.930
All it does is, given the
recursion, a and T of n

00:33:38.930 --> 00:33:47.130
over b, plus some
work for merging,

00:33:47.130 --> 00:33:51.700
where a and b are constants, it
directly tell you what T of n

00:33:51.700 --> 00:33:55.810
is, in some cases.

00:33:55.810 --> 00:33:59.640
So I'll first write the formula.

00:33:59.640 --> 00:34:01.990
Master Theorem actually
has three cases.

00:34:01.990 --> 00:34:07.440
The first case, fn,
is order n raised

00:34:07.440 --> 00:34:11.354
to c, where c is
less than log b of a.

00:34:11.354 --> 00:34:21.690
Then, Master Theorem says, it's
complexity is theta log b of a.

00:34:25.570 --> 00:34:37.335
Second case, fn is theta
nc log K, where c is,

00:34:37.335 --> 00:34:45.240
log b is equal to b of a,
then it's complexity is n

00:34:45.240 --> 00:34:50.024
raised to c log K plus 1 n.

00:34:50.024 --> 00:34:51.690
You don't necessarily
have to copy them,

00:34:51.690 --> 00:34:55.520
because you just
find them anywhere.

00:34:55.520 --> 00:34:58.160
And the third case,
you can imagine,

00:34:58.160 --> 00:35:03.205
it's the only remaining
case, which is, fn is large,

00:35:03.205 --> 00:35:10.085
it's omega n raised to c, where
c is greater than log b of a.

00:35:10.085 --> 00:35:13.845
Then, Master Theorem says,
its complexity, the complexity

00:35:13.845 --> 00:35:19.630
of Tn, is theta fn.

00:35:19.630 --> 00:35:23.810
So, intuitively, if fn
is not too much work,

00:35:23.810 --> 00:35:26.170
then it's basically
this recursion,

00:35:26.170 --> 00:35:27.800
what recursion gives you.

00:35:27.800 --> 00:35:33.330
If fn dominates, fn is
the biggest component,

00:35:33.330 --> 00:35:35.746
then Tn is, roughly,
on the order of fn,

00:35:35.746 --> 00:35:37.120
and there's a case
in the middle.

00:35:45.600 --> 00:35:48.000
Now, let's see why
that is the case.

00:35:48.000 --> 00:35:49.600
I'll only cover one case, here.

00:35:59.200 --> 00:36:01.200
So, again, we are going
to draw a recursion

00:36:01.200 --> 00:36:04.300
tree, because that is very
useful in all the recursion

00:36:04.300 --> 00:36:06.390
problems.

00:36:06.390 --> 00:36:10.556
So we start with a
problem of size n,

00:36:10.556 --> 00:36:14.080
and we break them into
problem size n over b.

00:36:22.560 --> 00:36:23.802
So on and so forth.

00:36:23.802 --> 00:36:25.260
What's the size of
this subproblem?

00:36:31.770 --> 00:36:36.500
So that recursion represents a
class of recursive algorithm.

00:36:36.500 --> 00:36:39.236
Every time it
breaks the problem,

00:36:39.236 --> 00:36:40.860
it reduced the problem
size by a factor

00:36:40.860 --> 00:36:43.015
of b, so what do I have here?

00:36:45.630 --> 00:36:46.404
Go ahead.

00:36:46.404 --> 00:36:48.180
AUDIENCE: [INAUDIBLE]

00:36:48.180 --> 00:36:52.510
LING REN: n over b squared.

00:36:52.510 --> 00:36:53.760
So on and so forth.

00:36:53.760 --> 00:36:59.640
So what is a, in this graph?

00:36:59.640 --> 00:37:01.950
AUDIENCE: 3.

00:37:01.950 --> 00:37:03.650
LING REN: 3, think so?

00:37:03.650 --> 00:37:04.322
3.

00:37:04.322 --> 00:37:08.490
a is just a branching
factor of this tree.

00:37:08.490 --> 00:37:09.980
I keep going.

00:37:09.980 --> 00:37:14.330
Finally, I will
reach my base case.

00:37:14.330 --> 00:37:19.060
So my next question is, after
how many levels of recursion

00:37:19.060 --> 00:37:22.340
will I reach a base
case of size 1?

00:37:31.498 --> 00:37:32.462
Go ahead.

00:37:32.462 --> 00:37:34.872
AUDIENCE: Log b of [INAUDIBLE]?

00:37:34.872 --> 00:37:35.890
LING REN: Log b of--

00:37:42.630 --> 00:37:48.730
OK, so, here is n over b, n
over b square, next one n over b

00:37:48.730 --> 00:37:50.630
cubic, so on and so forth.

00:37:50.630 --> 00:37:55.270
So, say, this last level it
Tth level, than the problems

00:37:55.270 --> 00:37:56.050
size is n over--

00:37:59.810 --> 00:38:08.510
we raise to T, and we want that
to be a constant, so what is T?

00:38:13.440 --> 00:38:15.420
AUDIENCE: Log b on n.

00:38:15.420 --> 00:38:20.276
LING REN: Log b of n.

00:38:20.276 --> 00:38:24.320
Now, this is the recursion
tree, and we have that fn

00:38:24.320 --> 00:38:26.350
among the emerging work to do.

00:38:26.350 --> 00:38:32.300
So, here, we have to do fn
work, to merge these a results

00:38:32.300 --> 00:38:36.940
to the solution
of our problem, n.

00:38:36.940 --> 00:38:42.040
Then, we have f- what's the
emerging work for this level,

00:38:42.040 --> 00:38:44.190
for this part of the tree?

00:38:47.160 --> 00:38:48.750
This is my problem size.

00:38:51.708 --> 00:38:54.670
AUDIENCE: [INAUDIBLE]

00:38:54.670 --> 00:38:55.890
LING REN: n over b, right.

00:38:55.890 --> 00:38:57.650
And we have a of them.

00:38:57.650 --> 00:39:01.590
OK, so on and so forth.

00:39:01.590 --> 00:39:05.920
So, then, we know what is Tn.

00:39:05.920 --> 00:39:09.260
Let's just enumerate all
the work we have to do.

00:39:09.260 --> 00:39:13.470
So on the first level,
we have to do fn.

00:39:13.470 --> 00:39:18.820
OK, on second level, af n of b--

00:39:18.820 --> 00:39:20.460
sorry, n over b.

00:39:20.460 --> 00:39:21.570
And what's the next level?

00:39:25.802 --> 00:39:27.010
We have how many subproblems?

00:39:30.080 --> 00:39:31.007
Speak louder.

00:39:31.007 --> 00:39:32.200
AUDIENCE: a squared.

00:39:32.200 --> 00:39:35.210
LING REN: a square
subproblems, and each of them

00:39:35.210 --> 00:39:43.570
is n over b squared.

00:39:43.570 --> 00:39:49.172
And, finally, I
reach my last level.

00:39:49.172 --> 00:39:54.300
They are all base cases, so
I have a raised to T of them,

00:39:54.300 --> 00:39:57.370
because I defined T to
be my depth of the tree.

00:39:57.370 --> 00:39:59.690
And each of them is T of 1.

00:40:02.630 --> 00:40:05.770
OK, so that's Tn.

00:40:05.770 --> 00:40:08.590
I'm not entirely happy
with this formula,

00:40:08.590 --> 00:40:11.850
because I have this
beautiful pattern, here,

00:40:11.850 --> 00:40:14.540
except for that last guy.

00:40:14.540 --> 00:40:19.910
It's add one a and divide
one b, blah, blah, blah.

00:40:19.910 --> 00:40:24.580
So I'm going to
change this T into f.

00:40:24.580 --> 00:40:26.570
Can I do that?

00:40:26.570 --> 00:40:28.610
Because it's [INAUDIBLE]
is the same, right?

00:40:28.610 --> 00:40:31.230
T1 is a constant,
f1 is also constant.

00:40:31.230 --> 00:40:41.140
Then, I get my beautiful
form, where it's a sum from i

00:40:41.140 --> 00:40:44.880
equals 0 to T.
What's in the sum?

00:40:50.226 --> 00:40:51.254
Go ahead.

00:40:51.254 --> 00:40:52.170
AUDIENCE: [INAUDIBLE].

00:40:55.086 --> 00:40:59.166
LING REN: a raised
to i, f of n over b1.

00:41:02.022 --> 00:41:03.190
Everyone gets that?

00:41:05.970 --> 00:41:10.080
Now, you can roughly see
why we have three cases.

00:41:10.080 --> 00:41:12.750
So let me deal with
the first case.

00:41:12.750 --> 00:41:21.177
The first case says, fn
is order n raised to c.

00:41:21.177 --> 00:41:22.010
What does that mean?

00:41:25.200 --> 00:41:30.940
It means this guy here
is sigma a raised to n,

00:41:30.940 --> 00:41:37.120
then this is what's
in my f raised to c.

00:41:37.120 --> 00:41:40.250
There should be order, here, but
everything has order before it,

00:41:40.250 --> 00:41:42.120
so I just omit that.

00:41:42.120 --> 00:41:46.310
So it actually
should be this, OK?

00:41:46.310 --> 00:41:50.890
So this, because n
raised to c is actually

00:41:50.890 --> 00:41:53.380
independent of the
sum, I can pull it out.

00:41:58.300 --> 00:42:00.640
And what am I left with?

00:42:07.940 --> 00:42:11.000
Is that correct?

00:42:11.000 --> 00:42:15.190
Now, this is a sum of
geometric sequence.

00:42:15.190 --> 00:42:17.480
We know how to
solve that, but we

00:42:17.480 --> 00:42:21.210
need to check whether this ratio
is greater or larger than 1,

00:42:21.210 --> 00:42:22.760
or if it's equal to 1.

00:42:22.760 --> 00:42:25.260
And what is this ratio?

00:42:25.260 --> 00:42:26.500
The case tells us.

00:42:26.500 --> 00:42:30.160
So c is less than log b of a.

00:42:30.160 --> 00:42:34.240
That means b raised
to c is less than b

00:42:34.240 --> 00:42:41.830
raised to this guy,
which is a, right?

00:42:41.830 --> 00:42:48.150
So we know our denominator
is smaller than or numerator.

00:42:48.150 --> 00:42:52.470
So this is an increasing
sequence, right?

00:42:52.470 --> 00:42:55.770
So what we have
is n raised to c,

00:42:55.770 --> 00:43:01.530
then that thing
raised to t minus 1

00:43:01.530 --> 00:43:04.030
divided by this thing minus 1.

00:43:04.030 --> 00:43:06.151
But they are all constants.

00:43:06.151 --> 00:43:09.250
Are everyone familiar
with this formula.

00:43:09.250 --> 00:43:12.350
of geometric sequence?

00:43:12.350 --> 00:43:14.140
OK, so that's what we have.

00:43:18.830 --> 00:43:23.480
Next, we have t
equals log b of n.

00:43:23.480 --> 00:43:33.120
That means b raised
to t is n, correct?

00:43:33.120 --> 00:43:37.770
So, then, b raised to t is
n, then we have raised to c,

00:43:37.770 --> 00:43:39.610
they cancel out.

00:43:39.610 --> 00:43:41.980
What do we have?

00:43:41.980 --> 00:43:44.020
I want to make sure
everyone's following.

00:43:52.146 --> 00:43:53.590
AUDIENCE: is it a over t?

00:43:53.590 --> 00:43:55.150
LING REN: A raised to t.

00:43:59.730 --> 00:44:00.650
No questions?

00:44:00.650 --> 00:44:02.570
AUDIENCE: Can you
do that stuff again?

00:44:02.570 --> 00:44:05.990
LING REN: OK, let
me do that again.

00:44:05.990 --> 00:44:09.340
It's actually a
raised to t, and then

00:44:09.340 --> 00:44:13.816
n over bt raised to c, right?

00:44:13.816 --> 00:44:15.940
AUDIENCE: How did you get
from the line above that?

00:44:15.940 --> 00:44:17.190
LING REN: This one to here?

00:44:17.190 --> 00:44:17.815
AUDIENCE: Yeah.

00:44:17.815 --> 00:44:20.100
LING REN: Oh, it's the
sum of geometric sequence,

00:44:20.100 --> 00:44:25.620
so if I have 1 plus q plus q
squared, all the way to qt,

00:44:25.620 --> 00:44:31.100
it's qt plus 1, I guess-- or
t, I don't remember very well--

00:44:31.100 --> 00:44:35.530
minus 1, then q minus 1.

00:44:35.530 --> 00:44:38.620
I guess this should be t plus 1.

00:44:38.620 --> 00:44:40.050
So this is what we're doing.

00:44:40.050 --> 00:44:43.635
So this is our q minus 1,
and divided by q minus 1,

00:44:43.635 --> 00:44:45.760
they are all constants, so
I don't care about them.

00:44:48.820 --> 00:44:52.430
So a raised plus this
thing raised to c,

00:44:52.430 --> 00:44:56.190
but we said that b raised
to t is equal to n,

00:44:56.190 --> 00:45:01.710
so we're just left
with a raised to t.

00:45:01.710 --> 00:45:06.700
And what is t?

00:45:06.700 --> 00:45:09.820
t is log b of n.

00:45:09.820 --> 00:45:17.820
I can write it as log
a of n over log a of b.

00:45:17.820 --> 00:45:20.260
Everyone familiar with that?

00:45:20.260 --> 00:45:27.279
That means log a
of n, log b of a.

00:45:27.279 --> 00:45:28.320
This is when I flip them.

00:45:31.660 --> 00:45:33.700
So this, what is that?

00:45:36.430 --> 00:45:37.547
AUDIENCE: n.

00:45:37.547 --> 00:45:38.380
LING REN: That is n.

00:45:42.930 --> 00:45:44.280
OK, we're done.

00:45:47.190 --> 00:45:48.160
Are we?

00:45:58.840 --> 00:46:01.820
Not exactly, because I
have an order here, right?

00:46:01.820 --> 00:46:04.260
So everything is ordered.

00:46:04.260 --> 00:46:07.620
If you only care about
order, big O, then it's fine.

00:46:07.620 --> 00:46:09.840
But that theorem
says theta, so you

00:46:09.840 --> 00:46:13.119
have to prove it the other way,
that it's no less than that.

00:46:13.119 --> 00:46:14.160
I'm not going to do that.

00:46:14.160 --> 00:46:16.970
It's not very hard.

00:46:16.970 --> 00:46:20.970
Next, I'm going to apply
this theorem to the two

00:46:20.970 --> 00:46:23.780
problems we left here.

00:46:23.780 --> 00:46:29.570
So let's apply Master
Theorem to this recurrence.

00:46:29.570 --> 00:46:31.623
I think you are still
looking at that side.

00:46:35.970 --> 00:46:39.260
So what is the a, b, c for this?

00:46:44.180 --> 00:46:47.700
a is 8, b is 2, right?

00:46:47.700 --> 00:46:53.150
And c is 2.

00:46:53.150 --> 00:46:59.945
Log b of a is 3, so that's which
case of the Master Theorem?

00:47:03.910 --> 00:47:06.410
So the theorem says
it should be n raised

00:47:06.410 --> 00:47:10.510
to log b of a, which is 3, OK?

00:47:13.550 --> 00:47:20.530
Now, what we have here,
can I remind someone

00:47:20.530 --> 00:47:21.353
to do that for me?

00:47:27.029 --> 00:47:28.070
Want to give it a try?

00:47:34.860 --> 00:47:37.300
Go ahead.

00:47:37.300 --> 00:47:45.660
AUDIENCE: OK, so we have
a equals 7, b equals 2,

00:47:45.660 --> 00:47:49.300
and c equals 2, like before.

00:47:49.300 --> 00:47:57.282
And, now, we want to see whether
c equals 2 is less than log b

00:47:57.282 --> 00:48:00.865
of a, which is log 2 of 7.

00:48:06.396 --> 00:48:08.140
Pretty sure that's
still the case.

00:48:08.140 --> 00:48:13.660
So we should just get
n to the log 2 of 7.

00:48:13.660 --> 00:48:15.180
LING REN: Yeah, exactly.

00:48:15.180 --> 00:48:16.384
So, yeah.

00:48:16.384 --> 00:48:18.550
Yeah, thank you. let's give
him a round of applause.

00:48:22.640 --> 00:48:26.480
So log 2 of 7 is
definitely greater than 2.

00:48:26.480 --> 00:48:27.070
Why?

00:48:27.070 --> 00:48:29.880
Because log 2 of 4 is 2, right?

00:48:29.880 --> 00:48:38.030
So this happens to be n raised
to 2.80, and many other digits,

00:48:38.030 --> 00:48:42.450
but it's less than n cubic.

00:48:42.450 --> 00:48:48.200
And, just for knowledge purpose,
this is no longer the best.

00:48:48.200 --> 00:48:50.300
It was the best,
when it was proposed,

00:48:50.300 --> 00:48:52.970
and, well, researchers
in that area

00:48:52.970 --> 00:48:56.590
have got it down to
n raised to 2.35.

00:48:56.590 --> 00:48:59.654
I think 2.37, first, then 2.35.

00:48:59.654 --> 00:49:01.570
I'm not following the
literature very closely,

00:49:01.570 --> 00:49:06.010
so maybe it's 2.34 now.

00:49:06.010 --> 00:49:08.575
So I should have one
more thing to cover,

00:49:08.575 --> 00:49:10.200
but I think we are
running out of time.

00:49:10.200 --> 00:49:11.340
Sorry about that.

00:49:11.340 --> 00:49:12.490
I can post it.

00:49:12.490 --> 00:49:15.490
So the last thing
we should do is,

00:49:15.490 --> 00:49:17.490
remember, we have this
medium finding algorithm,

00:49:17.490 --> 00:49:22.260
where we have a recurrence,
which is, I think,

00:49:22.260 --> 00:49:30.470
10 over 5, some ceiling, and
then plus this [INAUDIBLE]

00:49:30.470 --> 00:49:33.760
n plus theta n.

00:49:33.760 --> 00:49:38.780
And we want to solve
this recursion,

00:49:38.780 --> 00:49:41.180
but we cannot apply
Master Theorem.

00:49:41.180 --> 00:49:43.430
Apparently, it's
not the right form.

00:49:43.430 --> 00:49:45.340
So when Master
Theorem doesn't apply,

00:49:45.340 --> 00:49:47.389
we have to study
it case by case.

00:49:47.389 --> 00:49:48.930
Let me see if I have
time to do that.

00:49:54.970 --> 00:49:56.430
OK, I think I probably do.

00:50:01.640 --> 00:50:04.180
To solve that case,
first, can someone

00:50:04.180 --> 00:50:06.180
tell me, what's the
definition of theta?

00:50:06.180 --> 00:50:08.620
We have to go back to the
definition to solve that.

00:50:11.180 --> 00:50:12.720
What does theta even mean?

00:50:12.720 --> 00:50:18.140
So if I say fn is theta
n, what do I really mean?

00:50:21.764 --> 00:50:22.490
Go ahead.

00:50:22.490 --> 00:50:26.442
AUDIENCE: It's tightly bounded,
so you can move the [INAUDIBLE]

00:50:26.442 --> 00:50:27.930
to either side.

00:50:27.930 --> 00:50:33.470
LING REN: So it means I can
find some K1 and K2 such

00:50:33.470 --> 00:50:38.680
that this holds when n
gets sufficiently large.

00:50:38.680 --> 00:50:41.030
OK, so, now, we're
going to do induction.

00:50:49.490 --> 00:50:55.530
Assuming, for all the small
n less than capital N,

00:50:55.530 --> 00:51:00.360
my Tn is bounded by
this K2 and K1 thing.

00:51:03.360 --> 00:51:10.660
Then, my next step is, T of
this capital N would be bounded.

00:51:10.660 --> 00:51:12.885
I'll do the right side first.

00:51:12.885 --> 00:51:28.220
It will be bounded by
K2 n5 ceiling, plus K2.

00:51:28.220 --> 00:51:33.740
[INAUDIBLE] in a second
term, n plus another theta n.

00:51:33.740 --> 00:51:36.860
So, we know, that means it's
bounded by some other number.

00:51:36.860 --> 00:51:39.110
I'll say A2, then.

00:51:39.110 --> 00:51:41.910
That's the definition
of theta n.

00:51:41.910 --> 00:51:46.091
Then, I want this to be--

00:51:46.091 --> 00:51:47.590
sorry, all of them
should be capital

00:51:47.590 --> 00:51:52.340
N. Capital N, Capital N.
I want this to be smaller

00:51:52.340 --> 00:52:01.140
than K2 capital N.

00:52:01.140 --> 00:52:03.120
So let me redo this first step.

00:52:03.120 --> 00:52:15.930
This is roughly 5 of K2 plus
7 over 10 K2, plus A2 of n,

00:52:15.930 --> 00:52:18.910
plus a bunch of constants
that I don't care.

00:52:18.910 --> 00:52:24.321
I want it to be
smaller than K2 of n.

00:52:24.321 --> 00:52:25.640
Can I reach that?

00:52:25.640 --> 00:52:27.050
Of course I can, right?

00:52:27.050 --> 00:52:32.140
If I select a K2 to be
greater than all we have here,

00:52:32.140 --> 00:52:33.030
what is this?

00:52:33.030 --> 00:52:40.930
This is 9 over 10
K2 plus A2, right?

00:52:40.930 --> 00:52:47.910
So if I select the K2 to be
greater than 10 times A2--

00:52:50.986 --> 00:52:53.160
is everyone following that?

00:52:53.160 --> 00:52:59.020
When n is sufficiently large,
Tn should be bounded by A2 n.

00:53:01.700 --> 00:53:04.890
That's the induction.

00:53:04.890 --> 00:53:08.110
I am assuming, when n is
smaller than capital N,

00:53:08.110 --> 00:53:09.030
I have solved them.

00:53:09.030 --> 00:53:13.030
So I can use these two,
and I solve the next step.

00:53:13.030 --> 00:53:15.400
So there's the other side,
which is very similar.

00:53:15.400 --> 00:53:18.640
I'm not going to
go through that.

00:53:18.640 --> 00:53:22.760
All right, so that's
all for today.

00:53:22.760 --> 00:53:25.320
And just to quickly
recap, we went

00:53:25.320 --> 00:53:30.450
through the weighted
interval scheduling,

00:53:30.450 --> 00:53:33.240
and the Strassen algorithm,
Master Theorem and applying

00:53:33.240 --> 00:53:39.350
Master Theorem, and that case
study of a new recursion.

00:53:39.350 --> 00:53:42.210
OK, thanks,
everyone, for coming.

