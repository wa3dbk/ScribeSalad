WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high quality
educational resources for free.

00:00:10.730 --> 00:00:13.340
To make a donation or
view additional materials

00:00:13.340 --> 00:00:17.236
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.236 --> 00:00:17.861
at ocw.mit.edu.

00:00:21.280 --> 00:00:23.450
AMARTYA SHANKHA
BISWAS: So today, we're

00:00:23.450 --> 00:00:26.100
going to look at approximation
algorithms for the traveling

00:00:26.100 --> 00:00:27.670
salesman problem.

00:00:27.670 --> 00:00:30.290
So I hope everyone knows
what the traveling salesman

00:00:30.290 --> 00:00:30.850
problem is.

00:00:30.850 --> 00:00:34.947
You have a graph, you're
trying to visit every vertex.

00:00:34.947 --> 00:00:37.280
So you start at your vertex,
you visit every single one,

00:00:37.280 --> 00:00:39.090
and you end at the
starting vertex.

00:00:39.090 --> 00:00:41.760
And you want to do that in
the shortest possible time,

00:00:41.760 --> 00:00:43.990
or distance, or
whatever the metric is.

00:00:43.990 --> 00:00:46.840
So, unfortunately,
this is NP-hard.

00:00:46.840 --> 00:00:48.520
Also, the approximation
algorithms

00:00:48.520 --> 00:00:51.312
for any constant approximation
is also known to be NP-hard.

00:00:51.312 --> 00:00:53.520
So you should have gone over
approximation algorithms

00:00:53.520 --> 00:00:54.120
in lectures.

00:00:54.120 --> 00:00:57.370
So, basically, let's say
the optimal solution has

00:00:57.370 --> 00:01:00.747
some value of e, and if
you want to guarantee

00:01:00.747 --> 00:01:02.830
that your algorithm will
end up with a value which

00:01:02.830 --> 00:01:05.990
is within a constant factor
of v, so less than cv,

00:01:05.990 --> 00:01:07.570
that is an
approximation algorithm.

00:01:07.570 --> 00:01:09.520
But for the traveling
salesman problem,

00:01:09.520 --> 00:01:13.190
the constant approximation
algorithms are also NP-hard.

00:01:13.190 --> 00:01:16.200
So instead, we
modify it slightly.

00:01:16.200 --> 00:01:17.870
So, on the traveling
salesman problem,

00:01:17.870 --> 00:01:19.680
we impose something
called a metric.

00:01:19.680 --> 00:01:22.714
So the important relation
here is this one.

00:01:22.714 --> 00:01:24.380
So, first of all,
let's go through this.

00:01:24.380 --> 00:01:28.410
So you have a distance metric
for-- so xy are vertices.

00:01:28.410 --> 00:01:31.210
Your distance is always greater
than 0, which is reasonable.

00:01:31.210 --> 00:01:33.569
You're undirected,
which is this relation.

00:01:33.569 --> 00:01:35.110
And you have the
triangle inequality,

00:01:35.110 --> 00:01:39.350
which means that if
you have 3 vertices,

00:01:39.350 --> 00:01:43.740
and you have distance like
this, this distance is always

00:01:43.740 --> 00:01:46.210
smaller than the sum of
these two distances, which

00:01:46.210 --> 00:01:49.300
is like real world-ish things
that make sense, right?

00:01:49.300 --> 00:01:51.050
If this distance was
longer, it would just

00:01:51.050 --> 00:01:52.370
take this path instead.

00:01:52.370 --> 00:01:55.230
So the distance by
taking other node

00:01:55.230 --> 00:01:58.790
is always greater than or
equal to the direct distance.

00:01:58.790 --> 00:02:03.560
So, turns out, the Metric
TSP problem is also NP-hard.

00:02:03.560 --> 00:02:07.420
So nothing very
great there, but you

00:02:07.420 --> 00:02:09.262
can do a constant
approximation here.

00:02:09.262 --> 00:02:11.220
And you'll go through
two approximations today.

00:02:11.220 --> 00:02:17.720
The first, the simpler
one, is a 2 approximation,

00:02:17.720 --> 00:02:21.270
and then, we'll
improve this to 3/2.

00:02:21.270 --> 00:02:24.460
So let's start
with the first one.

00:02:24.460 --> 00:02:28.650
So before we begin, let's
define a couple of terms.

00:02:28.650 --> 00:02:34.580
Let's define c of
S. So what is S?

00:02:34.580 --> 00:02:37.130
Let X be a path.

00:02:37.130 --> 00:02:41.250
Or, rather, let's say
S is a set of edges.

00:02:47.240 --> 00:02:53.770
So if you have your graph,
here, your set of edges

00:02:53.770 --> 00:02:56.790
could be something like
this, this, this, this.

00:02:56.790 --> 00:02:58.260
So that's set of edges.

00:02:58.260 --> 00:03:03.140
And c of S is defined as the
sum of the weights of all

00:03:03.140 --> 00:03:04.190
the edges.

00:03:04.190 --> 00:03:06.220
And this, actually,
should be a multiset,

00:03:06.220 --> 00:03:08.640
because you can count
the same edge twice.

00:03:08.640 --> 00:03:10.660
So you can count this
edge three times, or how

00:03:10.660 --> 00:03:12.010
ever many times you want.

00:03:12.010 --> 00:03:13.580
So that's the definition.

00:03:13.580 --> 00:03:19.030
So, now, we want to
find a cycle which

00:03:19.030 --> 00:03:20.860
goes through all
the vertices, and we

00:03:20.860 --> 00:03:23.420
want to minimize the
cost of that cycle.

00:03:23.420 --> 00:03:25.504
So let's say your optimal--
this should remind you

00:03:25.504 --> 00:03:26.878
of the Hamiltonian
Cycle problem.

00:03:26.878 --> 00:03:29.410
So this is, essentially,
finding a Hamiltonian cycle

00:03:29.410 --> 00:03:31.490
in the graph of minimum weight.

00:03:31.490 --> 00:03:33.770
So this is worse than the
Hamiltonian cycle problem.

00:03:33.770 --> 00:03:37.370
This is find the minimum
weight Hamiltonian cycle.

00:03:37.370 --> 00:03:42.280
So let's say there exists this
beautiful Hamiltonian cycle.

00:03:42.280 --> 00:03:44.000
You know of minimum weight.

00:03:44.000 --> 00:03:46.792
Let's call that
H star G. So it's

00:03:46.792 --> 00:03:48.500
the best Hamiltonian
cycle on this graph,

00:03:48.500 --> 00:03:50.875
and that's the shortest path
that your traveling salesman

00:03:50.875 --> 00:03:51.420
can take.

00:03:51.420 --> 00:03:57.030
And so the cost of that is
[INAUDIBLE] if H star S G.

00:03:57.030 --> 00:04:01.280
So how do we go about trying
to approximate this problem?

00:04:01.280 --> 00:04:03.720
So think about what
algorithms you've

00:04:03.720 --> 00:04:08.590
seen that sort of connect
all the vertices of a graph,

00:04:08.590 --> 00:04:11.650
and minimize costs of edges.

00:04:11.650 --> 00:04:14.360
Does it remind you of
anything polynomial

00:04:14.360 --> 00:04:17.040
that you've seen in the class,
that connects all the vertices?

00:04:20.784 --> 00:04:23.340
Expands all the vertices?

00:04:23.340 --> 00:04:23.840
Exactly.

00:04:23.840 --> 00:04:25.423
So [INAUDIBLE],
minimum spanning tree.

00:04:25.423 --> 00:04:27.350
This minimum spanning
tree is polynomial time,

00:04:27.350 --> 00:04:28.641
and it connects all the vertex.

00:04:28.641 --> 00:04:29.780
So let's take some graph.

00:04:29.780 --> 00:04:32.290
Let's just go with this one.

00:04:32.290 --> 00:04:37.550
So you have some vertices,
and you make a minimum

00:04:37.550 --> 00:04:40.480
spanning tree out of them.

00:04:40.480 --> 00:04:42.950
Now, clearly, this
is not a cycle yet.

00:04:42.950 --> 00:04:45.740
But let's try to
construct a path out

00:04:45.740 --> 00:04:48.290
of this minimum spanning tree.

00:04:48.290 --> 00:04:50.510
So, first, let's root it.

00:04:50.510 --> 00:04:54.490
So let's say we are rooted
minimum spanning tree.

00:04:54.490 --> 00:04:56.014
Let's say this is the root.

00:04:56.014 --> 00:05:00.660
So you have three things
going out of there.

00:05:00.660 --> 00:05:02.540
I think that's it.

00:05:02.540 --> 00:05:04.360
So let's give these labels.

00:05:11.150 --> 00:05:12.640
So, now, what we're
going to do is,

00:05:12.640 --> 00:05:15.080
the way we're going to
traverse all the vertices,

00:05:15.080 --> 00:05:16.724
let's just do a DFS.

00:05:16.724 --> 00:05:18.140
So, in DFS traversal,
you'll first

00:05:18.140 --> 00:05:21.932
see 1, then you'll
go down and see 2,

00:05:21.932 --> 00:05:25.630
then you'll go down and see
3, then you'll go back up,

00:05:25.630 --> 00:05:27.260
see 2 again.

00:05:27.260 --> 00:05:29.290
Go back down, see 4.

00:05:29.290 --> 00:05:30.690
Go back up, see 2.

00:05:30.690 --> 00:05:34.630
1, 5, 1, 6.

00:05:34.630 --> 00:05:37.230
So, basically, you're ignoring
the rest of the graph.

00:05:37.230 --> 00:05:39.000
You find your minimum
spanning tree,

00:05:39.000 --> 00:05:40.530
and you follow all the paths.

00:05:40.530 --> 00:05:43.940
Follow them back up, and
just do a DFS traversal.

00:05:43.940 --> 00:05:46.280
And then, you go
reach back to 1.

00:05:46.280 --> 00:05:48.800
And then, you have this-- well,
it visits all the vertices.

00:05:48.800 --> 00:05:49.800
It visits some of
them more than once,

00:05:49.800 --> 00:05:52.180
which is a problem, which
we'll deal with shortly.

00:05:52.180 --> 00:05:55.432
But it visits all the
vertices, and it's a cycle.

00:05:55.432 --> 00:05:57.390
So, now, the problem is,
the traveling salesman

00:05:57.390 --> 00:06:00.390
problem does not allow you to
visit vertices more than once.

00:06:00.390 --> 00:06:03.290
Because, if you did not
have this restriction,

00:06:03.290 --> 00:06:04.810
you could shorten
your bat length

00:06:04.810 --> 00:06:07.042
by going to a separate
vertex and coming back,

00:06:07.042 --> 00:06:08.000
or something like that.

00:06:08.000 --> 00:06:10.430
So let's make that
more concrete.

00:06:10.430 --> 00:06:13.680
So, at least in this case,
given this triangle inequality,

00:06:13.680 --> 00:06:17.320
I claim that you can just
delete the duplicate vertices.

00:06:17.320 --> 00:06:18.820
So let's look at
the duplicate ones.

00:06:18.820 --> 00:06:20.850
You have 1, 2, 3, this repeats.

00:06:20.850 --> 00:06:22.420
So you delete that.

00:06:22.420 --> 00:06:27.140
Repeats, repeats, repeats,
and that's cycling back.

00:06:27.140 --> 00:06:28.670
So how do you delete things?

00:06:28.670 --> 00:06:30.336
So, in this case, you
had a path, right?

00:06:30.336 --> 00:06:37.780
You were going 1 to 2, and
2 to 3, to 2, and so on.

00:06:37.780 --> 00:06:39.360
Let's write the 4 in.

00:06:39.360 --> 00:06:42.532
So this is [INAUDIBLE]
only at tree edges.

00:06:42.532 --> 00:06:43.740
So how would you delete this?

00:06:43.740 --> 00:06:45.870
So, let's say, you find
the first duplicate vertex,

00:06:45.870 --> 00:06:46.440
and you don't want that.

00:06:46.440 --> 00:06:47.274
That's not allowed.

00:06:47.274 --> 00:06:49.190
So all you do is, simply,
you follow the path,

00:06:49.190 --> 00:06:50.770
and you bypass it.

00:06:50.770 --> 00:06:53.450
And by the triangle inequality,
you know that bypassing it

00:06:53.450 --> 00:06:55.860
will never increase your cost.

00:06:55.860 --> 00:06:58.530
It'll decrease it, or it
will keep it the same.

00:06:58.530 --> 00:07:01.045
So you can remove the
duplicate vertex in this path

00:07:01.045 --> 00:07:01.920
just by bypassing it.

00:07:01.920 --> 00:07:04.003
But, also, remember that
this is a complete graph.

00:07:04.003 --> 00:07:06.320
So the metric is defined
on all pairs of vertices.

00:07:06.320 --> 00:07:09.217
So every edge exists
with some value.

00:07:09.217 --> 00:07:11.300
So that also follows with
the triangle inequality.

00:07:11.300 --> 00:07:12.980
So if an edge does
not exist, just

00:07:12.980 --> 00:07:15.950
make it the sum of the--
so if xz is not an edge,

00:07:15.950 --> 00:07:18.785
just make it the
sum of xy plus yz.

00:07:18.785 --> 00:07:23.270
So in any case, you construct
the initial path just

00:07:23.270 --> 00:07:26.810
by going down the tree and
doing a naive DFS traversal.

00:07:26.810 --> 00:07:30.140
And, then, you correct
that path by skipping

00:07:30.140 --> 00:07:32.391
over the duplicates.

00:07:32.391 --> 00:07:34.140
So, finally, we'll end
up with [INAUDIBLE]

00:07:34.140 --> 00:07:36.514
skipping all the duplicates
we'll get a 1, 2, 3, 4, 5, 6,

00:07:36.514 --> 00:07:37.460
1.

00:07:37.460 --> 00:07:40.140
And that's a valid cycle.

00:07:40.140 --> 00:07:42.510
So let's call this
minimum spanning tree

00:07:42.510 --> 00:07:45.150
T. So that's your MST.

00:07:47.760 --> 00:07:54.370
And you are removing duplicate
edges, and getting a cycle, C.

00:07:54.370 --> 00:08:00.600
So now, actually, let's
take another step back.

00:08:00.600 --> 00:08:07.110
OK, let's define
our cycle, first.

00:08:07.110 --> 00:08:10.880
So let's call this
cycle, this guy

00:08:10.880 --> 00:08:16.870
is C. And then,
you're going from C,

00:08:16.870 --> 00:08:18.720
and you're deleting
the duplicates,

00:08:18.720 --> 00:08:21.580
and you're getting C dash.

00:08:21.580 --> 00:08:27.240
So now what you have
is cost of C dash.

00:08:27.240 --> 00:08:29.870
That's a [INAUDIBLE],
but anyway.

00:08:29.870 --> 00:08:33.590
The cost of C dash is less
than equal to cost of C.

00:08:33.590 --> 00:08:36.169
And what is the cost of C?

00:08:36.169 --> 00:08:38.929
If you know the weight of
your minimum spanning tree,

00:08:38.929 --> 00:08:40.049
what is the cost of C?

00:08:40.049 --> 00:08:42.770
C is just doing a [INAUDIBLE]
of this traversal.

00:08:42.770 --> 00:08:46.550
So what is the cost
of C, if you know

00:08:46.550 --> 00:08:48.854
your minimum spanning tree?

00:08:48.854 --> 00:08:50.665
STUDENT: [INAUDIBLE]

00:08:50.665 --> 00:08:51.790
AMARTYA SHANKHA BISWAS: No.

00:08:51.790 --> 00:08:54.290
So you're traversing every edge
in the minimum spanning tree

00:08:54.290 --> 00:08:54.910
twice.

00:08:54.910 --> 00:08:56.310
So you're doing a
DFS traversal, right?

00:08:56.310 --> 00:08:58.040
So you're going down, and
you're coming back up.

00:08:58.040 --> 00:09:00.164
So you're going down, coming
back up, backtracking,

00:09:00.164 --> 00:09:00.940
coming back down.

00:09:00.940 --> 00:09:02.356
So every edge is
traversed, right?

00:09:02.356 --> 00:09:04.290
So it's exactly twice T.

00:09:04.290 --> 00:09:06.010
So let's bring up
a different board.

00:09:09.010 --> 00:09:13.800
So you know that
cost of C is twice

00:09:13.800 --> 00:09:17.030
the cost of T. Does
that make sense,

00:09:17.030 --> 00:09:20.130
why the traversal implies
that you have every edge being

00:09:20.130 --> 00:09:22.180
visited twice, right?

00:09:22.180 --> 00:09:22.920
OK.

00:09:22.920 --> 00:09:29.580
So, now, our claim is that the C
dash cycle is a 2 approximation

00:09:29.580 --> 00:09:31.386
of the actual cycle.

00:09:31.386 --> 00:09:32.010
So why is that?

00:09:32.010 --> 00:09:33.990
So we've already
[INAUDIBLE], so this also

00:09:33.990 --> 00:09:41.560
implies that C of C dash is less
than equal to 2 of C T. Realize

00:09:41.560 --> 00:09:46.310
that this is not a valid cycle,
but this is a valid cycle.

00:09:46.310 --> 00:09:49.340
So, now, we need to show
that this is somehow

00:09:49.340 --> 00:09:52.982
bounded by a star G.
So how do you do that?

00:09:52.982 --> 00:09:54.690
Well, look at H star
G. What is H star G?

00:09:54.690 --> 00:09:57.790
H star G is just a cycle, which
goes through the optimal cycle,

00:09:57.790 --> 00:09:59.320
which goes through
all the vertices

00:09:59.320 --> 00:10:02.830
and comes back to
the parent vertex.

00:10:02.830 --> 00:10:07.290
So this is H star of G.
This is the optimal thing.

00:10:07.290 --> 00:10:11.040
Now, you can take an edge,
e, here, and delete it.

00:10:11.040 --> 00:10:14.450
And then you'll get
a spanning tree,

00:10:14.450 --> 00:10:16.410
because this is
your optimal cycle.

00:10:16.410 --> 00:10:18.960
Remove one edge, and
you get a spanning tree.

00:10:18.960 --> 00:10:21.710
So let's call that T dash.

00:10:28.167 --> 00:10:30.250
Does that make sense, why
that is a spanning tree?

00:10:30.250 --> 00:10:32.291
Because you had a cycle,
and you remove one edge,

00:10:32.291 --> 00:10:35.299
so it touches all the
vertices, and it's a tree.

00:10:35.299 --> 00:10:36.840
So it's a spanning
tree, but it's not

00:10:36.840 --> 00:10:38.370
the minimum spanning tree.

00:10:38.370 --> 00:10:47.110
So you know that H star G,
the cost of H star of G,

00:10:47.110 --> 00:10:51.250
is greater than equal
to the cost of H

00:10:51.250 --> 00:10:55.720
star of G minus the
edge we removed,

00:10:55.720 --> 00:11:01.120
is greater than equal to
the cost of T. Make sense?

00:11:01.120 --> 00:11:03.930
So you remove one
edge, and then that

00:11:03.930 --> 00:11:07.110
is still greater than the
minimum spanning tree.

00:11:07.110 --> 00:11:13.010
So, now, combining
this guy and this guy,

00:11:13.010 --> 00:11:15.626
you get cost of C dash is less
than equal to 2 [INAUDIBLE].

00:11:15.626 --> 00:11:17.750
We know that cost of C is
less than cost of H of G,

00:11:17.750 --> 00:11:18.958
so you get a 2-approximation.

00:11:32.088 --> 00:11:33.510
So does that make sense?

00:11:37.945 --> 00:11:39.195
So that was a 2-approximation.

00:11:39.195 --> 00:11:40.861
That was pretty
straightforward, We just

00:11:40.861 --> 00:11:42.300
constructed a spanning tree.

00:11:42.300 --> 00:11:44.480
You did a DFS traversal
and removed duplicates,

00:11:44.480 --> 00:11:47.280
and you have a nice path.

00:11:47.280 --> 00:11:49.736
OK, let's just keep it down.

00:11:49.736 --> 00:11:50.680
But here's the thing.

00:11:50.680 --> 00:11:53.142
It seems kind of wasteful
to go through all the edges

00:11:53.142 --> 00:11:54.100
when you don't need to.

00:11:54.100 --> 00:11:57.620
So you're traveling down the
tree, you're going back up,

00:11:57.620 --> 00:11:59.690
and you're traversing
every edge twice.

00:11:59.690 --> 00:12:01.564
So it seems kind of
ridiculous that you would

00:12:01.564 --> 00:12:03.220
be doing every edge twice.

00:12:03.220 --> 00:12:05.130
So what could you do better?

00:12:05.130 --> 00:12:11.130
Well, before we introduce that,
let's prove a couple of lemmas.

00:12:11.130 --> 00:12:16.230
So, first, we started with this.

00:12:16.230 --> 00:12:22.320
So let's say S is a subset
of V. So you have a graph,

00:12:22.320 --> 00:12:25.290
and you make a subgraph.

00:12:25.290 --> 00:12:27.632
So you pick out some vertices.

00:12:27.632 --> 00:12:29.840
So you pick out this one,
and this one, and this one,

00:12:29.840 --> 00:12:32.940
and this one, and
that is your S.

00:12:32.940 --> 00:12:35.920
And, so, you get
a new graph which

00:12:35.920 --> 00:12:38.310
contains just those vertices.

00:12:38.310 --> 00:12:42.430
And, whatever, I
just connect them.

00:12:42.430 --> 00:12:44.340
So the claim is
that that graph also

00:12:44.340 --> 00:12:47.050
has a Hamiltonian cycle,
the minimum cost Hamiltonian

00:12:47.050 --> 00:12:50.380
cycle, which is also the
traveling salesman solution.

00:12:50.380 --> 00:12:57.160
So let's call that H star of
S. So it's some cycle, which

00:12:57.160 --> 00:12:59.890
looks like this, I guess, here.

00:12:59.890 --> 00:13:06.590
So H star of S. Now, the claim
is that the cost of H star of S

00:13:06.590 --> 00:13:11.476
is less than equal to
the cost of H star of G.

00:13:11.476 --> 00:13:12.850
That should make
intuitive sense,

00:13:12.850 --> 00:13:14.808
because you're taking
only some of the vertices

00:13:14.808 --> 00:13:17.739
and trying to traverse
them, and, in this case,

00:13:17.739 --> 00:13:19.405
you'll try to traverse
all the vertices.

00:13:19.405 --> 00:13:21.890
However, this is only true
because of the triangle

00:13:21.890 --> 00:13:24.800
inequality, and let's
see why that is the case.

00:13:24.800 --> 00:13:29.470
So, proof by contradiction.

00:13:29.470 --> 00:13:36.740
Say cost of H star of
S is actually greater

00:13:36.740 --> 00:13:44.890
than cost of H star of G.
OK, so, look at H star of G.

00:13:44.890 --> 00:13:45.919
It's a cycle, right?

00:13:45.919 --> 00:13:46.835
So you have something.

00:13:49.350 --> 00:13:50.890
Your cycle.

00:13:50.890 --> 00:13:55.060
And, in this cycle, you
have all the vertices of S.

00:13:55.060 --> 00:13:55.870
So pick them out.

00:13:59.810 --> 00:14:03.520
And, now, you have
a cycle which has

00:14:03.520 --> 00:14:05.310
cost less than the
optimal cycle in S,

00:14:05.310 --> 00:14:07.800
but it contains all the vertices
in S. So what you can do

00:14:07.800 --> 00:14:11.479
is, now you can use the
skipping lemma from before.

00:14:11.479 --> 00:14:13.520
So, last time, we didn't
move duplicate vertices.

00:14:13.520 --> 00:14:15.603
But, this time, what you'll
do is, instead, you'll

00:14:15.603 --> 00:14:19.220
just skip over this vertex.

00:14:19.220 --> 00:14:20.930
We'll skip over this vertex.

00:14:20.930 --> 00:14:23.720
And so, every vertex that's
not an S, skip over it.

00:14:23.720 --> 00:14:26.260
And that can only
decrease the cost.

00:14:26.260 --> 00:14:28.464
So, now, you've constructed
another cycle, which

00:14:28.464 --> 00:14:30.130
contains only the
vertices of S. So it's

00:14:30.130 --> 00:14:33.480
a Hamiltonian cycle for S, but
it has cost less than equal

00:14:33.480 --> 00:14:38.090
to H star of G, which means
that this can never be true.

00:14:38.090 --> 00:14:40.750
So the important fact
is, there, that if you

00:14:40.750 --> 00:14:47.390
have a subset of vertices
making the restricted graph,

00:14:47.390 --> 00:14:49.370
the cost of the minimum
Hamiltonian cycle

00:14:49.370 --> 00:14:52.370
is always less than equal to
the one in the original graph.

00:14:52.370 --> 00:14:55.190
So, intuitively, that
should make sense.

00:14:55.190 --> 00:14:58.280
OK, next thing is
something which

00:14:58.280 --> 00:15:02.260
might seem unfamiliar right
now, perfect matchings.

00:15:10.360 --> 00:15:13.170
So you've seen perfect
matchings in the content

00:15:13.170 --> 00:15:14.500
of bipartite graphs, right?

00:15:14.500 --> 00:15:16.560
So you find the minimum
cost perfect matching.

00:15:16.560 --> 00:15:18.770
You do this flow thing,
you send all the flow in,

00:15:18.770 --> 00:15:21.020
and then you connect the
vertices with the capacities,

00:15:21.020 --> 00:15:22.400
and whatever.

00:15:22.400 --> 00:15:26.354
So, it turns out,
in a complete graph,

00:15:26.354 --> 00:15:27.770
you can still do
perfect matching.

00:15:27.770 --> 00:15:29.890
So perfect matching is, you have
a bunch of-- so, let's say, you

00:15:29.890 --> 00:15:30.920
need to have an even
number of vertices,

00:15:30.920 --> 00:15:32.860
right, until we have
perfect matching.

00:15:32.860 --> 00:15:35.885
So, let's say, you
have these varieties.

00:15:35.885 --> 00:15:37.880
So this is a perfect matching.

00:15:37.880 --> 00:15:40.790
So every vertex has one edge
coming out of it, exactly one

00:15:40.790 --> 00:15:41.707
edge coming out of it.

00:15:41.707 --> 00:15:43.748
And it needs to be even,
because, otherwise, that

00:15:43.748 --> 00:15:44.490
doesn't work out.

00:15:44.490 --> 00:15:46.490
So that's perfect matching,
and the minimum cost

00:15:46.490 --> 00:15:48.912
perfect matching is the
minimum among all such things.

00:15:48.912 --> 00:15:50.495
And you did this for
bivariate graphs.

00:15:50.495 --> 00:15:52.526
It's finite
[INAUDIBLE] networks.

00:15:52.526 --> 00:15:54.650
So I'm not going to go into
the algorithm for this.

00:15:54.650 --> 00:15:57.360
It's kind of complicated, but
it uses linear programming,

00:15:57.360 --> 00:15:59.780
and you can find this
for a complete graph,

00:15:59.780 --> 00:16:02.280
and it's polynomial,
so that's good.

00:16:02.280 --> 00:16:06.520
So, given a complete graph, you
can find the perfect matching.

00:16:06.520 --> 00:16:07.987
[INAUDIBLE] for now.

00:16:07.987 --> 00:16:16.960
OK, one last thing we want to
introduce is Euler circuits.

00:16:16.960 --> 00:16:20.037
So who has heard of
Euler circuits before?

00:16:20.037 --> 00:16:20.536
Anyone?

00:16:20.536 --> 00:16:21.503
Sort of?

00:16:21.503 --> 00:16:22.002
OK.

00:16:34.150 --> 00:16:36.810
So the reason we
are-- so, OK, let's

00:16:36.810 --> 00:16:38.550
go back to what we did before.

00:16:38.550 --> 00:16:42.770
We had a tree, and the best
way we found to traverse it

00:16:42.770 --> 00:16:45.100
was just going down, and
going back up, and going down,

00:16:45.100 --> 00:16:46.430
and terribly messy.

00:16:46.430 --> 00:16:48.460
So what we would,
rather, want to do,

00:16:48.460 --> 00:16:52.896
is sort of traverse the thing
without repeating edges.

00:16:52.896 --> 00:16:54.270
So, I don't know,
you've probably

00:16:54.270 --> 00:16:55.270
seen this puzzle before.

00:16:55.270 --> 00:16:58.240
So you have this
graph given to you,

00:16:58.240 --> 00:17:02.380
and the task is to draw
this graph without lifting

00:17:02.380 --> 00:17:04.630
your pen off the paper.

00:17:04.630 --> 00:17:06.240
So first, for example,
in this graph,

00:17:06.240 --> 00:17:09.269
you could start here,
go here, go here,

00:17:09.269 --> 00:17:13.290
and come back, and
something, and there you got.

00:17:13.290 --> 00:17:15.390
So you can do that.

00:17:15.390 --> 00:17:19.980
But if you add on another
lobe, here, then you

00:17:19.980 --> 00:17:21.009
can't make a circuit.

00:17:21.009 --> 00:17:22.550
You can still make
a path, I believe.

00:17:22.550 --> 00:17:25.280
If you add another one,
you can't even make a path.

00:17:25.280 --> 00:17:27.339
So how does this work?

00:17:27.339 --> 00:17:27.960
Let's see.

00:17:27.960 --> 00:17:33.980
So, let's say, forget
about the graph, for now.

00:17:33.980 --> 00:17:35.230
Let's say you're just drawing.

00:17:35.230 --> 00:17:36.750
So you start somewhere.

00:17:36.750 --> 00:17:37.980
You go to a vertex.

00:17:37.980 --> 00:17:39.530
You go to another vertex.

00:17:39.530 --> 00:17:42.766
Come back, go to this
vertex, leave it.

00:17:42.766 --> 00:17:46.960
And so, observe that, whenever
you're making this drawing,

00:17:46.960 --> 00:17:49.510
you go to a vertex,
and you leave it.

00:17:49.510 --> 00:17:52.340
Every time you hit a
vertex, you leave it.

00:17:52.340 --> 00:17:54.600
Since there's the circuit,
you just loop around,

00:17:54.600 --> 00:17:56.016
and every time you
enter a vertex,

00:17:56.016 --> 00:17:57.480
you'll have to leave it.

00:17:57.480 --> 00:18:00.450
What that means is that,
even though this is not

00:18:00.450 --> 00:18:03.420
directed, if you drew out the
actual path, you would see,

00:18:03.420 --> 00:18:06.020
the number of edges
going into a vertex

00:18:06.020 --> 00:18:07.520
is equal the number
of ones leaving,

00:18:07.520 --> 00:18:11.280
which means that every
degree has to be even.

00:18:11.280 --> 00:18:15.521
So if you go and look at this
graph, which is that of lobes,

00:18:15.521 --> 00:18:16.520
this degree is not even.

00:18:16.520 --> 00:18:18.860
Neither is this, neither
is this, neither is this.

00:18:18.860 --> 00:18:20.374
They're all 5, I think, yeah.

00:18:20.374 --> 00:18:22.610
They're all 5, which
means that this can never

00:18:22.610 --> 00:18:23.950
have an Euler circuit.

00:18:23.950 --> 00:18:26.290
So a graph can only
have an Euler circuit

00:18:26.290 --> 00:18:30.460
if it has even degrees
for every vertex.

00:18:30.460 --> 00:18:31.867
And the other way is also true.

00:18:31.867 --> 00:18:33.700
If a graph has even
degrees on every vertex,

00:18:33.700 --> 00:18:35.158
then it must have
an Euler circuit.

00:18:35.158 --> 00:18:36.780
That's not hard to
prove, but there's

00:18:36.780 --> 00:18:38.362
a constructive
algorithm you can use.

00:18:38.362 --> 00:18:40.570
So, let's say, you're given
this graph, for instance.

00:18:40.570 --> 00:18:43.530
You would simply
go to the graph,

00:18:43.530 --> 00:18:47.130
just start at some random
node, and then go through,

00:18:47.130 --> 00:18:48.901
and keep following
edges until you

00:18:48.901 --> 00:18:50.150
can no longer following edges.

00:18:50.150 --> 00:18:51.820
So, let's say, you stop here.

00:18:51.820 --> 00:18:54.450
Then, you pick another
edge, and start, and so on.

00:18:54.450 --> 00:18:57.530
And, then, you can splice these
cycles together at some point.

00:18:57.530 --> 00:18:59.170
So it's kind of a
[INAUDIBLE] argument,

00:18:59.170 --> 00:19:01.540
but it should be
sort of intuitive

00:19:01.540 --> 00:19:05.220
why you can construct another
path, given an even degree.

00:19:05.220 --> 00:19:06.520
You just perform searches.

00:19:06.520 --> 00:19:09.140
You just create cycles, and
you splice them together.

00:19:09.140 --> 00:19:10.560
But, for now, just
take it as fact

00:19:10.560 --> 00:19:13.590
that a graph is
an Euler circuit,

00:19:13.590 --> 00:19:16.060
as in you can draw it
without lifting your pen off,

00:19:16.060 --> 00:19:19.630
if, and only if, every
vertex has even degree,

00:19:19.630 --> 00:19:21.040
so why is that interesting?

00:19:21.040 --> 00:19:23.910
So, let's say, we could
add some edges to our tree

00:19:23.910 --> 00:19:26.431
and turn it into one
of those nice graphs.

00:19:26.431 --> 00:19:27.680
Right now, this is not, right?

00:19:27.680 --> 00:19:31.151
This is degree 1, degree 1,
degree 3, degree 1, degree 1,

00:19:31.151 --> 00:19:31.650
degree 3.

00:19:31.650 --> 00:19:34.200
All of them are odd,
so that's not good.

00:19:34.200 --> 00:19:36.640
But, let's say, you could
add some edges in, turn it

00:19:36.640 --> 00:19:38.780
into an Euler
circuit, and then you

00:19:38.780 --> 00:19:41.700
could do a nice reversal off it,
and, maybe, that will give you

00:19:41.700 --> 00:19:43.610
a better approximation.

00:19:43.610 --> 00:19:47.240
So with that hope, let's
look at the algorithm.

00:19:47.240 --> 00:19:50.090
So what you do is, you
go back to your tree.

00:19:58.090 --> 00:20:00.090
Let's just leave it at that.

00:20:00.090 --> 00:20:03.560
So, now, let's see.

00:20:03.560 --> 00:20:06.010
So this is degree
2, that's good.

00:20:06.010 --> 00:20:08.350
This is degree 3,
that's not good.

00:20:08.350 --> 00:20:09.860
Degree 1, this is fine.

00:20:09.860 --> 00:20:11.230
This is degree 1.

00:20:11.230 --> 00:20:13.390
This also is degree 1.

00:20:13.390 --> 00:20:15.017
This is degree 3.

00:20:15.017 --> 00:20:17.600
Actually, let's get rid of this,
so it does not have degree 3.

00:20:17.600 --> 00:20:18.720
That's a lot of vertices.

00:20:18.720 --> 00:20:21.390
OK, there we go.

00:20:21.390 --> 00:20:23.506
So, in this graph,
you see that you

00:20:23.506 --> 00:20:27.710
have 1, 2, 3, 4, 5 vertices
which have degree odd.

00:20:27.710 --> 00:20:32.880
So, now, we would like to
add some edges to turn this

00:20:32.880 --> 00:20:35.430
into an Euler circuitable graph.

00:20:35.430 --> 00:20:36.780
So how do we do that?

00:20:36.780 --> 00:20:48.940
So let's call the set of odd
edges S. Odd vertices, sorry.

00:20:56.010 --> 00:20:59.240
So you take the set of
odd-degree vertices.

00:20:59.240 --> 00:21:03.100
Now, go back to
perfect matchings.

00:21:03.100 --> 00:21:05.180
So what does a
perfect matching do?

00:21:05.180 --> 00:21:08.470
It adds edges to that
graph so that everything

00:21:08.470 --> 00:21:11.210
gets degree increased by one.

00:21:11.210 --> 00:21:14.340
So if you increase the degree
of all the odd vertices by 1,

00:21:14.340 --> 00:21:17.260
everything turns even, right?

00:21:17.260 --> 00:21:20.740
So you take the set
of odd vertices.

00:21:20.740 --> 00:21:22.479
OK, another thing to observe.

00:21:22.479 --> 00:21:24.520
Realize that, how many
odd vertices can you have?

00:21:24.520 --> 00:21:26.860
Can you have an odd
number of odd vertices?

00:21:26.860 --> 00:21:29.307
Because that would screw
up the whole thing where we

00:21:29.307 --> 00:21:30.640
needed an even number of things.

00:21:36.070 --> 00:21:37.525
So why is that not possible?

00:21:37.525 --> 00:21:39.650
Why can you not have an
odd number of odd vertices?

00:21:42.490 --> 00:21:48.030
So the thing is, that, let's
say, you have some graph,

00:21:48.030 --> 00:21:51.842
and what is the sum of
the degrees of the graph?

00:21:51.842 --> 00:21:53.550
Let's move to a
different board for this.

00:21:56.680 --> 00:22:00.640
So you have a graph, G, and
you want sum of degrees.

00:22:00.640 --> 00:22:04.722
So di is the degree, for all
V. So what is this equal to?

00:22:04.722 --> 00:22:06.180
So, let's say, you
have this graph.

00:22:12.990 --> 00:22:16.880
So, now, if you count the
degrees of every vertex,

00:22:16.880 --> 00:22:19.490
you're basically counting the
number of edges coming out,

00:22:19.490 --> 00:22:21.602
which means that every
edge is counted twice, once

00:22:21.602 --> 00:22:23.560
for this end point and
once for this end point.

00:22:23.560 --> 00:22:26.107
So this edge is counted
twice, for here and here.

00:22:26.107 --> 00:22:27.440
This edge is also counted twice.

00:22:27.440 --> 00:22:29.100
So, basically, the
sum of the degrees

00:22:29.100 --> 00:22:33.790
is nothing but 2 times mod
of E. Does that make sense?

00:22:37.120 --> 00:22:40.230
So this is even.

00:22:40.230 --> 00:22:43.470
Now, let's say you take
only the odd vertices out.

00:22:43.470 --> 00:22:45.510
So the even vertices are good.

00:22:45.510 --> 00:22:46.220
This is good.

00:22:46.220 --> 00:22:47.100
This is good.

00:22:47.100 --> 00:22:47.840
This is not good.

00:22:47.840 --> 00:22:50.280
This is also not good.

00:22:50.280 --> 00:22:53.670
So these are the odd vertices.

00:22:53.670 --> 00:22:56.170
So the sum of the degrees
of the even vertices

00:22:56.170 --> 00:22:58.320
are, by definition, even.

00:22:58.320 --> 00:23:01.100
So, if you remove them,
the sum of the odd vertices

00:23:01.100 --> 00:23:03.340
should also remain even.

00:23:03.340 --> 00:23:07.427
And so, you have the sum of
odd degrees becoming even,

00:23:07.427 --> 00:23:09.926
which means that you'll need
to have an even number of them.

00:23:09.926 --> 00:23:12.270
Make sense?

00:23:12.270 --> 00:23:16.140
So, going back to this, so
there's a lot of branching off,

00:23:16.140 --> 00:23:16.640
here.

00:23:16.640 --> 00:23:18.060
But going back to
the main point,

00:23:18.060 --> 00:23:22.300
here, is that you have an
even number of odd vertices.

00:23:22.300 --> 00:23:25.640
So consider the restriction
of the original graph,

00:23:25.640 --> 00:23:29.036
G to this set, S.
So, now, we're going

00:23:29.036 --> 00:23:30.410
to the first thing
we did, there,

00:23:30.410 --> 00:23:32.800
where we considered a
restriction of the graph

00:23:32.800 --> 00:23:34.340
to a certain set of vertices.

00:23:34.340 --> 00:23:37.050
So we take the set,
so 1, 2, 3, 4, 5.

00:23:37.050 --> 00:23:38.510
So you take these five vertices.

00:23:42.670 --> 00:23:46.080
And you consider the graph that
is restricted to these five

00:23:46.080 --> 00:23:46.580
vertices.

00:23:46.580 --> 00:23:49.010
Oh, sorry, there should be six.

00:23:49.010 --> 00:23:50.378
Oh, that's interesting.

00:23:50.378 --> 00:23:51.055
Oh, there we go.

00:23:51.055 --> 00:23:51.930
That's the other one.

00:23:56.200 --> 00:23:59.640
So those are the six vertices
which have odd degrees.

00:23:59.640 --> 00:24:01.310
Now, you find the
perfect matching

00:24:01.310 --> 00:24:03.950
with your polynomial-time
algorithm,

00:24:03.950 --> 00:24:06.680
and you get something.

00:24:06.680 --> 00:24:09.550
So you can now add those
edges back in here.

00:24:09.550 --> 00:24:14.955
So these are your new
edges, and, let's say,

00:24:14.955 --> 00:24:18.280
something, this one.

00:24:18.280 --> 00:24:20.370
OK, so you get three new edges.

00:24:20.370 --> 00:24:22.720
And, now, realize that all
the degrees are now even,

00:24:22.720 --> 00:24:24.280
so now you can do
your Euler circuit.

00:24:24.280 --> 00:24:28.690
Also, let's call this matching
M. So this is a set of edges,

00:24:28.690 --> 00:24:32.590
M. Let's call the
original tree T,

00:24:32.590 --> 00:24:37.997
and the new thing that
is formed, is T union M.

00:24:37.997 --> 00:24:39.580
So you're taking all
the edges from T,

00:24:39.580 --> 00:24:41.496
and you're adding
all the edges from M.

00:24:41.496 --> 00:24:43.370
So, realize that you
can have multiple edges,

00:24:43.370 --> 00:24:45.244
but that's fine, because
Euler circuits allow

00:24:45.244 --> 00:24:46.960
you to have multiple edges.

00:24:46.960 --> 00:24:48.910
So, now, you take
this graph, and you

00:24:48.910 --> 00:24:51.490
find this Euler circuit.

00:24:51.490 --> 00:24:54.680
So that is basically this thing.

00:24:54.680 --> 00:24:59.120
So this set of edges in some
order, and that order exists.

00:24:59.120 --> 00:25:01.890
So the cost of the
Euler circuit--

00:25:01.890 --> 00:25:06.000
let's call it C-- is equal to
the cost of T plus the cost

00:25:06.000 --> 00:25:07.400
of M, right?

00:25:07.400 --> 00:25:10.890
Because you're traversing
all the edges in your graph.

00:25:10.890 --> 00:25:12.640
So that is the cost
for the Euler circuit.

00:25:12.640 --> 00:25:15.850
Now, my claim is that-- so this
is the difference between all

00:25:15.850 --> 00:25:17.590
the nodes in the graph.

00:25:17.590 --> 00:25:20.640
And, remember, you can do the
whole duplication argument,

00:25:20.640 --> 00:25:23.000
from before.

00:25:23.000 --> 00:25:24.460
So, where's that?

00:25:24.460 --> 00:25:25.240
Oh, there.

00:25:25.240 --> 00:25:26.890
So you can do a
duplication argument,

00:25:26.890 --> 00:25:28.806
so you're visiting all
the edges in the graph,

00:25:28.806 --> 00:25:30.220
all the vertices in the graph.

00:25:30.220 --> 00:25:33.680
You remove the duplicates,
and you have a valid path.

00:25:33.680 --> 00:25:36.700
Now, let's see if this
valid path is actually

00:25:36.700 --> 00:25:37.680
a better approximation.

00:25:42.900 --> 00:25:45.496
So, again, you will go
from C. So this C, you

00:25:45.496 --> 00:25:49.046
will go to C dash.

00:25:49.046 --> 00:25:54.290
And this will give you,
as before, cost of C dash

00:25:54.290 --> 00:25:56.796
is less than equal
to the cost of C,

00:25:56.796 --> 00:25:58.670
So, now, you're only
interested in cost of C.

00:25:58.670 --> 00:25:59.795
So what are we doing there?

00:25:59.795 --> 00:26:05.170
So we know that the cost
of C is equal to cost

00:26:05.170 --> 00:26:12.070
of T plus the cost of M. So,
from the previous problem,

00:26:12.070 --> 00:26:15.500
we know that the cost of T is
less than equal to the cost

00:26:15.500 --> 00:26:18.700
of H star of G, right?

00:26:18.700 --> 00:26:27.770
So this is less than
equal to cost of H star G.

00:26:27.770 --> 00:26:32.357
So this guy is less than the
optimal Hamiltonian path.

00:26:32.357 --> 00:26:33.190
What about this guy?

00:26:36.130 --> 00:26:39.020
So let's look at the
actual H star G, again.

00:26:45.980 --> 00:26:49.960
So, actually, let's
look at H star S.

00:26:49.960 --> 00:26:53.370
So remember that S is
the set of odd vertices,

00:26:53.370 --> 00:26:55.470
and that is where
this matching is done.

00:26:55.470 --> 00:26:58.070
So H star S is nothing but
the optimal Hamiltonian

00:26:58.070 --> 00:27:02.030
cycle on that restricted graph.

00:27:02.030 --> 00:27:05.250
From our previous lemma,
which is down here,

00:27:05.250 --> 00:27:10.080
we know that H star of S
is less than H star of G.

00:27:10.080 --> 00:27:20.370
So we know that cost of is less
than equal to cost of whatever,

00:27:20.370 --> 00:27:25.630
G. So, now, let's just
look at H star of S. Now,

00:27:25.630 --> 00:27:28.020
we construct a matching.

00:27:28.020 --> 00:27:29.460
We take every other edge.

00:27:29.460 --> 00:27:33.410
We take this one, and we take
this one, and we take this one.

00:27:33.410 --> 00:27:36.630
And look at the
alternate set, also.

00:27:36.630 --> 00:27:39.190
So take this one, and
this one, and this one.

00:27:39.190 --> 00:27:41.405
So look at the blue
set and the red set.

00:27:41.405 --> 00:27:43.030
Since it's part of
a Hamiltonian cycle,

00:27:43.030 --> 00:27:46.990
they're both matchings, right?

00:27:46.990 --> 00:27:52.667
So let's call the red one
M1, and the blue one M2.

00:27:52.667 --> 00:27:54.500
So I'm not saying they're
perfect matchings.

00:27:54.500 --> 00:27:56.510
They're not the
minimum matchings,

00:27:56.510 --> 00:27:58.740
but they're definitely
perfect matchings.

00:27:58.740 --> 00:28:03.170
And because we know the
perfect matching is M,

00:28:03.170 --> 00:28:06.270
or the minimum matching
is M. Cost of M

00:28:06.270 --> 00:28:16.190
is less than equal to cost of
M1, and, also, the cost of M

00:28:16.190 --> 00:28:21.032
is less than equal
to the cost of M2.

00:28:21.032 --> 00:28:22.450
That make sense?

00:28:22.450 --> 00:28:24.655
Because M was the
minimum cost matching,

00:28:24.655 --> 00:28:27.030
you have cost of M is less
than any other matching, which

00:28:27.030 --> 00:28:29.270
is constructed from this.

00:28:29.270 --> 00:28:34.950
Again, so this implies
that the cost of M

00:28:34.950 --> 00:28:43.842
is less than equal
to half cost of-- OK,

00:28:43.842 --> 00:28:44.925
let's not write this here.

00:28:47.690 --> 00:28:49.030
Let's get a different board.

00:28:56.150 --> 00:29:04.786
So cost of n is less than
equal to half cost of M1

00:29:04.786 --> 00:29:08.770
plus cost of M2.

00:29:08.770 --> 00:29:10.740
Since both of these guys
are larger than this,

00:29:10.740 --> 00:29:13.515
their average is also
larger than this, right?

00:29:13.515 --> 00:29:15.805
But what is cost
of M1 cost of M2?

00:29:15.805 --> 00:29:22.650
This is nothing but half
cost of H star of S, right?

00:29:22.650 --> 00:29:27.416
Because the Hamiltonian cycle
is constructed from M1 and M2.

00:29:30.636 --> 00:29:32.460
And by our lemma,
this is less than

00:29:32.460 --> 00:29:39.690
equal to half cost
of H star of G.

00:29:39.690 --> 00:29:43.200
So, now, we have all we need.

00:29:43.200 --> 00:29:50.130
This is less than equal to
half cost of H star of G.

00:29:50.130 --> 00:29:55.630
And then, add them together,
you get cost of C dash

00:29:55.630 --> 00:29:58.170
is less than equal to
cost of C, is less than

00:29:58.170 --> 00:30:09.227
equal to the sum, which is equal
to 3/2 cost of H star of G.

00:30:09.227 --> 00:30:10.060
So that's the proof.

00:30:10.060 --> 00:30:12.410
So there's a lot of
things going on, here.

00:30:12.410 --> 00:30:14.580
Let's try to go back
and see what we did.

00:30:14.580 --> 00:30:19.830
So we took a minimum
spanning tree,

00:30:19.830 --> 00:30:23.195
and then we tried to remove
all the odd degree vertices.

00:30:23.195 --> 00:30:24.820
So we took all the
odd degree vertices,

00:30:24.820 --> 00:30:27.960
and made a perfect matching, the
minimum cost perfect matching.

00:30:27.960 --> 00:30:31.570
So we added edges just to
make everything even degree.

00:30:31.570 --> 00:30:36.770
Then, we took the Euler
circuit on that graph,

00:30:36.770 --> 00:30:38.329
and we removed duplicates.

00:30:38.329 --> 00:30:39.870
So that's fine,
that's the easy part.

00:30:39.870 --> 00:30:42.660
But you do [INAUDIBLE]
circuit on that graph,

00:30:42.660 --> 00:30:45.690
then you argued that, because
all the circuits in that graph

00:30:45.690 --> 00:30:48.810
is just the sum of the
edges in the spanning tree

00:30:48.810 --> 00:30:50.810
plus the sum of the edges
in the matching, which

00:30:50.810 --> 00:30:51.892
you added later.

00:30:51.892 --> 00:30:53.600
So the spanning tree
had already bounded,

00:30:53.600 --> 00:30:55.220
in the previous argument.

00:30:55.220 --> 00:30:58.770
The matching was bounded by
taking the optimal Hamiltonian

00:30:58.770 --> 00:31:02.690
cycle, decomposing it
into two matchings,

00:31:02.690 --> 00:31:04.840
arguing that those
two matchings are not

00:31:04.840 --> 00:31:06.465
the optimal matchings--
not necessarily

00:31:06.465 --> 00:31:08.470
the optimal
matchings, but they're

00:31:08.470 --> 00:31:10.120
less than equal to the optimal.

00:31:10.120 --> 00:31:11.450
So they're even, there.

00:31:11.450 --> 00:31:14.620
And, so, the cost of
the optimal matching,

00:31:14.620 --> 00:31:16.640
which you were using in
our constructive path,

00:31:16.640 --> 00:31:18.381
constructive
Hamiltonian cycle, is

00:31:18.381 --> 00:31:20.130
less than equal to
both of these matching.

00:31:20.130 --> 00:31:23.350
You add them up, you get
that bound, and it works.

00:31:23.350 --> 00:31:25.230
So questions on
any of the steps?

00:31:25.230 --> 00:31:28.802
This is a lot of branching off
and then coming back together.

00:31:28.802 --> 00:31:29.302
Yeah.

00:31:29.302 --> 00:31:31.054
STUDENT: The last
one's 3/2, right?

00:31:31.054 --> 00:31:32.220
AMARTYA SHANKHA BISWAS: Yes.

00:31:32.220 --> 00:31:33.964
That is not 3 over 3.

00:31:33.964 --> 00:31:35.130
That would be p equal to np.

00:31:38.897 --> 00:31:39.480
Anything else?

00:31:45.920 --> 00:31:49.310
You're free to go, or ask
questions, or whatever.

