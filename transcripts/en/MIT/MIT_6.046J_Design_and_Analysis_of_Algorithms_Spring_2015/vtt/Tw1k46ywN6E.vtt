WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:02.500
The following content is
provided under a Creative

00:00:02.500 --> 00:00:04.019
Commons license.

00:00:04.019 --> 00:00:06.360
Your support will help
MIT OpenCourseWare

00:00:06.360 --> 00:00:10.730
continue to offer high quality
educational resources for free.

00:00:10.730 --> 00:00:13.330
To make a donation or
view additional materials

00:00:13.330 --> 00:00:17.236
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.236 --> 00:00:17.861
at ocw.mit.edu.

00:00:20.695 --> 00:00:21.570
PROFESSOR: All right.

00:00:21.570 --> 00:00:23.150
Good morning, everyone.

00:00:23.150 --> 00:00:25.450
Thanks for coming on quiz day.

00:00:25.450 --> 00:00:28.680
I have to have someone
to throw Frisbees to.

00:00:28.680 --> 00:00:32.049
Empty chairs would be difficult.

00:00:32.049 --> 00:00:36.220
So we're going to be doing
dynamic programming, a notion

00:00:36.220 --> 00:00:40.090
you've learned in 6006.

00:00:40.090 --> 00:00:43.010
We'll look at three
different examples today.

00:00:43.010 --> 00:00:46.570
The first one is really
at the level of 006,

00:00:46.570 --> 00:00:51.190
a cute little problem on
finding the longest palindromic

00:00:51.190 --> 00:00:56.630
sequence inside of
a longer sequence.

00:00:56.630 --> 00:01:00.250
Sometimes it's called longest
palindromic subsequence.

00:01:00.250 --> 00:01:03.310
And as we'll talk
about, subsequence

00:01:03.310 --> 00:01:06.520
means that it can
be non-contiguous.

00:01:06.520 --> 00:01:12.840
So you could skip letters
in a sequence of letters

00:01:12.840 --> 00:01:16.770
and you would still have a
subsequence corresponding

00:01:16.770 --> 00:01:17.480
to that.

00:01:17.480 --> 00:01:19.100
Don't have to be contiguous.

00:01:19.100 --> 00:01:21.840
And then we'll raise
the stakes a little bit.

00:01:21.840 --> 00:01:27.530
So each of these problems gets
progressively more complicated,

00:01:27.530 --> 00:01:29.010
more sophisticated.

00:01:29.010 --> 00:01:32.950
And you'll probably
see problems here,

00:01:32.950 --> 00:01:37.070
at least alternating coin
game, that are beyond 006

00:01:37.070 --> 00:01:39.270
in the sense that
it wasn't covered.

00:01:39.270 --> 00:01:42.290
Those kinds of notions
weren't covered in 006.

00:01:42.290 --> 00:01:45.830
So just in terms of
review, I wrote this

00:01:45.830 --> 00:01:48.940
up here because I don't want
to spend a whole lot of time

00:01:48.940 --> 00:01:49.760
on it.

00:01:49.760 --> 00:01:52.300
This is something that you
should have some familiarity

00:01:52.300 --> 00:01:57.590
with from the
recitation, for example,

00:01:57.590 --> 00:02:00.880
that you had on
Friday and from 006.

00:02:00.880 --> 00:02:03.600
Dynamic programming is
this wonderful hammer.

00:02:03.600 --> 00:02:05.960
It's an algorithmic
technique that you

00:02:05.960 --> 00:02:11.390
can use to solve problems that
look exponential in complexity.

00:02:11.390 --> 00:02:15.210
But if you can find this
optimum substructure associated

00:02:15.210 --> 00:02:20.060
with the problem and its
connection to it's subproblems,

00:02:20.060 --> 00:02:22.080
and if you can
characterize that,

00:02:22.080 --> 00:02:26.410
then you can do a recursive
decomposition of the problem

00:02:26.410 --> 00:02:33.200
where you show that you can
construct the optimum solution

00:02:33.200 --> 00:02:34.660
from the subproblems.

00:02:34.660 --> 00:02:38.480
And that's really the key
step in dynamic programming,

00:02:38.480 --> 00:02:40.070
is step two.

00:02:40.070 --> 00:02:42.570
Once you've made this
characterization,

00:02:42.570 --> 00:02:48.630
you write this recurrence out
that relates the optimal value

00:02:48.630 --> 00:02:53.950
of a bigger problem to the
optimal values of subproblems.

00:02:53.950 --> 00:02:58.440
And you compute the value
of the optimal solution

00:02:58.440 --> 00:03:04.800
through a recursive memoization.

00:03:04.800 --> 00:03:07.750
And that memoization
is really what

00:03:07.750 --> 00:03:12.040
gives you the
efficient algorithm,

00:03:12.040 --> 00:03:16.540
because you don't repeat
the solution of subproblems.

00:03:16.540 --> 00:03:19.640
You can also do this in
an iterative fashion.

00:03:19.640 --> 00:03:22.620
Essentially, you're going to
be computing things bottom-up.

00:03:22.620 --> 00:03:24.890
You might want to think
about it as top-down

00:03:24.890 --> 00:03:26.790
when you write your recurrence.

00:03:26.790 --> 00:03:29.800
But ultimately, when you
actually execute the program,

00:03:29.800 --> 00:03:31.690
you'll be computing
things bottom-up,

00:03:31.690 --> 00:03:35.320
and you'll be checking the memo
table to see if you actually

00:03:35.320 --> 00:03:37.340
solved this problem before.

00:03:37.340 --> 00:03:41.340
And that would be the
recursive memoized case,

00:03:41.340 --> 00:03:43.430
which, in some sense,
is a little bit easier

00:03:43.430 --> 00:03:46.750
to think about and translate
directly from the recurrence.

00:03:46.750 --> 00:03:49.170
But the other way to do it
is to do it iteratively.

00:03:49.170 --> 00:03:51.590
And we'll take a look
for this first problem

00:03:51.590 --> 00:03:55.110
as to how you'd do the two
different ways at least

00:03:55.110 --> 00:03:58.720
from a conceptual standpoint,
even though I might not

00:03:58.720 --> 00:04:01.400
write out the code for
each of those cases.

00:04:01.400 --> 00:04:04.880
So a couple of choices
here, recurse and memoize,

00:04:04.880 --> 00:04:08.726
or essentially do
it iteratively.

00:04:08.726 --> 00:04:10.100
And the smaller
subproblems would

00:04:10.100 --> 00:04:16.279
have to get computed
first in both approaches.

00:04:16.279 --> 00:04:18.910
The one thing that sometimes we
don't spend a whole lot of time

00:04:18.910 --> 00:04:25.210
on is this last step, which
is getting the exact solution.

00:04:25.210 --> 00:04:27.570
So a lot of the time,
you stop with saying,

00:04:27.570 --> 00:04:31.030
I can compute the value
of the optimum solution,

00:04:31.030 --> 00:04:34.740
the value in terms of
the length of the longest

00:04:34.740 --> 00:04:38.770
palindromic sequence is 7 or 9.

00:04:38.770 --> 00:04:42.270
But what is that
sequence or subsequence?

00:04:42.270 --> 00:04:45.640
That requires some
additional coding,

00:04:45.640 --> 00:04:48.710
some additional accounting.

00:04:48.710 --> 00:04:51.100
The construction of
this optimal solution

00:04:51.100 --> 00:04:53.530
typically requires
some back-tracing

00:04:53.530 --> 00:04:58.200
and some information
to be kept track

00:04:58.200 --> 00:05:00.590
of during the recurse
and memoize step

00:05:00.590 --> 00:05:02.491
or during the iterative step.

00:05:02.491 --> 00:05:03.990
So that's something
to keep in mind.

00:05:03.990 --> 00:05:06.160
You're not quite
done once you've

00:05:06.160 --> 00:05:08.870
found the value of
the optimum solution.

00:05:08.870 --> 00:05:11.250
More often than not,
you want the solution.

00:05:11.250 --> 00:05:14.260
So we'll talk about that
as well a little bit.

00:05:14.260 --> 00:05:21.824
But let's just dive in and look
at this cute, little problem

00:05:21.824 --> 00:05:27.280
of longest palindromic sequence.

00:05:27.280 --> 00:05:35.140
And palindromes, of course,
read the same front to back

00:05:35.140 --> 00:05:36.220
or back to front.

00:05:36.220 --> 00:05:38.530
Radar is a palindrome.

00:05:38.530 --> 00:05:43.890
Just as a trivial example, a
single letter is a palindrome.

00:05:43.890 --> 00:05:48.440
Maybe I should have used a
since that's actually a word.

00:05:48.440 --> 00:05:50.890
But here I got bb.

00:05:50.890 --> 00:05:54.090
That's definitely not
a word, at least not

00:05:54.090 --> 00:05:57.670
a word that-- acronym, maybe.

00:05:57.670 --> 00:06:00.690
Radar is a palindrome.

00:06:00.690 --> 00:06:03.080
Able was I 'ere I
saw Elba, right?

00:06:03.080 --> 00:06:05.180
That's a palindrome.

00:06:05.180 --> 00:06:06.870
That's, of course,
not a single word.

00:06:06.870 --> 00:06:11.680
But it's a famous
palindrome, days of Napoleon.

00:06:11.680 --> 00:06:13.660
But what we're
trying to do here is,

00:06:13.660 --> 00:06:17.220
given that we have this
notion of a palindrome,

00:06:17.220 --> 00:06:22.400
we'd like to discover
palindromes inside longer

00:06:22.400 --> 00:06:24.700
words or longer sequences.

00:06:24.700 --> 00:06:33.921
So what we have is a string,
and we'll call it x1 through n,

00:06:33.921 --> 00:06:37.305
n greater than or equal to 1.

00:06:37.305 --> 00:06:45.920
And we want to find the
longest palindrome that

00:06:45.920 --> 00:06:46.720
is a subsequence.

00:06:50.420 --> 00:06:54.290
And so here's an example
to get you guys warmed up.

00:06:54.290 --> 00:06:58.050
We'll have a couple of
puzzles here in a second.

00:06:58.050 --> 00:06:59.720
So character.

00:06:59.720 --> 00:07:03.420
And you want to find
the longest palindrome.

00:07:03.420 --> 00:07:07.450
And so you go, I'll pick c,
I'll skip h, I'll pick a,

00:07:07.450 --> 00:07:10.150
I'll pick r, a, and c.

00:07:10.150 --> 00:07:15.020
And carac, which I guess
is not a word either--

00:07:15.020 --> 00:07:21.000
but it's the longest
palindrome that corresponds

00:07:21.000 --> 00:07:24.190
to a subsequence of character.

00:07:24.190 --> 00:07:24.690
Right?

00:07:24.690 --> 00:07:27.660
So the game here,
as you can see,

00:07:27.660 --> 00:07:33.670
is to pick the letters that
form the palindrome and drop

00:07:33.670 --> 00:07:35.860
the ones that don't.

00:07:35.860 --> 00:07:36.420
OK?

00:07:36.420 --> 00:07:40.630
And we're going to have to use
dynamic programming to do this.

00:07:40.630 --> 00:07:46.760
The answer will be greater
than or-- 1 in length

00:07:46.760 --> 00:07:51.640
because we've defined a
single letter as a palindrome.

00:07:51.640 --> 00:07:55.660
So it has to be-- if you have
one letter in the input, well,

00:07:55.660 --> 00:07:56.896
you just pick that letter.

00:07:56.896 --> 00:07:59.270
But regardless of how many
letters you have on the input,

00:07:59.270 --> 00:08:00.920
greater than or
equal to 1, you know

00:08:00.920 --> 00:08:03.980
that you're going to get
at least a one letter

00:08:03.980 --> 00:08:06.740
palindrome at the output.

00:08:06.740 --> 00:08:08.330
So here we go.

00:08:11.610 --> 00:08:17.900
Let's say I have under-- and
this is thanks to Eric here.

00:08:17.900 --> 00:08:22.350
I've got a couple of nice
words-- underqualified.

00:08:22.350 --> 00:08:25.310
The person who gets me
the longest palindrome

00:08:25.310 --> 00:08:27.400
wins a Frisbee.

00:08:27.400 --> 00:08:30.040
And if you want to code dynamic
programming in the next two

00:08:30.040 --> 00:08:33.159
minutes and run it
on your laptops,

00:08:33.159 --> 00:08:34.870
that's perfectly fine with me.

00:08:34.870 --> 00:08:37.909
That's not cheating.

00:08:37.909 --> 00:08:40.450
So underqualified.

00:08:40.450 --> 00:08:41.549
So u is a palindrome.

00:08:41.549 --> 00:08:42.539
So we got that.

00:08:42.539 --> 00:08:43.039
Right?

00:08:43.039 --> 00:08:45.300
So one letter for sure.

00:08:45.300 --> 00:08:46.430
What else?

00:08:46.430 --> 00:08:47.790
What's the longest palindrome?

00:08:47.790 --> 00:08:48.490
Shout it out.

00:08:48.490 --> 00:08:48.990
Go ahead.

00:08:48.990 --> 00:08:50.344
Shout it out.

00:08:50.344 --> 00:08:51.580
[STUDENTS RESPOND]

00:08:51.580 --> 00:08:53.470
PROFESSOR: D-E-I--
wow, that was quick.

00:08:53.470 --> 00:08:54.440
Deified.

00:08:54.440 --> 00:08:55.000
That's right.

00:08:55.000 --> 00:09:01.840
So right?

00:09:01.840 --> 00:09:07.920
Well, deified is to
make somebody a deity.

00:09:07.920 --> 00:09:12.180
So that was you, a
couple of you guys?

00:09:12.180 --> 00:09:13.649
Do you have a Frisbee yet?

00:09:13.649 --> 00:09:14.190
AUDIENCE: No.

00:09:14.190 --> 00:09:15.065
PROFESSOR: All right.

00:09:18.070 --> 00:09:18.570
All right.

00:09:18.570 --> 00:09:21.642
This is a little bit more
difficult. I tried this

00:09:21.642 --> 00:09:23.100
on my daughter
yesterday, so I know

00:09:23.100 --> 00:09:27.325
it's a little more
difficult. Turboventilator.

00:09:32.470 --> 00:09:35.440
We'll call that a word.

00:09:35.440 --> 00:09:37.640
Turboventilator.

00:09:37.640 --> 00:09:40.053
Yell it out.

00:09:40.053 --> 00:09:41.530
AUDIENCE: Rotor.

00:09:41.530 --> 00:09:42.500
PROFESSOR: Sorry?

00:09:42.500 --> 00:09:42.830
AUDIENCE: Rotor.

00:09:42.830 --> 00:09:43.145
PROFESSOR: Rotor.

00:09:43.145 --> 00:09:44.070
OK, well, that's five.

00:09:44.070 --> 00:09:45.535
Can anybody beat that?

00:09:45.535 --> 00:09:46.285
AUDIENCE: Rotator.

00:09:46.285 --> 00:09:47.540
PROFESSOR: Rotator.

00:09:47.540 --> 00:09:48.530
So rotator.

00:09:48.530 --> 00:09:49.350
Rotator.

00:09:49.350 --> 00:09:56.800
So R-O-T-A-T-O-R, rotator.

00:09:56.800 --> 00:09:57.550
All right.

00:10:01.409 --> 00:10:02.200
Who is the rotator?

00:10:05.150 --> 00:10:06.440
You already have one?

00:10:06.440 --> 00:10:07.742
I want to throw this one.

00:10:07.742 --> 00:10:08.242
Right.

00:10:12.210 --> 00:10:14.720
Good practice with
the quiz, guys.

00:10:14.720 --> 00:10:16.100
Good practice with the quiz.

00:10:16.100 --> 00:10:16.980
No, no, no.

00:10:16.980 --> 00:10:20.750
These quiz jokes
never go over well.

00:10:20.750 --> 00:10:22.890
I've been teaching for
27 years, and I still

00:10:22.890 --> 00:10:27.160
haven't learned that you
don't joke about exams.

00:10:27.160 --> 00:10:29.840
But so nothing like
this on the quiz.

00:10:29.840 --> 00:10:32.450
I don't want you studying
the thesaurus as opposed

00:10:32.450 --> 00:10:34.940
to the textbook for
the next few hours.

00:10:34.940 --> 00:10:35.570
OK?

00:10:35.570 --> 00:10:37.900
Nothing like this on the quiz.

00:10:37.900 --> 00:10:40.210
All right.

00:10:40.210 --> 00:10:44.820
Those of you who are missing
Python, who loved 6006

00:10:44.820 --> 00:10:50.190
in Python, let's talk about
how you would actually solve

00:10:50.190 --> 00:10:53.020
this using dynamic programming.

00:10:53.020 --> 00:10:58.750
And so what we
want is lij, which

00:10:58.750 --> 00:11:11.190
is the length of the longest
palindromic subsequence

00:11:11.190 --> 00:11:14.040
for xij.

00:11:14.040 --> 00:11:17.410
And we're going to have i
less than or equal to j.

00:11:20.830 --> 00:11:23.670
So that's essentially
what we'd like to compute.

00:11:23.670 --> 00:11:29.660
And essentially when I've said
this here, when I have lij,

00:11:29.660 --> 00:11:35.550
I have decomposed the overall
problem into subproblems,

00:11:35.550 --> 00:11:38.370
and it was kind of fairly
obvious in this case,

00:11:38.370 --> 00:11:41.120
because I'm going to
have to go in order.

00:11:41.120 --> 00:11:41.620
Right?

00:11:41.620 --> 00:11:42.980
I mean that's the constraint.

00:11:42.980 --> 00:11:46.700
A subsequence does maintain
the ordering constraint.

00:11:46.700 --> 00:11:48.486
It's not like I can
invert these letters.

00:11:48.486 --> 00:11:49.860
That would be a
different problem

00:11:49.860 --> 00:11:51.420
if I allowed you to do that.

00:11:51.420 --> 00:11:55.260
So I'm going to start somewhere,
and I'm going to end somewhere.

00:11:55.260 --> 00:11:57.630
And I want to have a
non-null subsequence,

00:11:57.630 --> 00:11:59.730
so I'm going to have i
less than or equal to j.

00:11:59.730 --> 00:12:02.560
I'm good with i being
equal to j, because I still

00:12:02.560 --> 00:12:05.740
have one letter, and, well,
that happens to be a palindrome,

00:12:05.740 --> 00:12:07.740
and it'll have a length of 1.

00:12:07.740 --> 00:12:10.380
So that's my lij.

00:12:10.380 --> 00:12:17.950
And what I want to do is
define a recursive algorithm

00:12:17.950 --> 00:12:20.610
that computes lij.

00:12:20.610 --> 00:12:25.360
So we'll just try and figure out
what the recurrence looks like,

00:12:25.360 --> 00:12:31.220
and then we can talk about
memoization or iteration.

00:12:31.220 --> 00:12:36.680
So if i equals
equals j, then I'm

00:12:36.680 --> 00:12:39.270
going to return
1, because I know

00:12:39.270 --> 00:12:43.970
that that's a palindrome
by default. So that's easy.

00:12:43.970 --> 00:12:48.640
And what do you think
the next check should be?

00:12:48.640 --> 00:12:51.410
If I look at this
x sequence, and I

00:12:51.410 --> 00:12:55.300
have i as the starting point
and j as the next point,

00:12:55.300 --> 00:12:58.150
what do you think the next check
is going to be once I have--

00:12:58.150 --> 00:13:01.965
if i is not equal to j?

00:13:01.965 --> 00:13:07.082
AUDIENCE: If x of i equals x
of j, then j equals as well.

00:13:07.082 --> 00:13:07.790
PROFESSOR: Sorry.

00:13:07.790 --> 00:13:08.623
What was that again?

00:13:08.623 --> 00:13:10.865
AUDIENCE: If x of
i equals x plus--

00:13:10.865 --> 00:13:11.740
PROFESSOR: Beautiful.

00:13:11.740 --> 00:13:14.240
You're just checking
to see-- you're just

00:13:14.240 --> 00:13:19.260
checking to see whether the
two endpoints are equal or not.

00:13:19.260 --> 00:13:21.610
Because if they're
equal, then you

00:13:21.610 --> 00:13:26.270
can essentially
grab those letters

00:13:26.270 --> 00:13:29.590
and say that you're
going to be looking

00:13:29.590 --> 00:13:37.480
at a smaller subsequence that is
going to get you a palindrome.

00:13:37.480 --> 00:13:40.090
And you're going to be able
to add these two letters that

00:13:40.090 --> 00:13:43.650
are equal on either side
of the computed palindrome

00:13:43.650 --> 00:13:45.300
from the subsequence.

00:13:45.300 --> 00:13:57.380
So if x of i equals equals x
of j, then I'm going to say,

00:13:57.380 --> 00:14:02.710
if i plus 1 equals
equals j, I'm going

00:14:02.710 --> 00:14:08.770
to go ahead and return
2, because at that point,

00:14:08.770 --> 00:14:10.900
I'm done.

00:14:10.900 --> 00:14:13.170
There's nothing else to do.

00:14:13.170 --> 00:14:26.920
Else I'm going to return 2
plus L of i plus 1 j minus 1.

00:14:26.920 --> 00:14:28.500
So I'm going to look inside.

00:14:28.500 --> 00:14:32.290
And I've got these two letters
on either side that are equal.

00:14:32.290 --> 00:14:35.890
So I can always prepend
to the palindrome

00:14:35.890 --> 00:14:40.830
I got from here the letter, and
then append the same letter.

00:14:40.830 --> 00:14:47.630
And I got 2 plus whatever value
I got from this quantity here.

00:14:47.630 --> 00:14:51.740
So so far, it's not
really particularly

00:14:51.740 --> 00:14:55.160
interesting from a
standpoint of constructing

00:14:55.160 --> 00:14:56.710
the optimum solution.

00:14:56.710 --> 00:15:01.050
But this last line that we have
here, where we have the case

00:15:01.050 --> 00:15:03.976
that the two letters
are not equal

00:15:03.976 --> 00:15:06.470
is the most interesting
line of code.

00:15:06.470 --> 00:15:09.080
That's the most interesting
aspect of this algorithm.

00:15:09.080 --> 00:15:12.290
So does someone tell
me what this line

00:15:12.290 --> 00:15:14.100
is going to be out here?

00:15:14.100 --> 00:15:15.427
Yeah, go ahead.

00:15:15.427 --> 00:15:20.225
AUDIENCE: If x of L i plus
1j or L i [INAUDIBLE].

00:15:20.225 --> 00:15:21.100
PROFESSOR: Beautiful.

00:15:21.100 --> 00:15:22.060
That's exactly right.

00:15:22.060 --> 00:15:24.143
So what you're going to
do is you're going to say,

00:15:24.143 --> 00:15:26.700
I need to look at two
different subproblems,

00:15:26.700 --> 00:15:31.110
and I need to evaluate
both of these subproblems.

00:15:31.110 --> 00:15:33.700
And the first subproblem is
I'm going to-- since these two

00:15:33.700 --> 00:15:37.710
letters are different, I'm going
to have to drop one of them.

00:15:37.710 --> 00:15:39.470
And I'm going to look inside.

00:15:39.470 --> 00:15:41.670
I'm going to say--
in this case, I'm

00:15:41.670 --> 00:15:44.890
going to drop the
i-th letter, and I'm

00:15:44.890 --> 00:15:47.540
going to get L i plus 1j.

00:15:47.540 --> 00:15:51.360
And in the second case, I'm
going to drop the j-th letter,

00:15:51.360 --> 00:15:54.930
and I'm going to get ij minus 1.

00:15:54.930 --> 00:15:56.090
And that's it.

00:15:56.090 --> 00:15:57.730
So it's a max.

00:15:57.730 --> 00:16:00.340
And there's nothing
that's being added here,

00:16:00.340 --> 00:16:04.270
because those two letters, one
of them had to get dropped.

00:16:04.270 --> 00:16:07.220
They weren't equal, so one
of them had to get dropped.

00:16:07.220 --> 00:16:10.450
So you're not adding
anything to this.

00:16:10.450 --> 00:16:11.440
So that's good.

00:16:11.440 --> 00:16:13.760
And at this point,
you're kind of done.

00:16:13.760 --> 00:16:14.260
Right?

00:16:17.810 --> 00:16:18.310
Whoops.

00:16:18.310 --> 00:16:20.000
Oh, nice catch.

00:16:20.000 --> 00:16:21.470
But you did drop something.

00:16:24.290 --> 00:16:24.790
All right.

00:16:24.790 --> 00:16:32.860
So the thing that we've done
here is gotten to step three.

00:16:32.860 --> 00:16:36.260
So just to be clear, we're
not done-done, in terms

00:16:36.260 --> 00:16:40.760
of this chart here, because
we don't have the code there

00:16:40.760 --> 00:16:47.990
that corresponds to actually
computing the sequence.

00:16:47.990 --> 00:16:49.980
So it's not that hard.

00:16:49.980 --> 00:16:54.510
I'm not going to go
over the code here.

00:16:54.510 --> 00:16:58.020
You can certainly look
at it in the notes.

00:16:58.020 --> 00:17:01.420
But you need a
little bit of tracing

00:17:01.420 --> 00:17:06.540
backwards in this recursion
to actually compute things.

00:17:06.540 --> 00:17:10.211
What is the complexity of
what I wrote up there, though?

00:17:10.211 --> 00:17:10.710
Yeah?

00:17:10.710 --> 00:17:12.200
AUDIENCE: Theta n squared?

00:17:12.200 --> 00:17:13.359
PROFESSOR: Theta n squared.

00:17:13.359 --> 00:17:16.030
Do people agree that the
complexity is theta n squared?

00:17:16.030 --> 00:17:17.479
Or is this gentleman
an optimist?

00:17:21.619 --> 00:17:23.390
Is the complexity
theta n squared?

00:17:23.390 --> 00:17:25.639
Tell me why the complexity
is theta n squared?

00:17:25.639 --> 00:17:27.106
AUDIENCE: Because
each subproblem

00:17:27.106 --> 00:17:30.615
is-- that code right there just
executed by itself is constant.

00:17:30.615 --> 00:17:32.490
But then there's theta
n squared subproblems.

00:17:32.490 --> 00:17:33.406
PROFESSOR: Absolutely.

00:17:33.406 --> 00:17:37.870
But if you actually implemented
this code, and you ran it,

00:17:37.870 --> 00:17:41.780
and n was 100,
how long would you

00:17:41.780 --> 00:17:43.205
wait for this code to complete?

00:17:47.300 --> 00:17:48.800
Look at it.

00:17:48.800 --> 00:17:49.915
What's missing?

00:17:49.915 --> 00:17:51.160
AUDIENCE: The cache.

00:17:51.160 --> 00:17:52.790
PROFESSOR: The cache, exactly.

00:17:52.790 --> 00:17:57.580
Well, you fixed your
own little error there.

00:17:57.580 --> 00:17:59.290
It was a trick question.

00:17:59.290 --> 00:18:01.790
So there's no recursion-- I'm
sorry, there's recursion here,

00:18:01.790 --> 00:18:03.940
but no memoization.

00:18:03.940 --> 00:18:06.810
So this is exponential
complexity.

00:18:06.810 --> 00:18:08.890
You will recur.

00:18:08.890 --> 00:18:14.730
In fact, the recurrence for
that is something like T of n

00:18:14.730 --> 00:18:23.310
equals 1 if n equals 1, and 2T
n minus 1 if n greater than 1.

00:18:23.310 --> 00:18:27.850
And this would be 2 raised
to n minus 1 in complexity.

00:18:27.850 --> 00:18:29.560
Now there's a
single line of code,

00:18:29.560 --> 00:18:32.510
and you all know this,
that would fix this.

00:18:32.510 --> 00:18:36.690
And that single line of code
is simply something that says,

00:18:36.690 --> 00:18:43.869
right here, look at
the lij-- and I'm

00:18:43.869 --> 00:18:44.910
writing this differently.

00:18:44.910 --> 00:18:48.860
I'm calling this now a 2D array.

00:18:48.860 --> 00:18:51.440
So that's why I have the open
brackets and close brackets.

00:18:51.440 --> 00:18:53.380
So I'm overloading l here.

00:18:53.380 --> 00:18:55.920
But it's a 2D
array that is going

00:18:55.920 --> 00:19:03.420
to essentially be a cache for
the subproblem solution values.

00:19:03.420 --> 00:19:07.500
And then if you want to do the
backtracing to actually compute

00:19:07.500 --> 00:19:09.220
the solution, you
could certainly

00:19:09.220 --> 00:19:12.310
have that as an additional
record that's connected

00:19:12.310 --> 00:19:14.070
to this very same value.

00:19:14.070 --> 00:19:17.900
But that's implementation,
and we won't really go there.

00:19:17.900 --> 00:19:26.990
So look at lij and don't
recurse if lij already computed.

00:19:32.270 --> 00:19:34.920
OK.

00:19:34.920 --> 00:19:37.180
So that's important to remember.

00:19:37.180 --> 00:19:41.900
Now, if you actually put that,
the cache lookup, hash table

00:19:41.900 --> 00:19:45.160
lookup, array lookup,
whatever you want to call it,

00:19:45.160 --> 00:19:48.740
out there, then what you
said is exactly correct.

00:19:48.740 --> 00:19:56.740
So our formula for computing
the complexity of a DP,

00:19:56.740 --> 00:19:59.360
that you've seen
a bunch of times

00:19:59.360 --> 00:20:01.930
and I mentioned in the
very first lecture as well,

00:20:01.930 --> 00:20:10.860
is number of
subproblems times time

00:20:10.860 --> 00:20:18.920
to solve each
subproblem assuming

00:20:18.920 --> 00:20:28.220
or given that smaller
ones are solved

00:20:28.220 --> 00:20:30.760
or the lookup is Order 1.

00:20:30.760 --> 00:20:31.610
So lookup.

00:20:37.520 --> 00:20:39.020
Now you could say
that hash table

00:20:39.020 --> 00:20:42.180
lookup is Order 1 on average,
et cetera, et cetera.

00:20:42.180 --> 00:20:45.170
So what actually happens
in the worst case,

00:20:45.170 --> 00:20:48.610
in this particular
case and in most DPs,

00:20:48.610 --> 00:20:53.160
you can do things
like perfect caching

00:20:53.160 --> 00:20:55.170
or, something that's even
simpler in this case,

00:20:55.170 --> 00:20:56.610
is just a 2D array.

00:20:56.610 --> 00:20:59.070
There's not going to be any
collisions if you just use i

00:20:59.070 --> 00:21:00.810
and j as the indices
to the array.

00:21:00.810 --> 00:21:05.390
So you will definitely get an
Order 1 lookup in this case,

00:21:05.390 --> 00:21:08.510
in most problems
we'll look at in 046.

00:21:08.510 --> 00:21:14.280
So if we just do that
computation, which

00:21:14.280 --> 00:21:16.580
my friend over here
just described,

00:21:16.580 --> 00:21:19.640
you do get your theta n
squared, because you have

00:21:19.640 --> 00:21:22.040
theta n squared subproblems.

00:21:22.040 --> 00:21:29.400
And time to solve
each subproblem, given

00:21:29.400 --> 00:21:31.640
that the smaller
ones are solved,

00:21:31.640 --> 00:21:34.070
is simply going to
be a computation

00:21:34.070 --> 00:21:37.820
of a max and an addition.

00:21:37.820 --> 00:21:40.600
So all of that is theta
1, because you're not

00:21:40.600 --> 00:21:43.390
counting the recursive calls.

00:21:43.390 --> 00:21:46.610
So this is our first example.

00:21:46.610 --> 00:21:48.560
I'm done with it.

00:21:48.560 --> 00:21:50.760
Any questions about it?

00:21:50.760 --> 00:21:54.746
Any questions about
DP in general?

00:21:54.746 --> 00:21:56.500
All right, good.

00:21:56.500 --> 00:22:00.440
So little bit of review there.

00:22:00.440 --> 00:22:02.860
Not a particularly
complicated question.

00:22:02.860 --> 00:22:06.600
Let's go to a different
question corresponding

00:22:06.600 --> 00:22:09.570
to optimal binary search trees.

00:22:09.570 --> 00:22:11.854
It's a very different question.

00:22:11.854 --> 00:22:13.270
I don't think I
need this anymore.

00:22:17.020 --> 00:22:18.724
And it's kind of
cute in its own way.

00:22:18.724 --> 00:22:20.890
One of things that's
interesting about this question

00:22:20.890 --> 00:22:27.150
is it seems like a greedy
algorithm should work.

00:22:27.150 --> 00:22:31.460
And we'll talk about that, as
to why the greedy algorithm

00:22:31.460 --> 00:22:33.010
doesn't quite work.

00:22:33.010 --> 00:22:36.050
So it's kind of similar
to the interval scheduling

00:22:36.050 --> 00:22:38.520
and the weighted interval
scheduling problem

00:22:38.520 --> 00:22:42.990
that we had back
in February, where

00:22:42.990 --> 00:22:46.300
the regular interval scheduling
problem, greedy worked,

00:22:46.300 --> 00:22:47.740
earliest finish time worked.

00:22:47.740 --> 00:22:49.480
But when it came
to weights, we had

00:22:49.480 --> 00:22:53.550
to graduate to
dynamic programming.

00:22:53.550 --> 00:22:59.460
So here's our second
problem, optimal BSTs.

00:22:59.460 --> 00:23:02.960
So what is an optimal BST?

00:23:02.960 --> 00:23:10.590
We have a bunch of keys that
we want to store in the BST, K1

00:23:10.590 --> 00:23:12.020
through Kn.

00:23:12.020 --> 00:23:15.540
And we'll assume that
the way this is set up

00:23:15.540 --> 00:23:19.440
is that K1 is less than K2,
da, da, da, less than Kn.

00:23:19.440 --> 00:23:22.240
And just to make our life
easier in our examples,

00:23:22.240 --> 00:23:26.260
we just assume that Ki equals i.

00:23:26.260 --> 00:23:29.510
That's not necessarily
required for anything

00:23:29.510 --> 00:23:30.520
we're going to do next.

00:23:30.520 --> 00:23:32.850
It's just for the
sake of examples

00:23:32.850 --> 00:23:35.080
and keeping things manageable.

00:23:35.080 --> 00:23:37.080
So I got a bunch of keys.

00:23:37.080 --> 00:23:40.670
And clearly there are many
different binary search trees

00:23:40.670 --> 00:23:45.460
that can come, whether they're
balanced or unbalanced.

00:23:45.460 --> 00:23:47.550
Many different
binary search trees

00:23:47.550 --> 00:23:52.070
can be consistent with
a given set of keys.

00:23:52.070 --> 00:23:55.840
If I choose the root
to be Kn, then I'm

00:23:55.840 --> 00:23:58.680
going to get this
horribly unbalanced tree.

00:23:58.680 --> 00:24:00.764
If I chose the root to be
somewhere in the middle,

00:24:00.764 --> 00:24:02.263
then I'm going to
get something that

00:24:02.263 --> 00:24:04.540
looks a little better, at
least at the top level.

00:24:04.540 --> 00:24:07.780
But again, if I messed
it up at the next level,

00:24:07.780 --> 00:24:10.110
I'd get something
that's unbalanced.

00:24:10.110 --> 00:24:13.200
So there's clearly
many different BSTs.

00:24:13.200 --> 00:24:15.300
I'm not talking about
balanced BSTs here.

00:24:15.300 --> 00:24:17.870
But we're going to define an
optimality criterion that's

00:24:17.870 --> 00:24:20.720
a little bit different
from balanced BSTs,

00:24:20.720 --> 00:24:23.430
because it's going to
have this additional cost

00:24:23.430 --> 00:24:25.500
function associated
with it that corresponds

00:24:25.500 --> 00:24:28.380
to the weight of the keys.

00:24:28.380 --> 00:24:30.460
So what is that?

00:24:30.460 --> 00:24:34.890
Well, I'm going to
have weights associated

00:24:34.890 --> 00:24:41.260
with each of these keys
corresponding to W1 through Wn.

00:24:41.260 --> 00:24:49.490
And the easiest
way to motivate you

00:24:49.490 --> 00:24:53.700
to think that these weights
are an interesting addition

00:24:53.700 --> 00:24:56.110
to this problem is to
think about these weights

00:24:56.110 --> 00:24:58.120
as being search probabilities.

00:24:58.120 --> 00:25:00.630
So what you have,
for argument's sake,

00:25:00.630 --> 00:25:06.090
is a static structure
that you've created.

00:25:06.090 --> 00:25:07.570
I mean, you could modify it.

00:25:07.570 --> 00:25:09.736
There's nothing that's
stopping you from doing that.

00:25:09.736 --> 00:25:12.750
But let's just pretend for now
that it's a static structure

00:25:12.750 --> 00:25:16.170
corresponding to this BST--
has a particular structure.

00:25:16.170 --> 00:25:20.590
And chances are you're going
to be searching for some keys

00:25:20.590 --> 00:25:22.930
more frequently than others.

00:25:22.930 --> 00:25:26.230
And the Wi's tell you
what the probabilities

00:25:26.230 --> 00:25:30.300
are in terms of searching
for a particular key Ki.

00:25:30.300 --> 00:25:32.670
So you can imagine, and
we won't have this here,

00:25:32.670 --> 00:25:35.474
that you take-- the
Wi's all sum up to 1,

00:25:35.474 --> 00:25:37.390
if you want to think of
them as probabilities.

00:25:37.390 --> 00:25:39.899
Or I'm just going
to give you numbers.

00:25:39.899 --> 00:25:42.190
I don't want to deal with
fractions, don't particularly

00:25:42.190 --> 00:25:43.620
like fractions.

00:25:43.620 --> 00:25:46.770
So you can imagine that
each probability corresponds

00:25:46.770 --> 00:25:50.740
to Wi divided by the sum
of all the Wi's, if you

00:25:50.740 --> 00:25:53.657
want all of the
probabilities to sum up to 1.

00:25:53.657 --> 00:25:55.365
So think of them as
search probabilities,

00:25:55.365 --> 00:26:00.450
because then you'll see what
the point of this exercise is.

00:26:00.450 --> 00:26:03.310
And the point of
this exercise is

00:26:03.310 --> 00:26:08.390
to find the BST T-- so
we're actually constructing

00:26:08.390 --> 00:26:09.970
a binary search tree here.

00:26:09.970 --> 00:26:12.500
So it's a little more
interesting than a subsequence,

00:26:12.500 --> 00:26:15.280
for example-- it has a richer
structure associated with it--

00:26:15.280 --> 00:26:17.690
than an exponential number
of possible binary search

00:26:17.690 --> 00:26:20.680
trees that are associated
with a given set of n keys

00:26:20.680 --> 00:26:22.620
that are all binary
search trees.

00:26:22.620 --> 00:26:25.950
They're consistent, unbalanced,
balanced-- unbalanced

00:26:25.950 --> 00:26:29.130
in one way versus another
way, et cetera, et cetera.

00:26:29.130 --> 00:26:33.220
So we want to find a
binary search tree T

00:26:33.220 --> 00:26:42.400
that minimizes sigma
i equals 1 through n.

00:26:42.400 --> 00:26:46.730
Obviously, we're going to have
this Wi that's the game here.

00:26:46.730 --> 00:26:52.710
Depth in that T-- so this
depth is for that T. What

00:26:52.710 --> 00:26:54.840
is the depth of the node?

00:26:54.840 --> 00:26:58.200
And K of i plus 1.

00:27:00.830 --> 00:27:02.760
And I'll explain
exactly what this

00:27:02.760 --> 00:27:05.710
and tell you what
precisely the depth is.

00:27:05.710 --> 00:27:09.345
But roughly speaking,
the depth of the root--

00:27:09.345 --> 00:27:10.220
not roughly speaking.

00:27:10.220 --> 00:27:13.330
The depth of the root is 0.

00:27:13.330 --> 00:27:16.490
And the depth of
1 below the root

00:27:16.490 --> 00:27:19.340
is 1, and so on and so forth.

00:27:19.340 --> 00:27:21.420
And so, as you can
see, what you want

00:27:21.420 --> 00:27:24.670
to do is collect in--
roughly speaking,

00:27:24.670 --> 00:27:29.620
you want to collect the high
weight nodes to have low depth.

00:27:29.620 --> 00:27:35.010
If Wi is high, you want
the multiplicative factor

00:27:35.010 --> 00:27:39.590
corresponding to depth T
of that node, i, i-th node,

00:27:39.590 --> 00:27:40.580
to be small.

00:27:40.580 --> 00:27:47.110
And if Wi is small, then you
don't mind the depth number

00:27:47.110 --> 00:27:48.320
to be higher.

00:27:48.320 --> 00:27:53.140
You only have a certain
number of low-depth nodes.

00:27:53.140 --> 00:27:56.580
You only have one
node of depth 0.

00:27:56.580 --> 00:28:00.810
And you have two nodes of depth
1, which means that you only

00:28:00.810 --> 00:28:03.000
have one node where
that quantity there

00:28:03.000 --> 00:28:05.757
is going to be 1, because
you're doing 0 plus 1.

00:28:05.757 --> 00:28:07.465
And you have two nodes
where the quantity

00:28:07.465 --> 00:28:10.920
is going to be 2, and
so on and so forth.

00:28:10.920 --> 00:28:13.520
So you have some room here
to play with corresponding

00:28:13.520 --> 00:28:18.380
to the BST structure, and you
want to minimize that quantity.

00:28:18.380 --> 00:28:19.330
Any questions so far?

00:28:22.090 --> 00:28:24.140
All right, good.

00:28:24.140 --> 00:28:28.020
So the search probabilities
would be an example.

00:28:28.020 --> 00:28:31.640
So in terms of a more
concrete application,

00:28:31.640 --> 00:28:35.670
you could imagine you had a
dictionary, English to French,

00:28:35.670 --> 00:28:37.670
French to English,
what have you.

00:28:37.670 --> 00:28:41.830
And there are obviously
words that are more common,

00:28:41.830 --> 00:28:45.650
let's say, in common
speech than others,

00:28:45.650 --> 00:28:48.990
and you do want to do the
translation in a dynamic way

00:28:48.990 --> 00:28:50.620
using this data structure.

00:28:50.620 --> 00:28:52.880
And you could imagine
that in this case,

00:28:52.880 --> 00:28:57.870
the search probability
of a word is associated

00:28:57.870 --> 00:29:03.630
with the occurrence of the
word, the number of times

00:29:03.630 --> 00:29:06.960
over some normalized
number of words

00:29:06.960 --> 00:29:09.180
that this particular
word occurs.

00:29:09.180 --> 00:29:11.450
And that would be the way.

00:29:11.450 --> 00:29:14.340
So it makes sense to
create a structure that

00:29:14.340 --> 00:29:16.800
minimizes that function,
because it would minimize

00:29:16.800 --> 00:29:18.890
the expected search
cost when you want

00:29:18.890 --> 00:29:21.870
to take this entire
essay, for example,

00:29:21.870 --> 00:29:25.960
and convert it from English
to French or vice versa.

00:29:25.960 --> 00:29:29.490
So this can-- if these
are search probabilities,

00:29:29.490 --> 00:29:33.340
then this would minimize--
this cost function here

00:29:33.340 --> 00:29:39.445
would minimize
expected search cost.

00:29:45.530 --> 00:29:46.420
Make sense?

00:29:46.420 --> 00:29:49.070
Yeah.

00:29:49.070 --> 00:29:52.560
So that's the definition
of the problem.

00:29:52.560 --> 00:29:56.950
And now we have to talk about
why this is complicated,

00:29:56.950 --> 00:30:01.290
why this requires
dynamic programming.

00:30:01.290 --> 00:30:05.630
Why can't we just do something
fairly straightforward,

00:30:05.630 --> 00:30:07.504
like a greedy algorithm?

00:30:07.504 --> 00:30:08.670
And so let's look into that.

00:30:25.130 --> 00:30:27.300
Let me give you a really
good sense for what's

00:30:27.300 --> 00:30:29.840
going on here with respect
to this cost function

00:30:29.840 --> 00:30:33.040
and maybe a little
abstract by giving you

00:30:33.040 --> 00:30:36.000
a couple of concrete examples.

00:30:36.000 --> 00:30:44.970
First off, we got exponentially
many trees, exponential in n.

00:30:44.970 --> 00:30:47.490
Let's say that n equals 2.

00:30:47.490 --> 00:30:49.490
So the number of nodes is 2.

00:30:49.490 --> 00:30:55.940
Then remember that I'm assuming
that the Ki's are all i's,

00:30:55.940 --> 00:30:59.670
that 1 and 2 would
be the case for n

00:30:59.670 --> 00:31:04.040
equals 2 and 1, 2, 3 for
n equals 3, et cetera.

00:31:04.040 --> 00:31:06.630
So I could have a tree
that looks like that.

00:31:06.630 --> 00:31:09.390
And I could have a tree
that looks like this.

00:31:09.390 --> 00:31:10.390
That's it.

00:31:10.390 --> 00:31:13.160
n equals 2, I got 2 trees.

00:31:13.160 --> 00:31:18.455
So in this case, my cost
function is W1 plus 2W2,

00:31:18.455 --> 00:31:21.870
and in this case, my cost
function is 2W1 plus W2.

00:31:24.720 --> 00:31:33.310
Just to be clear, what this
is the K, and it's also the i.

00:31:33.310 --> 00:31:35.360
So the numbers that
you see inside,

00:31:35.360 --> 00:31:36.920
those are the i
numbers, which happen

00:31:36.920 --> 00:31:40.030
to be equal to the Ki numbers.

00:31:40.030 --> 00:31:42.716
And the weight itself
would be the Wi.

00:31:42.716 --> 00:31:46.970
So I put W1 here, and the reason
it only gets multiplied by 1

00:31:46.970 --> 00:31:50.410
is because the depth here
is 0, and I add 1 to it.

00:31:50.410 --> 00:31:53.400
The depth here is 1,
and I add 1 to it, which

00:31:53.400 --> 00:31:56.490
is why I have a 2 out here.

00:31:56.490 --> 00:32:01.880
Being a little pedantic here
and pointing things out,

00:32:01.880 --> 00:32:04.930
because you're going to start
seeing some equations that

00:32:04.930 --> 00:32:06.630
are a little more
complicated than this,

00:32:06.630 --> 00:32:07.940
and I don't want you
to get confused as

00:32:07.940 --> 00:32:10.160
to what the weight is and
what the key number is

00:32:10.160 --> 00:32:11.340
and what the depth is.

00:32:11.340 --> 00:32:13.760
There's three things
going on here.

00:32:13.760 --> 00:32:17.770
So over here you see that
I'm looking at W1 here,

00:32:17.770 --> 00:32:19.300
which is this key.

00:32:19.300 --> 00:32:21.510
So the 1 corresponds to the 1.

00:32:21.510 --> 00:32:26.080
And this has a depth of 1, so
I put a 2 in here, and so on.

00:32:26.080 --> 00:32:28.940
So so far, so good?

00:32:28.940 --> 00:32:33.670
When you get to n equals 3,
you start getting-- well,

00:32:33.670 --> 00:32:39.550
at this point, you have 1, 2,
3, 4, 5-- you have five trees.

00:32:39.550 --> 00:32:42.300
And the trees look like this.

00:32:49.030 --> 00:32:50.850
I'll draw them
really quickly just

00:32:50.850 --> 00:32:53.460
to get a sense of
the variety here.

00:32:53.460 --> 00:32:56.950
But I won't write the
equations down for all of them.

00:33:02.899 --> 00:33:03.440
There you go.

00:33:03.440 --> 00:33:07.310
So those are the five binary
trees associated with n

00:33:07.310 --> 00:33:10.270
equals 3, the
binary search trees.

00:33:10.270 --> 00:33:13.220
And this is kind of cool.

00:33:13.220 --> 00:33:14.680
It's nice and balanced.

00:33:14.680 --> 00:33:17.250
The other ones aren't.

00:33:17.250 --> 00:33:22.450
And I'm not looking at--

00:33:22.450 --> 00:33:24.034
Should I have another one here?

00:33:24.034 --> 00:33:24.950
I guess I should have.

00:33:29.880 --> 00:33:31.530
This is a-- oh, no, no, no.

00:33:31.530 --> 00:33:33.370
So I'm not doing mirrors.

00:33:33.370 --> 00:33:35.910
So there are a
bunch of other trees

00:33:35.910 --> 00:33:39.850
that have the same equation
associated with two-- no,

00:33:39.850 --> 00:33:40.760
that's not true.

00:33:40.760 --> 00:33:42.400
Because these are it.

00:33:42.400 --> 00:33:44.400
I was going to say that
you could put 3 in here,

00:33:44.400 --> 00:33:46.680
but that wouldn't be
a binary search tree.

00:33:46.680 --> 00:33:48.510
So this is it.

00:33:48.510 --> 00:33:50.350
And we've got a bunch of trees.

00:33:50.350 --> 00:34:00.050
This one would be 2W1 plus W2
plus 2W3 by the same process

00:34:00.050 --> 00:34:04.710
that I used to show you
that W1 plus 2W2 for the n

00:34:04.710 --> 00:34:05.900
equals 2 case.

00:34:05.900 --> 00:34:07.810
You just go off, and
that's the equation.

00:34:07.810 --> 00:34:10.179
And so your goal here in
an algorithm-- clearly

00:34:10.179 --> 00:34:11.830
this is not the
algorithm you want

00:34:11.830 --> 00:34:14.739
to enumerate all the
exponentially many trees,

00:34:14.739 --> 00:34:16.940
compute the equations
for each of those trees,

00:34:16.940 --> 00:34:18.250
and pick the minimum.

00:34:18.250 --> 00:34:22.690
I mean, that would work, but
it would take exponential time.

00:34:22.690 --> 00:34:24.380
But that's what
you have to do now.

00:34:24.380 --> 00:34:25.920
That's the goal.

00:34:25.920 --> 00:34:30.350
You absolutely want the best
possible three that has,

00:34:30.350 --> 00:34:32.230
for the given Wi's
that you're going

00:34:32.230 --> 00:34:35.340
to be assigned as
constants, you do

00:34:35.340 --> 00:34:40.719
want to find the one tree
that has the minimum sum,

00:34:40.719 --> 00:34:42.760
and you want to do
that for arbitrary n,

00:34:42.760 --> 00:34:46.830
and you want to do that
in polynomial time.

00:34:46.830 --> 00:34:53.370
So the first thing that you
do when you have something

00:34:53.370 --> 00:34:58.590
like this is forgetting
about the fact

00:34:58.590 --> 00:35:00.340
that we're in a
dynamic programming

00:35:00.340 --> 00:35:04.910
lecture or a dynamic programming
module of this class,

00:35:04.910 --> 00:35:07.970
when you see a problem like
this in the real world,

00:35:07.970 --> 00:35:11.320
you want to think about whether
a greedy algorithm would work

00:35:11.320 --> 00:35:12.860
or not.

00:35:12.860 --> 00:35:17.100
And you don't want to go off
and build this dynamic program

00:35:17.100 --> 00:35:20.140
solution, which is,
chances are, going

00:35:20.140 --> 00:35:25.550
to be more inefficient then
a greedy solution, which,

00:35:25.550 --> 00:35:30.660
if it produces the optimum
answer, is the best way to go.

00:35:30.660 --> 00:35:35.360
So an obvious greedy
solution would

00:35:35.360 --> 00:35:41.220
be to pick K of r in
some greedy fashion.

00:35:45.000 --> 00:35:48.180
And what is the obvious
way of picking K of r

00:35:48.180 --> 00:35:51.200
to try and get a
greedy solution that

00:35:51.200 --> 00:35:53.510
at least attempts to
minimize that cost function

00:35:53.510 --> 00:35:54.675
that we have there?

00:35:54.675 --> 00:35:55.805
AUDIENCE: Highest weight.

00:35:55.805 --> 00:35:57.180
PROFESSOR: Highest
weight, right?

00:35:57.180 --> 00:35:59.430
So just pick K of r
to be highest weight.

00:35:59.430 --> 00:36:04.260
Because that goes back to what
I said about if Wi is high,

00:36:04.260 --> 00:36:08.170
you want this value
here to be small.

00:36:08.170 --> 00:36:10.670
So that's essentially
your greedy heuristic.

00:36:10.670 --> 00:36:13.390
So K of r should be picked
in a greedy fashion.

00:36:13.390 --> 00:36:14.930
So what you do is
you pick K of r

00:36:14.930 --> 00:36:17.410
as the root in this
particular problem.

00:36:17.410 --> 00:36:20.190
And you could certainly
apply this greedy technique

00:36:20.190 --> 00:36:22.230
recursively.

00:36:22.230 --> 00:36:24.720
So you do that for
every subproblem

00:36:24.720 --> 00:36:26.220
that you find
because when you do

00:36:26.220 --> 00:36:30.860
this choice of the root for
Kr in the current problem

00:36:30.860 --> 00:36:35.310
that you have, you immediately
split the keys into two

00:36:35.310 --> 00:36:40.380
sets, the sets that have to
go on the left-hand side of Kr

00:36:40.380 --> 00:36:43.340
and the sets that have to go
on the right-hand side of Kr.

00:36:43.340 --> 00:36:45.360
So in this case,
you know that you're

00:36:45.360 --> 00:36:50.110
going to have a bunch of
keys here that correspond

00:36:50.110 --> 00:36:57.880
to Ki to K4, and
over here, you're

00:36:57.880 --> 00:37:00.370
going to have-- oh, Kr
minus 1, I should say,

00:37:00.370 --> 00:37:02.500
because you already
have Kr out there.

00:37:02.500 --> 00:37:10.780
And the keys here are going to
be Kr plus 1 to Kj, if overall

00:37:10.780 --> 00:37:29.415
I'm going to say that eij is the
cost of the optimal BST on Ki,

00:37:29.415 --> 00:37:37.090
Ki plus 1, all the way to Kj.

00:37:40.160 --> 00:37:43.130
So I'm kind of already
setting myself up here

00:37:43.130 --> 00:37:45.102
for dynamic programming.

00:37:45.102 --> 00:37:46.560
But it also makes
sense in the case

00:37:46.560 --> 00:37:50.250
of a greedy algorithm, where
this greedy heuristic is going

00:37:50.250 --> 00:37:52.510
to be applied recursively.

00:37:52.510 --> 00:37:56.550
So initially, you're
going to have E(1, n)--

00:37:56.550 --> 00:37:59.930
so if you want to
compute E(1, n),

00:37:59.930 --> 00:38:05.830
which is the cost of the optimal
BST on the original problem,

00:38:05.830 --> 00:38:08.970
all the way from 1 to n,
you're going to look at it,

00:38:08.970 --> 00:38:13.650
and you're going to say, I
have a bunch of keys here

00:38:13.650 --> 00:38:17.430
of different weights that
correspond to K1 through Kn.

00:38:17.430 --> 00:38:19.860
I'm going to pick the
Kr that corresponds

00:38:19.860 --> 00:38:21.740
to the maximum
weight, and I'm going

00:38:21.740 --> 00:38:25.160
to use that as the
root node, and I'm

00:38:25.160 --> 00:38:26.590
going to stick that up there.

00:38:26.590 --> 00:38:30.590
And the reason I did
that is because I believe

00:38:30.590 --> 00:38:33.490
that this greedy heuristic
is going to work,

00:38:33.490 --> 00:38:36.660
where this maximum
weight node should have

00:38:36.660 --> 00:38:40.140
the absolute minimum depth.

00:38:40.140 --> 00:38:41.300
So I stick that up there.

00:38:41.300 --> 00:38:46.620
And then my BST invariant tells
me that Ki through Kr minus 1--

00:38:46.620 --> 00:38:49.490
remember, these are
sorted, and they

00:38:49.490 --> 00:38:53.966
go in increasing order,
as I have up here.

00:38:53.966 --> 00:38:55.590
You're going to have
those on the left,

00:38:55.590 --> 00:38:57.720
and you're going to
have those on the right.

00:38:57.720 --> 00:38:59.790
And then you've got to
go solve this problem.

00:38:59.790 --> 00:39:02.880
And you could certainly
apply the greedy heuristic

00:39:02.880 --> 00:39:04.440
to solve this problem.

00:39:04.440 --> 00:39:09.480
You could go essentially
find the K that

00:39:09.480 --> 00:39:11.460
has the highest weight.

00:39:11.460 --> 00:39:14.850
So you look at Wi
through Wr minus 1,

00:39:14.850 --> 00:39:18.210
and you find the K that
has the highest weight.

00:39:18.210 --> 00:39:19.940
Actually, you're not
going midway here.

00:39:19.940 --> 00:39:25.100
It's quite possible
that Kr is K of n.

00:39:25.100 --> 00:39:27.320
It just happens to
be Kr is K of n.

00:39:27.320 --> 00:39:32.380
So that means that you have the
highest weight node up here,

00:39:32.380 --> 00:39:35.410
but it's also the biggest key.

00:39:35.410 --> 00:39:37.960
So all of the nodes are
going to be on the left.

00:39:37.960 --> 00:39:40.760
So this greedy heuristic-- and
now you're starting to see,

00:39:40.760 --> 00:39:42.450
maybe there's a problem here.

00:39:42.450 --> 00:39:48.560
Because if you have a situation
where the highest weight

00:39:48.560 --> 00:39:51.720
node is also the
largest node, you're

00:39:51.720 --> 00:39:55.790
going to get a pretty
unbalanced tree.

00:39:55.790 --> 00:39:59.180
So I can tell you that
greedy doesn't work.

00:39:59.180 --> 00:40:02.410
And when I gave this
lecture, I think

00:40:02.410 --> 00:40:05.150
it was a couple of years
ago, I made that statement,

00:40:05.150 --> 00:40:11.440
and this annoying student
asked me for an example.

00:40:11.440 --> 00:40:13.950
And I couldn't come up with one.

00:40:13.950 --> 00:40:18.170
And so I kind of bailed
on it, went on, completely

00:40:18.170 --> 00:40:19.870
dissatisfied, of course.

00:40:19.870 --> 00:40:23.310
And by the end of the
lecture, the same student

00:40:23.310 --> 00:40:25.370
came up with a counter-example.

00:40:25.370 --> 00:40:28.040
So I'm going to have
put that up here

00:40:28.040 --> 00:40:37.150
and thank the student who
sent me an email about it.

00:40:37.150 --> 00:40:40.060
And so here's a
concrete example.

00:40:40.060 --> 00:40:43.240
It turns out I was trying
to get a tree node example

00:40:43.240 --> 00:40:46.470
for a few minutes and failed.

00:40:46.470 --> 00:40:49.610
It's, I think,
impossible-- I haven't

00:40:49.610 --> 00:40:52.650
proved this-- to
find a tree node

00:40:52.650 --> 00:40:56.720
example with arbitrary weights
for which the greedy algorithm

00:40:56.720 --> 00:40:58.380
fails.

00:40:58.380 --> 00:41:00.860
But four nodes, it fails.

00:41:00.860 --> 00:41:02.770
So that's the good news.

00:41:02.770 --> 00:41:07.635
So here's the example,
thanks to Nick Davis.

00:41:13.900 --> 00:41:15.090
And it looks like this.

00:41:45.000 --> 00:41:47.620
So I claim that the
greedy algorithm

00:41:47.620 --> 00:41:56.250
for the problem that is given
to me would produce this BST.

00:41:56.250 --> 00:41:59.790
And the reason for
that is simple.

00:41:59.790 --> 00:42:02.270
The highest weight
node happens to be node

00:42:02.270 --> 00:42:04.320
2, which has a weight of 10.

00:42:04.320 --> 00:42:07.567
So I would pick that, and
I would stick that up here,

00:42:07.567 --> 00:42:09.150
which means, of
course, that I'm going

00:42:09.150 --> 00:42:11.360
to have to have 1 on
this side, and I'm

00:42:11.360 --> 00:42:14.400
going to have to have 4
and 3 on the other side.

00:42:14.400 --> 00:42:19.740
And since 4 has a higher weight
than 3, I'd pick that first.

00:42:19.740 --> 00:42:22.480
And then 3 would
have to go over here.

00:42:22.480 --> 00:42:28.510
So if I go do the math, the
cost is going to be 1 times 2--

00:42:28.510 --> 00:42:30.420
and I'll explain what
these numbers are.

00:42:30.420 --> 00:42:35.360
I did tell you it was going
to get a little cluttered here

00:42:35.360 --> 00:42:37.350
with lots of numbers.

00:42:37.350 --> 00:42:39.610
But if you keep that
equation in mind,

00:42:39.610 --> 00:42:42.200
then this should all work out.

00:42:42.200 --> 00:42:44.190
So what do I have here?

00:42:44.190 --> 00:42:48.960
I'm just computing-- this is W1.

00:42:48.960 --> 00:42:52.800
So you see the first numbers in
each of these are the weights.

00:42:52.800 --> 00:42:55.230
And so this would
be W2 and et cetera.

00:42:55.230 --> 00:42:58.694
And you can see that
this is at depth 1, which

00:42:58.694 --> 00:43:00.360
means I have to have
2 here, because I'm

00:43:00.360 --> 00:43:01.790
adding 1 to the depth.

00:43:01.790 --> 00:43:04.720
So I have 1 times 2, 10
times 1, because that's

00:43:04.720 --> 00:43:07.580
at the root, 9
times 2, et cetera.

00:43:07.580 --> 00:43:10.020
And I get 54.

00:43:10.020 --> 00:43:12.180
It turns out the
optimum tree-- you

00:43:12.180 --> 00:43:20.210
can do better than that if you
pick 3, and you go like this.

00:43:28.670 --> 00:43:32.700
And so what you have here
is the cost equals 1 times

00:43:32.700 --> 00:43:41.215
3 plus 10 times 2 plus 8 times
1 plus 9 times 2, and that's 49.

00:43:45.290 --> 00:43:47.410
So I'll let you look at that.

00:43:47.410 --> 00:43:51.100
The bottom line is
because of the way

00:43:51.100 --> 00:43:54.310
the weights are set
up here, you really

00:43:54.310 --> 00:43:59.530
want to use the top
three spots, which

00:43:59.530 --> 00:44:04.080
have that the minimum depth,
for the highest weight nodes.

00:44:04.080 --> 00:44:09.980
And so you can see that I could
make these weights arbitrary,

00:44:09.980 --> 00:44:12.890
obviously, and I could
break a greedy algorithm

00:44:12.890 --> 00:44:14.930
as this little example shows.

00:44:14.930 --> 00:44:17.060
So we got no recurs here.

00:44:17.060 --> 00:44:18.560
We got to do some more work.

00:44:18.560 --> 00:44:21.177
We're going to have to use
DP to solve this problem.

00:44:21.177 --> 00:44:23.010
The good news is DP
does solve this problem.

00:44:26.490 --> 00:44:29.340
So let's take a look
at the decomposition.

00:44:29.340 --> 00:44:32.060
And as with anything
else, the key

00:44:32.060 --> 00:44:38.090
is the step that
corresponds to breaking up

00:44:38.090 --> 00:44:43.860
the original problem
into two parts or more

00:44:43.860 --> 00:44:46.620
that essentially give you
this sort of decomposition.

00:44:46.620 --> 00:44:48.200
And we don't quite know.

00:44:48.200 --> 00:44:50.440
So this is really the
key question here.

00:44:50.440 --> 00:44:53.640
We don't quite know what the
root node is going to be.

00:44:53.640 --> 00:44:59.310
So what do we do when we
don't know what to do?

00:44:59.310 --> 00:45:03.210
What do we do in DP when
we don't know what to do?

00:45:03.210 --> 00:45:06.035
This is a very
profound question.

00:45:06.035 --> 00:45:06.660
What do you do?

00:45:06.660 --> 00:45:07.326
AUDIENCE: Guess.

00:45:07.326 --> 00:45:08.510
PROFESSOR: You guess.

00:45:08.510 --> 00:45:12.940
And not only do yo guess,
you guess all outcomes.

00:45:12.940 --> 00:45:14.720
You say, is it going
to come up heads?

00:45:14.720 --> 00:45:15.928
Is it going to come up tails?

00:45:15.928 --> 00:45:17.810
I'll guess both.

00:45:17.810 --> 00:45:18.520
You have a die.

00:45:18.520 --> 00:45:22.220
It's going to get rolled,
a 1, 2, 3, 4, 5, 6.

00:45:22.220 --> 00:45:23.930
Guess them all, right?

00:45:23.930 --> 00:45:26.940
So if you're going to have to
guess that the root node could

00:45:26.940 --> 00:45:31.980
be any of the keys,
and it still--

00:45:31.980 --> 00:45:34.090
I mean there's a linear
number of guesses there.

00:45:34.090 --> 00:45:35.190
That's the good news.

00:45:35.190 --> 00:45:36.997
It's going to stay
polynomial time.

00:45:36.997 --> 00:45:38.330
So we're going to have to guess.

00:45:38.330 --> 00:45:40.720
And once you do that
guess, it turns out

00:45:40.720 --> 00:45:43.320
that decomposition
that you see up there

00:45:43.320 --> 00:45:45.400
is exactly what we want.

00:45:45.400 --> 00:45:46.870
It's just that the
greedy algorithm

00:45:46.870 --> 00:45:50.210
didn't bother with all of
these different guesses.

00:45:50.210 --> 00:45:52.910
And the DP is different
from the greedy algorithm

00:45:52.910 --> 00:45:55.910
because it's going to do
each of those guesses,

00:45:55.910 --> 00:45:58.090
and it's going to pick the
best one that comes out

00:45:58.090 --> 00:45:59.480
of all of those guesses.

00:45:59.480 --> 00:46:02.500
So it's really not that
different from greedy.

00:46:02.500 --> 00:46:06.380
So we'll keep that up
there, leave that here.

00:46:06.380 --> 00:46:07.990
Let's go over here.

00:46:07.990 --> 00:46:09.590
So the recursion
here is not going

00:46:09.590 --> 00:46:16.330
to be that hard, once you have
gotten the insight that you

00:46:16.330 --> 00:46:19.900
just have to go make a linear
number of guesses corresponding

00:46:19.900 --> 00:46:22.171
to the root node for your
particular subproblem,

00:46:22.171 --> 00:46:23.795
and obviously this
happens recursively.

00:46:26.870 --> 00:46:29.230
So there's a little
something here

00:46:29.230 --> 00:46:30.985
that that I'll point
out with respect

00:46:30.985 --> 00:46:33.590
to writing these equations out.

00:46:33.590 --> 00:46:36.270
So what I have here,
just to be clear,

00:46:36.270 --> 00:46:37.900
is what I wrote up there.

00:46:37.900 --> 00:46:40.120
Even when I was talking
about the greedy algorithm,

00:46:40.120 --> 00:46:43.190
I had the subproblems defined.

00:46:43.190 --> 00:46:46.280
So the original problem
is E1 through n.

00:46:46.280 --> 00:46:51.170
The subproblems
correspond to eij.

00:46:51.170 --> 00:46:55.290
And given a subproblem,
once I make a root choice,

00:46:55.290 --> 00:46:59.660
I get two subproblems that
result from the root choice.

00:46:59.660 --> 00:47:02.060
And each of those
two subproblems

00:47:02.060 --> 00:47:05.040
is going to be
something-- and this

00:47:05.040 --> 00:47:07.800
is something to keep in mind as
we write these equations out--

00:47:07.800 --> 00:47:11.380
they're going to be one
level below the root.

00:47:11.380 --> 00:47:15.320
So keep in mind that the
original eij subproblem

00:47:15.320 --> 00:47:19.560
corresponded to this
level, but that Ei

00:47:19.560 --> 00:47:28.940
r minus 1 problem and
the E r plus 1j problem

00:47:28.940 --> 00:47:33.640
are at one level below.

00:47:33.640 --> 00:47:37.730
So keep that in mind as we
write these equations up.

00:47:37.730 --> 00:47:42.000
And so what I want to do here
is just write the recurrence.

00:47:42.000 --> 00:47:44.410
And after that, things
become fairly mechanical.

00:47:44.410 --> 00:47:46.710
The fun is in the recurrence.

00:47:46.710 --> 00:47:52.990
So I got Wi if i equals j.

00:47:52.990 --> 00:47:54.590
And so I'm at this level.

00:47:54.590 --> 00:48:00.330
And if I just have one node
left, then at that level,

00:48:00.330 --> 00:48:04.440
I'm going to pay the weight
associated with that node,

00:48:04.440 --> 00:48:07.720
and I'm going to have
to do a certain amount

00:48:07.720 --> 00:48:12.940
of multiplication here
with respect to the depth.

00:48:12.940 --> 00:48:17.790
But I'm just talking about
eij as the subproblem weight,

00:48:17.790 --> 00:48:19.580
just focusing in
on that problem.

00:48:19.580 --> 00:48:22.380
So if I only have one
node, it's the root node.

00:48:22.380 --> 00:48:24.740
And that weight
is going to be Wi,

00:48:24.740 --> 00:48:27.110
because the root
node has depth of 0,

00:48:27.110 --> 00:48:29.100
and I'm going to add 1 to it.

00:48:29.100 --> 00:48:32.427
So for that
subproblem, I got Wi.

00:48:32.427 --> 00:48:34.760
Keep that in mind, because
that's the only subtlety here

00:48:34.760 --> 00:48:37.620
with respect to these
equations, making sure

00:48:37.620 --> 00:48:40.950
that our actual cost
function that we're computing

00:48:40.950 --> 00:48:45.100
has the correct
depth multiplicands

00:48:45.100 --> 00:48:47.500
associated with it.

00:48:47.500 --> 00:48:51.410
So then we have our
linear guessing.

00:48:51.410 --> 00:48:55.110
And I might have said
max at some point.

00:48:55.110 --> 00:48:57.240
We want to get the min here.

00:48:57.240 --> 00:48:59.610
And I had minimize
here, so I think

00:48:59.610 --> 00:49:01.660
I wrote things down
correct, but at some point,

00:49:01.660 --> 00:49:04.610
I think I might have said
we want to maximize cost.

00:49:04.610 --> 00:49:07.340
But we do want to minimize
cost here corresponding

00:49:07.340 --> 00:49:10.420
to the expected search.

00:49:10.420 --> 00:49:14.790
So we're doing a linear,
and we're doing a min.

00:49:14.790 --> 00:49:16.900
And we're going
to go off and look

00:49:16.900 --> 00:49:21.460
at each of the different
nodes as being the root,

00:49:21.460 --> 00:49:24.030
just like we discussed.

00:49:24.030 --> 00:49:29.420
And what I'm going to do here is
I'm going to simply say, first,

00:49:29.420 --> 00:49:33.440
that I'm going to
look at Ei r minus 1,

00:49:33.440 --> 00:49:42.270
which corresponds to this, and
I'm going to have plus E of r

00:49:42.270 --> 00:49:46.520
plus 1, j.

00:49:46.520 --> 00:49:54.300
And at this point,
I don't quite have

00:49:54.300 --> 00:49:57.980
what I want because
I haven't actually

00:49:57.980 --> 00:50:05.230
taken into account the fact that
the depth of the Ei r minus 1

00:50:05.230 --> 00:50:11.090
and the r plus 1j is
1 more than the eij.

00:50:11.090 --> 00:50:13.190
So it's 1 more than that.

00:50:13.190 --> 00:50:15.110
And I also haven't taken
into account the fact

00:50:15.110 --> 00:50:21.740
that, in this case, I definitely
need to add a Wi as well.

00:50:21.740 --> 00:50:26.340
Because the root node is part
of my solution in both cases.

00:50:26.340 --> 00:50:30.021
In one case, it ended my
solution, the top case.

00:50:30.021 --> 00:50:31.770
But in this case, it's
also the root node,

00:50:31.770 --> 00:50:33.478
as you can see over
on the left, and I've

00:50:33.478 --> 00:50:34.720
got to add that in there.

00:50:34.720 --> 00:50:38.680
So I definitely need
to add a Wi here.

00:50:38.680 --> 00:50:40.290
And what else do I need to add?

00:50:44.510 --> 00:50:46.580
From a standpoint
of the weights,

00:50:46.580 --> 00:50:53.443
what other weights do I
need to add to this line?

00:50:53.443 --> 00:50:54.350
Yeah?

00:50:54.350 --> 00:50:55.213
Go ahead.

00:50:55.213 --> 00:50:57.855
AUDIENCE: First of all,
shouldn't that be a Wr?

00:50:57.855 --> 00:50:59.480
PROFESSOR: First of
all, that should be

00:50:59.480 --> 00:51:01.165
a Wr, you're exactly correct.

00:51:01.165 --> 00:51:03.590
AUDIENCE: And you want
to add all the weights.

00:51:03.590 --> 00:51:06.560
PROFESSOR: And you want to
add all the weights, right.

00:51:06.560 --> 00:51:09.081
You're exactly right.

00:51:09.081 --> 00:51:10.580
I have two more
Frisbees, but I need

00:51:10.580 --> 00:51:12.750
to use them for something else.

00:51:12.750 --> 00:51:15.110
So you get one next time.

00:51:15.110 --> 00:51:18.910
Or do I have more than that?

00:51:18.910 --> 00:51:19.600
No, no.

00:51:19.600 --> 00:51:21.650
These are precious
Frisbees here.

00:51:21.650 --> 00:51:22.200
Sorry, man.

00:51:25.250 --> 00:51:27.280
And you corrected me, too.

00:51:27.280 --> 00:51:27.900
Shoot.

00:51:27.900 --> 00:51:30.990
This is sad.

00:51:30.990 --> 00:51:33.680
So that needed to be a Wr.

00:51:33.680 --> 00:51:37.920
But you also need to add up all
of the nodes that are in here,

00:51:37.920 --> 00:51:40.630
because they're one more level.

00:51:40.630 --> 00:51:43.950
And now you see why
I made the mistake.

00:51:43.950 --> 00:51:46.470
I don't usually make mistakes.

00:51:46.470 --> 00:51:49.610
But what I really
want-- actually it's

00:51:49.610 --> 00:51:52.610
more like-- I don't
know, a few per lecture.

00:51:52.610 --> 00:51:54.035
Constant order one mistakes.

00:51:56.700 --> 00:52:02.560
I'm going to say this is
Wi, j, where Wi, j is simply

00:52:02.560 --> 00:52:04.703
the sum of all of the
weights from i to j.

00:52:17.690 --> 00:52:20.580
And this makes perfect
sense, because the nice thing

00:52:20.580 --> 00:52:22.610
is that I don't even need
to put an r in there.

00:52:25.220 --> 00:52:27.686
I could choose a particular r.

00:52:27.686 --> 00:52:29.300
Wr will be in there.

00:52:29.300 --> 00:52:31.920
But all of the other nodes are
going to be in there anyway.

00:52:31.920 --> 00:52:34.980
So it doesn't really
matter what the r selection

00:52:34.980 --> 00:52:37.310
is corresponding
to this term here.

00:52:37.310 --> 00:52:41.510
I will put it inside
the minimization.

00:52:41.510 --> 00:52:43.500
This bracket here
is closed with that,

00:52:43.500 --> 00:52:45.140
but you can pull that
out, because that

00:52:45.140 --> 00:52:46.650
doesn't depend on r.

00:52:46.650 --> 00:52:50.360
It's just going to be there
for all of the cases, all

00:52:50.360 --> 00:52:52.220
of the guesses.

00:52:52.220 --> 00:52:53.811
So that's it.

00:52:53.811 --> 00:52:57.020
That's our recurrence
relationship corresponding

00:52:57.020 --> 00:53:02.840
to the DP for this
particular problem.

00:53:02.840 --> 00:53:05.960
You can go figure out
what the complexity is.

00:53:05.960 --> 00:53:09.260
I have other things to
do, so we'll move on.

00:53:09.260 --> 00:53:11.220
But you can do the
same things, and these

00:53:11.220 --> 00:53:14.850
are fairly mechanical at this
point to go write code for it,

00:53:14.850 --> 00:53:17.290
trace the solution to get
the optimum binary search

00:53:17.290 --> 00:53:21.170
tree, yadda, yadda, yadda.

00:53:21.170 --> 00:53:23.980
Any questions about this
equation or anything else?

00:53:23.980 --> 00:53:25.172
Do people get that?

00:53:25.172 --> 00:53:25.980
Yeah, go ahead.

00:53:25.980 --> 00:53:28.300
AUDIENCE: What is
the depth input?

00:53:28.300 --> 00:53:32.290
PROFESSOR: So the depth is
getting added by the weights.

00:53:32.290 --> 00:53:35.630
So basically what's happening
is that as I go deeper

00:53:35.630 --> 00:53:39.520
into the recursion, I'm adding
the weights and potentially

00:53:39.520 --> 00:53:42.750
multiple times,
depending on the depth.

00:53:42.750 --> 00:53:46.062
So if you really think
about it, this Wij,

00:53:46.062 --> 00:53:48.300
I added all of these weights.

00:53:48.300 --> 00:53:50.520
But when you go
into this recursion,

00:53:50.520 --> 00:53:53.120
into the ei of r
minus 1, well, you're

00:53:53.120 --> 00:53:57.330
going to see i to r minus 1 in
the next level of recursion.

00:53:57.330 --> 00:54:00.190
So you would have
added the weight again.

00:54:00.190 --> 00:54:02.810
So it's not the case
that the weights are only

00:54:02.810 --> 00:54:04.130
appearing once.

00:54:04.130 --> 00:54:07.070
They're, in fact,
appearing this many times.

00:54:07.070 --> 00:54:09.580
So that's what kind of
cute about this, the way

00:54:09.580 --> 00:54:10.310
we wrote it.

00:54:13.237 --> 00:54:14.070
Any other questions?

00:54:16.610 --> 00:54:17.610
All right, good.

00:54:17.610 --> 00:54:19.640
So we're done with that.

00:54:19.640 --> 00:54:21.740
So one last example.

00:54:21.740 --> 00:54:26.040
This is, again, a little bit
different from the examples

00:54:26.040 --> 00:54:30.670
of DP we've looked at up until
now, because it's a game.

00:54:30.670 --> 00:54:33.926
And you have an
opponent, and you

00:54:33.926 --> 00:54:35.550
have to figure out
what the opponent is

00:54:35.550 --> 00:54:41.170
going to do and try to win.

00:54:41.170 --> 00:54:43.030
I suppose you could
try to lose as well.

00:54:43.030 --> 00:54:46.700
But let's assume here, same
thing with minimization

00:54:46.700 --> 00:54:49.300
and maximization,
most of the time

00:54:49.300 --> 00:54:51.600
you can invert these
cost functions,

00:54:51.600 --> 00:54:53.750
and DP will still work.

00:54:53.750 --> 00:54:57.620
But let's assume here that
you want to win this game.

00:54:57.620 --> 00:55:00.280
So the game is an
alternating coins game

00:55:00.280 --> 00:55:13.040
where we have a row of n
coins of values V1 through Vn.

00:55:13.040 --> 00:55:16.620
These are not necessarily
in any particular order.

00:55:16.620 --> 00:55:18.630
And n is even.

00:55:18.630 --> 00:55:26.280
And the goal here is
select the outer coins.

00:55:26.280 --> 00:55:39.900
So select either the first
our last coin from the row,

00:55:39.900 --> 00:55:43.570
and then the opponent plays.

00:55:43.570 --> 00:55:52.250
Remove permanently, but
add it to your value

00:55:52.250 --> 00:55:53.240
and receive the value.

00:55:57.980 --> 00:56:03.170
So I need two volunteers
to play this game.

00:56:03.170 --> 00:56:06.290
And you want to
maximize the value.

00:56:06.290 --> 00:56:09.220
The winner gets a blue Frisbee.

00:56:09.220 --> 00:56:12.000
The loser gets a purple
Frisbee, because blue

00:56:12.000 --> 00:56:14.020
is greater than purple.

00:56:14.020 --> 00:56:16.540
And you might ask, why is that.

00:56:16.540 --> 00:56:21.220
Well, if you went to a beach,
and you saw water this color,

00:56:21.220 --> 00:56:24.610
and you went to another beach,
and you saw water this color,

00:56:24.610 --> 00:56:26.490
which beach would you pick?

00:56:26.490 --> 00:56:26.990
Right?

00:56:26.990 --> 00:56:28.030
This is Cozumel.

00:56:28.030 --> 00:56:30.790
This is Boston Harbor.

00:56:30.790 --> 00:56:32.930
So blue is greater than purple.

00:56:32.930 --> 00:56:36.160
Don't use this proof
technique in the quiz.

00:56:36.160 --> 00:56:40.380
So do I have a couple of
volunteers to play this game?

00:56:40.380 --> 00:56:41.470
Two of them over there.

00:56:41.470 --> 00:56:43.780
Are you waving for him?

00:56:43.780 --> 00:56:44.280
Yeah.

00:56:44.280 --> 00:56:44.440
I see one.

00:56:44.440 --> 00:56:45.370
You can come down.

00:56:45.370 --> 00:56:46.120
Another volunteer?

00:56:48.711 --> 00:56:49.210
Yeah.

00:56:49.210 --> 00:56:51.830
Over there.

00:56:51.830 --> 00:56:53.440
You don't get your Frisbees yet.

00:56:53.440 --> 00:56:56.538
So we're going to
make this really fair.

00:56:56.538 --> 00:56:57.246
What's your name?

00:56:57.246 --> 00:56:58.100
AUDIENCE: Josiah.

00:56:58.100 --> 00:56:58.496
PROFESSOR: Josiah.

00:56:58.496 --> 00:56:59.262
AUDIENCE: Tessa.

00:56:59.262 --> 00:56:59.970
PROFESSOR: Tessa.

00:56:59.970 --> 00:57:06.370
Josiah and Tessa, I'm going
to write out a bunch of-- it's

00:57:06.370 --> 00:57:09.750
going to be a fairly short game.

00:57:12.490 --> 00:57:14.050
And we're going
to be really fair,

00:57:14.050 --> 00:57:17.940
and we're going to flip a coin
to decide whether Josiah goes

00:57:17.940 --> 00:57:21.550
first-- you can pick
heads or tails--

00:57:21.550 --> 00:57:24.460
or whether Tessa goes first.

00:57:24.460 --> 00:57:28.870
Actually if you win, you can
let her go first if you want.

00:57:28.870 --> 00:57:29.810
But you get to choose.

00:57:29.810 --> 00:57:31.020
AUDIENCE: All right.

00:57:31.020 --> 00:57:32.020
PROFESSOR: So pick.

00:57:32.020 --> 00:57:33.036
AUDIENCE: Heads.

00:57:33.036 --> 00:57:34.190
PROFESSOR: That's heads.

00:57:34.190 --> 00:57:38.995
Do you want to go first, or do
you want to let Tessa go first?

00:57:38.995 --> 00:57:42.883
[LAUGHTER]

00:57:42.883 --> 00:57:44.133
AUDIENCE: You should go first.

00:57:47.345 --> 00:57:48.220
PROFESSOR: All right.

00:57:48.220 --> 00:57:50.320
So Tessa, you get to go first.

00:57:50.320 --> 00:57:52.560
AUDIENCE: OK, 6.

00:57:52.560 --> 00:57:54.240
PROFESSOR: 6, OK.

00:57:54.240 --> 00:58:00.270
So let's just say T.
So you get to choose

00:58:00.270 --> 00:58:02.800
either 25 or 4, Josiah.

00:58:02.800 --> 00:58:04.290
AUDIENCE: I think I'd pick 25.

00:58:04.290 --> 00:58:06.550
PROFESSOR: You think
you'll take 25.

00:58:06.550 --> 00:58:07.850
So that's j.

00:58:07.850 --> 00:58:11.960
So it's not on the 4 and 19 over
here because those are gone.

00:58:11.960 --> 00:58:13.390
So your turn again.

00:58:13.390 --> 00:58:15.602
AUDIENCE: OK.

00:58:15.602 --> 00:58:18.190
Can I take a minute,
or should I just go?

00:58:18.190 --> 00:58:21.405
PROFESSOR: Well, you
can take 30 seconds.

00:58:23.992 --> 00:58:24.533
AUDIENCE: 19.

00:58:24.533 --> 00:58:25.680
PROFESSOR: 19, OK.

00:58:38.576 --> 00:58:39.568
AUDIENCE: 4.

00:58:39.568 --> 00:58:41.056
[LAUGHTER]

00:58:41.056 --> 00:58:42.048
AUDIENCE: All right, 4.

00:58:42.048 --> 00:58:44.560
PROFESSOR: 4.

00:58:44.560 --> 00:58:47.400
All right.

00:58:47.400 --> 00:58:48.335
And 42?

00:58:48.335 --> 00:58:48.960
AUDIENCE: Yeah.

00:58:48.960 --> 00:58:50.850
PROFESSOR: All right, 42.

00:58:50.850 --> 00:58:54.650
This is one strange game.

00:58:54.650 --> 00:58:57.130
Now, we get to add
up the numbers.

00:58:57.130 --> 00:59:00.200
This is going to be tight.

00:59:00.200 --> 00:59:03.050
4 plus 39 is 43.

00:59:03.050 --> 00:59:05.053
43 plus 25 is 68.

00:59:07.870 --> 00:59:11.010
42 plus 19 is 61.

00:59:11.010 --> 00:59:14.030
61 plus 6 is 67.

00:59:14.030 --> 00:59:15.970
Ooh.

00:59:15.970 --> 00:59:19.130
Well, you get Frisbees.

00:59:19.130 --> 00:59:20.837
Well, blue for you.

00:59:20.837 --> 00:59:22.670
I mean, you could give
her blue if you like.

00:59:22.670 --> 00:59:23.250
AUDIENCE: I prefer purple.

00:59:23.250 --> 00:59:24.458
PROFESSOR: You prefer purple.

00:59:24.458 --> 00:59:25.670
Thanks.

00:59:25.670 --> 00:59:26.706
Good job.

00:59:26.706 --> 00:59:31.830
[APPLAUSE]

00:59:31.830 --> 00:59:34.660
No offense is intended
to Josiah and Tessa,

00:59:34.660 --> 00:59:39.930
but that was a classic example
of how not to play the game.

00:59:39.930 --> 00:59:44.970
First off, Josiah could
have won regardless

00:59:44.970 --> 00:59:47.610
of the coins that were
up there, regardless

00:59:47.610 --> 00:59:51.670
of the values of the coins,
if he'd chosen to go first.

00:59:51.670 --> 00:59:54.710
So this game, the
person who goes first

00:59:54.710 --> 00:59:56.790
is guaranteed to not lose.

00:59:56.790 --> 01:00:01.070
And by that, I mean you
may have a situation where

01:00:01.070 --> 01:00:03.430
you can have a tie in
terms of the values,

01:00:03.430 --> 01:00:06.774
but you're guaranteed
to not lose.

01:00:06.774 --> 01:00:08.690
Now, he ended up winning
anyway, because there

01:00:08.690 --> 01:00:12.710
were other errors
made during this,

01:00:12.710 --> 01:00:15.445
and I don't have the time
to enumerate all of them.

01:00:15.445 --> 01:00:17.380
[LAUGHTER]

01:00:17.380 --> 01:00:21.420
So we're just going to go move
on and do the right thing.

01:00:28.290 --> 01:00:31.560
So let me first tell
you, outside of DP, just

01:00:31.560 --> 01:00:35.330
in case you play this game
over Spring Break or something,

01:00:35.330 --> 01:00:39.880
how you can win this
game without having

01:00:39.880 --> 01:00:44.170
to compute complicated
recursive memoization DP

01:00:44.170 --> 01:00:47.350
programs for this case.

01:00:47.350 --> 01:00:53.190
So let's say I have V1, V2,
V3, all the way to V n minus 1

01:00:53.190 --> 01:00:53.690
and Vn.

01:00:53.690 --> 01:00:56.270
And remember n is even.

01:00:56.270 --> 01:00:58.830
So you've got to
pick n over 2 coins

01:00:58.830 --> 01:01:01.004
if you're the first
player and n over 2

01:01:01.004 --> 01:01:02.170
if you're the second player.

01:01:05.630 --> 01:01:13.740
So what the first
player does is simply

01:01:13.740 --> 01:01:19.150
compute V1-- take the odd
numbers-- and n is even,

01:01:19.150 --> 01:01:22.070
so you've got V n
minus 1 being odd.

01:01:22.070 --> 01:01:26.070
Compute V1 plus V3 all
the way to V n minus 1,

01:01:26.070 --> 01:01:31.730
and compare that with
the even positions,

01:01:31.730 --> 01:01:34.800
V2 plus V4 all the way Vn.

01:01:34.800 --> 01:01:40.330
So in this particular
instance, Josiah,

01:01:40.330 --> 01:01:43.910
who went second,
if you just look

01:01:43.910 --> 01:01:46.800
at the odd positions, which
is, in fact, what he ended up

01:01:46.800 --> 01:01:52.510
picking, it was 4 plus
39 plus 25, which was 68.

01:01:52.510 --> 01:01:54.450
So you can do this
computation beforehand.

01:01:54.450 --> 01:01:56.850
You compute this to
be 68, in our case.

01:01:56.850 --> 01:02:00.890
Compare that with 67.

01:02:00.890 --> 01:02:07.057
And you don't give up your
first-player advantage.

01:02:07.057 --> 01:02:08.640
So you're going with
the first player.

01:02:08.640 --> 01:02:14.065
But now you say, I know
that I can set this up--

01:02:14.065 --> 01:02:15.440
and that wasn't
the order that he

01:02:15.440 --> 01:02:17.490
did this-- but I know
I can set this up

01:02:17.490 --> 01:02:23.220
so I always have a chance to
get V1, V3, V5, et cetera.

01:02:23.220 --> 01:02:26.910
Because let's just say that
the first player Josiah

01:02:26.910 --> 01:02:28.130
started first.

01:02:28.130 --> 01:02:30.700
And he decided, in this
case, that the odd values

01:02:30.700 --> 01:02:32.980
are the ones that win.

01:02:32.980 --> 01:02:36.630
So let's say he picks V1.

01:02:36.630 --> 01:02:41.170
At this point, Tessa
sees V2 through Vn.

01:02:41.170 --> 01:02:42.980
So you're just looking at that.

01:02:42.980 --> 01:02:47.870
Now Tessa could either pick
V2 or she could pick Vn.

01:02:47.870 --> 01:02:50.890
In that case, Josiah,
who's the first player,

01:02:50.890 --> 01:02:54.275
could pick V3 or Vn minus
1 and stick with his rule

01:02:54.275 --> 01:02:56.910
of picking the odd coins.

01:02:56.910 --> 01:02:59.990
So regardless of
what Tessa does,

01:02:59.990 --> 01:03:04.320
the first player,
Josiah, could pick odd

01:03:04.320 --> 01:03:07.540
if odd was the way to go or if
the values were such that, even

01:03:07.540 --> 01:03:10.700
with the way to go,
he could go even.

01:03:10.700 --> 01:03:14.160
So no reason for the
first player to lose.

01:03:14.160 --> 01:03:22.170
But let's just say that you're
a nasty person, Michael Jordan

01:03:22.170 --> 01:03:24.190
nasty.

01:03:24.190 --> 01:03:27.890
You want to just
press your opponent.

01:03:27.890 --> 01:03:31.780
You want to make sure they
never want to play you again.

01:03:31.780 --> 01:03:36.560
So now you have a
maximization problem.

01:03:36.560 --> 01:03:37.770
So this is clearly not DP.

01:03:37.770 --> 01:03:40.390
You don't need DP to add
up a bunch of numbers.

01:03:40.390 --> 01:03:44.250
But let's say that you want
to, given a set of coins,

01:03:44.250 --> 01:03:51.260
V1 through Vn, you want
a dynamic strategy that

01:03:51.260 --> 01:03:55.730
gives you the maximum value.

01:03:55.730 --> 01:03:58.960
This odd versus even
is a bit constraining,

01:03:58.960 --> 01:04:00.900
because you're stuck
to these positions.

01:04:00.900 --> 01:04:03.070
And it's good to be
in that situation

01:04:03.070 --> 01:04:06.040
if you just want to win and
you don't care how you win.

01:04:06.040 --> 01:04:07.760
But if you want to
maximize, then it's

01:04:07.760 --> 01:04:10.000
a more complicated problem.

01:04:10.000 --> 01:04:13.980
And so we have to talk about
how you would do something that

01:04:13.980 --> 01:04:19.000
would give-- maybe it would be
V1 and V4 and something else,

01:04:19.000 --> 01:04:20.494
depends on the values.

01:04:20.494 --> 01:04:21.910
How would you get
to a situation--

01:04:21.910 --> 01:04:23.010
if you're the first player.

01:04:23.010 --> 01:04:24.926
We'll just stick with
you're the first player.

01:04:24.926 --> 01:04:27.980
You know you can't lose
using this strategy.

01:04:27.980 --> 01:04:29.960
But not only do you
want to not lose,

01:04:29.960 --> 01:04:32.410
you want to get as many
coins as possible--

01:04:32.410 --> 01:04:33.860
let's say this is money.

01:04:33.860 --> 01:04:40.470
More money is better,
and that's your goal.

01:04:40.470 --> 01:04:42.460
So people understand that.

01:04:42.460 --> 01:04:48.922
A little trick there with,
I guess, a greedy algorithm

01:04:48.922 --> 01:04:49.630
you can think of.

01:04:49.630 --> 01:04:53.710
Or it's not really
even something

01:04:53.710 --> 01:04:55.770
that you might want
to call an algorithm.

01:04:55.770 --> 01:05:00.440
It's a little computation.

01:05:00.440 --> 01:05:14.970
And our goal now is to
maximize the amount of money

01:05:14.970 --> 01:05:21.530
when assuming you move first.

01:05:21.530 --> 01:05:24.920
And so this is going to be a
little bit different from all

01:05:24.920 --> 01:05:26.580
of the other problems
we've looked at,

01:05:26.580 --> 01:05:29.110
because we have to now think
about what the opponent would

01:05:29.110 --> 01:05:30.140
do.

01:05:30.140 --> 01:05:32.550
And there's going to be
a sequence of moves here.

01:05:32.550 --> 01:05:34.860
You're going to move
first, so that one is easy.

01:05:34.860 --> 01:05:36.460
You've got the whole problem.

01:05:36.460 --> 01:05:38.910
But now you have to
say, the opponent

01:05:38.910 --> 01:05:41.850
is going to move
and pick a coin.

01:05:41.850 --> 01:05:44.600
And then you have to
think of your subproblems

01:05:44.600 --> 01:05:49.890
as the potential rows of coins
that are going to be different,

01:05:49.890 --> 01:05:51.910
depending on what
the opponent does.

01:05:51.910 --> 01:05:55.240
And through this process, you
have to maximize the value.

01:05:55.240 --> 01:05:57.940
So it's really pretty
different from the other couple

01:05:57.940 --> 01:06:01.970
of examples that we looked at.

01:06:01.970 --> 01:06:04.130
So we're going to have to
do a little bit of set-up

01:06:04.130 --> 01:06:06.421
before we get to the point
where we can write something

01:06:06.421 --> 01:06:10.800
like this, which is
the solution to our DP.

01:06:10.800 --> 01:06:12.290
And so let me do that set-up.

01:06:12.290 --> 01:06:14.780
But it's not super complicated.

01:06:14.780 --> 01:06:18.080
And part of this is going
to look kind of the same

01:06:18.080 --> 01:06:20.930
as previous problems
we've looked at.

01:06:20.930 --> 01:06:28.750
So Vij is the max
value we can definitely

01:06:28.750 --> 01:06:37.925
win if it is our turn.

01:06:40.710 --> 01:06:47.840
And only coins Vi
through Vj remain.

01:06:53.440 --> 01:06:56.660
And so we have Vii.

01:06:56.660 --> 01:07:01.204
Then there's only one coin
left, and you just pick i.

01:07:04.040 --> 01:07:07.720
Now, you might say,
but that's never

01:07:07.720 --> 01:07:10.460
going to happen if there's
an even number of coins

01:07:10.460 --> 01:07:14.950
and I'm playing first, because
the other player is going

01:07:14.950 --> 01:07:20.100
to be at the end of the-- is
going to be the person who

01:07:20.100 --> 01:07:21.190
picks the last coin.

01:07:21.190 --> 01:07:23.650
But we need to
categorize Vii because we

01:07:23.650 --> 01:07:27.030
need to model what the
other player is going to do.

01:07:27.030 --> 01:07:28.760
So we can't just
say that we're going

01:07:28.760 --> 01:07:31.260
to be looking at an even
number of coins in terms

01:07:31.260 --> 01:07:34.820
of the row of coins that
you look at, which is true,

01:07:34.820 --> 01:07:36.910
that when you get
to move, you only

01:07:36.910 --> 01:07:39.230
see an even number of coins
if you're the first player.

01:07:39.230 --> 01:07:41.280
But you do have to model
what the opponent does .

01:07:41.280 --> 01:07:42.071
So we need the Vii.

01:07:44.760 --> 01:07:47.850
And what you might
see, of course,

01:07:47.850 --> 01:07:59.960
is a board that looks like Vi
i plus 1, for some arbitrary i.

01:07:59.960 --> 01:08:01.490
So that's why I
have it up there.

01:08:01.490 --> 01:08:04.847
But remember that you're only
picking coins on the outside,

01:08:04.847 --> 01:08:06.680
so it's not like you're
going to have a gap.

01:08:06.680 --> 01:08:10.087
I mean, you're not going to
have V3 left and V7 left.

01:08:10.087 --> 01:08:11.670
There's no way that's
going to happen.

01:08:11.670 --> 01:08:13.753
You're just going to keep
shrinking, taking things

01:08:13.753 --> 01:08:15.180
from the left or the right.

01:08:15.180 --> 01:08:17.310
So it's going to
be i and i plus 1.

01:08:17.310 --> 01:08:19.060
That make sense?

01:08:19.060 --> 01:08:21.310
And so in this case,
what would you pick?

01:08:21.310 --> 01:08:23.970
Vi and i plus 1.

01:08:23.970 --> 01:08:25.240
You just pick the max.

01:08:25.240 --> 01:08:28.920
Because at the end of this,
either you did it right

01:08:28.920 --> 01:08:30.170
or you did it wrong.

01:08:30.170 --> 01:08:32.930
Either way, you're going
to improve your situation

01:08:32.930 --> 01:08:36.220
by picking the max
of Vi or Vi i plus 1.

01:08:36.220 --> 01:08:38.220
So there's no two
things about it.

01:08:38.220 --> 01:08:48.200
So here, you're going to
pick the maximum of the two.

01:08:51.554 --> 01:09:00.430
And you might have Vi i plus 2,
which is an odd number of coins

01:09:00.430 --> 01:09:02.609
that your opponent might see.

01:09:02.609 --> 01:09:06.420
It gets more complicated
for Vi and i plus 2.

01:09:06.420 --> 01:09:10.680
We're going to have to now start
thinking in more general terms

01:09:10.680 --> 01:09:12.474
as to what the
different moves are.

01:09:12.474 --> 01:09:13.890
But we've got the
base cases here.

01:09:13.890 --> 01:09:16.880
All I did here was take
care of the base case

01:09:16.880 --> 01:09:18.810
or a couple of base
cases associated

01:09:18.810 --> 01:09:21.899
with a single coin, which
is what your opponent will

01:09:21.899 --> 01:09:26.460
see and pick, or two coins,
which is your last move.

01:09:26.460 --> 01:09:28.270
So with DP, of
course, you always

01:09:28.270 --> 01:09:31.010
have to go down
to your base case,

01:09:31.010 --> 01:09:34.130
and that's when
things become easy.

01:09:34.130 --> 01:09:37.050
So we have to talk
about two things

01:09:37.050 --> 01:09:41.510
and put up our
recurrence together.

01:09:41.510 --> 01:09:43.390
The two things we
have to talk about

01:09:43.390 --> 01:09:48.229
are what you do when you
move, and that's actually

01:09:48.229 --> 01:09:50.890
fairly easy, and
the second thing

01:09:50.890 --> 01:09:53.580
is what the model
of the opponent

01:09:53.580 --> 01:09:59.270
looks like when you're waiting
for him or her to move.

01:09:59.270 --> 01:10:03.515
So let's take a
look at your move.

01:10:03.515 --> 01:10:05.970
And I've got V1.

01:10:05.970 --> 01:10:07.074
Let's look at Vi.

01:10:11.030 --> 01:10:14.480
Vj here, dot dot dot, Vn.

01:10:14.480 --> 01:10:17.330
So that's what you see.

01:10:17.330 --> 01:10:20.780
And you're looking at i and j.

01:10:20.780 --> 01:10:24.020
And at this point, you're
seeing all those other coins,

01:10:24.020 --> 01:10:28.840
the outer coins have disappeared
into people's pockets.

01:10:28.840 --> 01:10:33.400
And you're looking
at this interval.

01:10:33.400 --> 01:10:36.730
So I'm going to write
out what Vij should be.

01:10:36.730 --> 01:10:41.590
And keep in mind that we want
to maximize the amount of money.

01:10:41.590 --> 01:10:43.150
And we want to say
that you should

01:10:43.150 --> 01:10:47.510
be able to definitely win this
amount of money, regardless

01:10:47.510 --> 01:10:50.000
of what the opponent does.

01:10:50.000 --> 01:10:55.570
So I want to do
a max, obviously.

01:10:55.570 --> 01:10:58.850
And I have two choices here.

01:10:58.850 --> 01:11:01.550
I can pick Vi or I can pick Vj.

01:11:01.550 --> 01:11:03.810
It's not like there's
a lot of choices here.

01:11:03.810 --> 01:11:08.090
So if I pick Vi,
then-- let me go ahead

01:11:08.090 --> 01:11:10.590
and say I pick Vi here.

01:11:10.590 --> 01:11:13.025
And here, I pick Vj.

01:11:18.120 --> 01:11:21.810
Let me draw this out
a little bit better.

01:11:21.810 --> 01:11:28.320
So I've got to fill in these
two arguments to my max.

01:11:28.320 --> 01:11:32.010
So this is easy.

01:11:32.010 --> 01:11:34.360
I'm going to have
a plus Vi here.

01:11:34.360 --> 01:11:37.930
Going to have a plus
Vj here because I

01:11:37.930 --> 01:11:40.370
picked the appropriate value.

01:11:40.370 --> 01:11:45.230
And now, this is also
not that difficult.

01:11:45.230 --> 01:11:46.270
What exactly happens?

01:11:46.270 --> 01:11:49.680
What can I put in
here if I pick Vi?

01:11:49.680 --> 01:11:50.614
AUDIENCE: Vi plus 1.

01:11:50.614 --> 01:11:51.280
PROFESSOR: Yeah.

01:11:51.280 --> 01:11:53.240
Vi plus 1 to j.

01:11:53.240 --> 01:11:57.480
So the range becomes i plus 1 j.

01:12:01.370 --> 01:12:04.200
I have to be a little
careful here in terms

01:12:04.200 --> 01:12:10.270
of whether I can argue
that it's actually

01:12:10.270 --> 01:12:12.380
the V that I put in here.

01:12:12.380 --> 01:12:21.580
So the subtlety here is
simply that the Vi plus 1 j

01:12:21.580 --> 01:12:26.540
is not something that
I see in front of me.

01:12:26.540 --> 01:12:28.090
This is the complication.

01:12:28.090 --> 01:12:33.260
Vi plus 1 j is never a board
that I see in front of me,

01:12:33.260 --> 01:12:36.180
whereas Vij was a board
that I saw in front of me.

01:12:36.180 --> 01:12:41.370
So I have to model the boards
that I see in front of me,

01:12:41.370 --> 01:12:43.922
because those are the boards
that I have control over

01:12:43.922 --> 01:12:44.755
that I can maximize.

01:12:48.430 --> 01:12:51.570
I cannot would be Vi
plus 1 j in there,

01:12:51.570 --> 01:12:54.560
simply because I don't
quite know what that is,

01:12:54.560 --> 01:12:58.890
because of what I get eventually
is not something I control.

01:12:58.890 --> 01:13:03.370
It's going to be the board
after my opponent has moved.

01:13:03.370 --> 01:13:09.620
So all I'm going to do is
I'm going to say the range

01:13:09.620 --> 01:13:16.425
becomes-- range is i plus 1 j.

01:13:19.600 --> 01:13:22.280
And I'm going to say something
else in a second here.

01:13:22.280 --> 01:13:30.360
The range is i j minus 1.

01:13:30.360 --> 01:13:35.110
And in both of these
cases, the opponent moves.

01:13:40.810 --> 01:13:43.960
So in order to actually
write out my DP,

01:13:43.960 --> 01:13:48.070
I'm going to have to now
look at the worst case

01:13:48.070 --> 01:13:52.084
situation in terms of
the board I get back,

01:13:52.084 --> 01:13:53.750
because the only times
I'm adding values

01:13:53.750 --> 01:13:56.460
is when I see a board in
front of me and I pick a coin.

01:13:56.460 --> 01:13:59.020
And I'm going to have to say
now the opponent is going

01:13:59.020 --> 01:14:05.740
to see an i plus 1 j-- or
an i j minus 1, excuse me,

01:14:05.740 --> 01:14:07.590
and might do something.

01:14:07.590 --> 01:14:11.020
And I'm going to
get something back.

01:14:11.020 --> 01:14:13.260
I'm going to assume that
the opponent is just

01:14:13.260 --> 01:14:15.490
as smart as I am,
knows DP, taken

01:14:15.490 --> 01:14:18.420
6046, et cetera, et cetera.

01:14:18.420 --> 01:14:21.350
And I still want to
get the maximum value

01:14:21.350 --> 01:14:24.360
that I can definitely win.

01:14:24.360 --> 01:14:27.580
And so we need to look
inside of that a little bit.

01:14:27.580 --> 01:14:29.970
And it's not that hard if
you just make the assumption

01:14:29.970 --> 01:14:33.760
that I just did,
which is the opponent

01:14:33.760 --> 01:14:37.400
is going to do-- I mean
might not necessarily

01:14:37.400 --> 01:14:38.530
do the right thing.

01:14:38.530 --> 01:14:41.590
But you have to assume that
the opponent knows just as much

01:14:41.590 --> 01:14:47.090
as you do and is going to try
and do as well as possible.

01:14:47.090 --> 01:14:48.570
So let's do that.

01:14:48.570 --> 01:14:50.840
That's the last thing
that we have to do here.

01:14:50.840 --> 01:14:54.970
And it's just one more equation.

01:14:54.970 --> 01:14:58.400
So here's the solution.

01:14:58.400 --> 01:15:06.081
We now have Vi plus 1 j
subproblem with the opponent

01:15:06.081 --> 01:15:06.580
picking.

01:15:14.000 --> 01:15:18.150
And the simple
observation is that we

01:15:18.150 --> 01:15:29.930
are guaranteed the min
of Vi plus 1 j minus 1

01:15:29.930 --> 01:15:34.420
or Vi plus 2 j.

01:15:34.420 --> 01:15:44.325
In this case, the opponent
picks Vj, and in this case,

01:15:44.325 --> 01:15:51.370
the opponent picks Vi plus 1.

01:15:51.370 --> 01:15:54.700
And you're guaranteed
the minimum of these two,

01:15:54.700 --> 01:15:56.870
because the opponent
can only pick one coin.

01:15:56.870 --> 01:15:59.830
So that's the simple
observation that

01:15:59.830 --> 01:16:05.790
lets you jump ahead to your
next move, which is really

01:16:05.790 --> 01:16:10.560
what the DP is interested
in, because that's

01:16:10.560 --> 01:16:13.060
the only time that you're
actually executing something

01:16:13.060 --> 01:16:15.020
in terms of picking
coins from the board

01:16:15.020 --> 01:16:16.850
and adding to your value.

01:16:16.850 --> 01:16:21.320
But we did have to model that
as to what the maximum value was

01:16:21.320 --> 01:16:24.440
that you could win,
jumping ahead of this move.

01:16:24.440 --> 01:16:26.470
And you have the min
in here because you're

01:16:26.470 --> 01:16:30.190
assuming that this is
a definite guarantee.

01:16:30.190 --> 01:16:31.700
That's what we want.

01:16:31.700 --> 01:16:37.200
It's possible that the
opponent plays a different game

01:16:37.200 --> 01:16:40.720
from the one that we think
he or she is going to play,

01:16:40.720 --> 01:16:43.230
which maximizes his or value.

01:16:43.230 --> 01:16:45.780
But the min is guaranteed.

01:16:45.780 --> 01:16:48.150
So now that you've
made this observation,

01:16:48.150 --> 01:16:54.940
it turns out we just have to
take that, and we'll be done.

01:16:54.940 --> 01:16:56.230
So let's see.

01:16:56.230 --> 01:16:57.805
Let me erase this.

01:16:57.805 --> 01:17:01.005
It's the last set of equations.

01:17:05.740 --> 01:17:07.700
And it's just plugging
in that observation

01:17:07.700 --> 01:17:10.030
into what I wrote before.

01:17:10.030 --> 01:17:14.655
So we have Vi j equals max.

01:17:14.655 --> 01:17:17.820
This is the outer max that
I had up there already,

01:17:17.820 --> 01:17:20.620
so that's the same max.

01:17:20.620 --> 01:17:23.440
And put these giant
brackets here.

01:17:26.250 --> 01:17:31.950
And inside, I'm going to
plug in this min, which

01:17:31.950 --> 01:17:37.230
is something that
corresponds to the value

01:17:37.230 --> 01:17:39.820
that I would win
in the worst case

01:17:39.820 --> 01:17:42.980
after the opponent plays
the best possible move.

01:17:42.980 --> 01:18:00.000
And that would be Vi plus 1 j
minus 1, V1 plus 2 j plus Vi.

01:18:00.000 --> 01:18:04.100
This Vi is the same
as this one up here.

01:18:06.990 --> 01:18:10.200
And you've got a plus Vj here.

01:18:10.200 --> 01:18:12.610
And I didn't actually
do this, but in terms

01:18:12.610 --> 01:18:16.350
of writing out what the opponent
would do in other subproblem

01:18:16.350 --> 01:18:19.450
case, but it's really
pretty straightforward.

01:18:19.450 --> 01:18:22.970
You have a problem
that corresponds

01:18:22.970 --> 01:18:26.260
to the i j minus 1 problem.

01:18:26.260 --> 01:18:28.235
And the opponent
could pick the i-th

01:18:28.235 --> 01:18:30.417
or could pick the j minus 1th.

01:18:30.417 --> 01:18:32.000
If the opponent picks
the j minus 1th,

01:18:32.000 --> 01:18:38.460
you get Vi j minus 2, and you
need to take the min of that.

01:18:38.460 --> 01:18:42.520
In the other case, where the
opponent picks i, in which case

01:18:42.520 --> 01:18:44.880
you get i plus 1 j minus 1.

01:18:47.680 --> 01:18:49.630
And that's our DP.

01:18:49.630 --> 01:18:52.450
That's our DP.

01:18:52.450 --> 01:18:55.970
So the big difference
here was the modeling

01:18:55.970 --> 01:18:57.400
that you had to
do in the middle.

01:18:57.400 --> 01:19:00.270
We didn't actually have
to do that in any of DPs

01:19:00.270 --> 01:19:07.320
we've covered in 046 at
least up until this point.

01:19:07.320 --> 01:19:11.730
Before we talk about complexity,
that should just take a minute,

01:19:11.730 --> 01:19:13.550
people buy that?

01:19:13.550 --> 01:19:14.540
See that?

01:19:14.540 --> 01:19:15.060
Good.

01:19:15.060 --> 01:19:18.660
So with all of these
problems, the complexities

01:19:18.660 --> 01:19:21.510
are fairly straightforward
to compute.

01:19:21.510 --> 01:19:24.360
The complexity here
is simply, again, as

01:19:24.360 --> 01:19:26.610
before, the number
of subproblems times

01:19:26.610 --> 01:19:30.300
the time it takes to
solve the subproblem.

01:19:30.300 --> 01:19:32.750
You can see here are that
these are all constant time

01:19:32.750 --> 01:19:33.740
operations.

01:19:33.740 --> 01:19:37.800
So assuming that the
Vij's have been computed,

01:19:37.800 --> 01:19:41.450
it's theta 1 time to
compute a subproblem.

01:19:41.450 --> 01:19:43.160
So that's your theta 1.

01:19:43.160 --> 01:19:47.950
And as before, there are
n squared subproblems.

01:19:47.950 --> 01:19:48.460
Sorry.

01:19:48.460 --> 01:19:53.150
Let's just do number of
subproblems times theta 1.

01:19:53.150 --> 01:19:56.480
It's just theta n squared.

01:19:56.480 --> 01:19:58.360
So that was good.

01:19:58.360 --> 01:19:58.900
All right.

01:19:58.900 --> 01:20:01.700
So good luck for the quiz.

01:20:01.700 --> 01:20:04.400
And don't worry
too much about it.

01:20:04.400 --> 01:20:06.541
See you guys next week.

