WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.400
The following content is
provided under a Creative

00:00:02.400 --> 00:00:03.830
Commons license.

00:00:03.830 --> 00:00:06.840
Your support will help MIT
OpenCourseware continue to

00:00:06.840 --> 00:00:10.510
offer high-quality educational
resources for free.

00:00:10.510 --> 00:00:13.390
To make a donation, or view
additional materials from

00:00:13.390 --> 00:00:17.490
hundreds of MIT courses, visit
MIT OpenCourseware, at

00:00:17.490 --> 00:00:19.930
ocw.mit.edu.

00:00:19.930 --> 00:00:24.100
PROFESSOR JIM ERICSON:
OK, to work.

00:00:24.100 --> 00:00:27.730
A word of warning: fasten
your seat belts.

00:00:27.730 --> 00:00:29.460
Or, another way of saying it is,
I'm going to open up the

00:00:29.460 --> 00:00:31.610
fire hose a little bit today.

00:00:31.610 --> 00:00:33.780
Last lecture, you might have
thought this was a SHASS

00:00:33.780 --> 00:00:35.860
class, it's not like a
philosophy class, and it was

00:00:35.860 --> 00:00:38.620
important to set the stage for
what we're going to talk

00:00:38.620 --> 00:00:41.180
about, but we talked about
very high level things.

00:00:41.180 --> 00:00:43.960
The notion of recipes, the
notion of computation, why you

00:00:43.960 --> 00:00:45.700
want to do this, what you're
going to learn.

00:00:45.700 --> 00:00:48.000
Today we're going to dive into
the nitty-gritty, the nuts and

00:00:48.000 --> 00:00:51.040
bolts of the basics of
computation, and in

00:00:51.040 --> 00:00:53.320
particular, what I'm going to do
today is, I'm going to talk

00:00:53.320 --> 00:00:56.160
about operators and operands,
which we did a little bit real

00:00:56.160 --> 00:00:58.960
last time, in particular how
to create expressions, I'm

00:00:58.960 --> 00:01:02.360
going to talk about statements
as the key building blocks for

00:01:02.360 --> 00:01:06.060
writing code, and I'm going to
introduce simple sets of

00:01:06.060 --> 00:01:09.180
programs, in particular I'm
going to talk about branching,

00:01:09.180 --> 00:01:11.290
conditionals, and iteration.

00:01:11.290 --> 00:01:12.530
So, a lot to do.

00:01:12.530 --> 00:01:13.530
OK?

00:01:13.530 --> 00:01:16.070
So, let me jump straight
to it.

00:01:16.070 --> 00:01:18.350
At the end of last lecture, we
started introducing some of

00:01:18.350 --> 00:01:19.120
the pieces you want to do.

00:01:19.120 --> 00:01:20.450
And I want to remind
you of our goal.

00:01:20.450 --> 00:01:22.980
We're trying to describe
processes.

00:01:22.980 --> 00:01:24.700
We want to have things that
deduce new kinds of

00:01:24.700 --> 00:01:25.770
information.

00:01:25.770 --> 00:01:28.120
So we want to write programs
to do that.

00:01:28.120 --> 00:01:30.020
If we're going to write
programs, we need at least two

00:01:30.020 --> 00:01:32.570
things: we need some
representation

00:01:32.570 --> 00:01:34.420
for fundamental data.

00:01:34.420 --> 00:01:37.080
And we saw last time two
examples of that.

00:01:37.080 --> 00:01:39.000
And the second thing we're going
to need, is we're going

00:01:39.000 --> 00:01:43.230
to need a way to give
instructions to the computer

00:01:43.230 --> 00:01:44.390
to manipulate that data.

00:01:44.390 --> 00:01:47.570
We need to give it a description
of the recipe.

00:01:47.570 --> 00:01:52.940
In terms of primitive
data, what we saw

00:01:52.940 --> 00:01:56.910
were two kinds: Right?

00:01:56.910 --> 00:02:00.570
Numbers and strings.

00:02:00.570 --> 00:02:04.940
A little later on in the
lecture we're going to

00:02:04.940 --> 00:02:08.060
introduce a third kind of value,
but what we're going to

00:02:08.060 --> 00:02:11.260
see throughout the term is, no
matter how complex a data

00:02:11.260 --> 00:02:13.270
structure we create, and we're
going to create a variety of

00:02:13.270 --> 00:02:16.790
data structures, fundamentally
all of them have their basis,

00:02:16.790 --> 00:02:19.130
their atomic level if you like,
are going to be some

00:02:19.130 --> 00:02:22.290
combinations of numbers, of
strings, and the third type,

00:02:22.290 --> 00:02:23.700
which are booleans, which I'm
going to introduce a little

00:02:23.700 --> 00:02:25.670
later on in this lecture.

00:02:25.670 --> 00:02:27.030
And that kind of makes
sense right?

00:02:27.030 --> 00:02:29.210
Numbers are there to do numeric
things, strings are

00:02:29.210 --> 00:02:31.070
our fundamental way of
representing textual

00:02:31.070 --> 00:02:31.810
information.

00:02:31.810 --> 00:02:33.105
And so we're going to see
how to combine those

00:02:33.105 --> 00:02:35.810
things as we go along.

00:02:35.810 --> 00:02:38.800
Second thing we saw was, we saw
that associated with every

00:02:38.800 --> 00:02:41.480
primitive value was a type.

00:02:41.480 --> 00:02:42.880
And these are kind of
obvious, right?

00:02:42.880 --> 00:02:44.880
Strings are strings.

00:02:44.880 --> 00:02:47.510
For numbers, we had some
variations; we had integers,

00:02:47.510 --> 00:02:48.300
we had floats.

00:02:48.300 --> 00:02:49.910
We'll introduce a few
more as we go along.

00:02:49.910 --> 00:02:52.140
But those types are important,
because they tell us something

00:02:52.140 --> 00:02:55.560
about what we want to do when we
want to put them together.

00:02:55.560 --> 00:03:00.730
OK, but nonetheless, I want to
stress we have both a value,

00:03:00.730 --> 00:03:05.630
yeah, and a type.

00:03:05.630 --> 00:03:05.820
All right.

00:03:05.820 --> 00:03:07.210
Once we have them, we
want to start making

00:03:07.210 --> 00:03:08.120
combinations out of them.

00:03:08.120 --> 00:03:10.330
We want to put pieces
together.

00:03:10.330 --> 00:03:19.630
And for that, we combine
things in expressions.

00:03:19.630 --> 00:03:21.920
And what we saw as expressions
are formed of

00:03:21.920 --> 00:03:30.720
operands and operators.

00:03:30.720 --> 00:03:34.320
And the simple things we did
were the sort of things you'd

00:03:34.320 --> 00:03:36.640
expect from numerical things.

00:03:36.640 --> 00:03:39.300
Now I want to stress one
other nuance here.

00:03:39.300 --> 00:03:41.020
Which is, and we're going to
do some examples of this,

00:03:41.020 --> 00:03:43.590
initially we just typed in
expressions into the

00:03:43.590 --> 00:03:46.560
interpreter; that is, directly
into Python.

00:03:46.560 --> 00:03:48.740
And as I suggested last time,
the interpreter is actually a

00:03:48.740 --> 00:03:52.000
program inside of the machine
that is basically following

00:03:52.000 --> 00:03:54.346
the rules we're describing here
to deduce the value and

00:03:54.346 --> 00:03:55.350
print it up.

00:03:55.350 --> 00:03:58.040
And if we type directly into
the interpreter, it

00:03:58.040 --> 00:03:59.670
essentially does an
eval and a print.

00:03:59.670 --> 00:04:07.960
It evaluates, and it prints.

00:04:07.960 --> 00:04:10.730
Most of the time, we're going to
be doing expressions inside

00:04:10.730 --> 00:04:13.030
of some piece of code, inside
of a script, which is the

00:04:13.030 --> 00:04:15.150
Python word for program.

00:04:15.150 --> 00:04:17.700
In there, I want to make this
distinction, this nuance: the

00:04:17.700 --> 00:04:20.310
evaluator is still going to be
taking those expressions and

00:04:20.310 --> 00:04:23.040
using its rules to get a value,
but it's not going to

00:04:23.040 --> 00:04:24.960
print them back out.

00:04:24.960 --> 00:04:25.420
Why?

00:04:25.420 --> 00:04:27.880
Because typically, you're doing
that to use it somewhere

00:04:27.880 --> 00:04:28.780
else in the program.

00:04:28.780 --> 00:04:30.500
It's going to be stored
away in a variable.

00:04:30.500 --> 00:04:31.870
It's going to be stuck
in a data structure.

00:04:31.870 --> 00:04:34.360
It's going to be used
for a side effect.

00:04:34.360 --> 00:04:40.990
So, inside of code, or inside of
a script, there's no print,

00:04:40.990 --> 00:04:45.310
unless we make it explicit.

00:04:45.310 --> 00:04:47.800
And that's a little bit down in
the weeds, it's a detail,

00:04:47.800 --> 00:04:48.780
but one I want to stress.

00:04:48.780 --> 00:04:50.550
You need to, if you want
something to be printed out

00:04:50.550 --> 00:04:54.450
inside your code, you need to
tell the machine to do that.

00:04:54.450 --> 00:04:56.010
OK.

00:04:56.010 --> 00:04:57.460
So let's do some simple
examples.

00:04:57.460 --> 00:04:58.470
We've already seen somebody's.

00:04:58.470 --> 00:05:02.380
I just want to remind you, if I
wanted to, for example, type

00:05:02.380 --> 00:05:04.940
in an expression like that,
notice the syntactical form,

00:05:04.940 --> 00:05:07.940
it's an expression, a number,
followed by an operand,

00:05:07.940 --> 00:05:09.830
followed by another
expression.

00:05:09.830 --> 00:05:12.840
And of course I get out the
value I'd like there.

00:05:12.840 --> 00:05:15.810
Yes sir.

00:05:15.810 --> 00:05:17.650
Oh, you don't like leaning
that far to the left?

00:05:17.650 --> 00:05:20.230
OK, if you're a Republican I'll
be happy to shift this

00:05:20.230 --> 00:05:22.030
over a little bit.

00:05:22.030 --> 00:05:23.700
Wow, John, I got a laugh
for a political

00:05:23.700 --> 00:05:24.500
joke, I'm in big trouble.

00:05:24.500 --> 00:05:26.580
That better?

00:05:26.580 --> 00:05:32.740
Oh damn, all right, I'll have
to do it even more.

00:05:32.740 --> 00:05:35.040
OK, here we go, here we go,
you see, I'm doing it down

00:05:35.040 --> 00:05:37.420
here, I can't see it, does
that-- ah, I hear his sighs of

00:05:37.420 --> 00:05:38.570
relief, OK, good.

00:05:38.570 --> 00:05:39.730
There we go.

00:05:39.730 --> 00:05:40.140
Better.

00:05:40.140 --> 00:05:41.290
All right.

00:05:41.290 --> 00:05:42.900
One of the other things we
showed last time is that

00:05:42.900 --> 00:05:44.410
operators are overloaded.

00:05:44.410 --> 00:05:46.050
And this is where you heard
John and I disagree.

00:05:46.050 --> 00:05:47.720
I don't happen to like
this, but he

00:05:47.720 --> 00:05:49.100
thinks it's an ok thing.

00:05:49.100 --> 00:05:54.180
In a particular-- if we, whoa,
we don't do that, we do this--

00:05:54.180 --> 00:05:57.330
that is, give a combination of
a number multiplication in a

00:05:57.330 --> 00:06:01.460
string, this will in fact give
us back a new string with that

00:06:01.460 --> 00:06:03.280
many replicas, if you
like, of the string

00:06:03.280 --> 00:06:05.520
concatenated together.

00:06:05.520 --> 00:06:05.790
All right?

00:06:05.790 --> 00:06:08.110
And if you want to do other
things, for example, we can

00:06:08.110 --> 00:06:10.960
take two strings and add--
whoops, sorry-- and add them

00:06:10.960 --> 00:06:15.470
together, we will get
out, again, a

00:06:15.470 --> 00:06:17.270
concatenation of that string.

00:06:17.270 --> 00:06:19.040
And these will, we'll let you
work through the variations,

00:06:19.040 --> 00:06:21.690
but these are the simple
expressions we can use.

00:06:21.690 --> 00:06:25.440
Now, sometimes things get
a little interesting.

00:06:25.440 --> 00:06:27.860
All right?

00:06:27.860 --> 00:06:33.250
What's the value of
that expression?

00:06:33.250 --> 00:06:35.360
What do you think should happen
if I evaluate that

00:06:35.360 --> 00:06:38.350
expression?

00:06:38.350 --> 00:06:38.470
Somebody with a hand up,
so I can see it.

00:06:38.470 --> 00:06:39.120
What's going to happen?

00:06:39.120 --> 00:06:41.390
STUDENT: [UNINTELLIGIBLE]

00:06:41.390 --> 00:06:43.350
PROFESSOR JIM ERICSON:
An error?

00:06:43.350 --> 00:06:43.830
Why?

00:06:43.830 --> 00:06:48.210
STUDENT: [UNINTELLIGIBLE]

00:06:48.210 --> 00:06:50.538
PROFESSOR JIM ERICSON: Great.

00:06:50.538 --> 00:06:50.686
OK.

00:06:50.686 --> 00:06:51.021
That means, let's check it.

00:06:51.021 --> 00:06:52.550
It certainly is.

00:06:52.550 --> 00:06:53.670
We bribe people.

00:06:53.670 --> 00:06:57.540
So I, ah, by the way, John's a
Yankees fan, he throws like

00:06:57.540 --> 00:07:00.430
Johnny Damon, I'm a Red Sox fan,
so we'll see if I, how

00:07:00.430 --> 00:07:00.770
about that?

00:07:00.770 --> 00:07:03.530
And I almost hit John along
the way, great.

00:07:03.530 --> 00:07:05.350
My third right, exactly,
what can I say?

00:07:05.350 --> 00:07:07.620
All right, so we're into bribing
you as we go along

00:07:07.620 --> 00:07:08.730
here, and all right?

00:07:08.730 --> 00:07:11.340
You'll be badly overweight
by the end of the term.

00:07:11.340 --> 00:07:13.670
Right, it's a syntactic error,
because it doesn't know how to

00:07:13.670 --> 00:07:14.390
deal with this.

00:07:14.390 --> 00:07:16.500
But there's an important thing
going on here, if I in fact

00:07:16.500 --> 00:07:19.610
wanted to combine those into a
string, I should have told the

00:07:19.610 --> 00:07:23.690
machine to do that, and I can do
that, by explicitly saying,

00:07:23.690 --> 00:07:27.700
take that, which is a number,
and convert it into a string,

00:07:27.700 --> 00:07:29.680
and then-- bleah, I keep
doing that-- then

00:07:29.680 --> 00:07:33.650
add it to that string.

00:07:33.650 --> 00:07:35.960
OK, so there's an important
point here.

00:07:35.960 --> 00:07:44.810
We've got what's called
type conversion.

00:07:44.810 --> 00:07:48.800
That is, if I want to combine
two things together in a

00:07:48.800 --> 00:07:52.200
particular way, I need to make
sure that I give it the kind

00:07:52.200 --> 00:07:53.740
of operand it expects.

00:07:53.740 --> 00:07:57.800
So STR, which I just typed up
there, takes in parens, some

00:07:57.800 --> 00:08:01.040
input, and it converts it into
a string, so that now I can

00:08:01.040 --> 00:08:02.970
use that where I was
expecting a string.

00:08:02.970 --> 00:08:03.350
John.

00:08:03.350 --> 00:08:07.656
PROFESSOR JOHN GUTTAG: You've
got a static semantic error in

00:08:07.656 --> 00:08:07.710
your syntax.

00:08:07.710 --> 00:08:08.694
PROFESSOR JIM ERICSON:
Thank you.

00:08:08.694 --> 00:08:10.220
And I was going to come to that
in a second, but thank

00:08:10.220 --> 00:08:11.260
you, John, for pointing it out.

00:08:11.260 --> 00:08:12.550
All right.

00:08:12.550 --> 00:08:15.120
Why is it a static
semantic error?

00:08:15.120 --> 00:08:18.670
The syntax is OK in the sense
of, it is an operand, an

00:08:18.670 --> 00:08:23.380
operator, an operand, so
syntactically it's OK.

00:08:23.380 --> 00:08:26.000
The semantics was what caused
the problem, because the

00:08:26.000 --> 00:08:28.670
operator was expecting
a particular kind

00:08:28.670 --> 00:08:30.380
of structure there.

00:08:30.380 --> 00:08:32.020
There's a second thing going
on here that I want to

00:08:32.020 --> 00:08:36.480
highlight, because it's
really important.

00:08:36.480 --> 00:08:37.420
Yes indeed.

00:08:37.420 --> 00:08:38.970
OK, there we go.

00:08:38.970 --> 00:08:41.450
The second thing I want to
highlight is, that what's

00:08:41.450 --> 00:08:48.130
going on, is that Python is
doing some type checking.

00:08:48.130 --> 00:08:51.580
It caught the error, because
it checked the types of the

00:08:51.580 --> 00:08:54.050
operands before it applied
things, and it says,

00:08:54.050 --> 00:08:55.640
I'm going to stop.

00:08:55.640 --> 00:08:57.860
Now, you might have said, gee,
why didn't it just assume that

00:08:57.860 --> 00:09:00.030
I wanted to in fact treat these
as strings, and combine

00:09:00.030 --> 00:09:01.130
them together?

00:09:01.130 --> 00:09:03.540
Sounds like a reasonable
thing to do.

00:09:03.540 --> 00:09:05.300
But it's a dangerous thing.

00:09:05.300 --> 00:09:08.230
Because in doing that, Python
would then have a value that

00:09:08.230 --> 00:09:10.280
it could pass on into some other
part of a computation,

00:09:10.280 --> 00:09:13.820
and if it wasn't what I wanted,
I might be a long ways

00:09:13.820 --> 00:09:16.910
downstream in the computation
before I actually hit some

00:09:16.910 --> 00:09:18.960
result that makes no sense.

00:09:18.960 --> 00:09:21.330
And tracing back where it came
from can be really hard.

00:09:21.330 --> 00:09:23.810
So I actually want to have
type checking as much

00:09:23.810 --> 00:09:26.340
as I can early on.

00:09:26.340 --> 00:09:28.380
And in fact, under type
checking, different languages

00:09:28.380 --> 00:09:36.740
sometimes fall on a spectrum
from weak to strong typing.

00:09:36.740 --> 00:09:39.830
Which basically says, how much
type checking do they do?

00:09:39.830 --> 00:09:42.370
Now, you're going to hear John
and I go back and forth a lot,

00:09:42.370 --> 00:09:44.470
as I said I'm an old time-- well
I'm certainly old time,

00:09:44.470 --> 00:09:46.770
but I'm also an old time
Lisp programmer.

00:09:46.770 --> 00:09:49.320
I love Lisp, but Lisp is
certainly in the category of a

00:09:49.320 --> 00:09:50.680
very weakly typed language.

00:09:50.680 --> 00:09:53.830
It does not check the types
of its arguments at all.

00:09:53.830 --> 00:09:55.960
Python is, I wouldn't say
completely strong, but it's

00:09:55.960 --> 00:09:58.060
much closer to the strong
end of the spectrum.

00:09:58.060 --> 00:10:00.900
It's going to do a lot of type
checking for you before it

00:10:00.900 --> 00:10:03.400
actually passes things back.

00:10:03.400 --> 00:10:06.080
Nonetheless, I'm also going to
argue that it's probably not

00:10:06.080 --> 00:10:08.570
as strongly typed as
we might like.

00:10:08.570 --> 00:10:13.440
So, for example, there's
an expression.

00:10:13.440 --> 00:10:15.455
Now, less than is just, if you
haven't used it before, it's

00:10:15.455 --> 00:10:17.380
just the operator you'd expect,
it's comparing two

00:10:17.380 --> 00:10:19.200
things and it's going to return
either true or false

00:10:19.200 --> 00:10:21.210
depending on whether the first
argument is less than the

00:10:21.210 --> 00:10:23.270
second argument.

00:10:23.270 --> 00:10:24.690
What's going to happen here?

00:10:24.690 --> 00:10:28.360
Again, I need a hand so I can
know where to throw candy.

00:10:28.360 --> 00:10:29.420
I've also got on my
reading glasses

00:10:29.420 --> 00:10:31.600
on, I can't see anything.

00:10:31.600 --> 00:10:33.140
Anybody.

00:10:33.140 --> 00:10:36.660
TAs don't count, they
get their own candy.

00:10:36.660 --> 00:10:37.300
When it, yep.

00:10:37.300 --> 00:10:39.260
STUDENT: [INAUDIBLE]

00:10:39.260 --> 00:10:40.020
PROFESSOR JIM ERICSON:
Good question.

00:10:40.020 --> 00:10:41.000
Sounds like a reasonable
guess, right?

00:10:41.000 --> 00:10:44.030
How in the world am I going to
compare a string to a number?

00:10:44.030 --> 00:10:46.990
So, see how good my aim
is, ah, not bad.

00:10:46.990 --> 00:10:47.880
All right.

00:10:47.880 --> 00:10:51.010
A good quest-- sorry, a
good thought, but in

00:10:51.010 --> 00:10:53.820
fact, son of a gun.

00:10:53.820 --> 00:10:58.240
Or as my younger son would
say, fudge knuckle.

00:10:58.240 --> 00:10:58.890
Yeah.

00:10:58.890 --> 00:10:59.210
All right?

00:10:59.210 --> 00:11:01.290
So, what in the world's
going on here?

00:11:01.290 --> 00:11:02.220
This is a place--

00:11:02.220 --> 00:11:04.150
I don't know about you, John,
I think this is actually

00:11:04.150 --> 00:11:07.900
really not good, because right,
what this is doing is,

00:11:07.900 --> 00:11:12.280
it's allowing-- sorry, let me
back up and say it-- it's got

00:11:12.280 --> 00:11:14.800
an overload on the less-than
that allows you to compare

00:11:14.800 --> 00:11:18.360
basically the lexicographic
ordering, or this sequence of

00:11:18.360 --> 00:11:22.680
ordering of symbols, including
numbers inside of the machine.

00:11:22.680 --> 00:11:24.550
And this, in my mind, should
have been an error.

00:11:24.550 --> 00:11:26.750
Why in the world would you
want to compare that?

00:11:26.750 --> 00:11:29.510
Just to give you an example of
that, for instance, I can do

00:11:29.510 --> 00:11:35.360
the following: all right, the
number four is less than the

00:11:35.360 --> 00:11:42.370
string three, whereas the string
four, oops, is not less

00:11:42.370 --> 00:11:43.740
than the string three.

00:11:43.740 --> 00:11:46.210
And this is a place where it's
comparing strings and numbers

00:11:46.210 --> 00:11:47.750
in a strange way.

00:11:47.750 --> 00:11:48.920
So why am I showing you this?

00:11:48.920 --> 00:11:51.620
Partly to show you that it's
kind of weird, but also to

00:11:51.620 --> 00:11:56.210
tell you that one of the things
you want to do is

00:11:56.210 --> 00:12:00.510
exercise what I'm going to call
some type discipline.

00:12:00.510 --> 00:12:05.100
Meaning, when you write code,
you want to get into the habit

00:12:05.100 --> 00:12:08.250
of A, checking out operators or
procedures to see what they

00:12:08.250 --> 00:12:10.320
do under different
circumstances, either check

00:12:10.320 --> 00:12:13.100
them out or read the
specifications of it, and two,

00:12:13.100 --> 00:12:15.740
when you write your own code,
you want to be disciplined

00:12:15.740 --> 00:12:18.280
about what types of arguments
or operands

00:12:18.280 --> 00:12:20.620
you apply to operators.

00:12:20.620 --> 00:12:22.540
Because this is something that
could certainly have screwed

00:12:22.540 --> 00:12:25.370
you up if you didn't realize
it did it, and you need to

00:12:25.370 --> 00:12:26.550
have that discipline
to make sure it's

00:12:26.550 --> 00:12:29.160
doing the right thing.

00:12:29.160 --> 00:12:30.570
OK.

00:12:30.570 --> 00:12:33.420
One of the other things you're
going to see is that some of

00:12:33.420 --> 00:12:36.080
the operators have
odd meanings.

00:12:36.080 --> 00:12:37.290
And again, I think we looked--

00:12:37.290 --> 00:12:37.770
Yup?

00:12:37.770 --> 00:12:40.130
STUDENT: So, the string A is
less than three, is false

00:12:40.130 --> 00:12:40.340
because they're comparing
like ASCII values?

00:12:40.340 --> 00:12:45.360
PROFESSOR JIM ERICSON: Yes.

00:12:45.360 --> 00:12:46.340
I mean, I'm sorry.

00:12:46.340 --> 00:12:47.550
The answer is, I don't
know if it's ASCII.

00:12:47.550 --> 00:12:48.870
John, do you know, are
they doing ASCII

00:12:48.870 --> 00:12:49.830
encoding inside of here?

00:12:49.830 --> 00:12:51.540
I'm assuming so.

00:12:51.540 --> 00:12:51.780
Right.

00:12:51.780 --> 00:12:53.320
So, in case you didn't
understand what the the

00:12:53.320 --> 00:12:57.910
question was, basically every
symbol gets translated into a

00:12:57.910 --> 00:13:00.710
particular encoding, a string
of bit, if you like, inside

00:13:00.710 --> 00:13:02.450
the machine, there's a
particular one called ASCII,

00:13:02.450 --> 00:13:05.400
which is, if you like, an
ordering of that, and that's

00:13:05.400 --> 00:13:07.200
what the machine's actually
comparing inside of here,

00:13:07.200 --> 00:13:09.830
which is why in under ASCII
encoding the numbers are going

00:13:09.830 --> 00:13:12.530
to appear after the characters,
and you get the

00:13:12.530 --> 00:13:14.930
strange kind of thing going on.

00:13:14.930 --> 00:13:15.160
All right.

00:13:15.160 --> 00:13:16.960
I want a couple of other things,
just to quickly remind

00:13:16.960 --> 00:13:19.020
you, and one of them is,
remember, the operators do

00:13:19.020 --> 00:13:21.490
look at the types, so division,
for example nine

00:13:21.490 --> 00:13:25.290
divided by five is one, because
this is integer

00:13:25.290 --> 00:13:27.930
division, that is, it's the
largest number of integer

00:13:27.930 --> 00:13:30.680
multiples of five to go into
nine, and there would be a

00:13:30.680 --> 00:13:36.580
remainder associated with it,
which is in fact four.

00:13:36.580 --> 00:13:37.810
And again, you've got
to be careful about

00:13:37.810 --> 00:13:40.010
how you use the operators.

00:13:40.010 --> 00:13:41.890
Right, having done that, we
can certainly get to more

00:13:41.890 --> 00:13:46.060
complicated things, so for
example, suppose I look at

00:13:46.060 --> 00:13:47.660
that expression.

00:13:47.660 --> 00:13:50.570
Three plus four times five.

00:13:50.570 --> 00:13:51.680
All right.

00:13:51.680 --> 00:13:52.180
Now.

00:13:52.180 --> 00:13:55.420
There are two possible
values here, I think.

00:13:55.420 --> 00:13:57.770
One is 23, the other's 35.

00:13:57.770 --> 00:14:03.370
Because this could be three plus
four, times five, or it

00:14:03.370 --> 00:14:07.150
could be three, plus
four times five.

00:14:07.150 --> 00:14:08.990
And of course, you know, when
you look at code it doesn't

00:14:08.990 --> 00:14:09.780
pause in between them.

00:14:09.780 --> 00:14:10.360
But what I do?

00:14:10.360 --> 00:14:12.620
I just separated, do I do the
addition first or do the

00:14:12.620 --> 00:14:14.520
multiplication first?

00:14:14.520 --> 00:14:15.800
Anybody know what happens
In this case?

00:14:15.800 --> 00:14:17.210
Yeah, way up, oh God I'm going
to have a hell of time

00:14:17.210 --> 00:14:18.320
throwing up there, way
up at the back.

00:14:18.320 --> 00:14:25.604
STUDENT: Standard order of
operations, I guess take the

00:14:25.604 --> 00:14:26.040
multiplication first,
and add the three.

00:14:26.040 --> 00:14:26.361
PROFESSOR JIM ERICSON: Right.

00:14:26.361 --> 00:14:27.800
I'm going to try, if I don't
make it, you know, just get

00:14:27.800 --> 00:14:29.220
somebody to pass back, whoa!

00:14:29.220 --> 00:14:30.214
I just hit somebody
in the head.

00:14:30.214 --> 00:14:30.340
Thank you.

00:14:30.340 --> 00:14:32.220
Please pass it back
to that guy.

00:14:32.220 --> 00:14:34.410
If you want candy, sit much
closer down, and that way we

00:14:34.410 --> 00:14:36.310
can film you as well
as we go along.

00:14:36.310 --> 00:14:36.590
Right.

00:14:36.590 --> 00:14:39.000
So the point is, there is
something here called operator

00:14:39.000 --> 00:14:45.530
precedence, which is what
the gentleman said.

00:14:45.530 --> 00:14:48.150
I'm not going to say much more
about it, but basically what

00:14:48.150 --> 00:14:52.110
it says is, with all other
things being equal, things

00:14:52.110 --> 00:14:56.750
like exponentiation are done
before you do multiplication

00:14:56.750 --> 00:15:00.100
or division, which are done
before you do things like

00:15:00.100 --> 00:15:02.320
addition and subtraction.

00:15:02.320 --> 00:15:04.485
And so, in fact, if I wanted
the other version of it, in

00:15:04.485 --> 00:15:06.730
fact, if I do this right, it's
going to give me 23 because it

00:15:06.730 --> 00:15:09.370
does the multiplication first,
if I wanted the other version

00:15:09.370 --> 00:15:13.160
of it, I need to tell it that,
by using, excuse me,

00:15:13.160 --> 00:15:14.970
parentheses.

00:15:14.970 --> 00:15:16.720
And in general, what I
would say is, when

00:15:16.720 --> 00:15:26.410
in doubt, use parens.

00:15:26.410 --> 00:15:29.010
OK.

00:15:29.010 --> 00:15:32.830
Now, that just gives
us expressions.

00:15:32.830 --> 00:15:35.110
We can start having complex
expressions, you can imagine

00:15:35.110 --> 00:15:36.920
we can have things are lots of
parens, and all sorts of

00:15:36.920 --> 00:15:37.340
things in it.

00:15:37.340 --> 00:15:38.010
Yes, question.

00:15:38.010 --> 00:15:46.102
STUDENT: What does it mean, the
operator used, when you

00:15:46.102 --> 00:15:46.260
were calculating the remainder
between nine and five?

00:15:46.260 --> 00:15:46.540
PROFESSOR JIM ERICSON: It's
the percent sign.

00:15:46.540 --> 00:15:47.230
If you can't read it, I guess
I'm going to have to blow that

00:15:47.230 --> 00:15:47.820
font up, aren't I,
next time around.

00:15:47.820 --> 00:15:49.354
Yeah, it's a percent, so
this percent sign will

00:15:49.354 --> 00:15:52.480
give you the remainder.

00:15:52.480 --> 00:15:53.540
OK.

00:15:53.540 --> 00:15:55.670
Second thing I need to do,
though, is I need to, when I

00:15:55.670 --> 00:15:57.560
get those values, I want
to hang on to them.

00:15:57.560 --> 00:15:59.710
I'd like to give them a name,
so I can refer to them in

00:15:59.710 --> 00:16:00.900
other places.

00:16:00.900 --> 00:16:05.012
And so we saw that as well, the
last piece we had here is

00:16:05.012 --> 00:16:12.880
the ability to create variables,
which have their

00:16:12.880 --> 00:16:20.100
own values, and that's done
using an assignment statement.

00:16:20.100 --> 00:16:24.380
So in particular, that is
an assignment statement.

00:16:24.380 --> 00:16:29.060
It says, take the name x and
create a binding for that name

00:16:29.060 --> 00:16:31.180
to the value of the
sub-expression and in fact to

00:16:31.180 --> 00:16:35.300
do this, to stress a point,
let's do that.

00:16:35.300 --> 00:16:39.130
It's not just a number,
it's any expression.

00:16:39.130 --> 00:16:41.790
What Python will do, is it will
evaluate that expression

00:16:41.790 --> 00:16:43.570
using the kinds of rules we
talked about, and then it

00:16:43.570 --> 00:16:45.690
creates a binding for
x to that value.

00:16:45.690 --> 00:16:47.340
And I want to stress this, we're
going to come back to it

00:16:47.340 --> 00:16:50.060
later on in the term, so the
way I'd like you to think

00:16:50.060 --> 00:16:53.330
about it for now, is that
somewhere in the machine,

00:16:53.330 --> 00:16:57.080
there's a big space that
contains all possible values.

00:16:57.080 --> 00:16:57.250
Right.

00:16:57.250 --> 00:16:59.420
It's a slight lie, it doesn't
have all possible values, but

00:16:59.420 --> 00:17:00.050
you get the idea.

00:17:00.050 --> 00:17:01.640
It has, if you like,
intellectually,

00:17:01.640 --> 00:17:03.100
all possible values.

00:17:03.100 --> 00:17:07.310
And when I create a binding, I'm
taking a variable name, in

00:17:07.310 --> 00:17:11.140
this case x, stored somewhere in
a table, and I'm creating a

00:17:11.140 --> 00:17:20.410
link or a pointer from that
name to that value.

00:17:20.410 --> 00:17:21.740
This is a nuance.

00:17:21.740 --> 00:17:23.480
It's going to make a lot more
sense later on when we

00:17:23.480 --> 00:17:26.040
introduce mutation into our
language, but I want you to

00:17:26.040 --> 00:17:26.870
start thinking of it that way.

00:17:26.870 --> 00:17:29.660
Don't think of it as a specific
box into which we're

00:17:29.660 --> 00:17:32.920
putting things; think of it
as a link to a value.

00:17:32.920 --> 00:17:37.540
I could have, for example,
another assignment statement,

00:17:37.540 --> 00:17:45.630
and that creates a binding from
y into that same value,

00:17:45.630 --> 00:17:47.710
and one of the things as a
conservist I can do is, I

00:17:47.710 --> 00:17:53.180
could have a statement like,
let z be bound to

00:17:53.180 --> 00:17:54.340
the value of x.

00:17:54.340 --> 00:17:55.700
And I said it deliberately
that way.

00:17:55.700 --> 00:17:58.715
That statement says, get the
value of x, which is this

00:17:58.715 --> 00:18:05.250
link, and give z a pointer
to the same place.

00:18:05.250 --> 00:18:08.770
To the value, not to x.

00:18:08.770 --> 00:18:10.470
OK, and we'll just plant that
idea, we're going to come back

00:18:10.470 --> 00:18:13.980
to later on, as we carry on.

00:18:13.980 --> 00:18:14.390
OK.

00:18:14.390 --> 00:18:17.770
So if we have variables, one
of the questions we can ask

00:18:17.770 --> 00:18:25.500
is, what's the type
of the variable.

00:18:25.500 --> 00:18:28.830
And the answer is, it inherits
it from its value.

00:18:28.830 --> 00:18:30.550
OK.

00:18:30.550 --> 00:18:35.810
Yes.

00:18:35.810 --> 00:18:39.380
So if somewhere in my code, I
have that statement, that

00:18:39.380 --> 00:18:41.520
assignment statement,
x now is a variable

00:18:41.520 --> 00:18:44.670
whose value is an integer.

00:18:44.670 --> 00:18:47.980
Unfortunately, at least in
my mind, in Python, these

00:18:47.980 --> 00:18:51.550
variable bindings are
dynamic, or the

00:18:51.550 --> 00:18:55.590
type, rather, is dynamic.

00:18:55.590 --> 00:19:00.990
Meaning, it changes depending on
what the current value is.

00:19:00.990 --> 00:19:03.330
Or said a different way, if
somewhere later on in the

00:19:03.330 --> 00:19:10.110
program I do this, x
now has changed its

00:19:10.110 --> 00:19:14.270
type from INT to string.

00:19:14.270 --> 00:19:16.130
Now why should you care?

00:19:16.130 --> 00:19:21.110
OK, my view is, I
don't like it.

00:19:21.110 --> 00:19:24.330
Especially in the presence
of operator overload.

00:19:24.330 --> 00:19:26.450
Because I might have written
some code in which I'm

00:19:26.450 --> 00:19:28.180
expecting that particular
variable to

00:19:28.180 --> 00:19:29.040
have an integer value.

00:19:29.040 --> 00:19:32.640
If somewhere later on in the
code it shifts to string, I

00:19:32.640 --> 00:19:35.650
might not be manipulating that
and getting actual values out,

00:19:35.650 --> 00:19:37.850
but not what I wanted, and it's
going to be really hard

00:19:37.850 --> 00:19:39.450
for me to chase it back.

00:19:39.450 --> 00:19:41.540
So one of the things I would
like to suggest is that you

00:19:41.540 --> 00:19:46.330
develop some good style here,
and in particular, don't

00:19:46.330 --> 00:19:52.360
change types arbitrarily.

00:19:52.360 --> 00:19:59.380
I can't spell today.

00:19:59.380 --> 00:20:01.570
Meaning, sometimes you need
to do this, but in general

00:20:01.570 --> 00:20:03.300
there's-- at least in my view
and I don't, John, would you

00:20:03.300 --> 00:20:04.350
agree?-- you just don't
want to do this.

00:20:04.350 --> 00:20:05.640
You don't want to make
those changes.

00:20:05.640 --> 00:20:08.920
It just leads to trouble
down the road.

00:20:08.920 --> 00:20:10.530
OK.

00:20:10.530 --> 00:20:12.173
Now, last thing about variables,
and then we're

00:20:12.173 --> 00:20:13.230
going to start pushing
on this, is

00:20:13.230 --> 00:20:14.820
where can you use them?

00:20:14.820 --> 00:20:19.610
And the answer is, you can use
a variable anywhere you can

00:20:19.610 --> 00:20:20.300
use the value.

00:20:20.300 --> 00:20:32.630
So, any place it's legal
to use the value.

00:20:32.630 --> 00:20:35.750
OK.

00:20:35.750 --> 00:20:36.900
Now.

00:20:36.900 --> 00:20:39.420
This is just sort of bringing us
back up to speed and adding

00:20:39.420 --> 00:20:40.240
a few more details in.

00:20:40.240 --> 00:20:42.290
What we really want to
do now though is

00:20:42.290 --> 00:20:44.900
start using this stuff.

00:20:44.900 --> 00:20:46.880
So, operands.

00:20:46.880 --> 00:20:49.890
Let us take expressions, get
values out, we can store them

00:20:49.890 --> 00:20:52.450
away in places, but ultimately
we want to do something with

00:20:52.450 --> 00:20:54.390
them, so we need to now start
talking about what are the

00:20:54.390 --> 00:20:56.740
things we can do inside of
Python, or any programming

00:20:56.740 --> 00:20:58.640
language, to manipulate them.

00:20:58.640 --> 00:21:08.960
And for that, we're going
to have statements.

00:21:08.960 --> 00:21:13.610
Statements are basically, if
you want to think about it,

00:21:13.610 --> 00:21:15.980
legal, and I was about to use
the word expression except

00:21:15.980 --> 00:21:24.530
I've misused that elsewhere, so
legal commands that Python

00:21:24.530 --> 00:21:30.040
can interpret.

00:21:30.040 --> 00:21:32.520
You've already seen
a couple of them.

00:21:32.520 --> 00:21:39.650
Print, assignment, certainly
two obvious statements,

00:21:39.650 --> 00:21:41.000
they're commands to
do something.

00:21:41.000 --> 00:21:43.660
Assignment is binding a name
to a value, print is saying

00:21:43.660 --> 00:21:45.160
put it back out in the screen.

00:21:45.160 --> 00:21:47.240
Obviously if you have print as
a way of putting things out,

00:21:47.240 --> 00:21:48.940
we expect to have ways of
getting input in, we're going

00:21:48.940 --> 00:21:50.630
to see an example that
in the second.

00:21:50.630 --> 00:21:52.340
And as we go through the next
few lectures, we're going to

00:21:52.340 --> 00:21:54.190
add in more and more of
these statements.

00:21:54.190 --> 00:21:56.830
But let's look at what we
could do with this, OK?

00:21:56.830 --> 00:21:59.240
And to do this, I'm going to
use some code that I've

00:21:59.240 --> 00:22:00.450
already typed in.

00:22:00.450 --> 00:22:01.850
So I'm hoping you can
read that, and it's

00:22:01.850 --> 00:22:03.210
also in your handout.

00:22:03.210 --> 00:22:06.780
This is a little file I created,
all right, and I'm

00:22:06.780 --> 00:22:09.850
going to start with a sequence
of these things and walk them

00:22:09.850 --> 00:22:12.440
along, again I invite you to put
comments on that handout

00:22:12.440 --> 00:22:14.830
so that you can follow what
we're going to do.

00:22:14.830 --> 00:22:15.450
All right?

00:22:15.450 --> 00:22:16.730
So let's look at the
first part of this.

00:22:16.730 --> 00:22:19.520
Right now, this is
just a text file.

00:22:19.520 --> 00:22:19.700
OK.

00:22:19.700 --> 00:22:21.790
And I've highlighted in blue up
there one of the pieces I'm

00:22:21.790 --> 00:22:22.870
going to start with.

00:22:22.870 --> 00:22:23.380
And what do I have?

00:22:23.380 --> 00:22:25.320
I have a sequence of commands;
I've got an assignment

00:22:25.320 --> 00:22:27.710
statement, I've got another
assignment statement, I've got

00:22:27.710 --> 00:22:29.900
a print statement, I've got an
input statement, which we'll

00:22:29.900 --> 00:22:31.940
come back to in a second.

00:22:31.940 --> 00:22:34.350
And I want to basically try
and use these things to do

00:22:34.350 --> 00:22:35.660
something with them.

00:22:35.660 --> 00:22:38.270
Second thing I want to note is,
the little hash mark or

00:22:38.270 --> 00:22:41.600
the pound sign, that's
identifying a comment.

00:22:41.600 --> 00:22:42.390
So what's a comment?

00:22:42.390 --> 00:22:46.060
It's words to you, or to the
reader of the code, that are

00:22:46.060 --> 00:22:47.980
telling you what's going
on inside of this code.

00:22:47.980 --> 00:22:49.690
OK?

00:22:49.690 --> 00:22:54.770
Now, these comments, frankly,
are brain-damaged, or

00:22:54.770 --> 00:22:57.330
computationally challenged
if you prefer.

00:22:57.330 --> 00:23:00.590
Meaning, why in the world do I
have to tell the reader that

00:23:00.590 --> 00:23:02.480
I'm binding x to the
value three?

00:23:02.480 --> 00:23:02.770
All right?

00:23:02.770 --> 00:23:04.870
I'm putting them in there
to make a point.

00:23:04.870 --> 00:23:08.510
In general, good programming
style says you put in comments

00:23:08.510 --> 00:23:11.880
that are going to be valuable
in helping you as a reader

00:23:11.880 --> 00:23:14.780
understand what's going
on inside of the code.

00:23:14.780 --> 00:23:16.430
It could be, what's the
intuition behind

00:23:16.430 --> 00:23:17.080
this piece of code.

00:23:17.080 --> 00:23:19.580
It could be, preconditions
I want to have on input.

00:23:19.580 --> 00:23:22.420
It could be, explanations of
specific things you're doing.

00:23:22.420 --> 00:23:25.320
But you need to have those
comments there.

00:23:25.320 --> 00:23:27.540
Now, this becomes a little bit
of one of those motherhood and

00:23:27.540 --> 00:23:28.800
apple pie kinds of lectures.

00:23:28.800 --> 00:23:30.370
You know, your mother always
told you to eat brussels

00:23:30.370 --> 00:23:32.270
sprouts because it
was good for you.

00:23:32.270 --> 00:23:34.050
Well this is a brussels sprouts
comment. everybody

00:23:34.050 --> 00:23:35.480
goes yeah, yeah, yeah,
comments, of course.

00:23:35.480 --> 00:23:36.580
Of course we're going
to do comments.

00:23:36.580 --> 00:23:38.250
And they never do.

00:23:38.250 --> 00:23:40.730
So my challenge to you, and I
know Professor Guttag can do

00:23:40.730 --> 00:23:44.800
this, my challenge to you is, a
year from now, come back and

00:23:44.800 --> 00:23:46.650
look at code you wrote here.

00:23:46.650 --> 00:23:50.860
Can you still understand what it
was you were trying to do?

00:23:50.860 --> 00:23:52.170
I don't know, John, if
you'd agree, right?

00:23:52.170 --> 00:23:54.210
If you can read the code a
year later, even code you

00:23:54.210 --> 00:23:56.630
wrote yourself, it's a good
sign that you put good

00:23:56.630 --> 00:23:59.340
comments in, right?

00:23:59.340 --> 00:24:01.360
Second good piece
of style here is

00:24:01.360 --> 00:24:03.530
choice of variable names.

00:24:03.530 --> 00:24:05.200
These are lousy.

00:24:05.200 --> 00:24:06.040
Deliberately.

00:24:06.040 --> 00:24:06.840
OK?

00:24:06.840 --> 00:24:09.260
I'm just using simple things
like x and y and z because I

00:24:09.260 --> 00:24:10.600
want to make it, just
get through the

00:24:10.600 --> 00:24:11.340
lecture if you like.

00:24:11.340 --> 00:24:14.310
But in general, the choice of
variable name is a great way

00:24:14.310 --> 00:24:15.860
of commenting your code.

00:24:15.860 --> 00:24:19.000
Use variable names
that make sense.

00:24:19.000 --> 00:24:21.250
That little problem set
zero that you did.

00:24:21.250 --> 00:24:22.340
You read in a couple
of values, you

00:24:22.340 --> 00:24:23.960
probably stored them away.

00:24:23.960 --> 00:24:27.340
My bet is, you used simple
names like x and y.

00:24:27.340 --> 00:24:29.790
A much better name would have
been firstname, lastname, as

00:24:29.790 --> 00:24:31.650
the name of the variable to tell
you what you were trying

00:24:31.650 --> 00:24:33.540
to capture there.

00:24:33.540 --> 00:24:34.390
OK.

00:24:34.390 --> 00:24:38.300
The other piece I want to say
about variable names is, once

00:24:38.300 --> 00:24:41.980
I have that choice of variable
name, I can use it, but in

00:24:41.980 --> 00:24:44.260
fact there are a few things that
I can't use in terms of

00:24:44.260 --> 00:24:45.030
variable names.

00:24:45.030 --> 00:24:58.100
So, these are an important way
of documenting, but there're

00:24:58.100 --> 00:24:59.040
some things excluded.

00:24:59.040 --> 00:25:04.210
And in particular, there are
some key words that Python is

00:25:04.210 --> 00:25:07.270
going to use that have
to be excluded.

00:25:07.270 --> 00:25:09.180
Let me highlight that.

00:25:09.180 --> 00:25:10.860
As I said, right now that's
just text file.

00:25:10.860 --> 00:25:15.560
I'm going to save this away--
yeah, not that way, I'm going

00:25:15.560 --> 00:25:22.700
to save this away-- with the
subscript, or the suffix

00:25:22.700 --> 00:25:25.480
rather, py to make
it a Python file.

00:25:25.480 --> 00:25:28.600
Yeah, and I know it's already
there but I'm going to do it,

00:25:28.600 --> 00:25:30.920
and I get some wonderful
colors.

00:25:30.920 --> 00:25:33.130
But these are important, OK?

00:25:33.130 --> 00:25:34.640
So notice what I have
up there now.

00:25:34.640 --> 00:25:35.830
Comments appear in red.

00:25:35.830 --> 00:25:37.310
I can see those.

00:25:37.310 --> 00:25:39.580
There's a keyword, which I'm
going to highlight right up

00:25:39.580 --> 00:25:41.850
here, print, which is in,
I don't know what

00:25:41.850 --> 00:25:44.550
that color is, orange?

00:25:44.550 --> 00:25:48.330
There's a function in purple,
there's a string in green, and

00:25:48.330 --> 00:25:51.160
in black I have the assignment
statements.

00:25:51.160 --> 00:25:53.260
That print is a keyword.

00:25:53.260 --> 00:25:56.980
It's a command to Python
to do something.

00:25:56.980 --> 00:26:00.690
As a consequence, I can't use
it as a variable name.

00:26:00.690 --> 00:26:01.780
All right, think about
it for a second.

00:26:01.780 --> 00:26:04.680
If I wanted to use print as a
variable name, how do I get

00:26:04.680 --> 00:26:08.980
the system to decide gee, do
I want print as a value for

00:26:08.980 --> 00:26:11.560
something, or do I want
print as a command?

00:26:11.560 --> 00:26:13.670
So there's a sequence of these
that are blocked out, and I--

00:26:13.670 --> 00:26:16.340
John, I think there are
what, twenty-eight?

00:26:16.340 --> 00:26:18.020
Something like that,
TAs, is that right?

00:26:18.020 --> 00:26:20.930
Twenty-eight keywords
that are blocked?

00:26:20.930 --> 00:26:23.240
We'll find them as
we go along--

00:26:23.240 --> 00:26:24.530
OK.

00:26:24.530 --> 00:26:26.710
Having done this now, I can
simply go ahead and run this,

00:26:26.710 --> 00:26:29.120
and in fact if I go up here to
run, you'll see I've got both

00:26:29.120 --> 00:26:31.800
an option to check the module,
though in this case I'm just

00:26:31.800 --> 00:26:33.790
going to run it.

00:26:33.790 --> 00:26:35.340
Oh, notice what happened.

00:26:35.340 --> 00:26:37.620
It ran through that sequence of
instructions, in particular

00:26:37.620 --> 00:26:41.450
it bound x to the value three,
and then it took x times x,

00:26:41.450 --> 00:26:43.800
got the value of x multipied by
x, which of course is nine,

00:26:43.800 --> 00:26:46.670
bound that to the value of x,
and then it printed out the

00:26:46.670 --> 00:26:49.610
value, and now it's sitting
here waiting for an input.

00:26:49.610 --> 00:26:52.180
You notice what it did, it
printed out that little, right

00:26:52.180 --> 00:26:53.980
up here I'd said enter a number
and that's what it's

00:26:53.980 --> 00:26:58.790
printed out, so I can enter a
number and it prints it out.

00:26:58.790 --> 00:27:00.450
Great.

00:27:00.450 --> 00:27:01.950
Let's run it again.

00:27:01.950 --> 00:27:04.370
Actually for that, I can just
use, if I'm lucky, function

00:27:04.370 --> 00:27:09.220
F5, which didn't work, so let me
try it again., here we go.

00:27:09.220 --> 00:27:11.550
We're going to run that module.

00:27:11.550 --> 00:27:14.690
OK.

00:27:14.690 --> 00:27:17.050
Whoa.

00:27:17.050 --> 00:27:20.030
What happened?

00:27:20.030 --> 00:27:20.810
I said enter a number.

00:27:20.810 --> 00:27:21.130
I didn't.

00:27:21.130 --> 00:27:21.970
I gave it a string.

00:27:21.970 --> 00:27:23.240
And it still took it.

00:27:23.240 --> 00:27:25.080
And printed it up.

00:27:25.080 --> 00:27:26.790
Well, this is one of the places
where I want to come

00:27:26.790 --> 00:27:29.840
back to that highlighting
of what do things do?

00:27:29.840 --> 00:27:33.370
Even though my statement said
enter a number, in particular,

00:27:33.370 --> 00:27:37.040
raw input here simply takes in a
set of characters and treats

00:27:37.040 --> 00:27:38.390
it as a string.

00:27:38.390 --> 00:27:39.930
And then prints it back out.

00:27:39.930 --> 00:27:42.220
So if in fact I wanted to make
sure this was a number, I

00:27:42.220 --> 00:27:44.460
should have done something like
either try and convert it

00:27:44.460 --> 00:27:47.330
to a number, which of course
failed here, or put in a check

00:27:47.330 --> 00:27:48.610
to say where it is.

00:27:48.610 --> 00:27:50.620
So it's a way of reminding you,
I've got to be careful

00:27:50.620 --> 00:27:53.530
about the types of things
that I put in.

00:27:53.530 --> 00:27:56.380
OK.

00:27:56.380 --> 00:28:01.100
This is still boring, so let's
step on the accelerator.

00:28:01.100 --> 00:28:04.710
What I have now is the
following: I can write

00:28:04.710 --> 00:28:07.660
expressions, do combinations of
things to get out values, I

00:28:07.660 --> 00:28:11.260
can store them away, I
can print them up.

00:28:11.260 --> 00:28:13.760
But literally all I can do at
this stage is write what we

00:28:13.760 --> 00:28:18.060
would call a straight-line
program, that is, a program in

00:28:18.060 --> 00:28:28.540
which we execute in which we
execute the sequence of

00:28:28.540 --> 00:28:31.300
instructions one by one.

00:28:31.300 --> 00:28:34.240
Simply walk down that
list. That's what we

00:28:34.240 --> 00:28:34.790
just did there, right?

00:28:34.790 --> 00:28:36.780
We just walked through that
list. This is boring.

00:28:36.780 --> 00:28:39.290
In fact, you can do some nice
things to prove what is the

00:28:39.290 --> 00:28:42.220
class of functions you can
compute with straight-line

00:28:42.220 --> 00:28:44.330
programs, and what you'd see if
you did that is, it's not

00:28:44.330 --> 00:28:46.730
particularly interesting.

00:28:46.730 --> 00:28:48.050
OK.

00:28:48.050 --> 00:28:49.890
Let's go back and think
about our recipes.

00:28:49.890 --> 00:28:52.010
What we use as our
motivation here.

00:28:52.010 --> 00:28:54.880
Even in real recipes, you
have things like,

00:28:54.880 --> 00:28:59.210
if needed, add sugar.

00:28:59.210 --> 00:29:00.320
That's a decision.

00:29:00.320 --> 00:29:01.520
That's a conditional.

00:29:01.520 --> 00:29:02.340
That's a branch.

00:29:02.340 --> 00:29:04.910
That says, if something
is true, do something.

00:29:04.910 --> 00:29:06.970
Otherwise, do something
different.

00:29:06.970 --> 00:29:09.510
So to really add to this, we
need to have branching

00:29:09.510 --> 00:29:19.370
programs. What I mean by that
is, a branching program is

00:29:19.370 --> 00:29:32.750
something that can change the
order of instructions based on

00:29:32.750 --> 00:29:46.620
some test. And that test is
usually a value of a variable.

00:29:46.620 --> 00:29:47.730
OK.

00:29:47.730 --> 00:29:49.910
And these get a whole lot
more interesting.

00:29:49.910 --> 00:29:52.260
So let's look at a little
example, and this is going to,

00:29:52.260 --> 00:29:54.590
excuse me, both allow us
introduce the syntax as well

00:29:54.590 --> 00:29:56.520
as what we want to have
as the flow of

00:29:56.520 --> 00:29:57.530
control inside of here.

00:29:57.530 --> 00:30:02.960
So let me go back up here, and
I'm going to comment out that

00:30:02.960 --> 00:30:10.250
region, and let's uncomment
this region.

00:30:10.250 --> 00:30:12.480
I want to write a little
piece of code.

00:30:12.480 --> 00:30:14.890
It's going to print out even or
odd, depending on whether

00:30:14.890 --> 00:30:19.100
the value I put in, which is x
in this case, is even or odd.

00:30:19.100 --> 00:30:20.860
Think about that.

00:30:20.860 --> 00:30:24.490
That says, if this thing has
some particular value, I want

00:30:24.490 --> 00:30:26.420
to do one thing; otherwise,
I want to

00:30:26.420 --> 00:30:28.010
do something different.

00:30:28.010 --> 00:30:29.970
And let's look at the
syntax of this.

00:30:29.970 --> 00:30:31.936
This is the first of the
conditionals that

00:30:31.936 --> 00:30:36.530
we're going to see.

00:30:36.530 --> 00:30:38.740
Notice the format.

00:30:38.740 --> 00:30:39.290
I'm going to go up there.

00:30:39.290 --> 00:30:41.360
The first statement right
here, that's just an

00:30:41.360 --> 00:30:43.100
assignment statement, I'm
giving some value to x.

00:30:43.100 --> 00:30:45.100
We could make it something
different.

00:30:45.100 --> 00:30:47.360
And then, notice the
structure here.

00:30:47.360 --> 00:30:48.310
The next three statements.

00:30:48.310 --> 00:30:50.900
First of all, IF is a keyword.
which makes sense.

00:30:50.900 --> 00:30:55.430
It is followed, as you can see
there, by some expression,

00:30:55.430 --> 00:30:56.360
followed by a colon.

00:30:56.360 --> 00:30:59.950
And in fact, that colon is
important, so let me stress

00:30:59.950 --> 00:31:00.680
this over here.

00:31:00.680 --> 00:31:11.930
The colon is important It's
defining the beginning of a

00:31:11.930 --> 00:31:12.970
block of instructions.

00:31:12.970 --> 00:31:13.380
Yes sir.

00:31:13.380 --> 00:31:17.200
STUDENT: [UNINTELLIGIBLE]

00:31:17.200 --> 00:31:19.150
PROFESSOR JIM ERICSON: Based on
a test. Usually the value

00:31:19.150 --> 00:31:21.490
of a variable.

00:31:21.490 --> 00:31:22.620
OK, so let me go back
to where I am.

00:31:22.620 --> 00:31:23.580
I'm looking at that
piece of code.

00:31:23.580 --> 00:31:27.260
What that colon is saying is,
I'm about to begin a sequence

00:31:27.260 --> 00:31:29.840
of instructions that I want
to treat as a block.

00:31:29.840 --> 00:31:38.940
So it identifies a block
of instructions.

00:31:38.940 --> 00:31:43.000
It's, and in particular, the
colon is the start, and the

00:31:43.000 --> 00:31:48.340
carriage return is the end.

00:31:48.340 --> 00:31:49.210
Now what in the world
does that mean?

00:31:49.210 --> 00:31:50.930
I'm doing a lot of words here,
let me try and say this a

00:31:50.930 --> 00:31:51.540
little bit better.

00:31:51.540 --> 00:31:54.290
That code says the following:
the IF says, I've got an

00:31:54.290 --> 00:31:56.540
expression, I'm going
to evaluate it.

00:31:56.540 --> 00:32:01.350
If that value is true, I want
to do a set of things.

00:32:01.350 --> 00:32:04.230
And that set of things is
identified by the sequence of

00:32:04.230 --> 00:32:09.020
commands that are indented in,
this one right here, following

00:32:09.020 --> 00:32:12.600
the colon but before I get
back to the same place in

00:32:12.600 --> 00:32:14.940
terms of the indentation.

00:32:14.940 --> 00:32:19.780
If that test is not true, I want
to skip this instruction,

00:32:19.780 --> 00:32:23.340
and there's a second keyword
else, followed by a colon, and

00:32:23.340 --> 00:32:24.880
that tells me the thing
I want to do in the

00:32:24.880 --> 00:32:26.880
case that it's false.

00:32:26.880 --> 00:32:36.020
So in fact if I run this,
ah, and save it, and

00:32:36.020 --> 00:32:37.680
it prints out odd.

00:32:37.680 --> 00:32:39.250
So, what happened here?

00:32:39.250 --> 00:32:41.250
Well, let's look at the code.

00:32:41.250 --> 00:32:43.410
Right? x is initially
bound to fifteen.

00:32:43.410 --> 00:32:44.250
I get to the IF.

00:32:44.250 --> 00:32:46.550
The IF says, evaluate that
next expression.

00:32:46.550 --> 00:32:49.270
In that next expression, I'm
actually taking advantage of

00:32:49.270 --> 00:32:51.380
the fact that I'm doing integer
multiplication and

00:32:51.380 --> 00:32:52.720
division here.

00:32:52.720 --> 00:32:55.100
Right, that divide is, if x is
an integer and two is an

00:32:55.100 --> 00:32:56.000
integer, what's it
going to do?

00:32:56.000 --> 00:32:59.670
If x was even, x divided by two
is going to be actually

00:32:59.670 --> 00:33:02.200
the half of x, right?

00:33:02.200 --> 00:33:04.740
If x is odd, that integer
division is going to give me

00:33:04.740 --> 00:33:08.340
the number of multiples of two,
that go into x, plus a

00:33:08.340 --> 00:33:11.580
remainder, which I'm going
to throw away.

00:33:11.580 --> 00:33:13.970
In either case, I take that
value and multiply back by

00:33:13.970 --> 00:33:17.930
two, if it was even I get back
the original number, if it was

00:33:17.930 --> 00:33:20.530
odd, I'm not going to get back
the original number, so I can

00:33:20.530 --> 00:33:22.940
just check to see if
they're the same.

00:33:22.940 --> 00:33:24.510
OK, so a little nuance
that I'm using there.

00:33:24.510 --> 00:33:26.560
So, the first thing that IF
does, bleah that IF says is,

00:33:26.560 --> 00:33:30.220
evaluate that expression and
if it's true, do the next

00:33:30.220 --> 00:33:31.820
thing, the thing after
the colon.

00:33:31.820 --> 00:33:34.290
In this case it's not true, so
it's going to skip down and

00:33:34.290 --> 00:33:38.110
evaluate the thing printed
up the odd.

00:33:38.110 --> 00:33:38.390
OK.

00:33:38.390 --> 00:33:38.900
What-- yes.

00:33:38.900 --> 00:33:41.850
STUDENT: [INAUDIBLE]

00:33:41.850 --> 00:33:42.895
PROFESSOR JIM ERICSON:
Thank you.

00:33:42.895 --> 00:33:44.510
I was hoping somebody would
ask that question.

00:33:44.510 --> 00:33:47.635
The question was, if you didn't
hear, why do I have two

00:33:47.635 --> 00:33:49.070
equal signs?

00:33:49.070 --> 00:33:51.380
It's like I'm doing
this, right?

00:33:51.380 --> 00:33:52.680
Anybody have a se--%uFFFD
why don't I just

00:33:52.680 --> 00:33:53.390
use an equal sign?

00:33:53.390 --> 00:33:54.790
I want to know if something's
equal to something.

00:33:54.790 --> 00:33:55.210
Yeah.

00:33:55.210 --> 00:33:55.814
STUDENT: [INAUDIBLE]

00:33:55.814 --> 00:33:58.875
PROFESSOR JIM ERICSON:
Absolutely.

00:33:58.875 --> 00:34:02.510
The equal sign is
going to bind--

00:34:02.510 --> 00:34:05.060
Nice catch.

00:34:05.060 --> 00:34:06.640
John, this is so much
fun, throwing candy.

00:34:06.640 --> 00:34:07.950
I've got to say, we've got
to do this more often--

00:34:07.950 --> 00:34:08.160
Right.

00:34:08.160 --> 00:34:09.420
Let me, let me get
to the point.

00:34:09.420 --> 00:34:10.520
What does an equal sign do?

00:34:10.520 --> 00:34:11.560
It is an assignment.

00:34:11.560 --> 00:34:14.790
It says, take this thing on the
left and use it as a name

00:34:14.790 --> 00:34:17.050
to bind to the value
on the right.

00:34:17.050 --> 00:34:17.950
It's not what I want here.

00:34:17.950 --> 00:34:20.720
Having already chosen to use
equal as an assignment, I need

00:34:20.720 --> 00:34:23.130
something else to
do comparison.

00:34:23.130 --> 00:34:24.570
And that's why I use
double equals.

00:34:24.570 --> 00:34:27.320
Those two equal signs are
saying, is this thing equal

00:34:27.320 --> 00:34:31.450
to, in value, the thing
on the other side?

00:34:31.450 --> 00:34:32.780
OK.

00:34:32.780 --> 00:34:36.050
Now, having done that, again I
want to stress this idea and

00:34:36.050 --> 00:34:38.520
I'm going to write it out one
more time, that there's a

00:34:38.520 --> 00:34:42.780
particular format here.

00:34:42.780 --> 00:34:47.080
So we have if, and that is
followed by, I'm going to use

00:34:47.080 --> 00:34:49.100
angle braces here just to
indicates something goes in

00:34:49.100 --> 00:34:54.080
here, some test followed
by a colon.

00:34:54.080 --> 00:35:02.470
That is followed by a block
of instructions.

00:35:02.470 --> 00:35:08.420
And we have an ELSE, followed by
a colon in some other block

00:35:08.420 --> 00:35:17.240
of instructions.

00:35:17.240 --> 00:35:20.240
And I want you to get used to
this, that colon is important,

00:35:20.240 --> 00:35:23.860
it identifies the start, and
then the set of indented

00:35:23.860 --> 00:35:26.740
things identify all the things
at the same level, and when we

00:35:26.740 --> 00:35:29.130
reset back to the previous
level, that's when we go back

00:35:29.130 --> 00:35:31.070
to where we were.

00:35:31.070 --> 00:35:32.900
OK.

00:35:32.900 --> 00:35:35.750
Now, that's a nice simple little
test, let's look at a

00:35:35.750 --> 00:35:37.460
couple of other examples
to get a sense of

00:35:37.460 --> 00:35:39.270
what this will do.

00:35:39.270 --> 00:35:48.130
OK, let me comment this out,
and let's look at this next

00:35:48.130 --> 00:35:50.260
little piece of code.

00:35:50.260 --> 00:35:51.470
All right.

00:35:51.470 --> 00:35:53.670
I'm binding a z to be some
value, and then I'm

00:35:53.670 --> 00:35:55.050
going to run this.

00:35:55.050 --> 00:36:02.040
Well, let's just run it
and see what it does.

00:36:02.040 --> 00:36:03.590
Nothing.

00:36:03.590 --> 00:36:04.240
OK, so why?

00:36:04.240 --> 00:36:05.010
Well, let's look at it.

00:36:05.010 --> 00:36:08.950
I'm doing a test there to say,
if the string x is less than

00:36:08.950 --> 00:36:12.680
the value of b, and x does not
appear before b as strings,

00:36:12.680 --> 00:36:16.550
then I was going to do, oh, a
couple of things, because

00:36:16.550 --> 00:36:18.930
they're at the same
block level.

00:36:18.930 --> 00:36:22.330
Given that that wasn't
true, it did nothing.

00:36:22.330 --> 00:36:25.010
Now, wait a minute, you say,
where's the ELSE clause?

00:36:25.010 --> 00:36:26.390
And the answer is,
I don't need one.

00:36:26.390 --> 00:36:29.820
All right, if this is purely a
test of, if this is true do

00:36:29.820 --> 00:36:32.590
this otherwise I don't care, I
don't need the ELSE clause in

00:36:32.590 --> 00:36:33.120
there to identify it.

00:36:33.120 --> 00:36:35.820
All right?

00:36:35.820 --> 00:36:39.100
Second thing I want to look at
is, suppose I compare that the

00:36:39.100 --> 00:36:39.760
one below it.

00:36:39.760 --> 00:36:45.720
Oops, that I don't want to do.

00:36:45.720 --> 00:36:53.840
Comment that out, and let's
uncomment this.

00:36:53.840 --> 00:36:56.310
Yeah, I've still got a binding
for z and I'm giving it the

00:36:56.310 --> 00:36:59.710
same test, but notice now I've
got the two same commands but

00:36:59.710 --> 00:37:01.830
they have different
indentation.

00:37:01.830 --> 00:37:08.790
In this case, in fact I do
get a different behavior.

00:37:08.790 --> 00:37:10.330
Why?

00:37:10.330 --> 00:37:14.100
Because that block identifies a
set of things that I'm going

00:37:14.100 --> 00:37:16.090
to do if the test is true.

00:37:16.090 --> 00:37:18.630
If the test was not true, notice
that that last command

00:37:18.630 --> 00:37:21.520
for print Mon is now back at the
same level as the IF, so

00:37:21.520 --> 00:37:25.190
what this says is the IF does
the test, having done the

00:37:25.190 --> 00:37:27.300
test, it decides I'm not going
to do anything in the block

00:37:27.300 --> 00:37:29.830
below it, I'm going to skip
down therefore to the next

00:37:29.830 --> 00:37:32.850
instruction at the same level
as the IF, which gets me to

00:37:32.850 --> 00:37:35.690
the second print statement.

00:37:35.690 --> 00:37:36.140
OK.

00:37:36.140 --> 00:37:38.830
So now we're seeing some of
these variations, let's see

00:37:38.830 --> 00:37:39.800
what else can we do here.

00:37:39.800 --> 00:37:41.550
So let me just to try something
a little more

00:37:41.550 --> 00:37:43.520
interesting, and then we'll
get to writing some simple

00:37:43.520 --> 00:37:47.000
programs. So I'm going to
comment those out, and let's

00:37:47.000 --> 00:37:53.820
go down to this piece of
code, and uncomment it.

00:37:53.820 --> 00:37:55.710
Ooh yes, that was brilliant.

00:37:55.710 --> 00:37:59.010
Let's try this again.

00:37:59.010 --> 00:38:04.980
And uncomment that, and
uncomment it again.

00:38:04.980 --> 00:38:06.870
Right, so here's a little piece
of code that's going to

00:38:06.870 --> 00:38:09.670
print out the smallest
value of three.

00:38:09.670 --> 00:38:12.140
And notice what this
is showing is that

00:38:12.140 --> 00:38:13.760
the IFs can be nested.

00:38:13.760 --> 00:38:15.390
All right, it's so if I looked
at it, it's going to say that

00:38:15.390 --> 00:38:18.860
IF x is y-- sorry, IF x is less
than y, THEN check to see

00:38:18.860 --> 00:38:22.930
IF x is less than z, and if
that's true, print out x is

00:38:22.930 --> 00:38:26.260
the smallest. And notice the
structure of it, if it's not

00:38:26.260 --> 00:38:28.380
true I'm going to go to that
next ELSE, and print out that

00:38:28.380 --> 00:38:31.330
z is smallest. If the first test
wasn't true, I'm going to

00:38:31.330 --> 00:38:33.680
skip that whole block and just
go down and print out that y

00:38:33.680 --> 00:38:37.190
was smallest. So notice the
nesting, I can flow my way

00:38:37.190 --> 00:38:40.240
through how those tests are
actually going to take place.

00:38:40.240 --> 00:38:46.570
All right, so let's run this
and see what happens.

00:38:46.570 --> 00:38:50.970
Great. y is smallest. OK.

00:38:50.970 --> 00:38:55.070
Is that code correct?

00:38:55.070 --> 00:38:56.680
Is that a tentative
hand back there?

00:38:56.680 --> 00:38:57.650
Yeah.

00:38:57.650 --> 00:39:00.900
STUDENT: Let me compare
y to [INAUDIBLE]

00:39:00.900 --> 00:39:02.320
PROFESSOR JIM ERICSON: Yeah,
it's not doing all of the

00:39:02.320 --> 00:39:03.440
comparisons.

00:39:03.440 --> 00:39:05.055
All right, and let's just check
this out, because I want

00:39:05.055 --> 00:39:08.220
to make a point of this, let's
go back and do the following.

00:39:08.220 --> 00:39:18.150
Let's take y, change it to
thirteen, let's run it, hmm.

00:39:18.150 --> 00:39:20.380
So what did I miss here?

00:39:20.380 --> 00:39:22.120
Two important points.

00:39:22.120 --> 00:39:24.770
First one, when I write a piece
of code, especially code

00:39:24.770 --> 00:39:28.600
that has branches in it, when
I design test cases for that

00:39:28.600 --> 00:39:32.310
piece of code, I should try and
have a specific test case

00:39:32.310 --> 00:39:35.940
for each possible path
through the code.

00:39:35.940 --> 00:39:38.640
And by just doing that, I just
spotted, there's a bug here.

00:39:38.640 --> 00:39:40.440
And the bug was in my thinking,
I did not look for

00:39:40.440 --> 00:39:41.110
all of the tests.

00:39:41.110 --> 00:39:49.680
So the way I can fix that, is,
let me comment that out, and

00:39:49.680 --> 00:40:03.610
keep doing that, comment that
out, let's uncomment this,

00:40:03.610 --> 00:40:04.880
notice the structure here.

00:40:04.880 --> 00:40:06.610
I now have multiple tests.

00:40:06.610 --> 00:40:08.340
So actually, let's just run
it and then we'll talk

00:40:08.340 --> 00:40:09.140
about what it does.

00:40:09.140 --> 00:40:16.320
I run this, yeah, I have a
syntax error, yes indeed,

00:40:16.320 --> 00:40:20.060
because I forgot to comment that
one out, all right, and

00:40:20.060 --> 00:40:27.640
cue, we'll try it again.

00:40:27.640 --> 00:40:29.200
Ah-ha!

00:40:29.200 --> 00:40:31.940
And let's quickly look at
the structure of this.

00:40:31.940 --> 00:40:34.740
This now has, gee, a funny
thing, it says IF x is less

00:40:34.740 --> 00:40:39.530
than y AND x is less than
z, then do something.

00:40:39.530 --> 00:40:42.300
And then it has a strange thing
called ELIF, which is

00:40:42.300 --> 00:40:46.210
simply short for else/if in a
second test. So the way to

00:40:46.210 --> 00:40:48.370
think about this in terms of
flow is, it starts with that

00:40:48.370 --> 00:40:51.470
if and it says, check both
of those things.

00:40:51.470 --> 00:40:54.000
And that fact that both of those
things is the fact that

00:40:54.000 --> 00:41:06.520
we're using Boolean
combination here.

00:41:06.520 --> 00:41:11.510
It is to say, we can take any
logical expressions, combine

00:41:11.510 --> 00:41:14.440
them together with AND, OR,
or NOT to make a complex

00:41:14.440 --> 00:41:17.830
expression, and use the value of
that expression as my test.

00:41:17.830 --> 00:41:19.755
And that's literally what I've
done there, right, I've got x

00:41:19.755 --> 00:41:22.000
less than y, that's a test, it
returns a Boolean, which by

00:41:22.000 --> 00:41:25.125
the way is the other type, at
least I would include here, it

00:41:25.125 --> 00:41:32.880
has only two values, which are
true and false, and what that

00:41:32.880 --> 00:41:37.870
code says, if x is less than y,
AND, logically, whatever I

00:41:37.870 --> 00:41:42.620
put up there, x is less than
z, then the combination is

00:41:42.620 --> 00:41:44.610
true, and therefore I'm
going to do something.

00:41:44.610 --> 00:41:47.850
So AND is if both arguments are
true it's true, OR is if

00:41:47.850 --> 00:41:50.330
either argument it's true it's
true, NOT is if the argument

00:41:50.330 --> 00:41:53.565
is not true it's true, and then
the last piece, as I said

00:41:53.565 --> 00:41:56.540
is, I can now have a sequence
of things I want to do.

00:41:56.540 --> 00:41:58.690
So if this is true do something
else, otherwise test

00:41:58.690 --> 00:42:00.960
and see if this is true, do
something else, as many as I

00:42:00.960 --> 00:42:02.200
like followed by the end.

00:42:02.200 --> 00:42:05.560
And ELSE, it says, here's
what I want to do.

00:42:05.560 --> 00:42:07.050
OK.

00:42:07.050 --> 00:42:09.080
Now.

00:42:09.080 --> 00:42:12.330
Having added this in, I have
branching instructions.

00:42:12.330 --> 00:42:15.260
I have simple branching
programs. These are still

00:42:15.260 --> 00:42:16.450
awfully simple.

00:42:16.450 --> 00:42:16.645
OK?

00:42:16.645 --> 00:42:20.530
And they're awfully simple
because, all I can do now, is

00:42:20.530 --> 00:42:24.440
decide whether to execute some
piece of code or another.

00:42:24.440 --> 00:42:26.430
Said a different way, in the
case of the straight-line

00:42:26.430 --> 00:42:29.360
programs, how long would it
take to run a program?

00:42:29.360 --> 00:42:31.760
Well, basically, however many
instructions I have, because

00:42:31.760 --> 00:42:33.690
I've got to do each
one in order.

00:42:33.690 --> 00:42:36.720
With simple branching, how long
is it going to take to

00:42:36.720 --> 00:42:38.430
run a piece of code?

00:42:38.430 --> 00:42:42.240
Well at most, I'm going to
execute each instruction once.

00:42:42.240 --> 00:42:42.350
All right?

00:42:42.350 --> 00:42:44.320
Because the IFs are saying, if
it's true do this, otherwise

00:42:44.320 --> 00:42:46.070
skip on it.

00:42:46.070 --> 00:42:48.820
Therefore, for simple branching
programs, the length

00:42:48.820 --> 00:42:52.250
of time, the complexity
the code, is what

00:42:52.250 --> 00:42:53.630
we would call constant.

00:42:53.630 --> 00:42:56.560
That is, it's at most the length
of the actual number of

00:42:56.560 --> 00:42:57.080
instructions.

00:42:57.080 --> 00:42:59.840
It doesn't depend
on the input.

00:42:59.840 --> 00:43:00.880
Real simple programs.

00:43:00.880 --> 00:43:02.130
Let's take another
simple example.

00:43:02.130 --> 00:43:03.980
Suppose I want to compute
the average age

00:43:03.980 --> 00:43:05.750
of all the MIT faculty.

00:43:05.750 --> 00:43:07.470
There's about a thousand
of us.

00:43:07.470 --> 00:43:10.570
However I do that, I know that
should inherently take more

00:43:10.570 --> 00:43:12.880
time than it takes to compute
the average age of all the

00:43:12.880 --> 00:43:14.180
EECS faculty.

00:43:14.180 --> 00:43:16.080
There's only 125 of us.

00:43:16.080 --> 00:43:19.200
And that should take more time
than what it takes to compute

00:43:19.200 --> 00:43:21.960
the average of John's and my
ages, instructors in 600,

00:43:21.960 --> 00:43:23.020
because there's only
two of us.

00:43:23.020 --> 00:43:27.730
All right, those pieces of
code inherently involved

00:43:27.730 --> 00:43:30.920
something that does depend on
the size of the input, or on

00:43:30.920 --> 00:43:32.470
the particular input.

00:43:32.470 --> 00:43:35.060
And that is a preface to an
idea of computational

00:43:35.060 --> 00:43:36.270
complexity we're going
to come back to.

00:43:36.270 --> 00:43:38.500
One of the things we want to
help you do is identify the

00:43:38.500 --> 00:43:41.170
different classes of algorithms,
what their costs

00:43:41.170 --> 00:43:43.930
are, and how you can map
problems into the most

00:43:43.930 --> 00:43:47.200
efficient class to do
the computation.

00:43:47.200 --> 00:43:47.670
OK.

00:43:47.670 --> 00:43:48.700
Now.

00:43:48.700 --> 00:43:52.450
Think for a second about
computing the average age of

00:43:52.450 --> 00:43:53.790
the faculty.

00:43:53.790 --> 00:43:55.400
You can already kind of
see what I want to do.

00:43:55.400 --> 00:43:57.960
I, somehow if, I want to walk
through some sequence of data

00:43:57.960 --> 00:44:01.190
structures, gathering up or
doing the same thing, adding

00:44:01.190 --> 00:44:03.420
ages in until I get a total
age and then divide by the

00:44:03.420 --> 00:44:04.960
number faculty.

00:44:04.960 --> 00:44:07.580
How do I write a piece
of code for that?

00:44:07.580 --> 00:44:09.230
Well, let's go back
up to our original

00:44:09.230 --> 00:44:10.370
starting point of recipes.

00:44:10.370 --> 00:44:13.120
And I'm sure you don't remember,
but one of the

00:44:13.120 --> 00:44:18.820
things I had in my recipe, is
beat egg whites until stiff.

00:44:18.820 --> 00:44:19.200
OK.

00:44:19.200 --> 00:44:21.410
That until is an
important word.

00:44:21.410 --> 00:44:24.560
It's actually defining a test.
Let me rephrase it into

00:44:24.560 --> 00:44:26.760
garbled English that'll lead
more naturally into what I

00:44:26.760 --> 00:44:27.300
want to do.

00:44:27.300 --> 00:44:31.950
While the egg whites are
not stiff, beat them.

00:44:31.950 --> 00:44:33.840
That is a different
kind of structure.

00:44:33.840 --> 00:44:36.860
It has a test in it, which is
that while, while something is

00:44:36.860 --> 00:44:40.970
true, do something, but I
want to keep doing it.

00:44:40.970 --> 00:44:45.020
And so for that, we need
to add one last thing.

00:44:45.020 --> 00:44:49.350
Which is iteration.

00:44:49.350 --> 00:44:50.840
Or loops.

00:44:50.840 --> 00:44:52.460
We're going to see variations of
this, we're going to see a

00:44:52.460 --> 00:44:54.370
variation of it called
recursion, a little later on,

00:44:54.370 --> 00:44:56.070
but for now we're just going
to talk about how do we do

00:44:56.070 --> 00:44:57.260
iterations.

00:44:57.260 --> 00:45:00.370
And I want to show you an
example of this, to lead to

00:45:00.370 --> 00:45:04.640
both the syntax, and
to the semantics.

00:45:04.640 --> 00:45:15.190
And let me comment that out,
and let's go to this one.

00:45:15.190 --> 00:45:15.480
All right.

00:45:15.480 --> 00:45:17.890
What does this piece
of code say?

00:45:17.890 --> 00:45:19.090
Not, what does it do, but
what does it say.

00:45:19.090 --> 00:45:21.140
Well, the first three statements
are just assignment

00:45:21.140 --> 00:45:21.370
statements.

00:45:21.370 --> 00:45:25.130
I'm binding x, y, and iters
left to some values.

00:45:25.130 --> 00:45:27.700
And then notice the structure, I
got a keyword WHILE, there's

00:45:27.700 --> 00:45:32.170
that color identifying it, and
in parentheses I have a test.

00:45:32.170 --> 00:45:34.870
I'm expecting the value that
test to be a Boolean.

00:45:34.870 --> 00:45:36.370
Followed by a colon.

00:45:36.370 --> 00:45:38.820
The colon's identifying
a block of code.

00:45:38.820 --> 00:45:41.390
And what this is
saying is, gee.

00:45:41.390 --> 00:45:43.900
Check to see if the variable
iters left has a value

00:45:43.900 --> 00:45:45.070
greater than zero.

00:45:45.070 --> 00:45:47.600
If it does, then execute
each of the

00:45:47.600 --> 00:45:50.460
instructions in that block.

00:45:50.460 --> 00:45:52.050
So I'm going to have an
assignment of y, I'm going to

00:45:52.050 --> 00:45:53.890
have an assignment of iters
left, I've got a comment that

00:45:53.890 --> 00:45:57.070
I had borrowed in order to do
some debugging, and then what

00:45:57.070 --> 00:45:57.840
do I want it to do?

00:45:57.840 --> 00:46:02.190
I want it to go back around to
the test. Once again, say, is

00:46:02.190 --> 00:46:03.940
that test true?

00:46:03.940 --> 00:46:07.490
If it is true, execute the
sequence of instructions.

00:46:07.490 --> 00:46:10.040
So in fact we can block this
out and see what it does.

00:46:10.040 --> 00:46:16.400
If I make a little chart here,
I've got x, y, and iters left.

00:46:16.400 --> 00:46:19.600
x starts off as I think I set
it up as, here I can't even

00:46:19.600 --> 00:46:24.800
read it, is x is three, y is
zero, iters left is three.

00:46:24.800 --> 00:46:25.940
I can hand-simulate it.

00:46:25.940 --> 00:46:28.070
It says, is the value of iters
left greater than zero?

00:46:28.070 --> 00:46:28.510
Yes it is.

00:46:28.510 --> 00:46:30.710
So, execute those two
instructions.

00:46:30.710 --> 00:46:34.560
It says, take value of y and
value of x, add them together,

00:46:34.560 --> 00:46:36.600
and create that as the
new value of y.

00:46:36.600 --> 00:46:36.760
All right.

00:46:36.760 --> 00:46:38.310
That's the assigned statement.

00:46:38.310 --> 00:46:41.310
It says, take iters left,
subtract one from it, and bind

00:46:41.310 --> 00:46:44.830
that as the new value
of iters left.

00:46:44.830 --> 00:46:47.000
Having reached the end of the
block, go back up and check

00:46:47.000 --> 00:46:49.570
the test. Is iters left
greater than zero?

00:46:49.570 --> 00:46:50.550
Yes it is.

00:46:50.550 --> 00:46:54.270
So, evaluate the same sequence
of instructions again. y plus

00:46:54.270 --> 00:46:57.320
x is six, that's my new value
of y, two minus one is one,

00:46:57.320 --> 00:47:00.300
that's my new value of iters
left, go back up.

00:47:00.300 --> 00:47:01.990
Is iters left greater
than zero?

00:47:01.990 --> 00:47:02.720
Yes it is.

00:47:02.720 --> 00:47:07.150
So once more, thank God I didn't
take 47 as an example,

00:47:07.150 --> 00:47:12.050
x plus y, subtract one from
iters left, go back up to the

00:47:12.050 --> 00:47:14.560
test. Is iters left's value
greater than zero?

00:47:14.560 --> 00:47:16.380
No, it is not.

00:47:16.380 --> 00:47:20.190
Therefore, skip the rest of that
block of code and go to

00:47:20.190 --> 00:47:24.620
the next instruction, which
is, ah, print out y.

00:47:24.620 --> 00:47:29.270
In fact, if we test this,
son of a gun.

00:47:29.270 --> 00:47:32.060
Got a simple square
procedure,.

00:47:32.060 --> 00:47:34.860
Right, It's just squaring an
integer, is what it's doing.

00:47:34.860 --> 00:47:36.150
But notice the structure.

00:47:36.150 --> 00:47:39.080
Now I have the ability to create
a loop, that is, to

00:47:39.080 --> 00:47:41.880
reuse the same pieces of
code over and over

00:47:41.880 --> 00:47:43.870
again as I go around.

00:47:43.870 --> 00:47:47.030
And this adds, now, a lot
of power to the kinds

00:47:47.030 --> 00:47:49.040
of code I can write.

00:47:49.040 --> 00:47:51.610
Notice some other things I want
to highlight on this.

00:47:51.610 --> 00:47:52.610
All right?

00:47:52.610 --> 00:47:57.240
The first one is, that test
has to involve-- shouldn't

00:47:57.240 --> 00:47:59.300
have to, but almost always is
going to involve-- the value

00:47:59.300 --> 00:48:01.470
of some variable.

00:48:01.470 --> 00:48:05.340
What if I don't change the value
of that variable inside

00:48:05.340 --> 00:48:05.960
of the code?

00:48:05.960 --> 00:48:11.730
Or, another way of saying it
is, what if I did this?

00:48:11.730 --> 00:48:13.950
Comment it up.

00:48:13.950 --> 00:48:15.170
What happens if I
run this sucker?

00:48:15.170 --> 00:48:17.650
STUDENT: [INAUDIBLE]

00:48:17.650 --> 00:48:19.210
PROFESSOR JIM ERICSON: Yeah.

00:48:19.210 --> 00:48:20.230
It'll go forever.

00:48:20.230 --> 00:48:21.590
Absolutely, right?

00:48:21.590 --> 00:48:23.390
It's going to loop into
an infinite loop--

00:48:23.390 --> 00:48:26.690
I think I can hit this close,
ah, no I can't, boy what a

00:48:26.690 --> 00:48:27.940
terrible aim--

00:48:27.940 --> 00:48:30.120
All right, what has
[UNINTELLIGIBLE PHRASE] try

00:48:30.120 --> 00:48:32.200
again, the point I'm trying to
make here-- thank God we're at

00:48:32.200 --> 00:48:34.330
the end of this lecture, my
tongue is falling apart-- the

00:48:34.330 --> 00:48:37.940
point I'm trying to make is,
that test needs to involve

00:48:37.940 --> 00:48:40.870
some loop variable
that is changing.

00:48:40.870 --> 00:48:42.575
Otherwise the test is always
going to be true, we're going

00:48:42.575 --> 00:48:45.320
to go off here, but this would
loop forever if I did that.

00:48:45.320 --> 00:48:45.710
All right.

00:48:45.710 --> 00:48:49.100
Second question: or maybe a
better way of saying this, and

00:48:49.100 --> 00:48:51.980
the general format you're likely
to see here is, a test

00:48:51.980 --> 00:48:54.770
involving a variable name,
which must be initialized

00:48:54.770 --> 00:48:57.910
outside of the loop, and which
interior to the loop gets

00:48:57.910 --> 00:49:00.870
changed, so that the test
is going to change.

00:49:00.870 --> 00:49:02.750
Here's the second question.

00:49:02.750 --> 00:49:05.280
What value of inputs, what
values of x will this run

00:49:05.280 --> 00:49:08.530
correctly for?

00:49:08.530 --> 00:49:10.770
Probably should be
integers, right?

00:49:10.770 --> 00:49:13.130
Otherwise, this is going to be
doing something strange, but

00:49:13.130 --> 00:49:16.340
all integers?

00:49:16.340 --> 00:49:18.350
All right, suppose I do this.

00:49:18.350 --> 00:49:24.320
It's my last example.

00:49:24.320 --> 00:49:26.730
Yeah, how about that, right?

00:49:26.730 --> 00:49:29.450
We knew this was trying to do
squaring, so intellectually we

00:49:29.450 --> 00:49:31.840
know we can square -4, it
ought to be 16, but what

00:49:31.840 --> 00:49:33.630
happens here?

00:49:33.630 --> 00:49:34.940
Double fudge knuckle.

00:49:34.940 --> 00:49:35.960
All right?

00:49:35.960 --> 00:49:39.000
It's going to run through the
loop, accumulating the

00:49:39.000 --> 00:49:41.385
answers, but because I'm
subtracting, it's just going

00:49:41.385 --> 00:49:44.690
to keep making x more and more
negative as it goes along,

00:49:44.690 --> 00:49:46.680
again it's off into
an infinite loop.

00:49:46.680 --> 00:49:49.360
Which is a way of reminding you
that I need to think as I

00:49:49.360 --> 00:49:52.232
write the code about what are
my expectations from the

00:49:52.232 --> 00:49:54.160
input, and how might
I enforce them.

00:49:54.160 --> 00:49:56.050
In this case, I probably want
to make sure I use absolute

00:49:56.050 --> 00:49:57.350
value of x before
I carry it on.

00:49:57.350 --> 00:50:03.450
Yes ma'am.

00:50:03.450 --> 00:50:11.130
STUDENT: [UNINTELLIGIBLE]

00:50:11.130 --> 00:50:13.840
PROFESSOR JIM ERICSON: You're
absolutely right, because I

00:50:13.840 --> 00:50:16.440
bind iters left to, um, yeah.

00:50:16.440 --> 00:50:16.650
Yes.

00:50:16.650 --> 00:50:16.980
Thank you.

00:50:16.980 --> 00:50:19.260
Boy, two candy for you.

00:50:19.260 --> 00:50:20.390
You caught me making an error.

00:50:20.390 --> 00:50:21.040
Yes.

00:50:21.040 --> 00:50:24.230
The point is, it's not going to
work, and she caught both

00:50:24.230 --> 00:50:26.090
of them, impressive, it's not
going to work because iters

00:50:26.090 --> 00:50:27.980
left is already negative, it's
just going to skip the whole

00:50:27.980 --> 00:50:31.120
loop, and I'm in trouble, so
thank you for catching that.

00:50:31.120 --> 00:50:31.370
All right.

00:50:31.370 --> 00:50:33.380
I was going to do one more
example, but I've run you up

00:50:33.380 --> 00:50:34.160
to the end of the time.

00:50:34.160 --> 00:50:36.290
I'll leave the example on the
handout, it shows you another

00:50:36.290 --> 00:50:38.150
version that we'll come
back to next time.

00:50:38.150 --> 00:50:41.880
The key thing to notice is, I
now have the ability to create

00:50:41.880 --> 00:50:44.130
iterations, which extends
well I can do.

00:50:44.130 --> 00:50:46.840
And we'll see you next time.

