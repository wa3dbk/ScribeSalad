WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.400
ANNOUNCER: Open content is
provided under a creative

00:00:02.400 --> 00:00:03.830
commons license.

00:00:03.830 --> 00:00:06.840
Your support will help MIT
OpenCourseWare continue to

00:00:06.840 --> 00:00:10.520
offer High-quality educational
resources for free.

00:00:10.520 --> 00:00:13.380
To make a donation, or view
additional materials from

00:00:13.380 --> 00:00:17.490
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.490 --> 00:00:19.930
ocw.mit.edu .

00:00:19.930 --> 00:00:23.820
PROFESSOR ERIC GRIMSON: Let's
recap where we were.

00:00:23.820 --> 00:00:26.640
Last lecture, we talked about,
or started to talk about,

00:00:26.640 --> 00:00:27.770
efficiency.

00:00:27.770 --> 00:00:28.640
Orders of growth.

00:00:28.640 --> 00:00:30.050
Complexity.

00:00:30.050 --> 00:00:33.450
And I'll remind you, we saw a
set of algorithms, and part of

00:00:33.450 --> 00:00:35.740
my goal was to get you
to begin to recognize

00:00:35.740 --> 00:00:38.380
characteristics of algorithms
that map into

00:00:38.380 --> 00:00:40.200
a particular class.

00:00:40.200 --> 00:00:40.820
So what did we see?

00:00:40.820 --> 00:00:44.480
We saw linear algorithms.
Typical characterization, not

00:00:44.480 --> 00:00:47.100
all the time, but typical
characterization, is an

00:00:47.100 --> 00:00:51.270
algorithm that reduces the size
of a problem by one, or

00:00:51.270 --> 00:00:55.310
by some constant amount each
time, is typically an example

00:00:55.310 --> 00:00:57.330
of a linear algorithm.

00:00:57.330 --> 00:01:00.140
And we saw a couple of examples
of linear algorithms.

00:01:00.140 --> 00:01:03.620
We also saw a logarithmic
algorithm. and we like log

00:01:03.620 --> 00:01:06.510
algorithms, because they're
really fast. A typical

00:01:06.510 --> 00:01:09.490
characteristic of a log
algorithm is a pro-- or sorry,

00:01:09.490 --> 00:01:13.850
an algorithm where it reduces
the size of the problem by a

00:01:13.850 --> 00:01:14.820
constant factor.

00:01:14.820 --> 00:01:16.372
Obviously-- and that's a bad
way of saying it, I said

00:01:16.372 --> 00:01:18.120
constant the previous time--
in the linear case, it's

00:01:18.120 --> 00:01:19.600
subtract by certain amount.

00:01:19.600 --> 00:01:21.840
In the log case, it's
divide by an amount.

00:01:21.840 --> 00:01:23.240
Cut the problem in half.

00:01:23.240 --> 00:01:25.300
Cut the problem in half again.

00:01:25.300 --> 00:01:26.110
And that's a typical

00:01:26.110 --> 00:01:28.310
characterization of a log algorithm.

00:01:28.310 --> 00:01:31.140
We saw some quadratic
algorithms, typically those

00:01:31.140 --> 00:01:33.910
are things with multiple nested
loops, or iterative or

00:01:33.910 --> 00:01:36.390
recursive calls, where you're
doing, say, a linear amount of

00:01:36.390 --> 00:01:39.820
time but you're doing it a
linear number of times, and so

00:01:39.820 --> 00:01:42.010
it becomes quadratic, and you'll
see other polynomial

00:01:42.010 --> 00:01:43.100
kinds of algorithms.

00:01:43.100 --> 00:01:46.340
And finally, we saw an example
of an exponential algorithm,

00:01:46.340 --> 00:01:48.510
those Towers of Hanoi.

00:01:48.510 --> 00:01:51.200
We don't like exponential
algorithms, or at least you

00:01:51.200 --> 00:01:53.410
shouldn't like them, because
they blow up quickly.

00:01:53.410 --> 00:01:55.490
And we saw some examples
of that.

00:01:55.490 --> 00:01:58.210
And unfortunately, some problems
are inherently

00:01:58.210 --> 00:02:00.470
exponential, you're sort of
stuck with that, and then you

00:02:00.470 --> 00:02:03.450
just have to try be as
clever as you can.

00:02:03.450 --> 00:02:04.750
OK.

00:02:04.750 --> 00:02:07.180
At the end of the lecture last
time, I also showed you an

00:02:07.180 --> 00:02:09.940
example of binary search.

00:02:09.940 --> 00:02:12.440
And I want to redo that in a
little more detail today,

00:02:12.440 --> 00:02:15.170
because I felt like I did that
a little more quickly than I

00:02:15.170 --> 00:02:18.780
wanted to, so, if you really got
binary search, fall asleep

00:02:18.780 --> 00:02:21.060
for about ten minutes, just
don't snore, your neighbors

00:02:21.060 --> 00:02:22.680
may not appreciate it, but
we're going to go over it

00:02:22.680 --> 00:02:24.730
again, because it's a problem
and an idea that we're going

00:02:24.730 --> 00:02:26.690
to come back to, and I really
want to make sure that I do

00:02:26.690 --> 00:02:30.970
this in a way that makes
real good sense you.

00:02:30.970 --> 00:02:31.570
Again.

00:02:31.570 --> 00:02:33.820
Basic premise of binary search,
or at least we set it

00:02:33.820 --> 00:02:37.720
up was, imagine I have a sorted
list of elements.

00:02:37.720 --> 00:02:39.150
We get, in a second, to how
we're going to get them

00:02:39.150 --> 00:02:42.330
sorted, and I want to know,
is a particular

00:02:42.330 --> 00:02:44.390
element in that list..

00:02:44.390 --> 00:02:47.510
And the basic idea of binary
search is to start with the

00:02:47.510 --> 00:02:50.790
full range of the list,
pick the midpoint,

00:02:50.790 --> 00:02:53.160
and test that point.

00:02:53.160 --> 00:02:54.970
If it's the thing I'm looking
for, I'm golden.

00:02:54.970 --> 00:02:58.350
If not, because the list is
sorted, I can use the

00:02:58.350 --> 00:03:01.150
difference between what I'm
looking for and that midpoint

00:03:01.150 --> 00:03:04.040
to decide, should I look in the
top half of the list, or

00:03:04.040 --> 00:03:05.350
the bottom half of the list?

00:03:05.350 --> 00:03:06.960
And I keep chopping it down.

00:03:06.960 --> 00:03:09.230
And I want to show you a little
bit more detail of

00:03:09.230 --> 00:03:11.490
that, so let's create a simple
little list here.

00:03:11.490 --> 00:03:22.880
All right?

00:03:22.880 --> 00:03:24.530
I don't care what's in there,
but just assume that's my

00:03:24.530 --> 00:03:28.510
list. And just to remind you, on
your handout, and there it

00:03:28.510 --> 00:03:30.930
is on the screen, I'm going to
bring it back up, there's the

00:03:30.930 --> 00:03:32.140
little binary search
algorithm.

00:03:32.140 --> 00:03:33.350
We're going to call
search, which just

00:03:33.350 --> 00:03:34.550
calls binary search.

00:03:34.550 --> 00:03:39.140
And you can look at it, and
let's in fact take a look at

00:03:39.140 --> 00:03:40.640
it to see what it does.

00:03:40.640 --> 00:03:42.670
We're going to call binary
search, it's going to take the

00:03:42.670 --> 00:03:44.640
list to search and the element,
but it's also going

00:03:44.640 --> 00:03:52.390
to say, here's the first part
of the list, and there's the

00:03:52.390 --> 00:03:54.760
last part of the list,
and what does it

00:03:54.760 --> 00:03:55.830
do inside that code?

00:03:55.830 --> 00:03:57.770
Well, it checks to see,
is it bigger than two?

00:03:57.770 --> 00:03:59.280
Are there more than two
elements there?

00:03:59.280 --> 00:04:01.920
If there are less than two
elements there, I just check

00:04:01.920 --> 00:04:03.420
one or both of those to
see if I'm looking

00:04:03.420 --> 00:04:04.530
for the right thing.

00:04:04.530 --> 00:04:06.790
Otherwise, what does that
code say to do?

00:04:06.790 --> 00:04:10.370
It says find the midpoint, which
says, take the start,

00:04:10.370 --> 00:04:15.270
which is pointing to that place
right there, take last

00:04:15.270 --> 00:04:17.850
minus first, divide it by
2, and add it to start.

00:04:17.850 --> 00:04:21.230
And that basically, somewhere
about here,

00:04:21.230 --> 00:04:23.740
gives me the midpoint.

00:04:23.740 --> 00:04:25.590
Now I look at that element.

00:04:25.590 --> 00:04:26.830
Is it the thing I'm
looking for?

00:04:26.830 --> 00:04:29.020
If I'm really lucky, it is.

00:04:29.020 --> 00:04:33.030
If not, I look at the value of
that point here and the thing

00:04:33.030 --> 00:04:34.210
I'm looking for.

00:04:34.210 --> 00:04:36.450
And for sake of argument, let's
assume that the thing

00:04:36.450 --> 00:04:39.380
I'm looking for is smaller
than the value here.

00:04:39.380 --> 00:04:41.180
Here's what I do.

00:04:41.180 --> 00:04:42.470
I change-- oops!

00:04:42.470 --> 00:04:43.320
Let me do that this way--

00:04:43.320 --> 00:04:51.570
I change last to here, and keep
first there, and I throw

00:04:51.570 --> 00:04:54.330
away all of that.

00:04:54.330 --> 00:04:56.480
All right?

00:04:56.480 --> 00:04:59.730
That's just the those-- let me
use my pointer-- that's just

00:04:59.730 --> 00:05:01.580
these two lines here.

00:05:01.580 --> 00:05:05.020
I checked the value, and in
one case, I'm changing the

00:05:05.020 --> 00:05:09.350
last to be mid minus 1, which is
the case I'm in here, and I

00:05:09.350 --> 00:05:10.050
just call again.

00:05:10.050 --> 00:05:12.060
All right?

00:05:12.060 --> 00:05:13.450
I'm going to call exactly
the same thing.

00:05:13.450 --> 00:05:16.860
Now, first is pointing here,
last is pointing there, again,

00:05:16.860 --> 00:05:18.880
I check to see, are there more
than two things left?

00:05:18.880 --> 00:05:20.280
There are, in this case.

00:05:20.280 --> 00:05:21.000
So what do I do?

00:05:21.000 --> 00:05:24.060
I find the midpoint by taking
last minus first, divide by 2,

00:05:24.060 --> 00:05:25.800
and add to start.

00:05:25.800 --> 00:05:29.790
Just for sake of argument, we'll
assume it's about there,

00:05:29.790 --> 00:05:31.330
and I do the same thing.

00:05:31.330 --> 00:05:33.950
Is this value what
I'm looking for?

00:05:33.950 --> 00:05:35.970
Again, for sake of argument,
let's assume it's not.

00:05:35.970 --> 00:05:38.130
Let's assume, for sake of
argument, the thing I'm

00:05:38.130 --> 00:05:40.440
looking for is bigger
than this.

00:05:40.440 --> 00:05:43.630
In that case, I'm going to throw
away all of this, I'm

00:05:43.630 --> 00:05:46.790
going to hit that bottom
line of that code.

00:05:46.790 --> 00:05:47.200
Ah.

00:05:47.200 --> 00:05:48.310
What does that do?

00:05:48.310 --> 00:05:49.440
It changes the call.

00:05:49.440 --> 00:05:54.530
So in this case, first
now points

00:05:54.530 --> 00:06:00.310
there, last points there.

00:06:00.310 --> 00:06:01.110
And I cut around.

00:06:01.110 --> 00:06:07.660
And again, notice
what I've done.

00:06:07.660 --> 00:06:09.980
I've thrown away most of the
array-- most of the list, I

00:06:09.980 --> 00:06:12.780
shouldn't say array-- most
of the list. All right?

00:06:12.780 --> 00:06:16.420
So it cuts it down quickly
as we go along.

00:06:16.420 --> 00:06:18.170
OK.

00:06:18.170 --> 00:06:20.730
That's the basic idea
of binary search.

00:06:20.730 --> 00:06:23.210
And let's just run a couple of
examples to remind you of what

00:06:23.210 --> 00:06:27.470
happens if we do this.

00:06:27.470 --> 00:06:29.960
So if I call, let's
[UNINTELLIGIBLE], let's set up

00:06:29.960 --> 00:06:37.950
s to be, I don't know, some
big long list. OK.

00:06:37.950 --> 00:06:41.890
And I'm going to look to see, is
a particular element inside

00:06:41.890 --> 00:06:47.400
of that list, and again, I'll
remind you, that's just giving

00:06:47.400 --> 00:06:50.750
me the integers from zero up
to 9999 something or other.

00:06:50.750 --> 00:06:56.740
If I look for, say, minus 1,
you might go, gee, wait a

00:06:56.740 --> 00:06:58.680
minute, if I was just doing
linear search, I would've

00:06:58.680 --> 00:07:01.030
known right away that minus
one wasn't in this list,

00:07:01.030 --> 00:07:02.250
because it's sorted
and it's smaller

00:07:02.250 --> 00:07:03.840
than the first elements.

00:07:03.840 --> 00:07:06.070
So this looks like it's doing
a little bit of extra work,

00:07:06.070 --> 00:07:09.340
but you can see, if you look at
that, how it cuts it down

00:07:09.340 --> 00:07:09.990
at each stage.

00:07:09.990 --> 00:07:12.580
And I'll remind you, what I'm
printing out there is, first

00:07:12.580 --> 00:07:16.920
and last, with the range I'm
looking over, and then just

00:07:16.920 --> 00:07:20.230
how many times the
iteration called.

00:07:20.230 --> 00:07:22.590
So in this case, it just keeps
chopping down from the back

00:07:22.590 --> 00:07:24.830
end, which kind of makes
sense, all right?

00:07:24.830 --> 00:07:28.040
But in a fixed number, in fact,
twenty-three calls, it

00:07:28.040 --> 00:07:29.440
gets down to the point
of being able to say

00:07:29.440 --> 00:07:30.100
whether it's there.

00:07:30.100 --> 00:07:33.870
Let's go the other direction.

00:07:33.870 --> 00:07:39.490
And yes, I guess I'd better say
s not 2, or we're going to

00:07:39.490 --> 00:07:40.620
get an error here.

00:07:40.620 --> 00:07:48.320
Again, in twenty-three checks.

00:07:48.320 --> 00:07:50.650
In this case, it's cutting up
from the bottom end, which

00:07:50.650 --> 00:07:52.610
makes sense because the thing
I'm looking for is always

00:07:52.610 --> 00:07:55.950
bigger than the midpoint, and
then, I don't know, let's pick

00:07:55.950 --> 00:07:58.940
something in between.

00:07:58.940 --> 00:08:03.820
Somebody want-- ah, I keep doing
that-- somebody like to

00:08:03.820 --> 00:08:05.740
give me a number?

00:08:05.740 --> 00:08:07.620
I know you'd like to give
me other things, other

00:08:07.620 --> 00:08:10.810
expression, somebody
give me a number.

00:08:10.810 --> 00:08:11.650
Anybody?

00:08:11.650 --> 00:08:12.750
No?

00:08:12.750 --> 00:08:13.940
Sorry.

00:08:13.940 --> 00:08:14.880
Thank you.

00:08:14.880 --> 00:08:15.430
Good number.

00:08:15.430 --> 00:08:23.480
OK, walks in very quickly.

00:08:23.480 --> 00:08:24.620
OK?

00:08:24.620 --> 00:08:26.780
And if you just look at the
numbers, you can see how it

00:08:26.780 --> 00:08:29.290
cuts in from one side and then
the other side as it keeps

00:08:29.290 --> 00:08:31.800
narrowing that range, until it
gets down to the place where

00:08:31.800 --> 00:08:34.320
there are at most two things
left, and then it just has to

00:08:34.320 --> 00:08:37.030
check those two to say whether
it's there or not.

00:08:37.030 --> 00:08:39.350
Think about this compared
to a linear search.

00:08:39.350 --> 00:08:39.440
All right?

00:08:39.440 --> 00:08:41.300
A linear search, I start at the
beginning of the list and

00:08:41.300 --> 00:08:42.490
walk all the way through it.

00:08:42.490 --> 00:08:45.970
All right, if I'm lucky and it's
at the low end, I'll find

00:08:45.970 --> 00:08:46.770
it pretty quickly.

00:08:46.770 --> 00:08:48.980
If it's not, if it's at the
far end, I've got to go

00:08:48.980 --> 00:08:51.380
forever, and you saw that last
time where this thing paused

00:08:51.380 --> 00:08:52.470
for a little while
while it actually

00:08:52.470 --> 00:08:55.210
searched a list this big.

00:08:55.210 --> 00:08:55.470
OK.

00:08:55.470 --> 00:08:58.750
So, what do I want you to
take away from this?

00:08:58.750 --> 00:09:00.950
This idea of binary search
is going to be a

00:09:00.950 --> 00:09:02.720
really powerful tool.

00:09:02.720 --> 00:09:04.500
And it has this property,
again, of

00:09:04.500 --> 00:09:06.440
chopping things into pieces.

00:09:06.440 --> 00:09:09.040
So in fact, what does that
suggest about the order of

00:09:09.040 --> 00:09:09.400
growth here?

00:09:09.400 --> 00:09:12.860
What is the complexity of this?

00:09:12.860 --> 00:09:14.100
Yeah.

00:09:14.100 --> 00:09:14.750
Logarithmic.

00:09:14.750 --> 00:09:15.200
Why?

00:09:15.200 --> 00:09:17.810
STUDENT: [UNINTELLIGIBLE]

00:09:17.810 --> 00:09:18.450
PROFESSOR ERIC GRIMSON: Yeah.

00:09:18.450 --> 00:09:18.840
Thank you.

00:09:18.840 --> 00:09:20.830
I mean, I know I sort of said
it to you, but you're right.

00:09:20.830 --> 00:09:21.750
It's logarithmic, right?

00:09:21.750 --> 00:09:24.460
It's got that property of,
it cuts things in half.

00:09:24.460 --> 00:09:26.860
Here's another way to think
about why is this log.

00:09:26.860 --> 00:09:28.460
Actually, let me ask a slightly
different question.

00:09:28.460 --> 00:09:30.050
How do we know this
always stops?

00:09:30.050 --> 00:09:33.190
I mean, I ran three trials
here, and it did.

00:09:33.190 --> 00:09:36.560
But how would I reason about,
does this always stop?

00:09:36.560 --> 00:09:37.190
Well let's see.

00:09:37.190 --> 00:09:40.180
Where's the end test
on this thing?

00:09:40.180 --> 00:09:43.470
The end test-- and I've got
the wrong glasses on-- but

00:09:43.470 --> 00:09:46.450
it's up here, where I'm looking
to see, is last minus

00:09:46.450 --> 00:09:49.470
first less than or equal to 2?

00:09:49.470 --> 00:09:49.620
OK.

00:09:49.620 --> 00:09:52.330
So, soon as I get down to a list
that has no more than two

00:09:52.330 --> 00:09:55.060
elements in it, I'm done.

00:09:55.060 --> 00:09:55.600
Notice that.

00:09:55.600 --> 00:09:57.440
It's a less than or equal to.

00:09:57.440 --> 00:10:00.640
What if I just tested to see
if it was only, say, one?

00:10:00.640 --> 00:10:01.730
There was one element
in there.

00:10:01.730 --> 00:10:07.740
Would that have worked?

00:10:07.740 --> 00:10:09.480
I think it depends on
whether the list is

00:10:09.480 --> 00:10:11.870
odd or even in length.

00:10:11.870 --> 00:10:12.760
Actually, that's probably
not true.

00:10:12.760 --> 00:10:14.770
With one, it'll probably always
get it down there, but

00:10:14.770 --> 00:10:17.440
if I've made it just equal to
two, I might have lost.

00:10:17.440 --> 00:10:19.320
So first of all, I've got to be
careful about the end test.

00:10:19.320 --> 00:10:22.270
But the second thing is, OK, if
it stops whenever this is

00:10:22.270 --> 00:10:26.030
less than two, am I convinced
that this will always halt?

00:10:26.030 --> 00:10:26.820
And the answer is sure.

00:10:26.820 --> 00:10:27.670
Because what do I do?

00:10:27.670 --> 00:10:32.820
At each stage, no matter which
branch, here or here, I take,

00:10:32.820 --> 00:10:35.400
I'm cutting down the length
of the list that I'm

00:10:35.400 --> 00:10:36.850
searching in half.

00:10:36.850 --> 00:10:38.160
All right?

00:10:38.160 --> 00:10:41.020
So if I start off with a list
of length n, how many times

00:10:41.020 --> 00:10:43.610
can I divide it by 2, until
I get to something no

00:10:43.610 --> 00:10:45.450
more than two left?

00:10:45.450 --> 00:10:46.520
Log times, right.?

00:10:46.520 --> 00:10:47.630
Exactly as the gentleman said.

00:10:47.630 --> 00:10:48.490
Oh, I'm sorry.

00:10:48.490 --> 00:10:50.280
You're patiently waiting
for me to reward.

00:10:50.280 --> 00:10:53.340
Or actually, maybe you're not.

00:10:53.340 --> 00:10:55.030
Thank you.

00:10:55.030 --> 00:10:56.080
OK.

00:10:56.080 --> 00:11:08.690
So this is, in fact, log.

00:11:08.690 --> 00:11:10.830
Now, having said that,
I actually snuck

00:11:10.830 --> 00:11:12.900
something by you.

00:11:12.900 --> 00:11:14.330
And I want to spend a
couple of minutes

00:11:14.330 --> 00:11:16.300
again reinforcing that.

00:11:16.300 --> 00:11:19.690
So if we look at that code,
and we were little more

00:11:19.690 --> 00:11:21.480
careful about this, what
did we say to do?

00:11:21.480 --> 00:11:22.840
We said look an-- sorry.

00:11:22.840 --> 00:11:26.600
Count the number of primitive
operations in each step.

00:11:26.600 --> 00:11:26.860
OK.

00:11:26.860 --> 00:11:30.470
So if I look at this code,
first of all I'm calling

00:11:30.470 --> 00:11:35.420
search, it just has one call,
so looks like search is

00:11:35.420 --> 00:11:37.040
constant, except I
don't know what

00:11:37.040 --> 00:11:38.180
happens inside of b search.

00:11:38.180 --> 00:11:39.210
So I've got to look
at b search.

00:11:39.210 --> 00:11:39.900
So let's see.

00:11:39.900 --> 00:11:42.900
The first line, that
print thing, is

00:11:42.900 --> 00:11:44.910
obviously constant, right?

00:11:44.910 --> 00:11:47.510
Just take it as a constant
amount of operations But.

00:11:47.510 --> 00:11:50.960
let's look at the next one here,
or is that second line?

00:11:50.960 --> 00:11:51.310
OK.

00:11:51.310 --> 00:11:54.900
If last minus first is greater
than or equal to 2-- sorry,

00:11:54.900 --> 00:11:57.820
less than 2, then either
look at this thing or

00:11:57.820 --> 00:11:58.590
look at that thing.

00:11:58.590 --> 00:12:02.310
And that's where I said we've
got to be careful.

00:12:02.310 --> 00:12:05.900
That's accessing an element of
a list. We have to make sure

00:12:05.900 --> 00:12:08.490
that, in fact, that operation
is not linear.

00:12:08.490 --> 00:12:12.460
So let me expand on that very
slightly, and again, we did

00:12:12.460 --> 00:12:14.740
this last time but I want
to do one more time.

00:12:14.740 --> 00:12:22.470
I have to be careful about how
I'm actually implementing a

00:12:22.470 --> 00:12:22.840
list.

00:12:22.840 --> 00:12:38.410
So, for example: in
this case, my list

00:12:38.410 --> 00:12:40.530
is a bunch of integers.

00:12:40.530 --> 00:12:42.740
And one of the things I could
take advantage of, is I'm only

00:12:42.740 --> 00:12:44.540
going to need a finite
amount of space to

00:12:44.540 --> 00:12:46.180
represent an integer.

00:12:46.180 --> 00:12:49.730
So, for example, if I want to
allow for some fairly large

00:12:49.730 --> 00:12:52.880
range of integers, I might say,
I need four memory cells

00:12:52.880 --> 00:12:54.350
in a row to represent
an integer.

00:12:54.350 --> 00:12:56.660
All right, if it's a zero, it's
going to be a whole bunch

00:12:56.660 --> 00:12:59.200
of ones-- of zeroes, so one,
it may be a whole bunch of

00:12:59.200 --> 00:13:01.510
zeroes in the first three and
then a one at the end of this

00:13:01.510 --> 00:13:04.020
thing, but one of the way to
think about this list in

00:13:04.020 --> 00:13:08.470
memory, is that I can decide in
constant time how to find

00:13:08.470 --> 00:13:09.640
the i'th element of a list.

00:13:09.640 --> 00:13:12.460
So in particular, here's where
the zero-th element of the

00:13:12.460 --> 00:13:15.320
list starts, there's where the
first element starts, here's

00:13:15.320 --> 00:13:17.560
where the third element starts,
these are just memory

00:13:17.560 --> 00:13:25.140
cells in a row, and to find the
zero-th element, if start

00:13:25.140 --> 00:13:29.300
is pointing to that memory
cell, it's just at start.

00:13:29.300 --> 00:13:33.730
To find the first element,
because I know I need four

00:13:33.730 --> 00:13:41.590
memory cells to represent an
integer, it's at start plus 4.

00:13:41.590 --> 00:13:46.080
To get to the second element,
I know that that's-- you get

00:13:46.080 --> 00:13:50.940
the idea-- at the start plus 2
times 4, and to get to the

00:13:50.940 --> 00:14:01.520
k'th element, I know that I
want to take whatever the

00:14:01.520 --> 00:14:04.790
start is which points to that
place in memory, take care,

00:14:04.790 --> 00:14:08.590
multiply by 4, and that tells me
exactly where to go to find

00:14:08.590 --> 00:14:09.200
that location.

00:14:09.200 --> 00:14:13.860
This may sound like a nuance,
but it's important.

00:14:13.860 --> 00:14:14.910
Why?

00:14:14.910 --> 00:14:16.900
Because that's a constant
access, right?

00:14:16.900 --> 00:14:19.890
To get any location in memory,
to get to any value of the

00:14:19.890 --> 00:14:23.120
list, I simply have to say which
element do I want to

00:14:23.120 --> 00:14:25.780
get, I know that these things
are stored in a particular

00:14:25.780 --> 00:14:29.210
size, multiply that index by 4,
add it to start, and then

00:14:29.210 --> 00:14:31.880
it's in a constant amount of
time I can go to that location

00:14:31.880 --> 00:14:33.870
and get out the cell.

00:14:33.870 --> 00:14:36.590
OK.

00:14:36.590 --> 00:14:42.670
That works nicely if I know that
I have things stored in

00:14:42.670 --> 00:14:44.510
constant size.

00:14:44.510 --> 00:14:47.320
But what if I have
a list of lists?

00:14:47.320 --> 00:14:49.640
What if I have a homogeneous
list, a list of integers and

00:14:49.640 --> 00:14:52.438
strings and floats and lists and
lists of lists and lists

00:14:52.438 --> 00:14:53.860
of lists of lists and all
that sort of cool stuff?

00:14:53.860 --> 00:15:04.190
In that case, I've got to
be a lot more careful.

00:15:04.190 --> 00:15:07.450
So in this case, one of the
standard ways to do this, is

00:15:07.450 --> 00:15:13.130
to use what's called a linked
list. And I'm going to do it

00:15:13.130 --> 00:15:14.120
in the following way.

00:15:14.120 --> 00:15:21.570
Start again, we'll point to the
beginning of the list. But

00:15:21.570 --> 00:15:23.790
now, because my elements are
going to take different

00:15:23.790 --> 00:15:26.430
amounts of memory, I'm going
to do the following thing.

00:15:26.430 --> 00:15:31.440
In the first spot, I'm going to
store something that says,

00:15:31.440 --> 00:15:33.610
here's how far you
have to jump to

00:15:33.610 --> 00:15:35.320
get to the next element.

00:15:35.320 --> 00:15:38.910
And then, I'm going to use the
next sequence of things to

00:15:38.910 --> 00:15:40.750
represent the first
element, or

00:15:40.750 --> 00:15:42.230
the zero-th element,
if you like.

00:15:42.230 --> 00:15:44.120
In this case I might
need five.

00:15:44.120 --> 00:15:47.550
And then in the next spot, I'm
going to say how far you have

00:15:47.550 --> 00:15:49.070
to jump to get to the
next element.

00:15:49.070 --> 00:15:53.220
All right, followed by whatever
I need to represent

00:15:53.220 --> 00:15:54.880
it, which might only
be a blank one.

00:15:54.880 --> 00:15:59.100
And in the next spot, maybe I've
got a really long list,

00:15:59.100 --> 00:16:00.990
and I'm going to say
how to jump to

00:16:00.990 --> 00:16:02.060
get to the next element.

00:16:02.060 --> 00:16:05.020
All right, this is actually
kind of nice.

00:16:05.020 --> 00:16:07.800
This lets me have a way of
representing things that could

00:16:07.800 --> 00:16:08.900
be arbitrary in size.

00:16:08.900 --> 00:16:10.240
And some of these things
could be huge, if

00:16:10.240 --> 00:16:12.370
they're themselves lists.

00:16:12.370 --> 00:16:13.970
Here's the problem.

00:16:13.970 --> 00:16:16.690
How do I get to the nth-- er,
the k'th element in the list,

00:16:16.690 --> 00:16:17.860
in this case?

00:16:17.860 --> 00:16:21.380
Well I have to go to the zero-th
element, and say OK,

00:16:21.380 --> 00:16:23.520
gee, to get to the next
element, I've got

00:16:23.520 --> 00:16:24.700
to jump this here.

00:16:24.700 --> 00:16:27.490
And to get to the next element,
I've got to jump to

00:16:27.490 --> 00:16:29.760
here, and to get to the next
element, I've got to jump to

00:16:29.760 --> 00:16:32.990
here, until I get there.

00:16:32.990 --> 00:16:34.310
And so, I get some power.

00:16:34.310 --> 00:16:37.030
I get the ability to store
arbitrary things, but what

00:16:37.030 --> 00:16:39.830
just happened to
my complexity?

00:16:39.830 --> 00:16:41.270
How long does it take
me to find the

00:16:41.270 --> 00:16:43.310
k'th element?

00:16:43.310 --> 00:16:44.270
Linear.

00:16:44.270 --> 00:16:45.990
Because I've got to walk
my way down it.

00:16:45.990 --> 00:16:46.940
OK?

00:16:46.940 --> 00:16:56.730
So in this case, you
have linear access.

00:16:56.730 --> 00:16:57.820
Oh fudge knuckle.

00:16:57.820 --> 00:16:58.780
Right?

00:16:58.780 --> 00:17:01.440
If that was the case in that
code, then my complexity is no

00:17:01.440 --> 00:17:04.690
longer log, because I need
linear access for each time

00:17:04.690 --> 00:17:06.260
I've got to go to the list,
and it's going to be much

00:17:06.260 --> 00:17:06.940
worse than that.

00:17:06.940 --> 00:17:08.430
All right.

00:17:08.430 --> 00:17:08.650
Now.

00:17:08.650 --> 00:17:13.730
Some programming languages,
primarily Lisp, actually store

00:17:13.730 --> 00:17:15.700
lists these ways.

00:17:15.700 --> 00:17:17.470
You might say, why?

00:17:17.470 --> 00:17:19.850
Well it turns out there's
some trade-offs to it.

00:17:19.850 --> 00:17:22.340
It has some advantages in terms
of power of storing

00:17:22.340 --> 00:17:24.420
things, it has some
disadvantages, primarily in

00:17:24.420 --> 00:17:26.270
terms of access time.

00:17:26.270 --> 00:17:28.890
Fortunately for you, Python
decided, or the investors of

00:17:28.890 --> 00:17:30.840
Python decided, to store
this a different way.

00:17:30.840 --> 00:17:34.720
And the different way is to say,
look, if I redraw this,

00:17:34.720 --> 00:17:48.150
it's called a box and pointer
diagram, what we really have

00:17:48.150 --> 00:17:49.800
for each element
is two things.

00:17:49.800 --> 00:17:52.070
And I've actually just reversed
the order here.

00:17:52.070 --> 00:17:55.070
We have a pointer to the
location in memory that

00:17:55.070 --> 00:17:58.510
contains the actual value, which
itself might be a bunch

00:17:58.510 --> 00:18:02.885
of pointers, and we have a
pointer to the actual-- sorry,

00:18:02.885 --> 00:18:05.390
a pointer the value and we have
a pointer to the next

00:18:05.390 --> 00:18:08.000
element in the list.
All right?

00:18:08.000 --> 00:18:10.090
And one of the things we could
do if we look at that is, we

00:18:10.090 --> 00:18:12.440
say, gee, we could reorganize
this in a pretty

00:18:12.440 --> 00:18:13.360
straightforward way.

00:18:13.360 --> 00:18:21.400
In particular, why don't we
just take all of the first

00:18:21.400 --> 00:18:35.520
cells and stick them together?

00:18:35.520 --> 00:18:40.070
Where now, my list is a list of
pointers, it's not a set of

00:18:40.070 --> 00:18:42.080
values but it's actually a
pointer off to some other

00:18:42.080 --> 00:18:44.480
piece of memory that
contains the value.

00:18:44.480 --> 00:18:46.380
Why is this nice?

00:18:46.380 --> 00:18:50.750
Well this is exactly like this.

00:18:50.750 --> 00:18:53.480
All right?

00:18:53.480 --> 00:18:57.160
It's now something that I can
search in constant time.

00:18:57.160 --> 00:18:58.670
And that's what's going to
allow me to keep this

00:18:58.670 --> 00:19:01.400
thing as being log.

00:19:01.400 --> 00:19:03.440
OK.

00:19:03.440 --> 00:19:07.530
With that in mind, let's go
back to where we were.

00:19:07.530 --> 00:19:10.580
And where were we?

00:19:10.580 --> 00:19:15.040
We started off talking about
binary search, and I suggested

00:19:15.040 --> 00:19:18.870
that this was a log algorithm,
which it is, which is really

00:19:18.870 --> 00:19:21.060
kind of nice.

00:19:21.060 --> 00:19:32.970
Let's pull together what this
algorithm actually does.

00:19:32.970 --> 00:19:35.780
If I generalize binary search,
here's what I'm going to stake

00:19:35.780 --> 00:19:37.070
that this thing does.

00:19:37.070 --> 00:19:45.580
It says one: pick
the midpoint.

00:19:45.580 --> 00:19:56.360
Two: check to see if this is
the answer, if this is the

00:19:56.360 --> 00:19:58.000
thing I'm looking for.

00:19:58.000 --> 00:20:05.910
And then, three: if not, reduce
to a smaller problem,

00:20:05.910 --> 00:20:16.220
and repeat.

00:20:16.220 --> 00:20:18.260
OK, you're going, yeah, come on,
that makes obvious sense.

00:20:18.260 --> 00:20:18.980
And it does.

00:20:18.980 --> 00:20:21.150
But I want you to keep that
template in mind, because

00:20:21.150 --> 00:20:22.930
we're going to come
back to that.

00:20:22.930 --> 00:20:25.310
It's an example of a very common
tool that's going to be

00:20:25.310 --> 00:20:28.180
really useful to us, not just
for doing search, but for

00:20:28.180 --> 00:20:30.900
doing a whole range of problems.
That is, in essence,

00:20:30.900 --> 00:20:34.030
the template the describes
a log style algorithm.

00:20:34.030 --> 00:20:37.030
And we're going to
come back to it.

00:20:37.030 --> 00:20:38.620
OK.

00:20:38.620 --> 00:20:41.560
With that in mind though,
didn't I cheat?

00:20:41.560 --> 00:20:45.340
I remind you, I know you're not
really listening to me,

00:20:45.340 --> 00:20:45.940
but that's OK.

00:20:45.940 --> 00:20:47.635
I reminded you at the beginning
of the lecture, I

00:20:47.635 --> 00:20:50.090
said, let's assume we have
a sorted list, and then

00:20:50.090 --> 00:20:52.210
let's go search it.

00:20:52.210 --> 00:20:52.830
Where in the world

00:20:52.830 --> 00:20:54.790
did that sorted list
come from?

00:20:54.790 --> 00:20:58.700
What if I just get a list of
elements, what do I do?

00:20:58.700 --> 00:20:59.250
Well let's see.

00:20:59.250 --> 00:21:02.210
My fall back is, I could just
do linear search, walk down

00:21:02.210 --> 00:21:04.400
the list one at a time, just
comparing those things.

00:21:04.400 --> 00:21:04.580
OK.

00:21:04.580 --> 00:21:06.250
So that's sort of my base.

00:21:06.250 --> 00:21:08.390
But what if I wanted, you know,
how do I want to get to

00:21:08.390 --> 00:21:09.300
that sorted list?

00:21:09.300 --> 00:21:12.250
All right?

00:21:12.250 --> 00:21:16.090
Now.

00:21:16.090 --> 00:21:18.160
One of the questions, before we
get to doing the sorting,

00:21:18.160 --> 00:21:20.810
is even to ask, what should I do
in a search case like that?

00:21:20.810 --> 00:21:26.380
All right, so in particular,
does it make sense, if I'm

00:21:26.380 --> 00:21:29.990
given an unsorted list,
to first sort it,

00:21:29.990 --> 00:21:31.450
and then search it?

00:21:31.450 --> 00:21:34.330
Or should I just use the
basically linear case?

00:21:34.330 --> 00:21:34.580
All right?

00:21:34.580 --> 00:21:39.900
So, here's the question.

00:21:39.900 --> 00:21:47.560
Should we sort before
we search?

00:21:47.560 --> 00:21:47.820
OK.

00:21:47.820 --> 00:21:51.050
So let's see, if I'm going to
do this, how fast could we

00:21:51.050 --> 00:21:53.560
sort a list?

00:21:53.560 --> 00:22:05.880
Can we sort a list in
sublinear time?

00:22:05.880 --> 00:22:07.150
Sublinear meaning, something
like log

00:22:07.150 --> 00:22:08.180
less than linear time?

00:22:08.180 --> 00:22:11.460
What do you think?

00:22:11.460 --> 00:22:17.630
It's possible?

00:22:17.630 --> 00:22:19.800
Any thoughts?

00:22:19.800 --> 00:22:22.150
Don't you hate professors who
stand here waiting for you to

00:22:22.150 --> 00:22:25.660
answer, even when
they have candy?

00:22:25.660 --> 00:22:28.370
Does it make sense to think we
could do this in less than

00:22:28.370 --> 00:22:28.940
linear time?

00:22:28.940 --> 00:22:31.060
You know, it takes a little
bit of thinking.

00:22:31.060 --> 00:22:31.760
What would it mean--

00:22:31.760 --> 00:22:34.240
[UNINTELLIGIBLE PHRASE] do I see
a hand, way at the back,

00:22:34.240 --> 00:22:37.500
yes please?

00:22:37.500 --> 00:22:39.770
Thank you.

00:22:39.770 --> 00:22:41.570
Man, you're going to really make
me work here, I have no

00:22:41.570 --> 00:22:43.720
idea if I can get it that
far, ah, your friend

00:22:43.720 --> 00:22:44.250
will help you out.

00:22:44.250 --> 00:22:45.090
Thank you.

00:22:45.090 --> 00:22:47.130
The gentleman has it
exactly right.

00:22:47.130 --> 00:22:49.910
How could I possibly do it in
sublinear time, I've got to

00:22:49.910 --> 00:22:52.700
look at least every
element once.

00:22:52.700 --> 00:22:54.550
And that's the kind of instinct
I'd like you to get

00:22:54.550 --> 00:22:55.130
into thinking about.

00:22:55.130 --> 00:22:58.620
So the answer here is no.

00:22:58.620 --> 00:23:00.180
OK.

00:23:00.180 --> 00:23:07.380
Can we sort it in linear time?

00:23:07.380 --> 00:23:07.830
Hmmm.

00:23:07.830 --> 00:23:11.910
That one's not so obvious.

00:23:11.910 --> 00:23:13.440
So let's think about
this for a second.

00:23:13.440 --> 00:23:18.190
To sort a list in linear time,
would say, I have to look at

00:23:18.190 --> 00:23:20.530
each element in the
list at most a

00:23:20.530 --> 00:23:21.770
constant number of times.

00:23:21.770 --> 00:23:23.030
It doesn't have to be
just once, right?

00:23:23.030 --> 00:23:25.550
It could be two or three times.

00:23:25.550 --> 00:23:25.960
Hmm.

00:23:25.960 --> 00:23:26.590
Well, wait a minute.

00:23:26.590 --> 00:23:28.860
If I want to sort a list, I'll
take one element, I've got to

00:23:28.860 --> 00:23:33.590
look at probably a lot of the
other elements in the list in

00:23:33.590 --> 00:23:35.290
order to decide where it goes.

00:23:35.290 --> 00:23:37.370
And that suggests it's going
to depend on how

00:23:37.370 --> 00:23:38.200
long the list is.

00:23:38.200 --> 00:23:41.640
All right, so that's a weak
argument, but in fact, it's a

00:23:41.640 --> 00:23:49.010
way of suggesting,
probably not.

00:23:49.010 --> 00:23:50.490
All right.

00:23:50.490 --> 00:23:52.890
So how fast could
I sort a list?

00:23:52.890 --> 00:23:54.170
How fast can we sort it?

00:23:54.170 --> 00:24:03.020
And we're going to come back to
this, probably next time if

00:24:03.020 --> 00:24:12.670
I time this right, but the
answer is, we can do it in n

00:24:12.670 --> 00:24:14.830
log n time.

00:24:14.830 --> 00:24:15.810
We're going to come
back to that.

00:24:15.810 --> 00:24:16.110
All right?

00:24:16.110 --> 00:24:18.956
And I'm going to say-- sort of
set that stage here, so that--

00:24:18.956 --> 00:24:21.740
It turns out that that's
probably about the best we can

00:24:21.740 --> 00:24:25.560
do, or again ends at the
length of the list.

00:24:25.560 --> 00:24:27.510
OK, so that's still comes
back to my question.

00:24:27.510 --> 00:24:30.220
If I want to search a list,
should I sort it first and

00:24:30.220 --> 00:24:31.710
then search it?

00:24:31.710 --> 00:24:33.310
Hmmm.

00:24:33.310 --> 00:24:39.420
OK, so let's do the
comparison.

00:24:39.420 --> 00:24:42.550
I'm just going to take an
unsorted list and search it, I

00:24:42.550 --> 00:24:43.980
could do it in linear
time, right?

00:24:43.980 --> 00:24:44.600
One at a time.

00:24:44.600 --> 00:24:46.400
Walk down the elements
until I find it.

00:24:46.400 --> 00:24:48.480
That would be order n.

00:24:48.480 --> 00:24:53.020
On the other hand, if I want
to sort it first, OK, if I

00:24:53.020 --> 00:24:59.520
want to do sort and search, I
want to sort it, it's going to

00:24:59.520 --> 00:25:05.510
take n log n time to sort it,
and having done that, then I

00:25:05.510 --> 00:25:09.170
can search it in log n time.

00:25:09.170 --> 00:25:10.610
Ah.

00:25:10.610 --> 00:25:15.020
So which one's better?

00:25:15.020 --> 00:25:20.200
Yeah.

00:25:20.200 --> 00:25:20.760
Ah-ha.

00:25:20.760 --> 00:25:21.690
Thank you.

00:25:21.690 --> 00:25:23.205
Hold on to that thought for
second, I'm going to

00:25:23.205 --> 00:25:23.890
come back to it.

00:25:23.890 --> 00:25:25.860
That does not assume I'm running
a search it wants,

00:25:25.860 --> 00:25:29.000
which one's better?

00:25:29.000 --> 00:25:30.760
The unsorted, and you have
exactly the point I want to

00:25:30.760 --> 00:25:33.140
get to-- how come all the guys,
sorry, all the people

00:25:33.140 --> 00:25:36.780
answering questions are way,
way up in the back?

00:25:36.780 --> 00:25:40.430
Wow. that's a Tim Wakefield
pitch right there, all right.

00:25:40.430 --> 00:25:42.160
Thank you.

00:25:42.160 --> 00:25:43.910
He has it exactly right.

00:25:43.910 --> 00:25:45.170
OK?

00:25:45.170 --> 00:25:48.330
Is this smaller than that?

00:25:48.330 --> 00:25:49.190
No.

00:25:49.190 --> 00:25:50.340
Now that's a slight lie.

00:25:50.340 --> 00:25:52.730
Sorry, a slight misstatement,
OK?

00:25:52.730 --> 00:25:54.570
I could run for office, couldn't
I, if I can do that

00:25:54.570 --> 00:25:55.460
kind of talk.

00:25:55.460 --> 00:25:57.620
It's a slight misstatement in
the sense that these should

00:25:57.620 --> 00:25:58.630
really be orders of growth.

00:25:58.630 --> 00:26:00.640
There are some constants in
there, it depends on the size,

00:26:00.640 --> 00:26:05.800
but in general, n log n has
to be bigger than n.

00:26:05.800 --> 00:26:08.330
So, as the gentleman back there
said, if I'm searching

00:26:08.330 --> 00:26:11.920
it once, just use the
linear search.

00:26:11.920 --> 00:26:15.370
On the other hand, am I likely
to only search a list once?

00:26:15.370 --> 00:26:16.190
Probably not.

00:26:16.190 --> 00:26:17.710
There are going to be multiple
elements I'm going to be

00:26:17.710 --> 00:26:24.120
looking for, so that suggests
that in fact, I want to

00:26:24.120 --> 00:26:26.500
amortize the cost.

00:26:26.500 --> 00:26:30.970
And what does that say?

00:26:30.970 --> 00:26:33.000
It says, let's assume
I want to do k

00:26:33.000 --> 00:26:41.700
searches of a list. OK.

00:26:41.700 --> 00:26:44.720
In the linear case, meaning in
the unsorted case, what's the

00:26:44.720 --> 00:26:48.900
complexity of this?
k times n, right?

00:26:48.900 --> 00:26:51.170
Order n to do the search, and
I've got to do it k times, so

00:26:51.170 --> 00:26:55.830
this would be k times n.

00:26:55.830 --> 00:26:58.170
In the [GARBLED PHRASE]

00:26:58.170 --> 00:27:03.530
sort and search case,
what's my cost?

00:27:03.530 --> 00:27:05.690
I've got to sort it, and we
said, and we'll come back to

00:27:05.690 --> 00:27:10.520
that next time, that I can do
the sort in n log n, and then

00:27:10.520 --> 00:27:13.880
what's the search
in this case?

00:27:13.880 --> 00:27:17.730
Let's log n to do one search, I
want to do k of them, that's

00:27:17.730 --> 00:27:26.090
k log n, ah-ha!

00:27:26.090 --> 00:27:28.780
Now I'm in better
shape, right?

00:27:28.780 --> 00:27:31.730
Especially for really large n or
for a lot of k, because now

00:27:31.730 --> 00:27:37.860
in general, this is going
to be smaller than that.

00:27:37.860 --> 00:27:40.110
So this is a place where
the amortized cost

00:27:40.110 --> 00:27:41.800
actually helps me out.

00:27:41.800 --> 00:27:43.900
And as the gentleman at the
back said, the question he

00:27:43.900 --> 00:27:46.210
asked is right, it depends
on what I'm trying to do.

00:27:46.210 --> 00:27:49.160
So when I do the analysis, I
want to think about what am I

00:27:49.160 --> 00:27:51.370
doing here, am I capturing
all the pieces of it?

00:27:51.370 --> 00:27:54.020
Here, the two variables that
matter are what's the length

00:27:54.020 --> 00:27:57.030
of the list, and how many times
I'm going to search it?

00:27:57.030 --> 00:28:04.010
So in this case, this one wins,
whereas in this case,

00:28:04.010 --> 00:28:07.000
that one wins.

00:28:07.000 --> 00:28:08.960
OK.

00:28:08.960 --> 00:28:13.220
Having said that, let's look
at doing some sorts.

00:28:13.220 --> 00:28:16.290
And I'm going to start with
a couple of dumb sorting

00:28:16.290 --> 00:28:19.400
mechanisms. Actually, that's
the wrong way saying it,

00:28:19.400 --> 00:28:21.510
they're simply brain-damaged,
they're not dumb, OK?

00:28:21.510 --> 00:28:23.650
They are computationally
challenged, meaning, at the

00:28:23.650 --> 00:28:25.700
time they were invented, they
were perfectly good sorting

00:28:25.700 --> 00:28:27.170
algorithms, there are better
ones, we're going to see a

00:28:27.170 --> 00:28:29.010
much better one next time
around, but this is a good way

00:28:29.010 --> 00:28:30.900
to just start thinking about
how to do the algorithm, or

00:28:30.900 --> 00:28:32.360
how to do the sort.

00:28:32.360 --> 00:28:33.060
Blah, try again.

00:28:33.060 --> 00:28:34.560
How to do this sort.

00:28:34.560 --> 00:28:38.640
So the first one I want to talk
about it's what's called

00:28:38.640 --> 00:28:40.940
selection sort.

00:28:40.940 --> 00:28:50.330
And it's on your handout, and
I'm going to bring the code up

00:28:50.330 --> 00:28:53.310
here, you can see it, it's
called cell sort, just for

00:28:53.310 --> 00:28:54.160
selection sort.

00:28:54.160 --> 00:28:59.060
And let's take a look
at what this does.

00:28:59.060 --> 00:28:59.220
OK.

00:28:59.220 --> 00:29:01.010
And in fact I think the easy
way to look at what this

00:29:01.010 --> 00:29:02.690
does-- boy.

00:29:02.690 --> 00:29:03.700
My jokes are that bad.

00:29:03.700 --> 00:29:04.510
Wow--

00:29:04.510 --> 00:29:04.790
All right.

00:29:04.790 --> 00:29:07.535
I think the easiest way to look
at what this does, is

00:29:07.535 --> 00:29:10.790
let's take a really
simple example--

00:29:10.790 --> 00:29:20.690
I want to make sure I put
the right things out--

00:29:20.690 --> 00:29:23.040
I've got a simple little
list of values there.

00:29:23.040 --> 00:29:25.660
And if I look at this code, I'm
going to run over a loop,

00:29:25.660 --> 00:29:28.930
you can see that there, i is
going to go from zero up to

00:29:28.930 --> 00:29:34.720
the length minus 1, and I'm
going to keep track of a

00:29:34.720 --> 00:29:35.700
couple of variables.

00:29:35.700 --> 00:29:42.670
Min index, I think I
called it min val.

00:29:42.670 --> 00:29:42.810
OK.

00:29:42.810 --> 00:29:43.780
Let's simulate the code.

00:29:43.780 --> 00:29:44.960
Let's see what it's
doing here.

00:29:44.960 --> 00:29:47.780
All right, so we start off.

00:29:47.780 --> 00:29:53.110
Initially i-- ah, let me do it
this way, i is going to point

00:29:53.110 --> 00:29:58.780
there, and I want to make sure
I do it right, OK-- and min

00:29:58.780 --> 00:30:03.330
index is going to point to the
value of i, which is there,

00:30:03.330 --> 00:30:06.780
and min value is initially going
to have the value 1.

00:30:06.780 --> 00:30:09.490
So we're simply catting a hold
of what's the first value

00:30:09.490 --> 00:30:10.160
we've got there.

00:30:10.160 --> 00:30:12.000
And then what do we do?

00:30:12.000 --> 00:30:18.660
We start with j pointing here,
and we can see what this

00:30:18.660 --> 00:30:20.840
loop's going to do, right? j
is just going to move up.

00:30:20.840 --> 00:30:23.180
So it's going to look at the
rest of the list, walking

00:30:23.180 --> 00:30:25.990
along, and what does it do?

00:30:25.990 --> 00:30:27.780
It says, right.

00:30:27.780 --> 00:30:30.540
If j is-- well it says until j
is at the less than the length

00:30:30.540 --> 00:30:37.050
of l-- it says, if min value is
bigger than the thing I'm

00:30:37.050 --> 00:30:39.690
looking at, I'm going to do
something, all right?

00:30:39.690 --> 00:30:40.850
So let's walk this.

00:30:40.850 --> 00:30:42.030
Min value is 1,.

00:30:42.030 --> 00:30:43.020
Is 1 bigger than 8?

00:30:43.020 --> 00:30:43.410
No.

00:30:43.410 --> 00:30:44.080
I move j up.

00:30:44.080 --> 00:30:44.990
Is 1 bigger than 3?

00:30:44.990 --> 00:30:45.510
No.

00:30:45.510 --> 00:30:46.440
1 bigger than 6?

00:30:46.440 --> 00:30:46.580
No.

00:30:46.580 --> 00:30:47.550
1 bigger than 4?

00:30:47.550 --> 00:30:47.850
No.

00:30:47.850 --> 00:30:50.640
I get to the end of the loop,
and I actually do a little bit

00:30:50.640 --> 00:30:51.860
of wasted motion there.

00:30:51.860 --> 00:30:55.690
And the little bit of wasted
motion is, I take the value at

00:30:55.690 --> 00:31:00.405
i, store it away temporarily,
take the value where min index

00:31:00.405 --> 00:31:02.940
is pointing to, put it
back in there, and

00:31:02.940 --> 00:31:04.900
then swap it around.

00:31:04.900 --> 00:31:05.210
OK.

00:31:05.210 --> 00:31:11.540
Having done that, let's move i
up to here. i is now pointing

00:31:11.540 --> 00:31:12.070
at that thing.

00:31:12.070 --> 00:31:13.850
Go through the second
round of the loop.

00:31:13.850 --> 00:31:14.890
OK.

00:31:14.890 --> 00:31:15.790
What does that say?

00:31:15.790 --> 00:31:21.360
I'm going to change min index to
also point there n value is

00:31:21.360 --> 00:31:26.720
8, j starts off here, and I
say, OK, is the thing I'm

00:31:26.720 --> 00:31:30.330
looking at here smaller
than that?

00:31:30.330 --> 00:31:31.550
Yes.

00:31:31.550 --> 00:31:32.530
Ah-ha.

00:31:32.530 --> 00:31:33.710
What does that say to do?

00:31:33.710 --> 00:31:41.200
It says, gee, make min
index point to there,

00:31:41.200 --> 00:31:44.420
min value be 3.

00:31:44.420 --> 00:31:46.810
Change j.

00:31:46.810 --> 00:31:47.970
Is 6 bigger than 3?

00:31:47.970 --> 00:31:48.520
Yes.

00:31:48.520 --> 00:31:49.430
Is 4 bigger than 3?

00:31:49.430 --> 00:31:50.070
Yes.

00:31:50.070 --> 00:31:51.420
Get to the end.

00:31:51.420 --> 00:31:55.210
And when I get to the
end, what do I do?

00:31:55.210 --> 00:32:01.620
Well, you see, I say, take temp,
and store away what's

00:32:01.620 --> 00:32:04.300
here, all right?

00:32:04.300 --> 00:32:07.290
Which is that value, and then
take what min index is

00:32:07.290 --> 00:32:16.810
pointing to, and stick it in
there, and finally, replace

00:32:16.810 --> 00:32:21.550
that value.

00:32:21.550 --> 00:32:23.240
OK.

00:32:23.240 --> 00:32:24.900
Aren't you glad I'm
not a computer?

00:32:24.900 --> 00:32:26.890
Slow as hell.

00:32:26.890 --> 00:32:29.440
What's this thing doing?

00:32:29.440 --> 00:32:34.930
It's walking along the list,
looking for the smallest thing

00:32:34.930 --> 00:32:37.980
in the back end of the list,
keeping track of where it came

00:32:37.980 --> 00:32:41.220
from, and swapping it
with that spot in

00:32:41.220 --> 00:32:42.850
the list. All right?

00:32:42.850 --> 00:32:45.340
So in the first case, I didn't
have to do any swaps because 1

00:32:45.340 --> 00:32:46.150
was the smallest thing.

00:32:46.150 --> 00:32:49.700
In the second case, I found in
the next smallest element and

00:32:49.700 --> 00:32:52.550
moved here, taking what was
there and moving it on, in

00:32:52.550 --> 00:32:56.230
this case I would swap the 4 and
the 8, and in next case I

00:32:56.230 --> 00:32:58.300
wouldn't have to do anything.

00:32:58.300 --> 00:32:59.520
Let's check it out.

00:32:59.520 --> 00:33:02.650
I've written a little bit of a
test script here, so if we

00:33:02.650 --> 00:33:07.080
test cell sort, and I've written
this so that it's

00:33:07.080 --> 00:33:08.830
going to print out what
the list is at the end

00:33:08.830 --> 00:33:13.480
of each round, OK.

00:33:13.480 --> 00:33:16.110
Ah-ha.

00:33:16.110 --> 00:33:17.930
Notice what-- where am
I, here-- notice what

00:33:17.930 --> 00:33:19.000
happened in this case.

00:33:19.000 --> 00:33:22.220
At the end of the first round,
I've got the smallest element

00:33:22.220 --> 00:33:23.200
at the front.

00:33:23.200 --> 00:33:25.340
At the end of the second round,
I've got the smallest

00:33:25.340 --> 00:33:27.280
two elements at the front,
in fact I got all

00:33:27.280 --> 00:33:29.340
of them sorted out.

00:33:29.340 --> 00:33:31.810
And it actually runs through
the loop multiple times,

00:33:31.810 --> 00:33:33.180
making sure that it's
in the right form.

00:33:33.180 --> 00:33:36.710
Let's take another example.

00:33:36.710 --> 00:33:39.370
OK.

00:33:39.370 --> 00:33:40.950
Smallest element at the front.

00:33:40.950 --> 00:33:42.830
Smallest two elements
at the front.

00:33:42.830 --> 00:33:44.330
Smallest three elements
at the front.

00:33:44.330 --> 00:33:46.590
Smallest four elements at the
front, you get the idea.

00:33:46.590 --> 00:33:49.500
Smallest five elements
at the front.

00:33:49.500 --> 00:33:52.660
So this is a nice little
search-- sorry, a nice little

00:33:52.660 --> 00:33:53.210
sort algorithm .

00:33:53.210 --> 00:33:56.880
And in fact, it's relying on
something that we're going to

00:33:56.880 --> 00:33:59.200
come back to, called
the loop invariant.

00:33:59.200 --> 00:34:16.350
Actually, let me put it on this
board so you can see it.

00:34:16.350 --> 00:34:18.360
The loop invariant what does
the loop invariant mean?

00:34:18.360 --> 00:34:21.850
It says, here is a property that
is true of this structure

00:34:21.850 --> 00:34:23.510
every time through the loop.

00:34:23.510 --> 00:34:26.870
In the loop invariant here is
the following: the list is

00:34:26.870 --> 00:34:37.150
split, into a prefix or a first
part, and a suffix, the

00:34:37.150 --> 00:34:48.100
prefix is sorted, the suffix
is not, and basically, the

00:34:48.100 --> 00:34:50.410
loop starts off with the prefix
being nothing and it

00:34:50.410 --> 00:34:53.340
keeps increasing the size of the
prefix by 1 until it gets

00:34:53.340 --> 00:34:55.890
through the entire list, at
which point there's nothing in

00:34:55.890 --> 00:35:00.200
the suffix and entire
prefix is sorted.

00:35:00.200 --> 00:35:01.990
OK?

00:35:01.990 --> 00:35:04.114
So you can see that, it's just
walking through it, and in

00:35:04.114 --> 00:35:06.250
fact if I look at a couple of
another-- another couple of

00:35:06.250 --> 00:35:09.380
examples, it's been a
long day, again, you

00:35:09.380 --> 00:35:12.680
can see that property.

00:35:12.680 --> 00:35:16.470
You'll also notice that this
thing goes through the entire

00:35:16.470 --> 00:35:19.345
list, even if the list
is sorted before it

00:35:19.345 --> 00:35:20.030
gets partway through.

00:35:20.030 --> 00:35:22.720
And that you might look at,
for example, that first

00:35:22.720 --> 00:35:25.720
example, and say, man by this
stage it was already sorted,

00:35:25.720 --> 00:35:28.230
yet it had to go through and
check that the third element

00:35:28.230 --> 00:35:30.000
was in the right place, and then
the fourth and then the

00:35:30.000 --> 00:35:32.430
fifth and then the six.

00:35:32.430 --> 00:35:34.460
OK.

00:35:34.460 --> 00:35:35.740
What order of growth?

00:35:35.740 --> 00:35:40.450
What's complexity of this?

00:35:40.450 --> 00:35:43.200
I've got to get rid
of this candy.

00:35:43.200 --> 00:35:44.050
Anybody help me out?

00:35:44.050 --> 00:35:46.690
What's the complexity of this?

00:35:46.690 --> 00:35:49.010
Sorry, somebody at the back.

00:35:49.010 --> 00:35:49.680
n squared.

00:35:49.680 --> 00:35:52.810
Yeah, where n is what?

00:35:52.810 --> 00:35:54.940
Yeah, and I can't even see
who's saying that.

00:35:54.940 --> 00:35:56.220
Thank you.

00:35:56.220 --> 00:35:57.900
Sorry, I've got the wrong
glasses on, but you're

00:35:57.900 --> 00:36:00.030
absolutely right, and in case
the rest of you didn't hear

00:36:00.030 --> 00:36:03.890
it, n squared.

00:36:03.890 --> 00:36:05.980
How do I figure that out?

00:36:05.980 --> 00:36:09.630
Well I'm looping down
the list, right?

00:36:09.630 --> 00:36:12.660
I'm walking down the list. So
it's certainly at least linear

00:36:12.660 --> 00:36:15.230
in the length of the list.
For each starting

00:36:15.230 --> 00:36:15.940
point, what do I do?

00:36:15.940 --> 00:36:19.900
I look at the rest of the list
to decide what's the element

00:36:19.900 --> 00:36:21.300
to swap into the next place.

00:36:21.300 --> 00:36:23.200
Now, you might say, well,
wait a minute.

00:36:23.200 --> 00:36:26.310
As I keep moving down, that part
gets smaller, it's not

00:36:26.310 --> 00:36:29.110
always the initial length of
the list, and you're right.

00:36:29.110 --> 00:36:31.350
But if you do the sums, or if
you want to think of it this

00:36:31.350 --> 00:36:34.180
way, if you think about this
more generally, it's always on

00:36:34.180 --> 00:36:37.330
average at least the length of
the list. So I've got to do n

00:36:37.330 --> 00:36:39.160
things n times.

00:36:39.160 --> 00:36:42.620
So it's quadratic, in
terms of that sort.

00:36:42.620 --> 00:36:43.930
OK.

00:36:43.930 --> 00:36:45.680
That's one way to
do this sort.

00:36:45.680 --> 00:36:50.510
Let's do another one.

00:36:50.510 --> 00:36:52.180
The second one we're going to
do is called bubble sort.

00:36:52.180 --> 00:36:55.020
All right?

00:36:55.020 --> 00:36:59.980
And bubble sort is also
on your handout.

00:36:59.980 --> 00:37:07.970
And you want to take the first
of these, let me-- sorry, for

00:37:07.970 --> 00:37:10.480
a second let me uncomment
that, and let me

00:37:10.480 --> 00:37:11.510
comment this out--

00:37:11.510 --> 00:37:19.950
All right, you can see the code
for bubble sort there.

00:37:19.950 --> 00:37:21.770
Let's just look at it for a
second, then we'll try some

00:37:21.770 --> 00:37:23.100
examples, and then we'll
figure out what

00:37:23.100 --> 00:37:25.030
it's actually doing.

00:37:25.030 --> 00:37:27.890
So bubble sort, which
is right up here.

00:37:27.890 --> 00:37:28.630
What's it going to do?

00:37:28.630 --> 00:37:32.530
It's going to let j run over
the length of the list, all

00:37:32.530 --> 00:37:34.530
right, so it's going to start
at some point to move down,

00:37:34.530 --> 00:37:38.870
and then it's going to let i
run over range, that's just

00:37:38.870 --> 00:37:43.580
one smaller, and what's
it doing there?

00:37:43.580 --> 00:37:45.520
It's looking at successive
pairs, right?

00:37:45.520 --> 00:37:48.680
It's looking at the i'th and the
i plus first element, and

00:37:48.680 --> 00:37:51.240
it's saying, gee, if the i'th
element is bigger than the

00:37:51.240 --> 00:37:53.490
i'th plus first element, what's
the next set of three

00:37:53.490 --> 00:37:55.730
things doing?

00:37:55.730 --> 00:37:57.640
Just swapping them, right?

00:37:57.640 --> 00:37:59.770
I temporarily hold on to what's
in the i'th element so

00:37:59.770 --> 00:38:02.940
I can move the i plus first one
in, and then replace that

00:38:02.940 --> 00:38:05.210
with the i'th element.

00:38:05.210 --> 00:38:06.450
OK.

00:38:06.450 --> 00:38:08.980
What's this thing doing then,
in terms of sorting?

00:38:08.980 --> 00:38:13.230
At the end of the first pass,
what could I say about the

00:38:13.230 --> 00:38:16.910
result of this thing?

00:38:16.910 --> 00:38:25.360
What's the last element
in the list look like?

00:38:25.360 --> 00:38:28.050
I hate professors who do this.

00:38:28.050 --> 00:38:30.180
Well, let's try it.

00:38:30.180 --> 00:38:35.700
Let's try a little test. OK?

00:38:35.700 --> 00:38:40.850
Test bubble sort-- especially if
I could type-- let's run it

00:38:40.850 --> 00:38:49.740
on the first list. OK, let's
try it on another one.

00:38:49.740 --> 00:38:50.910
Oops sorry.

00:38:50.910 --> 00:38:53.520
Ah, I didn't want to do it this
time, I forgot to do the

00:38:53.520 --> 00:38:56.580
following, bear with me.

00:38:56.580 --> 00:38:57.890
I gave away my punchline.

00:38:57.890 --> 00:38:58.820
Let's try it again.

00:38:58.820 --> 00:39:04.440
Test bubble sort.

00:39:04.440 --> 00:39:07.180
OK, there's the first run, I'm
going to take a different

00:39:07.180 --> 00:39:18.720
list. Can you see
a pattern there?

00:39:18.720 --> 00:39:18.970
Yeah.

00:39:18.970 --> 00:39:22.180
STUDENT: The last cell in the
list is always going to

00:39:22.180 --> 00:39:22.510
[INAUDIBLE]

00:39:22.510 --> 00:39:23.400
PROFESSOR ERIC GRIMSON: Yeah.

00:39:23.400 --> 00:39:23.560
Why?

00:39:23.560 --> 00:39:24.380
You're right, but why?

00:39:24.380 --> 00:39:28.940
STUDENT: [UNINTELLIGIBLE PHRASE]

00:39:28.940 --> 00:39:29.910
PROFESSOR ERIC GRIMSON:
Exactly right.

00:39:29.910 --> 00:39:30.670
Thank you.

00:39:30.670 --> 00:39:37.090
The observation is, thank you,
on the first pass through, the

00:39:37.090 --> 00:39:40.110
last element is the biggest
thing in the list. On the next

00:39:40.110 --> 00:39:43.200
pass through, the next largest
element is at the second point

00:39:43.200 --> 00:39:43.280
in

00:39:43.280 --> 00:39:43.970
the list. OK?

00:39:43.970 --> 00:39:45.180
Because what am I doing?

00:39:45.180 --> 00:39:46.600
It's called bubble sort
because it's literally

00:39:46.600 --> 00:39:47.900
bubbling along, right?

00:39:47.900 --> 00:39:51.610
I'm walking along the list once,
taking two things, and

00:39:51.610 --> 00:39:53.510
saying, make sure the
biggest one is next.

00:39:53.510 --> 00:39:55.810
So wherever the largest element
started out in the

00:39:55.810 --> 00:39:59.800
list, by the time I get through
it, it's at the end.

00:39:59.800 --> 00:40:01.760
And then I go back and
I start again, and

00:40:01.760 --> 00:40:03.030
I do the same thing.

00:40:03.030 --> 00:40:03.250
OK.

00:40:03.250 --> 00:40:05.340
The next largest element
has to end up in

00:40:05.340 --> 00:40:06.740
the second last spot.

00:40:06.740 --> 00:40:07.290
Et cetera.

00:40:07.290 --> 00:40:09.990
All right, so it's called bubble
sort because it does

00:40:09.990 --> 00:40:12.340
this bubbling up until
it gets there.

00:40:12.340 --> 00:40:14.070
Now.

00:40:14.070 --> 00:40:15.110
What's the order
of growth here?

00:40:15.110 --> 00:40:19.810
What's the complexity?

00:40:19.810 --> 00:40:21.720
I haven't talked to the side
of the room in a while,

00:40:21.720 --> 00:40:23.160
actually I have. This gentleman
has helped me out.

00:40:23.160 --> 00:40:23.870
Somebody else help me out.

00:40:23.870 --> 00:40:27.970
What's the complexity here?

00:40:27.970 --> 00:40:31.700
I must have the wrong glasses
on to see a hand.

00:40:31.700 --> 00:40:34.160
No help.

00:40:34.160 --> 00:40:36.260
Log?

00:40:36.260 --> 00:40:38.050
Linear?

00:40:38.050 --> 00:40:40.450
Exponential?

00:40:40.450 --> 00:40:41.470
Quadratic?

00:40:41.470 --> 00:40:43.020
Yeah.

00:40:43.020 --> 00:40:44.970
Log.

00:40:44.970 --> 00:40:50.160
It's a good think, but why
do you think it's log?

00:40:50.160 --> 00:40:50.980
Ah-ha.

00:40:50.980 --> 00:40:53.490
It's not a bad instinct, the
length is getting shorter each

00:40:53.490 --> 00:40:54.400
time, but what's one of the

00:40:54.400 --> 00:40:56.260
characteristics of a log algorithm?

00:40:56.260 --> 00:40:58.920
It drops in half each time.

00:40:58.920 --> 00:41:00.900
So this isn't--

00:41:00.900 --> 00:41:01.230
OK.

00:41:01.230 --> 00:41:02.120
And you're also close.

00:41:02.120 --> 00:41:04.200
It's going to be linear,
but how many times do

00:41:04.200 --> 00:41:05.070
I go through this?

00:41:05.070 --> 00:41:08.980
All right, I've got to do one
pass to bubble the last

00:41:08.980 --> 00:41:10.080
element to the end.

00:41:10.080 --> 00:41:12.470
I've got to do another pass to
bubble the second last element

00:41:12.470 --> 00:41:12.720
to the end.

00:41:12.720 --> 00:41:14.730
I've got to do another pass.

00:41:14.730 --> 00:41:15.800
Huh.

00:41:15.800 --> 00:41:19.400
Sounds like a linear number of
times I've got to do-- oh

00:41:19.400 --> 00:41:20.150
fudge knuckle.

00:41:20.150 --> 00:41:23.230
A linear number of things,
quadratic.

00:41:23.230 --> 00:41:25.220
Right?

00:41:25.220 --> 00:41:25.600
OK.

00:41:25.600 --> 00:41:32.620
So this is again an example,
this was quadratic, and this

00:41:32.620 --> 00:41:35.130
one was quadratic.

00:41:35.130 --> 00:41:40.690
And I have this, to write it
out, this is order the length

00:41:40.690 --> 00:41:43.720
of the list squared, OK?

00:41:43.720 --> 00:41:44.820
Just to make it clear
what we're

00:41:44.820 --> 00:41:48.250
actually measuring there.

00:41:48.250 --> 00:41:48.360
All

00:41:48.360 --> 00:41:48.720
right.

00:41:48.720 --> 00:41:50.870
Could we do better?

00:41:50.870 --> 00:41:52.110
Sure.

00:41:52.110 --> 00:41:54.530
And in fact, next time we're
going to show you that n log n

00:41:54.530 --> 00:41:57.050
algorithm, but even with bubble
sort, we can do better.

00:41:57.050 --> 00:42:00.290
In a particular, if I look at
those traces, I can certainly

00:42:00.290 --> 00:42:03.950
see cases where, man, I already
had the list sorted

00:42:03.950 --> 00:42:06.350
much earlier on, and yet I
kept going back to see if

00:42:06.350 --> 00:42:08.620
there was anything else
to bubble up.

00:42:08.620 --> 00:42:09.870
How would I keep
track of that?

00:42:09.870 --> 00:42:12.600
Could I take advantage of that?

00:42:12.600 --> 00:42:13.860
Sure.

00:42:13.860 --> 00:42:16.550
Why don't I just keep track
on each pass through the

00:42:16.550 --> 00:42:18.720
algorithm whether I have
done any swaps?

00:42:18.720 --> 00:42:20.210
All right?

00:42:20.210 --> 00:42:22.480
Because if I don't do any swaps
on a pass through the

00:42:22.480 --> 00:42:23.850
algorithm, then it
says everything's

00:42:23.850 --> 00:42:24.820
in the right order.

00:42:24.820 --> 00:42:28.180
And so, in fact, the version
that I commented out-- which

00:42:28.180 --> 00:42:29.880
is also in your handout and I'm
now going to uncomment,

00:42:29.880 --> 00:42:38.820
let's get that one out, get rid
of this one-- notice the

00:42:38.820 --> 00:42:39.810
only change.

00:42:39.810 --> 00:42:42.113
I'm going to keep track of a
little variable called swap,

00:42:42.113 --> 00:42:46.225
it's initially true, and as long
as it's true, I'm going

00:42:46.225 --> 00:42:49.010
to keep going, but inside of the
loop I'm going to set it

00:42:49.010 --> 00:42:53.620
to false, and only if I do a
swap will I set it to true.

00:42:53.620 --> 00:42:56.070
This says, if I go through an
entire pass through the list

00:42:56.070 --> 00:42:58.410
and nothing gets changed,
I'm done.

00:42:58.410 --> 00:43:09.730
And in fact if I do that, and
try test bubble sort, well, in

00:43:09.730 --> 00:43:13.080
the first case, looks the same.

00:43:13.080 --> 00:43:13.620
Ah.

00:43:13.620 --> 00:43:17.660
On the second case, I
spot it right away.

00:43:17.660 --> 00:43:20.340
On the third case, it takes me
the same amount of time.

00:43:20.340 --> 00:43:24.210
And the fourth case, when
I set it up, I'm done.

00:43:24.210 --> 00:43:24.340
OK.

00:43:24.340 --> 00:43:25.670
So what's the lesson here?

00:43:25.670 --> 00:43:28.420
I can be a little more careful
about keeping track of what

00:43:28.420 --> 00:43:30.000
goes on inside of that loop.

00:43:30.000 --> 00:43:31.930
If I don't have any more work
to do, let me just stop.

00:43:31.930 --> 00:43:33.230
All right.

00:43:33.230 --> 00:43:36.940
Nonetheless, even with this
change, what's the order

00:43:36.940 --> 00:43:39.080
growth for bubble sort?

00:43:39.080 --> 00:43:40.380
Still quadratic, right?

00:43:40.380 --> 00:43:42.360
I'm looking for the worst case
behavior, it's still

00:43:42.360 --> 00:43:44.630
quadratic, it's quadratic in the
length of the list, so I'm

00:43:44.630 --> 00:43:47.180
sort of stuck with that.

00:43:47.180 --> 00:43:47.560
Now.

00:43:47.560 --> 00:43:49.120
Let me ask you one last
question, and then

00:43:49.120 --> 00:43:51.070
we'll wrap this up.

00:43:51.070 --> 00:43:55.420
Which of these algorithms
is better?

00:43:55.420 --> 00:43:57.020
Insertion sort or bubble sort?

00:43:57.020 --> 00:43:59.140
STUDENT: Bubble.

00:43:59.140 --> 00:43:59.520
PROFESSOR ERIC GRIMSON:
Bubble.

00:43:59.520 --> 00:44:00.270
Bubble bubble toil
and trouble.

00:44:00.270 --> 00:44:01.780
Who said bubble?

00:44:01.780 --> 00:44:02.140
Why?

00:44:02.140 --> 00:44:04.836
STUDENT: Well, the first
one was too inefficient

00:44:04.836 --> 00:44:07.195
[UNINTELLIGIBLE] store and
compare each one, so

00:44:07.195 --> 00:44:15.320
[UNINTELLIGIBLE]

00:44:15.320 --> 00:44:16.380
PROFESSOR ERIC GRIMSON: It's
not a bad instinct.

00:44:16.380 --> 00:44:16.600
Right.

00:44:16.600 --> 00:44:19.680
So it-- so, your argument is,
bubble is better because it's

00:44:19.680 --> 00:44:23.300
is essentially not doing all
these extra comparisons.

00:44:23.300 --> 00:44:25.150
Another way of saying it is,
I can do this stop when

00:44:25.150 --> 00:44:25.900
I don't need to.

00:44:25.900 --> 00:44:26.450
All right?

00:44:26.450 --> 00:44:28.120
OK.

00:44:28.120 --> 00:44:30.660
Anybody have an opposing
opinion?

00:44:30.660 --> 00:44:34.260
Wow, this sounds like a
presidential debate.

00:44:34.260 --> 00:44:35.320
Sorry, I should reward you.

00:44:35.320 --> 00:44:37.380
Thank you for that statement.

00:44:37.380 --> 00:44:40.160
Anybody have an opposing
opinion?

00:44:40.160 --> 00:44:41.730
Everybody's answering these
things and sitting

00:44:41.730 --> 00:44:42.390
way up at the back.

00:44:42.390 --> 00:44:44.340
Nice catch.

00:44:44.340 --> 00:44:44.720
Yeah.

00:44:44.720 --> 00:44:55.160
STUDENT: [INAUDIBLE]

00:44:55.160 --> 00:44:55.990
PROFESSOR ERIC GRIMSON: I
don't think so, right?

00:44:55.990 --> 00:44:57.690
I think selection sort, I
still have to go through

00:44:57.690 --> 00:45:01.750
multiple times, it was still
quadratic, OK, but I think

00:45:01.750 --> 00:45:03.540
you're heading towards a
direction I want to get at, so

00:45:03.540 --> 00:45:05.150
let me prime this
a little bit.

00:45:05.150 --> 00:45:10.120
How many swaps do I do in
general in bubble sort,

00:45:10.120 --> 00:45:13.650
compared to selection source?

00:45:13.650 --> 00:45:14.340
God bless.

00:45:14.340 --> 00:45:18.840
Oh, sorry, that wasn't a
sneeze, it was a two?

00:45:18.840 --> 00:45:23.460
How many swaps do I
do in bubble sort?

00:45:23.460 --> 00:45:24.430
A lot.

00:45:24.430 --> 00:45:24.840
Right.

00:45:24.840 --> 00:45:27.160
Potentially a lot because I'm
constantly doing that, that

00:45:27.160 --> 00:45:29.620
says I'm running that inner loop
a whole bunch of times.

00:45:29.620 --> 00:45:34.350
How many swaps do I do
in selection sort?

00:45:34.350 --> 00:45:36.190
Once each time.

00:45:36.190 --> 00:45:36.320
Right?

00:45:36.320 --> 00:45:39.130
I only do one swap potentially,
it-- though not

00:45:39.130 --> 00:45:40.750
one potentially, each
time at the end of

00:45:40.750 --> 00:45:42.450
the loop I do a swap.

00:45:42.450 --> 00:45:45.480
So this actually suggests again,
the orders of growth

00:45:45.480 --> 00:45:49.060
are the same, but probably
selection sort is a more

00:45:49.060 --> 00:45:51.710
efficient algorithm, because
I'm not doing that constant

00:45:51.710 --> 00:45:53.010
amount of work every
time around.

00:45:53.010 --> 00:45:55.890
And in fact, if you go look up,
you won't see bubble sort

00:45:55.890 --> 00:45:56.780
used very much.

00:45:56.780 --> 00:45:57.240
Most--

00:45:57.240 --> 00:45:59.140
I shouldn't say most, many
computer scientists don't

00:45:59.140 --> 00:46:00.700
think it should be taught,
because it's just so

00:46:00.700 --> 00:46:01.770
inefficient.

00:46:01.770 --> 00:46:03.950
I disagree, because it's a
clever idea, but it's still

00:46:03.950 --> 00:46:06.310
something that we have
to keep track of.

00:46:06.310 --> 00:46:07.770
All right.

00:46:07.770 --> 00:46:10.140
We haven't gotten to our n log n
algorithm, we're going to do

00:46:10.140 --> 00:46:14.150
that next time, but I want to
set the stage here by pulling

00:46:14.150 --> 00:46:16.940
out one last piece.

00:46:16.940 --> 00:46:17.330
OK.

00:46:17.330 --> 00:46:19.130
Could we do better in
terms of sorting?

00:46:19.130 --> 00:46:20.270
Again, remember what
our goal was.

00:46:20.270 --> 00:46:23.300
If we could do sort, then we
saw, if we amortized the cost,

00:46:23.300 --> 00:46:25.955
that searching is a lot more
efficient if we're searching a

00:46:25.955 --> 00:46:27.060
sorted list.

00:46:27.060 --> 00:46:29.030
How could we do better?

00:46:29.030 --> 00:46:30.500
Let me set the stage.

00:46:30.500 --> 00:46:34.690
I already said, back here, when
I used this board, that

00:46:34.690 --> 00:46:36.630
this idea was really
important.

00:46:36.630 --> 00:46:43.260
And that's because that is
a version of a divide and

00:46:43.260 --> 00:46:48.590
conquer algorithm.

00:46:48.590 --> 00:46:48.800
OK.

00:46:48.800 --> 00:46:51.460
Binary search is perhaps the
simplest of the divide and

00:46:51.460 --> 00:46:53.070
conquer algorithms, and
what does that mean?

00:46:53.070 --> 00:46:56.230
It says, in order to solve a
problem, cut it down to a

00:46:56.230 --> 00:46:58.770
smaller problem and try
and solve that one.

00:46:58.770 --> 00:47:01.740
So to just preface what we're
going to do next time, what

00:47:01.740 --> 00:47:04.810
would happen if I wanted to do
sort, and rather than in

00:47:04.810 --> 00:47:09.210
sorting the entire list at once,
I broke it into pieces,

00:47:09.210 --> 00:47:12.150
and sorted the pieces, and then
just figured out a very

00:47:12.150 --> 00:47:15.240
efficient way to bring those two
pieces and merge them back

00:47:15.240 --> 00:47:16.420
together again?

00:47:16.420 --> 00:47:19.310
Where those pieces, I would do
the same thing with, I would

00:47:19.310 --> 00:47:23.360
divide them up into smaller
chunks, and sort those.

00:47:23.360 --> 00:47:25.760
Is that going to give me a
more efficient algorithm?

00:47:25.760 --> 00:47:27.580
And if you come back
on Thursday,

00:47:27.580 --> 00:47:29.420
we'll answer that question.

