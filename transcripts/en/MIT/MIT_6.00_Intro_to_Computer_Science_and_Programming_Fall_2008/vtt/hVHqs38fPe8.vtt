WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.400
ANNOUNCER: Open content is
provided under a creative

00:00:02.400 --> 00:00:03.840
commons license.

00:00:03.840 --> 00:00:06.850
Your support will help MIT
OpenCourseWare continue to

00:00:06.850 --> 00:00:10.530
offer high-quality educational
resources for free.

00:00:10.530 --> 00:00:13.390
To make a donation, or view
additional materials from

00:00:13.390 --> 00:00:17.190
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.190 --> 00:00:19.980
ocw.mit.edu .

00:00:19.980 --> 00:00:23.600
PROFESSOR JOHN GUTTAG:
All right.

00:00:23.600 --> 00:00:30.720
That said, let's continue, and
if you remember last time, we

00:00:30.720 --> 00:00:35.180
ended up looking at this thing
I called square roots bi.

00:00:35.180 --> 00:00:38.810
This was using something called
a bisection method,

00:00:38.810 --> 00:00:42.230
which is related to something
called binary search, which

00:00:42.230 --> 00:00:47.270
we'll see lots more of later,
to find square roots.

00:00:47.270 --> 00:00:53.260
And the basic idea was that we
had some sort of a line, and

00:00:53.260 --> 00:00:57.010
we knew the answer was somewhere
between this point

00:00:57.010 --> 00:01:00.810
and this point.

00:01:00.810 --> 00:01:10.800
The line is totally ordered.

00:01:10.800 --> 00:01:16.980
And what that means, is that
anything here is smaller than

00:01:16.980 --> 00:01:19.680
anything to its right.

00:01:19.680 --> 00:01:23.000
So the integers are totally
ordered, the reals are totally

00:01:23.000 --> 00:01:25.250
ordered, lots of
things are, the

00:01:25.250 --> 00:01:28.290
rationals are totally ordered.

00:01:28.290 --> 00:01:32.620
And that idea was, we make a
guess in the middle, we test

00:01:32.620 --> 00:01:37.360
it so this is kind of a guess
and check, and if the answer

00:01:37.360 --> 00:01:41.410
was too big, then we knew
that we should be

00:01:41.410 --> 00:01:43.220
looking over here.

00:01:43.220 --> 00:01:45.470
If it was too small, we knew
we should be looking over

00:01:45.470 --> 00:01:50.140
here, and then we
would repeat.

00:01:50.140 --> 00:01:53.340
So this is very similar, this
is a kind of recursive

00:01:53.340 --> 00:01:56.590
thinking we talked about
earlier, where we take our

00:01:56.590 --> 00:01:59.390
problem and we make it smaller,
we solve a smaller

00:01:59.390 --> 00:02:02.900
problem, et cetera.

00:02:02.900 --> 00:02:03.630
All right.

00:02:03.630 --> 00:02:10.160
So now, we've got it, I've
got the code up for you.

00:02:10.160 --> 00:02:13.910
I want you to notice the
specifications to start.

00:02:13.910 --> 00:02:17.840
We're assuming that x is greater
than or equal to 0,

00:02:17.840 --> 00:02:21.400
and epsilon is strictly greater
than 0, and we're

00:02:21.400 --> 00:02:26.120
going to return some value y
such that y squared is within

00:02:26.120 --> 00:02:29.820
epsilon of x.

00:02:29.820 --> 00:02:34.110
I'd last time talked about the
two assert statements.

00:02:34.110 --> 00:02:36.750
In some sense, strictly speaking
they shouldn't be

00:02:36.750 --> 00:02:42.510
necessary, because the fact that
my specification starts

00:02:42.510 --> 00:02:46.740
with an assumption, says, hey
you, who might call square

00:02:46.740 --> 00:02:51.590
root, make sure that the things
you call me with obey

00:02:51.590 --> 00:02:53.140
the assumption.

00:02:53.140 --> 00:02:56.670
On the other hand, as I said,
never trust a programmer to do

00:02:56.670 --> 00:03:00.200
the right thing, so we're
going to check it.

00:03:00.200 --> 00:03:02.580
And just in case the assumptions
are not true,

00:03:02.580 --> 00:03:04.740
we're just going to stop
dead in our tracks.

00:03:04.740 --> 00:03:08.190
All right.

00:03:08.190 --> 00:03:12.390
Then we're going to set low to--
low and high, and we're

00:03:12.390 --> 00:03:18.160
going to perform exactly the
process I talked about.

00:03:18.160 --> 00:03:23.060
And along the way, I'm keeping
track of how many iterations,

00:03:23.060 --> 00:03:26.960
at the end I'll print how many
iterations I took, before I

00:03:26.960 --> 00:03:28.970
return the final guess.

00:03:28.970 --> 00:03:32.410
All right, let's test it.

00:03:32.410 --> 00:03:35.910
So one of the things I want you
to observe here, is that

00:03:35.910 --> 00:03:38.550
instead of sitting there and
typing away a bunch of test

00:03:38.550 --> 00:03:43.510
cases, I took the trouble to
write a function, called test

00:03:43.510 --> 00:03:44.500
bi in this case.

00:03:44.500 --> 00:03:49.680
All right, so what that's doing,
is it's taking the

00:03:49.680 --> 00:03:55.000
things I would normally type,
and putting them in a

00:03:55.000 --> 00:03:57.500
function, which I
can then call.

00:03:57.500 --> 00:04:05.450
Why is that better
than typing them?

00:04:05.450 --> 00:04:10.740
Why was it worth creating
a function to do this?

00:04:10.740 --> 00:04:11.080
Pardon?

00:04:11.080 --> 00:04:13.690
STUDENT:: [INAUDIBLE]

00:04:13.690 --> 00:04:17.480
PROFESSOR JOHN GUTTAG: Then I
can I can use it again and

00:04:17.480 --> 00:04:19.630
again and again.

00:04:19.630 --> 00:04:24.300
Exactly.

00:04:24.300 --> 00:04:28.390
By putting it in a function, if
I find a bug and I change

00:04:28.390 --> 00:04:33.380
my program, I can just run
the function again.

00:04:33.380 --> 00:04:40.010
The beauty of this is, it keeps
me from getting lazy,

00:04:40.010 --> 00:04:43.040
and not only testing my program
and the thing that

00:04:43.040 --> 00:04:47.260
found the bug, but in all the
things that used to work.

00:04:47.260 --> 00:04:51.090
We'll talk more about this
later, but it often happens

00:04:51.090 --> 00:04:54.290
that when you change your
program to solve one problem,

00:04:54.290 --> 00:04:58.080
you break it, and things that
used to work don't work.

00:04:58.080 --> 00:05:00.970
And so what you want to do, and
again we'll come back to

00:05:00.970 --> 00:05:03.360
this later in the term,
is something

00:05:03.360 --> 00:05:08.170
called regression testing.

00:05:08.170 --> 00:05:13.650
This has nothing to do with
linear regression.

00:05:13.650 --> 00:05:16.590
And that's basically trying to
make sure our program has not

00:05:16.590 --> 00:05:19.720
regressed, as to say,
gone backwards

00:05:19.720 --> 00:05:21.480
in how well it works.

00:05:21.480 --> 00:05:24.900
And so we always test
it on everything.

00:05:24.900 --> 00:05:25.630
All right?

00:05:25.630 --> 00:05:28.920
So I've created this function,
let's give it a shot and see

00:05:28.920 --> 00:05:37.990
what happens.

00:05:37.990 --> 00:05:40.530
We'll run test bi.

00:05:40.530 --> 00:05:42.600
Whoops!

00:05:42.600 --> 00:05:46.230
All right, well let's
look at our answers.

00:05:46.230 --> 00:05:51.790
I first tested it on the square
root of 4, and in one

00:05:51.790 --> 00:05:53.890
iteration it found 2.

00:05:53.890 --> 00:05:56.030
I like that answer.

00:05:56.030 --> 00:05:59.680
I then tested it on the square
root of 9, and as I mentioned

00:05:59.680 --> 00:06:03.510
last time, I didn't find 3.

00:06:03.510 --> 00:06:05.080
I was not crushed.

00:06:05.080 --> 00:06:08.110
You know, I was not really
disappointed, it found

00:06:08.110 --> 00:06:13.040
something close enough
to 3 that I'm happy.

00:06:13.040 --> 00:06:13.690
All right.

00:06:13.690 --> 00:06:18.260
I tried it on 2, I surely didn't
expect a precise and

00:06:18.260 --> 00:06:22.470
exact answer to that, but I
got something, and if you

00:06:22.470 --> 00:06:24.710
square this, you'll find
the answer kept pretty

00:06:24.710 --> 00:06:27.780
darn close to 2.

00:06:27.780 --> 00:06:34.250
I then tried it on
0.25 One quarter.

00:06:34.250 --> 00:06:39.990
And what happened was
not what I wanted.

00:06:39.990 --> 00:06:44.230
As you'll see, it crashed.

00:06:44.230 --> 00:06:50.460
It didn't really crash, it found
an assert statement.

00:06:50.460 --> 00:06:53.770
So if you look at the bottom
of the function, you'll see

00:06:53.770 --> 00:07:04.280
that, in fact, I checked
for that.

00:07:04.280 --> 00:07:08.220
I assert the counter is less
than or equal to 0.

00:07:08.220 --> 00:07:11.130
I'm checking that I didn't leave
my program because I

00:07:11.130 --> 00:07:14.460
didn't find an answer.

00:07:14.460 --> 00:07:16.570
Well, this is a good thing, it's
better than my program

00:07:16.570 --> 00:07:21.210
running forever, but it's a bad
thing because I don't have

00:07:21.210 --> 00:07:25.500
it the square root of 0.25.

00:07:25.500 --> 00:07:31.640
What went wrong here?

00:07:31.640 --> 00:07:33.450
Well, let's think about
it for a second.

00:07:33.450 --> 00:07:34.890
You look like-- someone
looks like they're

00:07:34.890 --> 00:07:36.060
dying to give an answer.

00:07:36.060 --> 00:07:37.990
No, you just scratching
your head?

00:07:37.990 --> 00:07:39.380
All right.

00:07:39.380 --> 00:07:44.070
Remember, I said when we do
a bisection method, we're

00:07:44.070 --> 00:07:46.890
assuming the answer lies
somewhere between the lower

00:07:46.890 --> 00:07:51.180
bound and the upper bound.

00:07:51.180 --> 00:07:56.560
Well, what is the square
root of a quarter?

00:07:56.560 --> 00:08:01.560
It is a half.

00:08:01.560 --> 00:08:06.130
Well, what-- where did
I tell my program

00:08:06.130 --> 00:08:08.060
to look for an answer?

00:08:08.060 --> 00:08:14.210
Between 0 and x.

00:08:14.210 --> 00:08:22.080
So the problem was, the answer
was over here somewhere, and

00:08:22.080 --> 00:08:25.940
so I'm never going to find it
cleverly searching in this

00:08:25.940 --> 00:08:28.960
region, right?

00:08:28.960 --> 00:08:34.120
So the basic idea was fine, but
I failed to satisfy the

00:08:34.120 --> 00:08:37.750
initial condition that the
answer had to be between the

00:08:37.750 --> 00:08:40.980
lower bound and the
upper bound.

00:08:40.980 --> 00:08:44.140
Right?

00:08:44.140 --> 00:08:45.510
And why did I do that?

00:08:45.510 --> 00:08:52.900
Because I forgot what happens
when you look at fractions.

00:08:52.900 --> 00:08:56.630
So what should I do?

00:08:56.630 --> 00:08:58.930
Actually I lied, by the way,
when I said the answer was

00:08:58.930 --> 00:08:59.830
over there.

00:08:59.830 --> 00:09:02.450
Where was the answer?

00:09:02.450 --> 00:09:05.360
Somebody?

00:09:05.360 --> 00:09:10.860
It was over here.

00:09:10.860 --> 00:09:15.920
Because the square root of a
quarter is not smaller than a

00:09:15.920 --> 00:09:18.430
quarter, it's bigger
than a quarter.

00:09:18.430 --> 00:09:18.750
Right?

00:09:18.750 --> 00:09:27.930
A half is strictly greater
than a quarter.

00:09:27.930 --> 00:09:29.730
So it wasn't on the region.

00:09:29.730 --> 00:09:31.170
So how-- what's the fix?

00:09:31.170 --> 00:09:33.410
Should be a pretty simple fix,
in fact we should be able to

00:09:33.410 --> 00:09:35.130
do it on the fly, here.

00:09:35.130 --> 00:09:40.550
What should I change?

00:09:40.550 --> 00:09:42.700
Do I need to change
the lower bound?

00:09:42.700 --> 00:09:45.860
Is the square root ever going
to be less than 0?

00:09:45.860 --> 00:09:49.580
Doesn't need to be, so, what
should I do about the upper

00:09:49.580 --> 00:09:52.580
bound here?

00:09:52.580 --> 00:09:56.060
Oh, I could cheat and make, OK,
the upper bound a half,

00:09:56.060 --> 00:09:58.970
but that wouldn't
be very honest.

00:09:58.970 --> 00:10:05.490
What would be a good
thing to do here?

00:10:05.490 --> 00:10:08.350
Pardon?

00:10:08.350 --> 00:10:13.030
I could square x, but maybe
I should just do something

00:10:13.030 --> 00:10:16.170
pretty simple here.

00:10:16.170 --> 00:10:19.000
Suppose-- whoops.

00:10:19.000 --> 00:10:35.620
Suppose I make it the
max of x and 1.

00:10:35.620 --> 00:10:38.220
Then if I'm looking for the
square root of something less

00:10:38.220 --> 00:10:44.660
than 1, I know it will be
in my region, right?

00:10:44.660 --> 00:10:47.370
All right, let's save
this, and run it

00:10:47.370 --> 00:11:04.370
and see what happens.

00:11:04.370 --> 00:11:08.840
Sure enough, it worked and, did
we get-- we got the right

00:11:08.840 --> 00:11:16.220
answer, 0.5 All right?

00:11:16.220 --> 00:11:19.830
And by the way, I checked
all of my previous ones,

00:11:19.830 --> 00:11:25.160
and they work too.

00:11:25.160 --> 00:11:25.630
All right.

00:11:25.630 --> 00:11:33.240
Any questions about
bisection search?

00:11:33.240 --> 00:11:37.710
One of the things I want you to
notice here is the number

00:11:37.710 --> 00:11:42.350
iterations is certainly
not constant.

00:11:42.350 --> 00:11:46.600
Yeah, when I will looked at 4,
it was a nice number like 1, 9

00:11:46.600 --> 00:11:54.250
looked like it took me 18, 2
took me 14, if we try some big

00:11:54.250 --> 00:12:00.240
numbers it might take
even longer.

00:12:00.240 --> 00:12:03.650
These numbers are small, but
sometimes when we look at

00:12:03.650 --> 00:12:08.900
really harder problems, we got
ourselves in a position where

00:12:08.900 --> 00:12:12.920
we do care about the number of
iterations, and we care about

00:12:12.920 --> 00:12:23.450
something called the speed
of convergence.

00:12:23.450 --> 00:12:27.790
Bisection methods were known to
the ancient Greeks, and it

00:12:27.790 --> 00:12:32.740
is believed by many, even
to the Babylonians.

00:12:32.740 --> 00:12:37.320
And as I mentioned last time,
this was the state of the art

00:12:37.320 --> 00:12:41.560
until the 17th century.

00:12:41.560 --> 00:12:45.530
At which point, things
got better.

00:12:45.530 --> 00:12:51.680
So, let's think about it, and
let's think about what we're

00:12:51.680 --> 00:12:54.160
actually doing when
we solve this.

00:12:54.160 --> 00:12:59.910
When we look for something like
the square root of x,

00:12:59.910 --> 00:13:06.690
what we're really doing,
is solving an equation.

00:13:06.690 --> 00:13:19.480
We're looking at the equation
f of guess equals the guess

00:13:19.480 --> 00:13:26.430
squared minus x.

00:13:26.430 --> 00:13:29.890
Right, that's what that is equal
to, and we're trying to

00:13:29.890 --> 00:13:39.600
solve the equation that
f of guess equals 0.

00:13:39.600 --> 00:13:45.320
Looking for the root
of this equation.

00:13:45.320 --> 00:13:54.870
So if we looked at it
pictorially, what we've got

00:13:54.870 --> 00:14:02.830
here is, we're looking at f of
x, I've plotted it here, and

00:14:02.830 --> 00:14:08.850
we're asking where it
crosses the x axis.

00:14:08.850 --> 00:14:12.610
Sorry for the overloading
of the word x.

00:14:12.610 --> 00:14:15.120
And I'm looking here at 16.

00:14:15.120 --> 00:14:20.290
Square root of 16, and my plot
basically shows it crosses at

00:14:20.290 --> 00:14:23.120
4 and-- well, I think
that's minus 4.

00:14:23.120 --> 00:14:28.650
The perspective is tricky--
and so we're

00:14:28.650 --> 00:14:32.120
trying to find the roots.

00:14:32.120 --> 00:14:37.630
Now Isaac Newton and/or Joseph
Raphson figured out how to do

00:14:37.630 --> 00:14:41.530
this kind of thing for all
differentiable functions.

00:14:41.530 --> 00:14:43.740
Don't worry about
what that means.

00:14:43.740 --> 00:14:50.130
The basic idea is, you take a
guess, and you -- whoops --

00:14:50.130 --> 00:14:56.540
and you find the tangent
of that guess.

00:14:56.540 --> 00:14:59.040
So let's say I guessed 3.

00:14:59.040 --> 00:15:04.290
I look for the tangent
of the curve at 3.

00:15:04.290 --> 00:15:07.700
All right, so I've got the
tangent, and then my next

00:15:07.700 --> 00:15:14.680
guess is going to be where the
tangent crosses the x axis.

00:15:14.680 --> 00:15:18.780
So instead of dividing it in
half, I'm using a different

00:15:18.780 --> 00:15:24.800
method to find the next guess.

00:15:24.800 --> 00:15:29.690
The utility of this relies upon
the observation that,

00:15:29.690 --> 00:15:34.050
most of the time-- and I want to
emphasize this, most of the

00:15:34.050 --> 00:15:40.830
time, that implies not all of
the time-- the tangent line is

00:15:40.830 --> 00:15:44.970
a good approximation
to the curve for

00:15:44.970 --> 00:15:51.240
values near the solution.

00:15:51.240 --> 00:15:56.820
And therefore, the x intercept
of the tangent will be closer

00:15:56.820 --> 00:16:01.020
to the right answer than
the current guess.

00:16:01.020 --> 00:16:04.520
Is that always true,
by the way?

00:16:04.520 --> 00:16:07.820
Show me a place where that's
not true, where the tangent

00:16:07.820 --> 00:16:12.370
line will be really bad.

00:16:12.370 --> 00:16:13.060
Yeah.

00:16:13.060 --> 00:16:17.050
Suppose I choose it right
down there, I guess 0.

00:16:17.050 --> 00:16:21.550
Well, the tangent there will not
even have an x intercept.

00:16:21.550 --> 00:16:24.920
So I'm really going to
be dead in the water.

00:16:24.920 --> 00:16:27.440
This is the sort of thing that
people who do numerical

00:16:27.440 --> 00:16:30.660
programming worry about
all the time.

00:16:30.660 --> 00:16:32.810
And there are a lot of a little
tricks they use to deal

00:16:32.810 --> 00:16:34.240
with that, they'll perturb
it a little

00:16:34.240 --> 00:16:36.380
bit, things like that.

00:16:36.380 --> 00:16:37.910
You should not, at
this point, be

00:16:37.910 --> 00:16:41.590
worrying about those things.

00:16:41.590 --> 00:16:45.230
This method, interestingly
enough, is actually the method

00:16:45.230 --> 00:16:48.350
used in most hand calculators.

00:16:48.350 --> 00:16:52.110
So if you've got a calculator
that has a square root button,

00:16:52.110 --> 00:16:53.890
it's actually in the calculator

00:16:53.890 --> 00:16:56.140
running Newton's method.

00:16:56.140 --> 00:16:58.050
Now I know you thought it was
going to do that thing you

00:16:58.050 --> 00:17:01.090
learned in high school for
finding square roots, which I

00:17:01.090 --> 00:17:03.860
never could quite understand,
but no.

00:17:03.860 --> 00:17:07.840
It uses Newton's method
to do it.

00:17:07.840 --> 00:17:11.280
So how do we find the intercept
of the tangent, the

00:17:11.280 --> 00:17:13.480
x intercept?

00:17:13.480 --> 00:17:17.940
Well this is where derivatives
come in.

00:17:17.940 --> 00:17:27.440
What we know is that the slope
of the tangent is given by the

00:17:27.440 --> 00:17:30.200
first derivative of the
function f at the

00:17:30.200 --> 00:17:31.940
point of the guess.

00:17:31.940 --> 00:17:36.090
So the slope of the guess
is the first derivative.

00:17:36.090 --> 00:17:36.570
Right.

00:17:36.570 --> 00:17:41.780
Which dy over dx.

00:17:41.780 --> 00:17:45.560
Change in y divided
by change in x.

00:17:45.560 --> 00:17:50.910
So we can use some algebra,
which I won't go through here,

00:17:50.910 --> 00:17:54.980
and what we would find is that
for square root, the

00:17:54.980 --> 00:18:05.630
derivative, written f prime of
the i'th guess is equal to two

00:18:05.630 --> 00:18:07.970
times the i'th guess.

00:18:07.970 --> 00:18:10.380
Well, should have left myself
a little more room, sorry

00:18:10.380 --> 00:18:15.570
about that.

00:18:15.570 --> 00:18:18.050
All right?

00:18:18.050 --> 00:18:20.190
You could work this out.

00:18:20.190 --> 00:18:20.950
Right?

00:18:20.950 --> 00:18:22.830
The derivative of the
square root is not

00:18:22.830 --> 00:18:26.570
a complicated thing.

00:18:26.570 --> 00:18:35.090
Therefore, and here's the key
thing we need to keep in mind,

00:18:35.090 --> 00:18:46.390
we'll know that we can choose
guess i plus 1 to be equal to

00:18:46.390 --> 00:18:53.900
the old guess, guess i, minus
whatever the value is of the

00:18:53.900 --> 00:19:03.060
new guess-- of the old rather,
the old guess-- divided by

00:19:03.060 --> 00:19:14.800
twice the old guess.

00:19:14.800 --> 00:19:17.870
All right, again this is
straightforward kind of

00:19:17.870 --> 00:19:20.400
algebraic manipulations
to get here.

00:19:20.400 --> 00:19:22.590
So let's look at an example.

00:19:22.590 --> 00:19:25.810
Suppose we start looking for
the square root of 16

00:19:25.810 --> 00:19:30.650
with the guess 3.

00:19:30.650 --> 00:19:37.660
What's the value of the
function f of 3?

00:19:37.660 --> 00:19:41.450
Well, it's going to be, we
looked at our function there,

00:19:41.450 --> 00:19:54.090
guess squared, 3 times 3 is 9 I
think, minus 16, that's what

00:19:54.090 --> 00:20:02.310
x is in this case, which
equals minus 7.

00:20:02.310 --> 00:20:13.310
That being the case, what's
my next guess?

00:20:13.310 --> 00:20:22.530
Well I start with my old guess,
3, minus f of my old

00:20:22.530 --> 00:20:33.770
guess, which is minus 7, divided
by twice my old guess,

00:20:33.770 --> 00:20:42.550
which is 6, minus the minus,
and I get as my new guess

00:20:42.550 --> 00:20:51.250
4.1666 or thereabouts.

00:20:51.250 --> 00:20:57.590
So you can see I've missed,
but I am closer.

00:20:57.590 --> 00:21:03.700
And then I would reiterate this
process using that as

00:21:03.700 --> 00:21:08.460
guess i, and do it again.

00:21:08.460 --> 00:21:12.960
One way to think about this
intuitively, if the derivative

00:21:12.960 --> 00:21:19.010
is very large, the function
is changing quickly, and

00:21:19.010 --> 00:21:21.080
therefore we want to
take small steps.

00:21:21.080 --> 00:21:23.520
All right.

00:21:23.520 --> 00:21:28.960
If the derivative is small, it's
not changing, maybe want

00:21:28.960 --> 00:21:31.630
to take a larger step,
but let's not worry

00:21:31.630 --> 00:21:34.100
about that, all right?

00:21:34.100 --> 00:21:37.310
Does this method work
all the time?

00:21:37.310 --> 00:21:42.880
Well, we already saw no, if my
initial guess is zero, I don't

00:21:42.880 --> 00:21:44.210
get anywhere.

00:21:44.210 --> 00:21:46.260
In fact, my program crashes
because I end up trying to

00:21:46.260 --> 00:21:49.730
divide by zero, a really
bad thing.

00:21:49.730 --> 00:21:53.620
Hint: if you implement Newton's
method, do not make

00:21:53.620 --> 00:21:57.030
your first guess zero.

00:21:57.030 --> 00:22:08.220
All right, so let's look
at the code for that.

00:22:08.220 --> 00:22:13.310
All right so-- yeah, how do I
get to the code for that?

00:22:13.310 --> 00:22:25.400
That's interesting.

00:22:25.400 --> 00:22:30.140
All right.

00:22:30.140 --> 00:22:32.110
So we have that square
root NR.

00:22:32.110 --> 00:22:36.620
NR for Newton Raphson.

00:22:36.620 --> 00:22:40.840
First thing I want you to
observe is its specification

00:22:40.840 --> 00:22:43.500
is identical to the
specification

00:22:43.500 --> 00:22:48.420
of square root bi.

00:22:48.420 --> 00:22:54.170
What that's telling me is that
if you're a user of this, you

00:22:54.170 --> 00:22:56.290
don't care how it's
implemented, you

00:22:56.290 --> 00:23:00.350
care what it does.

00:23:00.350 --> 00:23:03.600
And therefore, it's fine that
the specifications are

00:23:03.600 --> 00:23:06.820
identical, in fact it's a good
thing, so that means if

00:23:06.820 --> 00:23:09.330
someday Professor Grimson
invents something that's

00:23:09.330 --> 00:23:12.610
better than Newton Raphson, we
can all re-implement our

00:23:12.610 --> 00:23:16.030
square root functions and none
of the programs that use it

00:23:16.030 --> 00:23:18.270
will have to change,
as long as the

00:23:18.270 --> 00:23:24.000
specification is the same.

00:23:24.000 --> 00:23:28.150
All right, so, not much
to see about this.

00:23:28.150 --> 00:23:33.140
As I said, the specifications is
the same, same assertions,

00:23:33.140 --> 00:23:35.840
and the-- it's basically the
same program as the one we

00:23:35.840 --> 00:23:43.560
were just looking at, but I'm
starting with a different

00:23:43.560 --> 00:23:48.400
guess, in this case x over 2,
well I'm going to, couple of

00:23:48.400 --> 00:23:52.440
different guesses we can start
with, we can experiment with

00:23:52.440 --> 00:23:54.350
different guesses and see
whether we get the same

00:23:54.350 --> 00:23:57.920
answer, and in fact, if we did,
we would see we didn't

00:23:57.920 --> 00:24:02.590
get this, we got different
answers, but correct answers.

00:24:02.590 --> 00:24:09.710
Actually now, we'll just
comment that out.

00:24:09.710 --> 00:24:13.130
I'm going to compute the
difference, just as I did on

00:24:13.130 --> 00:24:17.440
the board, and off we'll go.

00:24:17.440 --> 00:24:18.360
All right.

00:24:18.360 --> 00:24:23.200
Now, let's try and compare
these things.

00:24:23.200 --> 00:24:30.890
And what we're going to look at
is another procedure, you

00:24:30.890 --> 00:24:33.610
have the code for these things
on your handout so we won't

00:24:33.610 --> 00:24:38.190
worry, don't need to show you
the code, but let's look at

00:24:38.190 --> 00:24:40.670
how we're going to test it.

00:24:40.670 --> 00:24:45.260
I'm doing a little trick by the
way, I'm using raw input

00:24:45.260 --> 00:24:49.930
in my function here, as a just
a way to stop the display.

00:24:49.930 --> 00:24:52.790
This way I can torture
you between tests

00:24:52.790 --> 00:24:54.550
by asking you questions.

00:24:54.550 --> 00:24:57.240
Making it stop.

00:24:57.240 --> 00:24:59.870
All right, so, we'll
try some things.

00:24:59.870 --> 00:25:06.240
We'll see what it does.

00:25:06.240 --> 00:25:09.910
Starting with that, well, let's
look at some of the

00:25:09.910 --> 00:25:12.590
things it will do.

00:25:12.590 --> 00:25:23.050
Yeah, I'll save it..

00:25:23.050 --> 00:25:34.560
It's a little bit annoying, but
it makes the font bigger.

00:25:34.560 --> 00:25:39.580
All right, so we've tested it,
and we haven't tested it yet,

00:25:39.580 --> 00:25:46.650
we have tested it but, we
haven't seen it, well, you

00:25:46.650 --> 00:25:47.310
know what I'm going to do?

00:25:47.310 --> 00:25:48.020
I'm going to tort--

00:25:48.020 --> 00:25:51.360
I'm going to make the font
smaller so we can see more.

00:25:51.360 --> 00:25:52.280
Sorry about this.

00:25:52.280 --> 00:26:04.100
Those of you in the back, feel
free to move forward.

00:26:04.100 --> 00:26:08.520
All right.

00:26:08.520 --> 00:26:12.410
So we've got it, now
let's test it.

00:26:12.410 --> 00:26:13.895
So we're going to do
here, we're going

00:26:13.895 --> 00:26:20.960
to run compare methods.

00:26:20.960 --> 00:26:32.860
Well we're seeing this famous
computers are no damn good.

00:26:32.860 --> 00:26:34.210
All right.

00:26:34.210 --> 00:26:37.760
So we're going to try it on 2,
and at least we'll notice for

00:26:37.760 --> 00:26:43.580
2, that the bisection method
took eight iterations, the

00:26:43.580 --> 00:26:46.730
Newton Raphson only took three,

00:26:46.730 --> 00:26:49.620
so it was more efficient.

00:26:49.620 --> 00:26:52.990
They came up with slightly
different answers, but both

00:26:52.990 --> 00:26:56.810
answers are within .01 which
is what I gave it here for

00:26:56.810 --> 00:26:59.890
epsilon, so we're OK.

00:26:59.890 --> 00:27:02.740
So even though they have
different answers, they both

00:27:02.740 --> 00:27:05.400
satisfy the same specification,

00:27:05.400 --> 00:27:09.630
so we have no problem.

00:27:09.630 --> 00:27:11.900
All right?

00:27:11.900 --> 00:27:17.020
Try it again, just for fun.

00:27:17.020 --> 00:27:21.510
I gave it here a different
epsilon, and you'll note, we

00:27:21.510 --> 00:27:26.940
get different answers.

00:27:26.940 --> 00:27:29.630
Again, that's OK.

00:27:29.630 --> 00:27:35.210
Notice here, when I asked for
a more precise answer,

00:27:35.210 --> 00:27:43.440
bisection took a lot more
iterations, but Newton Raphson

00:27:43.440 --> 00:27:47.480
took only one extra iteration to
get that extra precision in

00:27:47.480 --> 00:27:49.860
the answer.

00:27:49.860 --> 00:27:54.110
So we're sort of getting the
notion that Newton Raphson

00:27:54.110 --> 00:27:59.990
maybe is considerably better on
harder problems. Which, by

00:27:59.990 --> 00:28:03.080
the way, it is.

00:28:03.080 --> 00:28:08.630
We'll make it an even harder
problem, by making it looking

00:28:08.630 --> 00:28:13.370
an even smaller epsilon, and
again, what you'll see is,

00:28:13.370 --> 00:28:19.290
Newton Raphson just crept up by
one, didn't take it long,

00:28:19.290 --> 00:28:22.070
and got the better answer,
where bisection

00:28:22.070 --> 00:28:23.820
gets worse and worse.

00:28:23.820 --> 00:28:26.860
So as you can see, as we
escalate the problem

00:28:26.860 --> 00:28:30.720
difficulty, the difference
between the good method and

00:28:30.720 --> 00:28:33.290
the not quite as good
method gets bigger

00:28:33.290 --> 00:28:35.500
and bigger and bigger.

00:28:35.500 --> 00:28:38.470
That's an important observation,
and as we get to

00:28:38.470 --> 00:28:41.430
the part of the course, we
talk about computational

00:28:41.430 --> 00:28:45.930
complexity, you'll see that what
we really care about is

00:28:45.930 --> 00:28:49.850
not how efficient the program
is on easy problems, but how

00:28:49.850 --> 00:28:51.270
efficient it is on hard

00:28:51.270 --> 00:28:57.960
problems. All right.

00:28:57.960 --> 00:29:00.340
Look at another example.

00:29:00.340 --> 00:29:07.330
All right, here I gave it
a big number, 123456789.

00:29:07.330 --> 00:29:11.130
And again, I don't want to
bore you, but you can see

00:29:11.130 --> 00:29:19.760
what's going on here
with this trend.

00:29:19.760 --> 00:29:27.490
So here's an interesting
question.

00:29:27.490 --> 00:29:30.250
You may notice that it's always
printing out the same

00:29:30.250 --> 00:29:36.440
number of digits.

00:29:36.440 --> 00:29:39.140
Why should this be?

00:29:39.140 --> 00:29:48.480
If you look at it here,
what's going on?

00:29:48.480 --> 00:29:55.210
Something very peculiar
is happening here.

00:29:55.210 --> 00:30:04.760
We're looking at it, and we're
getting some funny answers.

00:30:04.760 --> 00:30:08.700
This gets back to what I talked
about before, about

00:30:08.700 --> 00:30:11.970
some of the precision of
floating point numbers.

00:30:11.970 --> 00:30:20.110
And the thing I'm trying to
drive home to you here is

00:30:20.110 --> 00:30:23.970
perhaps the most important
lesson we'll

00:30:23.970 --> 00:30:33.360
talk about all semester.

00:30:33.360 --> 00:30:49.130
Which is, answers
can be wrong.

00:30:49.130 --> 00:30:52.150
People tend to think, because
the computer says it's so, it

00:30:52.150 --> 00:30:53.180
must be so.

00:30:53.180 --> 00:30:58.640
That the computer is--
speaks for God.

00:30:58.640 --> 00:31:00.200
And therefore it's infallible.

00:31:00.200 --> 00:31:01.205
Maybe it speaks for the Pope.

00:31:01.205 --> 00:31:03.530
It speaks for something
that's infallible.

00:31:03.530 --> 00:31:06.520
But in fact, it is not.

00:31:06.520 --> 00:31:10.730
And so, something I find myself
repeating over and over

00:31:10.730 --> 00:31:15.780
again to myself, to my graduate
students, is, when

00:31:15.780 --> 00:31:19.820
you get an answer from the
computer, always ask yourself,

00:31:19.820 --> 00:31:21.660
why do I believe it?

00:31:21.660 --> 00:31:26.590
Do I think it's the
right answer?

00:31:26.590 --> 00:31:31.370
Because it isn't necessarily.

00:31:31.370 --> 00:31:34.860
So if we look at what we've got
here, we've got something

00:31:34.860 --> 00:31:36.890
rather peculiar, right?

00:31:36.890 --> 00:31:38.820
What's peculiar about what
this computer is now

00:31:38.820 --> 00:31:47.410
printing for us?

00:31:47.410 --> 00:31:50.370
Why should I be really
suspicious about what I see in

00:31:50.370 --> 00:31:51.120
the screen here?

00:31:51.120 --> 00:31:56.020
STUDENT: [INAUDIBLE]

00:31:56.020 --> 00:31:58.260
PROFESSOR JOHN GUTTAG: Well, not
only is it different, it's

00:31:58.260 --> 00:32:00.390
really different, right?

00:32:00.390 --> 00:32:02.710
If it were just a little bit
different, I could say, all

00:32:02.710 --> 00:32:05.960
right, I have a different
approximation.

00:32:05.960 --> 00:32:10.880
But when it's this different,
something is wrong.

00:32:10.880 --> 00:32:12.990
Right?

00:32:12.990 --> 00:32:17.320
We'll, later in the term when
we get to more detailed

00:32:17.320 --> 00:32:20.770
numerical things, look
at what's wrong.

00:32:20.770 --> 00:32:23.580
You can run into issues of
things like overflow,

00:32:23.580 --> 00:32:26.720
underflow, with floating point
numbers, and when you see a

00:32:26.720 --> 00:32:30.540
whole bunches of ones, it's
particularly a good time to be

00:32:30.540 --> 00:32:33.470
suspicious.

00:32:33.470 --> 00:32:39.170
Anyway the only point I'm making
here is, paranoia is a

00:32:39.170 --> 00:32:43.730
healthy human trait.

00:32:43.730 --> 00:32:44.920
All right.

00:32:44.920 --> 00:32:50.020
We can look at some other things
which will work better.

00:32:50.020 --> 00:32:52.460
And we'll now move on.

00:32:52.460 --> 00:32:53.450
OK.

00:32:53.450 --> 00:32:56.150
So we've looked at how to
solve square root we've,

00:32:56.150 --> 00:32:59.760
looked at two problems, I've
tried to instill in you this

00:32:59.760 --> 00:33:03.750
sense of paranoia which is so
valuable, and now we're going

00:33:03.750 --> 00:33:08.630
to pull back and return to
something much simpler than

00:33:08.630 --> 00:33:11.110
numbers, and that's Python.

00:33:11.110 --> 00:33:12.190
All right?

00:33:12.190 --> 00:33:13.090
Numbers are hard.

00:33:13.090 --> 00:33:16.250
That's why we teach whole
semesters worth of courses in

00:33:16.250 --> 00:33:17.890
number theory.

00:33:17.890 --> 00:33:24.000
Python it's easy, which is why
we do it in about four weeks.

00:33:24.000 --> 00:33:25.060
All right.

00:33:25.060 --> 00:33:34.630
I want to return to some
non-scalar types.

00:33:34.630 --> 00:33:39.110
So we've been looking, the last
couple of lectures, at

00:33:39.110 --> 00:33:43.070
floating point numbers
and integers.

00:33:43.070 --> 00:33:47.470
We've looked so far really
at two non-scalar types.

00:33:47.470 --> 00:34:02.620
And those were tuples written
with parentheses, and strings.

00:34:02.620 --> 00:34:05.490
The key thing about
both of them is

00:34:05.490 --> 00:34:11.340
that they were immutable.

00:34:11.340 --> 00:34:15.810
And I responded to at least one
email about this issue,

00:34:15.810 --> 00:34:20.030
someone quite correctly said
tuple are immutable, how can I

00:34:20.030 --> 00:34:21.750
change one?

00:34:21.750 --> 00:34:25.070
My answer is, you can't change
one, but you can create a new

00:34:25.070 --> 00:34:28.460
one that is almost like the
old one but different in a

00:34:28.460 --> 00:34:31.340
little bit.

00:34:31.340 --> 00:34:38.620
Well now we're going to talk
about some mutable types.

00:34:38.620 --> 00:34:42.580
Things you can change.

00:34:42.580 --> 00:34:46.450
And we're going to start with
one that you, many of you,

00:34:46.450 --> 00:34:48.500
have already bumped
into, perhaps by

00:34:48.500 --> 00:34:53.620
accident, which are lists.

00:34:53.620 --> 00:34:58.020
Lists differ from strings in two
ways; one way is that it's

00:34:58.020 --> 00:35:03.240
mutable, the other way is that
the values need not be

00:35:03.240 --> 00:35:05.620
characters.

00:35:05.620 --> 00:35:08.750
They can be numbers, they can
be characters, they can be

00:35:08.750 --> 00:35:13.560
strings, they can even
be other lists.

00:35:13.560 --> 00:35:18.930
So let's look at some
examples here.

00:35:18.930 --> 00:35:27.230
What we'll do, is we'll work
on two boards at once.

00:35:27.230 --> 00:35:36.060
So I could write a statement
like, techs, a variable, is

00:35:36.060 --> 00:35:39.320
equal to the list, written with
the square brace, not a

00:35:39.320 --> 00:35:55.700
parenthesis, MIT, Cal
Tech, closed brace.

00:35:55.700 --> 00:36:03.080
What that basically does, is it
takes the variable techs,

00:36:03.080 --> 00:36:15.590
and it now makes it point to a
list with two items in it.

00:36:15.590 --> 00:36:25.780
One is the string MIT and one
is the string Cal Tech.

00:36:25.780 --> 00:36:29.900
So let's look at it.

00:36:29.900 --> 00:36:37.750
And we'll now run another little
test program, show

00:36:37.750 --> 00:36:41.330
lists, and I printed it,
and it prints the

00:36:41.330 --> 00:36:49.200
list MIT, Cal Tech.

00:36:49.200 --> 00:36:55.310
Now suppose I introduce a new
variable, we'll call it ivys,

00:36:55.310 --> 00:37:07.270
and we say that is equal to the
list Harvard, Yale, Brown.

00:37:07.270 --> 00:37:11.110
Three of the ivy league
colleges.

00:37:11.110 --> 00:37:16.080
What that does is, I have a new
variable, ivys, and it's

00:37:16.080 --> 00:37:24.830
now pointing to another, what we
call object, in Python and

00:37:24.830 --> 00:37:28.090
Java, and many other languages,
think of these

00:37:28.090 --> 00:37:29.540
things that are sitting
there in memory

00:37:29.540 --> 00:37:31.970
somewhere as objects.

00:37:31.970 --> 00:37:34.730
And I won't write it all out,
I'll just write it's got

00:37:34.730 --> 00:37:39.930
Harvard as one in it, and
then it's got Yale, and

00:37:39.930 --> 00:37:43.400
then it's got Brown.

00:37:43.400 --> 00:37:49.520
And I can now print ivys.

00:37:49.520 --> 00:37:55.570
And it sure enough prints what
we expected it to print.

00:37:55.570 --> 00:38:03.390
Now, let's say I have univs, for
universities, equals the

00:38:03.390 --> 00:38:11.010
empty list. That would create
something over here called

00:38:11.010 --> 00:38:16.780
univs, another variable, and it
will point to the list, an

00:38:16.780 --> 00:38:19.590
object that contains
nothing in it.

00:38:19.590 --> 00:38:22.950
This is not the same as none.

00:38:22.950 --> 00:38:25.890
It's it does have a value, it
just happens to be the list

00:38:25.890 --> 00:38:29.480
that has nothing in it.

00:38:29.480 --> 00:38:33.440
And the next thing I'm
going to write is

00:38:33.440 --> 00:38:50.120
univs dot append tex.

00:38:50.120 --> 00:38:54.370
What is this going to do?

00:38:54.370 --> 00:39:03.570
It's going to take this list and
add to it something else.

00:39:03.570 --> 00:39:17.690
Let's look at the code.

00:39:17.690 --> 00:39:21.680
I'm going to print it, and
let's see what it prints.

00:39:21.680 --> 00:39:24.710
It's kind of interesting.

00:39:24.710 --> 00:39:25.290
Whoops.

00:39:25.290 --> 00:39:27.380
Why did it do that?

00:39:27.380 --> 00:39:36.640
That's not what I expected.

00:39:36.640 --> 00:39:37.620
It's going to print that.

00:39:37.620 --> 00:39:39.790
The reason it printed that is
I accidentally had my finger

00:39:39.790 --> 00:39:46.680
on the control key, which said
print the last thing you had.

00:39:46.680 --> 00:39:56.550
Why does it start with square
braced square brace?

00:39:56.550 --> 00:39:58.040
I take it-- yes, go ahead.

00:39:58.040 --> 00:40:01.320
STUDENT: So you're adding
a list to a list?

00:40:01.320 --> 00:40:04.040
PROFESSOR JOHN GUTTAG: So I'm
adding a list to a list. What

00:40:04.040 --> 00:40:10.650
have I-- what I've appended to
the empty list is not the

00:40:10.650 --> 00:40:15.850
elements MIT and Cal Tech
but the list that

00:40:15.850 --> 00:40:21.230
contains those elements.

00:40:21.230 --> 00:40:24.470
So I've appended this
whole object.

00:40:24.470 --> 00:40:28.920
Since that object is itself
a list, what I get

00:40:28.920 --> 00:40:37.190
is a list of lists.

00:40:37.190 --> 00:40:49.340
Now I should mention this
notation here append is what

00:40:49.340 --> 00:40:54.240
is in Python called a method.

00:40:54.240 --> 00:40:58.530
Now we'll hear lots more about
methods when we get to classes

00:40:58.530 --> 00:41:03.930
and inheritance, but really, a
method is just a fancy word

00:41:03.930 --> 00:41:08.670
for a function with
different syntax.

00:41:08.670 --> 00:41:13.670
Think of this as a function that
takes two arguments, the

00:41:13.670 --> 00:41:21.220
first of which is univs and the
second of which is techs.

00:41:21.220 --> 00:41:25.620
And this is just a different
syntax for writing that

00:41:25.620 --> 00:41:27.820
function call.

00:41:27.820 --> 00:41:33.400
Later in the term, we'll see
why we have this syntax and

00:41:33.400 --> 00:41:37.840
why it wasn't just a totally
arbitrary brain-dead decision

00:41:37.840 --> 00:41:41.620
by the designers of Python,
and many languages before

00:41:41.620 --> 00:41:45.970
Python, but in fact is a
pretty sensible thing.

00:41:45.970 --> 00:41:48.880
But for now, think of this as
just another way to write a

00:41:48.880 --> 00:41:54.210
function call.

00:41:54.210 --> 00:42:00.000
All right, people
with me so far?

00:42:00.000 --> 00:42:08.390
Now let's say we wanted as the
next thing we'll do, is we're

00:42:08.390 --> 00:42:15.810
going to append the ivys
to univ. Stick

00:42:15.810 --> 00:42:18.330
another list on it.

00:42:18.330 --> 00:42:20.800
All right.

00:42:20.800 --> 00:42:29.280
So we'll do that, and now we get
MIT, Cal Tech, followed by

00:42:29.280 --> 00:42:32.700
that list followed by the list
Harvard, Yale, Brown.

00:42:32.700 --> 00:42:41.760
So now we have a list containing
two lists.

00:42:41.760 --> 00:42:45.330
What are we going to try next?

00:42:45.330 --> 00:42:49.280
Well just to see what we know
what we're doing, let's look

00:42:49.280 --> 00:42:56.550
at this code here.

00:42:56.550 --> 00:42:59.800
I've written a little for
loop, which is going to

00:42:59.800 --> 00:43:03.970
iterate over all of the elements
in the list. So

00:43:03.970 --> 00:43:10.200
remember, before we wrote things
like for i in range 10,

00:43:10.200 --> 00:43:17.190
which iterated over a list or
tuple of numbers, here you can

00:43:17.190 --> 00:43:20.070
iterate over any list, and so
we're going to just going to

00:43:20.070 --> 00:43:26.250
take the list called univs
and iterate over it.

00:43:26.250 --> 00:43:30.090
So the first thing we'll do is,
we'll print the element,

00:43:30.090 --> 00:43:32.370
in this case it will
be a list, right?

00:43:32.370 --> 00:43:35.940
Because it's a list with
two lists in it.

00:43:35.940 --> 00:43:38.510
Then the next thing in the loop,
we're going to enter a

00:43:38.510 --> 00:43:46.050
nested loop, and say for every
college in the list e, we're

00:43:46.050 --> 00:43:51.390
going to print the name
of the college.

00:43:51.390 --> 00:43:59.790
So now if we look what we get--
do you not want to try

00:43:59.790 --> 00:44:07.330
and execute that?-- it'll
first print the list

00:44:07.330 --> 00:44:11.020
containing MIT and Cal Tech,
and then separately the

00:44:11.020 --> 00:44:14.990
strings MIT and Cal Tech, and
then the list containing

00:44:14.990 --> 00:44:18.560
Harvard, Yale, and Brown, and
then the strings Harvard,

00:44:18.560 --> 00:44:21.380
Yale, and Brown.

00:44:21.380 --> 00:44:25.220
So we're beginning to see this
is a pretty powerful notion,

00:44:25.220 --> 00:44:27.640
these lists, and that
we can do a lot of

00:44:27.640 --> 00:44:31.390
interesting things with them.

00:44:31.390 --> 00:44:37.640
Suppose I don't want all of this
structure, and I want to

00:44:37.640 --> 00:44:51.460
do what's called flattening the
list. Well I can do that

00:44:51.460 --> 00:44:56.560
by, instead of using the
method append, use the

00:44:56.560 --> 00:45:00.400
concatenation operator.

00:45:00.400 --> 00:45:06.300
So I can concatenate techs
plus ivys and assign that

00:45:06.300 --> 00:45:13.510
result to univs, and then when
I print it you'll notice I

00:45:13.510 --> 00:45:19.180
just get a list of
five strings.

00:45:19.180 --> 00:45:24.110
So plus and append do very
different things.

00:45:24.110 --> 00:45:30.440
Append sticks the list on the
end of the list, append

00:45:30.440 --> 00:45:32.930
flattens it, one level
of course.

00:45:32.930 --> 00:45:36.560
If I had lists of lists of
lists, then it would only take

00:45:36.560 --> 00:45:41.880
out the first level of it.

00:45:41.880 --> 00:45:45.150
OK, very quiet here.

00:45:45.150 --> 00:45:49.350
Any questions about
any of this?

00:45:49.350 --> 00:45:49.670
All right.

00:45:49.670 --> 00:45:53.790
Because we're about to get
to the hard part Sigh.

00:45:53.790 --> 00:45:54.290
All right.

00:45:54.290 --> 00:45:58.400
Let's look at the-- well,
suppose I want to, quite

00:45:58.400 --> 00:46:00.260
understandably, eliminate
Harvard.

00:46:00.260 --> 00:46:05.650
All right, I then get
down here, where I'm

00:46:05.650 --> 00:46:09.410
going to remove it.

00:46:09.410 --> 00:46:13.200
So this is again another method,
this is remove, takes

00:46:13.200 --> 00:46:16.700
two arguments, the first
is ivys, the second

00:46:16.700 --> 00:46:21.210
is the string Harvard.

00:46:21.210 --> 00:46:25.450
It's going to search through the
list until the first time

00:46:25.450 --> 00:46:39.030
it finds Harvard and then it's
going to yank it away.

00:46:39.030 --> 00:46:42.310
So what happened here?

00:46:42.310 --> 00:46:45.650
Did I jump to the wrong place?

00:46:45.650 --> 00:46:45.950
STUDENT: You hit two returns.

00:46:45.950 --> 00:46:46.533
PROFESSOR JOHN GUTTAG:
I hit two returns.

00:46:46.533 --> 00:46:46.590
Pardon?

00:46:46.590 --> 00:46:47.323
STUDENT: You hit two returns.

00:46:47.323 --> 00:46:47.950
One was at

00:46:47.950 --> 00:46:53.740
STUDENT: Pardo

00:46:53.740 --> 00:46:54.906
PROFESSOR JOHN GUTTAG:
This one.

00:46:54.906 --> 00:46:55.560
STUDENT: No, up one.

00:46:55.560 --> 00:46:56.770
PROFESSOR JOHN GUTTAG: Up one.

00:46:56.770 --> 00:46:57.120
STUDENT: Right.

00:46:57.120 --> 00:46:57.790
PROFESSOR JOHN GUTTAG: But
why is Harvard there?

00:46:57.790 --> 00:47:00.180
STUDENT: I'm sorry, I didn't
write it down.

00:47:00.180 --> 00:47:00.900
PROFESSOR JOHN GUTTAG: Let's
look at it again.

00:47:00.900 --> 00:47:04.110
All right, it's time to
interrupt the world, and we'll

00:47:04.110 --> 00:47:06.600
just type into the shell.

00:47:06.600 --> 00:47:16.040
Let's see what we get here.

00:47:16.040 --> 00:47:18.310
All right, so let's just see
what we got, we'll print

00:47:18.310 --> 00:47:22.070
univs. Nope, not defined.

00:47:22.070 --> 00:47:26.480
All right, well let's do a list
equals, and we'll put

00:47:26.480 --> 00:47:29.080
some interesting things in it,
we'll put a number in it,

00:47:29.080 --> 00:47:33.350
because we can put a number,
we'll put MIT in it, because

00:47:33.350 --> 00:47:38.830
we can put strings, we'll put
another number in it, 3.3,

00:47:38.830 --> 00:47:42.870
because we can put floating
points, we can put all sorts

00:47:42.870 --> 00:47:45.540
of things in this list. We can
put a list in the list again,

00:47:45.540 --> 00:47:47.920
as we've seen before.

00:47:47.920 --> 00:47:53.370
So let's put the list containing
the string a, and

00:47:53.370 --> 00:47:57.720
I'll print out, so now we see
something pretty interesting

00:47:57.720 --> 00:48:03.400
about a list, that we can mix up
all sorts of things in it,

00:48:03.400 --> 00:48:06.300
and that's OK.

00:48:06.300 --> 00:48:08.940
You'll notice I have the string
with the number 1, a

00:48:08.940 --> 00:48:12.750
string with MIT, and then it
just a plain old number, not a

00:48:12.750 --> 00:48:16.810
string, again it didn't quite
give me 3.3 for reasons we've

00:48:16.810 --> 00:48:21.050
talked before, and now
it in the list a.

00:48:21.050 --> 00:48:27.020
So, suppose I want to
remove something.

00:48:27.020 --> 00:48:32.530
What should we try and remove
from this list?

00:48:32.530 --> 00:48:37.100
Anybody want to vote?

00:48:37.100 --> 00:48:38.320
Pardon?

00:48:38.320 --> 00:48:42.590
All right, someone wants
to remove MIT.

00:48:42.590 --> 00:48:45.450
Sad but true.

00:48:45.450 --> 00:48:47.800
Now what do we get
if we print l?

00:48:47.800 --> 00:48:51.290
MIT is gone.

00:48:51.290 --> 00:48:54.900
How do I talk about the
different pieces of l?

00:48:54.900 --> 00:49:04.210
Well I can do this. l sub 0--
whoops-- will give me the

00:49:04.210 --> 00:49:09.580
first element of the list,
just as we could do with

00:49:09.580 --> 00:49:13.380
strings, and I can look at l
sub minus 1 to get the last

00:49:13.380 --> 00:49:17.070
element of the list, so I can
do all the strings, all the

00:49:17.070 --> 00:49:20.860
things that I could
do with strings.

00:49:20.860 --> 00:49:23.460
It's extremely powerful,
but what we

00:49:23.460 --> 00:49:29.760
haven't seen yet is mutation.

00:49:29.760 --> 00:49:32.730
Well, we have seen
mutation, right?

00:49:32.730 --> 00:49:36.960
Because notice that what remove
did, it was it actually

00:49:36.960 --> 00:49:42.650
changed the list. Didn't create
a new list. The old l

00:49:42.650 --> 00:49:47.360
is still there, but it's
different than it used to be.

00:49:47.360 --> 00:49:51.730
So this is very different from
what we did with slicing,

00:49:51.730 --> 00:49:54.250
where we got a new copy
of something.

00:49:54.250 --> 00:49:59.350
Here we took the old one
and we just changed it.

00:49:59.350 --> 00:50:05.150
On Thursday, we'll look at why
that allows you to do lots of

00:50:05.150 --> 00:50:10.170
things more conveniently than
you can do without mutation.

