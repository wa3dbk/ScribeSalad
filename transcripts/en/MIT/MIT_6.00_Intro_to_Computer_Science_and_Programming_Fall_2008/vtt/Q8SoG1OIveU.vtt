WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.990
OPERATOR: The following content
is provided under a

00:00:01.990 --> 00:00:03.830
Creative Commons license.

00:00:03.830 --> 00:00:06.840
Your support will help MIT
OpenCourseWare continue to

00:00:06.840 --> 00:00:10.510
offer high quality educational
resources for free.

00:00:10.510 --> 00:00:13.390
To make a donation or view
additional materials from

00:00:13.390 --> 00:00:17.490
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.490 --> 00:00:19.930
ocw.mit.edu.

00:00:19.930 --> 00:00:24.340
PROFESSOR: Last lecture we were
talking about classes,

00:00:24.340 --> 00:00:27.190
and object-oriented programming,
and we're going

00:00:27.190 --> 00:00:29.260
to come back to it today.

00:00:29.260 --> 00:00:31.260
I'm going to remind you, we were
talking about it because

00:00:31.260 --> 00:00:34.030
we suggested it is a really
powerful way of structuring

00:00:34.030 --> 00:00:36.270
systems, and that's really why
we want to use it, It's a very

00:00:36.270 --> 00:00:39.290
common way of structuring
systems. So today I'm going to

00:00:39.290 --> 00:00:42.810
pick up on a bunch of more
nuanced, or more complex if

00:00:42.810 --> 00:00:46.280
you like, ways of leveraging
the power of classes.

00:00:46.280 --> 00:00:48.150
But we're going to see a bunch
of examples that are going to

00:00:48.150 --> 00:00:48.600
give us a sense.

00:00:48.600 --> 00:00:50.250
I'm going to talk about
inheritance, we're going to

00:00:50.250 --> 00:00:53.350
talk about shadowing, we're
going to talk about iterators.

00:00:53.350 --> 00:00:56.340
But before get to it, I want to
start by just highlighting,

00:00:56.340 --> 00:00:58.740
sort of, what was the
point of classes?

00:00:58.740 --> 00:00:59.940
So I'll remind you.

00:00:59.940 --> 00:01:06.580
A class, I said, was basically
a template for an

00:01:06.580 --> 00:01:11.230
abstract data type.

00:01:11.230 --> 00:01:13.610
And this was really to drive
home this idea of modularity.

00:01:13.610 --> 00:01:15.910
I want the ability to say, I've
got a set of things that

00:01:15.910 --> 00:01:18.130
naturally belong together,
I'm going to cluster them

00:01:18.130 --> 00:01:20.790
together, I want to treat it
like it's a primitive, I want

00:01:20.790 --> 00:01:23.160
to treat it like it's a float
or an int or a string.

00:01:23.160 --> 00:01:25.380
Is this going to be a point
or a segment or something

00:01:25.380 --> 00:01:26.690
different like that.

00:01:26.690 --> 00:01:28.910
So it's really a way, as I
said, of just trying to

00:01:28.910 --> 00:01:30.110
cluster data together.

00:01:30.110 --> 00:01:39.000
And this is a notion of
modularity slash abstraction

00:01:39.000 --> 00:01:40.690
where I'm treating them
as primitives.

00:01:40.690 --> 00:01:45.000
But the second thing we talked
about is that we also have a

00:01:45.000 --> 00:01:47.860
set of methods, using the
special name method because

00:01:47.860 --> 00:01:48.680
we're talking classes.

00:01:48.680 --> 00:01:52.200
But basically functions that are
designed to deal with this

00:01:52.200 --> 00:01:53.280
data structure.

00:01:53.280 --> 00:01:55.030
We're trying to group those
together as well.

00:01:55.030 --> 00:02:00.450
So we cluster data
and methods.

00:02:00.450 --> 00:02:04.510
Second key thing we said was,
in the ideal case, which

00:02:04.510 --> 00:02:06.890
unfortunately Python isn't, but
we'll come back to that,

00:02:06.890 --> 00:02:10.460
in the ideal case, we would have
data hiding, and by data

00:02:10.460 --> 00:02:16.480
hiding, which is sort of a
version of encapsulation, what

00:02:16.480 --> 00:02:19.920
we meant was that you could
only get to the internal

00:02:19.920 --> 00:02:24.470
pieces of that data structure
through a proscribed method.

00:02:24.470 --> 00:02:26.170
Proscribed meaning it's
something I set up.

00:02:26.170 --> 00:02:35.220
So data hiding saying, you would
only access the parts

00:02:35.220 --> 00:02:39.120
through a method.

00:02:39.120 --> 00:02:47.470
And as we said, unfortunately
Python does not enforce this.

00:02:47.470 --> 00:02:50.710
Meaning that I could create one
of these data structures,

00:02:50.710 --> 00:02:52.710
ideally I'd have a method, that
I'm going to see some

00:02:52.710 --> 00:02:55.520
examples of that I used to get
the parts out, unfortunately

00:02:55.520 --> 00:03:00.000
in Python you could take the
name the instance dot some

00:03:00.000 --> 00:03:01.310
internal variable you'll
get it back.

00:03:01.310 --> 00:03:02.020
It is exposed.

00:03:02.020 --> 00:03:03.410
And this is actually just
not a good idea.

00:03:03.410 --> 00:03:06.550
So I suggested in my very bad
humor, that you practice

00:03:06.550 --> 00:03:09.550
computational hygiene and you
only use appropriate methods

00:03:09.550 --> 00:03:11.050
to get the parts out.

00:03:11.050 --> 00:03:12.890
OK didn't laugh the joke last
time, you're not going to

00:03:12.890 --> 00:03:14.950
laugh at it this time,
I don't blame you.

00:03:14.950 --> 00:03:18.390
All right, and then the last
piece of this is that we said

00:03:18.390 --> 00:03:20.470
the class is a template.

00:03:20.470 --> 00:03:23.470
When we call that class,
it makes an instance.

00:03:23.470 --> 00:03:31.170
So class is used to make
instances, meaning particular

00:03:31.170 --> 00:03:36.280
versions, of that structure,
and we said inside the

00:03:36.280 --> 00:03:39.570
instances we have a
set of attributes.

00:03:39.570 --> 00:03:42.680
Internal variables, methods,
that are going to belong to

00:03:42.680 --> 00:03:44.660
that structure.

00:03:44.660 --> 00:03:48.450
OK, so with that in mind, here's
what I want to do.

00:03:48.450 --> 00:03:51.790
I'm going to show you a set of
examples, and I want to warn

00:03:51.790 --> 00:03:53.780
you ahead of time, the code
handout today is a little

00:03:53.780 --> 00:03:55.940
longer than normal because we
want to build essentially an

00:03:55.940 --> 00:03:58.790
extended example of a sequence
of examples of classes.

00:03:58.790 --> 00:04:00.630
We're going to see the idea,
of which we're gonna talk

00:04:00.630 --> 00:04:03.080
about, of inheritance or
hierarchy, in which we can

00:04:03.080 --> 00:04:04.110
have classes that are

00:04:04.110 --> 00:04:06.510
specializations of other classes.

00:04:06.510 --> 00:04:08.770
We're gonna see how we can
inherit methods, how we can

00:04:08.770 --> 00:04:11.860
shadow methods, how we can use
methods in a variety of ways.

00:04:11.860 --> 00:04:13.980
So this is a way of suggesting
you may find it more

00:04:13.980 --> 00:04:16.890
convenient to put notes on the
code handout rather than in

00:04:16.890 --> 00:04:17.360
your own notes.

00:04:17.360 --> 00:04:19.160
Do whatever you like, but I
just wanted to alert you,

00:04:19.160 --> 00:04:22.410
we're going to go through a
little more code than normal.

00:04:22.410 --> 00:04:26.010
So, the little environment
I'm going to build is an

00:04:26.010 --> 00:04:27.300
environment of people.

00:04:27.300 --> 00:04:30.890
I'll build a simple little
simulation of people.

00:04:30.890 --> 00:04:33.350
So I'm going to start off with
the first class, which I've

00:04:33.350 --> 00:04:35.760
got up on the screen, and it's
on your handout as well, which

00:04:35.760 --> 00:04:38.960
is I'm going to build an
instance, or a class rather,

00:04:38.960 --> 00:04:42.050
of persons.

00:04:42.050 --> 00:04:44.920
I'm going to draw a diagram,
which I'm gonna try and see if

00:04:44.920 --> 00:04:48.750
I can do well, over here, of
the different objects we're

00:04:48.750 --> 00:04:55.670
going to have. So I've got, a
class, and by the way a class

00:04:55.670 --> 00:04:57.530
is an object.

00:04:57.530 --> 00:04:59.610
Instances are also objects,
but classes are objects.

00:04:59.610 --> 00:05:01.030
We're gonna see why we want
that in a second.

00:05:01.030 --> 00:05:02.815
Because I'm gonna build
an object, sorry a

00:05:02.815 --> 00:05:04.540
class, called a person.

00:05:04.540 --> 00:05:07.750
Now, let's walk through some
of the pieces here.

00:05:07.750 --> 00:05:10.970
The first one is, there's
something a little different.

00:05:10.970 --> 00:05:14.030
Remember last time we had that
keyword class and then a name,

00:05:14.030 --> 00:05:16.180
that name, in this case, person
says this is the name

00:05:16.180 --> 00:05:18.190
for the class, and then we
would have just had the

00:05:18.190 --> 00:05:21.210
semicolon and a bunch
of internal things.

00:05:21.210 --> 00:05:23.950
Here I've got something in
parens, and I want to stress

00:05:23.950 --> 00:05:26.570
this is not a variable.

00:05:26.570 --> 00:05:29.140
All right, this is not a
def, this is a class.

00:05:29.140 --> 00:05:31.460
I'm going to come back to it,
but what this is basically

00:05:31.460 --> 00:05:36.800
saying is that the person class
is going to inherit from

00:05:36.800 --> 00:05:39.920
another class, which in this
case is just the built-in

00:05:39.920 --> 00:05:42.260
Python object class.

00:05:42.260 --> 00:05:44.070
Hold on to that thought, it's
going to make more sense when

00:05:44.070 --> 00:05:45.850
we look at a little more
interesting example, but I

00:05:45.850 --> 00:05:46.700
want to highlight that.

00:05:46.700 --> 00:05:51.120
All right now, if we do this,
as I said before, we can

00:05:51.120 --> 00:05:52.900
create a version of a
person, let me just

00:05:52.900 --> 00:06:00.330
call it per, person.

00:06:00.330 --> 00:06:00.860
OK?

00:06:00.860 --> 00:06:03.440
And what we said last time is,
when we wanted to create an

00:06:03.440 --> 00:06:06.840
instance inside of this class
definition, we've got one of

00:06:06.840 --> 00:06:08.870
those built-in things
called init.

00:06:08.870 --> 00:06:14.820
I'm gonna again remind you, some
of the methods we have,

00:06:14.820 --> 00:06:19.140
Underbar underbar init is going
to be the thing that

00:06:19.140 --> 00:06:23.770
creates the instance.

00:06:23.770 --> 00:06:26.195
Actually slightly misspeaking,
actually Python creates the

00:06:26.195 --> 00:06:28.210
instance, but it's one thing
that fills it in.

00:06:28.210 --> 00:06:34.770
So in this case, I'm going to
give it 2 arguments: Frank

00:06:34.770 --> 00:06:41.500
Foobar Now, you might have said,
wait a minute, init here

00:06:41.500 --> 00:06:44.400
has 3 arguments: self, family
name, and first name.

00:06:44.400 --> 00:06:48.300
So again, just to remind you,
what we said happens here is

00:06:48.300 --> 00:06:53.440
that when I call this
class, person,

00:06:53.440 --> 00:06:54.770
I'm creating an instance.

00:06:54.770 --> 00:06:57.890
We'll draw a little instance
diagram down here.

00:06:57.890 --> 00:06:59.620
I'm going to give
it the name per.

00:06:59.620 --> 00:07:01.590
And I should have said inside
of person, we've

00:07:01.590 --> 00:07:02.580
got a set of things.

00:07:02.580 --> 00:07:07.720
We've got our underbar underbar
init, we've got, what

00:07:07.720 --> 00:07:08.510
else do I have up there?

00:07:08.510 --> 00:07:13.340
Family name.

00:07:13.340 --> 00:07:17.470
And a bunch of other methods,
down to say.

00:07:17.470 --> 00:07:20.420
What happens inside of Python
is, when we called the class

00:07:20.420 --> 00:07:25.010
definition, person, it creates
an instance, there it is.

00:07:25.010 --> 00:07:28.990
Think of it as a pointer to a
spot in memory, and then what

00:07:28.990 --> 00:07:35.320
we do is, we call, or find, that
init method, up here, and

00:07:35.320 --> 00:07:36.830
we apply it.

00:07:36.830 --> 00:07:40.660
And the first argument self,
points to the instance.

00:07:40.660 --> 00:07:46.940
So this object here is
what self looks at.

00:07:46.940 --> 00:07:48.360
Now you can see what
init's going to do.

00:07:48.360 --> 00:07:51.980
It says, oh, inside of self,
which is pointing to here, let

00:07:51.980 --> 00:07:59.290
me bind a variable, which was,
can read that very carefully,

00:07:59.290 --> 00:08:04.250
it's family underbar name,
to the value I passed

00:08:04.250 --> 00:08:08.820
in, which was 4.

00:08:08.820 --> 00:08:11.240
Same thing with first name.

00:08:11.240 --> 00:08:14.370
OK, so the reason I'm stressing
this is, self we do

00:08:14.370 --> 00:08:17.430
not supply explicitly, it is
supplied as pointing to the

00:08:17.430 --> 00:08:19.690
instance, it's giving us
that piece of memory.

00:08:19.690 --> 00:08:20.920
And that is what then
gets created.

00:08:20.920 --> 00:08:26.230
So here's, now, the
instance for per.

00:08:26.230 --> 00:08:28.260
OK, and I put a little label
on there, I'm going to call

00:08:28.260 --> 00:08:33.040
that an isALink, because it is
an instance of that class.

00:08:33.040 --> 00:08:33.630
God bless you.

00:08:33.630 --> 00:08:36.990
All right, so once we got this,
let's look at what we

00:08:36.990 --> 00:08:38.540
can do with person.

00:08:38.540 --> 00:08:41.250
That's why I built
person here.

00:08:41.250 --> 00:08:43.790
And as I said, I've
already bound

00:08:43.790 --> 00:08:45.540
basically, those two pieces.

00:08:45.540 --> 00:08:53.860
If I want to get a value out,
I can give person, or per,

00:08:53.860 --> 00:08:56.680
rather, this instance,
a messaging.

00:08:56.680 --> 00:08:59.100
In this case I want to get
family, what did I say, family

00:08:59.100 --> 00:09:05.240
name out, now, again I want to
stress, what is happening

00:09:05.240 --> 00:09:09.490
here? per is an instance,
it's this thing here.

00:09:09.490 --> 00:09:12.280
When I say per dot family
name, I'm sending it a

00:09:12.280 --> 00:09:14.930
message, in essence what that
does is, it says, from here

00:09:14.930 --> 00:09:19.810
it's going to go up the chain to
this class object and find

00:09:19.810 --> 00:09:23.390
the appropriate method,
which was family name.

00:09:23.390 --> 00:09:25.950
It is then going to apply
that to self, which

00:09:25.950 --> 00:09:27.890
points to this instance.

00:09:27.890 --> 00:09:30.510
And that allows it, therefore,
is you can see on the code, to

00:09:30.510 --> 00:09:33.690
look up under self, what's the
binding for family name, and

00:09:33.690 --> 00:09:35.480
print it back up.

00:09:35.480 --> 00:09:37.750
So self is always going to point
to the instance I want

00:09:37.750 --> 00:09:39.910
and I can use it.

00:09:39.910 --> 00:09:41.250
OK what else do we
have in here?

00:09:41.250 --> 00:09:42.980
We can get the first name,
that's not particularly

00:09:42.980 --> 00:09:43.380
interesting.

00:09:43.380 --> 00:09:51.040
We've got 2 other special
methods: that's cmp and str.

00:09:51.040 --> 00:09:57.830
All right, cmp is our
comparison method.

00:09:57.830 --> 00:10:01.140
And since I, I was about to
say I blew it last time, I

00:10:01.140 --> 00:10:03.090
misspoke last time, a wonderful
phrase that

00:10:03.090 --> 00:10:05.530
politicians like to use,
I misspoke last time.

00:10:05.530 --> 00:10:07.580
Let me clarify again
what cmp will do.

00:10:07.580 --> 00:10:11.160
Underbar underbar cmp is going
to be the method you're going

00:10:11.160 --> 00:10:16.540
to use to compare two instances
of an object.

00:10:16.540 --> 00:10:17.890
Now, let's back up for second.

00:10:17.890 --> 00:10:20.750
If I wanted to test equality,
in fact I could use underbar

00:10:20.750 --> 00:10:23.400
underbar eq, under under.

00:10:23.400 --> 00:10:26.170
It's natural to think about an
equality tester as returning a

00:10:26.170 --> 00:10:28.300
Boolean, it's either gonna
be true or false, because

00:10:28.300 --> 00:10:31.040
something's either
equal to or not.

00:10:31.040 --> 00:10:34.920
In many languages, comparisons
also return Booleans, which is

00:10:34.920 --> 00:10:37.590
why I went down this
slippery slope.

00:10:37.590 --> 00:10:39.970
For many languages, either it's
greater than or it's not.

00:10:39.970 --> 00:10:41.590
But Python is different.

00:10:41.590 --> 00:10:44.820
Python use cmp, in fact it has
a built in cmp, which is what

00:10:44.820 --> 00:10:47.270
we're relying on here.

00:10:47.270 --> 00:10:48.650
Where am I, right there.

00:10:48.650 --> 00:10:52.300
And what cmp returns
is 1 of 3 values.

00:10:52.300 --> 00:10:56.590
Given 2 objects, it says if the
first one is less than the

00:10:56.590 --> 00:11:00.150
second one, it returns -1, if
it's equal it returns 0, if

00:11:00.150 --> 00:11:01.840
it's greater than,
it returns 1.

00:11:01.840 --> 00:11:05.650
So it allows you this broader
range of comparisons.

00:11:05.650 --> 00:11:07.480
And if you think about it,
cmp, you could apply on

00:11:07.480 --> 00:11:08.820
integers, you could apply it on

00:11:08.820 --> 00:11:10.460
floats, apply it on strings.

00:11:10.460 --> 00:11:13.260
So it's overloaded, it has the
ability to do all of those.

00:11:13.260 --> 00:11:16.120
And in this case what we're
saying is, given 2 objects,

00:11:16.120 --> 00:11:20.590
let's create a tuple of the
first, sorry, family and first

00:11:20.590 --> 00:11:24.825
name of ourselves, and other is
another object, family and

00:11:24.825 --> 00:11:27.540
first name of that, and then
just use cmp to compare them.

00:11:27.540 --> 00:11:30.280
All right, so it's going
to use the base pieces.

00:11:30.280 --> 00:11:33.690
OK, so it gives me a way
of doing comparisons.

00:11:33.690 --> 00:11:37.180
And str we saw last time as
well, this is cmp does

00:11:37.180 --> 00:11:47.510
comparison, and str is our
printed representation.

00:11:47.510 --> 00:11:49.830
OK.

00:11:49.830 --> 00:11:54.460
So what we've got now, is
a simple little class.

00:11:54.460 --> 00:11:55.500
We've also got two
methods there.

00:11:55.500 --> 00:11:57.620
I want to look at them, we're
gonna come back to them, but

00:11:57.620 --> 00:12:02.110
they start to highlight things
we can do with our classes.

00:12:02.110 --> 00:12:03.470
So I've built one simple
version of it

00:12:03.470 --> 00:12:04.250
here, which is per.

00:12:04.250 --> 00:12:07.010
And notice I've got another
method, right up

00:12:07.010 --> 00:12:08.510
here, called say.

00:12:08.510 --> 00:12:12.620
And say takes two arguments,
for the moment the second

00:12:12.620 --> 00:12:14.160
argument, or the first
argument's, not going to make

00:12:14.160 --> 00:12:17.170
a lot of sense, but say takes
two arguments besides itself.

00:12:17.170 --> 00:12:19.500
It's going to take another
object to which it's saying

00:12:19.500 --> 00:12:22.380
something and the
thing to say.

00:12:22.380 --> 00:12:24.630
Since I only have one object
here, I'm going to have person

00:12:24.630 --> 00:12:25.520
talk to himself.

00:12:25.520 --> 00:12:27.000
You may have met a few
other undergraduates

00:12:27.000 --> 00:12:28.790
who have this behavior.

00:12:28.790 --> 00:12:37.160
I'll have him talk to himself
and say, just some random

00:12:37.160 --> 00:12:40.840
message the faculty members
occasionally worry about.

00:12:40.840 --> 00:12:43.210
OK, what does this thing do?

00:12:43.210 --> 00:12:45.410
Now you're going to see some
of the power of this.

00:12:45.410 --> 00:12:47.680
Again, remember, I'm down here,
I'm sending this the

00:12:47.680 --> 00:12:50.720
message say, it's going to go
up the chain to find the say

00:12:50.720 --> 00:12:51.550
message in person.

00:12:51.550 --> 00:12:54.890
And what does say do, it says
given another object and some

00:12:54.890 --> 00:12:58.990
string, it's going to return,
oh, and interesting things,

00:12:58.990 --> 00:13:00.860
part of which you can't
see on the screen.

00:13:00.860 --> 00:13:04.470
First what it does, is it
gets first name of self.

00:13:04.470 --> 00:13:07.340
Remember self is pointing to
this instance, so it's simply

00:13:07.340 --> 00:13:10.530
looks up that binding,
which is Frank.

00:13:10.530 --> 00:13:12.690
It's going to create a string
in which it adds to that the

00:13:12.690 --> 00:13:16.640
family name of self, and then
another thing that says to,

00:13:16.640 --> 00:13:21.580
and then ah, I'm now going to
send a message to the other

00:13:21.580 --> 00:13:25.070
object, saying give me
your first name.

00:13:25.070 --> 00:13:26.760
Going to add that to the second
piece, and you can see

00:13:26.760 --> 00:13:28.280
in this case it happens
to be the same

00:13:28.280 --> 00:13:29.630
first and family name.

00:13:29.630 --> 00:13:31.420
And then at the end of it, which
you can't see here but

00:13:31.420 --> 00:13:33.440
you can see in your handout, I
just append the whole string,

00:13:33.440 --> 00:13:35.760
so it spits it out.

00:13:35.760 --> 00:13:37.250
What's the point of this,
other than I can

00:13:37.250 --> 00:13:38.060
get it to say things?

00:13:38.060 --> 00:13:41.860
Notice, I can now reference
values of the instance.

00:13:41.860 --> 00:13:45.720
But I can also get values
of other instances, by

00:13:45.720 --> 00:13:46.710
sending in a message.

00:13:46.710 --> 00:13:51.640
And that's why we have that
form right there.

00:13:51.640 --> 00:13:54.850
And then it glued
all together.

00:13:54.850 --> 00:13:56.870
If you think about this for a
second, you might say, wait a

00:13:56.870 --> 00:13:58.920
minute, actually you might
have said wait a minute a

00:13:58.920 --> 00:14:02.180
while ago, why am I just using
the variable name there in the

00:14:02.180 --> 00:14:04.090
function over here?

00:14:04.090 --> 00:14:07.760
Well in fact, I could've used
the function here, first name

00:14:07.760 --> 00:14:09.230
open close, right?

00:14:09.230 --> 00:14:10.880
It would have done
the same thing.

00:14:10.880 --> 00:14:15.030
But because I know I'm inside
the instance, it's perfectly

00:14:15.030 --> 00:14:18.460
reasonable to just look
up the value.

00:14:18.460 --> 00:14:21.770
OK, I could have, although I
don't want you to do it, have

00:14:21.770 --> 00:14:24.690
done the same thing there and
used underbar, sorry, first

00:14:24.690 --> 00:14:28.340
name underbar, sorry, first
underbar name, but that's

00:14:28.340 --> 00:14:30.560
really breaking this contract
that I want to happen.

00:14:30.560 --> 00:14:33.800
I should send the message to
get the method back out.

00:14:33.800 --> 00:14:35.650
So again the standard practices
is if you know

00:14:35.650 --> 00:14:38.010
you're inside the object, you
can just access the values.

00:14:38.010 --> 00:14:40.140
If you're doing it with any
other objects, send it a

00:14:40.140 --> 00:14:42.460
message to get it out.

00:14:42.460 --> 00:14:47.190
OK, now, that gives you an
ability to say, let's look at

00:14:47.190 --> 00:14:48.710
one more example here, and
then we're going to start

00:14:48.710 --> 00:14:50.570
building our hierarchy,
which is, that this

00:14:50.570 --> 00:14:53.140
person can also sing.

00:14:53.140 --> 00:14:54.280
And we've got a little
sing method here.

00:14:54.280 --> 00:14:57.730
And notice what it does, it's
going to sing to somebody, I

00:14:57.730 --> 00:14:59.410
guess you're part of
the Chorallaries.

00:14:59.410 --> 00:15:01.860
You're going to sing something,
and notice what it

00:15:01.860 --> 00:15:06.100
does, it's simply going to use
its say method, but add at the

00:15:06.100 --> 00:15:09.880
end of whatever's being said,
just tra la la at the end.

00:15:09.880 --> 00:15:14.190
So this is now an example of a
method using another method.

00:15:14.190 --> 00:15:16.220
Why would you want that?

00:15:16.220 --> 00:15:17.700
It's nice modularly.

00:15:17.700 --> 00:15:20.260
I have one method that's doing
saying, I have another method

00:15:20.260 --> 00:15:21.260
that's just building on it.

00:15:21.260 --> 00:15:27.200
So if I have is person sing to
themselves, not a highly

00:15:27.200 --> 00:15:36.130
recommended activity, it would
help if I had it sing to

00:15:36.130 --> 00:15:45.840
itself, not sing to sing,
sorry about that.

00:15:45.840 --> 00:15:47.220
Notice what it does.

00:15:47.220 --> 00:15:50.180
Looks like exactly like a say
method, except it's got tra la

00:15:50.180 --> 00:15:51.640
la at the end.

00:15:51.640 --> 00:15:53.570
Don't worry I'm not going
to sing to you.

00:15:53.570 --> 00:15:56.240
I'll simply say the words.

00:15:56.240 --> 00:15:58.870
Power of this, other than
the silly examples.

00:15:58.870 --> 00:16:01.950
You see how I can access
variables of the instance, how

00:16:01.950 --> 00:16:04.910
I can access variables of other
instances, going to come

00:16:04.910 --> 00:16:10.530
back to that, and how I can use
versions of my own methods

00:16:10.530 --> 00:16:11.710
to implement other methods.

00:16:11.710 --> 00:16:14.680
In this case sing is using
say as part of what it

00:16:14.680 --> 00:16:17.210
wants to get out.

00:16:17.210 --> 00:16:20.350
OK, so we got a simple
little example.

00:16:20.350 --> 00:16:25.380
Now, let's start adding some
other pieces to this.

00:16:25.380 --> 00:16:28.040
OK, and what do I want to add.

00:16:28.040 --> 00:16:29.040
Find my spot here.

00:16:29.040 --> 00:16:37.840
OK, we're going to add
an MIT person.

00:16:37.840 --> 00:16:46.550
Sorry, machine is -- do
this, let's go down.

00:16:46.550 --> 00:16:49.850
OK so I'm going to add
an MIT person.

00:16:49.850 --> 00:16:51.620
Look at the code for second.

00:16:51.620 --> 00:16:52.130
Aha!

00:16:52.130 --> 00:16:53.010
Notice what this says.

00:16:53.010 --> 00:17:09.040
MIT person says it inherits
from person.

00:17:09.040 --> 00:17:10.630
That is, that's the first thing
in parens up there.

00:17:10.630 --> 00:17:13.580
It says, you know, class of
MIT person is person.

00:17:13.580 --> 00:17:18.190
What that is saying is, that
this is a specialization of

00:17:18.190 --> 00:17:18.960
the person class.

00:17:18.960 --> 00:17:25.310
Or another way of saying it is,
we have a super class, in

00:17:25.310 --> 00:17:27.870
this case it's person.

00:17:27.870 --> 00:17:35.550
And we have a subclass, in
this case its MIT person.

00:17:35.550 --> 00:17:37.080
And we're going to walk through
some examples, but

00:17:37.080 --> 00:17:40.230
what it says is that that
subclass of MIT person can

00:17:40.230 --> 00:17:44.320
inherit the attributes
of the person class.

00:17:44.320 --> 00:17:47.810
Can inherit the methods, it
can inherit variables.

00:17:47.810 --> 00:17:49.370
OK, what does MIT person do?

00:17:49.370 --> 00:17:50.760
Well, here's 1 of the
new things it does.

00:17:50.760 --> 00:17:58.990
It has a local variable called
next id num, which is

00:17:58.990 --> 00:18:00.490
initially set to 0.

00:18:00.490 --> 00:18:01.680
See that up there.

00:18:01.680 --> 00:18:03.470
And then it's got some methods,
it's got an init

00:18:03.470 --> 00:18:08.740
method, a get id method,
a few other things.

00:18:08.740 --> 00:18:11.370
OK, let's run this.

00:18:11.370 --> 00:18:19.050
In particular, I go back
down to this one.

00:18:19.050 --> 00:18:23.850
Let me just uncomment
this and do it here.

00:18:23.850 --> 00:18:26.400
Assuming my machine will do what
I want it to do, which it

00:18:26.400 --> 00:18:31.370
really doesn't seem to
want to do today.

00:18:31.370 --> 00:18:37.310
Try one more time.

00:18:37.310 --> 00:18:40.180
Thank you, yep.

00:18:40.180 --> 00:18:44.020
Still not doing it
for me, John.

00:18:44.020 --> 00:18:45.400
OK, we type it.

00:18:45.400 --> 00:18:47.760
No idea what Python doesn't like
me today, but it doesn't.

00:18:47.760 --> 00:18:56.800
So we're gonna define p 1, I've
lost my keyboard, indeed

00:18:56.800 --> 00:19:00.940
I have. Try one more time. p 1
MIT person, see how fast I can

00:19:00.940 --> 00:19:12.800
type here --

00:19:12.800 --> 00:19:15.500
OK, now, let's look at what the
code does, because again

00:19:15.500 --> 00:19:18.090
it's going to highlight
some things.

00:19:18.090 --> 00:19:22.150
I called MIT person, push this
up slightly, it's going to

00:19:22.150 --> 00:19:27.180
create an instance down
here, I called p 1.

00:19:27.180 --> 00:19:29.570
And when I would do that,
I'm gonna initialize it.

00:19:29.570 --> 00:19:36.350
So I've got, right up here, an
initializer, init for MIT

00:19:36.350 --> 00:19:40.000
person, takes in the family
name and the first name.

00:19:40.000 --> 00:19:42.050
Notice what it does.

00:19:42.050 --> 00:19:43.070
Huh.

00:19:43.070 --> 00:19:46.780
It says, if I'm sitting here at
MIT person, I'm going to go

00:19:46.780 --> 00:19:52.590
up and inherit from person its
init function and call it.

00:19:52.590 --> 00:19:53.540
And what am I calling it on?

00:19:53.540 --> 00:19:56.200
I'm calling it on self, which is
pointing to this object, so

00:19:56.200 --> 00:19:59.430
I've still got it, and then I'm
then going to apply the

00:19:59.430 --> 00:20:01.500
base initialization.

00:20:01.500 --> 00:20:03.400
And that does exactly what you'd
expect, which is just

00:20:03.400 --> 00:20:08.680
going to create a binding for
family name down here.

00:20:08.680 --> 00:20:10.440
As well as some other things.

00:20:10.440 --> 00:20:18.060
So this is an example
of inheritance.

00:20:18.060 --> 00:20:23.250
MIT person inherits the init
method from person, can get

00:20:23.250 --> 00:20:25.210
access to by simply referring
to it, and I

00:20:25.210 --> 00:20:26.700
refer to it right there.

00:20:26.700 --> 00:20:29.790
And it's take the person class,
get its init and apply

00:20:29.790 --> 00:20:32.460
it to my instance plus
those things.

00:20:32.460 --> 00:20:34.670
So I'm just using the
same piece of code

00:20:34.670 --> 00:20:35.890
Notice the second
thing it does.

00:20:35.890 --> 00:20:39.060
It says inside of self, I'm
going to bind the local

00:20:39.060 --> 00:20:43.580
variable id name to the value of
next id name in MIT person.

00:20:43.580 --> 00:20:47.410
Self is down here, id num,
sorry, not id name.

00:20:47.410 --> 00:20:51.150
I'm going to bind that to the
value that I find my going up

00:20:51.150 --> 00:20:56.670
to here, which is 0, and having
done that, I simply

00:20:56.670 --> 00:21:03.850
increment that value.

00:21:03.850 --> 00:21:05.660
OK?

00:21:05.660 --> 00:21:06.530
So what has this done?

00:21:06.530 --> 00:21:10.110
It says I now have captured in
the class, a local variable

00:21:10.110 --> 00:21:11.710
that I can keep track of.

00:21:11.710 --> 00:21:14.720
And when I use it, every time I
generate an example, let me

00:21:14.720 --> 00:21:16.140
build another one.

00:21:16.140 --> 00:21:33.460
I make p 2 another MIT person.

00:21:33.460 --> 00:21:37.180
OK, I can do things like saying,
what is the id number

00:21:37.180 --> 00:21:43.030
for each of these.

00:21:43.030 --> 00:21:52.320
First one is 0, second one is
1, which makes sense, right?

00:21:52.320 --> 00:21:54.850
I'm just incrementing
a global variable.

00:21:54.850 --> 00:21:57.420
Now, things I want you
to see about this.

00:21:57.420 --> 00:22:00.990
Now that I've got a beginning
of a hierarchy, I have this

00:22:00.990 --> 00:22:02.660
notion of inheritance.

00:22:02.660 --> 00:22:07.220
I can ask a function inside one
class to use a function

00:22:07.220 --> 00:22:09.990
from a class that it can reach
by going up the chain.

00:22:09.990 --> 00:22:10.670
I just did it there.

00:22:10.670 --> 00:22:14.720
I can ask it to go get values
of variables, right, so that

00:22:14.720 --> 00:22:15.130
looks good.

00:22:15.130 --> 00:22:17.070
What else do we have in
person or MIT person?

00:22:17.070 --> 00:22:18.470
Well, we can get the id
number, we just did.

00:22:18.470 --> 00:22:20.390
We have a thing to do
with this string.

00:22:20.390 --> 00:22:22.360
Notice it's going to print out
something a little different.

00:22:22.360 --> 00:22:24.660
In fact, there's a kind
of funky form there.

00:22:24.660 --> 00:22:26.560
Which just says, if I want to
print it out, I'm gonna

00:22:26.560 --> 00:22:29.930
create, what this says to do is,
I'm gonna create an output

00:22:29.930 --> 00:22:32.940
template that has that structure
to it, but where I

00:22:32.940 --> 00:22:36.500
see that percent s I'm going to
substitute this value for

00:22:36.500 --> 00:22:39.290
the first one, that value
for the second.

00:22:39.290 --> 00:22:41.370
So if I say, what is p 1?

00:22:41.370 --> 00:22:49.170
It says ok, MIT person
Fred Smith.

00:22:49.170 --> 00:22:53.420
On the other hand, if I said,
what is per, which is that

00:22:53.420 --> 00:22:55.890
thing I build earlier, it had
a different string method,

00:22:55.890 --> 00:23:00.340
which is just print out
person, those pieces.

00:23:00.340 --> 00:23:02.730
All right, one last piece
to this and we're

00:23:02.730 --> 00:23:04.720
going to add to it.

00:23:04.720 --> 00:23:08.830
Suppose I want Fred
to say something.

00:23:08.830 --> 00:23:20.530
Say something to Jane.

00:23:20.530 --> 00:23:23.620
OK, he said it.

00:23:23.620 --> 00:23:27.440
Where's the say method?

00:23:27.440 --> 00:23:32.200
OK, Fred is an instance
of an MIT person.

00:23:32.200 --> 00:23:34.650
where's the say method?

00:23:34.650 --> 00:23:36.690
Well, there isn't one there,
but again, that's where the

00:23:36.690 --> 00:23:37.910
hierarchy comes in.

00:23:37.910 --> 00:23:41.560
Fred is this object here, I'm
sending it the message say.

00:23:41.560 --> 00:23:44.630
That turns into going up the
chain to this object, which is

00:23:44.630 --> 00:23:48.225
the class object, and saying
find a say method and apply it

00:23:48.225 --> 00:23:49.880
to that instance.

00:23:49.880 --> 00:23:51.620
Fudge-knuckle, it ain't here.

00:23:51.620 --> 00:23:53.700
Don't worry about it, because
it says if I can't find one

00:23:53.700 --> 00:23:57.240
there, I'm going to go up the
chain to this method, sorry to

00:23:57.240 --> 00:23:59.450
this class, and look
for a method there.

00:23:59.450 --> 00:24:01.240
Which there was one, I
have a say method.

00:24:01.240 --> 00:24:03.190
It's going to use
that say method.

00:24:03.190 --> 00:24:05.110
Apply to it.

00:24:05.110 --> 00:24:07.160
Well, you might say, OK, what
happens if it isn't there?

00:24:07.160 --> 00:24:10.070
Well, that's where, remember
I defined person to be an

00:24:10.070 --> 00:24:12.700
instance of an object, it will
go up the chain one last time

00:24:12.700 --> 00:24:15.360
to the base object in Python
to see is there a

00:24:15.360 --> 00:24:16.780
method there or not.

00:24:16.780 --> 00:24:18.850
Probably isn't a say method
for an object, so at that

00:24:18.850 --> 00:24:21.390
point it's going to raise an
exception or throw an error.

00:24:21.390 --> 00:24:24.250
But now you again see this idea
that the inheritance lets

00:24:24.250 --> 00:24:27.950
you capture methods.

00:24:27.950 --> 00:24:30.080
Now you might say, why not just
put a say method inside

00:24:30.080 --> 00:24:31.920
of MIT person?

00:24:31.920 --> 00:24:34.040
Well, if you wanted it to do
something different, that

00:24:34.040 --> 00:24:35.130
would be the right
thing to do.

00:24:35.130 --> 00:24:37.770
But the whole notion here's that
I'm capturing modularity,

00:24:37.770 --> 00:24:40.910
I've got base methods
up in my base class.

00:24:40.910 --> 00:24:43.530
If I just want to use them I'm
just going to inherit them by

00:24:43.530 --> 00:24:48.040
following that chain, if you
like, basically up the track.

00:24:48.040 --> 00:24:54.400
OK, so we've got an MIT person,
we can use that.

00:24:54.400 --> 00:24:58.510
Let's add a little bit more
to our hierarchy here.

00:24:58.510 --> 00:25:02.140
I'm going to create, if
I can do this right, a

00:25:02.140 --> 00:25:10.220
specialization of an MIT
person, which is an

00:25:10.220 --> 00:25:12.270
undergraduate.

00:25:12.270 --> 00:25:14.820
A special kind of MIT person.

00:25:14.820 --> 00:25:19.100
All right, so if I go back up
here, even though my thing is

00:25:19.100 --> 00:25:23.720
not going to let me do it, let's
build an undergraduate.

00:25:23.720 --> 00:25:26.780
OK, there's the class definition
for an undergrad.

00:25:26.780 --> 00:25:28.790
We're just starting to see some
of the pieces, right, so

00:25:28.790 --> 00:25:31.980
in an undergraduate, where am
I here, an undergraduate.

00:25:31.980 --> 00:25:34.790
OK, it's also got an
initialization function.

00:25:34.790 --> 00:25:38.780
So if I call undergrad, I'm
gonna make an undergrad here,

00:25:38.780 --> 00:25:44.980
again let me go back down here,
line ug 2 it's making

00:25:44.980 --> 00:25:54.520
undergrad, Jane Doe.

00:25:54.520 --> 00:25:58.530
Now, what happens when I do
the initialization here?

00:25:58.530 --> 00:25:59.420
Notice what goes on.

00:25:59.420 --> 00:26:03.340
It simply calls the person
initialization method.

00:26:03.340 --> 00:26:05.200
All right, so I'm down here.

00:26:05.200 --> 00:26:06.870
I'm going to call the person
initialization

00:26:06.870 --> 00:26:07.550
method, what did do?

00:26:07.550 --> 00:26:11.620
Sorry, the MIT person method,
it calls the person method.

00:26:11.620 --> 00:26:13.610
Just walking up the chain,
that's going to do exactly

00:26:13.610 --> 00:26:15.960
what I did with all the other
ones, so I now have a family

00:26:15.960 --> 00:26:17.010
name and a first name.

00:26:17.010 --> 00:26:22.190
So I can, for example,
say family name

00:26:22.190 --> 00:26:24.290
and get it back out.

00:26:24.290 --> 00:26:25.420
All right?

00:26:25.420 --> 00:26:28.010
And then, other things that I
can do, well I can set what

00:26:28.010 --> 00:26:29.930
year the person's in, I can
figure out what year they're

00:26:29.930 --> 00:26:32.590
in, there's this unfortunate
overflow error if you've hung

00:26:32.590 --> 00:26:35.040
around too long, but that's not
going to happen to you.

00:26:35.040 --> 00:26:38.480
And I've now got a say method
here, so let's look what

00:26:38.480 --> 00:26:39.280
happens if I ask the

00:26:39.280 --> 00:26:52.930
undergraduate to say something.

00:26:52.930 --> 00:26:57.960
OK, it's not a realistic
dialogue I know, but, what did

00:26:57.960 --> 00:27:00.050
this method do?

00:27:00.050 --> 00:27:02.720
I asked this object
to do a say.

00:27:02.720 --> 00:27:05.110
And notice what it does.

00:27:05.110 --> 00:27:08.890
It simply passes it back
up to MIT person.

00:27:08.890 --> 00:27:09.910
There's that inheritance
again.

00:27:09.910 --> 00:27:11.620
It's saying, I'm going
to have my base

00:27:11.620 --> 00:27:13.750
say method say something.

00:27:13.750 --> 00:27:15.440
I'm going to say it to a person,
but all I'm going to

00:27:15.440 --> 00:27:17.410
do because undergraduates in my
experience, at least, are

00:27:17.410 --> 00:27:20.010
always very polite, I'm going to
put "Excuse me but" at the

00:27:20.010 --> 00:27:22.030
front of it.

00:27:22.030 --> 00:27:24.930
OK, what am I trying
to show you here?

00:27:24.930 --> 00:27:26.620
I know the jokes are awful,
but what am I

00:27:26.620 --> 00:27:28.030
trying to show you here?

00:27:28.030 --> 00:27:31.360
That I can simply pass up
the chain to get it.

00:27:31.360 --> 00:27:33.690
In fact, what method does
the final say here?

00:27:33.690 --> 00:27:36.440
What class does it come from?

00:27:36.440 --> 00:27:37.730
Person class, yes, thank you.

00:27:37.730 --> 00:27:39.650
It goes all the way up to
person, right, because MIT

00:27:39.650 --> 00:27:40.830
person didn't have a say.

00:27:40.830 --> 00:27:44.380
So I can simply walk up the
chain until I find the method

00:27:44.380 --> 00:27:45.900
I want to have.

00:27:45.900 --> 00:27:52.310
Now this is an example
of shadowing.

00:27:52.310 --> 00:27:54.590
Not a great example, but it's
a beginning example of

00:27:54.590 --> 00:27:58.770
shadowing, in that this same
method for an undergraduate,

00:27:58.770 --> 00:28:02.070
shadows the base say method, it
happens to call it, but it

00:28:02.070 --> 00:28:02.780
changes it.

00:28:02.780 --> 00:28:04.605
It puts "Excuse me but" at
the front, before it

00:28:04.605 --> 00:28:06.690
goes on to do something.

00:28:06.690 --> 00:28:10.350
Now again, I could have decided
here to actually copy

00:28:10.350 --> 00:28:12.800
what the original say method
did, stitch all the other

00:28:12.800 --> 00:28:14.070
things together.

00:28:14.070 --> 00:28:16.270
But again, that loses
my modularity.

00:28:16.270 --> 00:28:19.300
I'd really to only have to
change it in one place.

00:28:19.300 --> 00:28:22.540
So by putting my say method up
in person, I can add these

00:28:22.540 --> 00:28:24.310
nuances to it, and it lets
me have something

00:28:24.310 --> 00:28:25.620
that has that variation.

00:28:25.620 --> 00:28:29.430
If I decide I want to change
what say does, I only have to

00:28:29.430 --> 00:28:30.840
change it in one place.

00:28:30.840 --> 00:28:33.610
It is in the person class
definition, and everything

00:28:33.610 --> 00:28:36.080
else will follow through
for free.

00:28:36.080 --> 00:28:40.680
OK, so now I've got an
undergrad, right?

00:28:40.680 --> 00:28:42.070
Let's look at a couple
of variations of

00:28:42.070 --> 00:28:42.660
what happens here.

00:28:42.660 --> 00:28:50.270
So first of all, I can -- yes?

00:28:50.270 --> 00:28:54.640
PROFESSOR 2: Shadowing here
is often sometimes called

00:28:54.640 --> 00:28:55.240
overriding.

00:28:55.240 --> 00:28:57.660
PROFESSOR: Yes, thank you,
because I'm going to do a pure

00:28:57.660 --> 00:29:00.830
example of shadowing in
a second, John right.

00:29:00.830 --> 00:29:04.870
Also called overriding.

00:29:04.870 --> 00:29:06.780
Part of the reason I like the
phrase shadow is, if you think

00:29:06.780 --> 00:29:09.160
about it as looking at it from
this direction, you see this

00:29:09.160 --> 00:29:11.290
version of init before you see
the other ones, or you see

00:29:11.290 --> 00:29:13.530
that version of say, but
it is overriding

00:29:13.530 --> 00:29:15.680
the base say example.

00:29:15.680 --> 00:29:19.010
OK, so I can say, what does
p 1, sorry, yes, what does

00:29:19.010 --> 00:29:19.700
undergrad look like?

00:29:19.700 --> 00:29:23.560
And I said wait a minute,
MIT person, not

00:29:23.560 --> 00:29:26.690
undergrad, is that right?

00:29:26.690 --> 00:29:28.600
Well, where's the str method?

00:29:28.600 --> 00:29:31.730
I didn't define one in
undergrad, so it again tracks

00:29:31.730 --> 00:29:34.490
up the chain and finds the str
method here, so it's OK

00:29:34.490 --> 00:29:37.220
undergrads are MIT people
most the time, so

00:29:37.220 --> 00:29:39.280
it's perfectly fine.

00:29:39.280 --> 00:29:43.720
OK, now, I have built into this
also these cmp methods.

00:29:43.720 --> 00:29:44.980
So I've got two examples.

00:29:44.980 --> 00:29:47.220
I've got undergrad, or ug.

00:29:47.220 --> 00:29:50.600
And then I've got poor
old Frank Foobar

00:29:50.600 --> 00:29:53.180
back there, per person.

00:29:53.180 --> 00:29:58.340
So suppose I want
to compare them?

00:29:58.340 --> 00:30:01.250
What do you think
happens here?

00:30:01.250 --> 00:30:03.090
Compare sounds weird,
right, I compare an

00:30:03.090 --> 00:30:04.030
undergraduate to a person.

00:30:04.030 --> 00:30:05.630
I don't know what that's doing,
some kind of weird

00:30:05.630 --> 00:30:08.080
psychological thing, but what do
you think happens in terms

00:30:08.080 --> 00:30:12.370
of the code here
if I run this.

00:30:12.370 --> 00:30:14.040
I know it's a little hard
because you got a lot of code

00:30:14.040 --> 00:30:15.530
to look at.

00:30:15.530 --> 00:30:18.660
Do I have a cmp method
defined somewhere?

00:30:18.660 --> 00:30:19.620
Yeah.

00:30:19.620 --> 00:30:22.180
So, it's hard to know what it's
going to do, but let's

00:30:22.180 --> 00:30:25.300
look at it.

00:30:25.300 --> 00:30:27.100
Hmm.

00:30:27.100 --> 00:30:29.010
Now sometimes I type things
and I got errors I don't

00:30:29.010 --> 00:30:30.320
expect, this one I did expect.

00:30:30.320 --> 00:30:31.900
So what happened here?

00:30:31.900 --> 00:30:34.240
Well let's talk about what
happens if I do that

00:30:34.240 --> 00:30:39.400
comparison I was doing,
what was I doing?

00:30:39.400 --> 00:30:42.290
Ug greater than per?

00:30:42.290 --> 00:30:46.720
What unwinds into is, I'm going
to send to ug, that

00:30:46.720 --> 00:30:49.170
instance, a cmp method.

00:30:49.170 --> 00:30:52.190
This is really going to become
something like ug dot under

00:30:52.190 --> 00:30:57.020
under cmp under under
applied to per.

00:30:57.020 --> 00:30:59.670
I think that's close.

00:30:59.670 --> 00:31:00.460
What does that do?

00:31:00.460 --> 00:31:03.450
It says starting in ug, I'm
going to look for the first

00:31:03.450 --> 00:31:07.500
cmp method I could find, which
is actually sitting here.

00:31:07.500 --> 00:31:10.070
I had a cmp method
in MIT person.

00:31:10.070 --> 00:31:11.350
If you look at your code,
what does it do?

00:31:11.350 --> 00:31:14.280
It looks up the id numbers
to compare them.

00:31:14.280 --> 00:31:17.440
Well the, ug has an id number
because it was created along

00:31:17.440 --> 00:31:18.010
this chamber.

00:31:18.010 --> 00:31:20.530
Remember per over here was
just created as a person.

00:31:20.530 --> 00:31:24.560
It doesn't have an id number,
so that's why it complaints.

00:31:24.560 --> 00:31:29.280
Ok, happens if I do that?

00:31:29.280 --> 00:31:30.640
Compare per to ug.

00:31:30.640 --> 00:31:36.260
How many people think
I get an error?

00:31:36.260 --> 00:31:37.250
Wow.

00:31:37.250 --> 00:31:38.830
How many people think I'm going
to get either true or

00:31:38.830 --> 00:31:41.530
false out of this?

00:31:41.530 --> 00:31:43.500
A few brave hands.

00:31:43.500 --> 00:31:44.690
Why?

00:31:44.690 --> 00:31:45.360
Can I ask you, please?

00:31:45.360 --> 00:31:47.000
Why do you think I'm going to
get a, doesn't matter whether

00:31:47.000 --> 00:31:48.730
it's true or false, why am I
going to have something work

00:31:48.730 --> 00:31:50.400
this time that didn't
work last time?

00:31:50.400 --> 00:32:00.880
STUDENT: [INAUDIBLE]

00:32:00.880 --> 00:32:01.400
PROFESSOR: Yeah, exactly.

00:32:01.400 --> 00:32:02.950
And in case you didn't hear it,
thank you, great answer,

00:32:02.950 --> 00:32:04.600
sorry, terrible throw.

00:32:04.600 --> 00:32:09.900
In this case I'm using per,
that's the first part, so it's

00:32:09.900 --> 00:32:10.280
not symmetric.

00:32:10.280 --> 00:32:12.610
It's gonna use per to
do the look up.

00:32:12.610 --> 00:32:15.040
And as it was said there, per
over here goes up and finds a

00:32:15.040 --> 00:32:17.840
cmp method here which
it can apply.

00:32:17.840 --> 00:32:21.930
In that case, it simply looked
at, remember, it took the

00:32:21.930 --> 00:32:24.430
tuples of first and last name
which are both defined here,

00:32:24.430 --> 00:32:27.080
and did some comparison
on that.

00:32:27.080 --> 00:32:29.280
So this is a way of again
pointing out to you that the

00:32:29.280 --> 00:32:31.170
things are not always symmetric,
and I have to be

00:32:31.170 --> 00:32:33.360
careful about where do
I find the methods as

00:32:33.360 --> 00:32:34.820
I want to use them.

00:32:34.820 --> 00:32:36.780
Ok?

00:32:36.780 --> 00:32:38.700
All right.

00:32:38.700 --> 00:32:41.250
Let's add, I'm gonna do
two more classes here.

00:32:41.250 --> 00:32:44.780
Let's add one more class, some
people debate whether these

00:32:44.780 --> 00:32:46.990
are really people or not, but
we're going to add a class

00:32:46.990 --> 00:32:49.310
called a professor.

00:32:49.310 --> 00:32:51.090
OK.

00:32:51.090 --> 00:32:52.010
Now what am I doing?

00:32:52.010 --> 00:32:59.220
I'm creating another version
of class down here.

00:32:59.220 --> 00:33:02.100
Which again is an instance, or
a subclass, sorry, not an

00:33:02.100 --> 00:33:04.760
instance, a subclass
of an MIT person.

00:33:04.760 --> 00:33:08.160
I see that because I built
it to be there.

00:33:08.160 --> 00:33:10.850
Again I've got an initialization
that's going to

00:33:10.850 --> 00:33:13.070
call the person initialization,
which we know

00:33:13.070 --> 00:33:13.790
is going to go up --

00:33:13.790 --> 00:33:16.160
I keep saying that -- going
to call the MIT person

00:33:16.160 --> 00:33:18.650
initialization, which is going
to go up and call this one.

00:33:18.650 --> 00:33:21.020
So again I'm going to be
able to find names.

00:33:21.020 --> 00:33:22.830
And I do a couple of other
different things here.

00:33:22.830 --> 00:33:26.080
I'm gonna pass in a rank, full
professor, associate

00:33:26.080 --> 00:33:28.370
professor, assistant professor,
which I'm just

00:33:28.370 --> 00:33:30.120
going to bind locally.

00:33:30.120 --> 00:33:32.340
But I'm gonna add one other
piece here, which is I'm gonna

00:33:32.340 --> 00:33:35.800
add a little dictionary
on teaching.

00:33:35.800 --> 00:33:38.250
So when I create a professor,
I'm gonna associate with it a

00:33:38.250 --> 00:33:41.120
dictionary that says, what
have you been teaching?

00:33:41.120 --> 00:33:43.500
And then notice the
methods I create.

00:33:43.500 --> 00:33:47.880
I've got a method here called
add teaching, takes, obviously

00:33:47.880 --> 00:33:49.380
a pointer to the instance.

00:33:49.380 --> 00:33:52.490
A term, which will just be
a string, and a subject.

00:33:52.490 --> 00:33:54.780
And let's look at what
it does right here.

00:33:54.780 --> 00:33:56.340
OK.

00:33:56.340 --> 00:33:58.540
In fact the call I'm going to
make, I'm not certain I'm

00:33:58.540 --> 00:34:02.370
going to be able to get away
with it, my machine is still

00:34:02.370 --> 00:34:06.510
wonderfully broken, all right,
it is, let me just show you

00:34:06.510 --> 00:34:07.760
what the calls would
look like.

00:34:07.760 --> 00:34:11.530
As you can see here I'm not
going to be able to do them.

00:34:11.530 --> 00:34:15.380
But I'm going to add teaching,
as a method call with this

00:34:15.380 --> 00:34:20.580
with a string for term,
and a subject number.

00:34:20.580 --> 00:34:26.500
What is this going to do?

00:34:26.500 --> 00:34:28.605
Yeah, I know I'm just worried if
I restart Python, I may not

00:34:28.605 --> 00:34:30.420
be able to pull the thing back
in, so I'm going to try and

00:34:30.420 --> 00:34:32.210
wing it, John, and see if
I can make it happen.

00:34:32.210 --> 00:34:34.040
Right, what does that
teaching do?

00:34:34.040 --> 00:34:36.450
It's got one of those
try except methods.

00:34:36.450 --> 00:34:38.550
So what does it say
it's going to do?

00:34:38.550 --> 00:34:41.020
It's going to go into the
dictionary associated with

00:34:41.020 --> 00:34:45.880
teaching, under the value of
term, and get out a list. And

00:34:45.880 --> 00:34:47.080
it's going to append
to the end of the

00:34:47.080 --> 00:34:48.740
list the new subject.

00:34:48.740 --> 00:34:50.730
So it's going to be stored in
there, is then going to be

00:34:50.730 --> 00:34:53.270
term, and a list of what I
taught, in case I teach more

00:34:53.270 --> 00:34:55.080
than one thing each term.

00:34:55.080 --> 00:34:57.590
It's going to do that, but
notice it's a try.

00:34:57.590 --> 00:35:00.540
If in fact there is no term
currently in the dictionary,

00:35:00.540 --> 00:35:03.350
started out empty, it's going to
throw an error, sorry, not

00:35:03.350 --> 00:35:04.960
throw an error, it's going
to raise an exception.

00:35:04.960 --> 00:35:07.430
Which is a key error, in which
case notice what I'm going to

00:35:07.430 --> 00:35:09.090
do, I'm not going to treat
it as an error.

00:35:09.090 --> 00:35:13.000
I'm simply going to say, in that
case, just start off with

00:35:13.000 --> 00:35:16.480
an empty, with an initial list
with just that subject in and

00:35:16.480 --> 00:35:18.320
put it in the dictionary.

00:35:18.320 --> 00:35:21.050
As I add more things in, I'll
just keep adding things to

00:35:21.050 --> 00:35:23.140
this dictionary under
that term.

00:35:23.140 --> 00:35:25.790
And if I want to find out what
I'm doing, well I can use get

00:35:25.790 --> 00:35:28.630
teaching, which says given the
term, find the thing in the

00:35:28.630 --> 00:35:31.220
dictionary under that
term and return it.

00:35:31.220 --> 00:35:34.010
If I get an error, I'm going to
raise it, which says there

00:35:34.010 --> 00:35:35.750
is nothing for that term, and in
that case I guess I'm just

00:35:35.750 --> 00:35:37.730
going to return none.

00:35:37.730 --> 00:35:39.730
OK?

00:35:39.730 --> 00:35:41.820
And then the other two pieces
we're going to have here, and

00:35:41.820 --> 00:35:43.530
we want to look at a little more
carefully, I just wanted

00:35:43.530 --> 00:35:51.420
to show you that example, is a
professor can lecture, and a

00:35:51.420 --> 00:35:54.070
professor can say something.

00:35:54.070 --> 00:35:56.730
Look at the say method, because
this now add one more

00:35:56.730 --> 00:35:59.050
nuance to what we
want to do here.

00:35:59.050 --> 00:36:00.830
And I think in interest of
making this go, let me

00:36:00.830 --> 00:36:03.030
actually, since I'm not going
to get my machine to do this

00:36:03.030 --> 00:36:14.830
right, let me create a
couple of professors.

00:36:14.830 --> 00:36:17.870
If I look at what that is, it's
an MIT person because I

00:36:17.870 --> 00:36:20.850
didn't have any separate string
thing there, and we

00:36:20.850 --> 00:36:29.520
will create a more important
professor.

00:36:29.520 --> 00:36:30.450
What rank do you want, John?

00:36:30.450 --> 00:36:31.220
Do you want to stay full?

00:36:31.220 --> 00:36:33.700
PROFESSOR 2: Undergraduate.

00:36:33.700 --> 00:36:37.010
PROFESSOR: Undergraduate, right,
a lot more fun I agree.

00:36:37.010 --> 00:36:38.880
Sorry about that, and we
can again just see

00:36:38.880 --> 00:36:40.260
what that looks like.

00:36:40.260 --> 00:36:42.230
And that of course,
we'll print out,

00:36:42.230 --> 00:36:44.480
he's also an MIT person.

00:36:44.480 --> 00:36:46.420
But now here's what
I want to do.

00:36:46.420 --> 00:36:48.170
I want to say something
to my good

00:36:48.170 --> 00:36:50.450
colleague Professor Guttag.

00:36:50.450 --> 00:36:51.430
Actually I'm going to
start a separate --

00:36:51.430 --> 00:36:53.580
I'm going to say something
to a smart undergraduate.

00:36:53.580 --> 00:36:59.450
So if I say, remember we
have ug defined as an

00:36:59.450 --> 00:37:09.320
undergraduate, let
me do something a

00:37:09.320 --> 00:37:11.460
little different here.

00:37:11.460 --> 00:37:20.590
Well let, me do it that way.

00:37:20.590 --> 00:37:22.560
It says, I don't understand
why you say you

00:37:22.560 --> 00:37:24.120
were enjoying 6.00.

00:37:24.120 --> 00:37:29.180
Not a good thing to say, right,
but if I say to my good

00:37:29.180 --> 00:37:33.290
colleague Professor Guttag.

00:37:33.290 --> 00:37:35.450
I have to spell say right, I
know, I need help with this,

00:37:35.450 --> 00:37:44.190
what can I say?

00:37:44.190 --> 00:37:45.540
We flatter each other
all the time.

00:37:45.540 --> 00:37:47.540
It's part of what makes us feel
good about ourselves.

00:37:47.540 --> 00:37:48.490
Why is the sky blue?

00:37:48.490 --> 00:37:51.890
I enjoyed your paper, but
why is the sky blue?

00:37:51.890 --> 00:37:55.170
OK, terrible examples, but
what's going on here?

00:37:55.170 --> 00:37:56.530
One more piece that
I want to add.

00:37:56.530 --> 00:38:00.100
Here's my say method for
professor, and now I'm

00:38:00.100 --> 00:38:03.000
actually taking advantage of to
whom I am saying something.

00:38:03.000 --> 00:38:04.840
Notice again, what does it do?

00:38:04.840 --> 00:38:06.800
There's the self argument,
that's just pointing to the

00:38:06.800 --> 00:38:08.220
instance of me.

00:38:08.220 --> 00:38:11.045
I'm passing in another argument,
going to call it to

00:38:11.045 --> 00:38:14.080
who, in one case it was ug,
in one case it was Guttag.

00:38:14.080 --> 00:38:16.450
And then the thing I want to
say, ah, look what it does, it

00:38:16.450 --> 00:38:19.390
says, check the type.

00:38:19.390 --> 00:38:22.890
And the type is going to take
that instance, I had an

00:38:22.890 --> 00:38:25.060
instance, for example, of a
professor down here, and it's

00:38:25.060 --> 00:38:28.780
going to pick up what type
of object it is.

00:38:28.780 --> 00:38:34.200
So if the type of the person I'm
speaking to is undergrad,

00:38:34.200 --> 00:38:35.210
let's pause for second.

00:38:35.210 --> 00:38:38.020
Remember I started away back
saying we're building abstract

00:38:38.020 --> 00:38:39.000
data types.

00:38:39.000 --> 00:38:41.110
Well, here's a great example
of how I'm using

00:38:41.110 --> 00:38:42.670
exactly that, right?

00:38:42.670 --> 00:38:45.880
I've got int, I've got float,
I now have ug, it's a type.

00:38:45.880 --> 00:38:49.570
So it's says if the object to
whom I'm speaking is an

00:38:49.570 --> 00:38:53.320
undergrad, then use the same
method from person where I'm

00:38:53.320 --> 00:38:55.400
going to put this
on the front.

00:38:55.400 --> 00:38:57.570
On the other hand, if the object
to whom I'm speaking is

00:38:57.570 --> 00:39:00.660
a professor, then I'm going to
tag this on the front and use

00:39:00.660 --> 00:39:01.730
the underlying say method.

00:39:01.730 --> 00:39:05.020
On the other hand, if I'm
speaking to somebody else, I'm

00:39:05.020 --> 00:39:06.660
just going to go lecture.

00:39:06.660 --> 00:39:08.670
All right, and when a professor
lectures, they just

00:39:08.670 --> 00:39:10.710
put it's obvious on the
end of things, as

00:39:10.710 --> 00:39:13.090
you may have noticed.

00:39:13.090 --> 00:39:14.970
What's the point I want
you to see here?

00:39:14.970 --> 00:39:18.870
I'm now using the instances
to help me to find what

00:39:18.870 --> 00:39:20.200
the code should do.

00:39:20.200 --> 00:39:21.100
I'm looking at the type.

00:39:21.100 --> 00:39:22.200
If the type is this, do that.

00:39:22.200 --> 00:39:24.720
If the type is this, do
something different, ok?

00:39:24.720 --> 00:39:28.310
And I can now sort of build
those pieces up.

00:39:28.310 --> 00:39:31.300
OK, I said one more class.

00:39:31.300 --> 00:39:32.140
Notice what we're doing.

00:39:32.140 --> 00:39:35.530
I know they're silly examples,
but, sorry, they are cleverly

00:39:35.530 --> 00:39:37.590
designed examples to highlight
key points.

00:39:37.590 --> 00:39:40.970
What I'm trying to do is show
you how we have methods

00:39:40.970 --> 00:39:43.720
inherit methods, how have
message shadow methods, how we

00:39:43.720 --> 00:39:46.580
have methods override methods,
how we can use instances as

00:39:46.580 --> 00:39:49.250
types to define what the
method should do.

00:39:49.250 --> 00:39:51.730
Let me show you one last class,
because I'm gonna have

00:39:51.730 --> 00:39:53.650
one more piece that
we want to use.

00:39:53.650 --> 00:39:57.910
And the last class is, sort of,
once you've got a set of

00:39:57.910 --> 00:40:00.360
professors, you can have
an aggregate of them.

00:40:00.360 --> 00:40:02.750
And I don't know, if a group of
geese are gaggle, I don't

00:40:02.750 --> 00:40:05.100
know what a set of professors
are, John.

00:40:05.100 --> 00:40:05.710
Flamers?

00:40:05.710 --> 00:40:07.390
I, you know, we've got to figure
out what the right

00:40:07.390 --> 00:40:08.160
collective noun here is.

00:40:08.160 --> 00:40:11.040
We're going to call them a
faculty for lack of a better

00:40:11.040 --> 00:40:12.340
term, right?

00:40:12.340 --> 00:40:14.440
Now the reason I want to show
you this example is, this

00:40:14.440 --> 00:40:18.700
class, notice, it only is going
to inherit from object.

00:40:18.700 --> 00:40:19.420
It actually makes sense.

00:40:19.420 --> 00:40:21.510
This is going to be a collection
of things, but it's

00:40:21.510 --> 00:40:24.710
not a subclass of a particular
kind of person.

00:40:24.710 --> 00:40:28.050
And what I want the faculty to
do, is to be able to gather

00:40:28.050 --> 00:40:31.460
together a set of faculty.

00:40:31.460 --> 00:40:35.930
So if I go down here, grab this
for second, and pull it

00:40:35.930 --> 00:40:38.160
down so you can see it.

00:40:38.160 --> 00:40:39.790
It looks like I'm not going to
be able to run this because my

00:40:39.790 --> 00:40:42.250
machine is broken, but basically
I'm gonna define a

00:40:42.250 --> 00:40:45.780
set of professors, and then I'm
gonna create a new class

00:40:45.780 --> 00:40:47.900
called faculty.

00:40:47.900 --> 00:40:48.980
There's the definition of it.

00:40:48.980 --> 00:40:50.590
It's got an init.

00:40:50.590 --> 00:40:51.880
You can kind of see
what it does.

00:40:51.880 --> 00:40:53.980
It's going to set up an internal
variable called

00:40:53.980 --> 00:40:56.980
names, which is initially an
empty list, internal variable

00:40:56.980 --> 00:40:59.320
called ids, which is empty, an
internal variable called

00:40:59.320 --> 00:41:01.910
members, which is empty, and
another special variable

00:41:01.910 --> 00:41:03.710
called place, which we're going
to come back to in a

00:41:03.710 --> 00:41:06.640
second, initially
bound to none.

00:41:06.640 --> 00:41:09.760
OK, I've got a method called
add which I'm going to use

00:41:09.760 --> 00:41:13.250
down here to add professors
to the course 6 faculty.

00:41:13.250 --> 00:41:16.530
Here's what I want
to add to do.

00:41:16.530 --> 00:41:19.960
First of all, notice I'm going
to check the type.

00:41:19.960 --> 00:41:23.890
If this is not a professor, I'm
gonna raise an error, a

00:41:23.890 --> 00:41:26.710
type error, it's the wrong type
of object to pass in.

00:41:26.710 --> 00:41:30.760
The second thing I'm gonna do
is say, if that's okay, then

00:41:30.760 --> 00:41:32.440
let me go off and get
the id number.

00:41:32.440 --> 00:41:36.550
Now remember, that's right up
here, so I'm asking the

00:41:36.550 --> 00:41:39.780
instance of the professor to go
up and get the id number.

00:41:39.780 --> 00:41:42.350
And I want to make sure I only
have one instance of each

00:41:42.350 --> 00:41:46.640
professor in my faculty, so if
the id number is in the list

00:41:46.640 --> 00:41:51.290
of ids already, I'm going to
raise an error, sorry, raise

00:41:51.290 --> 00:41:54.140
an exception as well, saying
I've got a duplicate id.

00:41:54.140 --> 00:41:54.480
OK?

00:41:54.480 --> 00:41:56.340
And the reason that's
going to come up is,

00:41:56.340 --> 00:41:57.280
notice what I do now.

00:41:57.280 --> 00:42:01.640
Inside of the instant self, I
take the variable names and I

00:42:01.640 --> 00:42:06.370
add to it the family name of
the person I just added.

00:42:06.370 --> 00:42:07.360
OK, notice the form.

00:42:07.360 --> 00:42:10.500
I'm using the method, there's
the parens to get the family

00:42:10.500 --> 00:42:11.680
name of the person.

00:42:11.680 --> 00:42:13.940
I'm just adding it to the list.
I've got the id number,

00:42:13.940 --> 00:42:15.640
I've added the ids,
and I add the

00:42:15.640 --> 00:42:18.410
object itself into members.

00:42:18.410 --> 00:42:20.710
So as I do this, what
am I doing?

00:42:20.710 --> 00:42:24.510
I'm creating a list, actually
several lists: a list of ids,

00:42:24.510 --> 00:42:27.160
a list of the actual instances,
and a list of the

00:42:27.160 --> 00:42:28.470
family names.

00:42:28.470 --> 00:42:31.120
And as a cost I want to add,
that's why I can check and

00:42:31.120 --> 00:42:33.550
see, is this in here
already or not?

00:42:33.550 --> 00:42:36.310
Now, the last reason I want to
do this is, I want to be able

00:42:36.310 --> 00:42:58.830
to support things like that.

00:42:58.830 --> 00:43:03.380
This is now different, right,
this instance is a collection.

00:43:03.380 --> 00:43:05.630
I want to be able to do things
like, for all the things in

00:43:05.630 --> 00:43:07.110
that collection, do something,
like print

00:43:07.110 --> 00:43:08.570
out the family names.

00:43:08.570 --> 00:43:18.550
And to do that, I need two
special forms: iter and next.

00:43:18.550 --> 00:43:23.080
OK, now let me see if I
can say this cleanly.

00:43:23.080 --> 00:43:27.110
Whenever I use a for, in
structure, even if it was on

00:43:27.110 --> 00:43:30.320
just a normal list you built,
what Python is doing is

00:43:30.320 --> 00:43:32.940
returning an, what is
called an iterator.

00:43:32.940 --> 00:43:34.370
Which is something that
we talked earlier.

00:43:34.370 --> 00:43:37.340
It's keeping track of where are
you in the list, and how

00:43:37.340 --> 00:43:40.330
do I get to the next
thing in the list?

00:43:40.330 --> 00:43:42.395
I'm going to do the same thing
here, and I'm going to create

00:43:42.395 --> 00:43:43.890
it for this particular
structure.

00:43:43.890 --> 00:43:49.120
So this little thing iter, when
I call a for something

00:43:49.120 --> 00:43:52.740
in, one of these instances,
it calls iter, and

00:43:52.740 --> 00:43:53.570
notice what it does.

00:43:53.570 --> 00:43:55.470
It initializes place to 0.

00:43:55.470 --> 00:43:56.950
That was that variable
I had up there.

00:43:56.950 --> 00:43:59.590
That's basically saying I'm at
the beginning of the list.

00:43:59.590 --> 00:44:01.560
It's a pointer to the beginning
of the list, and it

00:44:01.560 --> 00:44:04.450
returns self.

00:44:04.450 --> 00:44:07.430
Just gives me back a pointer
to the instance.

00:44:07.430 --> 00:44:09.810
That now allows me at
each step in that

00:44:09.810 --> 00:44:11.550
loop to call next.

00:44:11.550 --> 00:44:13.250
And what does next do?

00:44:13.250 --> 00:44:17.970
Next says, check to see if that
value is too long, if

00:44:17.970 --> 00:44:21.290
it's longer than, for example,
the list of names, raise an

00:44:21.290 --> 00:44:24.070
exception called stop iteration,
which the for loop

00:44:24.070 --> 00:44:25.850
will use to say OK, I'm done.

00:44:25.850 --> 00:44:28.230
I'm going to break out
of the for loop.

00:44:28.230 --> 00:44:30.630
Otherwise, what am
I going to do?

00:44:30.630 --> 00:44:33.160
I'll increment place by 1,
that's going to move me to the

00:44:33.160 --> 00:44:35.680
next place in the list, and then
in this case I'll just

00:44:35.680 --> 00:44:38.010
return the instance
itself, right?

00:44:38.010 --> 00:44:40.600
Members is a list of instances,
place I've

00:44:40.600 --> 00:44:43.750
incremented by 1, I take 1
off of it, I get to it.

00:44:43.750 --> 00:44:45.840
So iter and next
work together.

00:44:45.840 --> 00:44:49.550
Iter creates this method, that's
going to give you a

00:44:49.550 --> 00:44:52.490
pointer to the place in the
structure, and then next

00:44:52.490 --> 00:44:54.810
literally walks along the
structure giving you the next

00:44:54.810 --> 00:44:57.220
element and returning elements
in turn so you can do

00:44:57.220 --> 00:44:59.360
something with it.

00:44:59.360 --> 00:45:01.830
Right, so now what that says
is, I can have classes that

00:45:01.830 --> 00:45:03.680
just have local variables.

00:45:03.680 --> 00:45:06.460
I can have classes that get
methods from other variables,

00:45:06.460 --> 00:45:09.030
and I can also have classes
that are collections.

00:45:09.030 --> 00:45:12.560
And I've supported that by
adding in this last piece.

00:45:12.560 --> 00:45:17.220
OK once you have all of that,
in principle we could start

00:45:17.220 --> 00:45:19.140
doing some fun things.

00:45:19.140 --> 00:45:21.180
So let's see what happens
if we try and

00:45:21.180 --> 00:45:22.030
make all of this go.

00:45:22.030 --> 00:45:23.900
And let me, since I'm not going
to be able to run it,

00:45:23.900 --> 00:45:29.990
let me simply do it this way.

00:45:29.990 --> 00:45:35.120
If I have my undergraduate,
ug.

00:45:35.120 --> 00:45:37.170
I can -- sorry, let's not
do it that way --

00:45:37.170 --> 00:45:53.090
I can have undergraduate say
things like -- all right, what

00:45:53.090 --> 00:45:54.320
did I just do wrong here?

00:45:54.320 --> 00:45:55.820
Do I not have undergrad
defined?

00:45:55.820 --> 00:46:00.350
I do.

00:46:00.350 --> 00:46:02.650
Oh, I didn't have Grimson,
sorry, it's me, isn't it?

00:46:02.650 --> 00:46:03.120
Thank you.

00:46:03.120 --> 00:46:13.310
The undergraduate very politely
asks why he didn't

00:46:13.310 --> 00:46:32.520
understand, you can have
the professor respond.

00:46:32.520 --> 00:46:35.570
Again, it simply puts a
different thing into there.

00:46:35.570 --> 00:46:41.660
On the other hand, if Professor
Guttag asks me

00:46:41.660 --> 00:46:50.050
something about understanding, I
say I really like this paper

00:46:50.050 --> 00:46:52.150
on, you do not understand,
it's a deep paper on

00:46:52.150 --> 00:46:55.150
programming languages 5, I
think, John, isn't it?

00:46:55.150 --> 00:46:56.890
What else can you do with
this thing, right?

00:46:56.890 --> 00:46:59.615
You can have an undergraduate
talk to an undergraduate, in

00:46:59.615 --> 00:47:01.580
which case they're
still polite.

00:47:01.580 --> 00:47:03.280
Or you could have -- sorry, let
me do that the other way

00:47:03.280 --> 00:47:05.330
-- you could also have an
undergraduate simply talk to a

00:47:05.330 --> 00:47:16.270
normal person.

00:47:16.270 --> 00:47:18.660
All right, but the good news is
you know eventually you get

00:47:18.660 --> 00:47:20.920
it done, and when you're really
done you can have the

00:47:20.920 --> 00:47:25.250
undergraduate be really happy
about this, and so she sings

00:47:25.250 --> 00:47:36.130
to herself.

00:47:36.130 --> 00:47:39.440
OK it's a little silly, but
notice what we've just

00:47:39.440 --> 00:47:39.660
illustrated.

00:47:39.660 --> 00:47:43.320
And this is where I want
to pull it together.

00:47:43.320 --> 00:47:48.750
With a simple set of classes,
and the following abilities,

00:47:48.750 --> 00:47:51.730
an ability to inherit methods
from subclasses, sorry from

00:47:51.730 --> 00:47:54.990
superclasses, that is having
this hierarchy of things.

00:47:54.990 --> 00:47:58.990
I can create a fairly complex
kind of interaction.

00:47:58.990 --> 00:48:02.440
I can take advantage of the
types of the objects to help

00:48:02.440 --> 00:48:04.050
me decide what to do.

00:48:04.050 --> 00:48:06.010
And if you think about that,
I know it sounds very

00:48:06.010 --> 00:48:08.410
straightforward, but you would
do exactly that if you were

00:48:08.410 --> 00:48:11.730
writing earlier code to deal
with some numerical problem.

00:48:11.730 --> 00:48:13.870
All right, if the thing is an
integer, do this, if it's a

00:48:13.870 --> 00:48:16.360
float, do that, if it's a
string, do something else.

00:48:16.360 --> 00:48:19.400
I'm now giving you exactly the
same ability, but the types

00:48:19.400 --> 00:48:21.550
now can be things that
you could create.

00:48:21.550 --> 00:48:25.050
And what I've also got is now
the ability to inherit those

00:48:25.050 --> 00:48:26.990
methods as they go
up the chain.

00:48:26.990 --> 00:48:28.980
So another way of saying it is,
things that you want to

00:48:28.980 --> 00:48:39.010
come away from here, are, in
terms of these classes.

00:48:39.010 --> 00:48:41.410
We now have this idea
of encapsulation.

00:48:41.410 --> 00:48:44.360
I'm gathering together data that
naturally belongs as a

00:48:44.360 --> 00:48:47.210
unit, and I'm gathering together
with it methods that

00:48:47.210 --> 00:48:48.330
apply to that unit.

00:48:48.330 --> 00:48:51.270
Just like we would have done
with float or int.

00:48:51.270 --> 00:48:54.210
Ideally, we data hide, we don't
happen to do it here,

00:48:54.210 --> 00:48:55.020
which is too bad.

00:48:55.020 --> 00:48:58.110
Basically we've got the
idea of encapsulation.

00:48:58.110 --> 00:49:06.640
The second thing we've got is
this idea of inheritance.

00:49:06.640 --> 00:49:08.570
Inheritance both meaning
I can inherit

00:49:08.570 --> 00:49:10.750
attributes or field values.

00:49:10.750 --> 00:49:13.920
I can inherit methods by
moving up the chain.

00:49:13.920 --> 00:49:22.990
I can also the shadow or
override methods, so that I

00:49:22.990 --> 00:49:24.530
can specialise.

00:49:24.530 --> 00:49:35.390
And I do all of that with this
nice hierarchy of classes.

00:49:35.390 --> 00:49:38.120
So what hopefully you've seen,
between these two lectures,

00:49:38.120 --> 00:49:39.690
and we're going to come back
to it in some subsequent

00:49:39.690 --> 00:49:42.210
lectures, is that this is now
a different way of just

00:49:42.210 --> 00:49:45.220
structuring a computational
system.

00:49:45.220 --> 00:49:47.770
Now, you'll also get arguments,
polite arguments

00:49:47.770 --> 00:49:50.700
from faculty members or other
experts about which is a

00:49:50.700 --> 00:49:51.790
better way of doing it.

00:49:51.790 --> 00:49:54.180
So I'll give you my bias,
Professor Guttag will give you

00:49:54.180 --> 00:49:55.350
his bias next time around.

00:49:55.350 --> 00:49:58.090
My view, object-oriented system
are great when you're

00:49:58.090 --> 00:50:01.880
trying to model systems that
consist of a large number of

00:50:01.880 --> 00:50:05.310
units that interact in
very specific ways.

00:50:05.310 --> 00:50:07.500
So, modeling a system of
people's a great idea.

00:50:07.500 --> 00:50:09.930
Modeling a system of molecules
is probably a great idea.

00:50:09.930 --> 00:50:13.320
Modeling a system where it is
natural to associate things

00:50:13.320 --> 00:50:15.960
together and where the number
of interactions between them

00:50:15.960 --> 00:50:17.010
is very controlled.

00:50:17.010 --> 00:50:18.980
These systems work
really well.

00:50:18.980 --> 00:50:21.260
And we'll see some examples
of that next week.

00:50:21.260 --> 00:50:22.510
Thanks.

