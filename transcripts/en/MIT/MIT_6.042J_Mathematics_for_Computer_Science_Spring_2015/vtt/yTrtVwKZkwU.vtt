WEBVTT
Kind: captions
Language: en

00:00:01.360 --> 00:00:04.500
PROFESSOR: The topic of
counting, or combinatorics,

00:00:04.500 --> 00:00:07.410
is an important one in a number
of different disciplines,

00:00:07.410 --> 00:00:11.450
and notably in computer science.

00:00:11.450 --> 00:00:16.470
So the origins of the
combinatorics and counting

00:00:16.470 --> 00:00:17.920
are a little bit disreputable.

00:00:17.920 --> 00:00:22.070
They come, historically, out
of people studying gambling

00:00:22.070 --> 00:00:26.650
and trying to calculate odds
and the fraction of times

00:00:26.650 --> 00:00:29.414
that various events occur
to know what kind of bets

00:00:29.414 --> 00:00:30.080
to make on them.

00:00:30.080 --> 00:00:32.170
So a typical kind
of question would

00:00:32.170 --> 00:00:34.610
be-- if you know
how poker works,

00:00:34.610 --> 00:00:36.460
there are various
classifications

00:00:36.460 --> 00:00:38.020
of five-card hands in poker.

00:00:38.020 --> 00:00:42.090
And you might ask, what fraction
of all possible five-card poker

00:00:42.090 --> 00:00:47.160
hands translate into
being a pair of jacks?

00:00:47.160 --> 00:00:51.210
And basically, this fraction
of total poker hands

00:00:51.210 --> 00:00:54.440
which fit into the
category "a pair of jacks"

00:00:54.440 --> 00:00:57.230
is the probability
of a pair of jacks.

00:00:57.230 --> 00:00:59.860
So counting in gambling
is one fundamental place

00:00:59.860 --> 00:01:01.030
where it really comes up.

00:01:01.030 --> 00:01:04.269
And historically, that's where
a lot of combinatorics begins.

00:01:04.269 --> 00:01:07.620
Related to that is
counting in games.

00:01:07.620 --> 00:01:11.350
When you're trying to write,
for example, a computer program

00:01:11.350 --> 00:01:16.150
to play chess or checkers or
so on, one of the aspects of it

00:01:16.150 --> 00:01:19.180
is getting a sense of
how much searching you

00:01:19.180 --> 00:01:21.845
have to do in order to look
ahead to find good moves.

00:01:21.845 --> 00:01:25.360
And you wind up counting,
from a given chess position,

00:01:25.360 --> 00:01:28.930
how many possible
further positions can you

00:01:28.930 --> 00:01:32.300
get to a given number of moves.

00:01:32.300 --> 00:01:36.940
A puzzle kind of question, in
solving the Rubik's Cube toy,

00:01:36.940 --> 00:01:39.494
is how many different
positions are there,

00:01:39.494 --> 00:01:41.160
and how many different
positions can you

00:01:41.160 --> 00:01:44.440
get to from a given position?

00:01:44.440 --> 00:01:48.030
Concretely, in computer science,
it comes up in algorithms.

00:01:48.030 --> 00:01:50.360
It's often the case that
an essential question

00:01:50.360 --> 00:01:52.480
is, how many
operations does it take

00:01:52.480 --> 00:01:54.880
to do a manipulation
on a data structure

00:01:54.880 --> 00:01:57.580
and to update it
from one to another?

00:01:57.580 --> 00:01:58.955
For example, how
many comparisons

00:01:58.955 --> 00:02:02.950
does it take to sort
n numerical items?

00:02:02.950 --> 00:02:06.860
And typically, the
count is n log n,

00:02:06.860 --> 00:02:10.620
proved as a number of operations
that are both achievable

00:02:10.620 --> 00:02:13.140
and a lower bound.

00:02:13.140 --> 00:02:16.321
One that we've seen when we
looked at fast exponentiation

00:02:16.321 --> 00:02:17.820
is a question like,
if you're trying

00:02:17.820 --> 00:02:21.490
to compute the nth
power of a number d,

00:02:21.490 --> 00:02:24.200
how many multiplications
does it take?

00:02:24.200 --> 00:02:27.690
It's roughly log n by using
the iterated squaring method.

00:02:27.690 --> 00:02:31.510
And we want to be able to count
that number of multiplications

00:02:31.510 --> 00:02:35.190
that a particular program
uses to compute d to the n

00:02:35.190 --> 00:02:38.130
in the smallest number
of multiplications

00:02:38.130 --> 00:02:40.120
you can get away with.

00:02:40.120 --> 00:02:43.670
And a place where, again,
counting and combinatorics

00:02:43.670 --> 00:02:49.500
becomes critical is for security
and the issue of cryptography.

00:02:49.500 --> 00:02:52.960
If you're going to have
security from passwords,

00:02:52.960 --> 00:02:56.570
there needs to be too
large a space of passwords

00:02:56.570 --> 00:02:58.890
for an adversary to search
through exhaustively

00:02:58.890 --> 00:03:01.550
and check them likewise.

00:03:01.550 --> 00:03:05.484
If you're doing encryption
with some kind of secret key

00:03:05.484 --> 00:03:06.900
that enables you
to read messages,

00:03:06.900 --> 00:03:09.840
you want to be sure that
the space of possible keys

00:03:09.840 --> 00:03:12.690
is also way too large
to search exhaustively

00:03:12.690 --> 00:03:15.640
to see what keys work.

00:03:15.640 --> 00:03:21.070
So let's talk briefly now
about the very basic counting

00:03:21.070 --> 00:03:25.392
methods, and two rules
for counting things--

00:03:25.392 --> 00:03:27.350
the most rudimentary of
them, but in fact we'll

00:03:27.350 --> 00:03:28.820
get some mileage out of them.

00:03:28.820 --> 00:03:30.530
So the first rule is
called the Sum Rule,

00:03:30.530 --> 00:03:33.460
and it's completely
straightforward and obvious,

00:03:33.460 --> 00:03:36.610
which is that if I have two
sets, A and B, that do not

00:03:36.610 --> 00:03:41.260
overlap, then the number
of elements in A union B

00:03:41.260 --> 00:03:43.150
is simply the number
of elements in A

00:03:43.150 --> 00:03:45.730
plus the number
of elements in B.

00:03:45.730 --> 00:03:48.210
And there's no issue proving
that-- it's self-evident--

00:03:48.210 --> 00:03:50.230
but let's do an example.

00:03:50.230 --> 00:03:54.470
Suppose a class has
43 women and 54 men.

00:03:54.470 --> 00:03:55.950
How many people are in it?

00:03:55.950 --> 00:03:58.090
43 plus 54 equals 97.

00:03:58.090 --> 00:04:00.580
This is implicitly
assuming that there's

00:04:00.580 --> 00:04:03.440
no one whose sex is
ambiguous and that there's

00:04:03.440 --> 00:04:08.546
no third sex, so that men
and women are disjoint.

00:04:08.546 --> 00:04:10.170
The total number of
students is the sum

00:04:10.170 --> 00:04:11.710
of the number of men and women.

00:04:11.710 --> 00:04:15.240
Another one is there
are 26 lowercase Roman

00:04:15.240 --> 00:04:19.529
letters and 26 uppercase
Roman letters and 10 digits.

00:04:19.529 --> 00:04:25.000
And so there are 26 plus 26
plus 10 equals 62 characters

00:04:25.000 --> 00:04:29.680
in that repertoire of symbols.

00:04:29.680 --> 00:04:31.870
The second rule is
called the Product Rule,

00:04:31.870 --> 00:04:34.770
and just about as obvious.

00:04:34.770 --> 00:04:37.040
Suppose I have four
boys and three girls.

00:04:37.040 --> 00:04:41.440
How many boy-girl couples
can I assemble out

00:04:41.440 --> 00:04:43.850
of four boys and three girls?

00:04:43.850 --> 00:04:49.720
And the answer is, there are
four ways to choose a boy,

00:04:49.720 --> 00:04:52.220
and for each of them, there are
three ways to choose a girl.

00:04:52.220 --> 00:04:56.670
So there's 4 times 3, or
12, possible boy-girl girl

00:04:56.670 --> 00:04:58.320
couples in this setting.

00:04:58.320 --> 00:05:01.445
More generally, if I
have a set A of size m

00:05:01.445 --> 00:05:06.990
and a set B of size n, then
A cross B-- remember, that's

00:05:06.990 --> 00:05:09.915
the set of ordered pairs where
the first element is from A

00:05:09.915 --> 00:05:14.350
and the second element is
from B-- the size of A cross B

00:05:14.350 --> 00:05:16.180
is-- the vertical
bars, remember,

00:05:16.180 --> 00:05:20.280
mean size-- is
equal to m times n.

00:05:20.280 --> 00:05:23.720
So let's just do an example
that illustrates it.

00:05:23.720 --> 00:05:27.770
Suppose that A is the set
of four elements-- little a,

00:05:27.770 --> 00:05:32.410
b, c, and d-- and B is the set
of three numbers, 1, 2, and 3.

00:05:32.410 --> 00:05:38.610
Then I can list A cross
B in a nice orderly way,

00:05:38.610 --> 00:05:41.850
as a 4-by-3 matrix.

00:05:41.850 --> 00:05:44.580
But this is really meant to
be just a list of elements,

00:05:44.580 --> 00:05:47.590
but I'm organizing this way so
the pattern is more apparent.

00:05:47.590 --> 00:05:53.730
And for each element
little a, I can pair it

00:05:53.730 --> 00:05:56.010
with each of the
three elements in B.

00:05:56.010 --> 00:05:58.760
And for the second
element, little b, in A,

00:05:58.760 --> 00:06:01.220
I can pair it with this
three digits [? in A. ?]

00:06:01.220 --> 00:06:04.770
And c I can pair with three,
and d I can pair with three.

00:06:04.770 --> 00:06:08.130
And that's where the 4 times 3
comes from, and more generally,

00:06:08.130 --> 00:06:10.417
the m times n comes from.

00:06:13.280 --> 00:06:15.700
A useful immediate
application of this

00:06:15.700 --> 00:06:18.440
is, how many binary
strings are there?

00:06:18.440 --> 00:06:22.350
How many strings of zeros and
ones are there of length 4?

00:06:22.350 --> 00:06:25.290
Well, the length
for binary strings,

00:06:25.290 --> 00:06:29.250
it can be explained as well
as the product of B times B

00:06:29.250 --> 00:06:31.950
times B times B. We're not
writing parentheses here.

00:06:31.950 --> 00:06:36.080
It's B times B-- cross B.

00:06:36.080 --> 00:06:38.590
So I'm thinking of a
quadruple like this

00:06:38.590 --> 00:06:43.700
as being a pair whose
first element is a triple.

00:06:43.700 --> 00:06:47.640
And a triple is a pair whose
first element is a pair.

00:06:47.640 --> 00:06:50.140
And given that it doesn't really
matter how you break it up,

00:06:50.140 --> 00:06:51.880
we just typically
write it as B cross

00:06:51.880 --> 00:06:57.520
B cross B, and even abbreviate
that as B to the fourth,

00:06:57.520 --> 00:06:58.930
where b is 0, 1.

00:06:58.930 --> 00:07:01.800
And the Product Rule says
that the size of this

00:07:01.800 --> 00:07:05.300
is the size of B
times the size of B

00:07:05.300 --> 00:07:09.900
times the size of B times the
size of B, or 2 to the fourth.

00:07:09.900 --> 00:07:12.550
So in general, if
I look at strings

00:07:12.550 --> 00:07:18.790
of length n, whose elements
are from an alphabet of size m,

00:07:18.790 --> 00:07:24.870
the total number of such
strings is m to the n.

