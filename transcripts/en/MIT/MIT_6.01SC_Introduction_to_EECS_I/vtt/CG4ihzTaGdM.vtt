WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:02.460
The following content is
provided under a Creative

00:00:02.460 --> 00:00:03.870
Commons license.

00:00:03.870 --> 00:00:06.910
Your support will help MIT
OpenCourseWare continue to

00:00:06.910 --> 00:00:10.560
offer high quality educational
resources for free.

00:00:10.560 --> 00:00:13.460
To make a donation or view
additional materials from

00:00:13.460 --> 00:00:17.390
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.390 --> 00:00:18.640
ocw.mit.edu.

00:00:26.080 --> 00:00:27.330
PROFESSOR: Hello, and welcome.

00:00:31.870 --> 00:00:34.920
Last week we started to think
about programming.

00:00:34.920 --> 00:00:38.550
Programming was the first
module in this class.

00:00:38.550 --> 00:00:40.900
And it was important for
two different reasons.

00:00:40.900 --> 00:00:44.410
First, we're going to use
programming throughout the

00:00:44.410 --> 00:00:49.660
term in the study of all the
different things that we do.

00:00:49.660 --> 00:00:52.540
So it's important that you learn
to program now, just so

00:00:52.540 --> 00:00:56.400
you can use that tool.

00:00:56.400 --> 00:01:00.360
More importantly perhaps, we
didn't just learn how to

00:01:00.360 --> 00:01:05.370
program, we focused on how to
program in a fashion that

00:01:05.370 --> 00:01:08.310
would let us construct
complicated systems out of a

00:01:08.310 --> 00:01:09.420
simpler systems.

00:01:09.420 --> 00:01:12.570
This is the way that we
can manage complexity.

00:01:12.570 --> 00:01:15.340
This is the only possible
way that we can

00:01:15.340 --> 00:01:18.440
make complicated systems.

00:01:18.440 --> 00:01:21.380
So that was the more important
intellectual theme from the

00:01:21.380 --> 00:01:26.040
first part, where we introduced
our mantra, PCAP --

00:01:26.040 --> 00:01:29.650
primitives, means of
combination, abstraction and

00:01:29.650 --> 00:01:31.760
identifying patterns.

00:01:31.760 --> 00:01:36.090
That's the key to this
modular approach to

00:01:36.090 --> 00:01:37.740
hierarchical kind of design.

00:01:40.430 --> 00:01:43.610
Today what I want to do is start
the second major theme.

00:01:43.610 --> 00:01:46.770
First theme was the design of
complex systems, we saw that

00:01:46.770 --> 00:01:49.110
by reference to programming.

00:01:49.110 --> 00:01:51.470
Today we're going to start
thinking about modeling and

00:01:51.470 --> 00:01:52.975
controlling physical systems.

00:01:55.890 --> 00:02:01.080
The idea here is not so much
how you construct systems--

00:02:01.080 --> 00:02:04.430
but we will get back to that.

00:02:04.430 --> 00:02:07.740
The idea is to characterize
the systems that you've

00:02:07.740 --> 00:02:11.280
constructed and say something
about their metrics as being

00:02:11.280 --> 00:02:13.360
positive or negative.

00:02:13.360 --> 00:02:16.205
So what we want to do is, in
fact, focus on behavior.

00:02:19.680 --> 00:02:23.920
So to illustrate that, I'll
start with an example.

00:02:23.920 --> 00:02:26.760
This is an example that you did
in design lab last week,

00:02:26.760 --> 00:02:29.260
or for some of you, yesterday.

00:02:29.260 --> 00:02:34.260
The idea was to program the
robot so that it could sense

00:02:34.260 --> 00:02:36.000
the distance to a wall.

00:02:36.000 --> 00:02:39.435
Represented two ways here,
sort of the view that you

00:02:39.435 --> 00:02:43.050
would get from Soar, and a more
schematic representation

00:02:43.050 --> 00:02:45.820
showing the position of a robot,
the position of a wall.

00:02:45.820 --> 00:02:48.930
The idea is that you can sense
the position to the wall using

00:02:48.930 --> 00:02:50.704
the sonars.

00:02:50.704 --> 00:02:52.940
You know where you would
like to be, because

00:02:52.940 --> 00:02:54.050
some user told you.

00:02:54.050 --> 00:02:57.100
You'd like to be say, half a
meter away from the wall.

00:02:57.100 --> 00:03:01.130
And your job was to write a
program that moves the robot

00:03:01.130 --> 00:03:03.210
from where it is to where
you'd like it to be.

00:03:06.200 --> 00:03:08.835
So here's the kind of behavior
we might have liked--

00:03:11.860 --> 00:03:13.050
so I'll do that again.

00:03:13.050 --> 00:03:17.180
So we might have liked that if
you started here, you have a

00:03:17.180 --> 00:03:21.080
nice smooth progression up to
where you'd like to be.

00:03:21.080 --> 00:03:24.890
Very graceful, ballet type, and
you just sort of smoothly

00:03:24.890 --> 00:03:27.090
glide into the position
that you'd like.

00:03:27.090 --> 00:03:29.700
Some of you probably achieved
that behavior, and some of you

00:03:29.700 --> 00:03:32.850
probably did other things.

00:03:32.850 --> 00:03:36.580
So that might be the
intended behavior.

00:03:36.580 --> 00:03:40.980
One way to achieve the intended
behavior is to use

00:03:40.980 --> 00:03:42.520
what we call a proportional
controller.

00:03:45.410 --> 00:03:50.100
In a proportional controller,
you make the command be, in

00:03:50.100 --> 00:03:55.160
some way, proportionate to
the intended response.

00:03:55.160 --> 00:04:00.070
So imagine this code, which
might establish a class for

00:04:00.070 --> 00:04:03.170
finding the wall.

00:04:03.170 --> 00:04:06.800
So the important thing-- as we
saw, for all state machines,

00:04:06.800 --> 00:04:10.480
the important thing is to define
a start state and a

00:04:10.480 --> 00:04:13.880
getNextValues routine.

00:04:13.880 --> 00:04:17.100
What this getNextValues routine
does is it establishes

00:04:17.100 --> 00:04:21.480
the desired distance to
be a half a meter.

00:04:21.480 --> 00:04:23.900
It figures out the current
distance to the wall by

00:04:23.900 --> 00:04:29.040
reading the sonars, and then
it specifies an action.

00:04:29.040 --> 00:04:33.300
So the first question is what
would you like fvel to be in

00:04:33.300 --> 00:04:37.260
order to make a proportional
controller?

00:04:37.260 --> 00:04:41.020
Which of those expressions
makes sense?

00:04:41.020 --> 00:04:44.130
Take 30 seconds, talk to your
neighbor, figure out some

00:04:44.130 --> 00:04:45.500
answer between (1) and (5).

00:04:45.500 --> 00:04:47.850
I will ask you in 30 seconds to
raise your hand with that

00:04:47.850 --> 00:04:48.530
number of fingers.

00:04:48.530 --> 00:04:49.780
AUDIENCE: [INAUDIBLE]

00:05:58.970 --> 00:06:01.270
PROFESSOR: So what's the right
kind of expression if we

00:06:01.270 --> 00:06:03.030
wanted the controller
to be proportionate?

00:06:03.030 --> 00:06:04.130
Everybody raise your
hand, show me

00:06:04.130 --> 00:06:05.380
some number of fingers.

00:06:07.570 --> 00:06:11.110
OK, the vast majority
is saying (2).

00:06:11.110 --> 00:06:14.690
Everybody likes the idea of
current minus desired.

00:06:14.690 --> 00:06:16.430
Why is that the right answer?

00:06:16.430 --> 00:06:17.960
That is the right answer.

00:06:17.960 --> 00:06:19.840
Why is that the right answer?

00:06:19.840 --> 00:06:22.252
How do you prove that
to somebody?

00:06:22.252 --> 00:06:25.138
AUDIENCE: Well, in current
divided desired, once you meet

00:06:25.138 --> 00:06:27.543
your desired distance, you're
still going to have to

00:06:27.543 --> 00:06:29.467
[UNINTELLIGIBLE] velocity
[UNINTELLIGIBLE], which really

00:06:29.467 --> 00:06:30.440
doesn't make sense
at this point.

00:06:30.440 --> 00:06:31.570
PROFESSOR: Exactly.

00:06:31.570 --> 00:06:35.450
So that method, we might
call extreme cases.

00:06:35.450 --> 00:06:39.120
Think of the simplifying cases
that give you some insight

00:06:39.120 --> 00:06:39.810
into the problem.

00:06:39.810 --> 00:06:43.390
So one simple case is
what if desired and

00:06:43.390 --> 00:06:44.960
current were the same?

00:06:44.960 --> 00:06:47.215
You'd better stop.

00:06:47.215 --> 00:06:49.510
OK, that's a simple case.

00:06:49.510 --> 00:06:52.820
So the simple case says that you
better have one of these--

00:06:52.820 --> 00:06:54.600
whatever the right answer is,
it better have the property

00:06:54.600 --> 00:06:57.610
that when current equals
desired, fvel is 0.

00:06:57.610 --> 00:06:58.890
Otherwise it's not
going to work.

00:06:58.890 --> 00:07:01.530
And in fact, using just that
one simple case, you can

00:07:01.530 --> 00:07:04.310
eliminate all the
ones except (2).

00:07:04.310 --> 00:07:06.080
There are some other simple
cases, what are some other

00:07:06.080 --> 00:07:07.330
simple cases?

00:07:10.137 --> 00:07:10.850
Simple cases.

00:07:10.850 --> 00:07:11.811
Yeah.

00:07:11.811 --> 00:07:14.170
AUDIENCE: currentDistance
greater than desiredDistance?

00:07:14.170 --> 00:07:15.765
PROFESSOR: Current bigger
than desired.

00:07:15.765 --> 00:07:18.010
So if current were bigger, that
would mean that you were

00:07:18.010 --> 00:07:21.590
starting out way over
here someplace.

00:07:21.590 --> 00:07:24.050
So if you were way over there
someplace, you'd want the

00:07:24.050 --> 00:07:26.230
velocity to be positive.

00:07:26.230 --> 00:07:28.590
The forward velocity
should be positive.

00:07:28.590 --> 00:07:32.200
That's how you would
disambiguate the sign.

00:07:32.200 --> 00:07:35.670
Similarly, if the current were
shorter than desired, if you

00:07:35.670 --> 00:07:37.610
were too close to the wall,
you'd like the forward

00:07:37.610 --> 00:07:39.770
velocity to be negative.

00:07:39.770 --> 00:07:41.020
OK.

00:07:41.020 --> 00:07:44.130
So that's the proportional
controller that we'd like.

00:07:44.130 --> 00:07:47.770
So we might fill in our wall
finder class this way.

00:07:50.430 --> 00:07:54.450
And then when we built it, if
things went really well, we

00:07:54.450 --> 00:07:56.920
would get exactly the
behavior we wanted.

00:07:56.920 --> 00:08:00.430
But if things went more
naturally, it wouldn't quite

00:08:00.430 --> 00:08:02.040
work that way, and
you might get a

00:08:02.040 --> 00:08:03.290
different kind of behavior.

00:08:07.130 --> 00:08:07.930
Let's do that again.

00:08:07.930 --> 00:08:11.030
So here is the resulting
behavior for that simple

00:08:11.030 --> 00:08:12.280
controller that I just showed.

00:08:16.310 --> 00:08:21.590
So in some sense, that's
not as good behavior.

00:08:21.590 --> 00:08:23.360
And the way we want to think
about behaviors--

00:08:23.360 --> 00:08:25.120
the way we're going to develop
today, is to think about

00:08:25.120 --> 00:08:29.010
behaviors in terms of signals.

00:08:29.010 --> 00:08:31.130
Plots.

00:08:31.130 --> 00:08:34.679
So the first question is, what
plot best represents the

00:08:34.679 --> 00:08:36.180
behavior that I saw here?

00:08:43.070 --> 00:08:45.330
So which of those plots best
represents that behavior?

00:08:45.330 --> 00:08:47.260
Take 30 seconds, talk to your
neighbor, figure out what's

00:08:47.260 --> 00:08:47.800
the right answer?

00:08:47.800 --> 00:08:49.050
AUDIENCE: [INAUDIBLE]

00:09:46.250 --> 00:09:49.850
PROFESSOR: OK, so which behavior
best represents the

00:09:49.850 --> 00:09:52.650
illustrated cartoon that
I showed previously?

00:09:52.650 --> 00:09:55.573
Raise your hand, show some
number fingers so that I can

00:09:55.573 --> 00:09:57.680
see if you're with it.

00:09:57.680 --> 00:10:02.050
Not all correct, but more
than 90% correct.

00:10:02.050 --> 00:10:04.510
The more than 90% answer
is number (2).

00:10:04.510 --> 00:10:07.200
What's good about number (2)
that's not good about numbers

00:10:07.200 --> 00:10:08.525
(1), (3), and (4)?

00:10:12.846 --> 00:10:14.337
AUDIENCE: The initial
value is different

00:10:14.337 --> 00:10:15.331
than the final value.

00:10:15.331 --> 00:10:16.822
PROFESSOR: Initial
is different.

00:10:16.822 --> 00:10:19.930
So here, I try initial and final
being roughly the same.

00:10:19.930 --> 00:10:22.390
So what's showed here,
is a plot.

00:10:22.390 --> 00:10:24.490
Current distance on
the y-axis, step

00:10:24.490 --> 00:10:26.820
number on the x-axis.

00:10:26.820 --> 00:10:29.270
And so we can see from here--
and the implication of the

00:10:29.270 --> 00:10:31.500
axes, by the way, is 0.

00:10:31.500 --> 00:10:34.970
So the implication of the
vertical axis is it intersects

00:10:34.970 --> 00:10:38.400
this at 0, unless I label
it otherwise.

00:10:38.400 --> 00:10:41.060
And similarly, this horizontal
line intersects the vertical

00:10:41.060 --> 00:10:43.100
at 0 unless I label
it otherwise.

00:10:43.100 --> 00:10:44.830
So that's the point (0, 0).

00:10:44.830 --> 00:10:47.870
So the implication here is that
the initial and the final

00:10:47.870 --> 00:10:51.470
values are the same,
as they are here.

00:10:51.470 --> 00:10:55.467
Here they're not, what makes
(2) better than (1).

00:10:55.467 --> 00:10:56.717
AUDIENCE: [INAUDIBLE]

00:11:00.457 --> 00:11:03.950
the current distance is
decreasing [UNINTELLIGIBLE].

00:11:03.950 --> 00:11:06.350
PROFESSOR: The current distance
starts out bigger

00:11:06.350 --> 00:11:07.710
than it ultimately is.

00:11:07.710 --> 00:11:10.430
So we start out bigger than
the final value, the final

00:11:10.430 --> 00:11:13.510
value is presumably
half a meter.

00:11:13.510 --> 00:11:16.120
We start out roughly
twice that far, and

00:11:16.120 --> 00:11:17.630
then we see some approach.

00:11:17.630 --> 00:11:20.360
The approach is not monotonic.

00:11:20.360 --> 00:11:23.560
So the answer is (2).

00:11:23.560 --> 00:11:27.760
Why do you think
it under-shot?

00:11:27.760 --> 00:11:30.820
So on the way to going from
one to one-half, it

00:11:30.820 --> 00:11:32.180
transiently went through
something

00:11:32.180 --> 00:11:33.030
smaller than one-half.

00:11:33.030 --> 00:11:34.730
Why do you think it did that?

00:11:34.730 --> 00:11:35.710
Yeah.

00:11:35.710 --> 00:11:37.180
AUDIENCE: Because [INAUDIBLE]

00:11:37.180 --> 00:11:39.956
this way, there's a small--
there's a small interval of

00:11:39.956 --> 00:11:41.100
time when its moving at the
velocity where it couldn't

00:11:41.100 --> 00:11:43.060
[INAUDIBLE].

00:11:43.060 --> 00:11:46.060
PROFESSOR: So it's a small
interval of time between when

00:11:46.060 --> 00:11:48.960
it does one thing, and it
does something else.

00:11:48.960 --> 00:11:51.620
When it senses and moves,
for example.

00:11:51.620 --> 00:11:54.100
So there could be a time delay,
in the system and in

00:11:54.100 --> 00:11:56.640
fact, that's true, there
is a time delay.

00:11:56.640 --> 00:12:00.190
So it takes some amount of
time for the sonars to

00:12:00.190 --> 00:12:02.390
register the distance.

00:12:02.390 --> 00:12:05.070
Then it takes some amount of
time for the computer inside

00:12:05.070 --> 00:12:07.640
the robot to register that
the sonar has told

00:12:07.640 --> 00:12:09.060
it something different.

00:12:09.060 --> 00:12:11.800
Than it takes some time from the
time the computer commands

00:12:11.800 --> 00:12:14.630
the wheels until the robot
starts moving.

00:12:14.630 --> 00:12:17.900
All of those cumulative effects
mean that you have the

00:12:17.900 --> 00:12:21.910
potential to overshoot where
you're going, because there's

00:12:21.910 --> 00:12:25.660
delay in the system, there's
inertia in the robot.

00:12:25.660 --> 00:12:28.140
All of those reasons can
lead to overshoot.

00:12:28.140 --> 00:12:32.850
And the point of today is to
figure out some way of

00:12:32.850 --> 00:12:37.460
predicting and correcting
for those kinds

00:12:37.460 --> 00:12:40.970
of unintended behaviors.

00:12:40.970 --> 00:12:45.960
So what we will do then, is
develop an approach focused on

00:12:45.960 --> 00:12:50.390
signals, not systems.

00:12:50.390 --> 00:12:51.850
So, so far, we've been thinking
about how do you

00:12:51.850 --> 00:12:52.470
build the system?

00:12:52.470 --> 00:12:53.720
Now we're going to think
about behavior.

00:12:53.720 --> 00:12:56.550
We're going to think about
analyzing that behavior.

00:12:56.550 --> 00:12:59.890
And the focus is going to be
on what was the input, what

00:12:59.890 --> 00:13:02.300
was desired?

00:13:02.300 --> 00:13:05.680
What was the output,
what was achieved?

00:13:05.680 --> 00:13:09.260
So we're going to be looking
at those output signals in

00:13:09.260 --> 00:13:12.330
order to figure out how
good the behavior was.

00:13:12.330 --> 00:13:16.770
That approach is called the
signals and systems approach.

00:13:16.770 --> 00:13:20.870
The idea is characterize your
system-- whatever that system

00:13:20.870 --> 00:13:23.550
is, a physical system, a
mathematical system, a

00:13:23.550 --> 00:13:27.740
computational system, whatever
it is, think about it by the

00:13:27.740 --> 00:13:33.330
way it transforms an input
signal into an output signal.

00:13:33.330 --> 00:13:36.350
That's kind of a bizarre way
to think about systems.

00:13:36.350 --> 00:13:39.270
So let me just illustrate that
by way of a system that you've

00:13:39.270 --> 00:13:40.590
all seen before.

00:13:40.590 --> 00:13:41.960
OK, here's a simple
system, right?

00:13:41.960 --> 00:13:43.920
You've all seen this, right?

00:13:43.920 --> 00:13:48.420
Anything like 8.01
ring any bells?

00:13:48.420 --> 00:13:51.070
OK, so that's a simple system,
you all know how to solve it.

00:13:51.070 --> 00:13:52.970
There's a gazillion ways
you could solve

00:13:52.970 --> 00:13:54.740
this system, right?

00:13:54.740 --> 00:13:58.220
Free body diagrams, kinetic
energy, potential energy,

00:13:58.220 --> 00:14:00.090
there's a gazillion ways
you could do it.

00:14:00.090 --> 00:14:02.900
You all know how to do it,
that's not the point.

00:14:02.900 --> 00:14:04.490
The point is, that we're going
to learn a different

00:14:04.490 --> 00:14:07.790
way to solve it.

00:14:07.790 --> 00:14:11.090
We're going to think about the
mass and spring system--

00:14:11.090 --> 00:14:14.340
not like potential energy and
kinetic energy, not like free

00:14:14.340 --> 00:14:17.200
body diagrams, we're going to
think about it as transforming

00:14:17.200 --> 00:14:20.440
an input signal into
an output signal.

00:14:20.440 --> 00:14:22.740
So the input signal--

00:14:22.740 --> 00:14:26.510
it's kind of arbitrary what I
use besides the output, but

00:14:26.510 --> 00:14:31.260
clearly the thing I have control
over is my hand.

00:14:31.260 --> 00:14:34.340
So it seems natural to associate
a variable with the

00:14:34.340 --> 00:14:37.920
position of my hand,
that would be x.

00:14:37.920 --> 00:14:41.110
Also it seems natural to
associate a variable with the

00:14:41.110 --> 00:14:44.270
position of the mass, that
could be the output y.

00:14:44.270 --> 00:14:46.580
That's not unique.

00:14:46.580 --> 00:14:50.340
Every time we try to solve a
problem we ask ourselves,

00:14:50.340 --> 00:14:53.630
what's the meaningful input,
what's the meaningful output?

00:14:53.630 --> 00:14:55.880
The meaningful output
could have been the

00:14:55.880 --> 00:14:57.130
force on the spring.

00:15:00.030 --> 00:15:02.840
I'm just sort of arbitrarily
saying for the purpose of my

00:15:02.840 --> 00:15:06.000
analysis, I'm going to consider
the input to be the

00:15:06.000 --> 00:15:08.140
position of the hand,
the output to be the

00:15:08.140 --> 00:15:09.270
position of the mass.

00:15:09.270 --> 00:15:11.700
And I'm going to think about the
mass and spring system as

00:15:11.700 --> 00:15:14.860
a box that transforms
x into y.

00:15:14.860 --> 00:15:17.200
So rather than thinking about
it in terms of free body

00:15:17.200 --> 00:15:19.575
diagrams, and kinetic energy,
and potential energy, I'm

00:15:19.575 --> 00:15:21.960
going to think there's some
input signal x, and there's

00:15:21.960 --> 00:15:24.120
some output signal y.

00:15:24.120 --> 00:15:27.500
And what I'd like to do is
given x, calculate y.

00:15:30.670 --> 00:15:32.830
OK, bizarre, why would
I do that?

00:15:32.830 --> 00:15:35.040
One of the reasons I want to
do that is that it's a very

00:15:35.040 --> 00:15:37.180
general way of thinking
about behaviors.

00:15:39.980 --> 00:15:42.170
It works for the mass and spring
system, it works for

00:15:42.170 --> 00:15:43.980
water tanks.

00:15:43.980 --> 00:15:45.700
What happens if I have
water flowing into

00:15:45.700 --> 00:15:47.103
a tank that's leaky?

00:15:47.103 --> 00:15:49.870
Well, it leaks into another tank
which is leaky, and that

00:15:49.870 --> 00:15:52.110
leaks more.

00:15:52.110 --> 00:15:55.100
Completely different physics.

00:15:55.100 --> 00:15:58.370
Probably wasn't covered
in 8.01.

00:15:58.370 --> 00:16:02.050
Probably is something you
could figure out.

00:16:02.050 --> 00:16:04.820
The point is that from the
signals and systems point of

00:16:04.820 --> 00:16:08.330
view, I'm going to map this
physics, whatever it is, into

00:16:08.330 --> 00:16:11.000
this structure.

00:16:11.000 --> 00:16:14.490
Think about the tank system as
the system that transforms

00:16:14.490 --> 00:16:16.450
some input.

00:16:16.450 --> 00:16:20.550
The input is that there's water
spurting for some small

00:16:20.550 --> 00:16:22.950
interval of time.

00:16:22.950 --> 00:16:26.520
The output is that there's
water coming out.

00:16:26.520 --> 00:16:29.180
And the idea is that I'm going
to characterize the system--

00:16:29.180 --> 00:16:33.080
whatever it is, as the rule
that transforms the input

00:16:33.080 --> 00:16:34.500
signal into the output signal.

00:16:37.070 --> 00:16:38.690
Here's a third example.

00:16:38.690 --> 00:16:42.100
I could think of a cell
phone system.

00:16:42.100 --> 00:16:44.170
Here again, there are very
complicated ways we could

00:16:44.170 --> 00:16:45.960
think about the system, but
I'm going to take the

00:16:45.960 --> 00:16:49.810
particularly simple approach
called signals and systems.

00:16:49.810 --> 00:16:52.300
Then I'm going to characterize
the phone system by the way it

00:16:52.300 --> 00:16:58.580
transforms some input sound
into some output sound.

00:16:58.580 --> 00:17:00.810
And as you can imagine, there's
a way of thinking

00:17:00.810 --> 00:17:03.490
about performance in terms
of that transformation.

00:17:03.490 --> 00:17:08.349
Ideally, we would like this to
bear some resemblance to that.

00:17:08.349 --> 00:17:10.050
So the point then,
is that we're

00:17:10.050 --> 00:17:11.810
going to focus on behaviors.

00:17:11.810 --> 00:17:14.440
And to do so, we're going to
think about the signals and

00:17:14.440 --> 00:17:16.089
systems approach.

00:17:16.089 --> 00:17:19.060
Represent a system, whatever
it is, by the way it

00:17:19.060 --> 00:17:22.569
transforms inputs
into outputs.

00:17:22.569 --> 00:17:24.730
One of the reasons we
like the approach is

00:17:24.730 --> 00:17:25.980
that it's so general.

00:17:28.420 --> 00:17:32.860
So you can use it for virtually
any kind of a system

00:17:32.860 --> 00:17:37.040
for which you can develop a
mathematical underpinning.

00:17:37.040 --> 00:17:39.330
You can use it to analyze
electrical systems, mechanical

00:17:39.330 --> 00:17:41.340
systems, optical systems,
acoustic systems, biological

00:17:41.340 --> 00:17:44.280
systems, financial systems if
you're on the dark side.

00:17:44.280 --> 00:17:51.340
So there's lots of different
kinds of systems that are

00:17:51.340 --> 00:17:52.790
amenable to this kind
of approach.

00:17:55.390 --> 00:17:59.435
Also, this approach has
a nice modularity.

00:18:02.720 --> 00:18:08.020
Having represented a cellphone
by transformation from sound

00:18:08.020 --> 00:18:11.220
in to electromagnetic field out,
as illustrated by this

00:18:11.220 --> 00:18:14.560
cartoon depicting sound going
in and having a radio wave

00:18:14.560 --> 00:18:17.430
transmitting to a tower.

00:18:17.430 --> 00:18:20.480
Then we represent tower to tower
communication some way,

00:18:20.480 --> 00:18:25.210
maybe via an optical fiber,
maybe via a satellite.

00:18:25.210 --> 00:18:28.160
Then tower to cell by the same
kind of reverse transformation

00:18:28.160 --> 00:18:30.440
that we used in the first one.

00:18:30.440 --> 00:18:33.520
We can piece those all together,
we can treat them as

00:18:33.520 --> 00:18:38.100
modules, because each box takes
an input signal and

00:18:38.100 --> 00:18:41.260
makes an output signal.

00:18:41.260 --> 00:18:45.510
The method is oblivious to
the underlying physics.

00:18:45.510 --> 00:18:49.030
That affords us a certain
amount of power.

00:18:49.030 --> 00:18:51.540
And in particular, it's
very modular.

00:18:51.540 --> 00:18:55.860
You can put together modules
that represent very different

00:18:55.860 --> 00:18:57.440
physical substrates.

00:19:00.210 --> 00:19:04.670
That allows us to
go back to PCAP.

00:19:04.670 --> 00:19:06.860
If the underlying
representations for the

00:19:06.860 --> 00:19:11.370
different physical substrates
are the same, we will be able

00:19:11.370 --> 00:19:14.670
to-- and we will over the next
three weeks, develop a bunch

00:19:14.670 --> 00:19:20.450
of techniques for combining
multiple modules into one.

00:19:20.450 --> 00:19:23.780
That provides the same kind of
abstraction and modularity

00:19:23.780 --> 00:19:29.020
that we saw in programming
for the last two weeks.

00:19:29.020 --> 00:19:30.380
So that's the idea.

00:19:30.380 --> 00:19:33.740
What we want to do is represent
a system by the way

00:19:33.740 --> 00:19:38.600
it transforms an input signal
to an output signal.

00:19:38.600 --> 00:19:43.050
There are many different kinds
of inputs and outputs, but a

00:19:43.050 --> 00:19:46.450
fundamental distinction that we
are going to have to make

00:19:46.450 --> 00:19:51.140
is continuous time,
and discrete time.

00:19:51.140 --> 00:19:53.810
This system works in what
we will refer to

00:19:53.810 --> 00:19:55.220
as continuous time.

00:19:55.220 --> 00:19:58.950
Because my position of my hand
is a continuous function of

00:19:58.950 --> 00:20:00.380
the continuous variable, time.

00:20:03.850 --> 00:20:07.120
The robots, by contrast, work
with what we will call,

00:20:07.120 --> 00:20:08.710
discrete time.

00:20:08.710 --> 00:20:10.870
Steps.

00:20:10.870 --> 00:20:13.550
It turns out the math for those
two different approaches

00:20:13.550 --> 00:20:15.280
are very different.

00:20:15.280 --> 00:20:18.450
And we will focus entirely in
this class on discrete time,

00:20:18.450 --> 00:20:21.370
because our area of application
is the robot.

00:20:21.370 --> 00:20:24.450
It's not that continuous is
deeper, or harder, or anything

00:20:24.450 --> 00:20:26.420
like that, it's different.

00:20:26.420 --> 00:20:30.110
So we'll focus on
discrete time.

00:20:30.110 --> 00:20:32.290
And the point of today then,
is to develop some

00:20:32.290 --> 00:20:38.290
representations for signals and
systems of this free time

00:20:38.290 --> 00:20:43.800
nature, that will let us analyze
and predict behaviors

00:20:43.800 --> 00:20:45.890
of systems like the
robot system.

00:20:48.480 --> 00:20:53.320
The first class of methods for
representing such systems is

00:20:53.320 --> 00:20:54.260
difference equations.

00:20:54.260 --> 00:20:57.610
Difference equations are a lot
like differential equations,

00:20:57.610 --> 00:20:59.110
except there's no differentials,
there's

00:20:59.110 --> 00:21:00.690
differences.

00:21:00.690 --> 00:21:06.050
Difference equations are the
discrete time analog of

00:21:06.050 --> 00:21:10.110
differential equations for
continuous time systems.

00:21:10.110 --> 00:21:12.670
Simplest possible
example here.

00:21:12.670 --> 00:21:17.410
Say I have an output y, that for
reasons that I don't care

00:21:17.410 --> 00:21:21.090
about, I know can be represented
as the difference

00:21:21.090 --> 00:21:23.790
between two values
of the input --

00:21:23.790 --> 00:21:26.250
x at time n, and x at
time n minus 1.

00:21:29.220 --> 00:21:33.280
That's a way to represent the
behavior of a system, a

00:21:33.280 --> 00:21:37.710
discrete time system, by using
a difference equation.

00:21:37.710 --> 00:21:39.660
That's in fact, almost
a complete

00:21:39.660 --> 00:21:40.910
description of the system.

00:21:43.990 --> 00:21:46.540
So let me just explain the
way you would use that.

00:21:46.540 --> 00:21:47.870
It's almost-- because
I didn't tell you

00:21:47.870 --> 00:21:49.120
anything about the input.

00:21:52.620 --> 00:21:55.190
I'll tell you something about
the input for the purpose of

00:21:55.190 --> 00:21:57.840
example, where I'll
use the simplest

00:21:57.840 --> 00:21:59.850
possible input I can imagine.

00:21:59.850 --> 00:22:03.990
Something that we'll call
a delta function.

00:22:03.990 --> 00:22:05.460
A delta function is a signal.

00:22:08.660 --> 00:22:10.910
It's a discrete time signal.

00:22:10.910 --> 00:22:14.660
It has the value 1 if the time
index is 0, and has the value

00:22:14.660 --> 00:22:17.330
0 everywhere else.

00:22:17.330 --> 00:22:20.170
It's, in some sense, the
simplest possible signal that

00:22:20.170 --> 00:22:22.600
we could imagine.

00:22:22.600 --> 00:22:24.490
So it's natural to
start there.

00:22:24.490 --> 00:22:26.930
So what I want to do now is
think about if this were a

00:22:26.930 --> 00:22:29.430
characterization of the system,
and if this were the

00:22:29.430 --> 00:22:30.530
input to that system?

00:22:30.530 --> 00:22:31.790
What would the output be?

00:22:31.790 --> 00:22:32.980
That's after all--

00:22:32.980 --> 00:22:35.830
that was the question that
I posed at the beginning.

00:22:35.830 --> 00:22:39.380
We would like to build a
representation for a system so

00:22:39.380 --> 00:22:43.080
that we can predict the output,
given the input.

00:22:43.080 --> 00:22:45.940
So how does that work?

00:22:45.940 --> 00:22:51.120
So given the difference
equation, all we need to do is

00:22:51.120 --> 00:22:52.380
step through it.

00:22:52.380 --> 00:22:53.600
OK, it's trivial.

00:22:53.600 --> 00:22:57.980
We call that analyzing
by step by step.

00:22:57.980 --> 00:23:03.170
So given the difference
equation, given the input

00:23:03.170 --> 00:23:08.080
signal, all we need to do is
sequentially go through the

00:23:08.080 --> 00:23:11.070
different values of n, and think
about the implication of

00:23:11.070 --> 00:23:13.000
the system on that input.

00:23:13.000 --> 00:23:19.300
So if I were to use the value
of n, being minus 1, this

00:23:19.300 --> 00:23:22.240
general form of the difference
equation tells me that the

00:23:22.240 --> 00:23:27.550
minus 1 value of n for the
output is related by this

00:23:27.550 --> 00:23:29.030
difference, with the input.

00:23:29.030 --> 00:23:31.300
So y of minus 1 is x of minus
1 minus x of minus 2.

00:23:33.870 --> 00:23:39.423
Since both of those are 0, it
says that the output at time

00:23:39.423 --> 00:23:41.700
minus 1 is 0.

00:23:41.700 --> 00:23:43.310
Trivial, right?

00:23:43.310 --> 00:23:44.730
Trivial.

00:23:44.730 --> 00:23:47.200
And similarly, we can just
iterate through the solution

00:23:47.200 --> 00:23:48.860
to the whole signal.

00:23:48.860 --> 00:23:53.640
So y of 0 is x of 0 minus
x of minus 1.

00:23:53.640 --> 00:23:57.000
x of 0 is that special
one, that is 1.

00:23:57.000 --> 00:24:01.630
So now we get 1 minus
0, which is 1.

00:24:01.630 --> 00:24:05.280
y of 1 is x of 1 minus x of 0.

00:24:05.280 --> 00:24:08.640
Now the special one is on the
other side of the minus sign,

00:24:08.640 --> 00:24:09.890
so the answer is minus 1.

00:24:13.390 --> 00:24:16.120
y of 2 is x of 2
minus x of 1 --

00:24:16.120 --> 00:24:17.470
they're both 0.

00:24:17.470 --> 00:24:21.400
And in fact, all the answers
from now on are going to be 0.

00:24:21.400 --> 00:24:25.910
So what I just did is a
trivial example of --

00:24:25.910 --> 00:24:30.380
I use a difference equation to
represent a system, and I

00:24:30.380 --> 00:24:33.275
figured out the output signal
from the input signal.

00:24:36.290 --> 00:24:38.840
That's the method
that we call--

00:24:38.840 --> 00:24:41.680
that's the representation for
discrete time systems that we

00:24:41.680 --> 00:24:43.220
refer to as difference
equations.

00:24:43.220 --> 00:24:46.180
Difference equations
are very powerful.

00:24:46.180 --> 00:24:49.570
As we will see, of all the
representations we look at,

00:24:49.570 --> 00:24:52.140
difference equations is the most
compact representation.

00:24:54.650 --> 00:24:57.120
But there are features of other
kinds of representations

00:24:57.120 --> 00:24:58.980
that are also valuable.

00:24:58.980 --> 00:25:00.560
So the next representation
I want to look

00:25:00.560 --> 00:25:01.810
at is a block diagram.

00:25:04.280 --> 00:25:09.130
What I'm trying to show here is
a picture, a diagram, that

00:25:09.130 --> 00:25:11.900
represents the same system that
we just analyzed with

00:25:11.900 --> 00:25:15.100
difference equations.

00:25:15.100 --> 00:25:17.380
Here though, I'm thinking
about it as

00:25:17.380 --> 00:25:20.350
a signal flow path.

00:25:20.350 --> 00:25:23.620
I'm thinking about what's the
cascade of operations that you

00:25:23.620 --> 00:25:29.540
need to do on each sample in
order to get from the input to

00:25:29.540 --> 00:25:31.860
the output?

00:25:31.860 --> 00:25:34.520
So the difference equation said
every value of the output

00:25:34.520 --> 00:25:36.200
should be equal to the
corresponding value of the

00:25:36.200 --> 00:25:40.950
input less the value
before that.

00:25:40.950 --> 00:25:44.110
I represent that in a block
diagram by saying there's a

00:25:44.110 --> 00:25:46.660
straight through path, y of
n is equal to x of n.

00:25:46.660 --> 00:25:51.060
The plus just adds the signals
on these two paths.

00:25:51.060 --> 00:25:53.360
So y of n is equal to x of n.

00:25:53.360 --> 00:25:56.770
Subtract out, because I'm
multiplying by minus 1.

00:25:56.770 --> 00:26:00.880
Delay, so I'm getting
the one from before.

00:26:00.880 --> 00:26:03.660
So this block diagram just is
a symbolic representation of

00:26:03.660 --> 00:26:04.910
that difference equation.

00:26:07.300 --> 00:26:08.770
The value of the
block diagram--

00:26:08.770 --> 00:26:11.490
we'll see several of them,
but one of them is focus

00:26:11.490 --> 00:26:13.180
on signal flow path.

00:26:13.180 --> 00:26:17.640
If you want to visualize the
transformation from input to

00:26:17.640 --> 00:26:23.990
output, the block diagram can
provide visual insight into

00:26:23.990 --> 00:26:27.350
what that transformation
is like.

00:26:27.350 --> 00:26:30.950
So as before, if I gave you
this representation rather

00:26:30.950 --> 00:26:33.720
than the difference equation,
you could still step by step

00:26:33.720 --> 00:26:35.280
and figure out the
way it worked.

00:26:35.280 --> 00:26:36.880
It's still easy.

00:26:36.880 --> 00:26:39.040
There's one new caveat here.

00:26:39.040 --> 00:26:44.130
We have to start the
system in a state.

00:26:44.130 --> 00:26:47.130
The state that we will usually
talk about is what we will

00:26:47.130 --> 00:26:48.880
call, at rest.

00:26:48.880 --> 00:26:54.560
At rest just means all the
outputs of all the delays are

00:26:54.560 --> 00:26:55.810
initially 0.

00:26:58.290 --> 00:27:01.130
So that specifies the state of
the system at the time the

00:27:01.130 --> 00:27:04.280
signal was turned on.

00:27:04.280 --> 00:27:07.000
So the system is at rest,
which means that all the

00:27:07.000 --> 00:27:10.440
delays start out with
output equal to 0.

00:27:10.440 --> 00:27:16.530
So at rest means this delay
has an output of 0.

00:27:16.530 --> 00:27:20.390
Well, if I tell you the output
is 0 times 0 for this delay,

00:27:20.390 --> 00:27:23.210
then it's a simple matter of
stepping through what is the

00:27:23.210 --> 00:27:25.710
output for each corresponding
input?

00:27:25.710 --> 00:27:27.420
So if I--

00:27:27.420 --> 00:27:29.930
the special value of the delta
function is that it's

00:27:29.930 --> 00:27:31.910
1 at the time 0.

00:27:31.910 --> 00:27:35.190
So at the time 0, there's
1 coming in.

00:27:35.190 --> 00:27:38.700
That 1 makes it through
the adder, adds to 0.

00:27:38.700 --> 00:27:42.210
Well, this is 0 because
it was at rest.

00:27:42.210 --> 00:27:44.775
So the 1 adds to 0 and
the output becomes 1.

00:27:47.950 --> 00:27:50.750
Notice that the 1 also goes
down this path, and goes

00:27:50.750 --> 00:27:54.442
through the gain of minus
1 to give me minus 1.

00:27:54.442 --> 00:27:57.520
But I'm in step 0.

00:27:57.520 --> 00:28:03.730
So at step 0, the output of the
delay is 0, not minus 1.

00:28:03.730 --> 00:28:08.880
So the output then, for time
equals 0, is y equals 1.

00:28:08.880 --> 00:28:10.450
Just like we solved for the
difference equation--

00:28:10.450 --> 00:28:13.250
after all, I'm hypothesizing
that those two systems are the

00:28:13.250 --> 00:28:15.940
same, they better give
me the same answer.

00:28:15.940 --> 00:28:23.000
So then at the next instant, as
the time index goes from 0

00:28:23.000 --> 00:28:26.310
to 1, two things happen.

00:28:26.310 --> 00:28:31.130
The input goes from
1 to 0, and the

00:28:31.130 --> 00:28:32.820
delay box gets updated.

00:28:32.820 --> 00:28:36.470
The delay is now reporting
to me the value

00:28:36.470 --> 00:28:38.780
that was at its input.

00:28:38.780 --> 00:28:42.180
So the output of the delay,
which had been 0 because it

00:28:42.180 --> 00:28:44.170
was at rest, becomes minus 1.

00:28:48.690 --> 00:28:50.940
So then what happens?

00:28:50.940 --> 00:28:56.300
The 1 goes to 0, the 0 goes to
minus 1, the 0 adds to minus

00:28:56.300 --> 00:29:00.130
1, and we get an answer
which is minus 1.

00:29:05.010 --> 00:29:09.390
Then the input becomes 0.

00:29:09.390 --> 00:29:12.120
That 0 comes down here,
the minus 1 goes to 0.

00:29:12.120 --> 00:29:15.290
We end up with 0 being added to
0, and the next answer is

00:29:15.290 --> 00:29:18.360
0, et cetera.

00:29:18.360 --> 00:29:21.620
So the idea then, is that you
can step through the block

00:29:21.620 --> 00:29:23.610
diagram representation, just
like you would a difference

00:29:23.610 --> 00:29:26.230
equation, it's just that now
we're thinking about these

00:29:26.230 --> 00:29:31.270
blocks characterizing the
system, rather than thinking

00:29:31.270 --> 00:29:34.745
of math as characterizing
the system.

00:29:37.690 --> 00:29:41.080
Why on earth would
you do that?

00:29:41.080 --> 00:29:42.720
What's good and bad?

00:29:42.720 --> 00:29:46.350
What's the relative merits of
difference equations verses

00:29:46.350 --> 00:29:48.230
block diagrams?

00:29:48.230 --> 00:29:50.830
Take 30 seconds, talk to your
neighbor, figure out some good

00:29:50.830 --> 00:29:51.790
feature of each.

00:29:51.790 --> 00:29:53.040
AUDIENCE: [INAUDIBLE]

00:31:16.200 --> 00:31:18.060
PROFESSOR: OK, we'll start
with the easy one.

00:31:18.060 --> 00:31:20.340
What's a feature, what's a
property of the difference

00:31:20.340 --> 00:31:22.421
equation that makes
it very good.

00:31:22.421 --> 00:31:25.367
I already said it, so.

00:31:25.367 --> 00:31:26.840
What's good about the
difference equation?

00:31:26.840 --> 00:31:27.822
Yeah.

00:31:27.822 --> 00:31:30.280
AUDIENCE: They can be solved
mathematically.

00:31:30.280 --> 00:31:33.780
PROFESSOR: They can be solved
mathematically.

00:31:33.780 --> 00:31:36.300
The block diagram could
be solved, maybe not

00:31:36.300 --> 00:31:38.350
mathematically, but kind of.

00:31:38.350 --> 00:31:40.250
Could you refine that
a little more?

00:31:40.250 --> 00:31:42.730
What's special about difference
equations that's

00:31:42.730 --> 00:31:44.045
different from block diagrams?

00:31:47.698 --> 00:31:51.020
Oh come on, I said it.

00:31:51.020 --> 00:31:51.680
AUDIENCE: Use math?

00:31:51.680 --> 00:31:54.013
PROFESSOR: They use
math, yes yes.

00:31:54.013 --> 00:31:57.380
They're concise, a
little, right?

00:31:57.380 --> 00:32:00.410
It's a very simple expression
to say that.

00:32:00.410 --> 00:32:03.710
It's by contrast, a bit more
complicated to draw this

00:32:03.710 --> 00:32:04.290
picture, right?

00:32:04.290 --> 00:32:06.450
It's mathematically
concise, right?

00:32:06.450 --> 00:32:08.500
It's completely accurate,

00:32:08.500 --> 00:32:14.070
self-contained, concise, small.

00:32:14.070 --> 00:32:17.370
It's a very concise
representation of a system.

00:32:17.370 --> 00:32:19.210
So why would we want to
use block diagrams?

00:32:19.210 --> 00:32:21.630
Can anybody think of any good
reason for block diagrams

00:32:21.630 --> 00:32:24.965
other than Freeman's up front
saying, do block diagrams?

00:32:24.965 --> 00:32:26.360
AUDIENCE: Electrical
engineering?

00:32:26.360 --> 00:32:28.685
PROFESSOR: Electrical
engineering.

00:32:28.685 --> 00:32:31.980
There should be a deeper
reason, I would hope.

00:32:31.980 --> 00:32:33.300
I don't disagree with
that reason.

00:32:36.270 --> 00:32:39.200
Why do electrical engineers
like this?

00:32:39.200 --> 00:32:40.120
Yes.

00:32:40.120 --> 00:32:42.880
AUDIENCE: It's a more physical
representation of this.

00:32:42.880 --> 00:32:44.980
PROFESSOR: It's more physical?

00:32:44.980 --> 00:32:47.207
Is there anything that
you can see that you

00:32:47.207 --> 00:32:48.457
can't see in math?

00:32:52.900 --> 00:32:54.385
Yes.

00:32:54.385 --> 00:32:56.035
AUDIENCE: In the way that you're
actually going to be

00:32:56.035 --> 00:32:56.365
programming it.

00:32:56.365 --> 00:32:59.335
Like, you're gonna make the
delay machine, you're gonna

00:32:59.335 --> 00:33:01.810
make the state machine that
multiplies them by negative 1

00:33:01.810 --> 00:33:03.790
and you're gonna see how
to connect them.

00:33:03.790 --> 00:33:05.275
PROFESSOR: That's a
really good point.

00:33:05.275 --> 00:33:10.770
It's kind of isomorphic
to the implementation.

00:33:10.770 --> 00:33:12.630
Everybody get that?

00:33:12.630 --> 00:33:14.850
It's kind of a picture
of the way you

00:33:14.850 --> 00:33:18.100
would build the system.

00:33:18.100 --> 00:33:21.130
Along those lines, there's
some bit of information--

00:33:21.130 --> 00:33:23.140
there's actually more
information in this one, than

00:33:23.140 --> 00:33:25.346
there is in that one.

00:33:25.346 --> 00:33:31.690
There is exactly one bit more
information in the block

00:33:31.690 --> 00:33:32.940
diagram, what's that bit?

00:33:38.520 --> 00:33:39.876
AUDIENCE: Delay?

00:33:39.876 --> 00:33:41.870
PROFESSOR: Delay?

00:33:41.870 --> 00:33:44.960
There's kind of delay
by the n minus 1.

00:33:44.960 --> 00:33:46.274
Yeah.

00:33:46.274 --> 00:33:47.524
AUDIENCE: [UNINTELLIGIBLE]

00:33:49.648 --> 00:33:52.540
PROFESSOR: The input and
output are explicit.

00:33:52.540 --> 00:33:53.986
Yes.

00:33:53.986 --> 00:33:58.980
The arrows are the
big difference.

00:33:58.980 --> 00:34:01.920
You can't tell from the
difference equation, what's

00:34:01.920 --> 00:34:05.470
the input and the output?

00:34:05.470 --> 00:34:08.020
You can tell from the block
diagram, what is the input and

00:34:08.020 --> 00:34:12.080
the output by the direction
of the arrows.

00:34:12.080 --> 00:34:14.205
So there's more information
in the block diagram.

00:34:17.870 --> 00:34:19.949
There's another way of thinking
about it, and this is

00:34:19.949 --> 00:34:21.929
kind of a summary of several
comments that

00:34:21.929 --> 00:34:23.540
came from the audience.

00:34:23.540 --> 00:34:25.860
The difference equation
is declarative.

00:34:25.860 --> 00:34:29.555
It tells you a true statement
about what the system will do.

00:34:32.820 --> 00:34:35.790
The block diagram
is imperative.

00:34:35.790 --> 00:34:39.909
It tells you what to do now.

00:34:39.909 --> 00:34:41.630
Take the input, put
into an adder.

00:34:41.630 --> 00:34:43.370
Take the input, multiply
by minus 1.

00:34:43.370 --> 00:34:44.239
Put it into a delay.

00:34:44.239 --> 00:34:46.530
Take the delay output,
put it into an adder.

00:34:46.530 --> 00:34:52.120
The representation with a block
diagram is imperative.

00:34:52.120 --> 00:34:54.889
It tells you what to do.

00:34:54.889 --> 00:34:58.400
So there's extra information,
but it comes at a cost.

00:34:58.400 --> 00:35:00.250
It's a more complicated
representation.

00:35:00.250 --> 00:35:06.820
It's a whole picture instead
of just an equation.

00:35:06.820 --> 00:35:09.260
What we'd like to do, and what
I'm going to do now, is

00:35:09.260 --> 00:35:11.980
develop a different mathematical
approach where

00:35:11.980 --> 00:35:18.050
you get a difference equation
that has the same properties

00:35:18.050 --> 00:35:24.880
of concision, the same
conciseness, but also contains

00:35:24.880 --> 00:35:28.860
all of the information that
was in the block diagram.

00:35:28.860 --> 00:35:32.390
And the way to do that is
to change our focus.

00:35:34.960 --> 00:35:38.940
And this is the big abstraction
of the day.

00:35:38.940 --> 00:35:43.370
Change our focus from thinking
about samples, to thinking

00:35:43.370 --> 00:35:45.430
about signals.

00:35:45.430 --> 00:35:50.340
Stop thinking about x of n,
start thinking about the

00:35:50.340 --> 00:35:53.310
input signal x.

00:35:53.310 --> 00:35:58.360
This is the same kind of
lumping that was key to

00:35:58.360 --> 00:36:01.770
abstraction in Python.

00:36:01.770 --> 00:36:04.390
Put all the interesting data
together into a list, put all

00:36:04.390 --> 00:36:07.620
the interesting operations
together into a definition.

00:36:07.620 --> 00:36:10.520
Here put all of the interesting
samples together

00:36:10.520 --> 00:36:13.890
into one signal.

00:36:13.890 --> 00:36:17.980
So what we want to do, is
develop a math by which we can

00:36:17.980 --> 00:36:22.570
operate on signals instead
of samples.

00:36:22.570 --> 00:36:26.500
So what I'm going to do is
replace the representation x

00:36:26.500 --> 00:36:31.180
of n, little x of n, with cap-X.
Cap-X means, all of the

00:36:31.180 --> 00:36:36.830
n's, it's the signal X. Cap-Y
means the signal Y. And I'm

00:36:36.830 --> 00:36:38.300
going to reinterpret
all the boxes.

00:36:41.860 --> 00:36:46.370
This box means, take this
signal, the whole thing, all n

00:36:46.370 --> 00:36:51.660
values on it, multiply it sample
by sample, by minus 1.

00:36:51.660 --> 00:36:55.710
Flip the whole signal
upside down.

00:36:55.710 --> 00:36:58.240
So I'm going to reinterpret all
of the operations on the

00:36:58.240 --> 00:37:02.220
block diagram in terms of
signals, rather than samples.

00:37:05.700 --> 00:37:07.910
To do that, I need a
representation--

00:37:07.910 --> 00:37:12.610
a mathematical representation,
for the delay box.

00:37:12.610 --> 00:37:17.730
And I'm going to call that R,
the right shift operator.

00:37:17.730 --> 00:37:22.700
If you apply the right shift
operator to a single X, it

00:37:22.700 --> 00:37:27.040
takes the whole signal X and
shifts it to the right one.

00:37:27.040 --> 00:37:29.830
That's all it does.

00:37:29.830 --> 00:37:35.220
So I'm going to say Y equals
R applied to X, or more

00:37:35.220 --> 00:37:37.970
abbreviated, RX.

00:37:37.970 --> 00:37:42.760
Simply says, let Y represent the
signal that is the same as

00:37:42.760 --> 00:37:45.190
X, except every sample was
shifted to the right.

00:37:45.190 --> 00:37:48.890
The entire signal was shifted
to the right.

00:37:48.890 --> 00:37:50.990
That's going to let me
represent this block

00:37:50.990 --> 00:37:54.680
diagram this way.

00:37:54.680 --> 00:37:56.570
Y--

00:37:56.570 --> 00:38:01.690
the whole signal Y, is the sum
of the whole signal X,

00:38:01.690 --> 00:38:10.970
subtract out R applied to X.
Or, even more concisely,

00:38:10.970 --> 00:38:20.140
calculate Y by applying to
X the operator 1 minus R.

00:38:20.140 --> 00:38:21.950
So I'm thinking now
of an operator.

00:38:21.950 --> 00:38:26.760
An operator is not something
that works on a number.

00:38:26.760 --> 00:38:31.730
Operations work on numbers,
operators operate on signals.

00:38:31.730 --> 00:38:33.880
So I'm thinking about
operator expression.

00:38:33.880 --> 00:38:37.730
I'm going to try to formulate
the transformation from the

00:38:37.730 --> 00:38:42.150
input to the output in
terms of operators.

00:38:42.150 --> 00:38:46.300
The way I take X, which is the
input, and turn it into Y, is

00:38:46.300 --> 00:38:53.480
to operate on it with the
operator 1 minus R.

00:38:53.480 --> 00:38:57.110
OK, just to see that you're with
me, connecting signals

00:38:57.110 --> 00:39:00.770
and samples, assume the
Y is RX, which of the

00:39:00.770 --> 00:39:03.700
following is also true?

00:39:03.700 --> 00:39:05.020
Take 30 seconds, talk
to your neighbor.

00:39:05.020 --> 00:39:06.755
Figure out some number
-- (1) through (5).

00:39:06.755 --> 00:39:08.005
AUDIENCE: [INAUDIBLE]

00:41:33.350 --> 00:41:36.980
PROFESSOR: OK, so which
representation works best?

00:41:36.980 --> 00:41:39.882
(1), (2), (3), (4), or
none of the above?

00:41:39.882 --> 00:41:41.754
Everybody raise a hand,
tell me some number.

00:41:45.030 --> 00:41:47.150
OK, virtually 100% correct.

00:41:47.150 --> 00:41:51.750
The answer was (2), why
is the answer (2)?

00:41:51.750 --> 00:41:53.225
Can somebody explain
that concisely?

00:41:57.636 --> 00:41:58.480
No no,no.

00:41:58.480 --> 00:42:00.170
I asked that wrong, of
course everybody

00:42:00.170 --> 00:42:01.410
can explain it concisely.

00:42:01.410 --> 00:42:03.730
Do I have a volunteer to
explain it concisely?

00:42:08.326 --> 00:42:09.254
Yes.

00:42:09.254 --> 00:42:12.760
AUDIENCE: The R operator just
shifts all of the values in X

00:42:12.760 --> 00:42:14.072
of n to the right.

00:42:14.072 --> 00:42:17.030
So you just add 1 to each
of these basically?

00:42:17.030 --> 00:42:19.000
PROFESSOR: So you think about
it-- so a good way to think

00:42:19.000 --> 00:42:22.070
about this is to think
about simple cases.

00:42:22.070 --> 00:42:22.450
Right?

00:42:22.450 --> 00:42:24.870
That's the same thing I
talked about earlier.

00:42:24.870 --> 00:42:26.000
What's a simple case?

00:42:26.000 --> 00:42:28.030
Well what if X--

00:42:28.030 --> 00:42:32.220
let's imagine that
X is simple.

00:42:32.220 --> 00:42:36.720
So let's say that X
looks like that.

00:42:36.720 --> 00:42:40.340
So X is delta.

00:42:40.340 --> 00:42:43.510
What would happen, what
is the signal RX?

00:42:48.250 --> 00:42:49.845
It's a right shift operator.

00:42:49.845 --> 00:42:51.888
So what does the signal
RX look like?

00:42:55.030 --> 00:42:57.090
Shifted to the right, right?

00:42:57.090 --> 00:42:58.600
That's the whole point.

00:42:58.600 --> 00:43:04.660
So the right shift operator
gives you that signal, and

00:43:04.660 --> 00:43:13.250
we've said that that's Y. So is
it true that Y of n is X of

00:43:13.250 --> 00:43:16.330
n, for all n?

00:43:16.330 --> 00:43:17.790
No.

00:43:17.790 --> 00:43:20.440
Is it true that Y of (n
plus 1) is equal to X

00:43:20.440 --> 00:43:22.560
of n for all n?

00:43:22.560 --> 00:43:24.075
Well, is it true
for n equals 0?

00:43:32.940 --> 00:43:41.170
So if we did n equals 0 we get Y
of 1, which happens to be 1.

00:43:41.170 --> 00:43:43.645
And X of 0, which also
happens to be 1.

00:43:46.380 --> 00:43:50.890
And if we choose any other
n, we would get two 0's.

00:43:50.890 --> 00:43:54.100
So at least for this simple
case, and it seems to be true,

00:43:54.100 --> 00:43:58.510
and if you think about building
upon this simple

00:43:58.510 --> 00:44:00.480
case, you can convince yourself
that number (2) is

00:44:00.480 --> 00:44:01.450
always true.

00:44:01.450 --> 00:44:04.970
And in fact, the general rule
is going to be that the left

00:44:04.970 --> 00:44:07.910
hand side has to have a number
that's bigger than

00:44:07.910 --> 00:44:10.680
the right hand side.

00:44:10.680 --> 00:44:12.270
Which is only true
for number (2).

00:44:15.670 --> 00:44:20.420
So the idea then, is that by
changing our focus, by looking

00:44:20.420 --> 00:44:24.020
not at samples, but looking
instead at signals, we can

00:44:24.020 --> 00:44:29.520
generate an algebra that looks
for all the world like

00:44:29.520 --> 00:44:31.410
difference equations.

00:44:31.410 --> 00:44:35.940
Except it knows the direction
from the input to the output.

00:44:35.940 --> 00:44:39.210
So it's more powerful.

00:44:39.210 --> 00:44:42.890
And in fact, this new algebra
is going to obey some very

00:44:42.890 --> 00:44:47.920
simple properties which we
can get a hint at here.

00:44:47.920 --> 00:44:51.180
If we were to cascade two
systems, imagine this system

00:44:51.180 --> 00:44:53.930
which looks just like the system
we've been looking at,

00:44:53.930 --> 00:44:57.610
but it's cascaded
with a clone.

00:44:57.610 --> 00:44:59.845
The question is, what would be
the behavior of that cascade?

00:45:02.350 --> 00:45:06.250
Well, according to our operator
representation, this

00:45:06.250 --> 00:45:15.600
Y1 signal is just the 1 minus
R operator applied to X.

00:45:15.600 --> 00:45:20.990
Analogously, the Y2 signal
should be a similar 1 minus R

00:45:20.990 --> 00:45:26.540
operator applied to the Y1
signal, which gives us a very

00:45:26.540 --> 00:45:29.065
concise representation
for the cascade.

00:45:31.800 --> 00:45:34.880
The point of the slide is that
the operator representation

00:45:34.880 --> 00:45:38.280
gives us a representation that
is just as compact as

00:45:38.280 --> 00:45:39.530
difference equations.

00:45:41.970 --> 00:45:46.050
It has other features, that it
can be manipulated just like

00:45:46.050 --> 00:45:48.910
difference equations.

00:45:48.910 --> 00:45:52.070
So if we continue with this same
example and try to think

00:45:52.070 --> 00:45:57.850
of the transformation on a
sample level, we could say

00:45:57.850 --> 00:46:05.585
that Y2 is Y1, the straight
path, minus Y1 delayed.

00:46:08.160 --> 00:46:12.510
But then we could substitute for
Y1 of n, that Y1 of n is X

00:46:12.510 --> 00:46:19.980
of n, this path, subtract
X of (n minus 1).

00:46:19.980 --> 00:46:24.370
Similarly, collapse, and we
get a simple expression.

00:46:27.340 --> 00:46:29.640
Now if we think about that same
sequence of operations in

00:46:29.640 --> 00:46:36.090
operator notation, we get a
much simpler expression.

00:46:36.090 --> 00:46:42.080
Throw away the index arithmetic,
it's just R. So

00:46:42.080 --> 00:46:47.970
the Y2 operator is 1 minus R
applied to the Y1 signal.

00:46:47.970 --> 00:46:51.870
The Y1 signal is 1 minus R
applied to the X signal.

00:46:51.870 --> 00:46:57.180
The total is 1 minus R the
operator squared, which by

00:46:57.180 --> 00:47:02.320
polynomial math is just 1 minus
2R plus R squared, the

00:47:02.320 --> 00:47:04.870
same thing we got there.

00:47:04.870 --> 00:47:08.560
The point is, the operator
notation is just as compact as

00:47:08.560 --> 00:47:10.515
the difference equation
representation.

00:47:13.400 --> 00:47:14.835
And it contains all
the information

00:47:14.835 --> 00:47:18.110
that's in block diagrams.

00:47:18.110 --> 00:47:23.410
And it's just as easy to
manipulate as a polynomial.

00:47:23.410 --> 00:47:27.630
So it's got lots of features
that make it superior to

00:47:27.630 --> 00:47:30.450
difference equations.

00:47:30.450 --> 00:47:34.550
The most important of which,
is you will be able to

00:47:34.550 --> 00:47:39.670
understand all systems that we
represent using the R operator

00:47:39.670 --> 00:47:41.970
using polynomial arithmetic,
something you

00:47:41.970 --> 00:47:44.870
learned in high school.

00:47:44.870 --> 00:47:47.300
There's nothing new here.

00:47:47.300 --> 00:47:48.290
That's what we like.

00:47:48.290 --> 00:47:53.160
Representations that simplify
the task of finding an answer.

00:47:53.160 --> 00:47:56.500
We'll be able to find the
answer to these operator

00:47:56.500 --> 00:47:58.640
expressions by treating
them as polynomials.

00:48:04.010 --> 00:48:06.560
So you can get a feeling for the
way that works by looking

00:48:06.560 --> 00:48:07.650
here, the power of this.

00:48:07.650 --> 00:48:10.580
So the power here is that, among
other things, you'll be

00:48:10.580 --> 00:48:15.530
able to use the operator
representation to prove

00:48:15.530 --> 00:48:18.050
equivalences.

00:48:18.050 --> 00:48:21.010
The idea is that here's a
system that we looked at

00:48:21.010 --> 00:48:26.750
before, that was the cascade of
two simple delay systems.

00:48:26.750 --> 00:48:31.980
Here's a somewhat more
complicated, somewhat simpler,

00:48:31.980 --> 00:48:34.890
representation.

00:48:34.890 --> 00:48:38.520
The point is, it's different.

00:48:38.520 --> 00:48:41.490
And if we compare the operator
representations for the two,

00:48:41.490 --> 00:48:44.660
we see that they are the same.

00:48:44.660 --> 00:48:47.530
And what I'm about to prove,
is that when the operator

00:48:47.530 --> 00:48:51.120
representations are the same,
the systems represent the same

00:48:51.120 --> 00:48:51.940
transformations--

00:48:51.940 --> 00:48:54.910
provided they all
start at rest.

00:48:54.910 --> 00:48:57.100
The provided is important.

00:48:57.100 --> 00:49:01.160
Obviously since they have
different delays in them, if

00:49:01.160 --> 00:49:06.090
the delays didn't all start out
at 0, the differences in

00:49:06.090 --> 00:49:08.890
the delays could propagate
into the output.

00:49:08.890 --> 00:49:11.880
So all of the statements that
I'm making are premised on the

00:49:11.880 --> 00:49:13.455
idea of initial rest.

00:49:16.580 --> 00:49:19.680
The other important thing to
remember about operators is

00:49:19.680 --> 00:49:24.510
that it's a higher level
of abstraction.

00:49:24.510 --> 00:49:28.450
We can think about the operator
as composing things,

00:49:28.450 --> 00:49:30.950
but the things that are composed
are whole signals,

00:49:30.950 --> 00:49:32.220
not samples.

00:49:32.220 --> 00:49:34.200
And here's an illustration of
how to think about that

00:49:34.200 --> 00:49:36.150
previous example.

00:49:36.150 --> 00:49:38.740
How do you think about this
transformation, 1 minus 2R

00:49:38.740 --> 00:49:40.710
plus R squared.

00:49:40.710 --> 00:49:43.730
What happens when you apply
that operator to an

00:49:43.730 --> 00:49:45.830
input signal X?

00:49:45.830 --> 00:49:50.020
Well let's say that X was
our unit sample signal.

00:49:50.020 --> 00:49:53.570
In order to apply this operator
1 minus 2R plus R

00:49:53.570 --> 00:49:56.960
squared, all we need to do is
think about each component.

00:49:56.960 --> 00:50:03.120
1 times X is X. Minus 2R applied
to X is minus 2RX.

00:50:03.120 --> 00:50:07.790
Plus R squared X is just plus
R squared X. So we start out

00:50:07.790 --> 00:50:12.170
with X, which is a unit sample,
minus 2RX means shift

00:50:12.170 --> 00:50:16.540
it to the right and multiply
by minus 2.

00:50:16.540 --> 00:50:21.390
Shift it to the right,
multiply by minus 2.

00:50:21.390 --> 00:50:26.050
Plus R squared X means shift
it twice to the right.

00:50:26.050 --> 00:50:30.430
So the result, this operator
1 minus 2R plus R squared

00:50:30.430 --> 00:50:33.230
applied to X is just the
sum of these things.

00:50:33.230 --> 00:50:36.410
So you can think about the
operator expression, it's just

00:50:36.410 --> 00:50:40.680
like algebra, except that
the elements are

00:50:40.680 --> 00:50:42.110
signals, not samples.

00:50:46.200 --> 00:50:49.220
And as I alluded previously,
you can make powerful

00:50:49.220 --> 00:50:52.680
statements about the way these
operators work which map

00:50:52.680 --> 00:50:57.100
isomorphically onto
polynomial math.

00:50:57.100 --> 00:51:01.160
So for example, it's easy to
prove that if you were to

00:51:01.160 --> 00:51:10.130
cascade the 1 minus R operator
with R. So start with X, apply

00:51:10.130 --> 00:51:20.580
1 minus R. Start with X, apply
1 minus R. Then apply R.

00:51:20.580 --> 00:51:24.210
That's going to result in the
same signal, assuming initial

00:51:24.210 --> 00:51:29.390
rest, as if you were to
flip those operators.

00:51:29.390 --> 00:51:34.540
The way I can see that is by
thinking about signal flow.

00:51:34.540 --> 00:51:36.780
You'll remember that I said,
one of the features, one of

00:51:36.780 --> 00:51:39.610
the powers of the block diagram
representation is that

00:51:39.610 --> 00:51:42.100
we can look at signal
flow paths.

00:51:42.100 --> 00:51:45.920
We can use that as a way
of proving things.

00:51:45.920 --> 00:51:48.750
This system has two signal flow
paths, the one that goes

00:51:48.750 --> 00:51:52.010
straight through that way, and
the one that goes down this

00:51:52.010 --> 00:51:53.260
way and up that way.

00:51:56.240 --> 00:51:59.370
Because of the addition, all it
does-- the adder just adds

00:51:59.370 --> 00:52:01.390
the result of those
two flow paths.

00:52:01.390 --> 00:52:04.960
So the first flow path
introduces one delay, the

00:52:04.960 --> 00:52:09.620
second flow path inverts
and puts in two delays.

00:52:09.620 --> 00:52:13.910
So there are two ways to get
from the input to the output.

00:52:13.910 --> 00:52:16.420
Similarly here, there are two
ways to get from the input to

00:52:16.420 --> 00:52:17.100
the output.

00:52:17.100 --> 00:52:19.450
One of them goes through a delay
and then goes through

00:52:19.450 --> 00:52:21.480
the adder, the other
goes through two

00:52:21.480 --> 00:52:23.840
delays at a minus 1.

00:52:23.840 --> 00:52:26.480
But that's the same two
signal paths that

00:52:26.480 --> 00:52:28.130
were in the top one.

00:52:28.130 --> 00:52:31.150
So that's a way of using the
block diagram to prove a

00:52:31.150 --> 00:52:33.890
relationship about
the operator.

00:52:33.890 --> 00:52:38.040
What I've just showed, is
that the operators obey

00:52:38.040 --> 00:52:40.180
commutativity.

00:52:40.180 --> 00:52:42.780
So what I was able to show is
that I can commute these two

00:52:42.780 --> 00:52:43.940
operators--

00:52:43.940 --> 00:52:46.105
doing a general proof is
slightly more complicated, I

00:52:46.105 --> 00:52:48.140
proved it in a special case.

00:52:48.140 --> 00:52:49.890
But the general case
works too.

00:52:52.930 --> 00:52:57.600
Just like polynomials,
operators commute.

00:52:57.600 --> 00:53:01.640
And I indicated why you should
think that's true by thinking

00:53:01.640 --> 00:53:04.630
about signal flow paths.

00:53:04.630 --> 00:53:07.220
Multiplication distributes
over addition.

00:53:07.220 --> 00:53:10.910
I apologize, the diagram
in your notes is wrong.

00:53:10.910 --> 00:53:12.770
This is right.

00:53:12.770 --> 00:53:14.420
I will always post the notes--

00:53:14.420 --> 00:53:17.910
I get up in the morning, I
make coffee, I read the

00:53:17.910 --> 00:53:20.090
lecture notes, and I say,
oh my goodness,

00:53:20.090 --> 00:53:22.150
there's a wrong figure.

00:53:22.150 --> 00:53:24.310
In this particular case, one of
the staff members wrote me

00:53:24.310 --> 00:53:26.180
an email and said, Hey
Freeman, your slides,

00:53:26.180 --> 00:53:27.590
something or other, is wrong.

00:53:27.590 --> 00:53:29.560
He was right.

00:53:29.560 --> 00:53:32.110
So this is the right diagram.

00:53:32.110 --> 00:53:36.380
So the idea is that if
multiplication distributes

00:53:36.380 --> 00:53:39.840
over addition, we should expect
that R applied to 1

00:53:39.840 --> 00:53:43.640
minus R, would give
R minus R squared.

00:53:43.640 --> 00:53:46.730
And we can again get a feeling
for why that ought to be true

00:53:46.730 --> 00:53:49.170
by thinking about the
signal flow paths.

00:53:49.170 --> 00:53:52.090
The two signals flow paths that
represent-- so the signal

00:53:52.090 --> 00:53:54.740
flow path that represents here,
this says take the 1

00:53:54.740 --> 00:53:58.850
minus R operator and apply it
to X, then apply R to the 1

00:53:58.850 --> 00:54:02.000
minus R operator, result.

00:54:02.000 --> 00:54:06.550
As opposed to this one says,
apply the R operator to X,

00:54:06.550 --> 00:54:08.890
then apply the R squared
operator to the X

00:54:08.890 --> 00:54:10.270
and subtract them.

00:54:10.270 --> 00:54:12.720
If you think about the signal
flow paths through those two

00:54:12.720 --> 00:54:15.520
systems, they're also the same
two signal flow paths.

00:54:18.380 --> 00:54:21.270
And here's a more complicated
example that shows

00:54:21.270 --> 00:54:22.520
associativity.

00:54:24.300 --> 00:54:28.940
You can think through
that, same idea.

00:54:28.940 --> 00:54:31.080
The reason that the idea--

00:54:31.080 --> 00:54:34.540
the big important point is,
difference equations are a

00:54:34.540 --> 00:54:36.960
good representation for
discrete time systems.

00:54:36.960 --> 00:54:38.240
They're mathematically
compact.

00:54:38.240 --> 00:54:40.750
Block diagrams are a good
representation, but they have

00:54:40.750 --> 00:54:42.210
more information.

00:54:42.210 --> 00:54:44.150
They tell you what is the input,
what is the output, and

00:54:44.150 --> 00:54:48.010
what are all the different flow
paths through the system?

00:54:48.010 --> 00:54:53.200
Operators kind of combine the
best features of both.

00:54:53.200 --> 00:54:55.460
It's mathematically concise,
it tells you which is the

00:54:55.460 --> 00:54:58.470
input and which is the output.

00:54:58.470 --> 00:55:01.050
And you can visualize all the
flow paths by thinking about

00:55:01.050 --> 00:55:06.110
all the ads in the operator
expression.

00:55:06.110 --> 00:55:08.470
OK, to make sure that
everybody's up with me, how

00:55:08.470 --> 00:55:12.240
many of the following systems
are equivalent?

00:55:12.240 --> 00:55:13.350
You have 30 seconds.

00:55:13.350 --> 00:55:14.600
AUDIENCE: [INAUDIBLE]

00:57:04.520 --> 00:57:06.380
PROFESSOR: OK, so how many
of those are equivalent?

00:57:11.440 --> 00:57:13.630
More hands, more hands.

00:57:13.630 --> 00:57:15.600
Not necessarily more fingers,
but more hands.

00:57:21.480 --> 00:57:28.410
OK, about 75% correct,
roughly speaking.

00:57:28.410 --> 00:57:33.840
OK, how many distinct signal
flow paths are going through

00:57:33.840 --> 00:57:35.090
the first system?

00:57:37.812 --> 00:57:41.291
How many distinct signal
flow paths can you see?

00:57:44.780 --> 00:57:46.030
Well, here's one.

00:57:48.744 --> 00:57:51.630
How many more are there?

00:57:51.630 --> 00:57:53.073
AUDIENCE: Three.

00:57:53.073 --> 00:57:54.035
PROFESSOR: Three more.

00:57:54.035 --> 00:58:03.822
So here's one, here's one,
here's one, and here's one.

00:58:03.822 --> 00:58:06.870
All you need to do to think
about this system, is think

00:58:06.870 --> 00:58:12.430
about all of the signal flow
paths through all of them,

00:58:12.430 --> 00:58:18.440
make a sum, and see how many
of them have the same sum.

00:58:18.440 --> 00:58:23.220
So the path with the greatest
delay through this path is two

00:58:23.220 --> 00:58:24.910
times two delay delay.

00:58:24.910 --> 00:58:29.390
Two delays with a
multiply by 4.

00:58:29.390 --> 00:58:31.010
What's the path with
the biggest delay

00:58:31.010 --> 00:58:34.140
through this one?

00:58:34.140 --> 00:58:37.160
Also straight through.

00:58:37.160 --> 00:58:39.835
Also delay of two, also
a coefficient of 4.

00:58:43.160 --> 00:58:44.840
How about this one?

00:58:44.840 --> 00:58:46.090
So that's this way.

00:58:49.020 --> 00:58:52.640
So they all have the same paths
with maximum delay.

00:58:52.640 --> 00:58:57.190
The delay is 2 and the
coefficient is 4.

00:58:57.190 --> 00:58:59.840
This one has four possible
paths, this

00:58:59.840 --> 00:59:03.210
one only has three.

00:59:03.210 --> 00:59:05.230
So there's one straight
through this way.

00:59:05.230 --> 00:59:08.900
There's one that has
one fewer delay.

00:59:08.900 --> 00:59:11.880
And there's one that
only has--

00:59:11.880 --> 00:59:14.930
so there's a straight through
one, there's a delay of 2, and

00:59:14.930 --> 00:59:18.150
there's a delay of 1.

00:59:18.150 --> 00:59:20.220
So let's do the straight
through one.

00:59:20.220 --> 00:59:23.440
This one has a straight
through path.

00:59:23.440 --> 00:59:30.820
No delay, coefficient is 1.

00:59:30.820 --> 00:59:32.240
This one has a straight
through path,

00:59:32.240 --> 00:59:33.540
coefficient is 1.

00:59:33.540 --> 00:59:34.870
This one has a straight
through path,

00:59:34.870 --> 00:59:38.200
coefficient is 1.

00:59:38.200 --> 00:59:43.030
So all three systems have the
same maximum delay path, they

00:59:43.030 --> 00:59:46.130
all have the same minimum delay
path, we only have one

00:59:46.130 --> 00:59:47.400
in the middle yet.

00:59:47.400 --> 00:59:50.990
This one has two ways
to get a delay of 1.

00:59:50.990 --> 00:59:56.370
2 delay, 2R, or 2R.

00:59:56.370 --> 00:59:58.770
Since they're both 2R, they
sum, so that's 4R.

01:00:01.990 --> 01:00:06.640
This one only has one way that
we can get 1 delay, and that

01:00:06.640 --> 01:00:09.180
is to come this way and then
go that way, that's 4R.

01:00:12.180 --> 01:00:14.310
This one, to get 1 delay,
I take the center

01:00:14.310 --> 01:00:16.490
path, and that's 4R.

01:00:16.490 --> 01:00:21.440
Each path has the same ways to
get through the system with

01:00:21.440 --> 01:00:24.290
zero delay, 1 delay,
and 2 delays.

01:00:24.290 --> 01:00:27.550
They're equivalent in the sense
that if you started them

01:00:27.550 --> 01:00:34.240
with initial rest, they would
all generate the same output

01:00:34.240 --> 01:00:36.060
given the same input.

01:00:36.060 --> 01:00:38.870
So the answer's (3).

01:00:38.870 --> 01:00:40.120
OK?

01:00:42.570 --> 01:00:45.680
So far I've only worked with
systems that propagate the

01:00:45.680 --> 01:00:49.710
inputs systematically through
to the outputs.

01:00:49.710 --> 01:00:51.100
We call such systems
feedforward.

01:01:02.470 --> 01:01:04.420
Things are a little
bit different

01:01:04.420 --> 01:01:07.270
when you have cycles.

01:01:07.270 --> 01:01:09.023
We call such systems feedback.

01:01:14.950 --> 01:01:19.150
So what I want to think about
now is how do you think about

01:01:19.150 --> 01:01:21.276
a system that has a feedback
loop in it?

01:01:24.420 --> 01:01:26.180
The interesting thing that
happens when you have a

01:01:26.180 --> 01:01:33.670
feedback loop is that the
operator expression no longer

01:01:33.670 --> 01:01:38.610
represents a simple sum
of input signals.

01:01:38.610 --> 01:01:40.760
Let's look at what
happens here.

01:01:40.760 --> 01:01:45.690
So Y is apparently the
sum of two things.

01:01:45.690 --> 01:01:51.630
It's the signal RY, which
comes around that way.

01:01:51.630 --> 01:01:54.000
Does everybody see that?

01:01:54.000 --> 01:01:56.650
So if I think about labeling
this input as X, labeling this

01:01:56.650 --> 01:02:01.270
output as Y, then the correct
label for this point is--

01:02:04.876 --> 01:02:08.700
don't everybody shout at once.

01:02:08.700 --> 01:02:12.350
If this can be labeled as the
point Y, what is the correct

01:02:12.350 --> 01:02:13.530
label to a label at this point?

01:02:13.530 --> 01:02:16.410
RY.

01:02:16.410 --> 01:02:25.730
So the signal Y must be, RY
plus X. What that says, is

01:02:25.730 --> 01:02:32.000
that if I apply the 1 minus R
operator to Y, I should get X.

01:02:32.000 --> 01:02:36.740
OK, that's a fine operator
expression, except that it's

01:02:36.740 --> 01:02:41.780
not a formulaic operator
applied to the input.

01:02:41.780 --> 01:02:47.390
The operator is applied
to the output.

01:02:47.390 --> 01:02:52.880
OK, the difference here is
the difference between an

01:02:52.880 --> 01:03:00.110
imperative system, like we
talked about block diagrams

01:03:00.110 --> 01:03:01.780
when we were thinking
about samples.

01:03:01.780 --> 01:03:07.970
The block diagram tells you
what to do step by step.

01:03:07.970 --> 01:03:10.210
Regardless of whether you have
feedback, the block diagram

01:03:10.210 --> 01:03:15.350
always tells you take X of n,
add it to Y of n, whatever.

01:03:15.350 --> 01:03:19.880
There's an imperative
rule, do this.

01:03:19.880 --> 01:03:22.450
We took the block diagrams and
we turned them into operators,

01:03:22.450 --> 01:03:25.085
and we ended up with something
that is not imperative.

01:03:28.140 --> 01:03:31.140
This is much more the kind of
statement we got when we did

01:03:31.140 --> 01:03:33.370
difference equations.

01:03:33.370 --> 01:03:37.930
This is a statement of truth,
it's declarative.

01:03:37.930 --> 01:03:43.760
If you tell me the signal X,
it must be true that the

01:03:43.760 --> 01:03:49.350
resulting signal Y when operated
upon by 1 minus R, is

01:03:49.350 --> 01:03:56.190
X. So the idea is that it's
a declaration, it's not an

01:03:56.190 --> 01:03:58.860
imperative rule.

01:03:58.860 --> 01:04:00.110
Does everybody get that?

01:04:02.420 --> 01:04:07.750
So this statement up here told
me a rule, start with X, apply

01:04:07.750 --> 01:04:12.780
the 1 minus R operator and
you will get Y. That's an

01:04:12.780 --> 01:04:15.340
imperative operation, do this.

01:04:18.070 --> 01:04:21.540
This is a declaration.

01:04:21.540 --> 01:04:26.350
If you tell me X, Y must be the
signal that when operated

01:04:26.350 --> 01:04:31.270
on by 1 minus R, gives you X.
But it doesn't tell me a way

01:04:31.270 --> 01:04:34.010
to find it.

01:04:34.010 --> 01:04:37.060
It tells me a truth, but it
doesn't tell me how to find

01:04:37.060 --> 01:04:39.350
that truth.

01:04:39.350 --> 01:04:41.090
So let's go back,
let's back up.

01:04:41.090 --> 01:04:43.550
OK, we got a representation,
we like the representation.

01:04:43.550 --> 01:04:46.270
It's concise, it has many
of the features of block

01:04:46.270 --> 01:04:49.695
diagrams, it doesn't seem
to be imperative.

01:04:49.695 --> 01:04:51.500
Well, that's a problem.

01:04:51.500 --> 01:04:54.930
So let's back up, think about
how this same system that ran

01:04:54.930 --> 01:04:57.760
into a problem with the
operator, think about what

01:04:57.760 --> 01:04:59.010
must the answer be.

01:05:02.330 --> 01:05:06.990
Well the answer we can figure
out by doing step by step.

01:05:06.990 --> 01:05:09.760
Imagine that it starts
at rest, so the

01:05:09.760 --> 01:05:12.660
output starts at 0.

01:05:12.660 --> 01:05:14.675
And now I just tick through
the samples.

01:05:17.470 --> 01:05:20.980
So when the first sample comes
in, X is equal to 1, I'm

01:05:20.980 --> 01:05:23.840
thinking about the unit
sample response.

01:05:23.840 --> 01:05:28.510
We call the delta function
the unit sample.

01:05:28.510 --> 01:05:31.840
When the unit sample at time n
equals 0 comes in, it has a

01:05:31.840 --> 01:05:33.180
value of 1.

01:05:33.180 --> 01:05:36.010
The 1 adds to the initial
condition, which is

01:05:36.010 --> 01:05:37.760
0, to give me 1.

01:05:42.537 --> 01:05:47.410
Then, this output is 1, so
when the clock ticks, the

01:05:47.410 --> 01:05:51.690
input goes from 1 to 0, but the
output of the delay goes

01:05:51.690 --> 01:05:52.940
from 0 to 1.

01:05:55.980 --> 01:05:58.650
So when the clock ticks,
I get another 1.

01:06:01.190 --> 01:06:04.190
And that persists.

01:06:04.190 --> 01:06:06.450
Does everybody see
what's going on?

01:06:06.450 --> 01:06:10.870
So I initially had a 0 coming
out of the delay.

01:06:10.870 --> 01:06:16.430
The unit sample made the first
output be one, but then that 1

01:06:16.430 --> 01:06:19.180
fed back in to make this be 1.

01:06:19.180 --> 01:06:23.250
Which combined with the next 0
to give me the same 1, and

01:06:23.250 --> 01:06:25.790
that state persisted.

01:06:25.790 --> 01:06:34.540
What's different, is that the
output signal persists long

01:06:34.540 --> 01:06:36.050
after the input went away.

01:06:38.900 --> 01:06:43.720
In fact, there is a prescriptive
way to figure out

01:06:43.720 --> 01:06:46.670
the relationship between the
input and the output.

01:06:46.670 --> 01:06:51.030
It's just that it takes an
infinite number of delays.

01:06:51.030 --> 01:06:54.840
Here's an alternative system
that would generate the same

01:06:54.840 --> 01:06:59.990
response to a unit sample signal
as was generated by the

01:06:59.990 --> 01:07:03.140
simple feedback system.

01:07:03.140 --> 01:07:07.450
It needs to generate the
answer 1, 1, 1, 1, 1 --

01:07:07.450 --> 01:07:11.090
when the input is just 1.

01:07:11.090 --> 01:07:15.540
Well, the output at 0 happens
through this path.

01:07:18.260 --> 01:07:21.830
The output at 1 happens
through this path.

01:07:21.830 --> 01:07:24.510
The output at 2 happens
through this path.

01:07:24.510 --> 01:07:25.170
3--

01:07:25.170 --> 01:07:26.065
et cetera.

01:07:26.065 --> 01:07:30.950
There's a separate path for
every one of those separate

01:07:30.950 --> 01:07:32.930
components of the output.

01:07:32.930 --> 01:07:35.350
That's how we can think about
this construction.

01:07:35.350 --> 01:07:41.360
The input had a single non-zero
entry, the output has

01:07:41.360 --> 01:07:43.550
an infinite number.

01:07:43.550 --> 01:07:46.830
We can think about that as
resulting from an infinite

01:07:46.830 --> 01:07:51.390
number of paths, or something
similar, about the simple

01:07:51.390 --> 01:07:54.540
feedback system, which can be
represented by that operator

01:07:54.540 --> 01:08:02.990
representation, and the infinite
feedforward system.

01:08:02.990 --> 01:08:06.400
This is a simple feedback
system.

01:08:06.400 --> 01:08:09.000
This is an infinite feedforward
system.

01:08:09.000 --> 01:08:11.100
There's something the same
about those two.

01:08:13.900 --> 01:08:17.899
In fact, they're equivalent in
the sense that if all the

01:08:17.899 --> 01:08:21.710
delays start out with initial
conditions of 0, they will

01:08:21.710 --> 01:08:27.819
generate the same response to
all possible input signals.

01:08:27.819 --> 01:08:29.450
Those two signals are
equivalent, and

01:08:29.450 --> 01:08:32.210
that's proved here.

01:08:32.210 --> 01:08:43.319
All you do is you say, OK, Y2
depends on X2 this way.

01:08:43.319 --> 01:08:47.220
If X2 is the same as X1,
I can substitute it.

01:08:47.220 --> 01:08:52.950
But X1, according to this rule,
looks like 1 minus RY1.

01:08:52.950 --> 01:08:55.455
When you multiply out this
mess, you get Y1.

01:08:58.040 --> 01:09:07.359
What I just showed is that if X1
is equal to X2, then Y1 is

01:09:07.359 --> 01:09:08.490
equal to Y2.

01:09:08.490 --> 01:09:11.979
Those two systems
are the same.

01:09:11.979 --> 01:09:14.899
Well that's weird.

01:09:14.899 --> 01:09:17.640
So there's something
the same about that

01:09:17.640 --> 01:09:20.060
operator and that operator.

01:09:20.060 --> 01:09:22.439
We write that this way.

01:09:22.439 --> 01:09:26.000
So here's the feedback system,
we think about that as

01:09:26.000 --> 01:09:32.740
representing the operator Y over
X, 1 over (1 minus R).

01:09:32.740 --> 01:09:38.450
So in order to calculate X,
cross multiply by X. Y is the

01:09:38.450 --> 01:09:43.410
operator, 1 minus
R applied to X.

01:09:43.410 --> 01:09:51.319
So we want to say Y is the
operator 1 minus R applied to

01:09:51.319 --> 01:09:56.775
X. What is the operator
1 over (1 minus R)?

01:10:00.040 --> 01:10:06.330
Well, if you didn't know
anything but polynomial math,

01:10:06.330 --> 01:10:08.495
you might have expanded
this in a series.

01:10:11.350 --> 01:10:15.390
And in fact, that gives you
exactly the right answer if

01:10:15.390 --> 01:10:19.250
you were to expand 1
over R in a series.

01:10:19.250 --> 01:10:22.270
So, for example, evaluate it
using synthetic division,

01:10:22.270 --> 01:10:24.290
evaluate it with a Taylor
series, however

01:10:24.290 --> 01:10:25.890
you want to do it.

01:10:25.890 --> 01:10:28.240
Think about R as though it were
a number, just like you

01:10:28.240 --> 01:10:31.300
would if it were a polynomial.

01:10:31.300 --> 01:10:35.710
Expanded just like you would
if it were a polynomial.

01:10:35.710 --> 01:10:38.640
And what you see, is that
there's a representation for

01:10:38.640 --> 01:10:42.950
this operator 1 over (1 minus
R) that is equivalent.

01:10:42.950 --> 01:10:46.920
That's exactly the same as if I
applied the operator 1 plus

01:10:46.920 --> 01:10:54.850
R plus R squared plus R cubed to
X. Those two are equivalent

01:10:54.850 --> 01:10:59.740
in the sense that if both
systems start out at rest, and

01:10:59.740 --> 01:11:03.150
if they are both applied to
the same input, they both

01:11:03.150 --> 01:11:06.230
generate the same output.

01:11:06.230 --> 01:11:12.590
So that gives us that way of
thinking about operators that

01:11:12.590 --> 01:11:14.723
have numerators and
denominators.

01:11:19.220 --> 01:11:24.370
So, to make sure you're up to
speed, a system is described

01:11:24.370 --> 01:11:27.120
by the following operator
expression.

01:11:27.120 --> 01:11:29.190
Determine the output of the
system when the input is a

01:11:29.190 --> 01:11:29.850
unit sample.

01:11:29.850 --> 01:11:31.100
AUDIENCE: [INAUDIBLE]

01:13:13.430 --> 01:13:14.890
PROFESSOR: What's the first
thing I should do?

01:13:21.228 --> 01:13:23.770
OK, this is one of those
systems that has the R

01:13:23.770 --> 01:13:26.800
polynomial in the bottom.

01:13:26.800 --> 01:13:31.450
So it says that X must be
the same signal by cross

01:13:31.450 --> 01:13:32.250
multiplying--

01:13:32.250 --> 01:13:36.140
X must be the same signal as
the (1 plus 2R) operator on

01:13:36.140 --> 01:13:38.080
the Y. OK, that's backwards.

01:13:38.080 --> 01:13:40.300
That's not the way I want
to think about it.

01:13:40.300 --> 01:13:44.320
How do I make that into a
forward statement that tells

01:13:44.320 --> 01:13:46.405
me what operator gets
applied to X?

01:13:49.180 --> 01:13:50.430
The answer is that.

01:13:53.030 --> 01:13:54.280
So what do I do?

01:14:00.350 --> 01:14:03.640
Multiply by--

01:14:03.640 --> 01:14:07.280
actually you could
cross multiply.

01:14:07.280 --> 01:14:12.280
How do I convert this into an
operator that looks like just

01:14:12.280 --> 01:14:16.388
the numerator times X. Yeah.

01:14:16.388 --> 01:14:19.600
AUDIENCE: 1 minus 2R
plus 4R squared.

01:14:19.600 --> 01:14:21.270
PROFESSOR: Exactly.

01:14:21.270 --> 01:14:25.490
What I want to do is convert
it by synthetic division,

01:14:25.490 --> 01:14:27.600
Taylor series, whatever
method.

01:14:27.600 --> 01:14:31.510
I want to think about
what would 1 over (1

01:14:31.510 --> 01:14:32.710
plus 2R) look like?

01:14:32.710 --> 01:14:37.140
What's the reciprocal
of 1 plus 2R?

01:14:37.140 --> 01:14:40.710
That is 1 minus 2R plus
4R squared, et cetera.

01:14:40.710 --> 01:14:44.290
So now I have this, which
I apply to X,

01:14:44.290 --> 01:14:47.440
which is a unit sample.

01:14:47.440 --> 01:14:50.530
So now I want to think about
applying this operator to the

01:14:50.530 --> 01:14:52.420
unit sample signal.

01:14:52.420 --> 01:14:54.530
But that's easy.

01:14:54.530 --> 01:14:59.550
The first term just
brings out delta.

01:14:59.550 --> 01:15:06.230
Minus 2R applied to delta
shifts the delta by 1.

01:15:06.230 --> 01:15:10.005
Gives me delta of n minus 1,
and multiplies by minus 2.

01:15:13.280 --> 01:15:16.780
And that whole mess then
just says that my

01:15:16.780 --> 01:15:19.310
output looks like this.

01:15:19.310 --> 01:15:23.990
If the input was X, which was
a unit sample signal, my

01:15:23.990 --> 01:15:28.570
output has an infinite
number of terms.

01:15:28.570 --> 01:15:34.050
Each one is a delayed version
of the predecessor, and the

01:15:34.050 --> 01:15:39.460
weights go 1, minus 2, plus 4,
minus 8, plus 16, and diverge.

01:15:42.910 --> 01:15:45.530
So what we just did was
pretty complicated.

01:15:45.530 --> 01:15:49.120
We just solved a block diagram,
but we did it with

01:15:49.120 --> 01:15:50.230
polynomial math.

01:15:50.230 --> 01:15:52.420
We did it with math that you
learned in high school.

01:15:52.420 --> 01:15:54.600
That's the point.

01:15:54.600 --> 01:16:00.610
In fact, the point of today is
that any system that's built

01:16:00.610 --> 01:16:01.870
out of simple parts--

01:16:01.870 --> 01:16:04.920
delays, adders, scalers,
that sort of thing--

01:16:04.920 --> 01:16:07.300
can be represented by a
difference equation.

01:16:07.300 --> 01:16:11.750
Fine, that's good, difference
equations are wonderful.

01:16:11.750 --> 01:16:13.480
They can equivalently
be represented

01:16:13.480 --> 01:16:16.930
by an operator equation.

01:16:16.930 --> 01:16:23.100
The operator equation has
more information in it.

01:16:23.100 --> 01:16:26.090
It knows how to get from the
input to the output.

01:16:26.090 --> 01:16:28.220
It's imperative.

01:16:28.220 --> 01:16:30.560
It's easy to manipulate.

01:16:30.560 --> 01:16:33.940
You use the same rules that
you use for polynomials.

01:16:33.940 --> 01:16:37.140
So all in all, this is a
more powerful kind of

01:16:37.140 --> 01:16:38.010
representation.

01:16:38.010 --> 01:16:40.880
And any system that can be
represented by a difference

01:16:40.880 --> 01:16:43.140
equation can similarly
be represented

01:16:43.140 --> 01:16:45.340
by an operator equation.

01:16:45.340 --> 01:16:47.920
That's why we're focusing
on operators.

01:16:47.920 --> 01:16:50.470
So final question.

01:16:50.470 --> 01:16:52.560
Think about--

01:16:52.560 --> 01:16:55.770
do everything backwards now.

01:16:55.770 --> 01:17:00.530
Here's a block diagram,
find the

01:17:00.530 --> 01:17:02.065
associated difference equation.

01:17:05.040 --> 01:17:07.980
And the idea is to take
advantage of operators.

01:17:11.110 --> 01:17:15.250
In the interest of time,
let me just do it.

01:17:15.250 --> 01:17:16.560
If we wanted to--

01:17:16.560 --> 01:17:18.810
because I'm running
out of time.

01:17:18.810 --> 01:17:21.180
So I could start with the block
diagram, I could stay in

01:17:21.180 --> 01:17:23.660
block diagram domain.

01:17:23.660 --> 01:17:26.270
Presumably that will
work, that's hard.

01:17:26.270 --> 01:17:28.580
I want to do the easy way.

01:17:28.580 --> 01:17:30.020
So convert it to operators.

01:17:30.020 --> 01:17:33.350
How do you convert a block
diagram to operators?

01:17:33.350 --> 01:17:38.050
Replace the delays by R,
label all the signals.

01:17:38.050 --> 01:17:41.240
x becomes X, y becomes Y. I
don't have a name for this, so

01:17:41.240 --> 01:17:44.290
I'll call it E, error.

01:17:44.290 --> 01:17:46.860
I don't have a name for this, so
I'll call it W, who knows.

01:17:49.400 --> 01:17:54.480
And then I'll express each of
the relationships imposed by

01:17:54.480 --> 01:17:57.760
the plus sign, this
R or this R, by a

01:17:57.760 --> 01:18:01.000
line of operator reasoning.

01:18:01.000 --> 01:18:07.330
The plus says that the E signal
is X plus W. The R says

01:18:07.330 --> 01:18:12.490
that the Y signal is R applied
to E. This box says that the W

01:18:12.490 --> 01:18:15.280
signal is R applied to Y.

01:18:15.280 --> 01:18:23.320
I get three equations in R. I
just solve algebraically.

01:18:23.320 --> 01:18:25.660
None of this difference stuff,
none of the square brackets

01:18:25.660 --> 01:18:26.920
with n's in them.

01:18:26.920 --> 01:18:28.170
I just use algebra.

01:18:30.640 --> 01:18:34.210
So I solve it algebraically
and I get this.

01:18:34.210 --> 01:18:37.640
And that translates into a
corresponding difference

01:18:37.640 --> 01:18:39.360
equation, showed here.

01:18:43.390 --> 01:18:44.350
The point.

01:18:44.350 --> 01:18:46.550
The point is three different
representations.

01:18:46.550 --> 01:18:49.330
Difference equations, block
diagrams, operators.

01:18:51.960 --> 01:18:54.940
Operators are easiest.

01:18:54.940 --> 01:18:57.990
Even when I was asked to solve
a problem that has no

01:18:57.990 --> 01:19:01.150
operators in it, it's easier
to cast it into an operator

01:19:01.150 --> 01:19:05.610
expression, solve it in the
operator domain, and then turn

01:19:05.610 --> 01:19:08.890
it back into a difference
equation.

01:19:08.890 --> 01:19:12.220
Starting next week, we will
figure out much more powerful

01:19:12.220 --> 01:19:13.650
things that we can do
with operators.

01:19:13.650 --> 01:19:16.040
This is just the beginning.

01:19:16.040 --> 01:19:20.370
So with that, let me just
summarize that we looked at

01:19:20.370 --> 01:19:26.500
three representations, and the
point of the labs for the week

01:19:26.500 --> 01:19:30.160
are going to be to exercise
this, to get some experience

01:19:30.160 --> 01:19:32.980
with representing signals
in Python.

