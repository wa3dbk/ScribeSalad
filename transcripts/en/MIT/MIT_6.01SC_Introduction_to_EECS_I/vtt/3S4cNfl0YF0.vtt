WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:17.890
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:17.890 --> 00:00:19.140
ocw.mit.edu.

00:00:28.480 --> 00:00:31.600
PROFESSOR: Hello, and
welcome to 6.01.

00:00:31.600 --> 00:00:32.409
I'm Denny Freeman.

00:00:32.409 --> 00:00:33.930
I'm the lecturer.

00:00:33.930 --> 00:00:35.970
One thing you should know about
today is that there's a

00:00:35.970 --> 00:00:37.060
single hand-out.

00:00:37.060 --> 00:00:38.830
You should have picked
it up on your way in.

00:00:38.830 --> 00:00:40.370
It's available at either
of the two doors.

00:00:42.980 --> 00:00:47.650
What I want to do today in this
first lecture is mostly

00:00:47.650 --> 00:00:50.750
focus on content.

00:00:50.750 --> 00:00:54.030
But before I do that, since
6.01 is a little bit of an

00:00:54.030 --> 00:00:56.320
unusual course, I want to give
you a little bit of an

00:00:56.320 --> 00:00:59.010
overview and tell you a little
bit about the administration

00:00:59.010 --> 00:01:00.260
of the course.

00:01:03.020 --> 00:01:11.490
6.01 is mostly about
modes of reasoning.

00:01:11.490 --> 00:01:14.410
What we would like you to get
out of this course is ways to

00:01:14.410 --> 00:01:17.800
think about engineering.

00:01:17.800 --> 00:01:21.330
We want to talk about how do you
design, how do you build,

00:01:21.330 --> 00:01:26.030
how do you construct, how do you
debug complicated systems?

00:01:26.030 --> 00:01:30.670
That's what engineers do, and
we're very good at it.

00:01:30.670 --> 00:01:33.700
And we want to make you
very good at it.

00:01:33.700 --> 00:01:34.780
We're very good at it.

00:01:34.780 --> 00:01:37.590
And you know that from your
common, everyday experience.

00:01:37.590 --> 00:01:41.010
Laptops are incredible.

00:01:41.010 --> 00:01:43.990
As we go through the course,
you're going to see that

00:01:43.990 --> 00:01:47.210
laptops incorporate things
from the tiniest, tiniest

00:01:47.210 --> 00:01:51.550
level, things so small that
you can't see them.

00:01:51.550 --> 00:01:52.370
They're microscopic.

00:01:52.370 --> 00:01:55.600
The individual transistors are
not things that you can see.

00:01:55.600 --> 00:01:58.160
We develop special tools for
you even to be able to

00:01:58.160 --> 00:02:00.520
visualize them.

00:02:00.520 --> 00:02:04.360
And yet, we conglomerate
billions of them into a system

00:02:04.360 --> 00:02:06.430
that works relatively
reliably.

00:02:06.430 --> 00:02:09.580
Now, I realize I'm going out on
a limb because when you say

00:02:09.580 --> 00:02:11.415
things like that, then
things always fail.

00:02:11.415 --> 00:02:15.250
But I'll go out on a limb and
say, for the most part, the

00:02:15.250 --> 00:02:19.270
systems we construct
are very reliable.

00:02:19.270 --> 00:02:22.790
We'd like you to know how you
think about making such a

00:02:22.790 --> 00:02:26.680
complicated system and
making it reliable.

00:02:26.680 --> 00:02:29.760
We want to tell you about how
you would model things.

00:02:29.760 --> 00:02:30.770
How do you gain insight?

00:02:30.770 --> 00:02:32.500
How do you get predictability?

00:02:32.500 --> 00:02:35.890
How do you figure out how
something will work before

00:02:35.890 --> 00:02:38.820
you've built it?

00:02:38.820 --> 00:02:42.390
If you're limited to trying
out how things work by

00:02:42.390 --> 00:02:45.750
actually constructing it,
you spend a lot of time

00:02:45.750 --> 00:02:48.430
constructing things that
never make it.

00:02:48.430 --> 00:02:52.310
We want to avoid that by
-- where we can --

00:02:52.310 --> 00:02:55.400
making a model, analyzing the
model, making a prediction

00:02:55.400 --> 00:02:59.860
from the model, and using that
prediction to build a better

00:02:59.860 --> 00:03:01.230
system on the first try.

00:03:04.080 --> 00:03:07.750
We want to tell you about how
to augment the physical

00:03:07.750 --> 00:03:11.390
behavior of a system by putting
computation in it.

00:03:11.390 --> 00:03:15.470
That's a very powerful technique
that is increasingly

00:03:15.470 --> 00:03:20.090
common in anything from a
microwave to a refrigerator.

00:03:20.090 --> 00:03:21.750
We'd like you to know
the principles

00:03:21.750 --> 00:03:23.990
by which to do that.

00:03:23.990 --> 00:03:26.630
And we'd like you to be able
to build systems that are

00:03:26.630 --> 00:03:29.500
robust to failure.

00:03:29.500 --> 00:03:31.580
That's a newer idea.

00:03:31.580 --> 00:03:35.540
It's something that people
are very good at.

00:03:35.540 --> 00:03:38.090
If we try to do something,
and we make a mistake, we

00:03:38.090 --> 00:03:39.830
know how to fix it.

00:03:39.830 --> 00:03:42.480
And often, the fix works.

00:03:42.480 --> 00:03:46.090
We're less good at doing that
in constructing artificial

00:03:46.090 --> 00:03:48.080
systems, in engineering
systems.

00:03:48.080 --> 00:03:49.740
And we'd like to talk
about principles by

00:03:49.740 --> 00:03:52.080
which we can do that.

00:03:52.080 --> 00:03:56.320
So the goal of 6.01 is, then,
really to convey a distinct

00:03:56.320 --> 00:04:02.330
perspective about how
we engineer systems.

00:04:02.330 --> 00:04:07.310
Now, having said that, this is
not a philosophy course.

00:04:07.310 --> 00:04:10.770
We are not going to make lists
of things to do if you want it

00:04:10.770 --> 00:04:13.250
to be robust.

00:04:13.250 --> 00:04:15.240
We're going to learn
to do things by

00:04:15.240 --> 00:04:17.329
actually making systems.

00:04:17.329 --> 00:04:19.700
This is an introductory
engineering course.

00:04:19.700 --> 00:04:22.230
And so you're going
to build things.

00:04:22.230 --> 00:04:25.040
The idea is going to be that in
constructing those things,

00:04:25.040 --> 00:04:28.380
we've written the exercises so
that some of those important

00:04:28.380 --> 00:04:31.450
themes become transparent.

00:04:31.450 --> 00:04:35.170
So the idea is -- this is
introductory engineering.

00:04:35.170 --> 00:04:36.900
You'll all make things.

00:04:36.900 --> 00:04:40.280
You'll all get things to work,
and in the process of doing

00:04:40.280 --> 00:04:44.710
that, learn something about the
bigger view of how quality

00:04:44.710 --> 00:04:45.960
engineering happens.

00:04:48.120 --> 00:04:51.220
So despite the fact that we're
really about modes of

00:04:51.220 --> 00:04:55.670
reasoning, that will be
grounded in content.

00:04:55.670 --> 00:05:00.080
We selected the content very
broadly from across EECS.

00:05:00.080 --> 00:05:04.050
EECS is an enormous endeavor.

00:05:04.050 --> 00:05:06.180
We can't possibly introduce
everything

00:05:06.180 --> 00:05:08.310
about EECS in one subject.

00:05:08.310 --> 00:05:11.460
That's ridiculous.

00:05:11.460 --> 00:05:13.630
However, we wanted to
give you a variety.

00:05:13.630 --> 00:05:16.320
We wanted to give you a sense
of the variety of tasks that

00:05:16.320 --> 00:05:21.450
you can use, that you can apply
the same techniques to.

00:05:21.450 --> 00:05:23.610
So we want to introduce modes
of reasoning, and then show

00:05:23.610 --> 00:05:27.750
you explicitly how you can use
those modes of reasoning in a

00:05:27.750 --> 00:05:29.640
variety of contexts.

00:05:29.640 --> 00:05:31.830
So we've chosen four, and we've
organized the course

00:05:31.830 --> 00:05:33.690
around four modules.

00:05:33.690 --> 00:05:35.940
First module is software
engineering, then signals and

00:05:35.940 --> 00:05:39.700
systems, then circuits, then
probability and planning.

00:05:39.700 --> 00:05:43.330
Even so, even having chosen
just four out of the vast

00:05:43.330 --> 00:05:46.240
number of things we could have
chosen, there's no way we can

00:05:46.240 --> 00:05:48.220
tell you adequately--

00:05:48.220 --> 00:05:50.420
we can't give you an adequate
introduction to any of those

00:05:50.420 --> 00:05:52.980
things either.

00:05:52.980 --> 00:05:57.250
What we've chosen to do instead
is focus on key

00:05:57.250 --> 00:06:01.740
concepts represented
by the asterisks.

00:06:01.740 --> 00:06:06.110
The idea is going to be we
choose one or two things and

00:06:06.110 --> 00:06:09.090
really focus on those deeply
so you get a thorough

00:06:09.090 --> 00:06:14.070
understanding not only of how
that fits within, for example,

00:06:14.070 --> 00:06:17.440
the context of software
engineering, but also how that

00:06:17.440 --> 00:06:20.260
concept ramifies into
other areas.

00:06:20.260 --> 00:06:23.500
Notice that I tried to choose
the stars so they

00:06:23.500 --> 00:06:25.960
hit multiple circles.

00:06:25.960 --> 00:06:27.080
That's what we're
trying to do.

00:06:27.080 --> 00:06:30.050
We're trying to not only
introduce an idea to you, but

00:06:30.050 --> 00:06:33.710
also show you how it connects
to other ideas.

00:06:36.270 --> 00:06:40.700
So the idea, then, is to focus
on a few, we hope, very

00:06:40.700 --> 00:06:45.220
well-chosen applications that
will demonstrate a variety of

00:06:45.220 --> 00:06:46.470
powerful techniques.

00:06:48.560 --> 00:06:52.430
Our mantra, the way we intend
to go about teaching this

00:06:52.430 --> 00:06:58.950
stuff, is practice,
theory, practice.

00:06:58.950 --> 00:07:00.710
There's an enormous educational

00:07:00.710 --> 00:07:02.420
literature that says--

00:07:02.420 --> 00:07:04.630
whether you like it or not--

00:07:04.630 --> 00:07:08.610
people learn better when
they're doing things.

00:07:08.610 --> 00:07:10.140
You have a lot of experience
with that.

00:07:10.140 --> 00:07:13.770
You have a lot of experience
on the other side, too.

00:07:13.770 --> 00:07:15.370
I'll try to forget the other
side, or at least try to wipe

00:07:15.370 --> 00:07:20.150
it from your brain momentarily
to focus on your more

00:07:20.150 --> 00:07:23.170
fundamental modes of learning.

00:07:23.170 --> 00:07:25.190
When you were a kid and you
were learning your first

00:07:25.190 --> 00:07:30.340
language, you didn't learn all
the rules of grammar first.

00:07:30.340 --> 00:07:32.440
You didn't learn all the letters
of the alphabet first.

00:07:32.440 --> 00:07:37.060
You didn't learn about
conjugating verbs first.

00:07:37.060 --> 00:07:38.580
You learned a little
bit about language.

00:07:38.580 --> 00:07:39.580
You started to use it.

00:07:39.580 --> 00:07:40.700
You ran into problems.

00:07:40.700 --> 00:07:43.840
You learned a little more
about language.

00:07:43.840 --> 00:07:50.750
You learned to go from words
like "feed me" to higher level

00:07:50.750 --> 00:07:54.300
concepts, like "Hey,
what's for dinner?"

00:07:54.300 --> 00:07:58.490
So the idea is that you learned
it in an iterative

00:07:58.490 --> 00:08:02.240
process where you learned some
stuff, tried it out, learned

00:08:02.240 --> 00:08:03.810
some more stuff, tried it out.

00:08:03.810 --> 00:08:05.580
And it built up.

00:08:05.580 --> 00:08:08.010
There's an enormous literature
in education that says that's

00:08:08.010 --> 00:08:11.140
exactly how we always
learn everything.

00:08:11.140 --> 00:08:13.170
And so that's the way this
course is focused.

00:08:13.170 --> 00:08:16.210
What we will do is, for example,
for today, we'll

00:08:16.210 --> 00:08:19.100
learn a little bit about
software engineering.

00:08:19.100 --> 00:08:21.370
Then, we'll do two lab sessions
where you actually

00:08:21.370 --> 00:08:25.110
try to use the things
we talk about.

00:08:25.110 --> 00:08:26.590
Then, we'll come back to lecture
and we'll have some

00:08:26.590 --> 00:08:30.770
more theory about how you
would do programming.

00:08:30.770 --> 00:08:33.429
And then, you go back to the
lab and do some more stuff.

00:08:33.429 --> 00:08:39.020
And the hope is that by this
tangible context, you'll have

00:08:39.020 --> 00:08:40.900
a deeper appreciation
of the ideas that

00:08:40.900 --> 00:08:42.150
we're trying to convey.

00:08:45.480 --> 00:08:48.530
So let me tell you a little
bit about the four modules

00:08:48.530 --> 00:08:49.600
that we've chosen.

00:08:49.600 --> 00:08:53.560
The course is going to be
organized on four modules.

00:08:53.560 --> 00:08:56.360
Each module will take about
one fourth of the course.

00:08:56.360 --> 00:08:59.990
First thing we'll look at
is software engineering.

00:08:59.990 --> 00:09:04.720
As I said, we don't have time
to focus on, or even survey,

00:09:04.720 --> 00:09:06.660
all of the big ideas in
software engineering.

00:09:06.660 --> 00:09:07.980
It's far too big.

00:09:07.980 --> 00:09:12.760
So we're going to focus narrowly
on one or two things.

00:09:12.760 --> 00:09:16.780
We'd like you to know about
abstraction and modularity

00:09:16.780 --> 00:09:20.680
because that's such an
important idea in the

00:09:20.680 --> 00:09:23.670
construction of big systems.

00:09:23.670 --> 00:09:26.550
So that's going to
be our focus.

00:09:26.550 --> 00:09:31.580
In today's lecture, we'll begin
talking about modularity

00:09:31.580 --> 00:09:35.760
and abstraction at
the small scale.

00:09:35.760 --> 00:09:38.240
How does it affect the
things you type as

00:09:38.240 --> 00:09:40.990
instructions to a computer?

00:09:40.990 --> 00:09:43.270
But by next week, we're going
to be talking about a whole

00:09:43.270 --> 00:09:45.350
bigger scale.

00:09:45.350 --> 00:09:48.380
By next week, we're going to
talk about constructing

00:09:48.380 --> 00:09:52.460
software modules at a
much higher level.

00:09:52.460 --> 00:09:54.180
In particular, we'll talk about
something that we'll

00:09:54.180 --> 00:09:56.750
call a state machine.

00:09:56.750 --> 00:10:02.710
A state machine is a thing
that works in steps.

00:10:02.710 --> 00:10:08.580
On every step, the state machine
gets a new input.

00:10:08.580 --> 00:10:11.670
Then, based on that input and
its memory of what's come

00:10:11.670 --> 00:10:14.830
before, the state machine
decides to do something.

00:10:14.830 --> 00:10:16.420
It generates an output.

00:10:16.420 --> 00:10:17.670
And then, the process repeats.

00:10:20.210 --> 00:10:23.380
We will see that that kind
of an abstraction --

00:10:23.380 --> 00:10:25.550
state machines --

00:10:25.550 --> 00:10:27.530
there's a way to think about
state machines that is

00:10:27.530 --> 00:10:33.030
compositional that you can think
of as a hierarchy, just

00:10:33.030 --> 00:10:36.740
as you can think of low-level
hierarchies within a language.

00:10:36.740 --> 00:10:39.260
I'll say a lot more
about that today.

00:10:39.260 --> 00:10:42.300
So the idea will be that once
you've composed a state

00:10:42.300 --> 00:10:46.070
machine, you'll be able to join
two state machines and

00:10:46.070 --> 00:10:49.500
have its behavior look just
like one state machine.

00:10:49.500 --> 00:10:52.520
That's a way to get a more
complicated behavior by

00:10:52.520 --> 00:10:54.620
constructing two simpler
behaviors.

00:10:54.620 --> 00:10:55.400
That's what we want.

00:10:55.400 --> 00:10:58.830
We want to learn tools that
let us compose complex

00:10:58.830 --> 00:11:01.100
behaviors out of simple
behaviors.

00:11:01.100 --> 00:11:05.610
And the tangible model of
that will be the robot.

00:11:05.610 --> 00:11:11.110
We will see how to write a
program that controls a robot

00:11:11.110 --> 00:11:14.250
as a state machine.

00:11:14.250 --> 00:11:17.270
That's certainly not the only
way you could control a robot.

00:11:17.270 --> 00:11:20.050
And it's probably not the way
you would first think of it if

00:11:20.050 --> 00:11:23.350
you took one course in
programming and somebody said

00:11:23.350 --> 00:11:27.160
to you, go program the robot
to do something.

00:11:27.160 --> 00:11:30.090
What we will see is that it's
a very powerful way to think

00:11:30.090 --> 00:11:35.460
about it for exactly this
reason of modularity.

00:11:35.460 --> 00:11:37.900
The bigger point that we will
make in thinking about this

00:11:37.900 --> 00:11:41.460
first module is the idea
of, how do you

00:11:41.460 --> 00:11:43.120
make systems modular?

00:11:43.120 --> 00:11:46.300
How do you use abstraction to
simplify the design task?

00:11:46.300 --> 00:11:48.930
And in particular, we will
focus on something

00:11:48.930 --> 00:11:52.300
that we'll call PCAP.

00:11:52.300 --> 00:11:54.765
When you think about a system,
we will always think about it

00:11:54.765 --> 00:11:57.950
in terms of, what are
the primitives?

00:11:57.950 --> 00:12:00.300
How do you combine them?

00:12:00.300 --> 00:12:05.480
How do you abstract a
bigger behavior from

00:12:05.480 --> 00:12:07.350
those smaller behaviors?

00:12:07.350 --> 00:12:11.990
And what are the patterns that
are important to capture?

00:12:11.990 --> 00:12:15.430
So the bigger point is this idea
of PCAP, which we will

00:12:15.430 --> 00:12:20.970
then revisit in every
subsequent module.

00:12:20.970 --> 00:12:24.350
OK, second module is on
signals and systems.

00:12:24.350 --> 00:12:27.580
That's also an enormous area.

00:12:27.580 --> 00:12:29.590
So we only have time
to do one thing.

00:12:29.590 --> 00:12:33.530
The thing that we will do is we
will think about discrete

00:12:33.530 --> 00:12:36.780
time feedback.

00:12:36.780 --> 00:12:40.350
How do you make a system that's
cognizant of what it's

00:12:40.350 --> 00:12:44.580
done so that it, in the future,
can do things with

00:12:44.580 --> 00:12:48.570
awareness of how it got there?

00:12:48.570 --> 00:12:51.920
A good example is robotic
steering.

00:12:51.920 --> 00:12:55.270
So the idea is going to be, OK,
think about what you do

00:12:55.270 --> 00:12:58.160
when you're driving a car.

00:12:58.160 --> 00:13:00.400
And think about how you
would tell a robot to

00:13:00.400 --> 00:13:03.860
do that same thing.

00:13:03.860 --> 00:13:06.390
Here's a naive driving
algorithm.

00:13:06.390 --> 00:13:08.530
I don't recommend it, but it's
widely used in Boston,

00:13:08.530 --> 00:13:09.150
apparently.

00:13:09.150 --> 00:13:11.190
[LAUGHTER]

00:13:11.190 --> 00:13:14.080
I find myself to the right of
where I would like to be.

00:13:14.080 --> 00:13:16.520
So what should I do?

00:13:16.520 --> 00:13:18.500
Turn left.

00:13:18.500 --> 00:13:20.330
I'm still to the right of
where I'd like to be.

00:13:20.330 --> 00:13:22.160
What should I do?

00:13:22.160 --> 00:13:24.060
Turn left.

00:13:24.060 --> 00:13:25.050
Oh!

00:13:25.050 --> 00:13:27.390
I'm exactly where I should be.

00:13:27.390 --> 00:13:30.170
What should I do?

00:13:30.170 --> 00:13:32.470
Go straight ahead.

00:13:32.470 --> 00:13:34.610
Oh, that's a bad idea.

00:13:34.610 --> 00:13:38.400
And what we'll see is that
perfectly innocent looking

00:13:38.400 --> 00:13:42.180
algorithms can have horrendous
performance.

00:13:42.180 --> 00:13:46.490
What we'll do is try to make
an abstraction of that.

00:13:46.490 --> 00:13:48.570
We'll try to make a model.

00:13:48.570 --> 00:13:51.510
We'll try to capture that in
math so that we don't need to

00:13:51.510 --> 00:13:55.020
build it to see the
bad behavior.

00:13:55.020 --> 00:13:57.200
We'll make a model.

00:13:57.200 --> 00:14:01.950
We'll use the model to predict
that that algorithm stinks.

00:14:01.950 --> 00:14:05.490
But more importantly, we'll use
the model to figure out an

00:14:05.490 --> 00:14:07.740
algorithm that'll work better.

00:14:07.740 --> 00:14:11.710
In fact, we'll even be able to
come up with bounds on how

00:14:11.710 --> 00:14:15.920
well such a controller
could possibly work.

00:14:15.920 --> 00:14:19.130
So the focus in this module is
going to be, how do you make a

00:14:19.130 --> 00:14:20.510
model to predict behavior?

00:14:20.510 --> 00:14:24.300
How do you analyze the model
so that you can design a

00:14:24.300 --> 00:14:25.870
better system?

00:14:25.870 --> 00:14:29.970
And then, how do you use the
model and the analysis to make

00:14:29.970 --> 00:14:32.110
a well-behaved system?

00:14:34.830 --> 00:14:37.690
The third module
is on circuits.

00:14:37.690 --> 00:14:39.790
Again, circuits is huge.

00:14:39.790 --> 00:14:41.810
We don't have time to talk
about all of circuits.

00:14:41.810 --> 00:14:43.680
We'll do very simple things.

00:14:43.680 --> 00:14:47.440
We'll focus our attention on
how you would add a sensory

00:14:47.440 --> 00:14:52.770
capability to an already
complicated system.

00:14:52.770 --> 00:14:55.020
The idea is going to be to
start with a robot--

00:14:55.020 --> 00:14:56.150
I guess this is brighter--

00:14:56.150 --> 00:15:03.720
start with our robots and design
a head for the robot.

00:15:03.720 --> 00:15:07.500
The robot comes from the factory
with sonar sensors.

00:15:07.500 --> 00:15:09.000
The sonar sensors are
these things.

00:15:09.000 --> 00:15:10.130
There's eight of them.

00:15:10.130 --> 00:15:13.840
They tell you how far away
something that reflects the

00:15:13.840 --> 00:15:17.560
ultrasonic wave is.

00:15:17.560 --> 00:15:21.960
As they come from the factory,
the robots can't sense light.

00:15:21.960 --> 00:15:24.940
What you'll do is add
light sensors.

00:15:24.940 --> 00:15:29.730
The goal is to make a system
to modify the robot so that

00:15:29.730 --> 00:15:31.720
the robot tracks light.

00:15:31.720 --> 00:15:33.820
That's a very simple goal.

00:15:33.820 --> 00:15:37.970
And the way we'll that is to
augment the robot with a

00:15:37.970 --> 00:15:42.140
simple sensor here, showed a
little more magnified here.

00:15:42.140 --> 00:15:46.030
The idea is that this
is a LEGO motor.

00:15:46.030 --> 00:15:51.980
The LEGO motor will turn this
relative to the attachment.

00:15:51.980 --> 00:15:55.230
That's the robot head's neck.

00:15:55.230 --> 00:16:00.070
So the robot will be
able to do this.

00:16:00.070 --> 00:16:02.170
And the robot will have eyes.

00:16:02.170 --> 00:16:06.680
These are photosensors,
photoresistors, actually.

00:16:06.680 --> 00:16:08.900
So the idea is going to be
that there's information

00:16:08.900 --> 00:16:12.560
available in those sensors for
figuring out where light is so

00:16:12.560 --> 00:16:15.690
that you can track it.

00:16:15.690 --> 00:16:17.940
Your job will be to
build a circuit--

00:16:17.940 --> 00:16:20.290
that that's this thing--

00:16:20.290 --> 00:16:21.760
that connects via cables--

00:16:21.760 --> 00:16:23.800
these red cables and
yellow cables--

00:16:23.800 --> 00:16:25.930
connects via cables
over to this head.

00:16:25.930 --> 00:16:28.770
We'll give you the head.

00:16:28.770 --> 00:16:33.870
Your job will be to make the
circuit that converts the

00:16:33.870 --> 00:16:35.660
signal from the photoresistor--

00:16:35.660 --> 00:16:38.390
which is in proportion
to light--

00:16:38.390 --> 00:16:43.710
and figures out how to turn the
motor to get the head to

00:16:43.710 --> 00:16:47.300
face the light and then ship
that information down to the

00:16:47.300 --> 00:16:51.310
robot to let the robot turn its
wheels to get the body.

00:16:51.310 --> 00:16:54.100
So it's kind of like the light
comes on bright over here.

00:16:54.100 --> 00:16:55.650
The robot looks at it and says,
oh, yeah, that's where I

00:16:55.650 --> 00:16:57.260
want to be.

00:16:57.260 --> 00:17:00.450
So that's the idea in the third
module is to incorporate

00:17:00.450 --> 00:17:04.460
new sensing capabilities
into the robot.

00:17:04.460 --> 00:17:08.069
The final module is on
probability and planning.

00:17:08.069 --> 00:17:14.810
And the idea there is to learn
about how you make systems

00:17:14.810 --> 00:17:22.599
that are robust to uncertainty
and that can implement

00:17:22.599 --> 00:17:26.839
complicated plans, that they,
too, are robust to

00:17:26.839 --> 00:17:28.870
uncertainty.

00:17:28.870 --> 00:17:31.820
So there's a number of things
that we will do, including

00:17:31.820 --> 00:17:36.860
creating maps of spaces that the
robot doesn't understand,

00:17:36.860 --> 00:17:41.030
telling the robot how to
localize itself, how if it

00:17:41.030 --> 00:17:43.050
woke up suddenly in an
environment, it could figure

00:17:43.050 --> 00:17:47.520
out where it is, how
to make a plan.

00:17:47.520 --> 00:17:51.790
And as an example, I'll show you
the kind of system that we

00:17:51.790 --> 00:17:53.540
will construct.

00:17:53.540 --> 00:17:55.950
Here, the idea is that
we have a robot.

00:17:55.950 --> 00:17:58.710
The robot knows where it is.

00:17:58.710 --> 00:18:00.100
Imagine there's a GPS in it.

00:18:00.100 --> 00:18:01.380
There isn't, but imagine
there is.

00:18:01.380 --> 00:18:03.600
So the robot knows where it
is, and it knows where it

00:18:03.600 --> 00:18:04.110
wants to go.

00:18:04.110 --> 00:18:06.965
That's the star.

00:18:06.965 --> 00:18:10.630
But it has no idea what kind of
obstacles are in the way.

00:18:10.630 --> 00:18:15.010
So if you were a robotic driver
in Boston, you know

00:18:15.010 --> 00:18:18.410
that you started out at home and
you want to end up in MIT.

00:18:18.410 --> 00:18:20.330
But there's these annoying
obstacles, they're called

00:18:20.330 --> 00:18:26.450
people, that you should, in
principle at least, miss.

00:18:26.450 --> 00:18:30.500
So that's kind of the idea.

00:18:30.500 --> 00:18:32.460
So I know where I am.

00:18:32.460 --> 00:18:32.980
I'm the robot.

00:18:32.980 --> 00:18:33.650
I know where I am.

00:18:33.650 --> 00:18:34.740
I know where I want to be.

00:18:34.740 --> 00:18:37.570
And I'm going to summarize
that information here.

00:18:37.570 --> 00:18:38.960
Where I am is purple.

00:18:38.960 --> 00:18:40.870
Where I want to be is gold.

00:18:40.870 --> 00:18:43.610
And I have a plan.

00:18:43.610 --> 00:18:45.340
That's blue.

00:18:45.340 --> 00:18:46.330
My plan's very simple.

00:18:46.330 --> 00:18:49.490
I don't know anything about
anything other than I'm in

00:18:49.490 --> 00:18:51.800
Waltham and I want to
go to Cambridge.

00:18:51.800 --> 00:18:54.100
So blast east.

00:18:57.130 --> 00:18:59.250
So I imagine that the
best way to do there

00:18:59.250 --> 00:19:02.390
is a straight line.

00:19:02.390 --> 00:19:07.160
OK, so now what I'm going to
do is turn on the robot.

00:19:07.160 --> 00:19:09.680
The robot has now
made one step.

00:19:09.680 --> 00:19:13.510
And I told you before about
these sonar sensors.

00:19:13.510 --> 00:19:16.370
From the sonar sensors, the
robot has learned now that

00:19:16.370 --> 00:19:19.590
there seems to be something
reflecting at each of these

00:19:19.590 --> 00:19:22.160
black dots.

00:19:22.160 --> 00:19:24.860
It got a reflection from
the black dots,

00:19:24.860 --> 00:19:26.540
from the sonar sensors.

00:19:26.540 --> 00:19:28.670
That means there's probably a
wall there, or a person, or

00:19:28.670 --> 00:19:30.105
something that, in principle,
I should avoid.

00:19:32.820 --> 00:19:37.200
And the red dots represent, OK,
the obstacle is so close I

00:19:37.200 --> 00:19:39.340
really can't get there.

00:19:39.340 --> 00:19:43.620
So I'm excluded from the red
spots because I'm too big.

00:19:43.620 --> 00:19:47.290
The black spots seem
to be an obstacle.

00:19:47.290 --> 00:19:51.040
The red spots seem to be
where I can't fit.

00:19:51.040 --> 00:19:54.750
I still want to go from the
where I am, purple, to where I

00:19:54.750 --> 00:19:56.060
want to be, gold.

00:19:56.060 --> 00:20:00.060
So what I do is I compute
the new plan.

00:20:00.060 --> 00:20:03.580
OK then, I start to take
a step along that plan.

00:20:03.580 --> 00:20:07.990
And as I'm stepping along, OK,
so now, I think that I can't

00:20:07.990 --> 00:20:09.840
go from where I started
over to here.

00:20:09.840 --> 00:20:11.660
I have to go around
this wall that I

00:20:11.660 --> 00:20:14.320
didn't know about initially.

00:20:14.320 --> 00:20:15.355
So now I just start driving.

00:20:15.355 --> 00:20:17.580
And it looks fine, right?

00:20:17.580 --> 00:20:20.230
I'm getting there, right?

00:20:20.230 --> 00:20:21.720
Now, I know I can go
straight down here.

00:20:21.720 --> 00:20:22.230
Oh, wait a minute.

00:20:22.230 --> 00:20:23.210
There's another wall.

00:20:23.210 --> 00:20:26.380
OK, what do I do now?

00:20:26.380 --> 00:20:31.350
So as the robot goes along, it
didn't know when it started

00:20:31.350 --> 00:20:33.480
what kinds of obstacles
it would encounter.

00:20:33.480 --> 00:20:34.895
But as it's driving,
it learned.

00:20:34.895 --> 00:20:36.870
Oh, that didn't work.

00:20:36.870 --> 00:20:39.970
Start over!

00:20:39.970 --> 00:20:46.330
So the idea is that this robot
is executing a very

00:20:46.330 --> 00:20:49.850
complicated plan.

00:20:49.850 --> 00:20:53.640
The plan has, in fact,
many sub-plans.

00:20:53.640 --> 00:20:56.130
And the sub-plans all
involve uncertainty.

00:20:56.130 --> 00:21:00.630
It didn't know where the walls
were when it started.

00:21:00.630 --> 00:21:03.630
And when it's all done, it's
going to have figured out

00:21:03.630 --> 00:21:05.340
where the walls were and--

00:21:05.340 --> 00:21:06.900
provided there's a way--

00:21:06.900 --> 00:21:11.300
presumably find the way to
negotiate the maze and get to

00:21:11.300 --> 00:21:13.440
the destination.

00:21:13.440 --> 00:21:19.120
So the idea, then, is that if
you were asked to write a

00:21:19.120 --> 00:21:23.156
conventional kind of program for
solving that, it might be

00:21:23.156 --> 00:21:25.090
kind of hard because
of the number of

00:21:25.090 --> 00:21:27.450
contingencies involved.

00:21:27.450 --> 00:21:31.240
What we will do is break down
the problem and figure out

00:21:31.240 --> 00:21:34.380
simple and elegant ways
to deal not only with

00:21:34.380 --> 00:21:36.755
uncertainty, but how do you
make complex plans.

00:21:41.360 --> 00:21:45.290
So as I said, our primary
pedagogy is going to be

00:21:45.290 --> 00:21:49.080
practice, theory, practice.

00:21:49.080 --> 00:21:54.880
And so that ramifies in how
the course is organized.

00:21:54.880 --> 00:21:59.370
So this is a quick map of some
of the aspects of the course.

00:21:59.370 --> 00:22:01.670
So we'll have weekly lectures.

00:22:01.670 --> 00:22:04.270
It's lecture unintensive.

00:22:04.270 --> 00:22:06.790
In total, there's only
13 lectures.

00:22:06.790 --> 00:22:10.160
We'll meet once a week
here for lecture.

00:22:10.160 --> 00:22:11.580
There's readings.

00:22:11.580 --> 00:22:13.340
There's voluminous readings.

00:22:13.340 --> 00:22:16.730
There's readings about every
topic that we will talk about.

00:22:16.730 --> 00:22:18.390
And the readings were
specifically

00:22:18.390 --> 00:22:19.910
designed for this course.

00:22:19.910 --> 00:22:21.880
I highly recommend
that you become

00:22:21.880 --> 00:22:23.200
familiar with the readings.

00:22:23.200 --> 00:22:26.510
If you have a question after
lecture, it's probably there.

00:22:26.510 --> 00:22:27.760
It's probably explained.

00:22:30.390 --> 00:22:33.180
We will do online
tutor problems.

00:22:33.180 --> 00:22:36.030
We sent you an email if you
pre-registered for the course.

00:22:36.030 --> 00:22:37.470
So you may already
know about this.

00:22:37.470 --> 00:22:41.540
The idea is going to be that
there's ways that you can

00:22:41.540 --> 00:22:45.350
prepare for the course by doing
computer exercises.

00:22:45.350 --> 00:22:48.850
And we will also use those same
kinds of exercises in all

00:22:48.850 --> 00:22:51.420
of the class sessions.

00:22:51.420 --> 00:22:53.410
We will have two kinds
of lab experiences.

00:22:53.410 --> 00:22:58.390
Besides lecture, the other two
events that you have to attend

00:22:58.390 --> 00:23:01.610
are a software lab
and a design lab.

00:23:01.610 --> 00:23:04.340
That's the practice part.

00:23:04.340 --> 00:23:06.330
So after you learned a little
bit about the theory by going

00:23:06.330 --> 00:23:09.380
to lecture, by doing the
reading, then you go to the

00:23:09.380 --> 00:23:12.310
lab and try some things out.

00:23:12.310 --> 00:23:15.170
We call the first lab
a software lab.

00:23:15.170 --> 00:23:16.100
It's a short lab.

00:23:16.100 --> 00:23:17.020
It's an hour and a half.

00:23:17.020 --> 00:23:18.120
You work individually.

00:23:18.120 --> 00:23:19.260
You try things out.

00:23:19.260 --> 00:23:20.910
You write little programs.

00:23:20.910 --> 00:23:27.390
The courseware can check the
program to see if it's OK.

00:23:27.390 --> 00:23:32.630
And primarily, the exercises
in the software lab are due

00:23:32.630 --> 00:23:34.000
during the software lab.

00:23:34.000 --> 00:23:36.870
But on occasion, there will
be extra things due

00:23:36.870 --> 00:23:38.780
a day or two later.

00:23:38.780 --> 00:23:40.340
The due dates are very
clearly written

00:23:40.340 --> 00:23:42.830
in the tutor exercises.

00:23:42.830 --> 00:23:44.350
Once a week, there's
a design lab.

00:23:44.350 --> 00:23:48.060
That's a three hour session in
which you work with a partner.

00:23:48.060 --> 00:23:51.800
The reason for the partner
is that the intent--

00:23:51.800 --> 00:23:54.000
the difference between the
design labs and the software

00:23:54.000 --> 00:23:58.720
labs is that the design labs ask
you to solve slightly more

00:23:58.720 --> 00:24:04.130
open-ended questions, the kind
of question that you might

00:24:04.130 --> 00:24:06.870
have no clue what
we're asking.

00:24:06.870 --> 00:24:09.170
Open-ended, the kind of thing
that you will be asked to do

00:24:09.170 --> 00:24:10.800
after you graduate.

00:24:10.800 --> 00:24:11.640
Design the system.

00:24:11.640 --> 00:24:12.890
What do you mean, design
the system?

00:24:15.420 --> 00:24:20.250
So the idea is that working with
a partner will give you a

00:24:20.250 --> 00:24:24.030
second, immediate source of
help and a little more

00:24:24.030 --> 00:24:26.700
confidence if neither of you
knows the solution so that you

00:24:26.700 --> 00:24:28.240
raise your hand and say,
I don't have a clue

00:24:28.240 --> 00:24:29.710
what's going on here.

00:24:29.710 --> 00:24:32.470
So the idea is that once a
week we do a software lab

00:24:32.470 --> 00:24:33.400
individually.

00:24:33.400 --> 00:24:36.260
Once a week, we do a design lab,
a little more open-ended

00:24:36.260 --> 00:24:38.170
with partners.

00:24:38.170 --> 00:24:40.865
There's a little bit of written
homework, four total.

00:24:40.865 --> 00:24:43.010
It's not much compared
to other subjects.

00:24:43.010 --> 00:24:46.480
It's mostly practice.

00:24:46.480 --> 00:24:50.610
There's a nano-quiz, just to
help you keep pace to make

00:24:50.610 --> 00:24:53.580
sure that you don't get
too far behind.

00:24:53.580 --> 00:24:56.200
The first 15 minutes
of every design lab

00:24:56.200 --> 00:24:57.560
starts with a nano-quiz.

00:24:57.560 --> 00:25:02.500
The nano-quizzes are intended to
be simple if you've caught

00:25:02.500 --> 00:25:04.860
up, if you're up to date.

00:25:04.860 --> 00:25:08.650
So the idea is that you go to
design lab, the first thing

00:25:08.650 --> 00:25:11.420
you do is a little, 15
minute nano-quiz.

00:25:11.420 --> 00:25:14.560
The nano-quiz uses a tutor much
like the homework tutor,

00:25:14.560 --> 00:25:17.150
much like the Python tutor.

00:25:17.150 --> 00:25:20.450
And it's intended
to be simple.

00:25:20.450 --> 00:25:25.730
But it does mean please get
to the design lab on time.

00:25:25.730 --> 00:25:29.540
The nano-quizzes are
administered by the software.

00:25:29.540 --> 00:25:32.520
It starts the hour when
the design lab starts.

00:25:32.520 --> 00:25:35.090
It times out 15 minutes later.

00:25:35.090 --> 00:25:38.250
So if you come 10 minutes late,
you will have 5 minutes

00:25:38.250 --> 00:25:39.700
to do something that
we planned to give

00:25:39.700 --> 00:25:40.950
you 15 minutes for.

00:25:44.290 --> 00:25:46.720
We will also have exams
and interviews.

00:25:46.720 --> 00:25:51.600
The interviews are intended to
be a one-on-one conversation

00:25:51.600 --> 00:25:52.850
about how the labs went.

00:25:55.520 --> 00:25:59.340
And we will have two mid-terms
and a final.

00:25:59.340 --> 00:26:01.050
So that's kind of
the logistics.

00:26:01.050 --> 00:26:05.880
The idea behind the logistics is
practice, theory, practice.

00:26:05.880 --> 00:26:06.830
Come to the labs.

00:26:06.830 --> 00:26:07.780
Try things out.

00:26:07.780 --> 00:26:09.160
Make sure you understand.

00:26:09.160 --> 00:26:10.280
Develop a little code.

00:26:10.280 --> 00:26:10.820
Type it in.

00:26:10.820 --> 00:26:12.290
See if it works.

00:26:12.290 --> 00:26:14.890
If it works, you're
on top of things.

00:26:14.890 --> 00:26:18.240
You're ready to get the next
batch of information from the

00:26:18.240 --> 00:26:21.050
lecture and readings.

00:26:21.050 --> 00:26:23.770
OK, let's go on, and let's
talk about the technical

00:26:23.770 --> 00:26:25.990
material in the first module
of the course, in

00:26:25.990 --> 00:26:27.580
the software module.

00:26:27.580 --> 00:26:31.720
We kick the course off talking
about software engineering for

00:26:31.720 --> 00:26:32.500
two reasons.

00:26:32.500 --> 00:26:34.190
We'd like you to know about
software engineering.

00:26:34.190 --> 00:26:39.060
It's an incredibly important
part of our department.

00:26:39.060 --> 00:26:41.690
It's an incredibly important
part of the engineering of

00:26:41.690 --> 00:26:46.490
absolutely any system,
any modern system.

00:26:46.490 --> 00:26:49.520
But we'd also like you to know
about it because it provides a

00:26:49.520 --> 00:26:52.460
very convenient way to think
about-- it's a convenient

00:26:52.460 --> 00:26:59.220
language to think about the
design issues, the engineering

00:26:59.220 --> 00:27:01.800
issues in all the other
parts of the class.

00:27:01.800 --> 00:27:03.330
So it's a very good
place to start.

00:27:06.840 --> 00:27:10.800
So what I will do today is talk
about some of the very

00:27:10.800 --> 00:27:15.530
simplest ideas about abstraction
and modularity in

00:27:15.530 --> 00:27:19.300
what I think of as the lowest
level of granularity.

00:27:19.300 --> 00:27:22.240
How do you think about
abstraction and modularity at

00:27:22.240 --> 00:27:25.760
the micro scale, at
the individual

00:27:25.760 --> 00:27:28.870
lines of code scale?

00:27:28.870 --> 00:27:33.620
As I said earlier, we will,
as we progress, look at

00:27:33.620 --> 00:27:37.530
modularity and abstraction
at the higher scale.

00:27:37.530 --> 00:27:38.990
But we have to start
somewhere.

00:27:38.990 --> 00:27:41.220
And we're going to start by
thinking about, how do you

00:27:41.220 --> 00:27:46.230
think about abstraction and
modularity at the micro scale?

00:27:46.230 --> 00:27:49.250
Special note about
programming.

00:27:49.250 --> 00:27:54.640
So what we are trying to do is,
in the first two weeks,

00:27:54.640 --> 00:28:00.000
ramp everybody up to some level
of software security,

00:28:00.000 --> 00:28:03.330
where you feel comfortable.

00:28:03.330 --> 00:28:07.570
So the first two weeks of this
course is intended to make you

00:28:07.570 --> 00:28:09.200
comfortable with programming.

00:28:09.200 --> 00:28:11.770
We don't assume you've done
extensive programming before.

00:28:14.750 --> 00:28:16.750
We want you to become
comfortable

00:28:16.750 --> 00:28:19.160
that you're not behind.

00:28:19.160 --> 00:28:24.060
And that's the focus of the
first two weeks' exercises.

00:28:24.060 --> 00:28:27.400
If you have little or no
previous background, if you

00:28:27.400 --> 00:28:32.990
are uncomfortable, please do
the Python tutor exercises.

00:28:32.990 --> 00:28:34.770
If you have not --

00:28:34.770 --> 00:28:38.240
if you do not have a lot of
experience programming, if

00:28:38.240 --> 00:28:41.970
you're uncomfortable with the
expectation that you can do

00:28:41.970 --> 00:28:46.240
programming, do that first.

00:28:46.240 --> 00:28:49.320
That takes priority over all the
other assignments during

00:28:49.320 --> 00:28:52.350
the first two weeks.

00:28:52.350 --> 00:28:56.190
In particular, if you're
uncomfortable, we will run a

00:28:56.190 --> 00:29:00.580
special Python help
session on Sunday.

00:29:00.580 --> 00:29:05.213
And if you attend that, you
can get a free extension.

00:29:08.140 --> 00:29:12.480
The idea is completing the tutor
exercises is intended to

00:29:12.480 --> 00:29:14.920
make you feel comfortable that
you have the software

00:29:14.920 --> 00:29:18.320
background to finish the
rest of the course.

00:29:18.320 --> 00:29:20.640
Do that first.

00:29:20.640 --> 00:29:26.000
We will forgive falling behind
in other things so that you

00:29:26.000 --> 00:29:29.190
feel comfortable with
programming.

00:29:29.190 --> 00:29:34.650
If, at the end of two weeks, you
still feel uncomfortable,

00:29:34.650 --> 00:29:40.780
we have a deal with 6.00, the
Python programming class, that

00:29:40.780 --> 00:29:43.170
they will allow you to switch
your registration

00:29:43.170 --> 00:29:46.360
from 6.01 to 6.00.

00:29:46.360 --> 00:29:49.990
But that expires Valentine's
Day.

00:29:49.990 --> 00:29:51.810
[LAUGHTER]

00:29:51.810 --> 00:29:54.730
So you have to make up your mind
before Valentine's Day if

00:29:54.730 --> 00:29:57.020
you'd like to use that option.

00:29:57.020 --> 00:30:00.850
So the idea is we'd like you
to be comfortable with

00:30:00.850 --> 00:30:01.620
programming.

00:30:01.620 --> 00:30:03.750
If you haven't programmed
before, do the

00:30:03.750 --> 00:30:05.120
Python tutor exercises.

00:30:05.120 --> 00:30:06.960
Go to software lab.

00:30:06.960 --> 00:30:10.350
Go to design lab, but work
on the tutor exercises.

00:30:10.350 --> 00:30:13.340
The staff will help
you with them.

00:30:13.340 --> 00:30:14.710
You can go to office hours.

00:30:14.710 --> 00:30:18.410
There's office hours listed
on the home page.

00:30:18.410 --> 00:30:20.630
You should try to become
comfortable, and you should

00:30:20.630 --> 00:30:22.510
try to set as your goal --

00:30:22.510 --> 00:30:25.510
I'm going to be comfortable
before Valentine's Day.

00:30:25.510 --> 00:30:29.220
And if you're not, talk to a
staff member about that.

00:30:32.320 --> 00:30:36.880
OK, so what do I want you to
know about programming?

00:30:36.880 --> 00:30:39.300
Well, we're going
to use Python.

00:30:39.300 --> 00:30:46.390
We selected Python because it's
very simple and because

00:30:46.390 --> 00:30:51.130
it lets us illustrate some
very important ideas in

00:30:51.130 --> 00:30:55.120
software engineering in
a very simple context.

00:30:55.120 --> 00:30:57.050
That's the reason.

00:30:57.050 --> 00:31:01.320
One of the reasons that it's
simple is that it's an

00:31:01.320 --> 00:31:02.570
interpreter.

00:31:04.630 --> 00:31:10.020
After some initialization, the
behavior of Python is to fall

00:31:10.020 --> 00:31:11.736
into an interpreter loop.

00:31:11.736 --> 00:31:16.450
The interpreter loop is, ask the
user what he would like me

00:31:16.450 --> 00:31:24.370
to do, read what the user types,
figure out what they're

00:31:24.370 --> 00:31:28.430
talking about, and print
the result, repeat--

00:31:28.430 --> 00:31:29.140
very simple.

00:31:29.140 --> 00:31:32.590
What that means is that you
can learn by doing.

00:31:35.090 --> 00:31:38.760
That's one of the points of
today's software lab.

00:31:38.760 --> 00:31:40.720
You can simply walk
up to a computer,

00:31:40.720 --> 00:31:43.940
type the word python--

00:31:43.940 --> 00:31:46.640
what you type is in red.

00:31:46.640 --> 00:31:51.380
Type the word "python." It
will prompt you, so this

00:31:51.380 --> 00:31:54.490
chevron, that says, I'd
like you to tell me

00:31:54.490 --> 00:31:55.180
something to do.

00:31:55.180 --> 00:31:57.550
I have nothing to do.

00:31:57.550 --> 00:32:01.350
If you type "2," Python tries
to interpret that.

00:32:01.350 --> 00:32:05.000
In this particular case,
Python says, oh, I see.

00:32:05.000 --> 00:32:06.810
That's a primitive data item.

00:32:06.810 --> 00:32:08.250
That's an integer.

00:32:08.250 --> 00:32:10.860
This person wants me to
understand an integer.

00:32:10.860 --> 00:32:17.040
And so it will echo 2,
indicating that it thinks you

00:32:17.040 --> 00:32:18.750
want it to understand
a simple integer.

00:32:21.260 --> 00:32:25.000
Similarly, if you type 5.7,
it says, oh, I got that.

00:32:25.000 --> 00:32:27.320
That's a float.

00:32:27.320 --> 00:32:28.820
The person wants me
to remember a

00:32:28.820 --> 00:32:31.160
floating point number.

00:32:31.160 --> 00:32:35.290
And it will similarly
echo the float.

00:32:35.290 --> 00:32:40.550
Now, of course, there's no
exact representation for

00:32:40.550 --> 00:32:41.800
floats, right?

00:32:41.800 --> 00:32:43.030
There's too many
of them, right?

00:32:43.030 --> 00:32:44.710
There's a lot of them.

00:32:44.710 --> 00:32:48.150
There's even more floats than
there are ints, right?

00:32:48.150 --> 00:32:50.950
So it has an approximation.

00:32:50.950 --> 00:32:54.810
So it will print its
approximation to the float

00:32:54.810 --> 00:32:56.770
that it thinks you are
interested in.

00:32:59.560 --> 00:33:04.520
If you type a string, "Hello,"
it'll say, oh, primitive data

00:33:04.520 --> 00:33:07.050
structure, string.

00:33:07.050 --> 00:33:09.760
And it'll print out
that string.

00:33:09.760 --> 00:33:12.780
So the idea is one of the
features of Python that makes

00:33:12.780 --> 00:33:16.410
it easy to learn is the fact
that it's interpreter based.

00:33:16.410 --> 00:33:17.350
You can play around.

00:33:17.350 --> 00:33:19.230
You can learn by doing.

00:33:19.230 --> 00:33:23.070
Now, of course, if the only
thing it did was simple data

00:33:23.070 --> 00:33:24.865
structures, it would
not be very useful.

00:33:27.540 --> 00:33:32.010
So the next more complex thing
that it can do is think about

00:33:32.010 --> 00:33:34.270
combinations.

00:33:34.270 --> 00:33:38.130
If you type "2 + 3," it
says, oh, I got it.

00:33:38.130 --> 00:33:40.000
This person's interested
in a combination.

00:33:40.000 --> 00:33:46.250
I should combine by the plus
operator two ints, 2 and 3.

00:33:46.250 --> 00:33:48.890
Oh, and if I do that, if I
combine by the plus operator

00:33:48.890 --> 00:33:50.290
two and three, I'll get 5.

00:33:50.290 --> 00:33:52.640
So it prints 5.

00:33:52.640 --> 00:33:59.120
So that's a way you know that
it interprets "2 + 3" as 5.

00:33:59.120 --> 00:34:02.950
Similarly here, except
I've mixed types.

00:34:02.950 --> 00:34:08.710
"5.7 + 3," it says, oh, this
user wants me to apply the

00:34:08.710 --> 00:34:12.489
plus operator on a
float and an int.

00:34:12.489 --> 00:34:15.840
OK, well I'll upgrade
the int to a float.

00:34:15.840 --> 00:34:20.560
I'll do the float version, and
I'll get this, which is its

00:34:20.560 --> 00:34:26.150
representation of 8.7.

00:34:26.150 --> 00:34:29.360
So the idea is that it will
first try to interpret what

00:34:29.360 --> 00:34:31.600
you're saying as a
simple data type.

00:34:31.600 --> 00:34:34.840
If that works, it prints the
result to tell you what it

00:34:34.840 --> 00:34:36.270
thinks is going on.

00:34:36.270 --> 00:34:39.679
It then will try to interpret
it as an expression.

00:34:39.679 --> 00:34:43.630
And sometimes, the expressions
won't makes sense.

00:34:43.630 --> 00:34:46.340
In particular, if you try to add
an int to a string, it's

00:34:46.340 --> 00:34:48.110
going to say, huh?

00:34:48.110 --> 00:34:50.810
And over the course of the first
two weeks, we hope that

00:34:50.810 --> 00:34:52.889
you get familiar with
interpreting

00:34:52.889 --> 00:34:55.330
this kind of mess.

00:34:55.330 --> 00:34:59.430
That's Python's attempt to tell
you what it was trying to

00:34:59.430 --> 00:35:03.130
do on your behalf and can't
figure out what

00:35:03.130 --> 00:35:04.380
you're talking about.

00:35:07.040 --> 00:35:09.280
OK, so that was simple.

00:35:09.280 --> 00:35:11.350
But it already illustrates
something that's very

00:35:11.350 --> 00:35:16.730
important, and that's the
idea of a composition.

00:35:16.730 --> 00:35:22.306
So the way Python works, the
fact that when you added 3 to

00:35:22.306 --> 00:35:27.950
2 it came out 5, what we were
doing was composing

00:35:27.950 --> 00:35:29.030
complicated--

00:35:29.030 --> 00:35:32.060
well, potentially complicated
(that was pretty simple) --

00:35:32.060 --> 00:35:36.470
potentially complicated
expressions and reducing them

00:35:36.470 --> 00:35:38.035
to a single data structure.

00:35:41.160 --> 00:35:46.190
And so that means that, in some
sense, this operation, 3

00:35:46.190 --> 00:35:53.030
times 8, can be thought of as
exactly the same as if the

00:35:53.030 --> 00:35:56.610
user had typed in 24.

00:35:56.610 --> 00:36:02.570
Whenever you can substitute
for a complex expression a

00:36:02.570 --> 00:36:07.490
simpler thing, we say that the
system is compositional.

00:36:07.490 --> 00:36:10.290
That's a very powerful idea.

00:36:10.290 --> 00:36:12.380
Even though it's simple, it's
a very powerful idea.

00:36:12.380 --> 00:36:16.120
And it's an idea that
you all know.

00:36:16.120 --> 00:36:20.580
You've seen it before in
algebra, in arithmetic.

00:36:20.580 --> 00:36:24.680
So in arithmetic expressions,
you can think about how the

00:36:24.680 --> 00:36:26.540
sum of two integers is an int.

00:36:29.530 --> 00:36:30.410
That's a closure.

00:36:30.410 --> 00:36:33.550
That's a kind of a combination
that makes the system

00:36:33.550 --> 00:36:38.220
compositional and that
provides a layer of

00:36:38.220 --> 00:36:41.950
hierarchical thinking so that,
in your head, even though it

00:36:41.950 --> 00:36:44.510
says 3 times 8, you don't need
to remember that anymore.

00:36:44.510 --> 00:36:47.920
You can say, oh, for any
purposes that follow, I might

00:36:47.920 --> 00:36:49.880
just as well think of
3 times 8 as being a

00:36:49.880 --> 00:36:53.670
single integer, 24.

00:36:53.670 --> 00:36:58.450
It's part of many other kinds
of systems, for example,

00:36:58.450 --> 00:37:00.850
natural language.

00:37:00.850 --> 00:37:03.810
The simplest example in natural
language is that you

00:37:03.810 --> 00:37:06.440
can think about "Apples
are good as snacks".

00:37:06.440 --> 00:37:08.490
"Apples" is a noun.

00:37:08.490 --> 00:37:11.380
It's a plural noun.

00:37:11.380 --> 00:37:15.130
Or you could substitute "Apples
and oranges", and it

00:37:15.130 --> 00:37:18.040
makes complete sense within
that same structure.

00:37:18.040 --> 00:37:22.450
So "Apples and oranges
are good as snacks".

00:37:22.450 --> 00:37:27.510
The combination of "apples" and
"oranges" works in every

00:37:27.510 --> 00:37:30.900
way from the point of view of
the grammar in the same way

00:37:30.900 --> 00:37:36.390
that a simple noun,
"apples," worked.

00:37:36.390 --> 00:37:40.270
What we would like to do is use
that idea as the starting

00:37:40.270 --> 00:37:43.590
point for a more general
compositional system.

00:37:46.790 --> 00:37:52.210
And a good way to think about
that is by way of names.

00:37:52.210 --> 00:37:55.550
What if we had some sequence of
operations that we think is

00:37:55.550 --> 00:38:00.220
particularly important so that
we would like to somehow

00:38:00.220 --> 00:38:04.100
canonize that so that,
subsequently, we can use that

00:38:04.100 --> 00:38:07.960
sequence of operations easily?

00:38:07.960 --> 00:38:10.680
Python provides a very
simple way to do it.

00:38:10.680 --> 00:38:11.960
Every programming
language does.

00:38:11.960 --> 00:38:14.550
It's not unique to Python.

00:38:14.550 --> 00:38:16.050
But the idea is --

00:38:16.050 --> 00:38:17.600
so here's an example.

00:38:17.600 --> 00:38:19.640
"2 times 2" --

00:38:19.640 --> 00:38:22.230
I'm squaring 2 and get
4. "3 times 3" --

00:38:22.230 --> 00:38:24.970
I'm squaring 3, and
I'm getting 9.

00:38:24.970 --> 00:38:29.400
"8 plus 4 times 8 plus 4",
I'm squaring "8 plus 4".

00:38:29.400 --> 00:38:31.300
"8 plus 4", well, I can
think of that as 12.

00:38:31.300 --> 00:38:34.940
I'm squaring 12, I'm
getting 144.

00:38:34.940 --> 00:38:37.280
The thing I'm trying to
illustrate there is the notion

00:38:37.280 --> 00:38:38.990
of squaring.

00:38:38.990 --> 00:38:43.970
Squaring is a sequence of
operations that I would like

00:38:43.970 --> 00:38:49.040
to be able to canonize as a
single entity so that, in

00:38:49.040 --> 00:38:51.140
subsequent programs, I can
think of the squaring

00:38:51.140 --> 00:38:54.880
operation as a single
operation just

00:38:54.880 --> 00:38:56.950
like I think of times.

00:38:56.950 --> 00:39:01.460
The way we say that in Python
is "define square of x to be

00:39:01.460 --> 00:39:02.710
return x squared".

00:39:07.190 --> 00:39:10.880
Then, having made that
definition, I can say "square

00:39:10.880 --> 00:39:14.040
of 6", and the answer is 36.

00:39:14.040 --> 00:39:15.850
OK, this is a very small step.

00:39:15.850 --> 00:39:18.150
But it illustrates a very
important point, the idea

00:39:18.150 --> 00:39:23.580
being that Python provides
a compositional facility.

00:39:27.630 --> 00:39:28.880
And it's hierarchical.

00:39:31.420 --> 00:39:35.240
Having defined square, I can use
square just as though it

00:39:35.240 --> 00:39:38.720
were a primitive operator.

00:39:38.720 --> 00:39:44.840
And I can use square to define
higher level operations.

00:39:44.840 --> 00:39:47.780
So for example, what if I were
interested in doing lots of

00:39:47.780 --> 00:39:49.320
sums of squares?

00:39:49.320 --> 00:39:51.960
Say I'm Pythagoreas, right?

00:39:51.960 --> 00:39:55.460
So I might want to add the
square of 2 and the square of

00:39:55.460 --> 00:39:58.720
4 to get 20, or the square
of 3 with the

00:39:58.720 --> 00:40:01.950
square of 4 to get 25.

00:40:01.950 --> 00:40:06.810
Using that simple idea of
composition, we can write a

00:40:06.810 --> 00:40:10.080
new program, sumOfSquares.

00:40:10.080 --> 00:40:13.540
sumOfSquares takes two
arguments, x and y.

00:40:13.540 --> 00:40:16.980
And it returns the square of
x and the square of y.

00:40:16.980 --> 00:40:19.530
SumOfSquares doesn't
care about how

00:40:19.530 --> 00:40:22.000
you compute the square.

00:40:22.000 --> 00:40:25.150
It trusts that square knows
how to do that.

00:40:25.150 --> 00:40:28.590
So the work is smaller.

00:40:28.590 --> 00:40:32.170
The idea is that square
takes care of

00:40:32.170 --> 00:40:35.470
squaring single numbers.

00:40:35.470 --> 00:40:39.190
sumOfSquares doesn't have to
know how to square numbers.

00:40:39.190 --> 00:40:44.390
It just needs to know how to
make a sum of squares.

00:40:44.390 --> 00:40:47.530
So what we've done is we've
broken a task, which was not

00:40:47.530 --> 00:40:52.560
very complicated, but the whole
idea is hierarchical.

00:40:52.560 --> 00:40:56.730
We've taken a problem and broken
it into two pieces.

00:40:56.730 --> 00:40:59.440
We factored the problem into
how do you do a square, and

00:40:59.440 --> 00:41:00.690
how do you sum squares.

00:41:03.210 --> 00:41:07.200
And the idea, then, is that this
hierarchical structure is

00:41:07.200 --> 00:41:12.920
a way of building complex
systems out of simpler parts.

00:41:17.130 --> 00:41:23.450
So that's the idea of how you
would build programs that are

00:41:23.450 --> 00:41:24.700
compositional.

00:41:27.320 --> 00:41:32.430
Python also provides a utility
for making lists, for making

00:41:32.430 --> 00:41:36.220
data structures that
are compositional.

00:41:39.950 --> 00:41:44.940
The most primitive is a list.

00:41:44.940 --> 00:41:48.570
So in Python, you can
specify a list.

00:41:48.570 --> 00:41:51.540
Here's a list of integers.

00:41:51.540 --> 00:41:53.860
So the list says, beginning
list, end of

00:41:53.860 --> 00:41:55.020
list, elements of list.

00:41:55.020 --> 00:41:57.170
So there's five elements
in the list, the

00:41:57.170 --> 00:41:58.420
integers 1, 2, 3, 4, 5.

00:42:00.940 --> 00:42:07.310
Python doesn't care what the
elements of a list are.

00:42:07.310 --> 00:42:11.440
We'll see in a minute that
that's really important.

00:42:11.440 --> 00:42:13.520
But for the time being, the
simplest thing that you can

00:42:13.520 --> 00:42:15.840
imagine is a heterogeneous
list.

00:42:15.840 --> 00:42:21.030
It's not critical that the list
contain just integers.

00:42:21.030 --> 00:42:23.510
Here's a list that contains
an int, a string,

00:42:23.510 --> 00:42:25.450
an int, and a string.

00:42:25.450 --> 00:42:26.810
Python doesn't care.

00:42:26.810 --> 00:42:28.630
It's a list that has
four elements.

00:42:28.630 --> 00:42:29.880
The first element's an int.

00:42:29.880 --> 00:42:34.120
The second element's a
string, et cetera.

00:42:34.120 --> 00:42:36.690
Here's an even more
complex example.

00:42:36.690 --> 00:42:38.045
Here's a list of lists.

00:42:41.320 --> 00:42:46.860
How many elements are
in that list?

00:42:46.860 --> 00:42:49.300
Three.

00:42:49.300 --> 00:42:53.030
How many elements are
in that list?

00:42:53.030 --> 00:42:57.730
So the idea is that you can
build more complex data

00:42:57.730 --> 00:42:59.660
structures out of simple ones.

00:42:59.660 --> 00:43:02.980
That's the idea of compositional
factoring

00:43:02.980 --> 00:43:04.230
applied to data.

00:43:07.840 --> 00:43:12.040
Just like it was important when
we were thinking about

00:43:12.040 --> 00:43:16.350
procedures, to associate
names with procedures--

00:43:16.350 --> 00:43:19.280
that's what "def" did--

00:43:19.280 --> 00:43:22.360
we can also think about
associating names with data

00:43:22.360 --> 00:43:24.790
structures.

00:43:24.790 --> 00:43:27.060
And that's what we use something
that Python calls a

00:43:27.060 --> 00:43:29.540
variable for.

00:43:29.540 --> 00:43:32.940
So I can say "b is 3".

00:43:32.940 --> 00:43:39.990
And that associates the data
item, 3, with the label, b.

00:43:39.990 --> 00:43:44.510
I can say, "x is 5 times 2.2".

00:43:44.510 --> 00:43:46.310
Python will figure out
what I mean by the

00:43:46.310 --> 00:43:49.170
expression on the right.

00:43:49.170 --> 00:43:52.480
It'll figure out that I'm
composing by using the star

00:43:52.480 --> 00:43:55.600
operator, which is multiply, an
integer and a float, which

00:43:55.600 --> 00:43:57.090
will give me a float.

00:43:57.090 --> 00:44:00.780
The answer to that's going to
be a floating point number.

00:44:00.780 --> 00:44:06.650
And it will assign a label, x,
to that floating point number.

00:44:06.650 --> 00:44:10.030
You can have a more complicated
list, a data

00:44:10.030 --> 00:44:13.250
structure, and associate
the name y with it.

00:44:13.250 --> 00:44:15.790
Then, having associated the name
y, you get many of the

00:44:15.790 --> 00:44:19.590
same benefits of associating a
name with a data structure

00:44:19.590 --> 00:44:22.980
that we got previously
in associating a

00:44:22.980 --> 00:44:25.480
name with an operation.

00:44:25.480 --> 00:44:28.370
So we can say, y(0).

00:44:28.370 --> 00:44:32.680
And what that means is, what's
the zero-th elements of the

00:44:32.680 --> 00:44:35.450
data structure, y?

00:44:35.450 --> 00:44:37.390
So the zero-th element of
the data structure,

00:44:37.390 --> 00:44:38.760
y, is a list, [1, 2, 3].

00:44:42.940 --> 00:44:45.980
Python has some funky
notations.

00:44:45.980 --> 00:44:49.010
The -1 element is
the last one.

00:44:49.010 --> 00:44:51.470
So the -1th element
of y is [7, 8, 9].

00:44:54.500 --> 00:44:57.270
And it's completely
hierarchical.

00:44:57.270 --> 00:45:01.040
If I asked for the -1 element
of y, I get [7, 8, 9].

00:45:01.040 --> 00:45:02.770
But then, if I asked for the
first element of that

00:45:02.770 --> 00:45:06.870
result, I get 8.

00:45:06.870 --> 00:45:08.220
OK?

00:45:08.220 --> 00:45:09.470
Everything is clear?

00:45:12.410 --> 00:45:15.030
OK, just to make sure everything
is clear, I want to

00:45:15.030 --> 00:45:17.060
ask you a question.

00:45:17.060 --> 00:45:19.340
But to kick off the idea of
working together, I'd like you

00:45:19.340 --> 00:45:21.670
to think about this question
with your neighbor.

00:45:21.670 --> 00:45:27.650
So before thinking about this
question, everybody stand up.

00:45:27.650 --> 00:45:29.290
Introduce yourself
to your neighbor.

00:45:29.290 --> 00:46:34.430
[AUDIENCE TALKS]

00:46:34.430 --> 00:46:43.870
So now, I'd like you to each
discuss with your neighbor the

00:46:43.870 --> 00:46:46.510
list that is best represented
by which of the following

00:46:46.510 --> 00:46:49.840
figures, 1, 2, 3, 4, or 5,
or none of the above.

00:46:49.840 --> 00:46:52.670
And in 30 seconds, I'm going
to ask everybody to raise a

00:46:52.670 --> 00:46:58.100
hand with a number of fingers
indicating the right answer.

00:46:58.100 --> 00:47:00.120
You're allowed to talk.

00:47:00.120 --> 00:47:02.479
That's the whole point
of having a partner.

00:47:02.479 --> 00:48:37.950
[AUDIENCE TALKS]

00:48:37.950 --> 00:48:39.200
OK.

00:48:41.940 --> 00:48:45.460
I'd like everybody now
to raise their hand.

00:48:45.460 --> 00:48:47.930
Put up the number of fingers
that show the answer.

00:48:47.930 --> 00:48:49.270
And I want to tally.

00:48:52.330 --> 00:48:53.040
Fantastic!

00:48:53.040 --> 00:48:54.420
Everybody gets it.

00:48:54.420 --> 00:48:57.530
OK, so which one do you like?

00:48:57.530 --> 00:48:58.330
AUDIENCE: 3.

00:48:58.330 --> 00:48:59.580
PROFESSOR: 3 --

00:48:59.580 --> 00:49:01.000
why do you like three.

00:49:01.000 --> 00:49:04.385
Somebody explain this to me?

00:49:04.385 --> 00:49:06.200
It just looks good?

00:49:06.200 --> 00:49:09.665
Its pattern recognition.

00:49:09.665 --> 00:49:12.635
What's good about 3?

00:49:12.635 --> 00:49:13.872
AUDIENCE: It shows
the compositional

00:49:13.872 --> 00:49:16.120
element of the list.

00:49:16.120 --> 00:49:16.890
PROFESSOR: Compositional?

00:49:16.890 --> 00:49:19.600
What is the compositional
element in the pictures?

00:49:22.790 --> 00:49:26.460
What represents what?

00:49:26.460 --> 00:49:28.370
OK, 'a' represents a.

00:49:28.370 --> 00:49:30.760
That's pretty easy, right?

00:49:30.760 --> 00:49:32.860
So that takes care of the
bulk of the figures.

00:49:32.860 --> 00:49:34.230
What's the blue lines
represent?

00:49:39.708 --> 00:49:40.704
Someone else?

00:49:40.704 --> 00:49:42.696
I didn't quite understand.

00:49:42.696 --> 00:49:45.690
AUDIENCE: The angles represent
like a list.

00:49:45.690 --> 00:49:47.469
PROFESSOR: They represent
a list.

00:49:47.469 --> 00:49:51.690
Where is the list
on the figures?

00:49:51.690 --> 00:49:52.630
AUDIENCE: The vertex?

00:49:52.630 --> 00:49:53.700
PROFESSOR: The vertex.

00:49:53.700 --> 00:49:57.050
The vertices are lists.

00:49:57.050 --> 00:49:59.300
So in 3 --

00:49:59.300 --> 00:50:03.960
at the highest level, we have a
list that's composed of how

00:50:03.960 --> 00:50:05.730
many elements?

00:50:05.730 --> 00:50:06.770
2.

00:50:06.770 --> 00:50:08.726
The first element
of that list is?

00:50:08.726 --> 00:50:09.420
AUDIENCE: a.

00:50:09.420 --> 00:50:11.220
PROFESSOR: And the second
element of that list is?

00:50:11.220 --> 00:50:11.730
AUDIENCE: Another list.

00:50:11.730 --> 00:50:12.660
PROFESSOR: Another list.

00:50:12.660 --> 00:50:15.650
That's the hierarchical
part, right?

00:50:15.650 --> 00:50:18.740
That second list has
how many elements?

00:50:18.740 --> 00:50:19.440
AUDIENCE: 2.

00:50:19.440 --> 00:50:21.066
PROFESSOR: Fine,
good, recurse.

00:50:21.066 --> 00:50:22.920
You got it.

00:50:22.920 --> 00:50:25.300
What is the list represented
by number 2?

00:50:29.260 --> 00:50:32.530
A single list with
five elements.

00:50:32.530 --> 00:50:36.710
Square bracket, a, comma, b,
comma, c, comma, d, comma, e,

00:50:36.710 --> 00:50:38.990
square bracket, right?

00:50:38.990 --> 00:50:42.383
What is the list represented
by that one?

00:50:42.383 --> 00:50:45.329
AUDIENCE: Not a list.

00:50:45.329 --> 00:50:47.300
PROFESSOR: Agh!

00:50:47.300 --> 00:50:49.660
It's not a list!

00:50:49.660 --> 00:50:50.670
What is it?

00:50:50.670 --> 00:50:52.826
Who knows?

00:50:52.826 --> 00:50:53.710
AUDIENCE: Looking
at the variable

00:50:53.710 --> 00:50:55.286
names, it defines them.

00:50:55.286 --> 00:50:56.270
You have variables.

00:50:56.270 --> 00:50:58.074
You have a variable a, that
defines a list that contains

00:50:58.074 --> 00:51:00.370
b, and the variable, c, that
defines another list that

00:51:00.370 --> 00:51:01.682
contains d.

00:51:01.682 --> 00:51:05.140
PROFESSOR: So we could
make that a variable.

00:51:05.140 --> 00:51:09.080
If we said a is a variable that
comprises b and c, then

00:51:09.080 --> 00:51:11.560
we have the problem of how
we're going to associate

00:51:11.560 --> 00:51:17.020
variables and elements into
this list, right?

00:51:17.020 --> 00:51:19.760
So the weird thing about
this one and, let's

00:51:19.760 --> 00:51:20.980
see, that one's weird.

00:51:20.980 --> 00:51:22.290
This one's also kind of weird.

00:51:22.290 --> 00:51:27.470
This one's weird because we're
giving names to lists in a

00:51:27.470 --> 00:51:31.940
fashion that's not showed
up here, right?

00:51:31.940 --> 00:51:34.060
That's not to say you couldn't
invent a meaning.

00:51:34.060 --> 00:51:36.800
It's just that it doesn't
map very well to that

00:51:36.800 --> 00:51:38.960
representation.

00:51:38.960 --> 00:51:43.360
Similarly over here, we seem to
be giving the name b to the

00:51:43.360 --> 00:51:46.920
element a, and then the name
c to the element b.

00:51:46.920 --> 00:51:47.800
What on earth are you
talking about?

00:51:47.800 --> 00:51:50.690
It's not clear what we're
doing their either.

00:51:50.690 --> 00:51:54.020
So the point is to get you
thinking about the abstract

00:51:54.020 --> 00:51:57.200
representation of lists and how
that maps into a complex

00:51:57.200 --> 00:51:58.030
data structure.

00:51:58.030 --> 00:52:00.360
That was the whole point.

00:52:00.360 --> 00:52:05.920
OK, so we've talked about,
then, four things so far.

00:52:05.920 --> 00:52:08.770
How do you think about
operations in a

00:52:08.770 --> 00:52:10.880
hierarchical fashion.

00:52:10.880 --> 00:52:13.210
And the idea was composition.

00:52:13.210 --> 00:52:18.230
We think about composing simple
operations to make

00:52:18.230 --> 00:52:21.270
bigger, compound operations.

00:52:21.270 --> 00:52:24.840
That's a way of saying, there's
this set of operations

00:52:24.840 --> 00:52:27.170
that I want to call foo.

00:52:27.170 --> 00:52:29.510
So every time I do this
complicated thing that has

00:52:29.510 --> 00:52:33.830
three pages of code,
that's one foo.

00:52:33.830 --> 00:52:37.950
And that's a way that we can
then combined foos in some

00:52:37.950 --> 00:52:42.810
other horribly complicated
way to make big foos.

00:52:42.810 --> 00:52:44.500
So the idea is composition.

00:52:44.500 --> 00:52:45.580
That's the first idea.

00:52:45.580 --> 00:52:51.030
The second is associating a name
with that composition.

00:52:51.030 --> 00:52:54.210
That's what "def" does--
define name, name of a

00:52:54.210 --> 00:52:55.780
sub-routine.

00:52:55.780 --> 00:52:58.030
So we thought about composing
operations,

00:52:58.030 --> 00:52:59.990
associating names with them.

00:52:59.990 --> 00:53:03.710
We composed data in terms of
lists, and we associated names

00:53:03.710 --> 00:53:06.040
with those lists in terms
of variables.

00:53:06.040 --> 00:53:09.030
The next thing we want to think
about is a higher order

00:53:09.030 --> 00:53:13.400
construct where we would like to
conglomerate into one data

00:53:13.400 --> 00:53:18.550
structure both data
and procedures.

00:53:18.550 --> 00:53:23.250
Python has a concept called a
class that lets us do that.

00:53:23.250 --> 00:53:27.020
In Python, you make a new class
by saying to the Python

00:53:27.020 --> 00:53:31.200
prompt, I want a new class
called Student.

00:53:31.200 --> 00:53:35.940
And then, under Student, there
is this thing which we will

00:53:35.940 --> 00:53:37.660
call an attribute.

00:53:37.660 --> 00:53:42.600
An attribute to a class is
simply a data item associated

00:53:42.600 --> 00:53:44.460
with the class.

00:53:44.460 --> 00:53:46.380
And a method--

00:53:46.380 --> 00:53:50.760
a method is just a
procedure that is

00:53:50.760 --> 00:53:52.450
associated with the class.

00:53:52.450 --> 00:53:58.540
So there's this single item
class called Student that has

00:53:58.540 --> 00:54:04.860
one piece of data, its
attribute, school, and one

00:54:04.860 --> 00:54:10.230
procedure, which is the method
calculateFinalGrade.

00:54:10.230 --> 00:54:12.370
So then, this is the kind of
data structure you might

00:54:12.370 --> 00:54:15.230
imagine that a registrar
would have.

00:54:15.230 --> 00:54:18.120
It's a way to associate.

00:54:18.120 --> 00:54:22.130
So the idea here is that
everybody here is a student.

00:54:22.130 --> 00:54:24.740
They all have a school.

00:54:24.740 --> 00:54:28.390
And they all have a way of
calculating their final grade.

00:54:28.390 --> 00:54:32.810
That's a very narrow view that
maybe a registrar would have.

00:54:32.810 --> 00:54:38.610
So classes, having defined
them, we can then use the

00:54:38.610 --> 00:54:42.570
class to define an instance.

00:54:42.570 --> 00:54:50.430
So an instance is a data
structure that inherits all of

00:54:50.430 --> 00:54:54.660
the structure from the class but
also provides a mechanism

00:54:54.660 --> 00:54:58.950
for having specific data
associated with the instance.

00:54:58.950 --> 00:55:02.930
So in Python, I say
Mary is a student.

00:55:02.930 --> 00:55:05.480
By mentioning the name of the
class and putting parenthesis

00:55:05.480 --> 00:55:10.510
on it, I say, give me an
instance of the student.

00:55:10.510 --> 00:55:15.860
So now, Mary is a name
associated with an instance of

00:55:15.860 --> 00:55:18.410
the class, Student.

00:55:18.410 --> 00:55:23.760
John is similarly an instance
of the class, Student.

00:55:23.760 --> 00:55:27.570
So both Mary and John
have schools.

00:55:27.570 --> 00:55:29.430
In fact, they're
both the same.

00:55:29.430 --> 00:55:34.160
The school of Mary and the
school of John are both MIT.

00:55:34.160 --> 00:55:42.200
But I can extend the instance
of Mary to include a new

00:55:42.200 --> 00:55:48.495
attribute, the section number,
so that Mary's section number

00:55:48.495 --> 00:55:50.910
is 3 and John's section
number is 4.

00:55:50.910 --> 00:55:52.880
So this provides a way--

00:55:52.880 --> 00:55:55.080
it's a higher-order concept.

00:55:55.080 --> 00:55:57.940
We thought of a way to aggregate
operations into

00:55:57.940 --> 00:56:01.140
complicated operation, data
into complicated data.

00:56:01.140 --> 00:56:06.230
Classes aggregate data
and operations.

00:56:06.230 --> 00:56:09.250
Classes allow us to create
a structure and

00:56:09.250 --> 00:56:10.520
then generate instances.

00:56:10.520 --> 00:56:15.780
And then the instances have
access to those features that

00:56:15.780 --> 00:56:18.480
were defined in the class, but
also have the ability to

00:56:18.480 --> 00:56:23.800
define their own unique
attributes and methods.

00:56:23.800 --> 00:56:27.820
You can also use a class
to define a subclass.

00:56:27.820 --> 00:56:31.950
So here, I'm defining the
subclass, Student601.

00:56:31.950 --> 00:56:35.770
All Student601s are members
of the class, Student.

00:56:35.770 --> 00:56:38.240
The reverse is not true.

00:56:38.240 --> 00:56:42.930
So all Student601 entities
inherit everything that a

00:56:42.930 --> 00:56:44.400
Student has.

00:56:44.400 --> 00:56:48.930
But all 601 students share
some other things.

00:56:48.930 --> 00:56:52.170
Besides having a school which
all students have, 601

00:56:52.170 --> 00:56:54.560
students also have a lecture
day, a lecture time, and a

00:56:54.560 --> 00:56:56.130
method for calculating
tutor scores.

00:56:59.350 --> 00:57:03.290
Not all students have a method
for calculating tutor scores.

00:57:03.290 --> 00:57:06.590
But members of the class
Student601 do.

00:57:09.390 --> 00:57:14.470
So this, again, represents a
way of organizing data and

00:57:14.470 --> 00:57:20.010
operations in a way that makes
it easier to compose higher,

00:57:20.010 --> 00:57:21.260
bigger, more complex
structures.

00:57:24.240 --> 00:57:27.230
The final thing that I want
to talk about today is the

00:57:27.230 --> 00:57:33.900
specific, gory details for how
Python manages the association

00:57:33.900 --> 00:57:38.370
between names and entities.

00:57:38.370 --> 00:57:40.840
We've already seen
two of those.

00:57:40.840 --> 00:57:45.660
Naming operations is via "def."
And it gives rise to

00:57:45.660 --> 00:57:48.270
the name of a procedure.

00:57:48.270 --> 00:57:52.640
Variables are ways of naming
data structures.

00:57:52.640 --> 00:57:59.000
Now, we've seen a way
of naming classes.

00:57:59.000 --> 00:58:01.640
And in fact, it's helpful
if you understand.

00:58:01.640 --> 00:58:07.680
So Python associates names and
entities in a very simple,

00:58:07.680 --> 00:58:08.870
straightforward fashion.

00:58:08.870 --> 00:58:11.080
And if you know the ground
rules, it makes it very easy

00:58:11.080 --> 00:58:11.600
to deal with.

00:58:11.600 --> 00:58:13.310
And if you don't know the ground
rules, it makes it very

00:58:13.310 --> 00:58:14.440
hard to deal with.

00:58:14.440 --> 00:58:15.670
So what's the ground rules?

00:58:15.670 --> 00:58:17.810
Here's the gory details.

00:58:17.810 --> 00:58:22.730
So Python associates names with
values in what Python

00:58:22.730 --> 00:58:26.920
calls a binding environment.

00:58:26.920 --> 00:58:30.470
An environment is just a
list that associates

00:58:30.470 --> 00:58:33.120
a name and an entity.

00:58:33.120 --> 00:58:35.860
So if you were to type b
equals 3 what Python is

00:58:35.860 --> 00:58:41.270
actually doing is it's building
this environment.

00:58:41.270 --> 00:58:46.357
When you type b equals 3, it
adds to the environment a

00:58:46.357 --> 00:58:54.620
name, b, and associates that
name with the integer, 3.

00:58:54.620 --> 00:59:01.840
When you type x equals 2.2, it
adds a name, x, and associates

00:59:01.840 --> 00:59:04.550
it with the float, 2.2.

00:59:04.550 --> 00:59:09.530
When you say foo is minus 506
times 2, it makes the name,

00:59:09.530 --> 00:59:16.762
foo, and associates it with
an int, minus 1012.

00:59:16.762 --> 00:59:22.940
Then, if you ask Python about
b, the rule is look it up in

00:59:22.940 --> 00:59:29.250
the environment and type the
thing that b refers to.

00:59:29.250 --> 00:59:31.940
So when you type "b," what
Python really does is it goes

00:59:31.940 --> 00:59:32.890
to the environment.

00:59:32.890 --> 00:59:36.570
It says, do I have some entity
called "b?" Well, yes I do.

00:59:36.570 --> 00:59:38.230
It happens to be an int, 3.

00:59:38.230 --> 00:59:39.480
So it prints 3.

00:59:43.170 --> 00:59:48.080
If you ask, what is "a?"
Python says, OK, in my

00:59:48.080 --> 00:59:55.290
environment, do I have some
name, "a?" It doesn't find it.

00:59:55.290 --> 00:59:59.240
So it prints out this cryptic
message that basically says,

00:59:59.240 --> 01:00:03.160
sorry, guys, I can't find
something called "a" in the

01:00:03.160 --> 01:00:05.750
current environment.

01:00:05.750 --> 01:00:11.300
That's the key to the way Python
does all name bindings.

01:00:11.300 --> 01:00:16.390
So in general, there's
a global environment.

01:00:16.390 --> 01:00:18.850
You start typing to Python.

01:00:18.850 --> 01:00:23.800
It just starts adding and
modifying the bindings in the

01:00:23.800 --> 01:00:25.520
binding environment.

01:00:25.520 --> 01:00:29.970
So if you type a equals 3 and
then type "a," it'll find 3.

01:00:29.970 --> 01:00:36.250
If you then type "b=a+2," it
evaluates the right-hand side

01:00:36.250 --> 01:00:39.870
relative to the current
environment.

01:00:39.870 --> 01:00:41.890
So it first looks here.

01:00:41.890 --> 01:00:47.060
And it says, do I have something
called "a?" Ah, yes.

01:00:47.060 --> 01:00:49.070
It's an integer, 3.

01:00:49.070 --> 01:00:51.280
Substitute that.

01:00:51.280 --> 01:00:52.310
Do I know what 2 is?

01:00:52.310 --> 01:00:53.100
Oh yeah, that's just an int.

01:00:53.100 --> 01:00:54.190
Do I know what plus is?

01:00:54.190 --> 01:00:56.560
Oh yeah, that's the thing
that combines two ints.

01:00:56.560 --> 01:00:59.800
So it decides that a plus 2--

01:00:59.800 --> 01:01:01.790
it evaluates a plus 2 in the
current environment.

01:01:01.790 --> 01:01:03.370
It gets 5.

01:01:03.370 --> 01:01:06.830
And it says, oh, I'm trying
to do a new equals, a new

01:01:06.830 --> 01:01:08.960
association, a new variable.

01:01:08.960 --> 01:01:15.210
Make the name, b, points to this
evaluated in the current

01:01:15.210 --> 01:01:16.150
environment.

01:01:16.150 --> 01:01:18.240
So b gets associated
with int 5.

01:01:20.960 --> 01:01:25.670
Then, if I do this line, it
evaluates b plus 1 in the

01:01:25.670 --> 01:01:26.920
current environment.

01:01:29.430 --> 01:01:31.760
b is 5 in the current
environment.

01:01:31.760 --> 01:01:32.390
It adds 1.

01:01:32.390 --> 01:01:34.300
It gets 6.

01:01:34.300 --> 01:01:40.210
And then, it says, associate
this thing, 6, with b.

01:01:40.210 --> 01:01:45.850
So it overwrites the b, which
had been bound to 5, and b is

01:01:45.850 --> 01:01:48.050
now bound to 6.

01:01:48.050 --> 01:01:48.670
OK?

01:01:48.670 --> 01:01:54.210
So the whole thing, the way it
treats variables, the way

01:01:54.210 --> 01:01:57.490
Python associates a name with
a value in a variable, is

01:01:57.490 --> 01:01:59.930
evaluate the right-hand side
according to the current

01:01:59.930 --> 01:02:01.190
environment.

01:02:01.190 --> 01:02:03.630
Then, change the current
environment to

01:02:03.630 --> 01:02:07.410
reflect the new binding.

01:02:07.410 --> 01:02:09.850
What it does in the case of
sub-routines is very similar.

01:02:13.140 --> 01:02:17.510
So here's an illustration of the
local environment that is

01:02:17.510 --> 01:02:19.810
generated by this
piece of code.

01:02:19.810 --> 01:02:22.760
When I say a equals 2, it
generates a name in the local

01:02:22.760 --> 01:02:25.090
environment, a.

01:02:25.090 --> 01:02:28.850
It evaluates the right-hand
side and finds 2.

01:02:28.850 --> 01:02:32.080
So it makes a binding in the
local environment where the

01:02:32.080 --> 01:02:36.140
name, a, is associated
with the integer, 2.

01:02:36.140 --> 01:02:39.770
Then, I say define square of
x to be return x squared.

01:02:42.980 --> 01:02:45.180
That's more complicated.

01:02:45.180 --> 01:02:48.740
Python says, oh, I'm defining
a new operation.

01:02:52.840 --> 01:02:55.150
It's a procedure.

01:02:55.150 --> 01:03:00.450
The procedure has a formal
argument, x.

01:03:00.450 --> 01:03:05.170
It has a body, return
x times x.

01:03:05.170 --> 01:03:07.060
I'm going to have to remember
all of that stuff.

01:03:09.590 --> 01:03:13.950
So I'm trying to define a new
procedure called square.

01:03:13.950 --> 01:03:17.300
It's going to make a
binding for square.

01:03:17.300 --> 01:03:20.830
So in the future, if somebody
says the word square, it'll

01:03:20.830 --> 01:03:23.210
find out, oh, square I
remember that one.

01:03:23.210 --> 01:03:25.860
square, it's a procedure.

01:03:28.380 --> 01:03:32.930
Just like the binding for a
variable might be an int, the

01:03:32.930 --> 01:03:39.880
binding for a procedure is the
name of the procedure.

01:03:39.880 --> 01:03:43.580
Then, in the procedure, which
is some other data structure

01:03:43.580 --> 01:03:47.140
outside the environment, it's
got to remember the formal

01:03:47.140 --> 01:03:48.110
parameters--

01:03:48.110 --> 01:03:50.540
in this case, x--

01:03:50.540 --> 01:03:51.790
and the body.

01:03:54.000 --> 01:03:57.560
And for the purpose of
resolving what do the

01:03:57.560 --> 01:04:02.100
variables mean, it needs to
remember what was the binding

01:04:02.100 --> 01:04:07.000
environment in which this
sub-routine was defined.

01:04:07.000 --> 01:04:09.470
So that's this arrow.

01:04:09.470 --> 01:04:14.140
So this sequence says, make a
new binding square, points to

01:04:14.140 --> 01:04:14.790
a procedure.

01:04:14.790 --> 01:04:18.930
The procedure has the
formal argument, x.

01:04:18.930 --> 01:04:23.030
It has the body return
x times x.

01:04:23.030 --> 01:04:25.180
And it has the binding.

01:04:25.180 --> 01:04:31.430
It came from the environment,
E1, the current environment.

01:04:31.430 --> 01:04:32.650
OK, is everybody clear?

01:04:32.650 --> 01:04:36.320
So the idea is that the
environment associates names

01:04:36.320 --> 01:04:37.220
with things.

01:04:37.220 --> 01:04:39.250
The thing could be
a data item, or

01:04:39.250 --> 01:04:40.500
it could be a procedure.

01:04:43.540 --> 01:04:48.280
Then, when you call a procedure,
it makes a new

01:04:48.280 --> 01:04:50.270
environment.

01:04:50.270 --> 01:04:54.830
So what happens, then, when I
try to evaluate a form, square

01:04:54.830 --> 01:04:58.260
of a plus 2?

01:04:58.260 --> 01:05:01.780
What Python does is it says,
OK, I need to figure

01:05:01.780 --> 01:05:04.460
out what square is.

01:05:04.460 --> 01:05:06.930
So it looks it up in the
environment, and it finds out

01:05:06.930 --> 01:05:09.160
that square is a procedure.

01:05:09.160 --> 01:05:12.640
Fine, I know how to deal
with procedures.

01:05:12.640 --> 01:05:16.290
So then, it figures out this
procedure has a formal

01:05:16.290 --> 01:05:17.910
argument, x.

01:05:17.910 --> 01:05:20.100
Oh, OK, if I'm going to run this
procedure, I'm going to

01:05:20.100 --> 01:05:23.110
have to know what x means.

01:05:23.110 --> 01:05:25.110
So Python makes a new
environment--

01:05:25.110 --> 01:05:28.760
here, it's labelled E2, separate
from the global

01:05:28.760 --> 01:05:30.760
environment, E1.

01:05:30.760 --> 01:05:33.010
It makes a new environment
that will

01:05:33.010 --> 01:05:35.630
associate x with something.

01:05:35.630 --> 01:05:39.390
Doesn't know what it is yet, it
just knows that this square

01:05:39.390 --> 01:05:43.540
is a procedure that takes
a formal argument, x.

01:05:43.540 --> 01:05:46.180
So Python makes a new
environment, E2, with x

01:05:46.180 --> 01:05:47.990
pointing to something.

01:05:47.990 --> 01:05:52.240
Then, Python evaluates the
argument a plus 2 in the

01:05:52.240 --> 01:05:53.490
environment E1.

01:05:56.200 --> 01:05:59.660
You called square of a plus 2
in the environment of E1.

01:05:59.660 --> 01:06:05.250
So it figures out what did
you mean by a plus 3.

01:06:05.250 --> 01:06:08.380
Well, you were in the
environment E1.

01:06:08.380 --> 01:06:12.570
So it means whatever a plus 3
would have meant if he had

01:06:12.570 --> 01:06:15.570
just typed a plus 3 in
that environment.

01:06:15.570 --> 01:06:18.940
So you evaluate a plus
3 in the environment

01:06:18.940 --> 01:06:20.290
E1, and you get 5.

01:06:22.980 --> 01:06:27.110
So then, this new environment,
E2, that is set up for this

01:06:27.110 --> 01:06:30.610
procedure, square, associates
5 with x.

01:06:33.220 --> 01:06:36.180
Now it's ready to
run the body.

01:06:36.180 --> 01:06:41.440
So now, it runs this procedure,
return x times x.

01:06:41.440 --> 01:06:45.080
But now, what it's trying to
resolve its variables, it

01:06:45.080 --> 01:06:48.710
looks it up in E2.

01:06:48.710 --> 01:06:52.170
So it says, I want to do
the procedure, the

01:06:52.170 --> 01:06:53.790
body, x times x.

01:06:53.790 --> 01:06:56.960
I need to know what x is, and
I need to know it twice.

01:06:56.960 --> 01:07:00.570
Look up what x means, but I
will look it up in my E2

01:07:00.570 --> 01:07:01.740
environment that was built

01:07:01.740 --> 01:07:03.830
specifically for this procedure.

01:07:03.830 --> 01:07:06.880
And fortunately, there's
an x there.

01:07:06.880 --> 01:07:08.800
So it finds out that x is 5.

01:07:08.800 --> 01:07:10.400
It multiplies 5 times 5.

01:07:10.400 --> 01:07:11.660
It gets the answer is 25.

01:07:11.660 --> 01:07:13.350
It returns 25.

01:07:13.350 --> 01:07:16.740
And then, it destroys this
environment, E2, because it

01:07:16.740 --> 01:07:20.100
was only necessary for the time
when it was running the

01:07:20.100 --> 01:07:21.870
procedure body.

01:07:21.870 --> 01:07:23.120
Is that clear?

01:07:28.520 --> 01:07:33.820
OK, so a slightly more difficult
example illustrates

01:07:33.820 --> 01:07:37.180
what happens whenever everything
is not defined in

01:07:37.180 --> 01:07:39.920
the current local environment.

01:07:39.920 --> 01:07:43.950
What if I type define
biz of a?

01:07:43.950 --> 01:07:50.070
Well, I create a new name in
the local environment that

01:07:50.070 --> 01:07:51.790
points to a procedure.

01:07:51.790 --> 01:07:55.720
The procedure has a formal
parameter, a, and a body that

01:07:55.720 --> 01:07:58.120
returns a plus b.

01:07:58.120 --> 01:08:02.470
The procedure also was defined
within the environment E1,

01:08:02.470 --> 01:08:04.150
which I'll keep track of.

01:08:07.430 --> 01:08:11.070
Then, if I say b equals 6, that
makes a new binding in

01:08:11.070 --> 01:08:16.430
the global environment,
b equals 6.

01:08:16.430 --> 01:08:23.250
Then, if I try to run biz
of 2, look up biz.

01:08:23.250 --> 01:08:25.220
Oh, that's a procedure,
formal parameter, a.

01:08:25.220 --> 01:08:27.140
Make an environment,
has an a in it.

01:08:27.140 --> 01:08:28.500
What should I put in a?

01:08:28.500 --> 01:08:30.399
Evaluate the argument, 2.

01:08:30.399 --> 01:08:31.290
OK, a is 2.

01:08:31.290 --> 01:08:34.529
Put two here.

01:08:34.529 --> 01:08:37.770
Now, I'm ready to
run the body.

01:08:37.770 --> 01:08:41.100
Run the body in the
environment, E2.

01:08:41.100 --> 01:08:46.319
When I run return a plus
b in E2, I have to

01:08:46.319 --> 01:08:48.760
first figure out a.

01:08:48.760 --> 01:08:52.000
Well, that's easy. a is 2.

01:08:52.000 --> 01:08:53.319
Then, I have to figure out b.

01:08:53.319 --> 01:08:54.569
What's b?

01:08:58.510 --> 01:08:58.989
AUDIENCE: 6?

01:08:58.989 --> 01:08:59.468
PROFESSOR: 6.

01:08:59.468 --> 01:09:00.905
So how did you get 6?

01:09:00.905 --> 01:09:03.300
AUDIENCE: [INAUDIBLE].

01:09:03.300 --> 01:09:06.479
PROFESSOR: So this local
environment that was created

01:09:06.479 --> 01:09:12.330
for the formal parameter has,
as its parent, E1 because

01:09:12.330 --> 01:09:13.819
that's where the procedure
was defined.

01:09:17.069 --> 01:09:22.340
So it doesn't find b in this
local environment.

01:09:22.340 --> 01:09:23.970
So it goes to the parent.

01:09:23.970 --> 01:09:28.140
Do you have a "b?" And it could,
in principal, propagate

01:09:28.140 --> 01:09:29.970
up a chain of environments.

01:09:29.970 --> 01:09:32.350
So you could construct
this hierarchically.

01:09:32.350 --> 01:09:37.290
So it will resolve bindings in
the most recent environment

01:09:37.290 --> 01:09:39.950
that has that binding.

01:09:39.950 --> 01:09:45.490
So the answer, then, is that
when you run biz of 2, this b

01:09:45.490 --> 01:09:51.290
gets associated with
that b, OK?

01:09:51.290 --> 01:09:55.840
So that's how the environments
work for simple procedures and

01:09:55.840 --> 01:09:57.870
simple data structures.

01:09:57.870 --> 01:10:01.800
It's very similar for the way
it works with classes.

01:10:01.800 --> 01:10:05.180
So imagine that I had this
data, and I wanted to

01:10:05.180 --> 01:10:07.110
represent that in Python.

01:10:07.110 --> 01:10:10.330
What I might do is look at
the common features.

01:10:10.330 --> 01:10:11.650
The courses are all the same.

01:10:11.650 --> 01:10:12.750
The rooms are all the same.

01:10:12.750 --> 01:10:13.800
The buildings are
all the same.

01:10:13.800 --> 01:10:16.690
The ages are highly variable.

01:10:16.690 --> 01:10:19.400
So I might want to create
a class that

01:10:19.400 --> 01:10:21.860
has the common data.

01:10:21.860 --> 01:10:23.920
So I might do this--

01:10:23.920 --> 01:10:26.230
class Staff601.

01:10:26.230 --> 01:10:27.480
The course is 601.

01:10:27.480 --> 01:10:28.280
The building's 34.

01:10:28.280 --> 01:10:30.390
The room is this.

01:10:30.390 --> 01:10:38.570
The way Python implements a
class is as an environment.

01:10:38.570 --> 01:10:43.160
Executing this set of statements
builds the class

01:10:43.160 --> 01:10:44.050
environment.

01:10:44.050 --> 01:10:45.810
This is it.

01:10:45.810 --> 01:10:48.010
It's a list of bindings.

01:10:48.010 --> 01:10:50.430
Here, I'm binding the
name, course, to the

01:10:50.430 --> 01:10:53.270
string, 601, et cetera.

01:10:53.270 --> 01:10:55.250
If there were a method, I
would do the same thing,

01:10:55.250 --> 01:10:59.070
except it would look like
a procedure then.

01:10:59.070 --> 01:11:06.330
So this creates the Staff601
environment.

01:11:06.330 --> 01:11:12.300
Staff601, because I executed
this class statement, that

01:11:12.300 --> 01:11:18.710
creates a binding in the local
environment, Staff601, which

01:11:18.710 --> 01:11:22.650
points to the new environment.

01:11:22.650 --> 01:11:26.320
So now, in the future, when
Python encounters the name

01:11:26.320 --> 01:11:33.430
Staff601, it will discover that
that's an environment.

01:11:33.430 --> 01:11:39.330
Python implements classes
as environments.

01:11:39.330 --> 01:11:46.600
So now, when I want to access
elements within a class, I use

01:11:46.600 --> 01:11:47.710
a special notation.

01:11:47.710 --> 01:11:49.870
It's a dot notation.

01:11:49.870 --> 01:11:56.480
Python regards dots as ways of
navigating an environment.

01:11:56.480 --> 01:12:02.310
When Python parses staff.room,
it looks up Staff601 in the

01:12:02.310 --> 01:12:04.200
current environment.

01:12:04.200 --> 01:12:08.540
If it finds an environment, it
then says, oh, I know about

01:12:08.540 --> 01:12:09.640
this .room thing.

01:12:09.640 --> 01:12:14.470
All I do is I look up
the room name in

01:12:14.470 --> 01:12:18.670
the environment Staff601.

01:12:18.670 --> 01:12:21.100
And when it does that, it
gets the answer 501.

01:12:21.100 --> 01:12:23.890
And the same sort of
thing happens here.

01:12:23.890 --> 01:12:25.450
It looks up Staff601.

01:12:25.450 --> 01:12:26.970
It finds an environment.

01:12:26.970 --> 01:12:28.010
It looks up coolness.

01:12:28.010 --> 01:12:29.530
It finds out there
is no such thing.

01:12:29.530 --> 01:12:32.700
Well, no, that's not true.

01:12:32.700 --> 01:12:40.250
So it creates coolness within
601 and assigns an

01:12:40.250 --> 01:12:43.890
integer, 11, to it.

01:12:43.890 --> 01:12:51.660
So then, the way Python treats
methods is completely

01:12:51.660 --> 01:12:54.530
analogous--

01:12:54.530 --> 01:12:56.280
oh, excuse me, instances.

01:12:56.280 --> 01:12:58.060
I'm doing instances first.

01:12:58.060 --> 01:13:04.490
If I make pat be an instance
of Staff601, pat is an

01:13:04.490 --> 01:13:08.320
instance of the class
Staff601.

01:13:08.320 --> 01:13:14.590
pat is implemented as
an environment.

01:13:14.590 --> 01:13:19.100
So when I make pat, pat points
to a new environment--

01:13:19.100 --> 01:13:20.340
here, E3.

01:13:20.340 --> 01:13:24.320
The parent of E3 is the class
that pat belongs to,

01:13:24.320 --> 01:13:25.570
which is, here, E2.

01:13:27.860 --> 01:13:31.120
And when I make the instance,
it's empty.

01:13:31.120 --> 01:13:36.150
But now, if I ask what is
pat.course, well, pat points

01:13:36.150 --> 01:13:37.050
to this environment.

01:13:37.050 --> 01:13:39.120
Does this environment have
something called a course?

01:13:39.120 --> 01:13:39.950
No.

01:13:39.950 --> 01:13:40.780
Does the parent?

01:13:40.780 --> 01:13:42.030
Yes.

01:13:43.670 --> 01:13:45.770
Course is bound to
the string 601.

01:13:45.770 --> 01:13:50.220
So pat.course is 601
just the same as

01:13:50.220 --> 01:13:53.570
Staff601.course had been 601.

01:13:53.570 --> 01:13:56.640
pat is an instance.

01:13:56.640 --> 01:14:00.530
It's a new environment
with the class

01:14:00.530 --> 01:14:02.405
environment as its parent.

01:14:06.830 --> 01:14:12.980
You can add attributes
to instances.

01:14:12.980 --> 01:14:17.930
And all that does is populate
the environment associated

01:14:17.930 --> 01:14:21.220
with the instance.

01:14:21.220 --> 01:14:26.140
You can add methods
to classes.

01:14:26.140 --> 01:14:28.650
And that does the same thing.

01:14:28.650 --> 01:14:32.310
So here, I've got the class,
Staff601, which has a method,

01:14:32.310 --> 01:14:35.930
salutation, instance
variables, course,

01:14:35.930 --> 01:14:38.410
building, and room.

01:14:38.410 --> 01:14:42.300
So when I build that structure,
Staff601 points to

01:14:42.300 --> 01:14:45.470
an environment that contains
salutation, which is a

01:14:45.470 --> 01:14:50.450
procedure, in addition to a
bunch of instance variables.

01:14:53.880 --> 01:14:56.480
So now, all of the rules that
we've talked about with regard

01:14:56.480 --> 01:15:00.910
to environments apply
now to this class.

01:15:00.910 --> 01:15:07.580
So in particular, I can say
Staff601 salutation of pat.

01:15:07.580 --> 01:15:12.436
When Python parses Staff601,
it finds an environment.

01:15:15.710 --> 01:15:17.060
It says dot salutation.

01:15:17.060 --> 01:15:19.550
Oh, I know how to do that.

01:15:19.550 --> 01:15:25.440
Within the environment,
Staff601, look for a binding

01:15:25.440 --> 01:15:28.800
for the name salutation.

01:15:28.800 --> 01:15:29.800
Do I find one?

01:15:29.800 --> 01:15:31.110
Well, yeah, there it is.

01:15:31.110 --> 01:15:32.430
It points to a procedure.

01:15:32.430 --> 01:15:35.560
So staff dot salutation
is a procedure.

01:15:35.560 --> 01:15:38.590
Do just the same things that
we would have done with a

01:15:38.590 --> 01:15:39.500
simple procedure.

01:15:39.500 --> 01:15:41.230
The only difference
here is that the

01:15:41.230 --> 01:15:42.535
procedure came from a class.

01:15:45.200 --> 01:15:54.040
In this particular case, the
sub-routine that I define has

01:15:54.040 --> 01:15:57.760
a formal parameter, self.

01:15:57.760 --> 01:16:01.060
So then, that's going to have
to build when I try to

01:16:01.060 --> 01:16:01.780
evaluate it.

01:16:01.780 --> 01:16:10.560
That has to build a binding for
self, which is set to pat.

01:16:10.560 --> 01:16:12.660
pat was an environment.

01:16:12.660 --> 01:16:16.130
So self gets pointed to pat.

01:16:16.130 --> 01:16:21.250
So now, when I run
Staff601.salutation on pat, it

01:16:21.250 --> 01:16:25.350
behaves as though that generic
method was applied to the

01:16:25.350 --> 01:16:26.600
instance pat.

01:16:29.330 --> 01:16:30.460
We'll do that a lot.

01:16:30.460 --> 01:16:32.410
It's a little bit
of redundancy.

01:16:32.410 --> 01:16:38.110
We know that pat is a
member of Staff601.

01:16:38.110 --> 01:16:41.010
So we will define a special
form-- or I should say, Python

01:16:41.010 --> 01:16:44.610
defines a special form-- that
makes that easy to say.

01:16:44.610 --> 01:16:49.270
This is the way we will usually
say, the instance pat

01:16:49.270 --> 01:16:56.790
should run the class method
salutation on itself.

01:16:56.790 --> 01:17:00.020
This is simply a simplified
notation that means

01:17:00.020 --> 01:17:06.520
precisely that, OK?

01:17:06.520 --> 01:17:10.960
So what we covered today, then,
was supposed to be the

01:17:10.960 --> 01:17:15.410
most elementary ideas in how
you construct modular

01:17:15.410 --> 01:17:20.500
programs, Modularity
at the small scale.

01:17:20.500 --> 01:17:24.110
How do you make operations that
are hierarchical, data

01:17:24.110 --> 01:17:26.270
structures, and classes?

01:17:26.270 --> 01:17:30.020
What we will do for the rest of
the week is practice those

01:17:30.020 --> 01:17:31.270
activities.

