WEBVTT
Kind: captions
Language: en

00:00:00.530 --> 00:00:02.960
The following content is
provided under a Creative

00:00:02.960 --> 00:00:04.370
Commons license.

00:00:04.370 --> 00:00:07.410
Your support will help MIT
OpenCourseWare continue to

00:00:07.410 --> 00:00:11.060
offer high-quality educational
resources for free.

00:00:11.060 --> 00:00:13.960
To make a donation or view
additional materials from

00:00:13.960 --> 00:00:18.590
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:18.590 --> 00:00:19.840
ocw.mit.edu.

00:00:25.400 --> 00:00:25.740
PROFESSOR: Hello.

00:00:25.740 --> 00:00:26.990
Welcome.

00:00:29.190 --> 00:00:33.440
Today we're going to talk about
one last new topic which

00:00:33.440 --> 00:00:35.682
has to do with search.

00:00:35.682 --> 00:00:38.820
So as you remember, we're
working on our last topic.

00:00:38.820 --> 00:00:43.490
The last topic was probability
and planning.

00:00:43.490 --> 00:00:45.130
Last lecture we talked
about probability.

00:00:49.260 --> 00:00:53.000
Mostly we focused on Bayes'
theorem, Bayes' rule.

00:00:53.000 --> 00:00:56.400
That was a way of updating our
belief about some situation

00:00:56.400 --> 00:00:59.350
based on new information.

00:00:59.350 --> 00:01:02.580
And this week in Design Lab 12,
you'll get a chance to use

00:01:02.580 --> 00:01:06.110
that in a robot application.

00:01:06.110 --> 00:01:09.300
The idea to Design Lab 12 is
going to be that a robot is

00:01:09.300 --> 00:01:12.770
pedaling along a corridor
with some

00:01:12.770 --> 00:01:15.750
obstacles off to its left.

00:01:15.750 --> 00:01:20.260
And the idea will be, you don't
know where the robot is,

00:01:20.260 --> 00:01:24.620
but the robot will be able to
estimate where it is by the

00:01:24.620 --> 00:01:29.480
signals that it receives from
its left-facing sonars.

00:01:29.480 --> 00:01:31.450
So this is a very realistic
type of

00:01:31.450 --> 00:01:33.030
state-estimation problem.

00:01:33.030 --> 00:01:37.110
The idea is going to be that at
any given time, t, you have

00:01:37.110 --> 00:01:41.460
access to your previous belief
at time t minus 1.

00:01:41.460 --> 00:01:44.940
And you have access to a new
observation, which is the

00:01:44.940 --> 00:01:46.890
sonar to your left.

00:01:46.890 --> 00:01:49.840
And based on those two bits of
information, you will update

00:01:49.840 --> 00:01:50.430
your belief.

00:01:50.430 --> 00:01:53.110
Which means that when you start
out you'll have no idea

00:01:53.110 --> 00:01:55.200
where you are, but that
situation should

00:01:55.200 --> 00:01:58.010
improve with time.

00:01:58.010 --> 00:01:58.075
Ok.

00:01:58.075 --> 00:02:01.900
So that's what we're going
to do in Design Lab 12.

00:02:01.900 --> 00:02:04.380
Today we're going to blast
ahead and think about the

00:02:04.380 --> 00:02:08.410
other important topic,
which is search.

00:02:08.410 --> 00:02:10.370
So we're going to think
about planning.

00:02:10.370 --> 00:02:11.430
We're going to be
planning ahead.

00:02:11.430 --> 00:02:13.520
We're not going to just
react to the situation

00:02:13.520 --> 00:02:14.260
that's given to us.

00:02:14.260 --> 00:02:16.840
We're going to try to figure out
what's the right thing to

00:02:16.840 --> 00:02:17.890
do in the future.

00:02:17.890 --> 00:02:20.550
And to do that, we're going to
think about all the things we

00:02:20.550 --> 00:02:24.540
could possibly do, search
through that space, and figure

00:02:24.540 --> 00:02:27.790
out the one that's, quote,
"best." And we'll have to

00:02:27.790 --> 00:02:30.490
define "best" somehow.

00:02:30.490 --> 00:02:34.420
Just to get going, I want to
show you a very simple kind of

00:02:34.420 --> 00:02:37.290
a search problem.

00:02:37.290 --> 00:02:40.930
This is called the
eight puzzle.

00:02:40.930 --> 00:02:45.110
The idea is to make a plan to
go from this configuration,

00:02:45.110 --> 00:02:48.430
which we'll call the state, to
this configuration, which

00:02:48.430 --> 00:02:51.790
we'll call the goal state.

00:02:51.790 --> 00:02:57.180
And on each move, you get to
move one of the tiles into the

00:02:57.180 --> 00:02:57.890
free space.

00:02:57.890 --> 00:03:00.660
So I could move the 8 to the
right or the 6 down.

00:03:00.660 --> 00:03:04.070
Those are the only two things I
could do in the start state.

00:03:04.070 --> 00:03:05.760
So I have to make up my
mind which of those I

00:03:05.760 --> 00:03:07.340
would like to do.

00:03:07.340 --> 00:03:09.750
And I would like to believe
that ultimately, after a

00:03:09.750 --> 00:03:12.780
series of moves, I'm going to be
able to control this state

00:03:12.780 --> 00:03:15.680
into that state.

00:03:15.680 --> 00:03:18.240
And you can imagine guessing.

00:03:18.240 --> 00:03:22.150
And we'll estimate in a moment
how big is the guess space.

00:03:22.150 --> 00:03:24.360
I mean, if the guess space only
had like four elements in

00:03:24.360 --> 00:03:27.250
it, guessing's a
fine strategy.

00:03:27.250 --> 00:03:31.510
If the guess space has a lot
more elements than that,

00:03:31.510 --> 00:03:34.860
guessing's probably
not a good idea.

00:03:34.860 --> 00:03:38.720
So I previously ran our search
algorithms, the ones that

00:03:38.720 --> 00:03:41.320
we'll develop during lecture,
on this problem.

00:03:41.320 --> 00:03:43.070
And here's the solution
that our search

00:03:43.070 --> 00:03:44.320
algorithm came up with.

00:03:51.300 --> 00:03:55.520
It's not exactly what you might
do the first time you

00:03:55.520 --> 00:03:56.770
touched it.

00:03:59.740 --> 00:04:02.150
OK, I made it.

00:04:02.150 --> 00:04:05.430
If you were counting,
I made 22 moves.

00:04:08.200 --> 00:04:12.180
The question is, how difficult
was that problem and how good

00:04:12.180 --> 00:04:14.190
was that solution?

00:04:14.190 --> 00:04:16.130
Was that a good solution
or a bad solution?

00:04:16.130 --> 00:04:18.320
Is there a better solution?

00:04:18.320 --> 00:04:20.519
How much work did I have
to do in order to

00:04:20.519 --> 00:04:22.420
calculate that solution?

00:04:22.420 --> 00:04:23.850
To get a handle on that,
let's start by

00:04:23.850 --> 00:04:25.450
asking a simple question.

00:04:25.450 --> 00:04:28.610
How many configurations
are there?

00:04:28.610 --> 00:04:30.190
I got there in 22.

00:04:30.190 --> 00:04:33.190
What was the space of things
I had to look through?

00:04:33.190 --> 00:04:37.470
How many different board
configurations exist?

00:04:37.470 --> 00:04:38.880
So think about that
for 20 seconds.

00:04:38.880 --> 00:04:39.720
Talk to your neighbor.

00:04:39.720 --> 00:04:43.640
And figure out whether it
is 8-squared, 9-squared,

00:04:43.640 --> 00:04:46.390
8-factorial, 9-factorial,
or none of those.

00:05:46.270 --> 00:05:49.530
So how many bar configurations
do you see?

00:05:49.530 --> 00:05:51.730
Raise your hand, show me a
number of fingers, so I can

00:05:51.730 --> 00:05:55.410
figure out roughly how people
were-- that's excellent.

00:05:55.410 --> 00:05:58.560
Very good participation, and
nearly 100% correct.

00:05:58.560 --> 00:06:00.980
The answer is number (4).

00:06:00.980 --> 00:06:01.960
You can think about this.

00:06:01.960 --> 00:06:03.880
What if you took all the tiles
out and threw them on the

00:06:03.880 --> 00:06:07.470
floor, and then put them
in one at a time?

00:06:07.470 --> 00:06:09.710
Well, you would have 9
possibilities for where you

00:06:09.710 --> 00:06:11.390
wanted to put the first one.

00:06:11.390 --> 00:06:13.460
Then you would have 8
possibilities for where you

00:06:13.460 --> 00:06:15.110
wanted to put the second one.

00:06:15.110 --> 00:06:17.300
Then you'd have 7 possibilities
for where you

00:06:17.300 --> 00:06:19.830
put the third one, et
cetera, et cetera.

00:06:19.830 --> 00:06:22.450
Even though the space doesn't
have a number on it, it still

00:06:22.450 --> 00:06:25.390
sort of counts.

00:06:25.390 --> 00:06:27.550
And so you end up with
9-factorial.

00:06:27.550 --> 00:06:32.130
And the point is, 9-factorial
is a big number.

00:06:32.130 --> 00:06:37.050
9-factorial is 362880.

00:06:37.050 --> 00:06:41.550
So if you thought about simply
guessing, that's probably not

00:06:41.550 --> 00:06:44.580
going to work all that
well, right?

00:06:44.580 --> 00:06:48.390
Even if you guessed,
you have on each--

00:06:48.390 --> 00:06:53.830
there's a third of a million
different configurations that

00:06:53.830 --> 00:06:56.260
you have to look at.

00:06:56.260 --> 00:06:59.370
And that's if you didn't
lose track of things.

00:06:59.370 --> 00:07:00.280
If you lost track of--

00:07:00.280 --> 00:07:00.780
Oh, my.

00:07:00.780 --> 00:07:02.080
It's coming up--

00:07:02.080 --> 00:07:03.460
almost, anyway.

00:07:03.460 --> 00:07:07.040
It looks like it's chopped
off at the top.

00:07:07.040 --> 00:07:09.130
So ignore that for now.

00:07:09.130 --> 00:07:12.100
Look over here.

00:07:12.100 --> 00:07:20.270
So even if you didn't confuse
yourself, there's a space of a

00:07:20.270 --> 00:07:22.760
third of a million things
to look at.

00:07:22.760 --> 00:07:25.720
And if you confused yourself,
there's even more.

00:07:25.720 --> 00:07:29.930
So it's not a huge problem by
computer science standards.

00:07:29.930 --> 00:07:31.690
But it's certainly not
a trivial problem.

00:07:31.690 --> 00:07:36.190
It's not something that you can
just guess and get right.

00:07:36.190 --> 00:07:41.790
So what we want to do today is
figure out an algorithm for

00:07:41.790 --> 00:07:43.920
conducting a search like that.

00:07:43.920 --> 00:07:47.520
We'd like to figure out the
algorithm, analyze how well it

00:07:47.520 --> 00:07:52.530
works, optimize it, and try to
find out a way to find the

00:07:52.530 --> 00:07:55.900
best solution, where "best" for
this particular problem

00:07:55.900 --> 00:07:59.090
would mean minimum
path length.

00:07:59.090 --> 00:08:01.720
So figure out the best solution
by considering as few

00:08:01.720 --> 00:08:02.810
cases as possible.

00:08:02.810 --> 00:08:04.850
Obviously, if you enumerate
all the

00:08:04.850 --> 00:08:08.120
cases, that should work.

00:08:08.120 --> 00:08:10.190
The problem is, it will be
interesting to solve problems

00:08:10.190 --> 00:08:12.110
where that enumeration
is quite large.

00:08:12.110 --> 00:08:15.690
Even here, the enumeration
is quite large.

00:08:15.690 --> 00:08:17.670
So let's think about
the algorithm.

00:08:17.670 --> 00:08:19.690
And I'll think about the
algorithm by way of an even

00:08:19.690 --> 00:08:21.790
simpler, more finite problem.

00:08:21.790 --> 00:08:25.480
What if I thought about a grid
of possible locations

00:08:25.480 --> 00:08:27.650
where I could be.

00:08:27.650 --> 00:08:28.800
Maybe this is the intersections

00:08:28.800 --> 00:08:31.640
of streets in Manhattan.

00:08:31.640 --> 00:08:35.130
I want to go from point A
to point I. What's the

00:08:35.130 --> 00:08:36.260
minimum-distance path?

00:08:36.260 --> 00:08:40.100
I hope you probably can
all figure that out.

00:08:40.100 --> 00:08:41.640
What I want to do is write
an algorithm that

00:08:41.640 --> 00:08:42.919
can figure that out.

00:08:42.919 --> 00:08:45.070
And then if we write the
algorithm well, we'll be able

00:08:45.070 --> 00:08:47.120
to use it for the tile problem,
which is not quite so

00:08:47.120 --> 00:08:49.130
easy to do.

00:08:49.130 --> 00:08:52.430
The way we're going to think
about doing that is to

00:08:52.430 --> 00:08:55.270
organize all of our possible
paths through

00:08:55.270 --> 00:09:00.140
that maze, in a tree.

00:09:00.140 --> 00:09:03.640
So if I started at A, I have
a decision to make.

00:09:03.640 --> 00:09:07.780
I could either go to B or D.

00:09:07.780 --> 00:09:16.140
Then if I went to, say, B, I
could either then go to A or C

00:09:16.140 --> 00:09:18.810
or E. I've organized them
alphabetically for no

00:09:18.810 --> 00:09:20.310
particularly good reason.

00:09:20.310 --> 00:09:20.640
Just--

00:09:20.640 --> 00:09:24.010
I needed some order.

00:09:24.010 --> 00:09:34.260
Then if I went from A to B to A,
say, then I could either go

00:09:34.260 --> 00:09:37.710
from A to B or D. That's
illustrated here.

00:09:37.710 --> 00:09:40.260
So the idea then--
ah, it works.

00:09:40.260 --> 00:09:42.700
So now it looks like they're
all three working.

00:09:42.700 --> 00:09:46.140
So the idea is, think about
the original problem.

00:09:46.140 --> 00:09:49.440
The original problem is
find the shortest path

00:09:49.440 --> 00:09:51.950
through some grid.

00:09:51.950 --> 00:09:55.360
I want to go from A to I. And
I'll think about all the

00:09:55.360 --> 00:09:58.650
possible paths on a tree.

00:09:58.650 --> 00:10:03.020
Then the problem is that for
the kinds of problems we're

00:10:03.020 --> 00:10:08.350
going to look at, that tree
could be infinite in length.

00:10:08.350 --> 00:10:09.530
Oh, that's a bummer.

00:10:09.530 --> 00:10:12.440
That means that the strategy of
building the tree and then

00:10:12.440 --> 00:10:14.910
searching it is probably
not a good strategy.

00:10:14.910 --> 00:10:17.890
So what we'll do instead is,
we'll try to write the

00:10:17.890 --> 00:10:22.650
algorithm in such a way that
we construct the tree and

00:10:22.650 --> 00:10:26.760
search for the best solution
all in one pass.

00:10:26.760 --> 00:10:29.650
Then hopefully, if we find a
solution in some finite number

00:10:29.650 --> 00:10:33.560
of steps, we'll only have
built part of the tree.

00:10:33.560 --> 00:10:37.650
But we'll have built the part
that has the answer.

00:10:37.650 --> 00:10:41.200
The idea, then, is going to be,
think about what is the

00:10:41.200 --> 00:10:44.130
path we want to take, by
thinking about the tree of all

00:10:44.130 --> 00:10:46.100
possible paths.

00:10:46.100 --> 00:10:51.270
But what we want to do is write
code that will construct

00:10:51.270 --> 00:10:57.150
the tree on the fly, while it's
considering how good were

00:10:57.150 --> 00:11:00.400
all the different nodes.

00:11:00.400 --> 00:11:00.460
Ok.

00:11:00.460 --> 00:11:02.820
So how are we going
to do that?

00:11:02.820 --> 00:11:05.070
We'll be working in Python,
not surprisingly.

00:11:05.070 --> 00:11:07.510
We'll represent all the
possible locations.

00:11:07.510 --> 00:11:10.420
We'll call those states.

00:11:10.420 --> 00:11:14.160
So the problem will have states
A, B, C, D, and we'll

00:11:14.160 --> 00:11:17.240
just represent those
by strings.

00:11:17.240 --> 00:11:19.090
That makes it flexible.

00:11:19.090 --> 00:11:21.480
That makes it arbitrary.

00:11:21.480 --> 00:11:24.440
Then we'll think about
transitions, not by

00:11:24.440 --> 00:11:25.570
enumerating them.

00:11:25.570 --> 00:11:27.830
Remember, we don't want to
enumerate them, because there

00:11:27.830 --> 00:11:29.050
could be infinitely
many of them.

00:11:29.050 --> 00:11:31.050
So how's the other way
we could do it?

00:11:31.050 --> 00:11:33.730
Well, we'll embody that
information in a program.

00:11:33.730 --> 00:11:38.780
We'll write a procedure called
"successor" that will, given

00:11:38.780 --> 00:11:45.730
the current state and action,
figure out the next state.

00:11:45.730 --> 00:11:48.870
So that's a way that we can
incrementally build the tree.

00:11:48.870 --> 00:11:58.383
So imagine here, if I started
in A and I executed action 0

00:11:58.383 --> 00:12:02.420
or 1, I would end up in
B or D, respectively.

00:12:02.420 --> 00:12:06.630
So I tell you the current state
and the current action,

00:12:06.630 --> 00:12:09.410
and the successor program
then will return

00:12:09.410 --> 00:12:12.420
to you the new state.

00:12:12.420 --> 00:12:17.730
That's all we need to construct
the tree on the fly.

00:12:17.730 --> 00:12:20.710
Then, to specify the particular
problem with

00:12:20.710 --> 00:12:23.400
interest, I have to tell
you where you start.

00:12:23.400 --> 00:12:27.530
So I have to define
initial state.

00:12:27.530 --> 00:12:30.250
And I have to tell
you where to end.

00:12:30.250 --> 00:12:33.000
I could just tell you
the final state.

00:12:33.000 --> 00:12:35.310
But in some of the problems of
the type that we will want to

00:12:35.310 --> 00:12:40.250
do, there could be multiple
acceptable answers.

00:12:40.250 --> 00:12:42.630
So I don't want to just give
you the final state.

00:12:42.630 --> 00:12:44.750
I'll give you a test.

00:12:44.750 --> 00:12:48.550
I'll give you another procedure,
called "goalTest."

00:12:48.550 --> 00:12:51.070
And that goal test, when passed
an input which is a

00:12:51.070 --> 00:12:54.410
state, will tell you whether or
not you reached the goal.

00:12:54.410 --> 00:12:57.400
That way, for example, all the
even-numbered squares could

00:12:57.400 --> 00:13:00.000
satisfy the goal, if that were
the problem of interest.

00:13:00.000 --> 00:13:04.560
Or all the states on the right
could satisfy the goal.

00:13:04.560 --> 00:13:06.520
It's just a little bit
more flexible.

00:13:06.520 --> 00:13:12.620
The idea, then, is that in order
to represent that tree,

00:13:12.620 --> 00:13:18.050
we'll do it by specifying a
procedure called successor and

00:13:18.050 --> 00:13:22.940
specifying the start state
and the goal test.

00:13:22.940 --> 00:13:27.670
So here's how I might set that
up for the simple Manhattan

00:13:27.670 --> 00:13:30.720
problem that I showed--
that I started with.

00:13:30.720 --> 00:13:34.550
So I want ultimately to have
something called successor

00:13:34.550 --> 00:13:36.530
that eats a state
and an action.

00:13:39.560 --> 00:13:46.370
I've built the structure of
Manhattan into a dictionary.

00:13:46.370 --> 00:13:50.690
The dictionary lists
for every state--

00:13:50.690 --> 00:13:55.940
A, B, C, D, E, F, G, H, I--

00:13:55.940 --> 00:14:00.840
for every state, it associates
that state with a list of

00:14:00.840 --> 00:14:02.490
possible next states.

00:14:02.490 --> 00:14:06.780
So if I'm in A, I could next be
in B or D. I could next be

00:14:06.780 --> 00:14:10.330
in B or D.

00:14:10.330 --> 00:14:13.220
I've organized these arbitrarily
in alphabetical

00:14:13.220 --> 00:14:15.220
order so I can remember
what's going on.

00:14:15.220 --> 00:14:17.970
So the next states are all
in alphabetical order.

00:14:17.970 --> 00:14:21.760
The number of next states
depends on the state.

00:14:21.760 --> 00:14:23.530
I'm not going to worry
about that too much.

00:14:23.530 --> 00:14:28.170
I'm just going to specify the
action as an integer--

00:14:28.170 --> 00:14:29.290
0,1,2,3 --

00:14:29.290 --> 00:14:31.590
however many I need.

00:14:31.590 --> 00:14:35.000
So the possible actions are
taken from that list.

00:14:35.000 --> 00:14:38.290
The possible action might be
do action 0, do action

00:14:38.290 --> 00:14:39.840
1, do action 2.

00:14:39.840 --> 00:14:47.500
So if I did action 2 starting
on state E, I would go to--

00:14:47.500 --> 00:14:48.750
so action started at 0 --

00:14:48.750 --> 00:14:50.940
so 0, 1, 2 --

00:14:50.940 --> 00:14:54.330
I would go to state F. OK?

00:14:54.330 --> 00:14:56.800
Is that all clear?

00:14:56.800 --> 00:15:00.520
The initial state is A, and the
goal state is, return S

00:15:00.520 --> 00:15:04.130
equal to I. So if S is equal
to I, it returns True.

00:15:04.130 --> 00:15:06.140
If S is not equal to I,
it returns False.

00:15:10.010 --> 00:15:11.430
I'm not quite done.

00:15:11.430 --> 00:15:13.850
That's enough to completely
specify the tree, but now I

00:15:13.850 --> 00:15:15.280
have to build the
tree in Python.

00:15:18.050 --> 00:15:23.020
Not surprisingly, from our
object-oriented past, we will

00:15:23.020 --> 00:15:29.000
use an object-oriented
representation for that tree.

00:15:29.000 --> 00:15:33.480
So we'll specify every node in
the tree as an instance of the

00:15:33.480 --> 00:15:36.230
class SearchNode.

00:15:36.230 --> 00:15:37.870
SearchNode is trivial.

00:15:37.870 --> 00:15:40.670
SearchNode simply knows,
what was the

00:15:40.670 --> 00:15:42.140
action that got me here?

00:15:42.140 --> 00:15:43.220
Who's my parent?

00:15:43.220 --> 00:15:45.420
And what's my current state?

00:15:45.420 --> 00:15:49.090
So when you make a new node,
you have to tell the

00:15:49.090 --> 00:15:52.550
constructor those
three things.

00:15:52.550 --> 00:15:54.290
What was the action
that got me here?

00:15:54.290 --> 00:15:55.230
What's my current state?

00:15:55.230 --> 00:15:56.480
And who is my parent?

00:15:58.930 --> 00:16:03.280
Knowing the node, you're
supposed to know the entire

00:16:03.280 --> 00:16:05.140
path that got you here.

00:16:05.140 --> 00:16:10.420
So we'll also add a method
which reports the path.

00:16:10.420 --> 00:16:15.750
So if I happen to be in node
E, my path ought to be I

00:16:15.750 --> 00:16:20.500
started in A, I took action 0
and got to B, and then I took

00:16:20.500 --> 00:16:25.360
action 2 and got to E.
This subroutine is

00:16:25.360 --> 00:16:28.130
intended to do that.

00:16:28.130 --> 00:16:31.230
If my parent is "none," which
will happen for the initial

00:16:31.230 --> 00:16:41.060
state, simply report that the
path to me is none, A.

00:16:41.060 --> 00:16:47.460
However, if I'm anybody other
than the initial node, if I'm

00:16:47.460 --> 00:16:52.340
other than the initial node,
then figure out the

00:16:52.340 --> 00:16:58.280
description of the path to my
parent, and add the action

00:16:58.280 --> 00:17:01.980
that got me here,
and my state.

00:17:01.980 --> 00:17:04.790
So that's what this is.

00:17:04.790 --> 00:17:06.190
OK, so what are we doing?

00:17:06.190 --> 00:17:09.849
We specify a problem by telling
you the successor

00:17:09.849 --> 00:17:14.180
function, the start state,
and the goal test.

00:17:14.180 --> 00:17:20.020
Then we provide a class by which
you can build nodes to

00:17:20.020 --> 00:17:26.010
construct, on the fly,
the search tree.

00:17:26.010 --> 00:17:27.900
Now we're ready to write
the algorithm.

00:17:27.900 --> 00:17:30.530
Here's the pseudocode
for the algorithm.

00:17:30.530 --> 00:17:31.150
What do we do?

00:17:31.150 --> 00:17:32.870
We initialize--

00:17:32.870 --> 00:17:34.930
so we're going to be
doing a s-- oh,

00:17:34.930 --> 00:17:36.270
this is very confusing.

00:17:36.270 --> 00:17:37.740
I'm trying to solve
a search problem.

00:17:40.500 --> 00:17:42.210
To solve the search problem,
I'm going to

00:17:42.210 --> 00:17:45.610
search through the tree.

00:17:45.610 --> 00:17:48.560
So I'm going to think about the
state of my search through

00:17:48.560 --> 00:17:53.870
the tree by way of something
we'll call the agenda.

00:17:53.870 --> 00:17:55.330
Very jargon-y word.

00:17:55.330 --> 00:17:56.700
I completely apologize for it.

00:17:56.700 --> 00:17:58.050
I didn't invent it.

00:17:58.050 --> 00:17:59.630
It's what everybody calls it.

00:17:59.630 --> 00:18:00.880
Sorry.

00:18:05.870 --> 00:18:10.700
The agenda is the set
of nodes that I'm

00:18:10.700 --> 00:18:12.920
currently thinking about.

00:18:12.920 --> 00:18:16.140
So I'll initialize that to
contain the starting node.

00:18:18.990 --> 00:18:23.640
Then I'll just systematically
keep repeating the same thing

00:18:23.640 --> 00:18:24.740
over and over again.

00:18:24.740 --> 00:18:28.450
Take one of the nodes out of
the agenda, think about it,

00:18:28.450 --> 00:18:32.960
replace that node
by its children.

00:18:32.960 --> 00:18:36.740
While I'm doing that, two things
are supposed to happen.

00:18:36.740 --> 00:18:40.180
I'm supposed to construct
the search tree.

00:18:40.180 --> 00:18:42.810
But I'm also going to be looking
over my shoulder to

00:18:42.810 --> 00:18:49.970
see if I just constructed a
child who is the answer.

00:18:49.970 --> 00:18:51.950
Because if I just constructed
the answer, I'm done.

00:18:51.950 --> 00:18:54.420
Ok.

00:18:54.420 --> 00:18:57.150
So initialize the agenda
to contain just

00:18:57.150 --> 00:18:58.160
the starting node.

00:18:58.160 --> 00:18:59.670
Then repeat the following
steps.

00:18:59.670 --> 00:19:01.680
Remove one node from
the agenda.

00:19:01.680 --> 00:19:03.830
Add that node's children
to the agenda.

00:19:03.830 --> 00:19:07.010
And keep going until one
of two things happens.

00:19:07.010 --> 00:19:08.510
Either you found it--

00:19:08.510 --> 00:19:13.210
goal test returned True--

00:19:13.210 --> 00:19:16.310
or the agenda got empty,
in which case there

00:19:16.310 --> 00:19:19.310
must not be a solution.

00:19:19.310 --> 00:19:21.480
If I've removed all of my
options and still haven't

00:19:21.480 --> 00:19:23.170
found anything, then there's
no solution.

00:19:25.800 --> 00:19:25.900
Ok.

00:19:25.900 --> 00:19:27.330
So what's the program
look like?

00:19:27.330 --> 00:19:30.150
It's actually remarkably simple,
especially when you

00:19:30.150 --> 00:19:31.780
think about just how hard
the problem is.

00:19:31.780 --> 00:19:37.450
Imagine if you wanted to do that
tiles problem with a very

00:19:37.450 --> 00:19:41.290
simple-minded "if this then
this, if this then this."

00:19:41.290 --> 00:19:44.420
We're talking about a third
of a million ifs, right?

00:19:44.420 --> 00:19:47.540
That's probably not the
right way to do it.

00:19:47.540 --> 00:19:49.640
This program is going to end
up being about this long.

00:19:49.640 --> 00:19:51.460
It'll fit on this page.

00:19:51.460 --> 00:19:53.600
And it's going to be able to
handle that case, or even

00:19:53.600 --> 00:19:56.580
harder cases.

00:19:56.580 --> 00:19:57.800
Define the search procedure.

00:19:57.800 --> 00:19:59.670
The search procedure is
something that's going to take

00:19:59.670 --> 00:20:02.870
the initial state, the goal
test, the possible actions,

00:20:02.870 --> 00:20:06.320
and the successor sub routine,
the successor procedure.

00:20:06.320 --> 00:20:09.700
That's everything you need
to specify the problem.

00:20:09.700 --> 00:20:12.818
And it's going to return
to me the optimal path.

00:20:15.520 --> 00:20:17.310
First, step (1).

00:20:17.310 --> 00:20:21.320
Initialize the agenda to
contain the start node.

00:20:21.320 --> 00:20:22.440
I want to put the
start node in.

00:20:22.440 --> 00:20:24.420
Well, there's a chance--

00:20:24.420 --> 00:20:26.350
I want this procedure to
be general purpose--

00:20:26.350 --> 00:20:30.900
there's a chance that that
start node is the answer.

00:20:30.900 --> 00:20:32.150
So take care of that first.

00:20:34.630 --> 00:20:38.460
If you're already there,
return the answer.

00:20:38.460 --> 00:20:41.450
The path to the answer is me.

00:20:44.080 --> 00:20:46.340
I'm trying to create
the agenda.

00:20:46.340 --> 00:20:48.330
I'm trying to put the first
node into the agenda.

00:20:48.330 --> 00:20:51.040
There's a chance that first
node is the answer.

00:20:51.040 --> 00:20:53.760
If that first node's the answer,
return the path to me.

00:20:53.760 --> 00:20:55.710
Which is, take no action.

00:20:55.710 --> 00:20:56.960
You're here.

00:20:59.010 --> 00:21:00.560
But that's not likely to be
the case for the kinds of

00:21:00.560 --> 00:21:04.430
questions we ask, in which case
we will create a list

00:21:04.430 --> 00:21:07.560
that contains one node, which
is the node that represents

00:21:07.560 --> 00:21:08.810
the start node.

00:21:12.780 --> 00:21:16.060
Then, repeat 'remove
a node' -- which

00:21:16.060 --> 00:21:17.890
we'll call the parent--

00:21:17.890 --> 00:21:19.900
from the agenda.

00:21:19.900 --> 00:21:21.670
And substitute --

00:21:21.670 --> 00:21:26.590
replace that node that we pulled
out of the agenda --

00:21:26.590 --> 00:21:29.920
replace that with
the children.

00:21:29.920 --> 00:21:32.180
While not empty of agenda--

00:21:32.180 --> 00:21:33.940
empty is some kind of a
pseudo-routine that I'm going

00:21:33.940 --> 00:21:35.690
to fill in, in a minute--

00:21:35.690 --> 00:21:40.600
while the agenda is not empty,
get an element out of the

00:21:40.600 --> 00:21:42.110
agenda, which we'll
call the parent.

00:21:45.320 --> 00:21:48.890
Then I want to think about
all the children.

00:21:48.890 --> 00:21:51.190
Well, there's a list of
possible actions.

00:21:51.190 --> 00:21:54.620
So for a in actions, do
the following things.

00:21:54.620 --> 00:21:57.370
Each parent can have multiple
children, one for every

00:21:57.370 --> 00:21:58.720
possible action.

00:21:58.720 --> 00:22:03.840
So for a in action, figure out
what would be the new state.

00:22:03.840 --> 00:22:10.370
The new state is just the
successor of the parent state.

00:22:10.370 --> 00:22:14.240
Remember, the parent
is a node, right?

00:22:14.240 --> 00:22:15.330
The parent is a node.

00:22:15.330 --> 00:22:17.890
We're constructing nodes
in the search tree.

00:22:17.890 --> 00:22:21.080
But nodes know their state.

00:22:21.080 --> 00:22:24.790
So figure out the new state,
which is the successor of my

00:22:24.790 --> 00:22:27.720
parent, the guy that I pulled
out of the agenda.

00:22:30.290 --> 00:22:36.300
Make a new node, which
corresponds to this child.

00:22:36.300 --> 00:22:40.070
Then ask the question,
did the new state

00:22:40.070 --> 00:22:42.500
satisfy the goal test?

00:22:42.500 --> 00:22:45.760
If it did, the answer is the
path to the new node.

00:22:49.410 --> 00:22:49.585
Ok.

00:22:49.585 --> 00:22:53.270
So create a new state, which is
the successor of the parent

00:22:53.270 --> 00:22:57.070
under the given action
A. Create a new node.

00:22:57.070 --> 00:22:58.320
See if it's the end.

00:22:58.320 --> 00:23:01.410
If it is, just return,
I'm done.

00:23:01.410 --> 00:23:04.100
Return from search.

00:23:04.100 --> 00:23:08.230
Otherwise, add it-- again, one
of these pseudo-procedures.

00:23:10.890 --> 00:23:12.560
We'll fill that in,
in a minute--

00:23:12.560 --> 00:23:14.360
add the new node into
the agenda.

00:23:17.670 --> 00:23:19.210
There's several things
that could happen

00:23:19.210 --> 00:23:21.690
when I run this loop.

00:23:21.690 --> 00:23:26.800
If the node has no children, I
will take out the parent and

00:23:26.800 --> 00:23:30.100
not put anything back in.

00:23:30.100 --> 00:23:35.700
If the node has multiple
children, I could take out one

00:23:35.700 --> 00:23:40.010
node and put in more nodes than
I took out, so the agenda

00:23:40.010 --> 00:23:41.260
could get longer.

00:23:46.990 --> 00:23:50.580
So the agenda could either
increase in length or decrease

00:23:50.580 --> 00:23:53.320
in length as a result of
spinning around this loop.

00:23:56.020 --> 00:23:59.740
Also, we could either identify
a goal or fail

00:23:59.740 --> 00:24:01.160
to identify a goal.

00:24:01.160 --> 00:24:05.500
So as it's increasing and
decreasing, we either will or

00:24:05.500 --> 00:24:07.090
won't find an answer.

00:24:10.100 --> 00:24:10.195
Ok.

00:24:10.195 --> 00:24:11.450
Now the trick--

00:24:11.450 --> 00:24:14.030
the only thing that makes
this complicated--

00:24:14.030 --> 00:24:16.346
is that order matters.

00:24:19.600 --> 00:24:24.980
So those pseudo-operations,
whatever they were--

00:24:24.980 --> 00:24:28.710
get element and add--

00:24:28.710 --> 00:24:32.110
exactly how I get element and
exactly how I add it to the

00:24:32.110 --> 00:24:36.235
agenda affects the way
I conduct the search.

00:24:38.820 --> 00:24:40.380
Let's think of something
very simple.

00:24:40.380 --> 00:24:48.550
Let's always remove the first
node from the agenda and

00:24:48.550 --> 00:24:52.710
replace it by its children.

00:24:52.710 --> 00:24:54.310
So pull out the first node.

00:24:54.310 --> 00:24:57.050
And put back into the beginning
of the agenda the

00:24:57.050 --> 00:24:58.980
children of the first node.

00:24:58.980 --> 00:24:59.500
How?

00:24:59.500 --> 00:25:01.830
I would start out in step (0).

00:25:01.830 --> 00:25:06.070
I would put the start node
into the agenda.

00:25:06.070 --> 00:25:09.030
So now there's one element in
the agenda, the start node.

00:25:09.030 --> 00:25:11.840
Then, on the first pass
through the loop, I

00:25:11.840 --> 00:25:14.350
would pull out that.

00:25:14.350 --> 00:25:16.930
That's the first node
in the agenda.

00:25:16.930 --> 00:25:18.280
There's only one node
in the agenda.

00:25:18.280 --> 00:25:20.630
That is the first one.

00:25:20.630 --> 00:25:23.620
Pull out the first one and
replace it by its children.

00:25:23.620 --> 00:25:27.900
Its children are AB and AD.

00:25:27.900 --> 00:25:33.510
I'm representing the nodes in
this notation by the path,

00:25:33.510 --> 00:25:37.400
because the same state
can appear multiple

00:25:37.400 --> 00:25:40.150
times in the tree.

00:25:40.150 --> 00:25:44.580
Notice that I could
walk ABAB --

00:25:44.580 --> 00:25:46.970
which would correspond to
the same state being

00:25:46.970 --> 00:25:49.090
repeated in the tree.

00:25:49.090 --> 00:25:53.130
So I can't, when I'm writing
it down here, represent the

00:25:53.130 --> 00:25:55.950
node by a state.

00:25:55.950 --> 00:26:00.230
But I can represent
a node by a path.

00:26:00.230 --> 00:26:04.940
So on the first pass through the
loop, pull out the first

00:26:04.940 --> 00:26:08.390
item in the agenda, which
is A, and push

00:26:08.390 --> 00:26:10.900
back that A's children.

00:26:10.900 --> 00:26:16.150
Well A's children
are AB and AD.

00:26:16.150 --> 00:26:16.230
Ok.

00:26:16.230 --> 00:26:20.850
So now on the second pass, the
rule is pull out the first guy

00:26:20.850 --> 00:26:23.420
and replace it by
the children.

00:26:23.420 --> 00:26:26.450
Now the first guy is AB.

00:26:26.450 --> 00:26:28.010
So I'm here.

00:26:28.010 --> 00:26:32.310
So pull that guy out and replace
him by his children.

00:26:32.310 --> 00:26:37.940
His children are ABA,
ABC, and ABE.

00:26:37.940 --> 00:26:41.030
AD is left over.

00:26:41.030 --> 00:26:43.610
The number of elements in
the agenda got bigger.

00:26:46.430 --> 00:26:51.120
Next step, pull out the first
item in the agenda, replace it

00:26:51.120 --> 00:26:52.170
by its children.

00:26:52.170 --> 00:26:54.020
The first item in the
agenda is ABA.

00:26:57.340 --> 00:27:02.498
The children of ABA
are ABAB and ABAD.

00:27:06.320 --> 00:27:06.560
Ok.

00:27:06.560 --> 00:27:09.490
Notice the structure
of what's going on.

00:27:09.490 --> 00:27:11.520
Ignore the stuff on the bottom,
and just watch the

00:27:11.520 --> 00:27:12.510
picture on the top.

00:27:12.510 --> 00:27:16.200
So I start by putting A in the
agenda, then its children,

00:27:16.200 --> 00:27:19.840
then its children, then
its children.

00:27:19.840 --> 00:27:21.500
So when I implemented
the algorithm--

00:27:21.500 --> 00:27:24.730
take out the first and replace
it by its children--

00:27:24.730 --> 00:27:28.080
I'm searching along
the depth first.

00:27:28.080 --> 00:27:32.820
I'm going deeper and deeper into
the tree without fully

00:27:32.820 --> 00:27:36.620
exploring all the horizontal
spaces.

00:27:36.620 --> 00:27:40.970
So I'm tracing a line
down that way.

00:27:40.970 --> 00:27:42.970
If you imagine this tree--

00:27:42.970 --> 00:27:45.530
I've only represented the first
three layers of nodes

00:27:45.530 --> 00:27:48.770
here-- this tree goes
on forever.

00:27:48.770 --> 00:27:52.150
It's an infinite tree, because
you can walk around in that

00:27:52.150 --> 00:27:54.140
Manhattan grid forever.

00:27:54.140 --> 00:27:58.390
There's no limit to how long
you can walk around.

00:27:58.390 --> 00:28:02.280
So although I'm only listing the
first three, the tree, in

00:28:02.280 --> 00:28:04.900
principle, goes on forever.

00:28:04.900 --> 00:28:08.930
And this algorithm will have
the feature that it walks

00:28:08.930 --> 00:28:11.740
along the left edge.

00:28:11.740 --> 00:28:17.350
We call that depth-first search
because we're exploring

00:28:17.350 --> 00:28:20.650
depth first, as opposed
to breadth.

00:28:23.500 --> 00:28:25.630
That results because
of our rule.

00:28:25.630 --> 00:28:28.040
The rule was, replace the first
node by its children.

00:28:28.040 --> 00:28:30.260
Let's think about a
different rule.

00:28:30.260 --> 00:28:32.430
Let's replace the last
node by its children.

00:28:38.320 --> 00:28:42.440
We start by initializing the
agenda to the node that

00:28:42.440 --> 00:28:45.320
represents the start state.

00:28:45.320 --> 00:28:50.830
So that's the path A.
Then pull out the

00:28:50.830 --> 00:28:54.040
last node in the agenda--

00:28:54.040 --> 00:28:55.080
that's A--

00:28:55.080 --> 00:28:57.480
and replace it by
its children.

00:28:57.480 --> 00:28:59.915
Its children are still AB and
AD, just like before.

00:29:02.460 --> 00:29:04.770
Now the answer differs from
the previous answer.

00:29:04.770 --> 00:29:08.680
Because when I pull out the last
node, I'm pulling out AD

00:29:08.680 --> 00:29:09.930
now, instead.

00:29:12.710 --> 00:29:16.160
And now I replace AD by
its children, which

00:29:16.160 --> 00:29:19.350
are ADA, ADE, ADG.

00:29:22.900 --> 00:29:28.480
Repeat, and what I've got is
a different, but still

00:29:28.480 --> 00:29:31.060
depth-first search.

00:29:31.060 --> 00:29:33.680
So I've looked at two different
orderings--

00:29:33.680 --> 00:29:36.410
pull out the first node from the
agenda and replace it by

00:29:36.410 --> 00:29:39.190
children, pull out
the last node and

00:29:39.190 --> 00:29:40.540
replace it by its children.

00:29:40.540 --> 00:29:47.320
Both of those algorithms give an
exploration of the decision

00:29:47.320 --> 00:29:51.580
tree searching out
depth first.

00:29:51.580 --> 00:29:54.060
So it's going to try to
exhaustively go through the

00:29:54.060 --> 00:29:57.480
entire depth before it tries
to explore the width.

00:30:01.510 --> 00:30:04.080
As an alternative, think
about a slightly

00:30:04.080 --> 00:30:05.770
more complicated rule.

00:30:05.770 --> 00:30:08.290
Remove the first element from
the agenda and add its

00:30:08.290 --> 00:30:09.880
children to the end
of the agenda.

00:30:13.350 --> 00:30:19.330
So initialize it with the start
state, A. Pull out the

00:30:19.330 --> 00:30:21.670
first element from the
agenda-- that's A--

00:30:21.670 --> 00:30:26.500
and replace it by its children,
which is AB, AD.

00:30:26.500 --> 00:30:28.360
Now pull out the first guy--

00:30:28.360 --> 00:30:31.470
the first guy is AB--

00:30:31.470 --> 00:30:35.600
and put its children
at the end.

00:30:35.600 --> 00:30:39.580
It's children are
ABA, ABC, ABE--

00:30:39.580 --> 00:30:41.480
ABA, ABC, ABE--

00:30:41.480 --> 00:30:43.380
and they are now
put at the end.

00:30:43.380 --> 00:30:48.650
So that on the next step, I'll
pick up AD-- the guy at the

00:30:48.650 --> 00:30:49.900
beginning--

00:30:51.780 --> 00:30:54.940
and put AD's children
at the end.

00:30:54.940 --> 00:30:57.710
et cetera, et cetera, et
cetera, et cetera,

00:30:57.710 --> 00:30:59.390
et cetera, et cetera.

00:30:59.390 --> 00:31:02.240
The idea being-- and now, pay no
attention to the bottom for

00:31:02.240 --> 00:31:04.350
a moment and just think
about the pattern that

00:31:04.350 --> 00:31:06.520
you see at the top.

00:31:06.520 --> 00:31:11.640
In this order, where we remove
the first node and put its

00:31:11.640 --> 00:31:15.770
children at the end of the
agenda, has the effect of

00:31:15.770 --> 00:31:17.210
exploring breadth first.

00:31:22.260 --> 00:31:23.760
So we call that a
breadth-first.

00:31:23.760 --> 00:31:29.880
so the idea is, we got this
generic set of tools that let

00:31:29.880 --> 00:31:32.180
us construct search trees.

00:31:32.180 --> 00:31:35.630
But the order by which we
manipulate the agenda plays a

00:31:35.630 --> 00:31:41.210
critical role in how the
search is conducted.

00:31:41.210 --> 00:31:47.100
And the two that epitomize the
two extreme cases are, what

00:31:47.100 --> 00:31:50.850
would happen if I replace the
last node by its children?

00:31:50.850 --> 00:31:54.460
Or what would happen if I remove
the first node and put

00:31:54.460 --> 00:31:56.000
its children's at the end?

00:31:56.000 --> 00:31:58.870
Those two structures
have names because

00:31:58.870 --> 00:32:00.110
they happen so often.

00:32:00.110 --> 00:32:01.780
We'll call the first
one a stack and the

00:32:01.780 --> 00:32:04.580
second one a queue.

00:32:04.580 --> 00:32:07.970
The stack-based is going
to give us depth first.

00:32:07.970 --> 00:32:11.080
The queue-based is going to
give us breadth first.

00:32:11.080 --> 00:32:12.720
So, stack.

00:32:12.720 --> 00:32:15.270
How do you think
about a stack?

00:32:15.270 --> 00:32:19.190
You think about a stack by
saying, OK, I've got a stack.

00:32:19.190 --> 00:32:21.080
A stack is like a
stack of dishes.

00:32:21.080 --> 00:32:25.620
So here's my table, and I'm
going to rack my dishes up.

00:32:25.620 --> 00:32:26.870
I'm going to put them
on a stack.

00:32:29.380 --> 00:32:30.370
So I make a stack.

00:32:30.370 --> 00:32:31.660
OK, I made the stack--

00:32:31.660 --> 00:32:33.590
push a 1, push a 9, push a 3.

00:32:33.590 --> 00:32:37.720
Push a 1, push a 9, push a 3.

00:32:37.720 --> 00:32:39.370
That's how I do a stack.

00:32:39.370 --> 00:32:41.530
Then pop.

00:32:41.530 --> 00:32:45.920
When I pop, the 3 comes out.

00:32:45.920 --> 00:32:50.840
Then pop, then the
9 comes out.

00:32:50.840 --> 00:32:53.060
Then push a minus 2.

00:32:55.600 --> 00:32:57.290
Then pop.

00:32:57.290 --> 00:33:00.850
Now the minus 2 comes out.

00:33:00.850 --> 00:33:01.440
OK?

00:33:01.440 --> 00:33:03.460
It's stack-based.

00:33:03.460 --> 00:33:10.030
So the last in becomes
the first out.

00:33:10.030 --> 00:33:14.220
That was the rule that we
wanted to have for the

00:33:14.220 --> 00:33:17.460
depth-first search.

00:33:17.460 --> 00:33:18.960
It's very easy to
implement this.

00:33:18.960 --> 00:33:22.440
We can implement it as a list.

00:33:22.440 --> 00:33:26.230
All we need to do is be careful
about how we implement

00:33:26.230 --> 00:33:29.820
the push and pop operators.

00:33:29.820 --> 00:33:34.120
So if we set up the push
operator to simply append to

00:33:34.120 --> 00:33:39.700
the end, and then pop ordinarily
pops from the end,

00:33:39.700 --> 00:33:42.320
we'll get the behavior
of a stack.

00:33:42.320 --> 00:33:45.180
That gives me, then, the rules
that I would want to use for

00:33:45.180 --> 00:33:50.140
those procedures, the
get element an add.

00:33:50.140 --> 00:33:55.040
I will use these stack-based
operators.

00:33:55.040 --> 00:33:58.270
The other alternative
is a queue.

00:33:58.270 --> 00:33:59.230
A queue is different.

00:33:59.230 --> 00:34:01.390
A queue is like when you're
waiting in line

00:34:01.390 --> 00:34:03.980
at the Stop &amp; Shop.

00:34:03.980 --> 00:34:08.500
The queue is, I've got this
queue here and I've got the

00:34:08.500 --> 00:34:09.750
server over here.

00:34:12.880 --> 00:34:14.850
The first person who comes
into the queue--

00:34:14.850 --> 00:34:16.620
so say I push one.

00:34:16.620 --> 00:34:19.429
So now 1 goes into the queue.

00:34:19.429 --> 00:34:22.010
Then another person walks
up while he's--

00:34:22.010 --> 00:34:26.889
the second person lines up
behind the first person.

00:34:26.889 --> 00:34:30.170
Then I push a 3.

00:34:30.170 --> 00:34:32.980
But the way the queue works is
that when I pop the next

00:34:32.980 --> 00:34:38.389
person off the queue, I take
the head of the line.

00:34:38.389 --> 00:34:39.639
So the 1 comes out.

00:34:42.830 --> 00:34:44.880
If I pop again, the
9 comes out.

00:34:48.889 --> 00:34:57.410
If I then push a minus 2 and
pop, then the next person in

00:34:57.410 --> 00:34:58.720
the queue comes out.

00:34:58.720 --> 00:35:01.200
And it's like that.

00:35:01.200 --> 00:35:04.000
It's queue based versus
stack based.

00:35:04.000 --> 00:35:06.857
And the queue based is the one
that we want to do for a

00:35:06.857 --> 00:35:09.873
breadth-first organization.

00:35:12.570 --> 00:35:16.300
And the implementation of a
queue is very trivially

00:35:16.300 --> 00:35:19.170
different from the
implementation for a stack.

00:35:19.170 --> 00:35:22.690
The only difference is that I'll
manipulate the list by

00:35:22.690 --> 00:35:26.060
popping off from the
head of the queue.

00:35:26.060 --> 00:35:29.950
So pop takes an optional
argument, which when

00:35:29.950 --> 00:35:32.020
0, tells you the--

00:35:32.020 --> 00:35:34.340
the argument tells you
which element to pop.

00:35:34.340 --> 00:35:36.530
So when you specify the zero-th
one, it takes it from

00:35:36.530 --> 00:35:39.480
the head of the queue.

00:35:39.480 --> 00:35:45.460
That makes it very easy now to
replace the pseudo-procedures

00:35:45.460 --> 00:35:47.180
with real procedures.

00:35:47.180 --> 00:35:52.670
If I wanted to implement a
depth-first search, I would

00:35:52.670 --> 00:35:57.830
replace the "create a list that
contains the agenda" with

00:35:57.830 --> 00:36:04.400
"create a stack that will
contain the agenda." So create

00:36:04.400 --> 00:36:07.850
a new stack, the agenda
is a stack.

00:36:07.850 --> 00:36:11.900
And then rather than simply
sticking the node--

00:36:11.900 --> 00:36:13.340
the start node--

00:36:13.340 --> 00:36:19.020
into a list, I will push
it into the stack.

00:36:19.020 --> 00:36:21.510
So agenda is a stack.

00:36:21.510 --> 00:36:25.560
Agenda.push, the initial node.

00:36:25.560 --> 00:36:28.610
And then every time I want to
get a new element out, I'll

00:36:28.610 --> 00:36:31.080
agenda.pop it.

00:36:31.080 --> 00:36:33.500
And every time I want to put
something into it, I'll

00:36:33.500 --> 00:36:36.050
agenda.push it.

00:36:36.050 --> 00:36:40.150
Other than that, it looks just
the same as the pseudocode

00:36:40.150 --> 00:36:42.800
that I showed earlier.

00:36:42.800 --> 00:36:45.982
So there is an implementation,
then, for

00:36:45.982 --> 00:36:50.400
a depth-first search.

00:36:50.400 --> 00:36:53.990
If I wanted instead to do
breadth, it's trivial.

00:36:53.990 --> 00:36:59.640
Change the word "stack" to the
word "queue." Now create an

00:36:59.640 --> 00:37:05.060
agenda that is a queue, but
queues have the same

00:37:05.060 --> 00:37:06.450
operations--

00:37:06.450 --> 00:37:09.660
push and pop and empty--

00:37:09.660 --> 00:37:10.840
that stacks have.

00:37:10.840 --> 00:37:12.790
So nothing else in the
program changed.

00:37:12.790 --> 00:37:16.470
All I needed to do is change
the structure of the thing

00:37:16.470 --> 00:37:18.580
that's holding the agenda.

00:37:18.580 --> 00:37:19.830
Everything else just follows.

00:37:27.700 --> 00:37:27.775
Ok.

00:37:27.775 --> 00:37:29.770
So that's everything
we need, right?

00:37:29.770 --> 00:37:31.930
Now what I want to do is think
through examples and think

00:37:31.930 --> 00:37:33.830
about the advantages and
disadvantages of different

00:37:33.830 --> 00:37:35.840
kinds of searches.

00:37:35.840 --> 00:37:38.680
And I want to go on to the
second step that I raised in

00:37:38.680 --> 00:37:40.730
the first slide.

00:37:40.730 --> 00:37:43.260
I want to think about, how
do I optimize the search?

00:37:43.260 --> 00:37:46.290
As I said, even that simple
little tile problem, even the

00:37:46.290 --> 00:37:47.340
eight puzzle--

00:37:47.340 --> 00:37:49.500
eight sounds easy, right?

00:37:49.500 --> 00:37:52.990
Even the eight puzzle
had a third of a

00:37:52.990 --> 00:37:54.540
million different states.

00:37:54.540 --> 00:37:56.740
I don't necessarily want to
look through all of them.

00:37:56.740 --> 00:37:59.100
I want to think now about
these different search

00:37:59.100 --> 00:38:03.000
strategies, and how optimal
are they relative to each

00:38:03.000 --> 00:38:05.320
other, and are there ways
to improve that?

00:38:05.320 --> 00:38:10.910
Now some of you may have noticed
that all of these

00:38:10.910 --> 00:38:15.070
paths don't seem equally good.

00:38:15.070 --> 00:38:16.220
So take a minute.

00:38:16.220 --> 00:38:18.500
Think about it.

00:38:18.500 --> 00:38:19.590
Remember the problem.

00:38:19.590 --> 00:38:22.540
The problem was this walk around
Manhattan problem.

00:38:22.540 --> 00:38:26.940
I wanted to go from A to I.
This was the tree of all

00:38:26.940 --> 00:38:30.640
possible paths from A to I.
What I'd like you to do is

00:38:30.640 --> 00:38:35.780
think about whether all of those
paths are important.

00:38:35.780 --> 00:38:37.250
Could we get rid of
some of them?

00:40:52.820 --> 00:40:54.810
So the question is, can I
throw away some of the

00:40:54.810 --> 00:40:55.700
terminal nodes?

00:40:55.700 --> 00:40:57.680
Notice that I'm using the word
"terminal" kind of funny here.

00:40:57.680 --> 00:41:00.550
The tree keeps going.

00:41:00.550 --> 00:41:03.890
The tree is actually
infinite in length.

00:41:03.890 --> 00:41:06.180
So by "terminal," I just
mean this row three.

00:41:06.180 --> 00:41:09.840
So could I throw away some of
the nodes in row three?

00:41:09.840 --> 00:41:12.410
And in particular, how many of
them could I throw away?

00:41:12.410 --> 00:41:15.190
0, 2, 4, 6, or 8?

00:41:15.190 --> 00:41:19.540
or Raise your hand with
the funny coding.

00:41:19.540 --> 00:41:22.530
And the answer is--

00:41:22.530 --> 00:41:23.080
come on, come on.

00:41:23.080 --> 00:41:24.340
Raise your hands, raise
your hands.

00:41:24.340 --> 00:41:25.690
Blame it on your neighbor.

00:41:25.690 --> 00:41:27.840
That's the whole point.

00:41:27.840 --> 00:41:35.870
OK, it's 2/3 (5) and 1/3 (4)

00:41:35.870 --> 00:41:37.120
How'd you get (5) and (4)?

00:41:39.856 --> 00:41:42.286
Yes?

00:41:42.286 --> 00:41:45.688
AUDIENCE: When you have that
[INAUDIBLE] nodes, you may

00:41:45.688 --> 00:41:47.146
know that there's
[? a procedure ?]

00:41:47.146 --> 00:41:48.130
[INAUDIBLE] before.

00:41:48.130 --> 00:41:48.920
PROFESSOR: Good.

00:41:48.920 --> 00:41:52.930
If you're walking around
Manhattan, and you're trying

00:41:52.930 --> 00:41:57.590
to go from A to I, and if you
spun around in this loop and

00:41:57.590 --> 00:42:03.000
came back to A, that would
probably be a bad path, right?

00:42:03.000 --> 00:42:09.070
So revisiting a place you've
been before is probably a bad

00:42:09.070 --> 00:42:13.350
idea, if what your goal was, was
to get from A to I in the

00:42:13.350 --> 00:42:17.030
shortest possible distance.

00:42:17.030 --> 00:42:18.510
So that's exactly right.

00:42:18.510 --> 00:42:23.360
So I would like to identify
instances where I go back to

00:42:23.360 --> 00:42:24.090
where I started.

00:42:24.090 --> 00:42:27.730
So for example, that
A. That A is bad.

00:42:27.730 --> 00:42:30.200
That means I went back
to the start place.

00:42:30.200 --> 00:42:32.860
I'm just starting over.

00:42:32.860 --> 00:42:37.430
So if I think about those, I
can identify by red all the

00:42:37.430 --> 00:42:38.610
places where I'm repeating.

00:42:38.610 --> 00:42:44.380
So ABA, don't really care
what happens after that.

00:42:44.380 --> 00:42:47.180
ABCB, well, that's B again.

00:42:47.180 --> 00:42:49.900
So that's just brain
dead, right?

00:42:49.900 --> 00:42:55.440
So I can actually remove a fair
amount of the tree by

00:42:55.440 --> 00:42:59.300
simply getting rid
of silliness.

00:42:59.300 --> 00:43:05.540
Don't start the path over again,
where "over" means if

00:43:05.540 --> 00:43:08.200
you come to a place you've
been before,

00:43:08.200 --> 00:43:09.550
stop looking there.

00:43:09.550 --> 00:43:12.320
That's not the right answer.

00:43:12.320 --> 00:43:15.850
And so you can see there
that I actually

00:43:15.850 --> 00:43:18.740
deleted half of the tree.

00:43:18.740 --> 00:43:21.370
The number of nodes on the
third line was 16.

00:43:21.370 --> 00:43:24.870
And 8 of them had the property
that they repeated.

00:43:24.870 --> 00:43:26.290
Yes?

00:43:26.290 --> 00:43:27.778
AUDIENCE: [INAUDIBLE]

00:43:27.778 --> 00:43:28.770
[? after D. ?]

00:43:28.770 --> 00:43:29.762
Are you [INAUDIBLE]?

00:43:29.762 --> 00:43:33.234
PROFESSOR: This B and D. So
there's no reason to consider

00:43:33.234 --> 00:43:37.698
this D, even though the
D didn't repeat.

00:43:37.698 --> 00:43:40.674
AUDIENCE: That would
be [? AD? ?]

00:43:40.674 --> 00:43:42.658
PROFESSOR: ABC,

00:43:42.658 --> 00:43:44.146
AUDIENCE: [? That would be E? ?]

00:43:44.146 --> 00:43:46.130
PROFESSOR: ABED.

00:43:46.130 --> 00:43:48.610
AUDIENCE: [INAUDIBLE]

00:43:48.610 --> 00:43:54.066
PROFESSOR: So I didn't, in this
path, ever hit D before.

00:43:54.066 --> 00:43:58.034
AUDIENCE: When it did lead to
the path there, you'll get the

00:43:58.034 --> 00:44:01.506
same one, AD [INAUDIBLE]

00:44:01.506 --> 00:44:03.490
PROFESSOR: I guess I
don't understand.

00:44:03.490 --> 00:44:06.466
AUDIENCE: What I'm saying is
that without getting the path

00:44:06.466 --> 00:44:08.450
AD, I still get (2)?

00:44:08.450 --> 00:44:09.442
PROFESSOR: Yes.

00:44:09.442 --> 00:44:13.910
So this D seems clearly inferior
to that D. Yes,

00:44:13.910 --> 00:44:17.530
that's absolutely true.

00:44:17.530 --> 00:44:20.960
So this is a very simple rule
for removing things.

00:44:20.960 --> 00:44:23.380
You're thinking of a
more advanced rule.

00:44:23.380 --> 00:44:25.100
So if you saw--

00:44:25.100 --> 00:44:27.950
if there's a shorter path to a
particular place, don't look

00:44:27.950 --> 00:44:28.800
at the longer path.

00:44:28.800 --> 00:44:30.100
You're absolutely right.

00:44:30.100 --> 00:44:36.500
So in fact, there might
be more severe pruning

00:44:36.500 --> 00:44:38.290
that you could do.

00:44:38.290 --> 00:44:39.670
There might have been
an answer that was

00:44:39.670 --> 00:44:41.590
bigger than 8 --

00:44:41.590 --> 00:44:41.990
right?

00:44:41.990 --> 00:44:43.240
And so you're absolutely
right.

00:44:47.900 --> 00:44:48.015
Ok.

00:44:48.015 --> 00:44:50.100
Let me ignore that for the
moment and come back to it in

00:44:50.100 --> 00:44:51.580
about four slides.

00:44:51.580 --> 00:44:54.490
You're absolutely right.

00:44:54.490 --> 00:44:58.850
So what we want to do now is
take that idea of throwing

00:44:58.850 --> 00:45:03.690
away silly paths and formalize
it so that we can put it into

00:45:03.690 --> 00:45:05.760
the algorithm.

00:45:05.760 --> 00:45:08.870
And we'll think about that
as pruning rules.

00:45:08.870 --> 00:45:10.730
So the first pruning rule
is the easy one.

00:45:10.730 --> 00:45:15.460
Don't consider any path that
visits the same state twice.

00:45:15.460 --> 00:45:19.560
That doesn't pick up your case,
but it does pick up 8

00:45:19.560 --> 00:45:22.360
cases here.

00:45:22.360 --> 00:45:27.630
So that's easy to implement.

00:45:27.630 --> 00:45:29.990
All we need to do is--

00:45:29.990 --> 00:45:32.970
down here where we're thinking
about whether this is a good

00:45:32.970 --> 00:45:35.870
state to add or not--

00:45:35.870 --> 00:45:39.920
we just ask, is it
in the path?

00:45:39.920 --> 00:45:43.870
So if the state that I'm about
to put in the path is already

00:45:43.870 --> 00:45:47.750
in the path, don't
put it there.

00:45:47.750 --> 00:45:49.210
If you don't shove
it back into the

00:45:49.210 --> 00:45:52.640
agenda, it'll get forgotten.

00:45:52.640 --> 00:45:55.570
So before you shove it into the
agenda, ask yourself the

00:45:55.570 --> 00:45:57.960
question, is it already
in the path?

00:45:57.960 --> 00:46:00.090
And so I do that here.

00:46:00.090 --> 00:46:08.050
Keep in mind, I popped out an
element called the parent.

00:46:08.050 --> 00:46:10.660
I'm looking at the children.

00:46:10.660 --> 00:46:14.640
The children's state is called
"new state." So I ask, is new

00:46:14.640 --> 00:46:19.400
state in the parent's path?

00:46:19.400 --> 00:46:23.000
So parent.inpath of new state.

00:46:23.000 --> 00:46:25.280
So that means I have
to write inpath.

00:46:25.280 --> 00:46:27.630
Inpath is easy.

00:46:27.630 --> 00:46:30.960
It's especially easy if
we use recursion.

00:46:30.960 --> 00:46:40.200
So inpath says, if my state is
state, then return True.

00:46:40.200 --> 00:46:42.760
I'm in the path.

00:46:42.760 --> 00:46:48.530
If that's not true, and I don't
have a parent, then that

00:46:48.530 --> 00:46:50.850
means I'm the start state.

00:46:50.850 --> 00:46:53.590
That means it wasn't
in the path.

00:46:53.590 --> 00:46:55.990
And if neither of those
is true, ask the same

00:46:55.990 --> 00:46:59.210
question of my parent.

00:46:59.210 --> 00:47:01.830
So that makes it recursive.

00:47:01.830 --> 00:47:04.860
So consider two cases
that could either

00:47:04.860 --> 00:47:06.390
make it true or false.

00:47:06.390 --> 00:47:09.680
It would be True if I'm
currently sitting on a node

00:47:09.680 --> 00:47:11.310
that happens to be
the same state.

00:47:11.310 --> 00:47:14.980
It would be False if I recursed
the whole way back to

00:47:14.980 --> 00:47:19.060
the start state and hadn't
found it yet.

00:47:19.060 --> 00:47:21.680
So there are two termination
states--

00:47:21.680 --> 00:47:26.240
I landed on a state in the path
that was the same as new

00:47:26.240 --> 00:47:29.830
state, or I ran the whole way
back to the start state and

00:47:29.830 --> 00:47:30.860
didn't find it.

00:47:30.860 --> 00:47:34.000
Those two terminate by
doing returns --

00:47:34.000 --> 00:47:36.890
return True or return False.

00:47:36.890 --> 00:47:39.800
The other option is that
I don't know the

00:47:39.800 --> 00:47:41.295
answer, ask my parent.

00:47:44.040 --> 00:47:48.170
So just recurse on inpath,
and ask my parent

00:47:48.170 --> 00:47:51.400
to do the same thing.

00:47:51.400 --> 00:47:53.380
So that's the way I
can figure out--

00:47:53.380 --> 00:47:57.360
I can implement pruning
rule (1).

00:47:57.360 --> 00:47:59.510
Now pruning rule (2) --

00:47:59.510 --> 00:48:02.200
if multiple actions lead to
the same state, only think

00:48:02.200 --> 00:48:03.320
about one of them.

00:48:03.320 --> 00:48:05.580
That actually doesn't happen on
the Manhattan grid problem.

00:48:05.580 --> 00:48:09.110
Because you can imagine search
cases where there are three

00:48:09.110 --> 00:48:10.380
different things that
you could do.

00:48:10.380 --> 00:48:12.790
In fact, you saw some of those
when you were coding

00:48:12.790 --> 00:48:15.270
the robot last week.

00:48:15.270 --> 00:48:18.160
There were multiple ways you
could end up at the state at

00:48:18.160 --> 00:48:20.430
the end of the hall.

00:48:20.430 --> 00:48:23.840
You could get there by being
there and moving left, which

00:48:23.840 --> 00:48:24.800
you hit the wall.

00:48:24.800 --> 00:48:27.510
Or you could get there by being
here and moving left.

00:48:27.510 --> 00:48:30.400
Both of them left you
in the same place.

00:48:30.400 --> 00:48:32.840
So if you're planning a search,
you don't need to

00:48:32.840 --> 00:48:35.200
distinguish among those, because
they take the same

00:48:35.200 --> 00:48:37.400
amount of steps.

00:48:37.400 --> 00:48:39.810
So since they take the same
amount of steps, we don't need

00:48:39.810 --> 00:48:40.500
to search further.

00:48:40.500 --> 00:48:41.650
So we can collapse them.

00:48:41.650 --> 00:48:44.390
That's called pruning
rule (2).

00:48:44.390 --> 00:48:46.120
That's also easy to implement.

00:48:46.120 --> 00:48:49.890
What we do is, we keep track of,
for every parent, what are

00:48:49.890 --> 00:48:52.830
all of its children.

00:48:52.830 --> 00:48:59.250
If the parent already has a
child at that place, throw

00:48:59.250 --> 00:49:02.210
away the excess children.

00:49:02.210 --> 00:49:03.460
That doesn't sound good.

00:49:07.220 --> 00:49:10.490
So keep track of how many
child states I have.

00:49:10.490 --> 00:49:12.480
Make a list.

00:49:12.480 --> 00:49:18.180
And if the new state didn't
satisfy the goal, ask if it's

00:49:18.180 --> 00:49:21.500
already in the list
of children.

00:49:21.500 --> 00:49:23.360
If it's already there, pass.

00:49:23.360 --> 00:49:24.610
Don't do anything.

00:49:27.430 --> 00:49:29.360
Otherwise, do pruning
rule (1).

00:49:29.360 --> 00:49:32.850
And then, before you push it
into the agenda, also push it

00:49:32.850 --> 00:49:35.150
into the list of new children.

00:49:38.010 --> 00:49:41.100
That's a way of making sure that
if there's multiple ways

00:49:41.100 --> 00:49:43.700
to get the same state, you
only keep track of one.

00:49:43.700 --> 00:49:47.420
So that's an additional
pruning rule.

00:49:47.420 --> 00:49:52.050
So now let's think about how
we would implement these.

00:49:52.050 --> 00:49:55.560
Let's think about the solution
to a problem where we want to

00:49:55.560 --> 00:50:02.490
apply a depth-first search on
this Manhattan problem, to get

00:50:02.490 --> 00:50:04.250
from A to I. So let's
think about--

00:50:09.800 --> 00:50:11.050
let's go up--

00:50:14.740 --> 00:50:19.780
so I want to think about, how do
I apply depth-first search

00:50:19.780 --> 00:50:21.260
to that problem?

00:50:21.260 --> 00:50:23.040
So think about the agenda.

00:50:23.040 --> 00:50:25.870
So the agenda, I initialized
it with the node that

00:50:25.870 --> 00:50:32.370
corresponds to the start state,
so that's A. I'm doing

00:50:32.370 --> 00:50:33.050
depth first.

00:50:33.050 --> 00:50:35.120
What's the rule for
depth first?

00:50:35.120 --> 00:50:39.290
Pop the last guy, replace
it by his children.

00:50:39.290 --> 00:50:41.360
OK, so pop the last guy.

00:50:41.360 --> 00:50:42.550
What's the last guy?

00:50:42.550 --> 00:50:45.220
The last guy is A. Replace
it by his children.

00:50:45.220 --> 00:50:47.420
What's his children of A?

00:50:47.420 --> 00:50:49.225
Well, there's two of
them, AB and AD.

00:50:56.050 --> 00:50:56.125
Ok.

00:50:56.125 --> 00:51:00.330
So I'm done with the loop
for the first level.

00:51:00.330 --> 00:51:06.230
So pop the last guy,
that's AD.

00:51:06.230 --> 00:51:07.420
Replace it by his children.

00:51:07.420 --> 00:51:10.780
What are the children of AD?

00:51:10.780 --> 00:51:11.830
Well, what could D do?

00:51:11.830 --> 00:51:17.040
D could go to A or E or G.
A's brain dead, so I

00:51:17.040 --> 00:51:18.620
don't want that one.

00:51:18.620 --> 00:51:21.970
So I'll think about E and G.

00:51:21.970 --> 00:51:26.120
So ADE, ADG.

00:51:30.810 --> 00:51:32.900
By the way, stop me if
I make a mistake.

00:51:32.900 --> 00:51:35.360
It's really embarrassing.

00:51:35.360 --> 00:51:39.200
OK, pop the end, ADG.

00:51:39.200 --> 00:51:43.740
Who's the possible
children of ADG?

00:51:43.740 --> 00:51:44.390
ADG?

00:51:44.390 --> 00:51:46.130
Well, it could go back to
D, but that's stupid.

00:51:46.130 --> 00:51:48.940
So ADGH seems to be
the only good one.

00:51:54.600 --> 00:51:58.260
Pop the last one, ADGH.

00:51:58.260 --> 00:52:02.400
And who's his children, ADGH?

00:52:02.400 --> 00:52:11.460
ADGH has children E, G, and I.
But I don't want G, because

00:52:11.460 --> 00:52:12.770
that's brain dead.

00:52:12.770 --> 00:52:24.700
So ADGH, E or I. And that
one won, right?

00:52:24.700 --> 00:52:27.750
Because I got to A.

00:52:27.750 --> 00:52:28.960
Everyone see what I did?

00:52:28.960 --> 00:52:33.380
I tried to work out the
algorithm manually.

00:52:33.380 --> 00:52:35.230
So the idea, then, was that--

00:52:38.630 --> 00:52:40.400
so how much work I do?

00:52:40.400 --> 00:52:43.570
I visited 1, 2, 3, 4, 5, 6, 7.

00:52:43.570 --> 00:52:44.720
And then I found it.

00:52:44.720 --> 00:52:45.970
So I did 7 visits.

00:52:48.580 --> 00:52:49.830
And I got the right answer.

00:52:52.450 --> 00:52:53.740
So both of those are good--

00:52:53.740 --> 00:52:56.220
7 is a small number, and getting
the right answer.

00:52:56.220 --> 00:52:59.330
Both of those are good things.

00:52:59.330 --> 00:53:02.570
And in general, if you think
about the way a depth-first

00:53:02.570 --> 00:53:03.850
search works--

00:53:03.850 --> 00:53:07.330
here's a transcript of
what I just did.

00:53:07.330 --> 00:53:09.550
This will be posted on
the online version.

00:53:09.550 --> 00:53:11.600
So you can see it, even
though it's not

00:53:11.600 --> 00:53:14.150
handed out to you now.

00:53:14.150 --> 00:53:17.410
So you can look this
up on the web.

00:53:17.410 --> 00:53:21.940
So in general, depth-first
search won't

00:53:21.940 --> 00:53:23.190
work for every problem.

00:53:25.840 --> 00:53:27.790
It happened to work
for this problem.

00:53:27.790 --> 00:53:29.820
In fact, it happened to be very
good for this problem.

00:53:29.820 --> 00:53:31.420
But it won't work for every
problem because

00:53:31.420 --> 00:53:33.570
it could get stuck.

00:53:33.570 --> 00:53:36.480
It could run forever in a
problem with infinite domain.

00:53:36.480 --> 00:53:37.890
This problem has infinite
domain.

00:53:37.890 --> 00:53:41.030
So if I were to choose my
start and end state

00:53:41.030 --> 00:53:44.380
judiciously, I could get it
stuck in an infinite loop.

00:53:44.380 --> 00:53:49.530
That's a property of
depth-first search.

00:53:49.530 --> 00:53:53.420
Even when it finds a path, it
doesn't necessarily find the

00:53:53.420 --> 00:53:55.110
shortest path.

00:53:55.110 --> 00:53:58.710
Well, that's a bummer.

00:53:58.710 --> 00:54:04.040
But it's very efficient
in its use of memory.

00:54:04.040 --> 00:54:08.580
So it's not a completely
brain-dead search strategy,

00:54:08.580 --> 00:54:10.720
but it's usually brain dead.

00:54:10.720 --> 00:54:16.230
So let's think about
breadth-first search as an

00:54:16.230 --> 00:54:17.360
alternative.

00:54:17.360 --> 00:54:21.060
Again, all we need do is switch
the idea of thinking

00:54:21.060 --> 00:54:26.020
about stacks versus queues.

00:54:26.020 --> 00:54:28.300
Take off the beginning,
add to the end.

00:54:28.300 --> 00:54:30.180
That's the way queues work.

00:54:30.180 --> 00:54:32.650
So now let's do the same
problem with a

00:54:32.650 --> 00:54:34.640
breadth-first search.

00:54:34.640 --> 00:54:36.190
So I start with the agenda.

00:54:36.190 --> 00:54:43.260
I put in A. I pop off the head
of the queue and stuff the

00:54:43.260 --> 00:54:45.320
children at the end.

00:54:45.320 --> 00:54:49.280
I pop off the beginning and
stuff the children AB, AD.

00:54:52.200 --> 00:54:54.520
That looks right.

00:54:54.520 --> 00:54:57.940
That's the end of path one.

00:54:57.940 --> 00:55:02.020
Now I pop off the beginning
and stick in the children.

00:55:02.020 --> 00:55:04.160
What are the children of AB?

00:55:04.160 --> 00:55:06.840
Well, AB could go to ACE.

00:55:06.840 --> 00:55:08.955
A is brain dead, so ABC--

00:55:12.070 --> 00:55:13.320
ABC or ABE.

00:55:16.670 --> 00:55:20.340
ABC or ABE, that looks right.

00:55:20.340 --> 00:55:26.130
Now pop off this guy, AD, and
put his children at the end.

00:55:26.130 --> 00:55:27.863
That's ADE and ADG.

00:55:35.690 --> 00:55:37.870
I don't think I made
a mistake yet.

00:55:37.870 --> 00:55:40.430
Pop off the first guy, ABC.

00:55:40.430 --> 00:55:44.350
Stick in his children ABC--

00:55:44.350 --> 00:55:49.930
ABC, it could go to B or F.
Looks like F is the only one

00:55:49.930 --> 00:55:52.630
that makes any sense.

00:55:52.630 --> 00:55:54.850
ABC, that looks right.

00:55:54.850 --> 00:56:01.750
ABE, put his children ABE--

00:56:01.750 --> 00:56:04.340
E could go to B-- that's
brain dead--

00:56:04.340 --> 00:56:11.450
D, F, or H. D, F-- wait.

00:56:15.019 --> 00:56:15.920
AUDIENCE: AB.

00:56:15.920 --> 00:56:17.170
PROFESSOR: AB, thank you.

00:56:21.770 --> 00:56:26.010
I'm supposed to be doing ABE
followed by something, ABE

00:56:26.010 --> 00:56:27.150
followed by something.

00:56:27.150 --> 00:56:32.290
I don't want B. D is fine,
F is fine, and H is fine.

00:56:32.290 --> 00:56:44.320
D, F, and H. OK so far?

00:56:44.320 --> 00:56:45.410
AUDIENCE: [INAUDIBLE]

00:56:45.410 --> 00:56:47.000
PROFESSOR: Oh no,
it's not right?

00:56:47.000 --> 00:56:48.349
OK, what did I do wrong?

00:56:48.349 --> 00:56:51.283
AUDIENCE: Just AB.

00:56:51.283 --> 00:56:53.239
It's the fourth--

00:56:53.239 --> 00:56:54.217
PROFESSOR: Oh, here.

00:56:54.217 --> 00:56:55.195
That's up here.

00:56:55.195 --> 00:56:56.662
Is that [INAUDIBLE].

00:56:56.662 --> 00:56:57.640
AUDIENCE: Yeah.

00:56:57.640 --> 00:56:58.618
PROFESSOR: Thank you.

00:56:58.618 --> 00:57:00.090
That would be embarrassing.

00:57:00.090 --> 00:57:03.010
OK, next pop off AD--

00:57:03.010 --> 00:57:04.940
This is why we have
computers, right?

00:57:04.940 --> 00:57:08.420
We don't normally
do this by hand.

00:57:08.420 --> 00:57:10.410
OK, so ADE--

00:57:15.850 --> 00:57:19.880
if I had ADE, I could do B--

00:57:19.880 --> 00:57:23.370
that seems OK, D seems bad--

00:57:23.370 --> 00:57:25.790
F, or H. So it would look like

00:57:25.790 --> 00:57:37.490
B, F, H. OK, ADG.

00:57:43.160 --> 00:57:48.013
A, D, G. It looks like
H is my only option.

00:57:52.690 --> 00:57:53.940
ABCF.

00:57:56.378 --> 00:58:11.300
A, B, C, F. Looks like I could
do E or I. Finally.

00:58:11.300 --> 00:58:12.650
Now the only question
is whether I got the

00:58:12.650 --> 00:58:14.380
right number of states.

00:58:14.380 --> 00:58:15.780
Let's assume I did.

00:58:15.780 --> 00:58:17.030
So 1, 2, 3, 4, 5, 6, 7, 8, 9,
10, 11, 12, 13, 14, 15, 16 --

00:58:26.740 --> 00:58:28.010
which happens to be
the right answer.

00:58:28.010 --> 00:58:29.820
At least it happens to be the
answer I got this morning when

00:58:29.820 --> 00:58:32.380
I was at breakfast.

00:58:32.380 --> 00:58:34.220
So what did I just do?

00:58:34.220 --> 00:58:37.450
I just did a breadth-first
search.

00:58:40.030 --> 00:58:41.660
Here's a transcript.

00:58:41.660 --> 00:58:42.910
16 matches, good.

00:58:45.860 --> 00:58:48.870
Breadth-first search has a
different set of properties.

00:58:48.870 --> 00:58:51.680
Notice that it took me longer.

00:58:51.680 --> 00:58:55.490
But because it's breadth first,
and because each row

00:58:55.490 --> 00:58:58.020
corresponds to an increasing
path length, it's always

00:58:58.020 --> 00:59:00.190
guaranteed to give you
the shortest answer.

00:59:00.190 --> 00:59:02.070
That's good.

00:59:02.070 --> 00:59:04.280
So it always gives you
the shortest answer.

00:59:07.410 --> 00:59:09.210
It requires more space.

00:59:09.210 --> 00:59:10.930
I mean, you can see that
just on the chalkboard.

00:59:13.960 --> 00:59:17.140
And also it still didn't take
care of your problem.

00:59:17.140 --> 00:59:20.480
So this still seems like
there's too much work.

00:59:24.690 --> 00:59:28.360
I looked at 16 different
places.

00:59:28.360 --> 00:59:32.140
I did 16 visits.

00:59:32.140 --> 00:59:34.800
There's just something
completely wrong about that,

00:59:34.800 --> 00:59:36.375
because there's only 9 states.

00:59:39.080 --> 00:59:44.750
How could it take more visits
than there are states?

00:59:44.750 --> 00:59:46.930
So that just doesn't
sound right.

00:59:46.930 --> 00:59:48.830
And it's for exactly
your point.

00:59:48.830 --> 00:59:51.570
And so there's another idea
that we can use, which is

00:59:51.570 --> 00:59:56.170
called "dynamic programming."
The idea in dynamic

00:59:56.170 --> 01:00:00.370
programming, the principal is,
if you think about a path that

01:00:00.370 --> 01:00:08.000
goes from x is z through y,
the best path from x to z

01:00:08.000 --> 01:00:11.820
through y is the sum
of two paths--

01:00:11.820 --> 01:00:15.608
the best path from x to y and
the best path from y to z.

01:00:18.750 --> 01:00:20.520
If you think about that, that
has to be the case.

01:00:23.040 --> 01:00:27.690
And if we further assume that
we're going to do breadth

01:00:27.690 --> 01:00:33.720
first, then the first time that
we see a state is the

01:00:33.720 --> 01:00:35.420
best way to get there.

01:00:38.100 --> 01:00:40.840
So what we can do then, in order
to take care of your

01:00:40.840 --> 01:00:45.530
case, is keep track of the
states we've already visited.

01:00:45.530 --> 01:00:49.760
If we've already visited a
state, it appears earlier in

01:00:49.760 --> 01:00:54.480
the tree, there's no point in
thinking about it further.

01:00:54.480 --> 01:00:57.440
That's the idea of dynamic
programming.

01:00:57.440 --> 01:00:59.980
And that's also easy
to implement.

01:00:59.980 --> 01:01:02.370
All we need to do is keep track
of all those places

01:01:02.370 --> 01:01:04.940
we've already visited.

01:01:04.940 --> 01:01:13.440
So we make a dictionary called
"visited." So I initialize

01:01:13.440 --> 01:01:15.510
before I start looking
at the children.

01:01:15.510 --> 01:01:18.910
I initialize right after
I set up the initial

01:01:18.910 --> 01:01:20.900
contents of the agenda.

01:01:20.900 --> 01:01:23.640
I create this dictionary
called visited.

01:01:23.640 --> 01:01:30.010
And every time I visit a new
state, I put that state in the

01:01:30.010 --> 01:01:32.430
visit list.

01:01:32.430 --> 01:01:41.520
Then before I add the child to
the agenda I ask, is the child

01:01:41.520 --> 01:01:45.510
already in the visit list?

01:01:45.510 --> 01:01:47.950
If the child's already there,
well forget it.

01:01:47.950 --> 01:01:51.030
I don't need him.

01:01:51.030 --> 01:01:57.560
Otherwise, just before you push
the new state, remember

01:01:57.560 --> 01:02:02.180
now that that's an element
that's been visited.

01:02:02.180 --> 01:02:05.420
So the idea, then, is that by
keeping track of who you've

01:02:05.420 --> 01:02:08.890
already looked at, you
can avoid looking--

01:02:08.890 --> 01:02:15.840
so if there's a depth-3 way to
get to D, and a depth-2, then

01:02:15.840 --> 01:02:19.620
I don't need to worry about
the previous ones, because

01:02:19.620 --> 01:02:20.560
it's already in the visit list.

01:02:20.560 --> 01:02:21.535
Yes?

01:02:21.535 --> 01:02:25.495
AUDIENCE: Why do we still need
the new child states up there?

01:02:25.495 --> 01:02:28.465
PROFESSOR: Why do we still have
the new child states?

01:02:28.465 --> 01:02:30.940
AUDIENCE: The placement was
based [? on-- ?] the

01:02:30.940 --> 01:02:32.425
[INAUDIBLE] state.

01:02:32.425 --> 01:02:35.395
PROFESSOR: I think
you're right.

01:02:35.395 --> 01:02:36.880
I should think about that.

01:02:36.880 --> 01:02:37.870
I think you're right.

01:02:37.870 --> 01:02:41.630
I think when I was modifying
the code for the different

01:02:41.630 --> 01:02:43.960
places I slipped and could
have removed that line.

01:02:43.960 --> 01:02:45.540
I think you're right.

01:02:45.540 --> 01:02:47.360
I'll have to think about it,
but I think you're right.

01:02:47.360 --> 01:02:50.370
So if that line magically
disappears from the online

01:02:50.370 --> 01:02:51.620
version, he's right.

01:02:55.020 --> 01:02:58.300
OK, so now one last problem.

01:02:58.300 --> 01:03:04.840
I want to see if I can figure
out what would happen with

01:03:04.840 --> 01:03:07.930
dynamic programming.

01:03:07.930 --> 01:03:10.500
So I want to do breadth first.

01:03:10.500 --> 01:03:14.500
And just as a warning, I'm
hypoglycemic at this point.

01:03:14.500 --> 01:03:17.440
So there may be more
errors than usual.

01:03:17.440 --> 01:03:19.860
So I need to keep track
of two things.

01:03:19.860 --> 01:03:22.580
I need to keep track
of the visit list.

01:03:22.580 --> 01:03:26.460
And I need to keep track
of the agenda.

01:03:26.460 --> 01:03:29.650
So there's two lists I have
to keep track of.

01:03:29.650 --> 01:03:30.320
OK.

01:03:30.320 --> 01:03:33.000
Let's start out by saying
that the agenda

01:03:33.000 --> 01:03:34.970
contains the start element.

01:03:34.970 --> 01:03:44.100
That's A. That means we visited
A. It's breadth first,

01:03:44.100 --> 01:03:47.550
so I want to take the first guy
out of the queue and add

01:03:47.550 --> 01:03:49.810
his children to the
end of the queue.

01:03:49.810 --> 01:03:51.730
So take the first guy
out of the queue.

01:03:51.730 --> 01:03:52.790
Add his children.

01:03:52.790 --> 01:03:59.510
A's children are B and D, which
means that I've now

01:03:59.510 --> 01:04:06.620
visited B and D.

01:04:06.620 --> 01:04:10.460
Now I want to take out the first
guy from the queue, AB,

01:04:10.460 --> 01:04:14.583
and I want to put his children
at the end of the queue.

01:04:14.583 --> 01:04:17.060
AB's children are A--

01:04:17.060 --> 01:04:19.200
that's been visited, C--

01:04:19.200 --> 01:04:21.040
not visited, and E--

01:04:21.040 --> 01:04:22.740
not visited.

01:04:22.740 --> 01:04:24.162
So ABCE.

01:04:28.580 --> 01:04:35.810
But that visits C and E.

01:04:35.810 --> 01:04:42.580
Now I want to take out AD and
put its children at the end.

01:04:42.580 --> 01:04:46.060
AD is AEG.

01:04:46.060 --> 01:04:52.245
A is visited, E is visited,
which leaves just G, so ADG .

01:04:54.800 --> 01:04:59.700
And that visits G.

01:04:59.700 --> 01:05:04.940
Then I want to take out ABC and
put in its children, A, B,

01:05:04.940 --> 01:05:09.180
C. ABC, oh dear.

01:05:09.180 --> 01:05:09.850
AB--

01:05:09.850 --> 01:05:11.920
I'm looking up there.

01:05:11.920 --> 01:05:14.360
I said I'm hypoglycemic.

01:05:14.360 --> 01:05:15.710
ABC--

01:05:15.710 --> 01:05:20.030
ABC -- could be B or F.
Well, B's no good.

01:05:20.030 --> 01:05:27.290
Which leaves F, but
that visits F.

01:05:27.290 --> 01:05:28.540
So now, ABE.

01:05:32.740 --> 01:05:38.570
ABE, so that could be
B, D, F, H. B--

01:05:38.570 --> 01:05:40.270
visited, D--

01:05:40.270 --> 01:05:41.820
visited, F--

01:05:41.820 --> 01:05:43.562
visited, H--

01:05:43.562 --> 01:05:44.812
OK.

01:05:47.530 --> 01:05:50.760
That visits H.

01:05:50.760 --> 01:05:52.010
Now take out ADG.

01:05:55.560 --> 01:05:58.100
Children of ADG--

01:05:58.100 --> 01:06:03.760
ADG, two children, D and H. D
and H, they're both there.

01:06:03.760 --> 01:06:05.380
That didn't work.

01:06:05.380 --> 01:06:09.567
There are no children of ADG.

01:06:09.567 --> 01:06:10.817
ABCF--

01:06:13.810 --> 01:06:17.210
ABCF, three children--

01:06:17.210 --> 01:06:20.590
C, E, I. C--

01:06:20.590 --> 01:06:21.710
visited, E--

01:06:21.710 --> 01:06:22.970
visited, I--

01:06:22.970 --> 01:06:25.240
done.

01:06:25.240 --> 01:06:26.070
Found the right answer.

01:06:26.070 --> 01:06:27.320
1, 2, 3, 4, 5, 6, 7, 8 --

01:06:29.410 --> 01:06:32.050
8 visits.

01:06:32.050 --> 01:06:40.910
So I've got the same answer,
and it's optimal, and I did

01:06:40.910 --> 01:06:42.560
fewer than 9 visits.

01:06:42.560 --> 01:06:44.800
9 was the number of states.

01:06:44.800 --> 01:06:48.790
So this algorithm will always
have those properties.

01:06:48.790 --> 01:06:52.380
So the dynamic programming--

01:06:52.380 --> 01:06:53.630
oh, I forgot a slide.

01:06:56.270 --> 01:06:59.360
The dynamic programming with
breadth-first search will

01:06:59.360 --> 01:07:01.410
always find the best.

01:07:01.410 --> 01:07:04.600
It will never take longer than
the number of states.

01:07:04.600 --> 01:07:07.400
So in this problem that had a
finite number of states, even

01:07:07.400 --> 01:07:10.360
though I had an infinite
number of paths--

01:07:10.360 --> 01:07:13.290
because you can go around
in circles--

01:07:13.290 --> 01:07:16.910
it'll still never take more
than the number of states.

01:07:16.910 --> 01:07:21.390
And all that it requires to
implement is to maintain two

01:07:21.390 --> 01:07:24.040
lists instead of one.

01:07:24.040 --> 01:07:27.670
So the point, then, is that
today we looked at a variety--

01:07:27.670 --> 01:07:29.980
we looked at two real different
kinds of search

01:07:29.980 --> 01:07:32.240
algorithms, depth-first search
and breadth-first search.

01:07:32.240 --> 01:07:34.600
And we looked at a number of
different pruning rules.

01:07:34.600 --> 01:07:36.610
Pruning rule (1) -- don't go
to some place that you've

01:07:36.610 --> 01:07:37.880
already visited.

01:07:37.880 --> 01:07:39.570
Pruning rule (2) -- if you have
two children that go to

01:07:39.570 --> 01:07:42.200
the same place, only think
about one of them.

01:07:42.200 --> 01:07:44.510
You can consider dynamic
programming to be a third

01:07:44.510 --> 01:07:49.030
pruning rule, because that's
the effect of it.

01:07:49.030 --> 01:07:54.850
And the final announcement,
don't forget about Wednesday.

01:07:54.850 --> 01:07:56.100
Have a good week.

