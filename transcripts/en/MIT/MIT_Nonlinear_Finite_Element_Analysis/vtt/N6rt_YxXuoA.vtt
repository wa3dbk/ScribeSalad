WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:02.470
The following content is
provided under a Creative

00:00:02.470 --> 00:00:03.880
Commons license.

00:00:03.880 --> 00:00:06.920
Your support will help MIT
OpenCourseWare continue to

00:00:06.920 --> 00:00:10.570
offer high quality educational
resources for free.

00:00:10.570 --> 00:00:13.470
To make a donation, or view
additional materials from

00:00:13.470 --> 00:00:18.825
hundreds of MIT courses, visit
MIT OpenCourseWare at

00:00:18.825 --> 00:00:20.075
ocw.mit.edu.

00:00:21.808 --> 00:00:23.920
PROFESSOR: Ladies and gentlemen,
welcome to this

00:00:23.920 --> 00:00:26.870
lecture on nonlinear finite
element analysis of solids and

00:00:26.870 --> 00:00:27.870
structures.

00:00:27.870 --> 00:00:30.050
In this lecture, I would like
to continue with our

00:00:30.050 --> 00:00:34.090
discussion of solution methods
that we use to solve the

00:00:34.090 --> 00:00:37.580
finite element equations in
nonlinear static analysis.

00:00:37.580 --> 00:00:40.020
We considered already in the
previous lecture a number of

00:00:40.020 --> 00:00:43.720
solution techniques to solve
this set of equations.

00:00:43.720 --> 00:00:47.350
t plus delta tr is equal to t
plus delta tf, where t plus

00:00:47.350 --> 00:00:51.720
delta tr is the load vector of
externally applied loads at

00:00:51.720 --> 00:00:56.410
time t plus delta t, and t plus
tf is a nodal point force

00:00:56.410 --> 00:00:59.210
vector corresponding to the
internal element stresses at

00:00:59.210 --> 00:01:01.080
time t plus delta t.

00:01:01.080 --> 00:01:04.010
We talked about the full
Newton-Raphson method, the

00:01:04.010 --> 00:01:07.270
modified Newton-Raphson method,
the BFGS method, the

00:01:07.270 --> 00:01:08.920
initial stress method,
and we discussed

00:01:08.920 --> 00:01:11.110
also convergence criteria.

00:01:11.110 --> 00:01:13.890
I've summarized here the
equations corresponding to the

00:01:13.890 --> 00:01:16.260
modified Newton iteration.

00:01:16.260 --> 00:01:19.700
Now, a distinguishing feature
of these solution techniques

00:01:19.700 --> 00:01:25.610
is that the analyst has to
prescribe the externally

00:01:25.610 --> 00:01:26.680
applied load vector

00:01:26.680 --> 00:01:30.520
corresponding to all load steps.

00:01:30.520 --> 00:01:36.240
This means schematically that
if you have this kind of

00:01:36.240 --> 00:01:40.380
displacement load curve, or load
displacement curve, shown

00:01:40.380 --> 00:01:44.350
here in red, the analyst has
to prescribe prior to the

00:01:44.350 --> 00:01:50.760
analysis the load levels at
which the response is sought.

00:01:50.760 --> 00:01:54.800
I've here indicated 1r as a load
level corresponding to

00:01:54.800 --> 00:01:58.560
load step one, 2r as a load
level corresponding to load

00:01:58.560 --> 00:02:01.150
step two, et cetera.

00:02:01.150 --> 00:02:04.130
Of course, the corresponding
solutions that the analyst is

00:02:04.130 --> 00:02:08.509
looking for are the
displacements.

00:02:08.509 --> 00:02:11.810
Now, what might very well happen
in practical analysis

00:02:11.810 --> 00:02:16.560
is that the analyst chooses
certain load levels, and at

00:02:16.560 --> 00:02:19.570
the particular load level
convergence difficulties are

00:02:19.570 --> 00:02:20.470
encountered.

00:02:20.470 --> 00:02:23.550
Too many iterations are required
to converge, for

00:02:23.550 --> 00:02:28.650
example, in a reasonable cost.

00:02:28.650 --> 00:02:33.210
And typically, say, if this
happens at this load step

00:02:33.210 --> 00:02:36.800
here, the analyst decides
to restock.

00:02:36.800 --> 00:02:41.700
And this means that a solution
corresponding to r4 here was

00:02:41.700 --> 00:02:43.730
not obtained.

00:02:43.730 --> 00:02:45.160
I'm scratching that out.

00:02:45.160 --> 00:02:50.400
And the analyst restarts now
with a smaller load step,

00:02:50.400 --> 00:02:54.270
namely indicated by these
green lines here.

00:02:54.270 --> 00:02:58.030
The solution is obtained
corresponding to that

00:02:58.030 --> 00:03:01.850
configuration, corresponding
to that configuration, that

00:03:01.850 --> 00:03:04.570
configuration, which corresponds
in this particular

00:03:04.570 --> 00:03:08.290
case now, to the level of r4,
because we have three load

00:03:08.290 --> 00:03:10.400
steps to reach now r4.

00:03:10.400 --> 00:03:15.470
And say, at this point now,
again, for example, we may

00:03:15.470 --> 00:03:17.970
encounter solution
difficulties.

00:03:17.970 --> 00:03:21.400
The analyst is not able to
obtain this solution here.

00:03:21.400 --> 00:03:25.540
Once again, the load step
has to be smaller.

00:03:25.540 --> 00:03:29.370
To continue the analysis, a
restart is necessary at this

00:03:29.370 --> 00:03:31.390
particular configuration.

00:03:31.390 --> 00:03:35.020
And like this the analyst tries
to get closer and closer

00:03:35.020 --> 00:03:37.600
to the collapse load.

00:03:37.600 --> 00:03:42.190
The conclusion is that we have
difficulties in calculating

00:03:42.190 --> 00:03:46.890
the collapse loads when we
use the techniques that I

00:03:46.890 --> 00:03:50.690
described in the last lecture.

00:03:50.690 --> 00:03:55.860
Of course, if you restart
enough, if you use small

00:03:55.860 --> 00:03:59.000
enough to load steps, you will
ultimately get very close to

00:03:59.000 --> 00:04:02.030
this collapse load, but this
is tedious in a practical

00:04:02.030 --> 00:04:04.730
analysis, and we would like to
have really an automatic

00:04:04.730 --> 00:04:09.900
scheme that directly can trace
out the collapse load and you

00:04:09.900 --> 00:04:14.460
can also go into the
post-collapse response, which

00:04:14.460 --> 00:04:19.740
is the response beyond this
ultimate limit load here.

00:04:19.740 --> 00:04:24.830
Well, I've prepared some view
graphs to show you, discuss

00:04:24.830 --> 00:04:29.730
with you, a solution technique
that actually can be employed

00:04:29.730 --> 00:04:34.680
to trace automatically load
displacement response out, and

00:04:34.680 --> 00:04:37.980
go beyond the collapse
load, as well.

00:04:37.980 --> 00:04:41.620
The idea is that we want to
obtain more rapid convergence

00:04:41.620 --> 00:04:44.170
in each load step.

00:04:44.170 --> 00:04:48.230
We want to have the program
automatically select load

00:04:48.230 --> 00:04:50.200
increments.

00:04:50.200 --> 00:04:53.440
And we want to also be
able to solve for the

00:04:53.440 --> 00:04:55.120
post-buckling response.

00:04:55.120 --> 00:04:59.980
Now, this here means, of course,
that a priori, prior

00:04:59.980 --> 00:05:03.400
to the analysis, you may not
know, in fact you do not know,

00:05:03.400 --> 00:05:06.880
for which loads you will
obtain the solution.

00:05:06.880 --> 00:05:10.190
We get the total load
displacement response curve,

00:05:10.190 --> 00:05:13.190
but the discrete load levels
at which the response was

00:05:13.190 --> 00:05:18.230
calculated is being decided
by the program.

00:05:18.230 --> 00:05:21.380
An effective solution would
proceed as follows,

00:05:21.380 --> 00:05:23.020
schematically, of course.

00:05:23.020 --> 00:05:25.280
Here we have the load axis.

00:05:25.280 --> 00:05:27.850
Here we have the displacement
axis.

00:05:27.850 --> 00:05:30.430
The solution scheme would
start with large load

00:05:30.430 --> 00:05:35.190
increments in the region where
the response is almost linear,

00:05:35.190 --> 00:05:40.720
then cut the load increments
to a smaller size, and

00:05:40.720 --> 00:05:44.830
capture, of course, the ultimate
limit load here, and

00:05:44.830 --> 00:05:48.650
then decrease the load, as shown
here, to go into the

00:05:48.650 --> 00:05:51.080
post-buckling, post-collapse
response.

00:05:51.080 --> 00:05:55.000
And the solution scheme, of
course, could continue up this

00:05:55.000 --> 00:05:57.240
branch as well.

00:05:57.240 --> 00:06:01.280
And the solution scheme should
automatically select the load

00:06:01.280 --> 00:06:05.190
step sizes, depending on the
convergence that has been

00:06:05.190 --> 00:06:10.620
encountered in the previous
load steps.

00:06:10.620 --> 00:06:16.040
We compute now, t plus delta tr
using this equation here.

00:06:16.040 --> 00:06:19.810
Notice that in this equation,
t plus delta t lambda is an

00:06:19.810 --> 00:06:22.600
unknown scaler that is going
to be determined by the

00:06:22.600 --> 00:06:26.920
program, and r is a vector that
gives a particular load

00:06:26.920 --> 00:06:28.095
distribution.

00:06:28.095 --> 00:06:30.280
r is constant.

00:06:30.280 --> 00:06:32.500
It may contain the contributions
of soft surface

00:06:32.500 --> 00:06:37.050
pressures, of concentrated
loads, et cetera.

00:06:37.050 --> 00:06:40.030
The point is that r is constant
and the program will

00:06:40.030 --> 00:06:42.390
automatically adjust lambda.

00:06:42.390 --> 00:06:46.340
Therefore, we assume in our
collapse analysis that the

00:06:46.340 --> 00:06:52.120
loads are increasing and
decreasing all in the same way

00:06:52.120 --> 00:06:54.190
as decided by one scale.

00:06:54.190 --> 00:06:58.170
Of course, one could extend
such an algorithm by

00:06:58.170 --> 00:07:02.460
introducing another vector,
calling this r1, introducing a

00:07:02.460 --> 00:07:05.020
vector r2, with another
scaler.

00:07:05.020 --> 00:07:08.000
And then have two scalers
that have to be adjusted

00:07:08.000 --> 00:07:09.830
automatically by the program.

00:07:09.830 --> 00:07:12.300
And perhaps one can even think
of three scalers, and so on,

00:07:12.300 --> 00:07:15.350
but then the algorithm would
become quite complicated.

00:07:15.350 --> 00:07:19.040
So we look at a scheme that only
has one scaler here, and

00:07:19.040 --> 00:07:22.680
one load vector that
remains constant

00:07:22.680 --> 00:07:24.400
throughout the solution.

00:07:24.400 --> 00:07:28.830
As an example here, you
see in blue the load

00:07:28.830 --> 00:07:32.020
intensity, t lambda r.

00:07:32.020 --> 00:07:35.740
Notice a concentrated load here,
a pressure load here,

00:07:35.740 --> 00:07:40.610
and at the time t plus delta t
we have the red intensity, t

00:07:40.610 --> 00:07:45.750
plus delta t lambda r, and of
course this concentrated load

00:07:45.750 --> 00:07:50.530
has increased in the same way as
the pressure has increased,

00:07:50.530 --> 00:07:53.080
as shown right here.

00:07:53.080 --> 00:07:57.260
The basic approach of the
solution scheme is shown on

00:07:57.260 --> 00:07:58.700
this view graph.

00:07:58.700 --> 00:08:01.650
Here we have the low
displacement curve that we are

00:08:01.650 --> 00:08:05.150
looking for, shown
in red again.

00:08:05.150 --> 00:08:07.880
Of course, loads plotted
vertically, displacements

00:08:07.880 --> 00:08:09.640
plotted horizontally.

00:08:09.640 --> 00:08:15.250
Now, notice that if this is an
equilibrium point, the red

00:08:15.250 --> 00:08:19.950
dot, and if you as the analyst
were to chose an increment in

00:08:19.950 --> 00:08:24.480
load shown by this
black line--

00:08:24.480 --> 00:08:27.440
I'm putting my pointer
now onto it--

00:08:27.440 --> 00:08:32.140
then you can see that this black
line defined by this

00:08:32.140 --> 00:08:39.860
load increment would mean that
we have a large number of

00:08:39.860 --> 00:08:41.750
iterations necessary.

00:08:41.750 --> 00:08:45.390
If you need a large number of
iterations, to converge to the

00:08:45.390 --> 00:08:47.480
new equilibrium configuration.

00:08:47.480 --> 00:08:52.230
In fact, you can see that this
red curve is almost parallel

00:08:52.230 --> 00:08:56.470
to the black line, so we can
anticipate large convergence

00:08:56.470 --> 00:09:00.530
difficulties trying to get to
a solution with the load

00:09:00.530 --> 00:09:06.660
increment being equal from
here to that black line.

00:09:06.660 --> 00:09:10.330
The important feature of the
algorithm that I want to

00:09:10.330 --> 00:09:16.000
present to you now, is that this
load level is the first

00:09:16.000 --> 00:09:19.190
load level which we start in
the iteration, but then the

00:09:19.190 --> 00:09:24.130
algorithm automatically cuts
down this load level, as shown

00:09:24.130 --> 00:09:30.920
by this arc here, by the blue
arc, until this equilibrium

00:09:30.920 --> 00:09:33.230
point is solved for.

00:09:33.230 --> 00:09:38.650
And this means that the
convergence is much increased.

00:09:38.650 --> 00:09:41.280
In other words, the algorithm
does not have great

00:09:41.280 --> 00:09:45.370
difficulties calculating this
particular equilibrium point.

00:09:45.370 --> 00:09:48.130
And from here, of course,
the same is repeated.

00:09:48.130 --> 00:09:52.640
And like this the algorithm
goes along this red

00:09:52.640 --> 00:09:57.160
low-displacement curve, and
traces this whole curve out.

00:09:57.160 --> 00:10:00.680
Let us look a bit at the
notation that I will be using,

00:10:00.680 --> 00:10:03.020
because it's important
that we get familiar

00:10:03.020 --> 00:10:05.600
with it at this stage.

00:10:05.600 --> 00:10:11.010
Notice t lambda r, of course,
is the load at time t.

00:10:11.010 --> 00:10:13.120
The corresponding displacement
is tu.

00:10:13.120 --> 00:10:15.650
We used that notation
earlier already.

00:10:15.650 --> 00:10:19.250
Notice that the increment in
displacement from time t to

00:10:19.250 --> 00:10:25.010
time t plus delta t is u,
shown here in green.

00:10:25.010 --> 00:10:29.110
Notice that the increment in the
load from time t to time t

00:10:29.110 --> 00:10:32.660
plus delta t is, of course,
given by the change in this

00:10:32.660 --> 00:10:34.920
load factor here.

00:10:34.920 --> 00:10:37.200
And that change in the load
factor is lambda.

00:10:40.560 --> 00:10:46.310
Now, this lambda value is also
given in this equation here.

00:10:46.310 --> 00:10:47.580
It's buried in there.

00:10:47.580 --> 00:10:51.380
Notice this lambda of i here.

00:10:51.380 --> 00:10:54.700
We are writing it as a sum all
of delta lambda k's We will

00:10:54.700 --> 00:11:01.300
solve for all these delta lambda
k's And this lambda i,

00:11:01.300 --> 00:11:05.940
when i becomes very large,
converges to the lambda that I

00:11:05.940 --> 00:11:07.670
have up here.

00:11:07.670 --> 00:11:11.660
Similarly, this ui which is
written as the sum of the

00:11:11.660 --> 00:11:17.930
delta uk's this ui converges
to the u

00:11:17.930 --> 00:11:19.890
that I'm showing here.

00:11:19.890 --> 00:11:25.730
So, u and lambda, shown in
green here, are the exact

00:11:25.730 --> 00:11:29.270
values, the values that you
want to converge to with

00:11:29.270 --> 00:11:32.560
lambda i and ui.

00:11:32.560 --> 00:11:36.150
Notice once again, delta lambda
k, summing all these

00:11:36.150 --> 00:11:39.640
delta lambda k's up we get
lambda i, and summing all the

00:11:39.640 --> 00:11:42.050
delta uk's up, we get ui.

00:11:42.050 --> 00:11:45.520
We should keep that in mind for
the discussion that you

00:11:45.520 --> 00:11:47.870
want to go through just now.

00:11:47.870 --> 00:11:52.090
The governing equations
are now as follows.

00:11:52.090 --> 00:11:55.420
On the left hand side we have
a tension stiffness matrix.

00:11:55.420 --> 00:11:57.890
In the modified Newton iteration
we would have tau

00:11:57.890 --> 00:11:59.670
equal to t.

00:11:59.670 --> 00:12:02.500
Delta ui is our displacement
increment vector.

00:12:02.500 --> 00:12:05.680
This is here, this
scaler, t plus

00:12:05.680 --> 00:12:10.270
delta t lambda i, unknown.

00:12:10.270 --> 00:12:12.460
This one we know.

00:12:12.460 --> 00:12:15.960
And that one we want to
calculate in the iteration i.

00:12:15.960 --> 00:12:18.740
In other words, this is an
increment that is unknown at

00:12:18.740 --> 00:12:20.940
the beginning of
the iteration.

00:12:20.940 --> 00:12:24.060
Here we have the nodal point
force vector corresponding to

00:12:24.060 --> 00:12:27.510
the elements stresses at time t
plus delta t, and at the end

00:12:27.510 --> 00:12:29.970
of iteration i minus 1.

00:12:29.970 --> 00:12:34.240
Notice that this is a set of
linear equations in the

00:12:34.240 --> 00:12:37.680
unknowns that are used.

00:12:37.680 --> 00:12:42.030
There are n such unknowns, and
there's one more unknown here.

00:12:42.030 --> 00:12:46.410
So, we have n equations
in n, plus 1 unknowns.

00:12:46.410 --> 00:12:48.080
We need, therefore,
one more equation.

00:12:48.080 --> 00:12:52.655
And that equation is given by
this constraint equation.

00:12:52.655 --> 00:12:59.300
The f here on delta lambda and
delta u, some constraint

00:12:59.300 --> 00:13:02.650
equation here, gives us the
additional equation that we

00:13:02.650 --> 00:13:07.380
need for the solution these n
plus 1 coupled equations.

00:13:07.380 --> 00:13:10.780
The unknowns, of course,
are these values here--

00:13:10.780 --> 00:13:13.630
n plus 1 unknowns.

00:13:13.630 --> 00:13:18.320
To solve these equilibrium
equations, we can rewrite them

00:13:18.320 --> 00:13:19.570
as shown here.

00:13:21.850 --> 00:13:25.660
In other words, the equations
on the finite element

00:13:25.660 --> 00:13:29.550
displacements can be split up,
if you look at the previous

00:13:29.550 --> 00:13:33.150
view graph, directly
into two sets of

00:13:33.150 --> 00:13:35.240
equations as shown here.

00:13:35.240 --> 00:13:40.280
The interesting point is that,
this equation here does not

00:13:40.280 --> 00:13:42.780
involve a delta lambda.

00:13:42.780 --> 00:13:47.380
This equation here does not
involve a delta lambda either.

00:13:47.380 --> 00:13:51.260
Now, having calculated from this
equation this vector, and

00:13:51.260 --> 00:13:55.240
from that equation that vector,
we can directly write

00:13:55.240 --> 00:13:59.240
delta u, as shown here, of
course, now involving the

00:13:59.240 --> 00:14:01.550
delta lambda.

00:14:01.550 --> 00:14:06.060
And this is a form of equation
for delta u that we will be

00:14:06.060 --> 00:14:10.150
using a little later.

00:14:10.150 --> 00:14:14.710
And the first constraint
equation I'd like to introduce

00:14:14.710 --> 00:14:18.250
you to, the one that I briefly
mentioned earlier already,

00:14:18.250 --> 00:14:22.430
where we talked about an arc
which is used to swing the

00:14:22.430 --> 00:14:27.300
load level around, so as to get
to the low displacement

00:14:27.300 --> 00:14:31.500
curve very quickly, and that
constraint equation is this

00:14:31.500 --> 00:14:35.290
spherical constant arc-length
criterion,

00:14:35.290 --> 00:14:37.030
which is written here.

00:14:37.030 --> 00:14:42.060
Notice here lambda i, here ui.

00:14:42.060 --> 00:14:45.600
Of course both of these
quantities create, in essence,

00:14:45.600 --> 00:14:48.640
beta factor and delta
l squared.

00:14:48.640 --> 00:14:56.760
Delta l is set at the beginning
of the load step.

00:14:56.760 --> 00:14:58.890
Delta l, in other words,
is constant

00:14:58.890 --> 00:15:00.640
throughout the load step.

00:15:00.640 --> 00:15:03.670
The value of delta l is chosen
based on what has happened in

00:15:03.670 --> 00:15:05.670
the previous load steps.

00:15:05.670 --> 00:15:10.410
Having chosen delta l, you can
calculate the right hand side,

00:15:10.410 --> 00:15:14.450
and on the left hand side, we
have a constraint between the

00:15:14.450 --> 00:15:19.340
increment in lambda, and the
increment in delta u.

00:15:19.340 --> 00:15:23.990
Remember, lambda I is the sum of
all of the delta lambda k's

00:15:23.990 --> 00:15:28.180
and ui is the sum of all of the
delta uk's I just showed

00:15:28.180 --> 00:15:30.170
that on the previous
view graph.

00:15:30.170 --> 00:15:33.820
Therefore, if we substitute
here, we get a constraint

00:15:33.820 --> 00:15:39.560
equation between the delta uk,
and the delta lambda k.

00:15:39.560 --> 00:15:43.490
Well, here we have the
definitions once more.

00:15:43.490 --> 00:15:48.780
Notice beta is a normalizing
factor which is applied in

00:15:48.780 --> 00:15:50.840
order to make these terms
here dimensionless.

00:15:54.540 --> 00:15:57.490
The equation may be
solved as follows.

00:15:57.490 --> 00:16:02.380
Using that lambda is equal
to this equation here.

00:16:02.380 --> 00:16:05.940
ui is given as that.

00:16:05.940 --> 00:16:09.370
Of course, this here can be
expanded using the information

00:16:09.370 --> 00:16:12.000
that we discussed earlier.

00:16:12.000 --> 00:16:15.640
And substituting for this value
and that value into the

00:16:15.640 --> 00:16:18.710
constraint equation, we directly
obtain a quadratic

00:16:18.710 --> 00:16:23.400
equation in delta lambda i
Remember that these two

00:16:23.400 --> 00:16:28.540
vectors here are, of
course, known.

00:16:28.540 --> 00:16:31.110
These two vectors are known,
and that one is known also,

00:16:31.110 --> 00:16:33.980
because that was established
in the previous iteration.

00:16:37.150 --> 00:16:44.460
If we geometrically interpret
this solution scheme, we find

00:16:44.460 --> 00:16:45.390
the following.

00:16:45.390 --> 00:16:47.390
Here we have our equilibrium
point.

00:16:47.390 --> 00:16:50.670
Here is delta lambda, which
is constant throughout the

00:16:50.670 --> 00:16:52.430
solution step.

00:16:52.430 --> 00:16:54.865
And let's assume the
use of modified

00:16:54.865 --> 00:16:57.330
Newton-Raphson iteration.

00:16:57.330 --> 00:17:02.260
We start off with this tangent
here at this solution point,

00:17:02.260 --> 00:17:08.420
the equilibrium point, and we
iterate around this arc using

00:17:08.420 --> 00:17:14.630
the constant stiffness matrix
at each of these points.

00:17:14.630 --> 00:17:19.740
In the first iteration,
we get to this point.

00:17:19.740 --> 00:17:21.359
Second iteration, that point.

00:17:21.359 --> 00:17:22.920
Third iteration, that point.

00:17:22.920 --> 00:17:27.109
And that signified also
looking here to the

00:17:27.109 --> 00:17:28.060
displacements.

00:17:28.060 --> 00:17:32.010
Notice t plus delta t u1 is
the displacement value

00:17:32.010 --> 00:17:35.210
calculated in the
first iteration.

00:17:35.210 --> 00:17:38.030
This is the one calculated
in the second iteration.

00:17:38.030 --> 00:17:41.820
That is the one calculated
in the third iteration.

00:17:41.820 --> 00:17:44.220
We use a constant stiffness
matrix here.

00:17:44.220 --> 00:17:47.660
Of course, we could also change
the stiffness matrix,

00:17:47.660 --> 00:17:51.290
go in other words, to a
stiffness matrix that has been

00:17:51.290 --> 00:17:55.230
updated in the iteration
corresponding to the current

00:17:55.230 --> 00:17:57.970
stress and displacement
conditions, and then

00:17:57.970 --> 00:18:00.110
convergence would
be more rapid.

00:18:00.110 --> 00:18:03.090
But of course there would also
be a higher cost involved,

00:18:03.090 --> 00:18:05.590
because whenever we calculate
with a new stiffness matrix,

00:18:05.590 --> 00:18:07.780
and we triangularize that
stiffness matrix, there's a

00:18:07.780 --> 00:18:10.880
considerable cost involved
in doing so.

00:18:10.880 --> 00:18:14.080
This is one scheme, and we
find this scheme quite

00:18:14.080 --> 00:18:19.300
effective, except that when we
want to calculate limit loads,

00:18:19.300 --> 00:18:23.330
we find that near the limit load
the scheme can require

00:18:23.330 --> 00:18:24.860
quite a number of iterations.

00:18:24.860 --> 00:18:27.430
And so, we have been looking for
other schemes that might

00:18:27.430 --> 00:18:31.140
do better in the range
of the limit load.

00:18:31.140 --> 00:18:35.960
Well, here we have one other
scheme, namely the "constant"

00:18:35.960 --> 00:18:39.320
increment of external
work criterion.

00:18:39.320 --> 00:18:42.700
We have here quotes on the
constant, because we are

00:18:42.700 --> 00:18:47.860
setting w on the right hand side
in the first iteration,

00:18:47.860 --> 00:18:51.410
as shown here, and in the
next iteration then,

00:18:51.410 --> 00:18:53.100
we have a zero here.

00:18:53.100 --> 00:19:00.040
Notice w is a value that is
calculated in each load step,

00:19:00.040 --> 00:19:05.890
and as soon as we find that
the first scheme-- and

00:19:05.890 --> 00:19:09.740
obviously, constant arc lengths
criterion scheme--

00:19:09.740 --> 00:19:13.800
has difficulties converging, or
marches too slow, then we

00:19:13.800 --> 00:19:16.370
switch to this "constant"
increment of external work

00:19:16.370 --> 00:19:21.160
criterion, with a w from the
previous step, the increment

00:19:21.160 --> 00:19:24.200
of external work from
the previous step.

00:19:24.200 --> 00:19:28.620
We use that for the current
step, and then this equation

00:19:28.620 --> 00:19:32.290
here gives us a constraint
on delta lambda 1.

00:19:32.290 --> 00:19:37.430
Notice that this equation here
means really that we are

00:19:37.430 --> 00:19:44.390
looking at is this area here,
the shaded area, being w, and

00:19:44.390 --> 00:19:49.130
we want to have the delta lambda
1 in such a way that

00:19:49.130 --> 00:19:55.360
this shaded area w here is equal
to what we have had as

00:19:55.360 --> 00:20:00.400
the increment of external work
in the previous load step.

00:20:00.400 --> 00:20:05.010
Well, this gives us delta
lambda (1), and having

00:20:05.010 --> 00:20:09.930
obtained delta lambda (1),
we can go into the next

00:20:09.930 --> 00:20:15.440
iterations, 2 to 3, and so on
for i, and as I mentioned

00:20:15.440 --> 00:20:18.940
already earlier, we then have a
zero on the right hand side.

00:20:18.940 --> 00:20:21.670
Otherwise the same
left hand side.

00:20:21.670 --> 00:20:25.230
And this left hand side
has now two solutions.

00:20:25.230 --> 00:20:30.330
This solution here is
disregarded, because this

00:20:30.330 --> 00:20:34.380
solution would reverse the
direction of the load, and we

00:20:34.380 --> 00:20:35.790
don't want to admit that.

00:20:35.790 --> 00:20:39.930
We want to basically have the
load increase more and more

00:20:39.930 --> 00:20:42.830
until the total collapse of the
structure is reached, and

00:20:42.830 --> 00:20:45.980
then of course it may decrease
to go into the post-buckling

00:20:45.980 --> 00:20:47.960
response, but we don't want
to have the load totally

00:20:47.960 --> 00:20:52.780
reversed, and so this is a
solution that we now use for

00:20:52.780 --> 00:20:55.370
delta lambda (i).

00:20:55.370 --> 00:21:00.120
Notice that for a single degree
of freedom system, we

00:21:00.120 --> 00:21:04.390
would immediately find that
delta u (2) must be zero.

00:21:04.390 --> 00:21:04.730
Why?

00:21:04.730 --> 00:21:08.270
Because we notice that the load
vector is orthogonal to

00:21:08.270 --> 00:21:09.990
the displacement vector.

00:21:09.990 --> 00:21:12.450
Now, for a single degree of
freedom system, of course,

00:21:12.450 --> 00:21:19.230
each of these are just numbers,
and since the r is

00:21:19.230 --> 00:21:22.330
not zero, because that is of
course a prescribed value

00:21:22.330 --> 00:21:25.890
prior to the analysis, this
is not zero, delta

00:21:25.890 --> 00:21:28.340
u (2) must be zero.

00:21:28.340 --> 00:21:31.740
And that shows already the
effectiveness, just show it a

00:21:31.740 --> 00:21:33.845
bit, of this algorithm.

00:21:36.690 --> 00:21:40.310
All the algorithm altogether
is now as follows.

00:21:40.310 --> 00:21:43.060
We specify r.

00:21:43.060 --> 00:21:47.520
In other words, the analyst
has to specify the load

00:21:47.520 --> 00:21:52.210
distribution, concentrated
loads, distributed loads, that

00:21:52.210 --> 00:21:56.620
shall be dealt with in this
collapse analysis, and also

00:21:56.620 --> 00:22:00.850
the displacement at one degree
of freedom corresponding to

00:22:00.850 --> 00:22:02.730
delta t lambda.

00:22:02.730 --> 00:22:07.120
This is done to just start
the algorithm.

00:22:07.120 --> 00:22:12.160
Once the analyst has specified
the displacement at one degree

00:22:12.160 --> 00:22:17.900
of freedom, the program can
solve for delta tu--

00:22:17.900 --> 00:22:20.680
in other words, all the
other displacements--

00:22:20.680 --> 00:22:25.470
and this delta tu corresponds
to delta t lambda.

00:22:25.470 --> 00:22:29.750
We feel that to start the
algorithm it is easier for the

00:22:29.750 --> 00:22:34.500
analyst to prescribe the
displacement at one node

00:22:34.500 --> 00:22:39.290
corresponding to delta
t lambda--

00:22:39.290 --> 00:22:43.440
Rather, to prescribe this
displacement than to prescribe

00:22:43.440 --> 00:22:47.170
the first load level, because
if you don't have much of an

00:22:47.170 --> 00:22:50.600
idea how the structure really
behaves, it can be very

00:22:50.600 --> 00:22:54.500
difficult to give a load level
that is reasonable, and is not

00:22:54.500 --> 00:22:57.040
too close to the ultimate limit
load, or is already

00:22:57.040 --> 00:22:59.040
perhaps even beyond the
ultimate limit load.

00:22:59.040 --> 00:23:03.980
So we feel that this is
a good way to proceed.

00:23:03.980 --> 00:23:07.600
For example, if you analyze the
collapse of a shell, you

00:23:07.600 --> 00:23:12.130
may want to pick a node that
you know will have non-zero

00:23:12.130 --> 00:23:17.510
displacement and assign at that
node a displacement, say,

00:23:17.510 --> 00:23:20.250
one third of the thickness
of the shell.

00:23:20.250 --> 00:23:23.070
That displacement then would
give you delta t lambda, and

00:23:23.070 --> 00:23:26.320
surely would be less
than the ultimate

00:23:26.320 --> 00:23:28.860
limit load of the shell.

00:23:28.860 --> 00:23:32.020
This means, once you have solved
for delta t lambda and

00:23:32.020 --> 00:23:35.620
delta tu, we can set delta l.

00:23:35.620 --> 00:23:38.260
The arc lengths for the
next load steps.

00:23:38.260 --> 00:23:40.475
And now the program does
everything automatically.

00:23:40.475 --> 00:23:46.730
It selects the increment in
displacements and loads using

00:23:46.730 --> 00:23:50.340
this arc-lengths criterion
that we just discussed.

00:23:50.340 --> 00:23:53.880
We use 1, which is the
arc-lengths criterion, for the

00:23:53.880 --> 00:23:55.280
next load steps.

00:23:55.280 --> 00:24:00.280
We calculate w for
each load step.

00:24:00.280 --> 00:24:03.480
When w does not change
appreciably, or when there are

00:24:03.480 --> 00:24:06.830
difficulties with the
arc-lengths criterion, with 1,

00:24:06.830 --> 00:24:10.310
in other words, then we switch
to our constant increment and

00:24:10.310 --> 00:24:11.640
external work criterion.

00:24:11.640 --> 00:24:13.680
We call that the 2 criterion.

00:24:16.490 --> 00:24:21.820
Once again, notice that delta
l is calculated in each load

00:24:21.820 --> 00:24:28.380
step, and it is adjusted based
on the number of iterations

00:24:28.380 --> 00:24:32.870
that we have been using in
the previous load steps.

00:24:32.870 --> 00:24:38.390
In other words, if you go, say,
up to load step three,

00:24:38.390 --> 00:24:41.860
and you have, say, obtained
a solution up to load step

00:24:41.860 --> 00:24:48.830
three, the program has used a
certain delta in load step

00:24:48.830 --> 00:24:52.310
three, and now the program
looks at the number of

00:24:52.310 --> 00:24:55.980
iterations that were performed
to get to the equilibrium

00:24:55.980 --> 00:24:59.020
position at the end of
load steps three.

00:24:59.020 --> 00:25:02.420
Based on these number of
iterations, the program then

00:25:02.420 --> 00:25:08.200
cuts delta l down, or makes
delta l larger, depending on

00:25:08.200 --> 00:25:11.580
whether the iterations were very
many that you used, or

00:25:11.580 --> 00:25:15.110
were very few to get to the
equilibrium configuration at

00:25:15.110 --> 00:25:16.900
load step three.

00:25:16.900 --> 00:25:20.430
So, the a program automatically
adjusts delta l.

00:25:20.430 --> 00:25:24.660
Also notice that the stiffness
matrix is recalculated when

00:25:24.660 --> 00:25:26.860
convergence is slow.

00:25:26.860 --> 00:25:30.320
In fact, a full Newton-Raphson
iteration is performed

00:25:30.320 --> 00:25:34.050
automatically, the program
switched automatically from

00:25:34.050 --> 00:25:35.810
the modified Newton-Raphson
iteration to the full

00:25:35.810 --> 00:25:38.220
Newton-Raphson iteration
when it is

00:25:38.220 --> 00:25:41.090
deemed to be more effective.

00:25:41.090 --> 00:25:45.250
This is the automatic load
incrementation scheme that I

00:25:45.250 --> 00:25:47.220
wanted to discuss with you.

00:25:47.220 --> 00:25:51.210
And I'd now like to go over
to one other topic, a very

00:25:51.210 --> 00:25:54.680
important topic as well in the
analysis of the nonlinear

00:25:54.680 --> 00:25:58.900
response of structures, and
this is the linearized

00:25:58.900 --> 00:26:01.390
buckling analysis.

00:26:01.390 --> 00:26:07.170
In the linearized buckling
analysis, we want to predict a

00:26:07.170 --> 00:26:11.930
collapse load, the buckling load
of the structure via this

00:26:11.930 --> 00:26:14.740
criterion here.

00:26:14.740 --> 00:26:19.590
The determinant we know at
the collapse point of the

00:26:19.590 --> 00:26:23.600
stiffness matrix is zero.

00:26:23.600 --> 00:26:25.400
The matrix is, another
words, singular.

00:26:28.050 --> 00:26:34.770
The criterion that we use here
determined of k is equal to

00:26:34.770 --> 00:26:38.390
zero, of course, means
once again

00:26:38.390 --> 00:26:39.940
the k matrix is singular.

00:26:39.940 --> 00:26:44.440
And that means that we really
have a solution to this set of

00:26:44.440 --> 00:26:46.880
equations that is nontrivial.

00:26:46.880 --> 00:26:49.120
The trivial solution, of course,
would always be u star

00:26:49.120 --> 00:26:53.010
is equal to zero, but that is
not a real solution that we're

00:26:53.010 --> 00:26:54.620
interested in.

00:26:54.620 --> 00:27:00.870
A solution, a nontrivial
solution exists to this set of

00:27:00.870 --> 00:27:04.450
equations only in the case
when tau k is singular.

00:27:04.450 --> 00:27:07.330
And, of course, that is the
same as saying that the

00:27:07.330 --> 00:27:12.810
determined of k, tau
k is equal to zero.

00:27:12.810 --> 00:27:19.470
If tau k is singular the
structure is unstable, and the

00:27:19.470 --> 00:27:26.660
collapse load situation
has been reached.

00:27:26.660 --> 00:27:29.970
Let's look at what this
means physically.

00:27:29.970 --> 00:27:31.360
If we have here a beam.

00:27:31.360 --> 00:27:34.890
If we look at a beam, pinned
at this end, pinned at that

00:27:34.890 --> 00:27:39.710
end, subjected to a certain
load, then if the load takes

00:27:39.710 --> 00:27:44.930
on a certain value, the smallest
imbalance of the

00:27:44.930 --> 00:27:49.830
load, a very small load this
way, would immediately result

00:27:49.830 --> 00:27:51.870
in very large displacements.

00:27:51.870 --> 00:27:55.790
That's what the buckling
criterion tells us.

00:27:55.790 --> 00:28:01.640
In other words, at tau r, the
buckling load, the structure

00:28:01.640 --> 00:28:06.650
is unstable to any smallest
load imbalance.

00:28:06.650 --> 00:28:09.890
Of course, the material data for
the structure are given.

00:28:09.890 --> 00:28:12.410
And in this particular
case, we use the data

00:28:12.410 --> 00:28:15.490
of an elastic beam.

00:28:15.490 --> 00:28:18.460
In the linearized buckling
analysis we want to predict

00:28:18.460 --> 00:28:23.110
the load level, and the
buckling load shape

00:28:23.110 --> 00:28:30.420
corresponding to the buckling
situation, by linearizing

00:28:30.420 --> 00:28:33.860
about a particular configuration
that is not

00:28:33.860 --> 00:28:38.010
necessarily very close to
the buckling load level.

00:28:38.010 --> 00:28:42.340
In fact, we assume that tau k is
given via this relationship

00:28:42.340 --> 00:28:46.520
here, and tau r is given
via this relationship.

00:28:46.520 --> 00:28:53.040
Notice here t minus delta tk and
tk are known values, known

00:28:53.040 --> 00:28:56.960
stiffness matrices, and
similarly, this load vector,

00:28:56.960 --> 00:29:00.920
and that load vector, and that
one, are known values.

00:29:00.920 --> 00:29:02.750
Lambda is a scaler.

00:29:02.750 --> 00:29:05.220
So basically, what we are trying
to do in the linearized

00:29:05.220 --> 00:29:09.510
buckling analysis is to
linearize about the

00:29:09.510 --> 00:29:14.190
configuration, not necessarily
very close to the collapse

00:29:14.190 --> 00:29:19.990
load configuration, and
establish with this linearized

00:29:19.990 --> 00:29:27.270
relationship an equation from
which we can calculate an

00:29:27.270 --> 00:29:35.410
increment in load that gives
us an approximation to the

00:29:35.410 --> 00:29:38.160
actual collapse load.

00:29:38.160 --> 00:29:41.750
Pictorially, we are
doing this here.

00:29:41.750 --> 00:29:46.520
We have here the load
displacement curve in red.

00:29:46.520 --> 00:29:51.390
We have at displacement
t minus delta

00:29:51.390 --> 00:29:54.440
tu, this load level.

00:29:54.440 --> 00:29:59.090
At displacement tu we have
that load level.

00:29:59.090 --> 00:30:04.360
And if you linearize about these
configurations here,

00:30:04.360 --> 00:30:07.130
using the stiffness matrices
corresponding to these two

00:30:07.130 --> 00:30:13.510
load levels, we can predict a
collapse load, which because

00:30:13.510 --> 00:30:17.500
of this linearization is, of
course, not exactly the

00:30:17.500 --> 00:30:20.990
collapse load, but we hope
that we are close to that

00:30:20.990 --> 00:30:22.240
actual collapse load.

00:30:24.970 --> 00:30:28.430
Pictorially here, we
do the following.

00:30:28.430 --> 00:30:33.500
Notice here we have the
k plotted and the

00:30:33.500 --> 00:30:36.070
lambda value plotted.

00:30:36.070 --> 00:30:37.890
Along this axis.

00:30:37.890 --> 00:30:43.010
At a particular value,
lambda equal to 1, we

00:30:43.010 --> 00:30:44.870
would have this point.

00:30:44.870 --> 00:30:48.250
Now let's look first along
this axis here.

00:30:48.250 --> 00:30:50.170
Here we have tk.

00:30:50.170 --> 00:30:52.710
Here we have t minus delta tk.

00:30:52.710 --> 00:30:56.260
Notice tk is smaller than
t minus delta tk.

00:30:56.260 --> 00:30:58.640
We are looking here, of course,
at a single degree of

00:30:58.640 --> 00:31:00.220
freedom case again.

00:31:00.220 --> 00:31:02.980
This means that the structure
becomes softer, we are getting

00:31:02.980 --> 00:31:06.730
closer to the collapse load.

00:31:06.730 --> 00:31:09.910
In our linearized buckling
analysis we put really through

00:31:09.910 --> 00:31:15.070
this point and that point
a straight line.

00:31:15.070 --> 00:31:20.560
That projects us to a point,
lambda 1, at which tau k is

00:31:20.560 --> 00:31:23.740
equal to zero.

00:31:23.740 --> 00:31:26.800
Corresponding to what we're
doing here with the stiffness

00:31:26.800 --> 00:31:30.570
matrix, we have here also
picture for the loads.

00:31:30.570 --> 00:31:37.500
Notice t minus delta tr here, tr
there, and a straight line

00:31:37.500 --> 00:31:40.670
through it brings
us up to tau r.

00:31:40.670 --> 00:31:43.750
Tau r is the collapse load.

00:31:43.750 --> 00:31:47.490
Tau r is the collapse load,
linearized collapse load,

00:31:47.490 --> 00:31:52.290
corresponding to the value
that we have here

00:31:52.290 --> 00:31:53.910
obtained for lambda 1.

00:31:56.690 --> 00:32:00.930
The problem of solving for
lambda such that the

00:32:00.930 --> 00:32:06.610
determinant of tau k is zero is
really nothing else than an

00:32:06.610 --> 00:32:07.690
eigenproblem.

00:32:07.690 --> 00:32:12.060
And the eigenproblem that we
have to consider there is

00:32:12.060 --> 00:32:13.560
written down here.

00:32:13.560 --> 00:32:17.970
Notice phi is an eigenvector,
lambda is the eigenvalue--

00:32:17.970 --> 00:32:20.400
unknown at this point--

00:32:20.400 --> 00:32:28.080
and here we have a difference in
matrices that we know, and

00:32:28.080 --> 00:32:29.950
once again the eigenvector.

00:32:29.950 --> 00:32:31.740
Notice one interesting point.

00:32:31.740 --> 00:32:35.590
That to establish this
difference in matrix, all you

00:32:35.590 --> 00:32:38.520
need to do in the computer
program is to store the

00:32:38.520 --> 00:32:42.630
previous difference matrix, and
subtract from the previous

00:32:42.630 --> 00:32:45.750
difference matrix corresponding
to load step t

00:32:45.750 --> 00:32:49.220
minus delta t, the current
difference matrix.

00:32:49.220 --> 00:32:55.550
This is interesting to note that
because we don't need to

00:32:55.550 --> 00:32:57.740
separate out element difference
matrices.

00:32:57.740 --> 00:33:00.710
We don't need to talk about
nonlinear strain stiffness

00:33:00.710 --> 00:33:03.670
matrices coming from the
elements, and linear strain

00:33:03.670 --> 00:33:06.410
stiffness matrices coming
from the elements.

00:33:06.410 --> 00:33:10.300
We talked about, of course,
these particular element

00:33:10.300 --> 00:33:12.870
stiffness matrices in
previous lectures.

00:33:12.870 --> 00:33:16.160
We don't separate
any out here.

00:33:16.160 --> 00:33:19.390
In fact, what we're doing,
we simply take all of the

00:33:19.390 --> 00:33:23.110
contributions from the elements
into account here,

00:33:23.110 --> 00:33:26.180
and all of the contribution
towards element into account

00:33:26.180 --> 00:33:30.070
here, of course corresponding to
time t minus delta t here,

00:33:30.070 --> 00:33:33.280
and corresponding
to time t here.

00:33:33.280 --> 00:33:35.440
This therefore, is a very
simple operation in the

00:33:35.440 --> 00:33:36.690
computer program.

00:33:38.870 --> 00:33:44.380
And having established this
eigenvalue problem, we can

00:33:44.380 --> 00:33:48.990
schematically look at the
eigenvalues that would become

00:33:48.990 --> 00:33:50.610
calculated.

00:33:50.610 --> 00:33:54.320
Here we have some positive
eigenvalues indicated, and

00:33:54.320 --> 00:33:57.710
here we have some negative
eigenvalues indicated.

00:33:57.710 --> 00:34:00.930
Notice that there's a
possibility of negative

00:34:00.930 --> 00:34:03.450
eigenvalues as well.

00:34:03.450 --> 00:34:07.360
A physical problem that shows
how you can get a negative

00:34:07.360 --> 00:34:10.500
eigenvalue is shown in
this view graph.

00:34:10.500 --> 00:34:13.800
Here you have a structure, a
frame structure, so to say,

00:34:13.800 --> 00:34:15.960
that is subjected to
a compressive load

00:34:15.960 --> 00:34:17.739
and a tensile load.

00:34:17.739 --> 00:34:21.330
Now, notice that this
compressive load would of

00:34:21.330 --> 00:34:24.230
course initiate buckling here,
and there would be a

00:34:24.230 --> 00:34:26.690
corresponding to a positive
eigenvalue.

00:34:26.690 --> 00:34:30.239
However, this tensile load has
to reverse its sign in order

00:34:30.239 --> 00:34:34.060
for this member to buckle, and
that would correspond then to

00:34:34.060 --> 00:34:36.360
a negative eigenvalue.

00:34:36.360 --> 00:34:40.030
Now when we try to solve
eigenvalue problems that have

00:34:40.030 --> 00:34:43.360
negative and positive
eigenvalues, there can be

00:34:43.360 --> 00:34:46.280
difficulties with the eigenvalue
solution method

00:34:46.280 --> 00:34:47.320
that you're using.

00:34:47.320 --> 00:34:51.230
It is easier for a solution
method to simply deal with

00:34:51.230 --> 00:34:53.330
eigenvalues that are
only positive.

00:34:53.330 --> 00:34:58.360
And for that reason we are
reformulating the basic

00:34:58.360 --> 00:35:02.770
eigenvalue equation
into this form.

00:35:02.770 --> 00:35:06.560
Here you have now the eigenvalue
problem simply

00:35:06.560 --> 00:35:13.240
rewritten, really, with gamma
being the eigenvalue, and phi

00:35:13.240 --> 00:35:16.350
still being the eigenvector,
gamma of course, being a

00:35:16.350 --> 00:35:19.580
function of lambda.

00:35:19.580 --> 00:35:25.260
With this eigenvalue problem
then, we have only positive

00:35:25.260 --> 00:35:30.090
eigenvalues on gamma, of course,
and we are interested

00:35:30.090 --> 00:35:33.960
in finding the smallest
gamma value.

00:35:33.960 --> 00:35:36.450
Because the smallest gamma
value corresponds to the

00:35:36.450 --> 00:35:40.330
smallest lambda 1
positive value.

00:35:40.330 --> 00:35:43.900
And of course, sometimes you
also want to calculate gamma 2

00:35:43.900 --> 00:35:49.100
corresponding to the second
smallest positive lambda

00:35:49.100 --> 00:35:50.900
value, and so on.

00:35:50.900 --> 00:35:53.540
The negative lambda values
lie over here.

00:35:56.960 --> 00:36:00.650
The value of the linearized
buckling analysis can be

00:36:00.650 --> 00:36:02.400
summarized as follows.

00:36:02.400 --> 00:36:05.680
The buckling analysis is
not very expensive.

00:36:05.680 --> 00:36:10.340
It gives insight into possible
modes of failure.

00:36:10.340 --> 00:36:13.730
For applicability, however, the
pre-buckling displacements

00:36:13.730 --> 00:36:16.830
should be small.

00:36:16.830 --> 00:36:21.060
And very important it is that
the buckling analysis yields

00:36:21.060 --> 00:36:25.300
modes, buckling mode shapes,
that can be very effectively

00:36:25.300 --> 00:36:30.460
used to impose imperfections
onto a structure and to study

00:36:30.460 --> 00:36:33.970
the sensitivity of the structure
to imperfections.

00:36:33.970 --> 00:36:37.440
Many structures are very
sensitive, particularly shell

00:36:37.440 --> 00:36:40.350
structures, are very sensitive
to initial imperfections in

00:36:40.350 --> 00:36:44.620
the geometry, and this
linearized buckling analysis

00:36:44.620 --> 00:36:49.220
gives us the mechanisms and
means to calculate mode shapes

00:36:49.220 --> 00:36:52.580
that we can impose onto the
perfect structure as a

00:36:52.580 --> 00:36:56.010
geometric imperfection, onto
the geometry of the perfect

00:36:56.010 --> 00:37:00.420
structure, to study then the
behavior of the structure

00:37:00.420 --> 00:37:04.480
subject to these
imperfections.

00:37:04.480 --> 00:37:10.550
But it is very important that
the procedure be only employed

00:37:10.550 --> 00:37:14.100
with great care, because the
results can be quite

00:37:14.100 --> 00:37:14.840
misleading.

00:37:14.840 --> 00:37:17.280
The buckling loads that you
might calculate in the

00:37:17.280 --> 00:37:20.440
linearized buckling analysis,
these buckling loads may be

00:37:20.440 --> 00:37:24.490
way higher than the actual
buckling loads that you should

00:37:24.490 --> 00:37:26.330
be using in your design.

00:37:26.330 --> 00:37:30.560
And we will actually show some
examples in the next lecture

00:37:30.560 --> 00:37:35.020
pertaining to this particular
problem here.

00:37:35.020 --> 00:37:38.840
And one should always keep in
mind that the procedure really

00:37:38.840 --> 00:37:43.120
predicts only physically
realistic buckling loads when

00:37:43.120 --> 00:37:46.910
we have structures that
behave close to the

00:37:46.910 --> 00:37:48.460
Euler column type.

00:37:48.460 --> 00:37:53.150
In other words, that buckle
with very small initial

00:37:53.150 --> 00:37:57.640
displacements, or pre-buckling
displacements, I should say.

00:37:57.640 --> 00:37:59.930
Let's look at an example.

00:37:59.930 --> 00:38:03.930
Here we have the example
of an arch

00:38:03.930 --> 00:38:07.540
subjected to uniform pressure.

00:38:07.540 --> 00:38:11.050
The geometric data of the
arch are given here.

00:38:11.050 --> 00:38:12.890
The material data are
given as well.

00:38:12.890 --> 00:38:14.890
Notice it's an elastic arch.

00:38:14.890 --> 00:38:21.250
And it's an arch with cross
section b and h here, being

00:38:21.250 --> 00:38:23.680
both equal to 1.

00:38:23.680 --> 00:38:25.970
We also want to consider only
the two-dimensional

00:38:25.970 --> 00:38:27.200
motion of the arch.

00:38:27.200 --> 00:38:28.980
In other words, two-dimensional
action.

00:38:28.980 --> 00:38:33.700
We do not allow out-of-plane
bucking for this arch.

00:38:33.700 --> 00:38:40.240
Now the finite element model
that we select for the arch is

00:38:40.240 --> 00:38:43.800
a model of 10 2-node
isoparametric beam elements.

00:38:43.800 --> 00:38:46.780
We will talk about these
isoparametric beam elements--

00:38:46.780 --> 00:38:49.190
we call them also isobeam
elements--

00:38:49.190 --> 00:38:50.840
in a later lecture.

00:38:50.840 --> 00:38:55.780
And for the two-dimensional
motion of the arch, we model

00:38:55.780 --> 00:38:58.200
the complete arch.

00:38:58.200 --> 00:39:01.810
The purpose of the analysis is
to determine the collapse

00:39:01.810 --> 00:39:05.580
mechanism, the collapse load
level of the structure.

00:39:05.580 --> 00:39:11.250
And not only this particular
part, but we also want to

00:39:11.250 --> 00:39:16.150
calculate the post-collapse
response of the structure.

00:39:16.150 --> 00:39:22.750
Let us now go through the
solution that was performed

00:39:22.750 --> 00:39:24.140
for this arch.

00:39:24.140 --> 00:39:29.180
As a first step we calculated
the linearized buckling loads

00:39:29.180 --> 00:39:30.390
and corresponding mode shapes.

00:39:30.390 --> 00:39:32.480
And we calculated two.

00:39:32.480 --> 00:39:35.620
Interesting to note that the
first mode corresponds to this

00:39:35.620 --> 00:39:42.000
pressure, and it's an
anti-symmetric mode.

00:39:42.000 --> 00:39:48.010
The second buckling mode
shape looks like this.

00:39:48.010 --> 00:39:50.370
It's a symmetric buckling
mode shape.

00:39:50.370 --> 00:39:54.430
Notice that, in other words,
the anti-symmetric buckling

00:39:54.430 --> 00:39:59.660
mode corresponds to a lower
load than the symmetry

00:39:59.660 --> 00:40:02.320
buckling mode shape.

00:40:02.320 --> 00:40:05.350
Having performed the linearized
buckling analysis,

00:40:05.350 --> 00:40:08.580
we next use our automatic load
stepping algorithm to

00:40:08.580 --> 00:40:11.630
calculate the displacement
response of the arch as the

00:40:11.630 --> 00:40:13.000
load increases.

00:40:13.000 --> 00:40:16.630
Here on this view graph, we
have plotted the pressure

00:40:16.630 --> 00:40:19.680
vertically up here, and the
displacement of the center of

00:40:19.680 --> 00:40:21.410
the arch horizontally.

00:40:21.410 --> 00:40:26.790
Notice this black curve here
shows a computed response

00:40:26.790 --> 00:40:30.210
using about 60 steps
in the analysis.

00:40:30.210 --> 00:40:34.060
Notice it is a collapse load, of
course, here, and this is a

00:40:34.060 --> 00:40:36.950
post-collapse response.

00:40:36.950 --> 00:40:40.480
It's interesting to note that
the collapse load predicted

00:40:40.480 --> 00:40:42.950
using the buckling analysis
and linearized buckling

00:40:42.950 --> 00:40:48.240
analysis given by this blue line
lies below this actual

00:40:48.240 --> 00:40:52.600
ultimate load predicted for
using the automatic load

00:40:52.600 --> 00:40:54.870
stepping algorithm.

00:40:54.870 --> 00:40:58.470
And we have to ask ourselves
why is that the case?

00:40:58.470 --> 00:41:05.740
Well, the computed response of
the the perfect symmetry arch

00:41:05.740 --> 00:41:09.900
does not allow the
anti-symmetric displacements

00:41:09.900 --> 00:41:15.130
to take place, and it is the
anti-symmetric displacements

00:41:15.130 --> 00:41:20.550
that, of course, initialize,
so to say, anti-symmetric

00:41:20.550 --> 00:41:22.880
buckling response.

00:41:22.880 --> 00:41:25.910
We have computed the response
of a perfect symmetric arch

00:41:25.910 --> 00:41:31.580
that is subjected to a perfectly
symmetric load, and

00:41:31.580 --> 00:41:36.810
this does not allow the
anti-symmetric buckling mode

00:41:36.810 --> 00:41:39.800
of the arch to come
into effect.

00:41:39.800 --> 00:41:45.020
However, a real structure will
contain imperfections, and

00:41:45.020 --> 00:41:51.990
hence it will go into the
anti-symmetric behavior, and

00:41:51.990 --> 00:41:56.450
the actual collapse load will be
below the one that we have

00:41:56.450 --> 00:41:59.630
predicted in our first analysis
using the automatic

00:41:59.630 --> 00:42:02.180
load stepping algorithm, and
the results of which

00:42:02.180 --> 00:42:05.470
I've just shown you.

00:42:05.470 --> 00:42:09.640
Therefore, to really obtain a
realistic collapse load, we

00:42:09.640 --> 00:42:16.410
have to now impose onto the
perfect symmetry arch a

00:42:16.410 --> 00:42:22.550
geometric imperfection which
allows the anti-symmetric

00:42:22.550 --> 00:42:25.030
behavior to take place.

00:42:25.030 --> 00:42:31.470
And we do so by adding to the
geometry of the arch to the

00:42:31.470 --> 00:42:36.040
nodal point coordinates of the
arch a multiple of the

00:42:36.040 --> 00:42:39.580
anti-symmetric mode shape.

00:42:39.580 --> 00:42:43.400
This collapse mode is scaled
so that the magnitude of

00:42:43.400 --> 00:42:47.600
imperfection is less than 100.

00:42:47.600 --> 00:42:51.240
This resulting imperfect arch
is, of course, no longer

00:42:51.240 --> 00:42:55.830
symmetric, and we now solve for
the response of that arch

00:42:55.830 --> 00:43:00.210
using our automatic load
stepping algorithm again.

00:43:00.210 --> 00:43:03.700
This is the response
that you'll see.

00:43:03.700 --> 00:43:07.280
Pressure and displacement
of the arch.

00:43:07.280 --> 00:43:12.850
Notice this is well below the
linearized buckling analysis

00:43:12.850 --> 00:43:16.420
solution, the blue solution,
that I showed you on the

00:43:16.420 --> 00:43:19.380
earlier response graph.

00:43:19.380 --> 00:43:24.520
And this is here a much more
realistic estimate for the

00:43:24.520 --> 00:43:26.060
collapse load of the arch.

00:43:26.060 --> 00:43:29.270
This is the realistic estimate
that you would be using, for

00:43:29.270 --> 00:43:32.860
example, in the design of
the actual structure.

00:43:32.860 --> 00:43:35.540
It's also interesting to look at
the deflective shape of the

00:43:35.540 --> 00:43:40.390
structure, and here we have the
deflective shape of the

00:43:40.390 --> 00:43:45.400
perfect arch, of being
symmetric at this

00:43:45.400 --> 00:43:47.350
displacement value.

00:43:47.350 --> 00:43:52.430
And here we have a deflective
shape of the imperfect arch at

00:43:52.430 --> 00:43:54.500
this particular displacement
value.

00:43:54.500 --> 00:43:56.750
Of course, this one
is not a totally

00:43:56.750 --> 00:43:59.230
symmetric deflective shape.

00:43:59.230 --> 00:44:02.640
Well, we have discussed now
quite a number of solution

00:44:02.640 --> 00:44:07.290
schemes that we use to solve the
finite element equations

00:44:07.290 --> 00:44:09.160
in static non-linear analysis.

00:44:09.160 --> 00:44:13.100
We have looked in the previous
lecture at some schemes-- the

00:44:13.100 --> 00:44:15.880
full Newton-Raphson method, the
modified Newton-Raphson

00:44:15.880 --> 00:44:19.320
method, the BFGS method, the
initial stress method--

00:44:19.320 --> 00:44:21.535
in which we have to prescribe
the load levels.

00:44:21.535 --> 00:44:26.780
For each load step we have to
prescribe the load level prior

00:44:26.780 --> 00:44:30.570
to the analysis, by the input
of the computer program, and

00:44:30.570 --> 00:44:33.390
in this lecture I have shared
with you some experiences

00:44:33.390 --> 00:44:35.940
regarding an automatic load
stepping scheme regarding

00:44:35.940 --> 00:44:37.960
linearized buckling analysis.

00:44:37.960 --> 00:44:40.560
What we have not done yet,
really, in my opinion is to

00:44:40.560 --> 00:44:43.510
look at enough examples, and
that's what I would like to do

00:44:43.510 --> 00:44:44.630
in the next lecture.

00:44:44.630 --> 00:44:46.300
Thank you very much for
your attention.

