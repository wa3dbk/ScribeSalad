WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:01.800
The following
content is provided

00:00:01.800 --> 00:00:04.040
under a Creative
Commons license.

00:00:04.040 --> 00:00:06.890
Your support will help MIT
OpenCourseWare continue

00:00:06.890 --> 00:00:10.740
to offer high quality
educational resources for free.

00:00:10.740 --> 00:00:13.350
To make a donation or
view additional materials

00:00:13.350 --> 00:00:17.237
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.237 --> 00:00:17.862
at ocw.mit.edu.

00:00:23.170 --> 00:00:25.960
PROFESSOR: I hope you're
all recovered from the quiz.

00:00:25.960 --> 00:00:30.380
Our apologies for
hard questions,

00:00:30.380 --> 00:00:33.570
but it's just the first quiz.

00:00:33.570 --> 00:00:37.535
We have a lot more fun
things to do in 006.

00:00:37.535 --> 00:00:41.230
So today's lecture today's
lecture is a light lecture,

00:00:41.230 --> 00:00:43.720
I would even call it a
recreational mathematics

00:00:43.720 --> 00:00:44.590
lecture.

00:00:44.590 --> 00:00:46.220
And so, thanks for coming.

00:00:46.220 --> 00:00:49.340
I'll make it worth
your while, all right?

00:00:49.340 --> 00:00:51.990
So we're going to talk
about irrationals.

00:00:51.990 --> 00:00:55.250
The motivation behind
this is really that every

00:00:55.250 --> 00:00:59.660
once in awhile we are going
to have a situation where

00:00:59.660 --> 00:01:05.910
we want to compute with numbers
that are much longer than 64

00:01:05.910 --> 00:01:10.000
bits, which is really the word
length in standard computer

00:01:10.000 --> 00:01:10.770
these days.

00:01:10.770 --> 00:01:13.910
It used to be 8 bits
back in the day.

00:01:13.910 --> 00:01:19.070
For most of my adult
life it was 32 bits.

00:01:19.070 --> 00:01:23.320
And recently Intel and AMD
have gone to 64-bit processors.

00:01:23.320 --> 00:01:27.170
But 64 bits ain't
near enough if you

00:01:27.170 --> 00:01:30.910
want to do what's called high
precision computation, you want

00:01:30.910 --> 00:01:34.790
to find precisely the
weight of a neutrino,

00:01:34.790 --> 00:01:37.080
if you're a physicist,
for example.

00:01:37.080 --> 00:01:42.680
And that, you're talking
about literally a hundred

00:01:42.680 --> 00:01:45.020
decimal digits,
which is obviously

00:01:45.020 --> 00:01:46.900
much more than 64 bits.

00:01:46.900 --> 00:01:49.690
And that's just one example.

00:01:49.690 --> 00:01:54.820
So what happens if you want to
compute the square root of 2

00:01:54.820 --> 00:02:00.370
to a million digits, or
pi to 10 million digits?

00:02:00.370 --> 00:02:03.280
How do you do that
on a computer?

00:02:03.280 --> 00:02:06.280
So that's what we're going
to do for this module, which

00:02:06.280 --> 00:02:08.400
is a short module on numerics.

00:02:08.400 --> 00:02:12.900
We'll have a lecture today
and another one on Tuesday

00:02:12.900 --> 00:02:16.420
telling you about techniques
that use, among other things,

00:02:16.420 --> 00:02:21.740
Newton's method to compute
irrational numbers, as one

00:02:21.740 --> 00:02:27.560
example, to arbitrary precision
And for your problem set

00:02:27.560 --> 00:02:31.130
you are you going to look at
different application that

00:02:31.130 --> 00:02:35.210
corresponds to encryption,
RSA encryption,

00:02:35.210 --> 00:02:37.850
where you have to
work with primes.

00:02:37.850 --> 00:02:40.760
These are now integers,
but you work with primes

00:02:40.760 --> 00:02:43.900
that are thousands of
bits long, so again,

00:02:43.900 --> 00:02:46.160
much more than 64 bits.

00:02:46.160 --> 00:02:48.720
And so you have to
think about how you're

00:02:48.720 --> 00:02:50.910
going to multiply numbers
that are thousands of bits

00:02:50.910 --> 00:02:53.368
long, how you're going to divide
numbers that are thousands

00:02:53.368 --> 00:02:57.881
of bits long, and that's really
the purpose of this module.

00:02:57.881 --> 00:02:59.880
So let's start off by
talking about irrationals.

00:03:04.970 --> 00:03:12.440
And Pythagoras, whom I'm
sure you've all heard of

00:03:12.440 --> 00:03:19.740
is credited with the discovery
that a square's diagonal

00:03:19.740 --> 00:03:23.210
and its side are
incommensurable.

00:03:23.210 --> 00:03:29.510
So you can't really express
the ratio as a rational number,

00:03:29.510 --> 00:03:32.160
as a ratio of integers.

00:03:32.160 --> 00:03:34.540
Now it turns out that the
Babylonians and the Indians

00:03:34.540 --> 00:03:37.740
knew this way before
Pythagoras, but he

00:03:37.740 --> 00:03:40.230
gets credit for the
Pythagoras theorem.

00:03:40.230 --> 00:03:43.717
And there's also a
Greek philosopher,

00:03:43.717 --> 00:03:45.800
in fact, maybe he was first
a philosopher and then

00:03:45.800 --> 00:03:51.410
a mathematician, and he
the espoused a philosophy

00:03:51.410 --> 00:03:54.730
that, I guess, is called
Pythagorean mysticism, that

00:03:54.730 --> 00:03:59.730
said that all is number, so
the world is about numbers.

00:03:59.730 --> 00:04:03.965
And he worshipped numbers, his
followers worshipped numbers.

00:04:10.790 --> 00:04:16.740
And the problem here was
that he didn't really

00:04:16.740 --> 00:04:20.769
like the square root of 2
because he couldn't express it

00:04:20.769 --> 00:04:25.330
as a number, of what he thought
of as a number, which was 1, 2,

00:04:25.330 --> 00:04:28.260
3, et cetera, integers,
whole numbers.

00:04:28.260 --> 00:04:35.051
So he called this
ratio speechless,

00:04:35.051 --> 00:04:36.800
something that he
really couldn't explain.

00:04:39.480 --> 00:04:42.400
And irrationals were
actually considered a threat

00:04:42.400 --> 00:04:44.520
to the mystics because
they couldn't really

00:04:44.520 --> 00:04:47.030
explain what square
root of 2 was.

00:04:47.030 --> 00:04:49.290
They'd try and measure
it, and they would come up

00:04:49.290 --> 00:04:52.060
with the right answer because
the next time around it

00:04:52.060 --> 00:04:55.140
would be a little bit
different If they did things

00:04:55.140 --> 00:04:58.380
a little more precisely,
or not so precisely.

00:04:58.380 --> 00:05:00.680
And it bothered them no end.

00:05:00.680 --> 00:05:05.100
And so they tried to find
patterns in irrationals

00:05:05.100 --> 00:05:07.030
because they considered
them a threat.

00:05:07.030 --> 00:05:11.500
And they obviously
didn't find patterns,

00:05:11.500 --> 00:05:14.820
but imagine if we could
actually find patterns.

00:05:14.820 --> 00:05:17.910
I mean, that would
be a really big deal,

00:05:17.910 --> 00:05:21.909
it would be better than p equals
np, if you know what I mean.

00:05:21.909 --> 00:05:23.200
If you don't it doesn't matter.

00:05:26.630 --> 00:05:31.210
So that's another of motivation
for high precision arithmetic.

00:05:31.210 --> 00:05:34.310
Let's try and find
patterns in irrationals

00:05:34.310 --> 00:05:36.420
if you go to millions
and trillions of digits,

00:05:36.420 --> 00:05:41.530
maybe it's just a matter of time
before we discover that there's

00:05:41.530 --> 00:05:44.240
no such thing as
irrational numbers.

00:05:44.240 --> 00:05:45.370
Who knows?

00:05:45.370 --> 00:05:47.500
So let's do that for the
rest of this lecture.

00:05:47.500 --> 00:05:49.160
Let's try and
figure out how we're

00:05:49.160 --> 00:05:52.490
going to compute irrational
numbers, or things

00:05:52.490 --> 00:05:55.200
like square root of 2,
to arbitrary precision.

00:05:55.200 --> 00:05:57.970
So we can go play around,
and we'll give you some code,

00:05:57.970 --> 00:06:00.020
and you can play with it.

00:06:00.020 --> 00:06:01.550
So if you look at
square root of 2--

00:06:01.550 --> 00:06:10.870
I'll just put this up
here-- so it's 1.414,

00:06:10.870 --> 00:06:12.540
you probably all know that.

00:06:12.540 --> 00:06:28.300
Then it's 213,562,373,095,048
et cetera.

00:06:28.300 --> 00:06:29.800
I mean, I don't see
a pattern there.

00:06:29.800 --> 00:06:34.730
I see a zero, a
couple of zeroes here.

00:06:34.730 --> 00:06:36.680
It's hard to imagine--
you'd probably

00:06:36.680 --> 00:06:40.920
want to think of a computer
program that generates

00:06:40.920 --> 00:06:43.600
square root of 2, and then
maybe a different computer

00:06:43.600 --> 00:06:45.910
program that's
looking for patterns.

00:06:48.550 --> 00:06:51.860
So let's not worry about
the square root of 2.

00:06:51.860 --> 00:06:53.280
I want to digress a little bit.

00:06:53.280 --> 00:06:55.640
I did say this was a bit of
a recreational mathematics

00:06:55.640 --> 00:06:57.340
lecture.

00:06:57.340 --> 00:07:00.090
And let's talk about something
completely different,

00:07:00.090 --> 00:07:01.880
which are Catalan numbers.

00:07:01.880 --> 00:07:07.680
So these are really my
favorite numbers in the world.

00:07:07.680 --> 00:07:11.870
And people like primes, some
people like irrationals,

00:07:11.870 --> 00:07:13.980
I like Catalan numbers.

00:07:13.980 --> 00:07:18.410
Catalan numbers are-- they
show up all over the place.

00:07:21.010 --> 00:07:23.150
How many of you know
what Catalan numbers are?

00:07:23.150 --> 00:07:23.890
Oh good.

00:07:23.890 --> 00:07:25.290
Excellent.

00:07:25.290 --> 00:07:31.320
So Catalan numbers have
a recursive definition.

00:07:31.320 --> 00:07:36.990
You can think of them as
representing the cardinality

00:07:36.990 --> 00:07:45.480
of the set p of balanced
parentheses strings.

00:07:45.480 --> 00:07:47.190
And we're going to
recursively define

00:07:47.190 --> 00:07:49.605
these strings as follows.

00:07:49.605 --> 00:07:52.030
We're going to have
lambda belonging

00:07:52.030 --> 00:07:55.210
to p where lambda
is the empty string.

00:08:02.010 --> 00:08:06.250
And that's rule one.

00:08:06.250 --> 00:08:13.290
Rule two is if alpha
and beta belong

00:08:13.290 --> 00:08:20.130
to p then I'm going to put
a paren, open paren, alpha,

00:08:20.130 --> 00:08:22.730
close paren, and then beta.

00:08:22.730 --> 00:08:25.310
And that belongs to p.

00:08:25.310 --> 00:08:30.520
So you iteratively or
recursively apply this rule

00:08:30.520 --> 00:08:34.440
over and over, and
you start getting

00:08:34.440 --> 00:08:36.330
strings that are balanced.

00:08:36.330 --> 00:08:38.400
So this is balanced.

00:08:38.400 --> 00:08:41.760
Now that's not
balanced, this is not

00:08:41.760 --> 00:08:46.870
balanced, and so
on and so forth.

00:08:46.870 --> 00:08:49.180
Obviously things
get more complicated

00:08:49.180 --> 00:08:55.660
in terms of the parentheses
if when you have more brackets

00:08:55.660 --> 00:08:56.770
or parentheses.

00:08:56.770 --> 00:08:59.590
And so, the nice thing
about this definition

00:08:59.590 --> 00:09:12.770
is that you can get every
non-empty balanced paren

00:09:12.770 --> 00:09:30.500
string, via rule two, from
a unique alpha, beta pair.

00:09:30.500 --> 00:09:33.130
So as an example,
suppose you want

00:09:33.130 --> 00:09:36.254
to generate the string
that looks like this--

00:09:36.254 --> 00:09:38.420
So that's a little more
complicated than the strings

00:09:38.420 --> 00:09:41.200
that we have looked
at so far-- then you

00:09:41.200 --> 00:09:52.600
obtain that by having alpha
be this simple string.

00:09:52.600 --> 00:09:55.380
And then you put the brackets
around that, and then

00:09:55.380 --> 00:09:59.560
your beta corresponds to this.

00:09:59.560 --> 00:10:03.430
So now alpha and beta
were previously generated,

00:10:03.430 --> 00:10:07.570
so if you applied rule
two to the empty string,

00:10:07.570 --> 00:10:09.000
with alpha being
the empty string

00:10:09.000 --> 00:10:13.860
and beta being the empty string,
then you get this thing here.

00:10:13.860 --> 00:10:19.180
And obviously you could
get beta by setting

00:10:19.180 --> 00:10:22.990
alpha to be the empty string and
beta to be this string that you

00:10:22.990 --> 00:10:25.370
just generated, and
so on and so forth.

00:10:25.370 --> 00:10:28.740
So you just keep going and the
strings get longer and longer.

00:10:28.740 --> 00:10:31.550
The cardinality of the set
gets bigger and bigger.

00:10:31.550 --> 00:10:33.640
And those of the
Catalan numbers.

00:10:33.640 --> 00:10:35.210
OK

00:10:35.210 --> 00:10:40.560
And so, this is a
non-trivial question,

00:10:40.560 --> 00:10:45.430
which is I'd like to
enumerate the Catalan numbers,

00:10:45.430 --> 00:10:48.240
and compute, and get
an analytical form

00:10:48.240 --> 00:10:51.020
for the cardinality of the set.

00:10:51.020 --> 00:10:52.980
And that's really what
the Catalan number is.

00:10:52.980 --> 00:10:55.180
It's a cardinality of the set.

00:10:55.180 --> 00:11:08.730
And so cn is the number of
balanced parentheses strings

00:11:08.730 --> 00:11:16.130
with exactly n pairs
of parentheses.

00:11:22.100 --> 00:11:26.735
And I have c0 equals 1,
which is my base case.

00:11:30.430 --> 00:11:32.700
And that's just setting--
it's an empty string.

00:11:32.700 --> 00:11:37.190
I'm going to say that
empty string is a string,

00:11:37.190 --> 00:11:40.190
and that's just setting
up the base case.

00:11:40.190 --> 00:11:45.325
And now I want an
equation for cn plus 1.

00:11:48.630 --> 00:11:50.700
And I need to use
the fact that I

00:11:50.700 --> 00:11:55.790
can get cn plus 1, a
particular strain that belongs

00:11:55.790 --> 00:12:02.930
to this set, where I have n plus
1 parenthesis in a unique way

00:12:02.930 --> 00:12:06.070
from a string I've previously
generated that was part

00:12:06.070 --> 00:12:12.830
of either the set that
had n parentheses--

00:12:12.830 --> 00:12:17.930
or it was combined using
strings, where alpha was

00:12:17.930 --> 00:12:21.330
in some set that was
maybe generated awhile

00:12:21.330 --> 00:12:24.290
back with a small
n, or something

00:12:24.290 --> 00:12:27.640
significantly smaller than
n, and another thing that

00:12:27.640 --> 00:12:30.660
was generated, beta,
that was generated later,

00:12:30.660 --> 00:12:33.140
or maybe at the same
time, et cetera.

00:12:33.140 --> 00:12:40.050
So can someone tell me what an
equation would be for cn plus 1

00:12:40.050 --> 00:12:43.820
based on the cis
that are less than n?

00:12:53.970 --> 00:12:55.470
So what about c1?

00:12:55.470 --> 00:12:59.186
Maybe I'll ask-- what about c1?

00:12:59.186 --> 00:13:01.496
What's c1?

00:13:01.496 --> 00:13:03.000
1.

00:13:03.000 --> 00:13:09.450
c1 is 1 because all I have
is this string, that's

00:13:09.450 --> 00:13:12.750
the only balanced string.

00:13:12.750 --> 00:13:14.940
Now I have c0 and c1.

00:13:14.940 --> 00:13:19.020
What's an equation for
c2 in terms of numbers.

00:13:19.020 --> 00:13:24.850
I want a number for
c2 based on c0 and c1.

00:13:24.850 --> 00:13:26.696
Someone?

00:13:26.696 --> 00:13:27.660
Yeah.

00:13:27.660 --> 00:13:29.590
AUDIENCE: C0 plus c1.

00:13:29.590 --> 00:13:30.900
PROFESSOR: c0 plus c1?

00:13:34.810 --> 00:13:35.830
No, not quite right.

00:13:38.960 --> 00:13:41.040
How many strings do I have?

00:13:43.800 --> 00:13:44.850
c0 plus c1.

00:13:44.850 --> 00:13:47.224
Yeah, actually you're right.

00:13:47.224 --> 00:13:50.620
Well, the number is right
but the equation is wrong.

00:13:50.620 --> 00:13:53.000
It's not quite that.

00:13:53.000 --> 00:13:54.398
You get a-- Yup.

00:13:54.398 --> 00:14:01.570
AUDIENCE: So when something
like c-- c1 times c1 plus c1.

00:14:01.570 --> 00:14:03.833
PROFESSOR: c1 times c1 plus c1?

00:14:03.833 --> 00:14:04.720
AUDIENCE: Yeah.

00:14:04.720 --> 00:14:06.386
PROFESSOR: I think
you want to use a c0.

00:14:06.386 --> 00:14:07.620
AUDIENCE: OK. c0.

00:14:07.620 --> 00:14:11.770
PROFESSOR: c0 Well, that's
not quite right either.

00:14:11.770 --> 00:14:13.210
Someone else.

00:14:13.210 --> 00:14:13.710
Yeah.

00:14:13.710 --> 00:14:14.210
OK.

00:14:14.210 --> 00:14:14.921
You.

00:14:14.921 --> 00:14:18.010
AUDIENCE: c0 times c1
plus c1 [INAUDIBLE].

00:14:18.010 --> 00:14:21.362
PROFESSOR: c0
times c1-- c2 would

00:14:21.362 --> 00:14:25.180
be c0 times c1 plus c1 times c0.

00:14:25.180 --> 00:14:25.880
OK.

00:14:25.880 --> 00:14:29.550
And if you're setting the
alpha-- So here's the thing,

00:14:29.550 --> 00:14:32.670
you set the alpha, and
you choose the alpha,

00:14:32.670 --> 00:14:34.667
and then you choose the beta.

00:14:34.667 --> 00:14:36.250
And there's a couple
of different ways

00:14:36.250 --> 00:14:37.800
that you could choose the alpha.

00:14:37.800 --> 00:14:40.300
You could choose
the alpha from-- you

00:14:40.300 --> 00:14:41.940
could make it a
string that's empty,

00:14:41.940 --> 00:14:43.432
or you could make
it the one string

00:14:43.432 --> 00:14:44.890
that you've generated
so far, which

00:14:44.890 --> 00:14:49.140
is the standard simple
string, the non-empty,

00:14:49.140 --> 00:14:51.530
the non-trivial balanced string.

00:14:51.530 --> 00:14:53.840
And you could do that in
a couple different ways

00:14:53.840 --> 00:14:55.040
with alpha.

00:14:55.040 --> 00:14:57.360
And that's why you have
two terms over there.

00:14:57.360 --> 00:15:03.080
So the number, in terms of
all of the equations I got,

00:15:03.080 --> 00:15:04.480
they all came out
to be the same.

00:15:04.480 --> 00:15:05.604
It's 2, and that's correct.

00:15:08.480 --> 00:15:11.200
But this is the equation for it.

00:15:11.200 --> 00:15:14.150
And so now, tell me
what a general equation

00:15:14.150 --> 00:15:19.500
is for cn plus 1
based on what we've

00:15:19.500 --> 00:15:23.430
learned so far for
the c2 equation?

00:15:23.430 --> 00:15:25.170
Yeah, back to you.

00:15:25.170 --> 00:15:28.970
AUDIENCE: So c0 times
cn plus c1 times cn

00:15:28.970 --> 00:15:32.589
minus 1 all the way to
cn times [INAUDIBLE].

00:15:32.589 --> 00:15:33.380
PROFESSOR: Perfect.

00:15:33.380 --> 00:15:33.880
Good.

00:15:33.880 --> 00:15:35.067
That deserves a cushion.

00:15:40.165 --> 00:15:42.970
That wasn't me, it was you.

00:15:42.970 --> 00:15:44.803
And put it right
there, breadbasket.

00:15:49.180 --> 00:15:57.060
So cn plus 1 equals sigma,
so you give me a summation,

00:15:57.060 --> 00:16:05.497
k equals 0 through n,
ck, cn minus k where

00:16:05.497 --> 00:16:06.830
n is greater than or equal to 0.

00:16:11.570 --> 00:16:15.820
And you can figure this out,
it's not particularly important

00:16:15.820 --> 00:16:20.760
as to exactly why this is true.

00:16:20.760 --> 00:16:22.870
You can think about it offline.

00:16:22.870 --> 00:16:25.860
But the interesting thing is
that this is a generator of,

00:16:25.860 --> 00:16:29.760
obviously, and it's
going to give you

00:16:29.760 --> 00:16:32.330
a nice looking set of numbers.

00:16:32.330 --> 00:16:40.650
And I came in early and wrote
that the Catalan in numbers

00:16:40.650 --> 00:16:47.520
up on the board going from
c0, c1, c2, et cetera, just

00:16:47.520 --> 00:16:52.930
in case-- just in case you ever
see these numbers in real life,

00:16:52.930 --> 00:16:54.710
or when you're writing
computer programs.

00:16:54.710 --> 00:16:57.620
Or you're driving on the road,
the next time you see a license

00:16:57.620 --> 00:17:01.290
plate 4862, turn around and
tell your mom or dad, hey,

00:17:01.290 --> 00:17:03.810
that's the Catalan number.

00:17:03.810 --> 00:17:05.119
And maybe she'll be impressed.

00:17:07.505 --> 00:17:08.880
This, of course,
you're not going

00:17:08.880 --> 00:17:11.310
to see on a license
plate, but you can always

00:17:11.310 --> 00:17:14.280
make up a bumper
sticker or something,

00:17:14.280 --> 00:17:16.420
and you can have
the c17 as being

00:17:16.420 --> 00:17:18.126
a bumper sticker on your car.

00:17:18.126 --> 00:17:20.000
I mean, that's the kind
of thing that I'd do.

00:17:23.050 --> 00:17:27.410
Anyway, so it's just in
case you see these numbers--

00:17:27.410 --> 00:17:30.700
we might come back to this a
little bit later in the class,

00:17:30.700 --> 00:17:31.222
but--

00:17:31.222 --> 00:17:32.430
AUDIENCE: 42 is on that list.

00:17:32.430 --> 00:17:33.680
PROFESSOR: 42 is on that list.

00:17:33.680 --> 00:17:34.960
Yeah, it has to be.

00:17:34.960 --> 00:17:37.580
42 is on every list.

00:17:37.580 --> 00:17:40.590
42 is the answer
to every question.

00:17:40.590 --> 00:17:43.320
I am glad you guys didn't
put 42 down in the answer

00:17:43.320 --> 00:17:44.560
to every quiz question.

00:17:44.560 --> 00:17:48.730
It doesn't quite work
all the time, all right,

00:17:48.730 --> 00:17:52.400
but most of the time
42 is a good answer.

00:17:52.400 --> 00:17:54.450
Most of the time.

00:17:54.450 --> 00:17:55.700
OK good.

00:17:55.700 --> 00:18:00.210
So let's get down to business.

00:18:00.210 --> 00:18:03.680
So we talked about Catalan
numbers as a digression.

00:18:03.680 --> 00:18:07.260
If you see them you'll
recognize them, I think.

00:18:07.260 --> 00:18:08.880
Let's talk about how
we could compute.

00:18:08.880 --> 00:18:11.460
Let's go back to
irrationals and talk

00:18:11.460 --> 00:18:13.790
about how we could
compute square root of 2

00:18:13.790 --> 00:18:16.360
and other things to
arbitrary precision.

00:18:16.360 --> 00:18:19.090
So what I want to do is to
talk about Newton's method.

00:18:26.860 --> 00:18:29.450
And Newton's method is
something you probably

00:18:29.450 --> 00:18:32.510
learned about in middle
school, high school.

00:18:36.840 --> 00:18:38.900
And let's say you
have a function

00:18:38.900 --> 00:18:44.650
y equals f of x where
this is x and that's

00:18:44.650 --> 00:18:48.100
y, the coordinate axes.

00:18:48.100 --> 00:18:58.378
And we want to try and find
the root of fx equals 0

00:18:58.378 --> 00:18:59.895
through successive
approximation.

00:19:12.550 --> 00:19:18.790
For example, we might have f
of x equals x squared minus a.

00:19:18.790 --> 00:19:23.030
And if a is 2 then you're
trying to use Newton's method

00:19:23.030 --> 00:19:24.800
to find the root,
and you're going

00:19:24.800 --> 00:19:29.760
to end up trying to compute
square root of 2 or plus

00:19:29.760 --> 00:19:31.690
minus square root
of 2, in this case.

00:19:31.690 --> 00:19:35.080
But you can go for
a particular root,

00:19:35.080 --> 00:19:37.930
and you're try and
converge to that.

00:19:37.930 --> 00:19:44.380
So the way Newton's method
works is it tries, geometrically

00:19:44.380 --> 00:19:48.740
speaking, it tries
to find tangents--

00:19:48.740 --> 00:19:51.000
and a different color
chalk would be useful here

00:19:51.000 --> 00:19:54.420
but I don't seem to see
one-- So what would happen

00:19:54.420 --> 00:19:57.210
is, let's say you
are sitting out here,

00:19:57.210 --> 00:20:00.240
and it's successive
approximation method,

00:20:00.240 --> 00:20:05.200
so this would give you x of i.

00:20:05.200 --> 00:20:08.870
And now you want to
compute x of i plus 1.

00:20:08.870 --> 00:20:11.890
And what you're going
to do is draw a tangent,

00:20:11.890 --> 00:20:18.540
like so, and find the
intercept onto the x-axis,

00:20:18.540 --> 00:20:20.150
the x-intercept.

00:20:20.150 --> 00:20:25.720
And that is going to
be your xi plus 1.

00:20:25.720 --> 00:20:28.900
And you have to write an
equation for that tangent.

00:20:28.900 --> 00:20:32.540
And this is, I guess,
trying to figure

00:20:32.540 --> 00:20:35.730
out how much of middle school
math or high school math

00:20:35.730 --> 00:20:37.220
that you remember.

00:20:37.220 --> 00:20:41.870
What is the equation
for that tangent?

00:20:41.870 --> 00:20:42.370
Anybody?

00:20:48.520 --> 00:20:50.340
The equation for that tangent?

00:20:50.340 --> 00:20:53.200
What do you do in order
to compute that tangent?

00:20:53.200 --> 00:20:54.215
Give me a name.

00:20:54.215 --> 00:20:55.090
AUDIENCE: Derivative?

00:20:55.090 --> 00:20:55.570
PROFESSOR: Derivative.

00:20:55.570 --> 00:20:56.460
Thank you.

00:20:56.460 --> 00:20:59.380
So what's the equation
for that tangent?

00:20:59.380 --> 00:21:09.602
y equals-- Someone?

00:21:09.602 --> 00:21:11.080
AUDIENCE: [INAUDIBLE]

00:21:11.080 --> 00:21:12.110
PROFESSOR: It's a good
think your middle school,

00:21:12.110 --> 00:21:13.485
high school teachers
aren't here.

00:21:16.140 --> 00:21:16.855
Not you.

00:21:16.855 --> 00:21:18.610
You already got a cushion.

00:21:18.610 --> 00:21:19.270
Someone else.

00:21:23.470 --> 00:21:24.421
Someone else.

00:21:24.421 --> 00:21:24.920
All right.

00:21:24.920 --> 00:21:26.750
I'll start giving
you some hints here.

00:21:30.540 --> 00:21:37.745
f of xi plus-- plus--

00:21:37.745 --> 00:21:38.555
ALL: f prime.

00:21:38.555 --> 00:21:39.680
PROFESSOR: f prime xi.

00:21:39.680 --> 00:21:40.190
Thank you.

00:21:40.190 --> 00:21:40.851
Thank you.

00:21:40.851 --> 00:21:41.350
All right.

00:21:41.350 --> 00:21:42.630
You get a cushion.

00:21:42.630 --> 00:21:45.371
I'm getting them.

00:21:45.371 --> 00:21:47.820
Whatever it takes.

00:21:47.820 --> 00:21:50.170
Here you go.

00:21:50.170 --> 00:21:51.016
Yeah.

00:21:51.016 --> 00:21:52.390
That was left-handed,
by the way.

00:21:52.390 --> 00:21:55.560
I'm actually
right-handed, as you know.

00:21:55.560 --> 00:21:57.900
So what do we have here?

00:21:57.900 --> 00:22:01.300
So we have f prime xi.

00:22:01.300 --> 00:22:03.190
Now come on, let's
finish it, finish it.

00:22:03.190 --> 00:22:05.550
AUDIENCE: Times i minus xi.

00:22:05.550 --> 00:22:06.640
PROFESSOR: Times xi is xi.

00:22:06.640 --> 00:22:07.390
Thank you.

00:22:07.390 --> 00:22:07.890
OK.

00:22:07.890 --> 00:22:09.190
So now I get it.

00:22:09.190 --> 00:22:11.370
You thought this was
too simple a question.

00:22:11.370 --> 00:22:13.930
You guys were insulted
by the question.

00:22:13.930 --> 00:22:16.730
So that's why you didn't tell
me what it was At least, that's

00:22:16.730 --> 00:22:21.780
what I'm going to pretend
to make myself feel better.

00:22:21.780 --> 00:22:26.055
So y equals f of
xi plus f prime xi,

00:22:26.055 --> 00:22:31.990
which is the derivative
of f evaluated at xi times

00:22:31.990 --> 00:22:35.220
x minus xi, that's the
equation for the line.

00:22:35.220 --> 00:22:38.260
And that's essentially
what we have

00:22:38.260 --> 00:22:42.640
to do to compute things
like square root of 2, which

00:22:42.640 --> 00:22:45.220
is iteratively applied
Newton's method.

00:22:45.220 --> 00:22:50.630
The only problem is this
is all good in theory

00:22:50.630 --> 00:22:56.980
that we can do-- take that
equation turn it into xi

00:22:56.980 --> 00:23:03.642
plus 1 equals xi minus f of
xi divided by f prime of xi.

00:23:06.320 --> 00:23:13.870
And if you end up doing f of x
equals x squared minus a, then

00:23:13.870 --> 00:23:23.030
you have xi plus 1
equals xi minus xi

00:23:23.030 --> 00:23:27.570
squared minus a divided by 2xi,
which is the derivative of x

00:23:27.570 --> 00:23:32.050
squared minus a evaluated at xi.

00:23:32.050 --> 00:23:34.970
And finally you get
this equation, xi

00:23:34.970 --> 00:23:39.850
plus a divided by
xi divided by 2.

00:23:39.850 --> 00:23:41.560
So it's fairly straightforward.

00:23:41.560 --> 00:23:46.060
xi plus 1 equals xi plus a
divided by xi divided by 2.

00:23:46.060 --> 00:23:47.970
And if you look
at this, remember

00:23:47.970 --> 00:23:51.180
that a is typically
a small number.

00:23:51.180 --> 00:23:52.930
I mean, it's two, in
this case, if you're

00:23:52.930 --> 00:23:54.920
computing square root of 2.

00:23:54.920 --> 00:23:58.730
it may even be an
integer, maybe a fraction.

00:23:58.730 --> 00:24:01.199
But you have to do
a division here.

00:24:01.199 --> 00:24:03.240
And remember that since
we want to compute things

00:24:03.240 --> 00:24:07.090
to millions of digits,
potentially, these numbers,

00:24:07.090 --> 00:24:11.690
the xi numbers, are going
to have millions of digits.

00:24:11.690 --> 00:24:15.620
And so if you end up
running this Newton method

00:24:15.620 --> 00:24:22.710
on a equals 2, then
if I simulate what

00:24:22.710 --> 00:24:26.924
happens without worrying
about the implementation,

00:24:26.924 --> 00:24:28.090
and this is what you'll get.

00:24:33.300 --> 00:24:40.260
You have x0-- you start with x0
equals 1 with a bunch of zeros.

00:24:40.260 --> 00:24:47.740
xi equals 1.5 with a
bunch of zeros, et cetera.

00:24:47.740 --> 00:24:55.370
And then, x2 equals
1.41666 et cetera.

00:24:55.370 --> 00:24:58.140
That goes on.

00:24:58.140 --> 00:25:00.600
And we're not talking
about fractions here,

00:25:00.600 --> 00:25:05.920
we're talking about
floating point numbers that

00:25:05.920 --> 00:25:08.620
are integers with a certain
amount of precision.

00:25:08.620 --> 00:25:11.160
So you've decided that
you want to compute this

00:25:11.160 --> 00:25:14.030
to d digits of precision
where d may be a million.

00:25:14.030 --> 00:25:17.620
And so, really, here you would
have a representation that's

00:25:17.620 --> 00:25:19.860
a million digits
long that where,

00:25:19.860 --> 00:25:22.800
basically, everything is zero,
and here everything but one

00:25:22.800 --> 00:25:26.570
is 0, or maybe a couple
if you count the 1 here.

00:25:26.570 --> 00:25:28.790
And here you have
all these sixes here,

00:25:28.790 --> 00:25:30.280
and so on and so forth.

00:25:30.280 --> 00:25:42.687
And you keep going, and you
get x2 equals 1.414215686.

00:25:42.687 --> 00:25:44.270
And I want to write
one more because I

00:25:44.270 --> 00:25:46.560
want to point out
something that's important.

00:25:46.560 --> 00:25:54.610
1.414213562.

00:25:54.610 --> 00:25:58.740
And what's nice about
this, if you go compare it

00:25:58.740 --> 00:26:01.160
with what you have
up there, is that you

00:26:01.160 --> 00:26:05.550
have quadratic convergence
using the Newton's method.

00:26:05.550 --> 00:26:07.970
And what do I mean by that?

00:26:07.970 --> 00:26:10.875
Well, quadratic convergence
is a nice property.

00:26:13.800 --> 00:26:15.890
It's much better than
linear convergence.

00:26:15.890 --> 00:26:17.930
Linear convergence
would mean that you

00:26:17.930 --> 00:26:24.250
get an extra digit of
precision for every iteration.

00:26:24.250 --> 00:26:26.892
So in this case, actually,
a quadratic is better.

00:26:26.892 --> 00:26:28.600
Usually we think of
quadratic algorithms,

00:26:28.600 --> 00:26:30.330
and we are going to throw up.

00:26:30.330 --> 00:26:33.710
But linear algorithms
is what we like.

00:26:33.710 --> 00:26:36.020
But in this case it's
actually a good thing.

00:26:36.020 --> 00:26:39.330
You have this extended this
quadratic rate of convergence

00:26:39.330 --> 00:26:42.880
where the number of
digits that are correct

00:26:42.880 --> 00:26:46.100
doubles with every
iteration, as you can see.

00:26:46.100 --> 00:26:50.300
So here you have-- you
start with, roughly,

00:26:50.300 --> 00:26:53.270
if you rounded this
up you would get 5.

00:26:53.270 --> 00:26:56.670
So you're saying that that's
one digit of precision

00:26:56.670 --> 00:26:58.120
in terms of the decimal.

00:26:58.120 --> 00:27:10.160
And then, now you're
talking about 41421356,

00:27:10.160 --> 00:27:13.560
so that's 1, 2,
3, 4, 5, 6, 7, 8,

00:27:13.560 --> 00:27:16.460
so that's eight digits of
precision here, four here,

00:27:16.460 --> 00:27:18.840
and so on and so forth.

00:27:18.840 --> 00:27:19.710
So that's nice.

00:27:19.710 --> 00:27:21.460
That's why the Newton's
method is actually

00:27:21.460 --> 00:27:26.920
used in practice because the
number of digits doubles.

00:27:29.392 --> 00:27:30.225
This is a precision.

00:27:33.160 --> 00:27:36.750
So now you don't get too
scared about calculating things

00:27:36.750 --> 00:27:39.307
that are a million because
you kind of go and say, whoa,

00:27:39.307 --> 00:27:40.890
I mean, that's not
so bad, that's only

00:27:40.890 --> 00:27:43.910
a logarithmic number
of integrations.

00:27:43.910 --> 00:27:46.420
And it's not like you have to
run for a million iterations.

00:27:46.420 --> 00:27:51.790
You go 2, 4, 8, 16, and now
that exponential helps you,

00:27:51.790 --> 00:27:55.320
the geometric series helps you.

00:27:55.320 --> 00:27:57.880
So that's the nice thing
about the Newton's method.

00:27:57.880 --> 00:28:01.830
Haven't quite told
you how we are

00:28:01.830 --> 00:28:04.650
going to compute the
most important thing here

00:28:04.650 --> 00:28:07.640
with respect to a divided by xi.

00:28:07.640 --> 00:28:09.200
So this is just additions.

00:28:09.200 --> 00:28:12.580
You can imagine that if
you have long numbers

00:28:12.580 --> 00:28:17.410
you'd end up doing addition
fairly straightforwardly

00:28:17.410 --> 00:28:20.220
because you only have to
worry about one carry,

00:28:20.220 --> 00:28:21.310
and so you go off.

00:28:21.310 --> 00:28:23.410
And I'm sure you've
added up numbers

00:28:23.410 --> 00:28:26.460
that are in tens, if not
hundreds, of digits long

00:28:26.460 --> 00:28:29.190
but I'm guessing
you haven't manually

00:28:29.190 --> 00:28:34.330
multiplied numbers that are
hundreds of digits long.

00:28:34.330 --> 00:28:36.740
And if you have
I'd be impressed,

00:28:36.740 --> 00:28:38.720
though I won't
believe your result.

00:28:38.720 --> 00:28:44.380
But that's something that is
kind of a painful thing to do.

00:28:44.380 --> 00:28:46.200
And so that's why
we need computers.

00:28:46.200 --> 00:28:50.050
And that's multiplication
and-- has anybody

00:28:50.050 --> 00:28:54.840
divided a hundred-digit number
by another 50-digit number?

00:28:54.840 --> 00:28:55.870
No.

00:28:55.870 --> 00:28:57.810
So you need computers.

00:28:57.810 --> 00:29:00.370
So we've got to be able
to do that division there,

00:29:00.370 --> 00:29:04.220
a divided by xi,
using computers.

00:29:04.220 --> 00:29:06.929
And so that's really the purpose
of this and the next lecture

00:29:06.929 --> 00:29:08.720
If you're only going
to do a high precision

00:29:08.720 --> 00:29:10.140
multiplication here.

00:29:10.140 --> 00:29:13.830
And try see what an algorithm
would be for high precision

00:29:13.830 --> 00:29:15.820
multiplication because
what we're going to do

00:29:15.820 --> 00:29:21.560
is, essentially, take the
reciprocal of one over xi

00:29:21.560 --> 00:29:24.010
and then multiply that by a.

00:29:24.010 --> 00:29:27.510
And we need-- division is going
to require multiplication.

00:29:27.510 --> 00:29:29.210
You don't really
see a multiplication

00:29:29.210 --> 00:29:31.770
there other than
a times 1 over xi.

00:29:31.770 --> 00:29:34.150
And you can say, well, do we
really need multiplication?

00:29:34.150 --> 00:29:37.620
Well, the answer is
the division algorithm

00:29:37.620 --> 00:29:41.010
that is used in practice in
most division algorithms have

00:29:41.010 --> 00:29:43.430
multiplication as a subroutine.

00:29:43.430 --> 00:29:46.290
So we're going to have to
figure out high precision

00:29:46.290 --> 00:29:48.580
multiplication first--
It's a little bit easier

00:29:48.580 --> 00:29:52.900
than division-- and use it as
a subroutine for high precision

00:29:52.900 --> 00:29:56.090
division, which
we'll do next time.

00:29:56.090 --> 00:29:59.610
So now we're sort of back
in 006 land, if you will.

00:29:59.610 --> 00:30:03.040
We have a problem that is
high precision multiplication,

00:30:03.040 --> 00:30:05.770
and we want to find
an algorithm for it.

00:30:05.770 --> 00:30:08.040
And there's the
vanilla algorithm

00:30:08.040 --> 00:30:10.950
that is going to take
certain amounts of time,

00:30:10.950 --> 00:30:12.585
asymptotically
speaking, and then there

00:30:12.585 --> 00:30:14.180
is better and better algorithms.

00:30:14.180 --> 00:30:16.325
As you can imagine,
multiplication

00:30:16.325 --> 00:30:19.670
is just such a
fundamental operation

00:30:19.670 --> 00:30:21.720
that people have
looked at trying

00:30:21.720 --> 00:30:25.190
to reduce the complexity of
high precision multiplication.

00:30:25.190 --> 00:30:27.900
So if you have n bits-- So
what is the standard algorithm

00:30:27.900 --> 00:30:32.678
for multiplication take if
you have n bits of precision?

00:30:32.678 --> 00:30:33.650
AUDIENCE: N squared.

00:30:33.650 --> 00:30:34.980
PROFESSOR: n squared.

00:30:34.980 --> 00:30:36.940
But you can do better.

00:30:36.940 --> 00:30:38.840
And the people are work on it.

00:30:38.840 --> 00:30:40.680
You can do fast
Fourier transforms.

00:30:40.680 --> 00:30:42.010
We won't quite do that here.

00:30:42.010 --> 00:30:45.970
If you take 6.046 you'll
probably learn about that.

00:30:45.970 --> 00:30:47.910
But we'll do a
couple of algorithms

00:30:47.910 --> 00:30:50.977
that are better than the
order n squared method,

00:30:50.977 --> 00:30:52.310
and we'll do one of those today.

00:30:59.650 --> 00:31:01.650
So the way they're going
to work with integers--

00:31:01.650 --> 00:31:10.710
one little point that I need to
make before we move ahead here

00:31:10.710 --> 00:31:16.860
is, generally, we going to
say, for the purposes of 006,

00:31:16.860 --> 00:31:23.100
that we know the digits of
precision up front because we

00:31:23.100 --> 00:31:28.240
want d digits of precision,
maybe it's 42, maybe it's 125.

00:31:28.240 --> 00:31:30.910
In the case of our problem
set in RSA we going to have it

00:31:30.910 --> 00:31:34.310
1,024-bit numbers, maybe 2,048.

00:31:34.310 --> 00:31:36.680
So we know d beforehand.

00:31:36.680 --> 00:31:43.480
And so what we want
is an integer, which

00:31:43.480 --> 00:31:49.020
is 10 raised to d times the
square root of 2, a floor,

00:31:49.020 --> 00:31:57.890
and which is essentially the
same as that, 2 times 10 raised

00:31:57.890 --> 00:31:59.141
to 2 d.

00:31:59.141 --> 00:32:00.890
So we're going to treat
these as integers,

00:32:00.890 --> 00:32:02.440
so we don't want to worry
about decimal points

00:32:02.440 --> 00:32:03.360
and things like that.

00:32:03.360 --> 00:32:06.144
All of these things are
going to be integers.

00:32:06.144 --> 00:32:07.310
And there's no problem here.

00:32:07.310 --> 00:32:08.690
We can still use
Newton's method.

00:32:15.970 --> 00:32:18.500
It just works on integers.

00:32:18.500 --> 00:32:21.240
And let's take a
look at how we would

00:32:21.240 --> 00:32:28.370
apply Newton's method
in standard form.

00:32:35.360 --> 00:32:40.870
And we won't to
really get to the part

00:32:40.870 --> 00:32:44.260
where we're going to go from
division to multiplication

00:32:44.260 --> 00:32:46.090
today, as I said,
we're just going

00:32:46.090 --> 00:32:50.117
to look at how you can
multiply two numbers.

00:32:50.117 --> 00:32:51.533
So I didn't mean
to say that we're

00:32:51.533 --> 00:32:52.820
going to look at
Newton's method.

00:32:52.820 --> 00:32:54.700
We're going to look at high
precision multiplication,

00:32:54.700 --> 00:32:56.075
and then, eventually,
we're going

00:32:56.075 --> 00:32:59.890
to use that to build
Newton's method

00:32:59.890 --> 00:33:01.060
which requires the division.

00:33:08.800 --> 00:33:23.400
So I have two n-digit
numbers, and the radix

00:33:23.400 --> 00:33:28.620
could be-- the base
could be 2, 10.

00:33:28.620 --> 00:33:32.340
Normally, it doesn't
really matter.

00:33:32.340 --> 00:33:38.320
0 less than x, less than
y, strictly less than r

00:33:38.320 --> 00:33:39.790
raised to n.

00:33:39.790 --> 00:33:44.450
That's standard for the ranges.

00:33:44.450 --> 00:33:46.530
And what I have
here is-- the way

00:33:46.530 --> 00:33:49.460
I'm going to do this is use
our favorite strategy, which

00:33:49.460 --> 00:33:53.280
is divide and conquer, because
I have n, which is large,

00:33:53.280 --> 00:33:56.700
need to break things
down, break it into n

00:33:56.700 --> 00:34:00.080
by two-digit multiplications.

00:34:00.080 --> 00:34:01.790
And when, finally,
I break things down,

00:34:01.790 --> 00:34:05.550
I get down to 64 bits, I
just run one instruction

00:34:05.550 --> 00:34:10.030
on my computer to multiply
the 64-bit numbers.

00:34:10.030 --> 00:34:14.440
And the standard machines, you
would get 128 bits of result

00:34:14.440 --> 00:34:16.772
back when you multiply
64-bit numbers.

00:34:16.772 --> 00:34:18.230
So in some sense
you only go down--

00:34:18.230 --> 00:34:22.130
you don't go down to 1
bit, you go down to 64

00:34:22.130 --> 00:34:25.100
and your machine does the rest.

00:34:25.100 --> 00:34:29.889
So what we have here
is you set x to be x1

00:34:29.889 --> 00:34:36.420
where x1 is the high half, r
raised to n over 2 plus x0.

00:34:36.420 --> 00:34:44.080
So x1 is the more significant
half and x0 is the low half.

00:34:47.210 --> 00:34:50.570
And the same thing for y.

00:34:50.570 --> 00:34:55.199
y1, whoops, r raised
to n over 2 plus y0.

00:34:58.750 --> 00:35:01.690
Now the ranges change.

00:35:01.690 --> 00:35:07.840
x0 and x1 are smaller, so that's
what you have for x0 and x1.

00:35:14.780 --> 00:35:17.080
Same thing for y0 and y1.

00:35:17.080 --> 00:35:23.220
So that's a fairly
straightforward decomposition

00:35:23.220 --> 00:35:26.470
of this multiplication
operation.

00:35:26.470 --> 00:35:30.700
And again, if you do things
in a straightforward way

00:35:30.700 --> 00:35:38.050
you will create a recursive
multiply, as I'll write here.

00:35:38.050 --> 00:35:50.110
And what you do is you say
let z0 equal x0 times y0,

00:35:50.110 --> 00:36:03.260
z two equals x2 times
y2, and-- I missed z1,

00:36:03.260 --> 00:36:09.500
but z1 equals x0, y1 plus x1 y0.

00:36:12.620 --> 00:36:17.070
And I have, overall,
z equals y equals

00:36:17.070 --> 00:36:27.600
x1 y1 times r raised to n
plus x0 y1 plus x1 y0 times

00:36:27.600 --> 00:36:34.440
r raised to n over
2 plus x0 y0 zero.

00:36:34.440 --> 00:36:42.770
And this part here was
z0, this part here was z1,

00:36:42.770 --> 00:36:45.810
and this part here was z2.

00:36:45.810 --> 00:36:54.250
And if you look at, it you need
four multiplies, 1, 2, 3, 4.

00:36:54.250 --> 00:36:56.550
And you need four
multiplies of n

00:36:56.550 --> 00:37:03.725
by two-- n by two-digit numbers.

00:37:06.980 --> 00:37:11.270
And by now, after you have
prepared for quiz two,

00:37:11.270 --> 00:37:19.975
I will just say that it would
take theta n square time

00:37:19.975 --> 00:37:21.550
because you're
recursive equation

00:37:21.550 --> 00:37:35.990
is tn equals 4t of n over 2 plus
the linear time that you take

00:37:35.990 --> 00:37:38.520
for addition.

00:37:38.520 --> 00:37:49.209
So this is tn equals 4t
of n over 2 plus theta n.

00:37:49.209 --> 00:37:51.000
And you're assuming
that the additions here

00:37:51.000 --> 00:37:52.930
take linear time.

00:37:52.930 --> 00:37:55.470
So that's how you get your
theta n square algorithm.

00:37:55.470 --> 00:37:58.460
And we're not happy with that.

00:37:58.460 --> 00:38:00.750
We'd like to do better.

00:38:00.750 --> 00:38:03.410
And so how do you do better?

00:38:03.410 --> 00:38:07.310
Well, there's many
ways of doing better.

00:38:07.310 --> 00:38:13.330
The simplest way off fairly,
substantially lowering

00:38:13.330 --> 00:38:19.390
the complexity is
due to a gentleman

00:38:19.390 --> 00:38:20.940
by the name of Karatsuba.

00:38:29.300 --> 00:38:31.310
This is one of
those things where

00:38:31.310 --> 00:38:32.720
if you were born
early enough you

00:38:32.720 --> 00:38:35.870
get your name on an algorithm.

00:38:35.870 --> 00:38:42.430
And what happens here is, using
the z's that I have out there,

00:38:42.430 --> 00:38:46.940
you essentially say, look,
I know z0 equals x0 and y0,

00:38:46.940 --> 00:38:49.210
I'm going to go
ahead and multiply.

00:38:49.210 --> 00:38:54.750
z2 equals x2 and y2,
go ahead and do that.

00:38:54.750 --> 00:39:03.520
And now I'm going to write
z1 as x0 plus x1 times y0

00:39:03.520 --> 00:39:08.430
plus y1 minus z0 minus z2.

00:39:08.430 --> 00:39:11.420
So you're actually
computing z0 and z2 first,

00:39:11.420 --> 00:39:16.470
and then using
them to compute z1.

00:39:16.470 --> 00:39:20.570
So someone tell me why
this is interesting?

00:39:20.570 --> 00:39:25.030
And just take it all the way to
the complexity of an algorithm.

00:39:25.030 --> 00:39:28.250
Explain to me why
this is interesting

00:39:28.250 --> 00:39:32.060
and why Karatsuba's algorithm
has-- I'll give it away--

00:39:32.060 --> 00:39:34.220
a lower complexity
than theta n square?

00:39:34.220 --> 00:39:37.220
But tell me what it is.

00:39:37.220 --> 00:39:37.820
Someone?

00:39:37.820 --> 00:39:38.778
Someone other than you.

00:39:42.185 --> 00:39:43.185
Someone way at the back.

00:39:47.265 --> 00:39:47.765
Yup.

00:39:47.765 --> 00:39:48.610
Out there.

00:39:48.610 --> 00:39:52.070
AUDIENCE: It's n to
the log base 2 of 3.

00:39:52.070 --> 00:39:53.215
PROFESSOR: n raised to--

00:39:53.215 --> 00:39:53.930
AUDIENCE: Log base 2--

00:39:53.930 --> 00:39:54.570
PROFESSOR: --log base 2 of 3.

00:39:54.570 --> 00:39:55.550
That's exactly right.

00:39:55.550 --> 00:39:56.450
And now, why did you get that?

00:39:56.450 --> 00:39:57.783
Explain to me how you got there.

00:39:57.783 --> 00:39:59.670
AUDIENCE: If you're
using three products--

00:39:59.670 --> 00:40:00.670
PROFESSOR: That's right.

00:40:00.670 --> 00:40:03.110
So first insight
is that we're only

00:40:03.110 --> 00:40:05.230
doing three
multiplications here.

00:40:05.230 --> 00:40:07.780
Additions are easy.

00:40:07.780 --> 00:40:10.080
And we're doing three
multiplications as opposed

00:40:10.080 --> 00:40:12.300
to four.

00:40:12.300 --> 00:40:16.220
So tell me how that
equation changed, of tn.

00:40:16.220 --> 00:40:17.510
tn equals--

00:40:17.510 --> 00:40:18.510
AUDIENCE: 3 [INAUDIBLE].

00:40:18.510 --> 00:40:23.550
PROFESSOR: 3 times t of
n over 2 plus theta n

00:40:23.550 --> 00:40:25.870
because you're doing three
multiplications rather than

00:40:25.870 --> 00:40:26.600
four.

00:40:26.600 --> 00:40:29.030
Multiplications are the
complicated operation.

00:40:29.030 --> 00:40:30.700
Divisions are even
more complicated,

00:40:30.700 --> 00:40:34.170
but additions are easy, and you
could do those in linear time

00:40:34.170 --> 00:40:36.570
for n-digit numbers.

00:40:36.570 --> 00:40:39.480
And so, if you do that and
then you go off and you say,

00:40:39.480 --> 00:40:42.890
well, that tells
us that tn equals

00:40:42.890 --> 00:40:50.010
theta of n raised to log two
of three, which is, by the way,

00:40:50.010 --> 00:40:53.850
theta of n raised to
1.58, roughly speaking.

00:40:53.850 --> 00:40:57.220
And I do not want to compute
that to arbitrary precision,

00:40:57.220 --> 00:40:58.660
though I could.

00:40:58.660 --> 00:40:59.850
But that goes on and on.

00:40:59.850 --> 00:41:01.892
Why don't you grab
this after you're done.

00:41:01.892 --> 00:41:03.100
But that just goes on and on.

00:41:03.100 --> 00:41:06.800
1.58 is a rough approximation.

00:41:06.800 --> 00:41:09.940
That's an irrational
number too, assuming

00:41:09.940 --> 00:41:12.170
you think that
irrational numbers exist.

00:41:12.170 --> 00:41:14.500
That's an irrational number.

00:41:14.500 --> 00:41:18.970
So good, that's
really all I had.

00:41:18.970 --> 00:41:23.236
By the way, it's 1.58490625.

00:41:23.236 --> 00:41:24.860
I really should have
written that down.

00:41:24.860 --> 00:41:28.710
1.58-- in the context
of this lecture

00:41:28.710 --> 00:41:30.950
I think it's
important that we get

00:41:30.950 --> 00:41:33.270
at least a few
digits a precision.

00:41:36.740 --> 00:41:40.730
Now you can imagine that you
could do it better than this.

00:41:40.730 --> 00:41:43.390
And it turns out that--
we'll talk a little bit

00:41:43.390 --> 00:41:46.340
about this next time-- But you
can imagine breaking this up

00:41:46.340 --> 00:41:50.960
into not n over two chunks,
but n over three chunks.

00:41:50.960 --> 00:41:54.880
Why don't I just break
up x into the top third,

00:41:54.880 --> 00:41:57.280
the middle third, and
then the bottom third,

00:41:57.280 --> 00:41:59.710
and then try and see
if I can get away

00:41:59.710 --> 00:42:02.760
with fewer than eight
multiplications?

00:42:02.760 --> 00:42:05.310
Because the original
thing would have

00:42:05.310 --> 00:42:07.340
taken eight, and if I
can do less than eight,

00:42:07.340 --> 00:42:10.952
maybe I can reduce
that 1.58 number.

00:42:10.952 --> 00:42:12.410
So that's a little
bit of a preview

00:42:12.410 --> 00:42:14.420
for what we'll do next time.

00:42:14.420 --> 00:42:18.480
But what I'd like
to do is do a demo.

00:42:18.480 --> 00:42:22.240
And I want you to run
that-- it's out there so

00:42:22.240 --> 00:42:25.920
blank that out for a second.

00:42:25.920 --> 00:42:31.300
What I'd like to do is really
look at a different problem

00:42:31.300 --> 00:42:35.780
than square root of 2, and
show you a demo of code

00:42:35.780 --> 00:42:42.810
that Victor wrote that computes
this particular quantity that,

00:42:42.810 --> 00:42:48.060
you would argue, is irrational,
to arbitrary digits.

00:42:48.060 --> 00:42:50.760
Though we'll probably only go
up to about a thousand today.

00:42:50.760 --> 00:42:54.580
And if we just look at-- root
2 is kind of boring, right?

00:42:54.580 --> 00:42:56.530
It's been around for a while.

00:42:56.530 --> 00:43:02.530
Let's go back and remember
high school geometry.

00:43:02.530 --> 00:43:05.150
So I think your
high school teachers

00:43:05.150 --> 00:43:08.240
would like this lecture.

00:43:08.240 --> 00:43:09.520
Nice little review.

00:43:09.520 --> 00:43:11.610
So what is that about?

00:43:11.610 --> 00:43:14.840
That's supposed to be a circle,
I think, as you've forgotten.

00:43:14.840 --> 00:43:17.250
That's supposed to be a circle.

00:43:17.250 --> 00:43:22.910
And the circle here is
a really big circle.

00:43:22.910 --> 00:43:25.000
It's a trillion units long.

00:43:27.670 --> 00:43:31.770
I'm into big numbers
today, big numbers.

00:43:31.770 --> 00:43:37.840
And the center of the
circle is c, c for center.

00:43:37.840 --> 00:43:40.870
That is what's called a radius,
in case you'd forgotten.

00:43:43.410 --> 00:43:44.890
And that's b.

00:43:44.890 --> 00:43:50.160
And this is also a
radius, and that's a.

00:43:50.160 --> 00:43:52.065
And what I'm going
to do is I'm going--

00:43:52.065 --> 00:44:01.450
I want to make a drop a little,
I guess, perpendicular down,

00:44:01.450 --> 00:44:03.910
which is one unit high.

00:44:03.910 --> 00:44:06.590
So the way that
this is structured

00:44:06.590 --> 00:44:09.600
is that this is one unit
high, this obviously

00:44:09.600 --> 00:44:13.241
is-- someone tell
me what that is, CB.

00:44:13.241 --> 00:44:14.642
AUDIENCE: [INAUDIBLE].

00:44:14.642 --> 00:44:16.630
PROFESSOR: Half a trillion.

00:44:16.630 --> 00:44:18.510
That's half a trillion.

00:44:18.510 --> 00:44:21.600
And obviously, CA
is half a trillion.

00:44:21.600 --> 00:44:24.900
And if I call this
D, somebody who

00:44:24.900 --> 00:44:28.950
remembers high school or
middle school geometry

00:44:28.950 --> 00:44:31.130
give me an equation for AD.

00:44:31.130 --> 00:44:34.910
And that's definitely
worth a cushion.

00:44:34.910 --> 00:44:37.860
so what's an
equation for AD guys?

00:44:37.860 --> 00:44:38.360
Yeah.

00:44:38.360 --> 00:44:39.480
Go ahead.

00:44:39.480 --> 00:44:43.710
AUDIENCE: The radius,
half-trillion minus the square

00:44:43.710 --> 00:44:45.600
root of--

00:44:45.600 --> 00:44:47.070
PROFESSOR: Square
root of-- Yeah?

00:44:47.070 --> 00:44:52.104
AUDIENCE: Minus the square root
of [INAUDIBLE] square minus 1?

00:44:52.104 --> 00:44:53.270
PROFESSOR: Perfect, perfect.

00:44:53.270 --> 00:44:54.040
OK good.

00:44:54.040 --> 00:44:57.870
So AD equals AC
minus CD, and that

00:44:57.870 --> 00:45:02.830
is going to be half a
trillion-- that is 500 billion,

00:45:02.830 --> 00:45:04.560
a little bit less
than bailout money,

00:45:04.560 --> 00:45:14.466
but it's close-- 500 thousand
minus square root of 500--

00:45:14.466 --> 00:45:16.382
this, when you start
squaring this, of course,

00:45:16.382 --> 00:45:19.730
is not even real,
real big money.

00:45:19.730 --> 00:45:25.400
But 500 thousand
squared minus 1.

00:45:25.400 --> 00:45:27.914
So forget the
square root of two.

00:45:27.914 --> 00:45:29.080
You can put the screen down.

00:45:32.110 --> 00:45:34.366
So is it on, the projector?

00:45:34.366 --> 00:45:36.387
AUDIENCE: It's on, it
just needs a [INAUDIBLE].

00:45:36.387 --> 00:45:36.970
PROFESSOR: OK.

00:45:36.970 --> 00:45:38.416
You can turn that on.

00:45:38.416 --> 00:45:39.166
AUDIENCE: Rolling.

00:45:41.190 --> 00:45:42.690
PROFESSOR: So what
we're going to do

00:45:42.690 --> 00:45:46.530
is, I'm just going to
show you the digits

00:45:46.530 --> 00:45:55.350
of this crazy quantity being
computed to tens of thousands

00:45:55.350 --> 00:45:56.430
of digits.

00:45:56.430 --> 00:46:00.160
And you argue that this
is it something clearly

00:46:00.160 --> 00:46:01.930
that isn't a perfect square.

00:46:01.930 --> 00:46:04.630
You took a perfect square,
subtracted 1 from it,

00:46:04.630 --> 00:46:06.610
and so you have an
irrational quantity

00:46:06.610 --> 00:46:08.720
that is going to go on and on.

00:46:08.720 --> 00:46:13.171
And let's see what that
number-- what it looks like.

00:46:13.171 --> 00:46:13.670
OK?

00:46:23.630 --> 00:46:24.804
Get out of the way.

00:46:28.316 --> 00:46:29.690
I hope you can
see from the back.

00:46:32.625 --> 00:46:33.666
AUDIENCE: Oh man, really?

00:46:38.650 --> 00:46:41.672
PROFESSOR: Looking pretty good
so far, looking pretty good.

00:46:41.672 --> 00:46:42.630
AUDIENCE: That's crazy.

00:46:47.640 --> 00:46:51.710
PROFESSOR: Somebody see
the numbers somewhere else?

00:46:51.710 --> 00:46:53.970
Have you see these
numbers before?

00:46:53.970 --> 00:46:59.240
Like 20 minutes ago, like
right in front of you?

00:46:59.240 --> 00:47:01.900
OK All right.

00:47:01.900 --> 00:47:05.990
So I think that's a
good place to stop.

00:47:05.990 --> 00:47:08.870
If you want an
explanation for this

00:47:08.870 --> 00:47:11.990
I think you can go
to section tomorrow.

00:47:11.990 --> 00:47:14.880
I'm going to use a some
attendance tomorrow.

00:47:14.880 --> 00:47:16.140
All right.

00:47:16.140 --> 00:47:20.610
Happy to answer questions
about the rest of the lecture,

00:47:20.610 --> 00:47:23.060
and thanks for coming.

