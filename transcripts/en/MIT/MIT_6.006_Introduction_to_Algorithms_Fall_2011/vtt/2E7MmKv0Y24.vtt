WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:01.800
The following
content is provided

00:00:01.800 --> 00:00:04.040
under a Creative
Commons license.

00:00:04.040 --> 00:00:06.880
Your support will help MIT
OpenCourseWare continue

00:00:06.880 --> 00:00:10.740
to offer high quality
educational resources for free.

00:00:10.740 --> 00:00:13.350
To make a donation, or
view additional materials

00:00:13.350 --> 00:00:17.237
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.237 --> 00:00:17.862
at ocw.mit.edu.

00:00:22.460 --> 00:00:24.510
PROFESSOR: Good
morning, everyone.

00:00:24.510 --> 00:00:26.740
Let's get started
on lecture number

00:00:26.740 --> 00:00:30.580
two of four lecture
sequences of shortest paths.

00:00:30.580 --> 00:00:34.220
So, last time, we talked
about a general structure

00:00:34.220 --> 00:00:37.160
for a shortest path algorithm.

00:00:37.160 --> 00:00:40.022
Today, we'll actually look
at a concrete algorithm

00:00:40.022 --> 00:00:40.980
that's due to Dijkstra.

00:00:43.990 --> 00:00:45.960
Before we get to
that, I want to do

00:00:45.960 --> 00:00:49.610
a little bit of a
review of the concepts

00:00:49.610 --> 00:00:54.450
that we covered in
the lecture last week.

00:00:54.450 --> 00:00:56.590
In particular, we
talked about this notion

00:00:56.590 --> 00:00:59.425
of relaxation, which is
a fundamental operation

00:00:59.425 --> 00:01:01.630
in all shortest path algorithms.

00:01:01.630 --> 00:01:03.680
And I want to go
over that again.

00:01:03.680 --> 00:01:06.020
We look at a couple
of special cases

00:01:06.020 --> 00:01:10.080
today, with respect to
algorithms for shortest paths.

00:01:10.080 --> 00:01:13.440
We look at a Directed
Acyclic Graph.

00:01:13.440 --> 00:01:17.430
Then your graph has
no cycles in it.

00:01:17.430 --> 00:01:22.770
Regardless of whether you
have negative edges or not,

00:01:22.770 --> 00:01:24.440
there's a
straightforward algorithm

00:01:24.440 --> 00:01:28.760
that we look at to find
shortest paths and DAGs.

00:01:28.760 --> 00:01:30.770
And then, we'll
focus in on the case

00:01:30.770 --> 00:01:32.660
where there are
no negative edges.

00:01:32.660 --> 00:01:35.970
And talk about
Dijkstra's algorithm.

00:01:35.970 --> 00:01:43.190
So, to start with
the review, here's,

00:01:43.190 --> 00:01:46.330
really, a trivial
example of a graph

00:01:46.330 --> 00:01:50.000
that we want to compute
the shortest paths on.

00:01:50.000 --> 00:01:56.780
And the numbers that are
inside these vertices

00:01:56.780 --> 00:01:58.320
are our priority values.

00:01:58.320 --> 00:02:09.720
So, think of d of v as the
length of the current shortest

00:02:09.720 --> 00:02:16.250
path from the source, s, to v.

00:02:16.250 --> 00:02:22.900
And, given the source, s, the
length to the source is 0.

00:02:22.900 --> 00:02:24.130
So d of s is 0.

00:02:24.130 --> 00:02:26.590
It starts at 0 and ends at 0.

00:02:26.590 --> 00:02:29.940
And other ones, I
initialized to infinity.

00:02:29.940 --> 00:02:35.180
And through this process
that we call relaxation,

00:02:35.180 --> 00:02:40.770
we can generally
reduce these d values,

00:02:40.770 --> 00:02:42.930
that are the lengths of
the current shortest paths,

00:02:42.930 --> 00:02:47.025
down to what we call
the delta values.

00:02:49.610 --> 00:02:53.790
Which is the length
of our shortest path.

00:02:57.030 --> 00:02:57.945
It may be unique.

00:02:57.945 --> 00:02:59.750
It may not be unique.

00:02:59.750 --> 00:03:02.280
But you have to get
the minimum value.

00:03:02.280 --> 00:03:09.330
And then, all of the vertices
have convergent values

00:03:09.330 --> 00:03:11.710
of d that converge to delta.

00:03:11.710 --> 00:03:14.120
Then, your algorithm is done.

00:03:14.120 --> 00:03:19.490
And one last thing that is
important to reconstruct

00:03:19.490 --> 00:03:26.900
the path is the notion
of a predecessor and pi v

00:03:26.900 --> 00:03:36.530
is the predecessor of v in
the shortest path from s

00:03:36.530 --> 00:03:44.180
to v. And you can
follow this predecessor

00:03:44.180 --> 00:03:46.810
chain to reconstruct
the shortest path,

00:03:46.810 --> 00:03:51.560
once you've converged,
and all of the values

00:03:51.560 --> 00:03:57.140
are down to the delta s comma
v. So, in this trivial example,

00:03:57.140 --> 00:04:04.580
you start with d of s being 0, d
of a and d of b being infinity.

00:04:04.580 --> 00:04:10.560
Let's put on it a
few weights here.

00:04:10.560 --> 00:04:13.520
And what you do is
potentially relax

00:04:13.520 --> 00:04:16.510
the edges that go out of s.

00:04:16.510 --> 00:04:19.489
And this notion of relaxation,
that I'll write out formally

00:04:19.489 --> 00:04:21.940
in a minute-- we
looked at it last time,

00:04:21.940 --> 00:04:24.180
is a process of
following this edge,

00:04:24.180 --> 00:04:26.710
and updating the d of a value.

00:04:26.710 --> 00:04:30.140
And this infinity becomes
1 because you say, well,

00:04:30.140 --> 00:04:33.590
if I start here with 0 and
I add 1 to it, I get 1 here.

00:04:33.590 --> 00:04:35.830
Similarly, this
infinity becomes 3.

00:04:35.830 --> 00:04:38.100
And, at this point,
you've relaxed the edges

00:04:38.100 --> 00:04:43.040
that go out of s two these
other two nodes, a and b.

00:04:43.040 --> 00:04:45.532
You're not quite done yet.

00:04:45.532 --> 00:04:49.770
At this point, you could imagine
that, at least in this example,

00:04:49.770 --> 00:04:52.350
you found the shortest
path to the vertex a.

00:04:52.350 --> 00:04:57.940
But it is, in fact, a path
of length, 2, to vertex b.

00:04:57.940 --> 00:05:01.540
Right now, we think that the
the current shortest path to b,

00:05:01.540 --> 00:05:05.500
after the first step of
relaxing the edges from s,

00:05:05.500 --> 00:05:06.720
happens to be 3.

00:05:06.720 --> 00:05:13.360
But if you go like so,
then you end up with the 2.

00:05:13.360 --> 00:05:15.790
And, at this point, you're done.

00:05:15.790 --> 00:05:20.380
Now we have to prove that any
particular algorithm we put up

00:05:20.380 --> 00:05:24.760
is going to converge to the
delta values, and the algorithm

00:05:24.760 --> 00:05:25.374
to terminate.

00:05:25.374 --> 00:05:27.790
And then, we have to worry
about the asymptotic complexity

00:05:27.790 --> 00:05:28.930
of the algorithm.

00:05:28.930 --> 00:05:31.060
But that's the
general overall flow.

00:05:31.060 --> 00:05:34.060
And we look at, as I said,
two algorithms today.

00:05:34.060 --> 00:05:35.520
Both special cases.

00:05:35.520 --> 00:05:38.380
One for DAGs and one
for non-negative edges.

00:05:38.380 --> 00:05:41.430
And we'll go through, and
maybe not do a formal proof,

00:05:41.430 --> 00:05:44.320
but suddenly give you
a strong intuition

00:05:44.320 --> 00:05:46.990
as to why these algorithms work.

00:05:46.990 --> 00:05:52.750
Any questions about
this material?

00:05:52.750 --> 00:05:54.920
OK.

00:05:54.920 --> 00:05:58.220
So, what I want
to do is give you

00:05:58.220 --> 00:06:04.770
a sense for why this
relaxation step is useful.

00:06:04.770 --> 00:06:08.470
But also, importantly,
safe, or correct.

00:06:08.470 --> 00:06:15.220
And recall that our basic
relaxation operation, which

00:06:15.220 --> 00:06:19.740
we did over here, as we
updated the infinity value to 1

00:06:19.740 --> 00:06:24.100
and the 3 value to 2, et
cetera, looks like this.

00:06:24.100 --> 00:06:33.510
It says, if d of v is greater
than d of u plus w u,v. Then,

00:06:33.510 --> 00:06:40.100
I'm going to update d of v
to be d of u plus w u, v.

00:06:40.100 --> 00:06:44.070
You found a better way
of reaching vertex v.

00:06:44.070 --> 00:06:44.895
A shorter way.

00:06:48.560 --> 00:06:51.920
And this way happens to be
going through the vertex, u.

00:06:51.920 --> 00:06:55.330
So you update not only the
priority value, but also

00:06:55.330 --> 00:06:57.450
the predecessor relationship.

00:06:57.450 --> 00:06:57.950
All right?

00:06:57.950 --> 00:06:59.940
That's the relaxation step.

00:06:59.940 --> 00:07:04.805
Now, I want to be able to
show that relaxation is safe.

00:07:10.200 --> 00:07:11.760
What do I mean by that?

00:07:11.760 --> 00:07:16.470
Well, I want to make sure
that I never relax an edge

00:07:16.470 --> 00:07:18.490
and somehow do
something wrong, which

00:07:18.490 --> 00:07:23.320
gets me a value that's
less than delta s v.

00:07:23.320 --> 00:07:25.880
I want to be able to
converge from the top.

00:07:25.880 --> 00:07:28.840
I want to be able to start
with these infinity values

00:07:28.840 --> 00:07:31.660
because I don't have a path
to this particular vertex,

00:07:31.660 --> 00:07:35.700
and continually reduce the
values of the priorities.

00:07:35.700 --> 00:07:39.459
And then get down to delta, the
correct values, and don't go,

00:07:39.459 --> 00:07:40.750
I don't want to go any further.

00:07:40.750 --> 00:07:41.470
All right?

00:07:41.470 --> 00:07:44.130
Because, if I get below,
then you're talking about,

00:07:44.130 --> 00:07:46.170
essentially, you may
be able to get back up,

00:07:46.170 --> 00:07:49.630
but that is not the kind
of algorithm that we want.

00:07:49.630 --> 00:07:51.960
At least, algorithms
we look at here.

00:07:51.960 --> 00:07:53.930
And that is dangerous.

00:07:53.930 --> 00:07:56.850
So we want relaxation
to be safe.

00:07:56.850 --> 00:08:02.510
And we can fairly easily
prove a simple lemma,

00:08:02.510 --> 00:08:10.280
using induction, that
says that the relaxation

00:08:10.280 --> 00:08:13.690
operation-- and
it doesn't matter

00:08:13.690 --> 00:08:15.690
what sequence you relax things.

00:08:15.690 --> 00:08:17.595
This is a fairly
powerful lemma that

00:08:17.595 --> 00:08:20.850
says that if you have an
algorithm that uses relaxation,

00:08:20.850 --> 00:08:25.850
and that's the only way of
updating these d values,

00:08:25.850 --> 00:08:27.560
then it's safe.

00:08:27.560 --> 00:08:30.934
You're not going to get a
wrong, shortest path value.

00:08:30.934 --> 00:08:32.350
Either at the end
of the algorithm

00:08:32.350 --> 00:08:35.299
or at any time during the
running, or the execution,

00:08:35.299 --> 00:08:36.410
of this algorithm.

00:08:36.410 --> 00:08:36.909
OK?

00:08:36.909 --> 00:08:39.890
So the relaxation
operation algorithm

00:08:39.890 --> 00:08:53.160
maintains the
invariant that d of v

00:08:53.160 --> 00:09:02.310
is greater than or equal to
delta s, v for all vertices.

00:09:02.310 --> 00:09:03.230
OK?

00:09:03.230 --> 00:09:05.376
So that's a powerful lemma.

00:09:05.376 --> 00:09:07.250
It's a fairly straightforward
lemma to prove.

00:09:07.250 --> 00:09:09.750
But it's an important lemma.

00:09:09.750 --> 00:09:13.330
It tells us that we can
create the generic structure

00:09:13.330 --> 00:09:16.480
of the shortest path algorithm
that I talked about last week.

00:09:16.480 --> 00:09:19.370
It says, pick an edge.

00:09:19.370 --> 00:09:20.311
Relax it.

00:09:20.311 --> 00:09:21.060
Pick another edge.

00:09:21.060 --> 00:09:21.997
Relax it.

00:09:21.997 --> 00:09:23.580
And hopefully
everything will work out

00:09:23.580 --> 00:09:25.480
and you'll get
your delta values.

00:09:25.480 --> 00:09:28.927
And what this lemma
says is, you'll

00:09:28.927 --> 00:09:30.510
never get something
in the middle that

00:09:30.510 --> 00:09:32.500
is less than your
shortest path value.

00:09:32.500 --> 00:09:35.780
And if you keep running
over for long enough time,

00:09:35.780 --> 00:09:37.440
depending on the
particular heuristic

00:09:37.440 --> 00:09:39.560
that you use for
selecting the edges,

00:09:39.560 --> 00:09:41.570
your algorithm will
eventually terminate.

00:09:41.570 --> 00:09:46.740
And, hopefully, it'll
run in polynomial time.

00:09:46.740 --> 00:09:50.500
So, how do we prove this?

00:09:50.500 --> 00:09:52.620
I'm going to do
about half of it,

00:09:52.620 --> 00:09:56.160
then try and get
you to finish it.

00:09:56.160 --> 00:10:04.640
So it's by induction
on the number of steps,

00:10:04.640 --> 00:10:14.920
in the sense that we are going
to essentially assume that d

00:10:14.920 --> 00:10:23.950
of u is greater than
or equal to delta s,u.

00:10:23.950 --> 00:10:28.850
And we're going to do
this relaxation operation.

00:10:28.850 --> 00:10:33.235
So it's like a base case
is that this is correct.

00:10:36.680 --> 00:10:43.450
And now we want to show that
the relaxation operation doesn't

00:10:43.450 --> 00:10:47.090
make d of v incorrect.

00:10:47.090 --> 00:10:52.025
So, that's the
inductive hypothesis.

00:10:54.660 --> 00:11:00.680
Now, we can say by the
triangle inequality

00:11:00.680 --> 00:11:05.590
that I talked about late
in last week's lecture,

00:11:05.590 --> 00:11:12.050
you have delta s, v less than
or equal to delta s comma

00:11:12.050 --> 00:11:17.660
u plus delta u comma
v. And what is that?

00:11:17.660 --> 00:11:26.670
Well, that just says, if I
have something like this,

00:11:26.670 --> 00:11:30.340
that I have s.

00:11:30.340 --> 00:11:35.570
Let's call this u and v.

00:11:35.570 --> 00:11:38.970
This is not an edge between
s and v. It's a path.

00:11:38.970 --> 00:11:40.340
It could be a single edge.

00:11:40.340 --> 00:11:42.600
But we think of this
as a path between s

00:11:42.600 --> 00:11:47.030
and v. This is a
path between s and u.

00:11:47.030 --> 00:11:50.890
This is a path between u and v.

00:11:50.890 --> 00:11:57.780
And, in particular,
if there's a way

00:11:57.780 --> 00:12:08.640
of getting from s to u and u
to v that happens to be shorter

00:12:08.640 --> 00:12:12.980
then the best way of
getting from s to v,

00:12:12.980 --> 00:12:14.831
well, that's a contradiction.

00:12:14.831 --> 00:12:15.330
OK?

00:12:15.330 --> 00:12:21.270
Because this is the shortest
way of getting from s to v.

00:12:21.270 --> 00:12:23.600
And it has no constraints
over the number of edges

00:12:23.600 --> 00:12:26.750
that it incorporates.

00:12:26.750 --> 00:12:28.730
And so, by definition,
the shortest way

00:12:28.730 --> 00:12:31.140
of getting from s to v is
either some direct way.

00:12:31.140 --> 00:12:32.460
Maybe there's a single edge.

00:12:32.460 --> 00:12:36.611
Or it may go through
this vertex, u.

00:12:36.611 --> 00:12:37.110
All right?

00:12:37.110 --> 00:12:39.890
So that's the
triangle inequality.

00:12:39.890 --> 00:12:44.160
Notice that, what I
have here, is something

00:12:44.160 --> 00:12:50.670
where going from s,
to a, to b is actually

00:12:50.670 --> 00:12:53.062
shorter than going from s to b.

00:12:53.062 --> 00:12:55.020
But these are single
edges we're talking about.

00:12:55.020 --> 00:12:56.220
These are weights
we're talking about.

00:12:56.220 --> 00:12:57.880
And there's no
contradiction here

00:12:57.880 --> 00:13:01.930
because all this says is
that, what I want to see here

00:13:01.930 --> 00:13:07.470
is delta s comma b
is going to be 2.

00:13:07.470 --> 00:13:08.840
OK?

00:13:08.840 --> 00:13:11.310
Initially, I may be starting
out with infinity and 3

00:13:11.310 --> 00:13:12.900
for the d values.

00:13:12.900 --> 00:13:15.160
But the delta value,
which is the shortest way

00:13:15.160 --> 00:13:17.510
of getting to b,
happens to go through a.

00:13:17.510 --> 00:13:20.150
And so, if you use that,
then the triangle inequality

00:13:20.150 --> 00:13:21.060
makes sense.

00:13:21.060 --> 00:13:23.940
So don't get confused
when you see pictures

00:13:23.940 --> 00:13:29.020
like this, where the weights
don't obey the triangle

00:13:29.020 --> 00:13:30.040
inequality.

00:13:30.040 --> 00:13:33.680
The triangle inequality has to
do with the shortest paths, not

00:13:33.680 --> 00:13:35.101
the single edge ways.

00:13:35.101 --> 00:13:35.600
OK?

00:13:38.410 --> 00:13:42.320
So, that's half the proof here.

00:13:42.320 --> 00:13:46.790
What I've done is assumed
that d of u is correct.

00:13:46.790 --> 00:13:50.060
And I've used the
triangle inequality.

00:13:50.060 --> 00:13:51.680
And I've just written this down.

00:13:51.680 --> 00:13:58.200
Now, someone do the last step,
or the second to last step,

00:13:58.200 --> 00:13:59.730
of this proof.

00:13:59.730 --> 00:14:00.230
Anybody?

00:14:03.100 --> 00:14:05.800
What can I say now, given
that what I have here.

00:14:05.800 --> 00:14:09.080
Look at these two values.

00:14:09.080 --> 00:14:12.620
What can I say
about these values?

00:14:12.620 --> 00:14:14.520
How can I prove what
I want to prove,

00:14:14.520 --> 00:14:19.750
which is, basically, delta of
s comma v should be less than

00:14:19.750 --> 00:14:21.560
or equal to d of v?

00:14:21.560 --> 00:14:22.190
OK.

00:14:22.190 --> 00:14:24.680
That's what I want to show.

00:14:24.680 --> 00:14:26.780
I've just written
another way here.

00:14:26.780 --> 00:14:27.510
How do I do that?

00:14:30.946 --> 00:14:31.446
Anyone?

00:14:36.380 --> 00:14:45.810
What can I substitute for--
there's a less than operator,

00:14:45.810 --> 00:14:48.830
which means that I can
replace things over here.

00:14:48.830 --> 00:14:49.635
Yeah.

00:14:49.635 --> 00:14:53.017
AUDIENCE: If you, like,
you have a [INAUDIBLE]?

00:14:53.017 --> 00:14:53.600
PROFESSOR: Ah.

00:14:53.600 --> 00:14:54.100
Excellent.

00:14:54.100 --> 00:14:59.260
So the first thing is, I could
put d of u over here, right?

00:14:59.260 --> 00:15:04.150
Less than or equal to d of u.

00:15:04.150 --> 00:15:06.770
And the reason I can do
that is because d of u

00:15:06.770 --> 00:15:09.540
is greater then delta s comma u.

00:15:09.540 --> 00:15:13.070
So that's cool, right?

00:15:13.070 --> 00:15:13.690
Sorry, delta.

00:15:13.690 --> 00:15:14.680
Thank you.

00:15:14.680 --> 00:15:15.900
Delta s comma u.

00:15:15.900 --> 00:15:16.960
Thank you.

00:15:16.960 --> 00:15:18.630
And so, that's what I got here.

00:15:18.630 --> 00:15:20.040
What else?

00:15:20.040 --> 00:15:20.540
Yeah?

00:15:20.540 --> 00:15:24.074
AUDIENCE: You replace
delta u, v with w u, v.

00:15:24.074 --> 00:15:25.990
PROFESSOR: I can replace
delta u, v with w, u,

00:15:25.990 --> 00:15:28.710
v. Exactly right.

00:15:28.710 --> 00:15:29.720
Exactly right.

00:15:29.720 --> 00:15:30.320
Great.

00:15:30.320 --> 00:15:31.560
That deserves a cushion.

00:15:31.560 --> 00:15:33.420
I think you already have one.

00:15:33.420 --> 00:15:35.041
Yep.

00:15:35.041 --> 00:15:35.540
Oh, man.

00:15:35.540 --> 00:15:39.030
I should have not-- so you
get that because I messed up.

00:15:39.030 --> 00:15:40.930
Seems like you
need to get-- whoa.

00:15:40.930 --> 00:15:41.510
Hey.

00:15:41.510 --> 00:15:42.520
OK.

00:15:42.520 --> 00:15:44.270
You get one because I
hit you on the head.

00:15:44.270 --> 00:15:45.190
All right.

00:15:45.190 --> 00:15:46.440
And this time, I'll just save.

00:15:46.440 --> 00:15:47.814
I'm running out
of cushions here.

00:15:47.814 --> 00:15:51.890
But I've got some in my office.

00:15:51.890 --> 00:15:52.710
All right.

00:15:52.710 --> 00:15:53.270
So that's it.

00:15:53.270 --> 00:15:54.860
That's the proof.

00:15:54.860 --> 00:15:56.032
OK?

00:15:56.032 --> 00:15:56.990
Fairly straightforward.

00:15:59.860 --> 00:16:04.290
You get to the
point where you want

00:16:04.290 --> 00:16:07.000
to apply the
triangle inequality.

00:16:07.000 --> 00:16:12.990
You simply look at each of
these terms and, by induction

00:16:12.990 --> 00:16:16.350
hypothesis, you
could put d,u here.

00:16:16.350 --> 00:16:18.500
And, I just talked
about the weights,

00:16:18.500 --> 00:16:20.480
and so on, and so forth.

00:16:20.480 --> 00:16:23.630
And you know that w u,v,
which is a direct way,

00:16:23.630 --> 00:16:29.640
a single edge way,
of getting to a node,

00:16:29.640 --> 00:16:33.550
has to be greater than
the shortest path.

00:16:33.550 --> 00:16:36.290
Like here, this 3
value is a direct way

00:16:36.290 --> 00:16:38.520
of getting from s to b.

00:16:38.520 --> 00:16:41.210
And, in this case, it's
greater than the shortest

00:16:41.210 --> 00:16:42.770
path, which is of length 2.

00:16:42.770 --> 00:16:45.710
But it can never be smaller
than the shortest path.

00:16:45.710 --> 00:16:51.250
And so, once we have that
here, we can essentially say,

00:16:51.250 --> 00:16:55.010
we know that delta s, v is less
than or equal to d u plus d v.

00:16:55.010 --> 00:16:57.530
Which implies, of course,
that this is simply--

00:16:57.530 --> 00:17:00.040
once we are done with the
relaxation step-- that

00:17:00.040 --> 00:17:07.630
equals d v. This part
here equals d v. OK?

00:17:07.630 --> 00:17:09.440
That's how that works.

00:17:09.440 --> 00:17:11.150
So that's good news.

00:17:11.150 --> 00:17:15.276
We have a relaxation
algorithm that is safe.

00:17:15.276 --> 00:17:16.650
We can now
arbitrarily, and we'll

00:17:16.650 --> 00:17:21.520
do this for all of algorithms
we look at, really.

00:17:21.520 --> 00:17:23.980
At least in 006,
for shortest paths.

00:17:23.980 --> 00:17:27.560
Which applies some
sequence of relaxations.

00:17:27.560 --> 00:17:31.516
And, depending on the
special case of the problem,

00:17:31.516 --> 00:17:33.640
we're going to apply these
things in different ways

00:17:33.640 --> 00:17:36.310
to get the most
efficient algorithm.

00:17:36.310 --> 00:17:37.200
All right?

00:17:37.200 --> 00:17:40.890
So, we can now do algorithms.

00:17:40.890 --> 00:17:43.715
Let's look at DAGs first.

00:17:53.670 --> 00:17:58.390
So, DAG stands for
Directed Acyclic Graphs.

00:17:58.390 --> 00:18:08.430
So that means we
can't have cycles.

00:18:08.430 --> 00:18:10.310
So we can't have
negative cycles.

00:18:10.310 --> 00:18:13.410
So that's why this is an
interesting special case.

00:18:13.410 --> 00:18:15.470
It makes things a
little bit easier for us

00:18:15.470 --> 00:18:18.390
because we don't have to
worry about negative cycles.

00:18:18.390 --> 00:18:20.280
We're actually going
to look at DAGs

00:18:20.280 --> 00:18:22.275
that have negative
edges in them.

00:18:22.275 --> 00:18:22.820
All right?

00:18:22.820 --> 00:18:26.090
So, we're allowed to have
negative edges in these DAGs.

00:18:26.090 --> 00:18:27.730
But we don't have
negative cycles.

00:18:27.730 --> 00:18:29.284
And, as I said
last time, it's not

00:18:29.284 --> 00:18:30.950
the negative edges
that cause a problem.

00:18:30.950 --> 00:18:34.266
If you only go through
at negative edge once,

00:18:34.266 --> 00:18:35.640
you can just
subtract that value.

00:18:35.640 --> 00:18:36.910
And it's cool.

00:18:36.910 --> 00:18:38.960
It's only when you
get into a situation

00:18:38.960 --> 00:18:41.370
where you're going
through a negative edge,

00:18:41.370 --> 00:18:42.360
a negative cycle.

00:18:42.360 --> 00:18:45.960
And you can just iterate through
them to get to minus infinity.

00:18:45.960 --> 00:18:49.840
And you have an indeterminate
shortest path value.

00:18:49.840 --> 00:18:54.320
So the way this is going
to work-- if you ever

00:18:54.320 --> 00:18:56.820
have a DAG, by the way, the
first thing you want to try--

00:18:56.820 --> 00:18:58.820
and this is certainly
true in your problem set--

00:18:58.820 --> 00:19:01.840
when there's a question, try
to topologically sort it.

00:19:01.840 --> 00:19:02.430
OK?

00:19:02.430 --> 00:19:05.550
It's a fine hammer to
use, when you have a DAG.

00:19:05.550 --> 00:19:11.690
And it's not an exception here.

00:19:11.690 --> 00:19:13.500
To do shortest
paths, we're going

00:19:13.500 --> 00:19:17.760
to topologically sort the DAG.

00:19:17.760 --> 00:19:32.770
And the path from u
to v implies that u

00:19:32.770 --> 00:19:37.500
is before v in the ordering.

00:19:41.820 --> 00:19:43.692
And, once you do that,
you have this linear.

00:19:43.692 --> 00:19:44.900
And I'll show you an example.

00:19:44.900 --> 00:19:46.510
You have this linear ordering.

00:19:46.510 --> 00:19:49.080
And we're just going to
go through, in order,

00:19:49.080 --> 00:19:51.162
from left to right,
relaxing these edges.

00:19:51.162 --> 00:19:52.620
And we're going to
get our shortest

00:19:52.620 --> 00:19:55.240
paths for all the vertices.

00:19:55.240 --> 00:20:01.080
So, the second and last step
is, one pass, left to right,

00:20:01.080 --> 00:20:07.460
over the vertices, in
topologically sorted order.

00:20:17.000 --> 00:20:20.570
And we're going to
relax each edge that

00:20:20.570 --> 00:20:22.124
leaves the particular
vertex we are

00:20:22.124 --> 00:20:23.290
trying to process right now.

00:20:32.940 --> 00:20:36.990
And so, we know topological
sorting is order v plus e,

00:20:36.990 --> 00:20:38.660
includes depth-first search.

00:20:38.660 --> 00:20:41.460
And this pass over the vertices,
you're touching each vertex.

00:20:41.460 --> 00:20:44.490
And you're touching every edge
a constant number of times.

00:20:44.490 --> 00:20:45.970
In this case, once.

00:20:45.970 --> 00:20:53.180
So this is our first special
case shortest path algorithm.

00:20:53.180 --> 00:20:55.920
And that takes
order v plus e time.

00:20:55.920 --> 00:20:57.010
All right?

00:20:57.010 --> 00:20:58.570
Why does this work?

00:20:58.570 --> 00:21:06.150
And just one little
interesting aspect

00:21:06.150 --> 00:21:09.570
of this, which is
related to a DAG.

00:21:09.570 --> 00:21:14.810
And the relationship between the
DAG and the particular starting

00:21:14.810 --> 00:21:17.230
vertex that we're
going to be looking at.

00:21:17.230 --> 00:21:20.500
So, this is an example.

00:21:20.500 --> 00:21:23.570
Suppose I have a DAG like this.

00:21:23.570 --> 00:21:26.720
And I marked this vertex as s.

00:21:26.720 --> 00:21:30.020
And I want to find the
shortest path from s

00:21:30.020 --> 00:21:33.330
to these other nodes
that are a and b.

00:21:33.330 --> 00:21:36.280
Well, they don't exist, right?

00:21:36.280 --> 00:21:40.170
So, in this case, I'm
going to have a shortest

00:21:40.170 --> 00:21:42.410
path to a being infinity
and shortest path to b

00:21:42.410 --> 00:21:43.710
being infinity.

00:21:43.710 --> 00:21:46.080
And this is a trivial example.

00:21:46.080 --> 00:21:48.330
So, this algorithm is general.

00:21:48.330 --> 00:21:51.730
It doesn't say anything about
what the starting vertex is.

00:21:51.730 --> 00:21:52.230
Right?

00:21:52.230 --> 00:21:55.300
It should work for any
choice of starting vertex.

00:21:55.300 --> 00:22:00.530
The nice thing is that you
can do the topological sort.

00:22:00.530 --> 00:22:05.460
And then you can commit to
what the starting vertex is.

00:22:05.460 --> 00:22:08.890
And you can go off, and you can
say, from this starting vertex,

00:22:08.890 --> 00:22:11.600
I'm going to go and
compute the shortest paths

00:22:11.600 --> 00:22:15.340
to the other vertices
that I can actually reach.

00:22:15.340 --> 00:22:16.050
OK?

00:22:16.050 --> 00:22:19.640
So let's say that you had
a DAG that looks like this.

00:22:19.640 --> 00:22:21.640
All right, once you've
topologically sorted it,

00:22:21.640 --> 00:22:27.087
you can always draw
a DAG in linear form.

00:22:27.087 --> 00:22:27.920
That's a nice thing.

00:22:37.912 --> 00:22:39.870
I'm going to put edge
weights down in a minute.

00:22:48.150 --> 00:22:48.650
All right.

00:22:48.650 --> 00:22:49.620
So that's my DAG.

00:22:52.880 --> 00:22:53.380
Let's see.

00:22:53.380 --> 00:23:04.160
5, 3, 2, 6, 7, 4,
2, minus 1, minus 2.

00:23:07.970 --> 00:23:09.240
So that's my DAG.

00:23:09.240 --> 00:23:12.840
And I've drawn it in
topologically sorted form.

00:23:12.840 --> 00:23:14.300
And I go left to right.

00:23:14.300 --> 00:23:19.080
Now, let's say that, at this
point, I get to step two.

00:23:19.080 --> 00:23:20.810
And I want to find
shortest paths.

00:23:20.810 --> 00:23:23.490
Now, I have to say,
what is my source?

00:23:23.490 --> 00:23:28.850
And, if I just happen to
have this as my source,

00:23:28.850 --> 00:23:31.160
well, there's
nothing to do here.

00:23:31.160 --> 00:23:33.440
There's no edges
that go out of this.

00:23:33.440 --> 00:23:36.510
And so that means that
everything to the left of me

00:23:36.510 --> 00:23:37.930
is infinity.

00:23:37.930 --> 00:23:38.740
OK?

00:23:38.740 --> 00:23:40.590
So the first thing
that you do is,

00:23:40.590 --> 00:23:44.180
you say, find the
source that corresponds

00:23:44.180 --> 00:23:46.790
to the starting vertex.

00:23:46.790 --> 00:23:50.210
And let's say, this is the
starting vertex, in this case.

00:23:50.210 --> 00:23:53.900
Which I'll mark in bold.

00:23:53.900 --> 00:23:55.120
So that's my starting vertex.

00:23:55.120 --> 00:23:57.060
I'll take a nontrivial case.

00:23:57.060 --> 00:23:59.570
And everything to
the left is going

00:23:59.570 --> 00:24:02.980
to get marked with infinity.

00:24:02.980 --> 00:24:07.020
And now, I've got to do
some work on relaxation.

00:24:07.020 --> 00:24:10.080
And I'm not going to get
the shortest path instantly

00:24:10.080 --> 00:24:14.530
for a particular vertex, once
I get to it, because there

00:24:14.530 --> 00:24:16.250
may be better ways
of getting there.

00:24:16.250 --> 00:24:18.350
And especially if I
have negative edges.

00:24:18.350 --> 00:24:21.970
And that's certainly possible,
that a longer length path

00:24:21.970 --> 00:24:24.230
is going to be
the shortest path.

00:24:24.230 --> 00:24:27.020
But what I'll do is take s.

00:24:27.020 --> 00:24:30.610
And I'm going to relax
edges that emanate from s.

00:24:30.610 --> 00:24:32.520
And so, step one,
all of these are

00:24:32.520 --> 00:24:34.350
going to be infinity
to start with.

00:24:34.350 --> 00:24:35.910
So everything is infinity.

00:24:35.910 --> 00:24:37.780
The ones to the
left stay infinity.

00:24:37.780 --> 00:24:40.500
The ones to the right are
going to be reachable.

00:24:40.500 --> 00:24:47.110
And you're going to
update those values.

00:24:47.110 --> 00:24:51.230
And so, when you go
like so, this becomes 2.

00:24:51.230 --> 00:24:52.970
This becomes 6.

00:24:52.970 --> 00:24:54.350
As I follow that.

00:24:54.350 --> 00:24:58.940
And I'm done with
this vertex, s.

00:24:58.940 --> 00:25:00.160
And this is what I have.

00:25:00.160 --> 00:25:01.310
2 and 6.

00:25:01.310 --> 00:25:04.560
So the next step is
to get to this vertex.

00:25:04.560 --> 00:25:06.770
Let's call that the vertex a.

00:25:06.770 --> 00:25:09.900
And I'm going relax the
edges going out of a.

00:25:09.900 --> 00:25:14.560
And, when I go out
of a, I get 2 plus 7

00:25:14.560 --> 00:25:17.010
is 9, which is greater than 6.

00:25:17.010 --> 00:25:19.260
So there's no reason
to update that.

00:25:19.260 --> 00:25:22.840
2 plus 4 is less than infinity.

00:25:22.840 --> 00:25:26.750
And so, that's 6.

00:25:26.750 --> 00:25:31.140
2 plus 2 gives me 4 here.

00:25:31.140 --> 00:25:32.740
And so on and so forth.

00:25:32.740 --> 00:25:34.710
So then, now I'm
done with vertex a.

00:25:34.710 --> 00:25:39.020
If this vertex is b, then I
have a value of 6 for this.

00:25:39.020 --> 00:25:42.255
And 6 minus 1 is less than 6.

00:25:42.255 --> 00:25:44.810
So this becomes 5.

00:25:44.810 --> 00:25:49.930
And 5 minus 2-- well, that's
the next step after that.

00:25:49.930 --> 00:25:52.630
I haven't put-- this is a 1.

00:25:52.630 --> 00:25:55.717
And so 6 plus 1 is 7.

00:25:55.717 --> 00:25:56.800
But that's greater than 4.

00:25:56.800 --> 00:25:58.870
So we don't have
to anything there.

00:25:58.870 --> 00:26:05.410
So the final values that I end
up getting are 3 for this one.

00:26:05.410 --> 00:26:07.230
So this is the final value.

00:26:07.230 --> 00:26:09.840
5 is the final value here.

00:26:09.840 --> 00:26:12.090
6 is the final value here.

00:26:12.090 --> 00:26:14.020
2 is the final value here.

00:26:14.020 --> 00:26:15.650
And that one is 0.

00:26:15.650 --> 00:26:17.460
And this stays infinity.

00:26:17.460 --> 00:26:18.470
OK?

00:26:18.470 --> 00:26:20.680
So fairly straightforward.

00:26:20.680 --> 00:26:22.560
Do a topological sort.

00:26:22.560 --> 00:26:24.180
Find the starting point.

00:26:24.180 --> 00:26:27.130
And then run all the
way to the right.

00:26:27.130 --> 00:26:30.580
Interestingly, this is actually
a really simple example

00:26:30.580 --> 00:26:33.150
of dynamic programming,
which we'll talk about

00:26:33.150 --> 00:26:36.460
in gory detail,
later in November.

00:26:36.460 --> 00:26:44.250
But what I have here is
the simplest special case

00:26:44.250 --> 00:26:48.160
of a graph that has an
order of v e [INAUDIBLE]

00:26:48.160 --> 00:26:49.430
shortest path algorithm.

00:26:49.430 --> 00:26:52.120
And the reason for that
is we don't have cycles.

00:26:52.120 --> 00:26:53.150
All right?

00:26:53.150 --> 00:26:55.220
Any questions about this?

00:26:55.220 --> 00:26:57.630
People buy this?

00:26:57.630 --> 00:26:58.450
It works?

00:26:58.450 --> 00:26:59.370
OK.

00:26:59.370 --> 00:27:02.260
So, we've got one
algorithm under our belt.

00:27:02.260 --> 00:27:05.080
And we look at, really,
a more interesting case

00:27:05.080 --> 00:27:08.380
because most graphs are
going to have cycles in them.

00:27:08.380 --> 00:27:12.090
But we will stay
with the special case

00:27:12.090 --> 00:27:13.340
of no negative edges, now.

00:27:13.340 --> 00:27:13.840
All right?

00:27:13.840 --> 00:27:18.720
So Dijkstra's algorithm doesn't
work for negative edges.

00:27:18.720 --> 00:27:20.070
So it's different.

00:27:20.070 --> 00:27:23.150
This algorithm is not
subsumed by Dijkstra.

00:27:23.150 --> 00:27:25.100
That's important to understand.

00:27:25.100 --> 00:27:28.340
So Dijkstra's algorithm
works for graphs with cycles.

00:27:28.340 --> 00:27:32.740
But all of the edge ways have
to be either 0 or positive.

00:27:32.740 --> 00:27:35.740
This algorithm works for DAGs
that can have negative edges.

00:27:35.740 --> 00:27:37.340
But you can't have cycles.

00:27:37.340 --> 00:27:40.450
So both of these algorithms
have their place under the sun.

00:27:43.330 --> 00:27:46.230
So, let's take a look
at Dijkstra's algorithm.

00:27:46.230 --> 00:27:48.010
Actually, I guess I have a demo.

00:27:48.010 --> 00:27:57.390
So, the one demo
we have in 6006.

00:27:57.390 --> 00:28:00.460
[INAUDIBLE] Dijkstra is a very
straightforward algorithm.

00:28:00.460 --> 00:28:04.590
It's not trivial to
prove its correctness.

00:28:04.590 --> 00:28:07.770
But from a standpoint of
coding, from a standpoint

00:28:07.770 --> 00:28:10.640
of understanding the flow,
it's a very straightforward

00:28:10.640 --> 00:28:12.020
algorithm.

00:28:12.020 --> 00:28:14.060
One of the reasons
why that's the case

00:28:14.060 --> 00:28:17.260
is because it's a
greedy algorithm.

00:28:17.260 --> 00:28:21.710
It does things incrementally,
maximizing the benefit,

00:28:21.710 --> 00:28:22.780
as you will.

00:28:22.780 --> 00:28:26.000
And intuitively builds
the shortest paths.

00:28:26.000 --> 00:28:28.770
And it goes vertex by vertex.

00:28:28.770 --> 00:28:31.410
So here's a demo
of Dijkstra, which,

00:28:31.410 --> 00:28:33.419
the reason I want
to show you this,

00:28:33.419 --> 00:28:35.960
is because it will give you some
intuition as to why Dijkstra

00:28:35.960 --> 00:28:36.753
works.

00:28:36.753 --> 00:28:41.040
Now, some points of note.

00:28:41.040 --> 00:28:43.070
I can't tilt this more
than about this much

00:28:43.070 --> 00:28:45.150
because then these
balls will fall off.

00:28:45.150 --> 00:28:49.180
So, cameraman, can you get this?

00:28:49.180 --> 00:28:49.680
All right?

00:28:49.680 --> 00:28:52.270
For posterity.

00:28:52.270 --> 00:28:55.440
So I got an undirected
graph here, right?

00:28:55.440 --> 00:28:58.480
And each of these
things are nodes.

00:28:58.480 --> 00:29:01.200
The balls are the
nodes of the vertices.

00:29:01.200 --> 00:29:03.010
And I've drawn the
picture over there.

00:29:03.010 --> 00:29:04.280
And G stands for green.

00:29:04.280 --> 00:29:06.350
And Y stands for
yellow, et cetera.

00:29:06.350 --> 00:29:09.080
So, this graph is essentially
what I have up there.

00:29:09.080 --> 00:29:16.540
And I've put strings connecting
these balls, associated

00:29:16.540 --> 00:29:21.970
with the weights that
you see up there.

00:29:21.970 --> 00:29:25.700
So, if I got this
right, the string

00:29:25.700 --> 00:29:30.190
that's connecting the green ball
to the yellow ball up on top

00:29:30.190 --> 00:29:31.860
is 19 centimeters.

00:29:31.860 --> 00:29:33.935
And so on and so forth
for these other ones.

00:29:33.935 --> 00:29:35.250
All right?

00:29:35.250 --> 00:29:37.800
So, that's Dijkstra.

00:29:37.800 --> 00:29:41.610
And what do you
think I have to do

00:29:41.610 --> 00:29:46.209
to compute shortest paths,
mechanically speaking?

00:29:46.209 --> 00:29:47.500
What do you think I have to do?

00:29:50.248 --> 00:29:51.110
Yeah, someone.

00:29:53.741 --> 00:29:55.532
AUDIENCE: Pick up the
green ball and just--

00:29:55.532 --> 00:29:56.630
PROFESSOR: Pick up the
ball and lift it up.

00:29:56.630 --> 00:29:57.171
That's right.

00:29:57.171 --> 00:29:58.020
Good.

00:29:58.020 --> 00:30:00.250
It's worth a cushion.

00:30:00.250 --> 00:30:02.090
All right, so, let's
all this works.

00:30:05.760 --> 00:30:10.720
So, first, let me show you by
those values that I have there.

00:30:10.720 --> 00:30:15.730
If the green ball is the
starting vertex, then

00:30:15.730 --> 00:30:21.790
the shortest path to the
purple vertex, p, is 7.

00:30:21.790 --> 00:30:24.530
And that's the
closest node to G.

00:30:24.530 --> 00:30:27.360
And then, the next
closest node is

00:30:27.360 --> 00:30:30.540
the blue one, which
is b, which is 12.

00:30:30.540 --> 00:30:31.830
7 plus 5.

00:30:31.830 --> 00:30:33.210
And so on and so forth.

00:30:33.210 --> 00:30:35.890
And so, if this all works,
and I haven't tried this out,

00:30:35.890 --> 00:30:37.930
because this is a one use demo.

00:30:37.930 --> 00:30:41.780
Once I pull this up, the
strings get so tangled up,

00:30:41.780 --> 00:30:42.860
it doesn't work anymore.

00:30:42.860 --> 00:30:43.440
All right?

00:30:43.440 --> 00:30:46.090
So that's why I had to do
all of this, lug these over.

00:30:46.090 --> 00:30:47.780
Otherwise, it'd
be-- so this is not

00:30:47.780 --> 00:30:49.335
a computer reversible
kind of thing.

00:30:49.335 --> 00:30:51.340
So, if you want to
code Dijkstra up.

00:30:51.340 --> 00:30:54.670
OK, so if I just lift
it up, and if I do that,

00:30:54.670 --> 00:30:56.337
and if I tilt it in
the right direction.

00:30:56.337 --> 00:30:56.836
Yeah.

00:30:56.836 --> 00:30:57.520
I want to that.

00:30:57.520 --> 00:30:59.720
So you can see that this is a
little bit of fudging going on

00:30:59.720 --> 00:31:01.530
here, with respect to
getting this right.

00:31:01.530 --> 00:31:03.115
But you see green is up on top.

00:31:03.115 --> 00:31:04.490
And what is the
next one you see?

00:31:04.490 --> 00:31:05.010
AUDIENCE: Purple.

00:31:05.010 --> 00:31:05.450
PROFESSOR: Purple.

00:31:05.450 --> 00:31:05.969
That's good.

00:31:05.969 --> 00:31:07.135
What's the next one you see?

00:31:07.135 --> 00:31:07.450
AUDIENCE: Blue.

00:31:07.450 --> 00:31:08.116
PROFESSOR: Blue.

00:31:08.116 --> 00:31:10.220
That's good.

00:31:10.220 --> 00:31:14.680
Y, and then R. And
strings that are taught,

00:31:14.680 --> 00:31:18.310
that have tension in them, are
the predecessor vertices, OK?

00:31:18.310 --> 00:31:19.880
That's the pie.

00:31:19.880 --> 00:31:20.440
All right?

00:31:20.440 --> 00:31:23.350
So, again, I computed the
shortest paths, right?

00:31:23.350 --> 00:31:24.340
Mechanically.

00:31:24.340 --> 00:31:27.660
And, if I could have a way
of measuring the tension

00:31:27.660 --> 00:31:30.921
on the strings, I have my pie,
my predecessor relationship,

00:31:30.921 --> 00:31:31.420
as well.

00:31:31.420 --> 00:31:32.060
All right?

00:31:32.060 --> 00:31:33.972
Now, let's see if this works.

00:31:33.972 --> 00:31:35.090
This works, right?

00:31:35.090 --> 00:31:40.270
So, if the second thing doesn't
work, don't hold it against me.

00:31:40.270 --> 00:31:44.950
But, let's say if I take R,
and I lift it up like that.

00:31:44.950 --> 00:31:46.810
Yikes.

00:31:46.810 --> 00:31:50.430
So, R, followed by Y,
followed by B, followed by P,

00:31:50.430 --> 00:31:51.490
followed by G.

00:31:51.490 --> 00:31:52.820
Hey.

00:31:52.820 --> 00:31:54.560
Come on.

00:31:54.560 --> 00:31:55.170
All right?

00:31:55.170 --> 00:31:55.670
This works.

00:31:55.670 --> 00:31:56.180
Thank you.

00:31:56.180 --> 00:31:57.422
Thank you.

00:31:57.422 --> 00:31:59.290
All right.

00:31:59.290 --> 00:32:06.750
So there's actually a
reason why I did that demo.

00:32:06.750 --> 00:32:09.600
There's a greedy algorithm here.

00:32:09.600 --> 00:32:11.390
And, I guess, greedy is gravity.

00:32:11.390 --> 00:32:11.890
Right?

00:32:11.890 --> 00:32:13.830
Gravity is greedy.

00:32:13.830 --> 00:32:16.904
So, obviously, the reason
why those balls are hanging

00:32:16.904 --> 00:32:18.070
is because they have weight.

00:32:18.070 --> 00:32:19.140
And they have gravity.

00:32:19.140 --> 00:32:21.812
And you can imagine that you
could now-- people in physics.

00:32:21.812 --> 00:32:23.520
I don't know anybody
majoring in physics.

00:32:23.520 --> 00:32:26.300
Anyone double majoring in
physics or something here?

00:32:26.300 --> 00:32:27.980
All right.

00:32:27.980 --> 00:32:30.000
So, you know your Newton's
laws of mechanics.

00:32:30.000 --> 00:32:31.900
And you know about
gravity, and all of that.

00:32:31.900 --> 00:32:33.780
So you can imagine that
you said, you know,

00:32:33.780 --> 00:32:36.775
the heck with all this priority
queue stuff in the problem set.

00:32:36.775 --> 00:32:38.150
In the algorithm
that we're going

00:32:38.150 --> 00:32:39.660
to be talking
about for Dijkstra,

00:32:39.660 --> 00:32:43.770
I'm going to do a kinetic
simulation of shortest paths

00:32:43.770 --> 00:32:47.791
in order to get the actual
values of these shortest paths.

00:32:47.791 --> 00:32:48.290
OK?

00:32:48.290 --> 00:32:49.790
Now, that would be cool.

00:32:49.790 --> 00:32:51.730
But it'd be horribly slow.

00:32:51.730 --> 00:32:54.660
And so, the Dijkstra algorithm
we're going to be talking about

00:32:54.660 --> 00:32:57.980
is going to just compute the
steady state, corresponding

00:32:57.980 --> 00:33:04.810
to the closest vertex that
is closest to G. All right?

00:33:04.810 --> 00:33:07.670
So Dijkstra, the algorithm,
the intuition behind it,

00:33:07.670 --> 00:33:10.710
is that it's going to greedily
construct shortest paths.

00:33:10.710 --> 00:33:12.650
And it's going to
be starting with G,

00:33:12.650 --> 00:33:13.982
which is your source vertex.

00:33:13.982 --> 00:33:15.440
And then, the first
thing that it's

00:33:15.440 --> 00:33:17.455
going to process, and
find the shortest path to

00:33:17.455 --> 00:33:19.220
is going to be
the purple vertex.

00:33:19.220 --> 00:33:20.070
And then the blue.

00:33:20.070 --> 00:33:21.120
And then the yellow.

00:33:21.120 --> 00:33:21.940
And then the red.

00:33:21.940 --> 00:33:22.440
All right?

00:33:22.440 --> 00:33:26.530
So it actually mimics, to
some extent, this demo.

00:33:26.530 --> 00:33:29.762
All right?

00:33:29.762 --> 00:33:31.970
So, let's take a look at
the pseudocode for Dijkstra.

00:34:00.090 --> 00:34:01.290
So, g is your graph.

00:34:01.290 --> 00:34:03.050
w are the weights.

00:34:03.050 --> 00:34:06.760
Small s is the starting vertex.

00:34:06.760 --> 00:34:16.370
We're going to initialize g
and s, which means we just mark

00:34:16.370 --> 00:34:18.330
s a starting vertex.

00:34:18.330 --> 00:34:22.780
And we're going to also have
this capital S, that I'll

00:34:22.780 --> 00:34:27.050
use these little bars to
differentiate from small s.

00:34:27.050 --> 00:34:28.199
So this is a set.

00:34:28.199 --> 00:34:30.880
Capital S is a set.

00:34:30.880 --> 00:34:33.590
And we're going to
initialize that to null.

00:34:33.590 --> 00:34:36.170
And there's another
set called Q,

00:34:36.170 --> 00:34:40.400
which is initialized to
the entire set of vertices.

00:34:40.400 --> 00:34:43.110
And all this means is
that, initially, we

00:34:43.110 --> 00:34:44.420
haven't done any processing.

00:34:44.420 --> 00:34:49.230
And we don't know the
shortest paths to any vertex

00:34:49.230 --> 00:34:52.860
because this set of
vertices is null.

00:34:52.860 --> 00:34:56.310
And Q is the set of vertices
that need to be processed.

00:34:56.310 --> 00:34:59.560
And, as we start
processing vertices from Q,

00:34:59.560 --> 00:35:01.960
we're going to move
them to capital S.

00:35:01.960 --> 00:35:04.480
And they're going to
contain the set of vertices

00:35:04.480 --> 00:35:08.660
that we know the shortest
paths to already.

00:35:08.660 --> 00:35:10.960
And that's the invariant
in this algorithm.

00:35:10.960 --> 00:35:13.422
s is going to contain
the set of vertices

00:35:13.422 --> 00:35:14.880
that we know the
shortest paths to.

00:35:17.440 --> 00:35:22.970
And so, Dijkstra is
a little while loop

00:35:22.970 --> 00:35:24.740
that says, while
they're vertices

00:35:24.740 --> 00:35:32.300
that need to be processed,
then I'm going to take u.

00:35:32.300 --> 00:35:46.190
And I'm going to
extract-min from Q.

00:35:46.190 --> 00:35:54.410
And this is going
to delete u from Q.

00:35:54.410 --> 00:35:58.430
And this
initialization-- and this

00:35:58.430 --> 00:36:05.240
is a small s here-- is
going to set d of s to be 0.

00:36:05.240 --> 00:36:07.170
That's all this
initialization does.

00:36:07.170 --> 00:36:08.930
Because that's all we know.

00:36:08.930 --> 00:36:10.334
We have a starting vertex.

00:36:10.334 --> 00:36:12.750
And we know that the shortest
path to the starting vertex,

00:36:12.750 --> 00:36:15.240
from the starting vertex, is 0.

00:36:15.240 --> 00:36:18.150
So, all that means is
that, all of the other ones

00:36:18.150 --> 00:36:19.700
have infinity values.

00:36:19.700 --> 00:36:22.060
So, at this very first
step, it makes sense

00:36:22.060 --> 00:36:24.730
that extract-min
Q is going to pull

00:36:24.730 --> 00:36:27.670
the starting vertex,
small s, out.

00:36:27.670 --> 00:36:31.660
And is going to assign
it to this u value.

00:36:31.660 --> 00:36:35.040
And we're going to
set s to be-- capital

00:36:35.040 --> 00:36:42.520
S-- to be capital S union u.

00:36:42.520 --> 00:36:49.350
And then, all we have to do is
relax the edges from the vertex

00:36:49.350 --> 00:36:50.640
that we just added.

00:36:50.640 --> 00:36:57.910
So, for each vertex, v
belonging to adjacent

00:36:57.910 --> 00:37:00.670
s, so that you can reach from u.

00:37:00.670 --> 00:37:05.788
We relax u, v, w.

00:37:08.476 --> 00:37:09.380
All right?

00:37:09.380 --> 00:37:10.060
That's it.

00:37:10.060 --> 00:37:10.916
That's Dijkstra.

00:37:14.890 --> 00:37:17.460
It's a greedy algorithm.

00:37:17.460 --> 00:37:18.930
It's iterative.

00:37:18.930 --> 00:37:21.690
And the reason it's greedy
is because of this step here.

00:37:21.690 --> 00:37:25.590
It's just picking
the min priority

00:37:25.590 --> 00:37:30.760
from the un-processed
vertices, Q. And, essentially,

00:37:30.760 --> 00:37:37.590
claiming that this min value
is something that you already

00:37:37.590 --> 00:37:40.160
computed the shortest paths for.

00:37:40.160 --> 00:37:42.800
So, when you're putting
something into S,

00:37:42.800 --> 00:37:45.110
you're saying, I'm done.

00:37:45.110 --> 00:37:48.220
I know the shortest path
to this particular vertex.

00:37:48.220 --> 00:37:51.580
And I need to now process
it, in the sense that I

00:37:51.580 --> 00:37:55.250
have to relax the edges that
are coming out of this vertex.

00:37:55.250 --> 00:37:58.610
And update the priority
values because relax

00:37:58.610 --> 00:38:02.780
is going to go change
the d values, as we know,

00:38:02.780 --> 00:38:07.280
corresponding to the vertex,
v. It might change the value.

00:38:07.280 --> 00:38:08.310
It might not.

00:38:08.310 --> 00:38:10.950
But there's a possibility
that it would.

00:38:10.950 --> 00:38:13.280
And you're going to do
this for all of the edges

00:38:13.280 --> 00:38:15.937
that are emanating
out of the vertex, u.

00:38:15.937 --> 00:38:18.270
And so you may be changing a
bunch of different priority

00:38:18.270 --> 00:38:18.770
values.

00:38:18.770 --> 00:38:20.940
So the next time
around, you will

00:38:20.940 --> 00:38:27.270
get a different minimum
priority vertex.

00:38:27.270 --> 00:38:27.970
For two reasons.

00:38:27.970 --> 00:38:31.050
One is that you've extracted
out the minimum priority vertex.

00:38:31.050 --> 00:38:34.150
You've deleted it from
Q. And the second reason

00:38:34.150 --> 00:38:36.340
is that these
priority values change

00:38:36.340 --> 00:38:38.200
as you go through the loop.

00:38:38.200 --> 00:38:39.110
All right?

00:38:39.110 --> 00:38:41.960
And so, in our demo,
essentially what happened was,

00:38:41.960 --> 00:38:46.120
the first time, the process
of lifting the green vertex,

00:38:46.120 --> 00:38:49.220
corresponding to choosing
it as a starting vertex.

00:38:49.220 --> 00:38:51.570
And the first thing
that was closest

00:38:51.570 --> 00:38:55.550
to it, which had the taught
string hanging from it,

00:38:55.550 --> 00:38:57.174
has the min priority value.

00:38:57.174 --> 00:38:58.090
And you pull that out.

00:38:58.090 --> 00:39:01.420
And then so on and so
forth, as you go down.

00:39:01.420 --> 00:39:04.445
And I'm not going to go
through and prove this.

00:39:04.445 --> 00:39:06.570
But it's certainly something
that is worth reading.

00:39:06.570 --> 00:39:10.610
It's half of page proof,
maybe a page in CLRS.

00:39:10.610 --> 00:39:12.480
And you should read
the proof for Dijkstra,

00:39:12.480 --> 00:39:13.791
the formal proof for Dijkstra.

00:39:13.791 --> 00:39:15.790
Which just, essentially,
does all the accounting

00:39:15.790 --> 00:39:16.940
and gets things right.

00:39:16.940 --> 00:39:20.290
And uses the lemma that we have,
with respect to the relaxation

00:39:20.290 --> 00:39:24.540
operation being safe.

00:39:24.540 --> 00:39:25.370
OK?

00:39:25.370 --> 00:39:26.770
Any questions about Dijkstra?

00:39:26.770 --> 00:39:29.141
Or about the pseudocode,
in particular?

00:39:29.141 --> 00:39:31.390
I guess you guys are going
to code this at some point.

00:39:31.390 --> 00:39:31.600
Yeah?

00:39:31.600 --> 00:39:33.350
AUDIENCE: How are the
vertices comparable?

00:39:33.350 --> 00:39:34.250
In what way?

00:39:34.250 --> 00:39:36.015
PROFESSOR: Oh, so
that's a good question.

00:39:36.015 --> 00:39:37.515
And I should have
made that clearer.

00:39:40.810 --> 00:39:43.420
So, Q is a priority queue.

00:39:43.420 --> 00:39:47.840
And the priorities of the
vertices are the d values, OK?

00:39:52.890 --> 00:39:55.900
s being null is clear, I hope.

00:39:55.900 --> 00:39:56.920
That's clear.

00:39:56.920 --> 00:39:59.580
And then Q being the set of
vertices are clear, as well.

00:39:59.580 --> 00:40:03.030
Now, Q is a priority queue, OK?

00:40:03.030 --> 00:40:06.530
And we'll talk about how
we'll implement this priority

00:40:06.530 --> 00:40:08.570
queue, and the
complexity of Dijkstra,

00:40:08.570 --> 00:40:09.840
before we're done here.

00:40:09.840 --> 00:40:12.440
But, as an ADT, as an
Abstract Data Type,

00:40:12.440 --> 00:40:14.230
think of Q as being
a priority queue.

00:40:14.230 --> 00:40:15.650
And there's
priorities associated

00:40:15.650 --> 00:40:19.650
with each vertex that's in Q.
And these priorities change.

00:40:19.650 --> 00:40:21.211
And they're the d values.

00:40:21.211 --> 00:40:21.710
All right?

00:40:21.710 --> 00:40:22.460
So the priorities.

00:40:30.720 --> 00:40:34.860
So, initially, d of
s-- small s-- is 0.

00:40:34.860 --> 00:40:37.280
And all of the other
ones are infinity.

00:40:37.280 --> 00:40:39.350
So it's clear that, the
very first time, you're

00:40:39.350 --> 00:40:42.590
going to set u to be small s,
which is a starting vertex.

00:40:42.590 --> 00:40:44.980
And then you relax the
edges coming out of s,

00:40:44.980 --> 00:40:47.890
potentially change some of
these other infinity values

00:40:47.890 --> 00:40:49.530
of the vertices
that you can reach

00:40:49.530 --> 00:40:51.850
from s to be less than infinity.

00:40:51.850 --> 00:40:55.420
And you're going
to, essentially,

00:40:55.420 --> 00:40:58.580
change the values of
the priority queue.

00:40:58.580 --> 00:40:59.187
And go around.

00:40:59.187 --> 00:41:01.020
And then select the min
value the next time.

00:41:01.020 --> 00:41:02.230
And so on and so forth.

00:41:02.230 --> 00:41:03.860
OK?

00:41:03.860 --> 00:41:04.860
Thanks for the question.

00:41:04.860 --> 00:41:05.693
Any other questions?

00:41:09.320 --> 00:41:10.300
OK.

00:41:10.300 --> 00:41:19.350
So, let's just go through a
couple of steps in an example.

00:41:19.350 --> 00:41:22.700
I'm not going to go
through the whole thing.

00:41:22.700 --> 00:41:27.860
But you'll see an execution
of Dijkstra in the nodes.

00:41:27.860 --> 00:41:30.790
I think it's worth spending
just a couple of minutes going

00:41:30.790 --> 00:41:36.300
through the first few steps
of a Dijkstra execution.

00:41:36.300 --> 00:41:45.340
Just so how this priority
queue works is clear,

00:41:45.340 --> 00:41:48.740
let's take a look at a directed
graph that has five vertices.

00:42:02.400 --> 00:42:03.110
So that's 7.

00:42:14.040 --> 00:42:18.760
So let's start with a
being the starting vertex.

00:42:18.760 --> 00:42:21.490
And so d of a is 0.

00:42:21.490 --> 00:42:26.190
And d of b through
e are all infinity.

00:42:26.190 --> 00:42:31.580
Your s is null to begin with.

00:42:31.580 --> 00:42:35.100
And Q has all of the
five vertices in it.

00:42:39.710 --> 00:42:43.721
So extract-min is
going to select a.

00:42:43.721 --> 00:42:46.830
That's the only one that is a 0.

00:42:46.830 --> 00:42:51.550
Because you've got 0, infinity,
infinity, infinity, infinity.

00:42:51.550 --> 00:42:56.130
And so, you select that,
and you set s to be a.

00:42:56.130 --> 00:42:57.970
And once you set s
to be a, you relax

00:42:57.970 --> 00:42:59.640
the edges coming out of a.

00:42:59.640 --> 00:43:01.000
And there's two of them.

00:43:01.000 --> 00:43:07.010
So you end up with 0, 10,
3, infinity, infinity.

00:43:07.010 --> 00:43:10.410
And the next extract-min
is going to select 3.

00:43:10.410 --> 00:43:14.820
And you're going to
set s to be a comma c.

00:43:14.820 --> 00:43:16.570
And so you're,
essentially, doing

00:43:16.570 --> 00:43:19.290
kind of a breadth-first search.

00:43:19.290 --> 00:43:21.100
But you're being greedy.

00:43:21.100 --> 00:43:23.230
It's a mixed breadth-first
depth-first search.

00:43:23.230 --> 00:43:24.730
You do a breadth-first
search when

00:43:24.730 --> 00:43:25.950
you're given a
particular vertex,

00:43:25.950 --> 00:43:27.408
and you look at
all of the vertices

00:43:27.408 --> 00:43:29.320
that you can reach
from that vertex.

00:43:29.320 --> 00:43:31.810
And then you say, I'm
a greedy algorithm.

00:43:31.810 --> 00:43:34.710
I'm going to pick the
vertex in this frontier

00:43:34.710 --> 00:43:37.660
that I've just created, that
is the shortest distance

00:43:37.660 --> 00:43:40.350
away from me, that has
the lowest priority value.

00:43:40.350 --> 00:43:43.030
And, in this case, it would be
c because this other one is 10.

00:43:43.030 --> 00:43:44.110
And this is shorter.

00:43:44.110 --> 00:43:44.610
Right?

00:43:44.610 --> 00:43:46.690
So that's why we
pick c over here.

00:43:46.690 --> 00:43:48.620
And one last one.

00:43:48.620 --> 00:43:52.940
Once you process c,
you're going to end up

00:43:52.940 --> 00:43:54.620
processing this
edge going out here.

00:43:54.620 --> 00:43:55.840
This edge going out there.

00:43:55.840 --> 00:43:57.560
This edge going out this way.

00:43:57.560 --> 00:44:05.070
And you're going to end
up with 0, 7, 3, 11, 5.

00:44:05.070 --> 00:44:08.280
And you've processed a bunch
of edges coming out of c.

00:44:08.280 --> 00:44:11.730
And, at this point, 0
is gone and 3 is gone.

00:44:11.730 --> 00:44:13.310
I'm just writing
the values here,

00:44:13.310 --> 00:44:14.890
just so you know what they are.

00:44:14.890 --> 00:44:17.670
But these are out of the picture
because, in s, those values

00:44:17.670 --> 00:44:18.920
should never change.

00:44:18.920 --> 00:44:21.500
Dijkstra essentially guarantees.

00:44:21.500 --> 00:44:23.100
And that's the
proof of correctness

00:44:23.100 --> 00:44:28.380
that takes a bit of doing,
is that this value is never

00:44:28.380 --> 00:44:29.620
going to reduce anymore.

00:44:29.620 --> 00:44:31.810
The pre-value is
never going to reduce.

00:44:31.810 --> 00:44:33.710
And it's been put into s.

00:44:33.710 --> 00:44:35.800
But what's remaining now is 5.

00:44:35.800 --> 00:44:39.090
And that corresponds
to the e vertex.

00:44:39.090 --> 00:44:45.130
So s becomes a, c, e.

00:44:45.130 --> 00:44:46.970
The 5 gets stuck in there.

00:44:46.970 --> 00:44:48.580
And so on and so forth.

00:44:48.580 --> 00:44:50.220
All right?

00:44:50.220 --> 00:44:51.712
So, that's Dijkstra.

00:44:51.712 --> 00:44:53.045
And now, let's start complexity.

00:44:55.630 --> 00:44:58.640
So, it we have the code
for Dijkstra on the left,

00:44:58.640 --> 00:45:03.530
we have an ADT associated
with the priority queue.

00:45:03.530 --> 00:45:06.550
And now, we're back
to talking like we

00:45:06.550 --> 00:45:11.410
did early on in the term,
where we compared linked lists,

00:45:11.410 --> 00:45:15.170
and arrays, and
heaps, and trees.

00:45:15.170 --> 00:45:21.580
And said, for a particular
set of operations,

00:45:21.580 --> 00:45:24.020
which one is going
to be the best?

00:45:24.020 --> 00:45:25.130
OK?

00:45:25.130 --> 00:45:29.100
So, if you analyze Dijkstra,
and you look at the pseudocode

00:45:29.100 --> 00:45:34.320
first, and you say, what are the
operations that I'm performing?

00:45:37.810 --> 00:45:43.440
I got an operation here,
corresponding to theta v

00:45:43.440 --> 00:45:47.670
inserts into the priority queue.

00:45:53.760 --> 00:45:57.440
And that's inserting
things into Q.

00:45:57.440 --> 00:46:02.860
I got theta v
extract-min operations.

00:46:08.290 --> 00:46:11.070
I'm only going to delete a
vertex once, process of vertex

00:46:11.070 --> 00:46:12.160
once.

00:46:12.160 --> 00:46:15.780
And that's why I have
theta v extract operations.

00:46:15.780 --> 00:46:22.840
And I have theta e, what
decrease key or update

00:46:22.840 --> 00:46:29.690
key operations because
when I do, I relax here.

00:46:29.690 --> 00:46:32.220
I'm decreasing the key.

00:46:34.719 --> 00:46:36.510
It's in particular,
it's not an update key.

00:46:36.510 --> 00:46:39.329
It happens to be a decrease
key, which is not a big deal.

00:46:39.329 --> 00:46:40.620
We don't need to get into that.

00:46:40.620 --> 00:46:42.530
But you are reducing
the d value.

00:46:42.530 --> 00:46:45.040
So it's a decrease
key operation.

00:46:45.040 --> 00:46:51.295
And, again, it's theta e
because, in a directed graph,

00:46:51.295 --> 00:46:53.170
you're only going to
process each edge that's

00:46:53.170 --> 00:46:55.512
coming out of the vertex once.

00:46:55.512 --> 00:46:57.220
Since you're processing
each vertex once,

00:46:57.220 --> 00:46:59.930
and you're looking at
all of the outgoing edges

00:46:59.930 --> 00:47:01.470
from that vertex.

00:47:01.470 --> 00:47:02.530
OK?

00:47:02.530 --> 00:47:06.340
So that's what you can get
looking at the pseudocode.

00:47:06.340 --> 00:47:09.230
And now, you're a data
structure designer.

00:47:09.230 --> 00:47:12.120
And you have some choices
here, with respect

00:47:12.120 --> 00:47:14.910
to actually implementing
the priority queue.

00:47:14.910 --> 00:47:21.030
And let's look at the complexity
of Dijkstra for arrays.

00:47:21.030 --> 00:47:25.420
So, suppose I ended
up using an array

00:47:25.420 --> 00:47:28.040
structure for the
priority queue.

00:47:28.040 --> 00:47:31.800
But then, what do I have?

00:47:31.800 --> 00:47:37.570
I have, if I look at
this, my extract-min, what

00:47:37.570 --> 00:47:40.720
is the complexity of
extract-min in an array?

00:47:40.720 --> 00:47:41.540
AUDIENCE: Theta v.

00:47:41.540 --> 00:47:44.270
PROFESSOR: Theta v. And
what's the complexity

00:47:44.270 --> 00:47:48.290
of a decrease key in an array?

00:47:48.290 --> 00:47:50.210
I just go access that element.

00:47:50.210 --> 00:47:51.600
And I change it.

00:47:51.600 --> 00:47:53.140
State of one, right?

00:47:53.140 --> 00:47:59.010
So I have theta v
for extract-min.

00:47:59.010 --> 00:48:00.810
I'll just call it ex-min.

00:48:00.810 --> 00:48:06.750
Theta one for decrease key.

00:48:06.750 --> 00:48:09.890
And if I go do the
multiplication,

00:48:09.890 --> 00:48:17.290
I get theta v times v plus
e times 1, or a constant,

00:48:17.290 --> 00:48:19.860
which is theta v squared.

00:48:19.860 --> 00:48:23.260
Because I know that
e is order v squared.

00:48:23.260 --> 00:48:23.760
Right?

00:48:23.760 --> 00:48:27.100
If I have a simple graph,
it may be a complete graph,

00:48:27.100 --> 00:48:29.460
but-- we talked
about this last time.

00:48:29.460 --> 00:48:31.810
e is, at most, v squared.

00:48:31.810 --> 00:48:34.445
So I can just call
this theta v squared.

00:48:34.445 --> 00:48:35.340
All right?

00:48:35.340 --> 00:48:39.000
So we have a theta v squared
Dijkstra implementation

00:48:39.000 --> 00:48:42.012
that uses an array structure.

00:48:42.012 --> 00:48:43.720
But do we want to use
an array structure?

00:48:43.720 --> 00:48:49.290
What data structure
should we use?

00:48:49.290 --> 00:48:50.200
Yeah?

00:48:50.200 --> 00:48:50.829
AUDIENCE: Heap.

00:48:50.829 --> 00:48:52.370
PROFESSOR: You can
use it a min-heap.

00:48:52.370 --> 00:48:53.990
Exactly right.

00:48:53.990 --> 00:49:00.840
So, if you use a
binary min-heap,

00:49:00.840 --> 00:49:16.830
then my extract-min is
finding the min is a constant

00:49:16.830 --> 00:49:18.910
because you just pick
it up from the top.

00:49:18.910 --> 00:49:22.770
But we know that, if you
want to update the heap,

00:49:22.770 --> 00:49:28.220
and delete it, then it's going
to take that theta log v.

00:49:28.220 --> 00:49:31.460
And decrease key
is the same thing.

00:49:31.460 --> 00:49:35.336
Theta log v. So that's
worse than array.

00:49:37.880 --> 00:49:40.000
And if I go do the
multiplication again,

00:49:40.000 --> 00:49:45.920
I get v log v plus e log v. OK?

00:49:45.920 --> 00:49:49.590
And this is not quite the
complexity that I put up,

00:49:49.590 --> 00:49:54.330
as some of you may
remember, last time.

00:49:54.330 --> 00:49:57.790
This is not the optimum
complexity of Dijkstra.

00:49:57.790 --> 00:50:01.280
Or an optimal
complexity of Dijkstra.

00:50:01.280 --> 00:50:05.800
You can actually take this out
by using a data structure that

00:50:05.800 --> 00:50:08.460
we won't talk about in 006.

00:50:08.460 --> 00:50:11.190
But you can read about it.

00:50:11.190 --> 00:50:15.660
It's not 6006 level material.

00:50:15.660 --> 00:50:18.410
You're not responsible
for this in 006.

00:50:18.410 --> 00:50:20.480
But it's got a Fibonacci heap.

00:50:20.480 --> 00:50:22.780
And you might learn
about it in 6046.

00:50:22.780 --> 00:50:27.440
The Fibonacci heap is an
amortized data structure

00:50:27.440 --> 00:50:31.980
that has theta log
v for extract-min.

00:50:31.980 --> 00:50:43.090
And theta one amortized
time for decrease key.

00:50:43.090 --> 00:50:44.890
And what's nice
about it is that,

00:50:44.890 --> 00:50:52.320
once you do that, you end up
with theta v log v plus e time.

00:50:52.320 --> 00:50:56.850
And that's the complexity
I put up way back, I guess,

00:50:56.850 --> 00:50:59.610
last Thursday.

00:50:59.610 --> 00:51:04.000
So that's to show you, with
respect to two special cases,

00:51:04.000 --> 00:51:08.930
we have the DAGs, which are
linear time, essentially.

00:51:08.930 --> 00:51:13.420
And Dijkstra, with amortized,
and their proper data

00:51:13.420 --> 00:51:16.101
structure, also,
essentially, linear time.

00:51:16.101 --> 00:51:16.600
Right?

00:51:16.600 --> 00:51:18.308
Next time, we'll look
at the general case

00:51:18.308 --> 00:51:20.550
where we have potentially
negative cycles.

00:51:20.550 --> 00:51:24.070
And we end up with algorithms
that have greater complexity.

00:51:24.070 --> 00:51:26.220
See you next time.

