WEBVTT
Kind: captions
Language: en

00:00:00.090 --> 00:00:01.800
The following
content is provided

00:00:01.800 --> 00:00:04.030
under a Creative
Commons license.

00:00:04.030 --> 00:00:06.880
Your support will help MIT
OpenCourseWare continue

00:00:06.880 --> 00:00:10.740
to offer high quality
educational resources for free.

00:00:10.740 --> 00:00:13.360
To make a donation, or
view additional materials

00:00:13.360 --> 00:00:17.237
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:17.237 --> 00:00:17.862
at ocw.mit.edu.

00:00:21.349 --> 00:00:22.890
PROFESSOR: OK, so
up until now, we've

00:00:22.890 --> 00:00:26.371
been talking about the
shortest path in graphs.

00:00:26.371 --> 00:00:28.370
And we've been talking
about these game problems

00:00:28.370 --> 00:00:34.260
where you came up with a way to
represent the state of a game

00:00:34.260 --> 00:00:35.240
as noting graphs.

00:00:35.240 --> 00:00:39.400
And then we drew edges between
those vertices that represented

00:00:39.400 --> 00:00:42.210
states, to represent moves
that you can do in a game.

00:00:42.210 --> 00:00:44.500
It turns out you can solve
a lot of problems this way.

00:00:44.500 --> 00:00:47.650
And you can do it without
thinking of a graph at all.

00:00:47.650 --> 00:00:50.482
So we usually think of a
graph, build the graph,

00:00:50.482 --> 00:00:51.690
then run dynamic programming.

00:00:51.690 --> 00:00:54.550
You can do better without
building the graph.

00:00:54.550 --> 00:00:59.260
And the good part about that
is that your code is smaller,

00:00:59.260 --> 00:01:00.630
and it runs faster.

00:01:00.630 --> 00:01:03.510
The bad part about that is
it's harder to understand.

00:01:03.510 --> 00:01:06.260
The dynamic programming
code looks like black magic.

00:01:06.260 --> 00:01:09.420
And, when we're going to
give you dynamic programming

00:01:09.420 --> 00:01:11.129
problems on the final,
you can't say, oh,

00:01:11.129 --> 00:01:13.378
we're going to build something
and run [? dystring ?].

00:01:13.378 --> 00:01:14.460
And get partial credit.

00:01:14.460 --> 00:01:16.970
You actually have to
understand the magic,

00:01:16.970 --> 00:01:21.360
and write the formulas,
and hopefully get

00:01:21.360 --> 00:01:22.790
something that works.

00:01:22.790 --> 00:01:26.090
So, we're going to spend all
the time that we have left

00:01:26.090 --> 00:01:27.640
in the semester, I
think, building up

00:01:27.640 --> 00:01:30.360
your intuition for how to
build dynamic programming.

00:01:30.360 --> 00:01:32.040
So, from lecture,
dynamic programming

00:01:32.040 --> 00:01:37.659
is just a catchy name for
for optimization problems.

00:01:37.659 --> 00:01:39.450
So, problems where
you're trying to compute

00:01:39.450 --> 00:01:42.740
the minimum or the
maximum of something.

00:01:42.740 --> 00:01:44.140
So let's start with a problem.

00:01:44.140 --> 00:01:46.190
And then, see how all
the concepts in lecture

00:01:46.190 --> 00:01:47.290
relate to that.

00:01:47.290 --> 00:01:49.650
So this problem is
called Crazy Eights.

00:01:49.650 --> 00:01:55.030
And we start out with a deck
of cards, randomly shuffled.

00:01:55.030 --> 00:01:57.310
And then some of the
cards are pulled out.

00:01:57.310 --> 00:01:59.050
Did everyone see playing cards?

00:01:59.050 --> 00:02:00.520
Poker cards?

00:02:00.520 --> 00:02:04.420
Does everyone know what they
are or do I have to define them?

00:02:04.420 --> 00:02:06.740
Does anyone need me
to define poker cards?

00:02:06.740 --> 00:02:08.210
Let's put it that way.

00:02:08.210 --> 00:02:08.740
OK.

00:02:08.740 --> 00:02:10.639
Cool.

00:02:10.639 --> 00:02:13.270
So, suppose we have
a bunch of these.

00:02:17.086 --> 00:02:19.112
AUDIENCE: I don't know
what Crazy Eights is.

00:02:19.112 --> 00:02:20.320
PROFESSOR: We'll get to that.

00:02:20.320 --> 00:02:21.450
AUDIENCE: OK.

00:02:21.450 --> 00:02:22.384
It's an 8.

00:02:22.384 --> 00:02:23.884
AUDIENCE: I know
what an 8 is, but I

00:02:23.884 --> 00:02:24.880
don't know how the game works.

00:02:24.880 --> 00:02:25.140
PROFESSOR: OK.

00:02:25.140 --> 00:02:25.930
We'll get to it.

00:02:25.930 --> 00:02:28.000
So, let's see.

00:02:31.010 --> 00:02:31.880
4 of spades.

00:02:55.250 --> 00:02:58.354
OK, so this is a
bunch of cards that

00:02:58.354 --> 00:02:59.520
were pulled out of the deck.

00:02:59.520 --> 00:03:03.660
And we want the longest
crazy subsequence.

00:03:03.660 --> 00:03:05.670
And the crazy subsequence
is a subsequence

00:03:05.670 --> 00:03:09.090
where two cards are
like each other.

00:03:09.090 --> 00:03:13.370
The way we define like
is that either they

00:03:13.370 --> 00:03:16.370
have the same number.

00:03:16.370 --> 00:03:19.480
Or they have the same suit.

00:03:19.480 --> 00:03:21.700
Or one of them is an 8.

00:03:21.700 --> 00:03:23.700
So an 8 is like anything else.

00:03:31.160 --> 00:03:31.660
OK.

00:03:31.660 --> 00:03:32.650
So 4 and 8.

00:03:32.650 --> 00:03:35.172
Are they like each other?

00:03:35.172 --> 00:03:37.960
AUDIENCE: Yes.

00:03:37.960 --> 00:03:39.610
PROFESSOR: 8 and 5.

00:03:39.610 --> 00:03:41.055
Are they like each other?

00:03:41.055 --> 00:03:43.677
AUDIENCE: Yep.

00:03:43.677 --> 00:03:44.260
PROFESSOR: OK.

00:03:47.780 --> 00:03:50.470
this 5, 5 of hearts
and 9 of diamonds.

00:03:50.470 --> 00:03:52.210
Are they like each other?

00:03:52.210 --> 00:03:53.610
No.

00:03:53.610 --> 00:03:56.649
5 of hearts and 7 of hearts.

00:03:56.649 --> 00:03:57.690
Are they like each other?

00:03:57.690 --> 00:04:00.200
AUDIENCE: Yes.

00:04:00.200 --> 00:04:03.000
PROFESSOR: 5 of spades and 7
of hearts, like each other?

00:04:03.000 --> 00:04:03.500
No.

00:04:03.500 --> 00:04:04.330
OK.

00:04:04.330 --> 00:04:06.600
So we have some cards
that are like each other.

00:04:06.600 --> 00:04:09.850
We want the longest
possible subsequence.

00:04:09.850 --> 00:04:11.058
AUDIENCE: What about 5 and 5?

00:04:11.058 --> 00:04:12.240
Those are like each other.

00:04:12.240 --> 00:04:15.064
PROFESSOR: They're
like each other, yep.

00:04:15.064 --> 00:04:17.480
They are more cards that are
like each other than the ones

00:04:17.480 --> 00:04:18.070
I drew here.

00:04:18.070 --> 00:04:24.263
For example, this guy
is like everything else.

00:04:24.263 --> 00:04:25.742
Oh, we already drew that one.

00:04:28.700 --> 00:04:29.440
OK.

00:04:29.440 --> 00:04:31.880
So how do we model this
problem using graphs?

00:04:31.880 --> 00:04:36.310
So, stuff that we knew
before the last lecture.

00:04:36.310 --> 00:04:37.997
AUDIENCE: Those
could all be nodes.

00:04:37.997 --> 00:04:38.580
PROFESSOR: OK.

00:04:38.580 --> 00:04:39.579
All the cards are nodes.

00:04:39.579 --> 00:04:41.180
That's good.

00:04:41.180 --> 00:04:46.860
And, I want the longest
path between what and what?

00:04:49.758 --> 00:04:52.917
AUDIENCE: One node to another?

00:04:52.917 --> 00:04:53.500
PROFESSOR: OK.

00:04:53.500 --> 00:04:54.930
AUDIENCE: The longest
path in the graph.

00:04:54.930 --> 00:04:55.250
PROFESSOR: Yeah.

00:04:55.250 --> 00:04:56.750
The longest path in the graph.

00:04:56.750 --> 00:04:59.510
One trick to reduce
it to a known problem

00:04:59.510 --> 00:05:02.880
is to add the fake source.

00:05:02.880 --> 00:05:04.084
So this is a fake source.

00:05:04.084 --> 00:05:05.750
And it's going to
connect to everything.

00:05:11.984 --> 00:05:14.650
And this way, I want the longest
path, starting from the source.

00:05:17.524 --> 00:05:19.564
AUDIENCE: And the other source?

00:05:19.564 --> 00:05:20.230
PROFESSOR: Nope.

00:05:20.230 --> 00:05:22.688
The longest path, starting from
the source, ending anywhere

00:05:22.688 --> 00:05:24.992
in the graph.

00:05:24.992 --> 00:05:28.684
AUDIENCE: Such that it doesn't
go touch another card again?

00:05:28.684 --> 00:05:29.350
PROFESSOR: Yeah.

00:05:29.350 --> 00:05:30.860
So, if I want a
longer subsequence,

00:05:30.860 --> 00:05:31.818
that's a good question.

00:05:31.818 --> 00:05:33.884
How would the edges look?

00:05:33.884 --> 00:05:34.785
AUDIENCE: Directed.

00:05:34.785 --> 00:05:35.410
PROFESSOR: Yep.

00:05:35.410 --> 00:05:36.020
Directed.

00:05:36.020 --> 00:05:37.570
And which direction?

00:05:40.354 --> 00:05:43.140
AUDIENCE: Arbitrary [INAUDIBLE].

00:05:43.140 --> 00:05:46.350
PROFESSOR: So, if I choose
this one and this one,

00:05:46.350 --> 00:05:48.691
can I go back afterwards?

00:05:48.691 --> 00:05:50.440
AUDIENCE: You just
can't go back to the 4.

00:05:50.440 --> 00:05:52.481
PROFESSOR: So, in the
longest common subsequence,

00:05:52.481 --> 00:05:54.390
all the cards have to
be in increasing order.

00:05:54.390 --> 00:05:57.360
So I can say I'm going to
choose this one, this one,

00:05:57.360 --> 00:05:58.420
and this one.

00:05:58.420 --> 00:06:01.150
And they have to
match in this order.

00:06:01.150 --> 00:06:03.950
So I can only go forward.

00:06:03.950 --> 00:06:05.490
So I can't reorder the cards.

00:06:05.490 --> 00:06:13.270
My answer has to be, say, 4
of diamonds, 8 of diamonds.

00:06:13.270 --> 00:06:15.890
And then, what else
would match that?

00:06:15.890 --> 00:06:16.500
9 of diamonds.

00:06:16.500 --> 00:06:18.400
AUDIENCE: You can put the
8 anywhere, though, right?

00:06:18.400 --> 00:06:18.983
PROFESSOR: No.

00:06:18.983 --> 00:06:21.180
I can't move them.

00:06:21.180 --> 00:06:23.249
So the cards have to be
in the initial order.

00:06:23.249 --> 00:06:24.790
I don't have to
choose all the cards,

00:06:24.790 --> 00:06:26.581
but the cards that I
choose have to respect

00:06:26.581 --> 00:06:27.674
the initial ordering.

00:06:27.674 --> 00:06:29.290
AUDIENCE: So everything
points right.

00:06:29.290 --> 00:06:30.900
PROFESSOR: Everything
points right.

00:06:30.900 --> 00:06:31.762
Forward.

00:06:31.762 --> 00:06:32.262
Yep.

00:06:39.330 --> 00:06:41.891
And, I need one more
edge from here to here.

00:06:41.891 --> 00:06:43.641
AUDIENCE: Oh, so you're
saying in the game

00:06:43.641 --> 00:06:45.170
you get an initial order.

00:06:45.170 --> 00:06:46.580
And you can't reorder it.

00:06:46.580 --> 00:06:48.710
PROFESSOR: Yeah.

00:06:48.710 --> 00:06:51.350
But otherwise I can, if
I have all the cards,

00:06:51.350 --> 00:06:52.610
I'm just going to order them.

00:06:52.610 --> 00:06:55.592
AUDIENCE: Well, that's
the point right?

00:06:55.592 --> 00:06:57.720
I was picturing more like
you get a set of cards

00:06:57.720 --> 00:06:59.000
and you try to figure out--

00:06:59.000 --> 00:06:59.780
PROFESSOR: No.

00:06:59.780 --> 00:07:01.260
So, that's a different game.

00:07:01.260 --> 00:07:03.860
That might be harder to solve,
so let's stick with this.

00:07:03.860 --> 00:07:04.607
Yes?

00:07:04.607 --> 00:07:08.140
AUDIENCE: Why is 8
in there, with 7?

00:07:08.140 --> 00:07:09.640
PROFESSOR: 8 is
similar to anything.

00:07:12.240 --> 00:07:13.467
Just for the heck of it.

00:07:13.467 --> 00:07:14.300
These are the rules.

00:07:17.340 --> 00:07:18.900
OK, so we have a
graph and we want

00:07:18.900 --> 00:07:21.360
to compute the longest path.

00:07:21.360 --> 00:07:24.250
We do not have an algorithm
to compute the longest path.

00:07:24.250 --> 00:07:26.480
We only have algorithms
to compute shortest paths.

00:07:26.480 --> 00:07:28.710
So how do I deal with that?

00:07:28.710 --> 00:07:30.928
We had that in problem set six.

00:07:30.928 --> 00:07:32.386
AUDIENCE: Make all
weights negative

00:07:32.386 --> 00:07:34.957
because there's no
cycle [INAUDIBLE].

00:07:34.957 --> 00:07:35.540
PROFESSOR: OK.

00:07:35.540 --> 00:07:36.980
We know it's negative.

00:07:36.980 --> 00:07:39.370
And, I guess these
ones don't matter.

00:07:39.370 --> 00:07:41.870
But all these are going
to be, instead of being 1,

00:07:41.870 --> 00:07:43.190
they're all going to be -1.

00:07:43.190 --> 00:07:45.070
Very good.

00:07:45.070 --> 00:07:47.520
And there are no
cycles in this graph,

00:07:47.520 --> 00:07:51.391
so we know that the answer
will be well defined.

00:07:51.391 --> 00:07:51.890
OK.

00:07:51.890 --> 00:07:54.780
Everyone with me so far?

00:07:54.780 --> 00:07:55.480
Happy nods?

00:07:55.480 --> 00:07:57.590
Yes.

00:07:57.590 --> 00:08:00.952
So, what algorithm do I know
that solves this problem?

00:08:00.952 --> 00:08:01.910
AUDIENCE: Bellman-Ford.

00:08:01.910 --> 00:08:02.690
PROFESSOR: Bellman-Ford.

00:08:02.690 --> 00:08:03.190
Good.

00:08:09.260 --> 00:08:11.290
What is the running
time of Bellman-Ford?

00:08:11.290 --> 00:08:14.230
AUDIENCE: [INAUDIBLE].

00:08:14.230 --> 00:08:15.420
PROFESSOR: Cool.

00:08:15.420 --> 00:08:17.400
Suppose I have N cards.

00:08:17.400 --> 00:08:20.585
How many vertices do I have?

00:08:20.585 --> 00:08:23.420
AUDIENCE: [INAUDIBLE]

00:08:23.420 --> 00:08:25.440
PROFESSOR: Plus the source.

00:08:25.440 --> 00:08:26.350
It's ordering.

00:08:26.350 --> 00:08:27.740
So you're right.

00:08:27.740 --> 00:08:29.010
How many edges do I have?

00:08:33.530 --> 00:08:34.616
Worst case.

00:08:34.616 --> 00:08:35.530
AUDIENCE: N squared.

00:08:35.530 --> 00:08:36.382
PROFESSOR: Yep.

00:08:36.382 --> 00:08:42.080
AUDIENCE: [INAUDIBLE] you mean,
like, the directed [INAUDIBLE]?

00:08:42.080 --> 00:08:43.650
PROFESSOR: No, I
mean Bellman-Ford.

00:08:43.650 --> 00:08:45.358
Then, we're going to
go to that algorithm

00:08:45.358 --> 00:08:47.500
and get the better running time.

00:08:47.500 --> 00:08:50.647
AUDIENCE: Cause isn't
Bellman-Ford e times e?

00:08:50.647 --> 00:08:51.230
PROFESSOR: Oh.

00:08:51.230 --> 00:08:52.625
What?

00:08:52.625 --> 00:08:53.250
AUDIENCE: Yeah.

00:08:53.250 --> 00:08:56.370
PROFESSOR: Yeah, that's what
I-- Did someone say, v plus e?

00:08:56.370 --> 00:09:00.210
Or did I write v plus e?

00:09:00.210 --> 00:09:00.710
Yep.

00:09:00.710 --> 00:09:01.290
You did.

00:09:01.290 --> 00:09:02.776
Thank you.

00:09:02.776 --> 00:09:03.670
So it's v times e.

00:09:07.260 --> 00:09:09.662
So the total running time is.

00:09:09.662 --> 00:09:12.092
aUDIENCE: N squared.

00:09:12.092 --> 00:09:13.064
aUDIENCE: N cubed.

00:09:13.064 --> 00:09:13.980
AUDIENCE: Or, n cubed.

00:09:13.980 --> 00:09:16.952
Yeah, it's multiplying
[INAUDIBLE], too.

00:09:16.952 --> 00:09:20.120
PROFESSOR: You guys
are mean today.

00:09:20.120 --> 00:09:24.490
OK, so n cubed
applying Bellman-Ford.

00:09:24.490 --> 00:09:27.440
There is a better way of
solving this problem, right?

00:09:27.440 --> 00:09:30.630
The Directed Acyclic
Graph Bellman-Ford.

00:09:30.630 --> 00:09:33.950
So let's look at the Directed
Acyclic Graph, not the one

00:09:33.950 --> 00:09:36.600
to be generated by this because
that might be a bit messy.

00:09:36.600 --> 00:09:38.225
And let's try to
compute shortest path.

00:09:40.510 --> 00:09:42.410
s, a, b, c.

00:10:27.200 --> 00:10:28.860
OK, so let's see
how we'd compute

00:10:28.860 --> 00:10:30.690
the shortest path in this graph.

00:10:30.690 --> 00:10:31.570
It's Acyclic, right?

00:10:31.570 --> 00:10:35.467
All the the edges are
pointing downwards.

00:10:35.467 --> 00:10:37.050
So let's try to
compute them directly.

00:10:37.050 --> 00:10:38.360
I'm not going to write
pseudocode first.

00:10:38.360 --> 00:10:39.800
I'm going to write
the formulas, and that

00:10:39.800 --> 00:10:41.050
will get the intuition for it.

00:10:41.050 --> 00:10:43.240
Then, maybe right psuedocode.

00:10:43.240 --> 00:10:46.066
So what is the distance
from the source to itself?

00:10:46.066 --> 00:10:47.730
AUDIENCE: [INAUDIBLE].

00:10:47.730 --> 00:10:50.020
PROFESSOR: Good.

00:10:50.020 --> 00:10:52.820
The first ones are easy, so
I'm going to do them myself.

00:10:52.820 --> 00:10:54.110
sa is 1.

00:10:54.110 --> 00:10:57.010
sb is 2.

00:10:57.010 --> 00:10:58.440
sc is 3.

00:10:58.440 --> 00:11:01.360
And, of course, you guys
get to do the hard ones.

00:11:01.360 --> 00:11:05.155
So the distance
from s to d is what?

00:11:05.155 --> 00:11:08.702
How would I compute it?

00:11:08.702 --> 00:11:11.510
AUDIENCE: There's two paths
to get to [INAUDIBLE].

00:11:11.510 --> 00:11:12.630
PROFESSOR: OK.

00:11:12.630 --> 00:11:16.740
So, I would want the shortest
path from those, right?

00:11:16.740 --> 00:11:17.240
OK.

00:11:17.240 --> 00:11:17.960
So it's 4.

00:11:17.960 --> 00:11:22.700
And the formula for it is the
minimum of two paths, right?

00:11:22.700 --> 00:11:27.220
AUDIENCE: [INAUDIBLE] S
to b, and then b to b.

00:11:27.220 --> 00:11:28.740
PROFESSOR: So, one path is--

00:11:28.740 --> 00:11:30.658
AUDIENCE: [INAUDIBLE]
and s [? and b ?].

00:11:30.658 --> 00:11:33.424
AUDIENCE: [INAUDIBLE].

00:11:33.424 --> 00:11:34.090
PROFESSOR: Wait.

00:11:34.090 --> 00:11:35.420
sa.

00:11:35.420 --> 00:11:37.930
So, first there's
a path from s to a.

00:11:37.930 --> 00:11:40.020
And the edge a to d.

00:11:40.020 --> 00:11:43.140
And then, there's
a path from s to b.

00:11:43.140 --> 00:11:47.170
And the 8 from b to d, right?

00:11:50.220 --> 00:11:52.550
And I already know the
values for sa and sb,

00:11:52.550 --> 00:11:54.550
so this is well defined.

00:11:54.550 --> 00:11:56.540
We can compute it right away.

00:11:56.540 --> 00:11:58.150
No recursion.

00:11:58.150 --> 00:12:00.330
No metrics.

00:12:00.330 --> 00:12:04.960
I mean, there's recursion, but
there's no infinite recursion.

00:12:04.960 --> 00:12:07.060
Does this make sense?

00:12:07.060 --> 00:12:12.095
So, in order to get to d, there
are two edges pointing into d.

00:12:12.095 --> 00:12:13.180
One of them coming from a.

00:12:13.180 --> 00:12:14.470
One of them coming from b.

00:12:14.470 --> 00:12:16.620
So I can either get to
a and take this edge.

00:12:16.620 --> 00:12:19.249
Or get to b and take this edge.

00:12:19.249 --> 00:12:20.790
This is what the
formulas are saying.

00:12:25.620 --> 00:12:28.745
How about se?s
What's the formula?

00:12:33.303 --> 00:12:36.170
AUDIENCE: [INAUDIBLE]

00:12:36.170 --> 00:12:37.190
PROFESSOR: OK.

00:12:37.190 --> 00:12:39.520
What are they?

00:12:39.520 --> 00:12:40.546
AUDIENCE: s3.

00:12:40.546 --> 00:12:44.506
AUDIENCE: Yeah, sa, sb, sc.

00:12:44.506 --> 00:12:45.422
AUDIENCE: [INAUDIBLE].

00:12:45.422 --> 00:12:45.922
Aed's.

00:12:57.270 --> 00:12:58.510
PROFESSOR: And the number?

00:12:58.510 --> 00:13:07.010
AUDIENCE: [INAUDIBLE] 3?

00:13:07.010 --> 00:13:09.510
I think.

00:13:09.510 --> 00:13:11.680
e to e.

00:13:11.680 --> 00:13:13.682
PROFESSOR: OK.

00:13:13.682 --> 00:13:14.182
f.

00:13:18.170 --> 00:13:20.500
Someone that hasn't
spoken today.

00:13:20.500 --> 00:13:24.550
So that I can see
that everyone gets it.

00:13:24.550 --> 00:13:26.360
Please.

00:13:26.360 --> 00:13:27.807
AUDIENCE: dsb--

00:13:27.807 --> 00:13:28.390
PROFESSOR: OK.

00:13:28.390 --> 00:13:32.540
AUDIENCE: --plus wef.

00:13:32.540 --> 00:13:33.850
PROFESSOR: OK.

00:13:33.850 --> 00:13:42.030
AUDIENCE: And dsc plus wcf.

00:13:42.030 --> 00:13:43.440
PROFESSOR: Awesome.

00:13:43.440 --> 00:13:45.386
And that is--

00:13:45.386 --> 00:13:46.257
PROFESSOR: 4.

00:13:46.257 --> 00:13:47.840
PROFESSOR: I'll take
your word for it.

00:13:50.900 --> 00:13:52.460
OK, so now the last one.

00:13:52.460 --> 00:13:53.836
Distance from std.

00:14:04.748 --> 00:14:05.250
AUDIENCE: 5.

00:14:05.250 --> 00:14:05.640
Wait.

00:14:05.640 --> 00:14:06.140
No.

00:14:10.240 --> 00:14:13.676
PROFESSOR: So, let's
write a formula.

00:14:13.676 --> 00:14:14.654
AUDIENCE: Oh, g, not a.

00:14:14.654 --> 00:14:15.445
AUDIENCE: That's 5.

00:14:15.445 --> 00:14:16.225
AUDIENCE: 5.

00:14:16.225 --> 00:14:17.850
PROFESSOR: OK, so
let's write a formula

00:14:17.850 --> 00:14:19.641
to make sure that you
guys are computing it

00:14:19.641 --> 00:14:21.570
in the fastest
possible way for me.

00:14:21.570 --> 00:14:22.800
So--

00:14:22.800 --> 00:14:25.860
sd plus sd to g.

00:14:30.047 --> 00:14:30.630
PROFESSOR: OK.

00:14:33.690 --> 00:14:34.760
Does anyone else?

00:14:34.760 --> 00:14:36.840
Is this the only path?

00:14:36.840 --> 00:14:38.166
AUDIENCE: No.

00:14:38.166 --> 00:14:39.570
There's more.

00:14:39.570 --> 00:14:40.325
PROFESSOR: OK.

00:14:40.325 --> 00:14:43.126
AUDIENCE: Plus e as to f.

00:14:43.126 --> 00:14:45.334
PROFESSOR: Plus e as f.

00:14:45.334 --> 00:14:46.000
AUDIENCE: And n.

00:14:46.000 --> 00:14:47.437
AUDIENCE: c to f.

00:14:47.437 --> 00:14:48.210
I mean, c to g.

00:14:48.210 --> 00:14:50.140
Or, No. no.

00:14:50.140 --> 00:14:51.937
s to c.

00:14:51.937 --> 00:14:52.520
PROFESSOR: OK.

00:14:52.520 --> 00:14:53.390
See, there's a trick.

00:14:53.390 --> 00:14:53.889
OK.

00:14:53.889 --> 00:14:54.970
Cool.

00:14:54.970 --> 00:14:58.476
And then, what are the weights?

00:14:58.476 --> 00:15:01.200
AUDIENCE: w e to g.

00:15:01.200 --> 00:15:01.950
PROFESSOR: e to g.

00:15:01.950 --> 00:15:02.650
Very good.

00:15:02.650 --> 00:15:03.457
AUDIENCE: fg.

00:15:03.457 --> 00:15:04.040
PROFESSOR: fg.

00:15:04.040 --> 00:15:05.792
AUDIENCE: cg.

00:15:05.792 --> 00:15:06.375
PROFESSOR: cg.

00:15:12.990 --> 00:15:15.797
AUDIENCE: Why are
you adding in c?

00:15:15.797 --> 00:15:17.380
AUDIENCE: Because
there's the extra c.

00:15:17.380 --> 00:15:18.713
AUDIENCE: Oh, I didn't see that.

00:15:21.250 --> 00:15:24.339
PROFESSOR: So, the point of this
guy's, is that if you do bfs,

00:15:24.339 --> 00:15:25.130
you'll get tricked.

00:15:28.130 --> 00:15:30.730
Because bfs would put g on
the same level as these.

00:15:30.730 --> 00:15:32.450
And might compute
the value for g

00:15:32.450 --> 00:15:34.144
before it has the
values for these.

00:15:38.320 --> 00:15:41.650
OK, so what order do I need
to compute these numbers in,

00:15:41.650 --> 00:15:42.585
for this to work?

00:15:45.964 --> 00:15:47.940
AUDIENCE: That way
you computed them?

00:15:47.940 --> 00:15:53.701
PROFESSOR: So, that is a, that
is a, something of the graph.

00:15:53.701 --> 00:15:54.200
Yeah.

00:15:54.200 --> 00:15:55.360
AUDIENCE: Oh, topological.

00:15:55.360 --> 00:15:56.026
PROFESSOR: Yeah.

00:15:56.026 --> 00:15:57.100
Stole your answer.

00:16:01.020 --> 00:16:04.710
Topological sort.

00:16:04.710 --> 00:16:07.330
So, any of the
topological sorts works.

00:16:07.330 --> 00:16:09.800
The one we used this
time is sabcdefg.

00:16:14.210 --> 00:16:17.383
Why am I using a
topological sort?

00:16:17.383 --> 00:16:19.230
AUDIENCE: Because
there's dependency.

00:16:19.230 --> 00:16:20.350
PROFESSOR: Yep.

00:16:20.350 --> 00:16:25.700
So, this depends on
this and this, right?

00:16:25.700 --> 00:16:28.880
As c depends on sa, as b as c.

00:16:28.880 --> 00:16:32.225
So basically, every edge
here indicates a dependency.

00:16:32.225 --> 00:16:34.600
In order to compute the shortest
distance from the source

00:16:34.600 --> 00:16:36.560
to here, I need to
know the shortest

00:16:36.560 --> 00:16:38.630
distance from the
source to these two.

00:16:38.630 --> 00:16:41.650
And then I can
look at the edges.

00:16:41.650 --> 00:16:43.725
So, the nice thing
about a topological sort

00:16:43.725 --> 00:16:45.850
is, after I write the
vertices this way,

00:16:45.850 --> 00:16:48.470
all the edges point forward.

00:16:48.470 --> 00:16:50.680
Right? s to a. s to b.

00:16:50.680 --> 00:16:52.285
s to c.

00:16:52.285 --> 00:16:54.150
a to d.

00:16:54.150 --> 00:16:55.492
a to e.

00:16:55.492 --> 00:16:57.125
b to d.

00:16:57.125 --> 00:16:58.470
b to e.

00:16:58.470 --> 00:16:58.970
b to f.

00:16:58.970 --> 00:16:59.740
I can keep going.

00:16:59.740 --> 00:17:02.440
But the point is, there's no
such thing as a backward edge.

00:17:05.400 --> 00:17:09.339
So if I compute the numbers in
this order, when I get to se,

00:17:09.339 --> 00:17:13.180
I know that I computed the
distance from s to abcd.

00:17:13.180 --> 00:17:15.800
And if I have any
edge coming into e,

00:17:15.800 --> 00:17:18.280
I know that I've already
computed the shortest distance

00:17:18.280 --> 00:17:19.829
to the node that
it is coming from.

00:17:22.810 --> 00:17:24.109
yes?

00:17:24.109 --> 00:17:24.950
Did I lose you guys?

00:17:24.950 --> 00:17:26.230
Was this too--

00:17:26.230 --> 00:17:28.750
AUDIENCE: So
basically, like, at a,

00:17:28.750 --> 00:17:32.560
you relaxed all the
edges going out of it.

00:17:32.560 --> 00:17:34.200
PROFESSOR: You can
look at it that way.

00:17:34.200 --> 00:17:38.350
But what we're doing here
is I'm looking at a node

00:17:38.350 --> 00:17:41.000
and I'm relaxing all the
edges coming into a node.

00:17:41.000 --> 00:17:42.027
AUDIENCE: OK.

00:17:42.027 --> 00:17:43.610
PROFESSOR: So this
matches this order.

00:17:43.610 --> 00:17:44.327
AUDIENCE: OK.

00:17:44.327 --> 00:17:46.410
PROFESSOR: What you said
doesn't match this order.

00:17:46.410 --> 00:17:47.710
But it's exactly the same thing.

00:17:47.710 --> 00:17:48.030
AUDIENCE: Oh.

00:17:48.030 --> 00:17:49.780
PROFESSOR: It'll give
you the same result.

00:17:49.780 --> 00:17:52.790
AUDIENCE: You'd get the first
value at g when you reach c.

00:17:52.790 --> 00:17:54.565
But, like, end up
with the same answer.

00:17:54.565 --> 00:17:55.190
PROFESSOR: Yep.

00:17:55.190 --> 00:17:58.709
AUDIENCE: We're still going
backwards then, instead of--

00:17:58.709 --> 00:18:00.750
PROFESSOR: As long as
you're processing the nodes

00:18:00.750 --> 00:18:04.010
in the topological sort
order, all the algorithms

00:18:04.010 --> 00:18:06.190
will work because
you're just computing

00:18:06.190 --> 00:18:07.880
these terms in a
different order.

00:18:07.880 --> 00:18:10.450
But as long as the
dependencies are satisfied,

00:18:10.450 --> 00:18:14.330
you're still going to
get the right thing.

00:18:14.330 --> 00:18:17.079
OK, so what's the
running time of this?

00:18:17.079 --> 00:18:18.620
How many people know
the running time

00:18:18.620 --> 00:18:24.030
without having to write
pseudocode for this?

00:18:24.030 --> 00:18:26.601
I know the answer beforehand,
so I cheated, obviously.

00:18:26.601 --> 00:18:27.100
OK.

00:18:27.100 --> 00:18:28.570
AUDIENCE: Is it a?

00:18:28.570 --> 00:18:29.600
[INAUDIBLE] edges.

00:18:29.600 --> 00:18:30.350
PROFESSOR: Almost.

00:18:30.350 --> 00:18:30.981
Very close.

00:18:30.981 --> 00:18:31.814
[INTERPOSING VOICES]

00:18:38.751 --> 00:18:40.250
PROFESSOR: So, it's
the topological.

00:18:40.250 --> 00:18:42.100
So, running time
plus the running time

00:18:42.100 --> 00:18:43.110
for evaluating this.

00:18:43.110 --> 00:18:45.740
The running time for evaluating
this is v plus e because you

00:18:45.740 --> 00:18:49.200
have every h shows up
exactly once in here.

00:18:49.200 --> 00:18:50.510
So you have e terms.

00:18:50.510 --> 00:18:53.130
And you have v vertices, even
if you don't have any edge,

00:18:53.130 --> 00:18:55.160
you have to initialize
the verdicts.

00:18:55.160 --> 00:18:57.473
So that's why it's v plus e.

00:18:57.473 --> 00:19:00.630
AUDIENCE: It's also
topological sort.

00:19:00.630 --> 00:19:04.350
PROFESSOR: So, this is the
order in which we process this.

00:19:04.350 --> 00:19:06.850
So everything is v plus e.

00:19:06.850 --> 00:19:09.740
If we use this algorithm
to solve this problem,

00:19:09.740 --> 00:19:11.317
what will the running time be?

00:19:14.375 --> 00:19:15.480
AUDIENCE: n.

00:19:15.480 --> 00:19:16.970
AUDIENCE: n squared.

00:19:16.970 --> 00:19:17.845
AUDIENCE: It's an no.

00:19:17.845 --> 00:19:21.320
PROFESSOR: So, it's v
prime plus u prime, which

00:19:21.320 --> 00:19:31.810
is n squared plus [INAUDIBLE]
squared, which is n squared.

00:19:31.810 --> 00:19:34.840
So, by observing that
this graph is acyclic,

00:19:34.840 --> 00:19:38.410
we have a better running
time than Bellman-Ford.

00:19:38.410 --> 00:19:41.200
Even though we used
exactly the same intuition

00:19:41.200 --> 00:19:42.400
that we used up until now.

00:19:42.400 --> 00:19:44.020
Model the problem as a graph.

00:19:44.020 --> 00:19:46.040
Figure out what the edges are.

00:19:46.040 --> 00:19:47.980
Run a shortest path algorithm.

00:19:47.980 --> 00:19:49.900
We have a better
shortest path algorithm,

00:19:49.900 --> 00:19:51.940
which works for
Directed Acyclic Graphs,

00:19:51.940 --> 00:19:53.810
so we get a better running time.

00:19:56.590 --> 00:19:58.590
OK, questions for
what we did so far?

00:20:02.470 --> 00:20:06.360
AUDIENCE: It's [INAUDIBLE]
on this graph here,

00:20:06.360 --> 00:20:08.560
then you would do
the same thing.

00:20:08.560 --> 00:20:11.580
Take each node and then
relax the incoming edges.

00:20:15.300 --> 00:20:16.700
PROFESSOR: Yeah.

00:20:16.700 --> 00:20:19.288
So what is the
topological sort of this?

00:20:19.288 --> 00:20:21.000
AUDIENCE: [INAUDIBLE]

00:20:21.000 --> 00:20:23.000
PROFESSOR: It's exactly
the cards in the order

00:20:23.000 --> 00:20:25.740
that they're on
the board, right?

00:20:25.740 --> 00:20:30.050
So, in dynamic programming,
the topological sort order

00:20:30.050 --> 00:20:31.690
is obvious.

00:20:31.690 --> 00:20:33.760
So the hard part is
representing the state

00:20:33.760 --> 00:20:35.730
and figuring out what
the dependencies are.

00:20:35.730 --> 00:20:36.700
So what the edges are.

00:20:36.700 --> 00:20:39.329
And after that, the
topological sort usually comes,

00:20:39.329 --> 00:20:40.495
it's fairly straightforward.

00:20:44.370 --> 00:20:47.910
OK, so what we can do now,
we have a few directions

00:20:47.910 --> 00:20:49.239
in which we can go.

00:20:49.239 --> 00:20:50.780
We can write the
pseudocode for this.

00:20:56.250 --> 00:21:00.100
I mean, it's
basically, it's just,

00:21:00.100 --> 00:21:02.900
we're going to write abstract
things instead of this.

00:21:02.900 --> 00:21:06.240
So we're going to write one
piece of pseudocode that

00:21:06.240 --> 00:21:07.500
evaluates these.

00:21:07.500 --> 00:21:12.470
So it's just
generalizing this thing.

00:21:12.470 --> 00:21:14.420
Something else we
can do is we can

00:21:14.420 --> 00:21:18.790
look at how would these things
get computed using memoization?

00:21:24.030 --> 00:21:28.215
We can look at how we would
compute shortest path in graphs

00:21:28.215 --> 00:21:29.270
with cycles.

00:21:29.270 --> 00:21:30.960
So this assumes we have a DAG.

00:21:30.960 --> 00:21:31.920
What if we have cycles?

00:21:31.920 --> 00:21:34.560
How do we deal with them?

00:21:34.560 --> 00:21:38.380
Or we can do another DP problem,
and see how we'd model that.

00:21:43.220 --> 00:21:45.160
So, votes?

00:21:45.160 --> 00:21:46.590
What do people want to see?

00:21:46.590 --> 00:21:49.420
I think we might have time for
two things, out of these four.

00:21:49.420 --> 00:21:51.360
So, everyone votes for one.

00:21:51.360 --> 00:21:52.490
And we'll start with that.

00:21:52.490 --> 00:21:53.442
Sorry?

00:21:53.442 --> 00:21:55.161
AUDIENCE: DP problem.

00:21:55.161 --> 00:21:56.910
PROFESSOR: OK, so one
vote for DP problem.

00:21:56.910 --> 00:21:59.020
AUDIENCE: Yeah.

00:21:59.020 --> 00:21:59.832
PROFESSOR: OK.

00:21:59.832 --> 00:22:00.540
AUDIENCE: Cyclic.

00:22:04.017 --> 00:22:05.725
AUDIENCE: Wait, you
got two or one votes?

00:22:05.725 --> 00:22:06.440
PROFESSOR: One vote.

00:22:06.440 --> 00:22:06.690
AUDIENCE: OK.

00:22:06.690 --> 00:22:07.190
I'll DP.

00:22:07.190 --> 00:22:10.576
AUDIENCE: I'll stick
with [INAUDIBLE].

00:22:10.576 --> 00:22:12.990
AUDIENCE: DP.

00:22:12.990 --> 00:22:14.811
PROFESSOR: I think
we're done here.

00:22:14.811 --> 00:22:15.310
All right.

00:22:15.310 --> 00:22:16.370
So, new DP problem.

00:22:19.830 --> 00:22:22.760
So, suppose you have something
like Manhattan's map, which

00:22:22.760 --> 00:22:26.210
is basically a lattice.

00:22:26.210 --> 00:22:28.830
Fancy math term for a grid.

00:22:36.970 --> 00:22:41.085
And suppose it we can
only go forward and down.

00:22:43.840 --> 00:22:46.090
So, all the streets are
one way because they

00:22:46.090 --> 00:22:48.420
liked how people drive
in San Francisco,

00:22:48.420 --> 00:22:50.545
and decided they're going
to do the same craziness.

00:23:04.320 --> 00:23:08.520
So, we want to go from s to t.

00:23:08.520 --> 00:23:14.590
And there are different
cost on all these edges.

00:23:14.590 --> 00:23:18.450
This is an n by m matrix.

00:23:18.450 --> 00:23:24.660
And I want to get from s to t
in the shortest possible way.

00:23:24.660 --> 00:23:27.420
So, let's model the problem.

00:23:27.420 --> 00:23:30.784
And then let's do
recursion formulas

00:23:30.784 --> 00:23:33.200
and make it look like a DP
instead of like a graph problem

00:23:33.200 --> 00:23:35.220
because-- it might be
too easy of a graph

00:23:35.220 --> 00:23:37.397
problem in hindsight.

00:23:37.397 --> 00:23:38.730
OK, so what's the graph problem?

00:23:38.730 --> 00:23:41.135
AUDIENCE: It's not equivalent.

00:23:41.135 --> 00:23:42.260
AUDIENCE: Topological sort.

00:23:42.260 --> 00:23:44.647
And then bfs.

00:23:44.647 --> 00:23:45.230
PROFESSOR: OK.

00:23:45.230 --> 00:23:46.180
Topological sort.

00:23:46.180 --> 00:23:50.340
And then, and then that.

00:23:50.340 --> 00:23:53.530
Well, let's write
this as, let's say

00:23:53.530 --> 00:23:57.890
that each node is so let's say
that the nodes have numbers,

00:23:57.890 --> 00:23:58.390
right?

00:23:58.390 --> 00:24:03.980
So this is 1,1 and this is 5,4.

00:24:03.980 --> 00:24:07.566
And I want to write
this using math, so 2,1.

00:24:07.566 --> 00:24:09.470
3,1.

00:24:09.470 --> 00:24:10.898
4,1.

00:24:10.898 --> 00:24:13.600
5,1.

00:24:13.600 --> 00:24:16.420
And then, 1,2.

00:24:16.420 --> 00:24:18.575
1,3.

00:24:18.575 --> 00:24:21.440
1,4.

00:24:21.440 --> 00:24:23.170
OK, so this is the graph.

00:24:23.170 --> 00:24:26.020
The shortest path from
here to here is obvious.

00:24:26.020 --> 00:24:27.516
By the way, this
is a real problem

00:24:27.516 --> 00:24:29.140
for people who don't
see the connection

00:24:29.140 --> 00:24:31.950
between dynamic
programming and graphs.

00:24:31.950 --> 00:24:34.900
I This problem has tripped
up people on exams before.

00:24:34.900 --> 00:24:36.320
So it's not a toy problem.

00:24:38.915 --> 00:24:39.415
OK.

00:24:39.415 --> 00:24:40.981
AUDIENCE: So, on an
examine, would you

00:24:40.981 --> 00:24:43.290
have the option of just using
a straight up graph algorithm--

00:24:43.290 --> 00:24:45.410
PROFESSOR: Well, we're going to
ask you to solve this using DP.

00:24:45.410 --> 00:24:48.380
So let's try to solve this using
dynamic programming by writing

00:24:48.380 --> 00:24:50.430
recursion formulas.

00:24:50.430 --> 00:24:58.590
So, what's the shortest
distance to 1,1.

00:24:58.590 --> 00:25:01.157
AUDIENCE: 0.

00:25:01.157 --> 00:25:01.990
PROFESSOR: OK, then.

00:25:01.990 --> 00:25:06.390
If I have a general distance,
if I have some random node here,

00:25:06.390 --> 00:25:09.478
dij, how do I compute this?

00:25:09.478 --> 00:25:11.430
AUDIENCE: It's a
minimum distance

00:25:11.430 --> 00:25:15.310
between the distance
of law plus weights.

00:25:15.310 --> 00:25:17.790
AUDIENCE: Or the distance of j.

00:25:17.790 --> 00:25:19.307
i minus one.

00:25:19.307 --> 00:25:19.806
Yeah.

00:25:22.690 --> 00:25:24.100
PROFESSOR: So, i minus 1 j.

00:25:24.100 --> 00:25:25.270
AUDIENCE: Yeah.

00:25:25.270 --> 00:25:27.380
We get it.

00:25:27.380 --> 00:25:32.645
Plus the weight of the, yeah.

00:25:32.645 --> 00:25:35.308
AUDIENCE: Going from
one to the other.

00:25:35.308 --> 00:25:40.380
PROFESSOR: OK, so the weight
from i minus 1 j to ij.

00:25:40.380 --> 00:25:41.440
OK.

00:25:41.440 --> 00:25:42.490
And?

00:25:42.490 --> 00:25:45.000
AUDIENCE: j minus 1i.

00:25:45.000 --> 00:25:49.030
For i, j minus 1.

00:25:49.030 --> 00:25:52.495
PROFESSOR: ij minus 1.

00:25:52.495 --> 00:25:58.184
AUDIENCE: Plus
weight of that ij.

00:25:58.184 --> 00:26:01.537
ij minus j1 to ij.

00:26:01.537 --> 00:26:04.900
ij [INAUDIBLE]

00:26:04.900 --> 00:26:05.904
PROFESSOR: OK.

00:26:05.904 --> 00:26:07.070
So these are the recursions.

00:26:07.070 --> 00:26:10.450
Now, how would I write the
full set of code for this?

00:26:10.450 --> 00:26:15.713
So what's a valid topological
sort for these guys?

00:26:15.713 --> 00:26:16.296
AUDIENCE: 1,1.

00:26:16.296 --> 00:26:16.796
2,1.

00:26:16.796 --> 00:26:18.220
3,1.

00:26:18.220 --> 00:26:19.182
AUDIENCE: Dials.

00:26:19.182 --> 00:26:20.144
AUDIENCE: 1,2.

00:26:20.144 --> 00:26:22.550
AUDIENCE: The right dials.

00:26:22.550 --> 00:26:25.270
PROFESSOR: That's going
to be hard to code.

00:26:25.270 --> 00:26:26.735
That's going to be easy to code.

00:26:26.735 --> 00:26:28.110
So I'm going to
take your answer.

00:26:28.110 --> 00:26:28.425
AUDIENCE: OK.

00:26:28.425 --> 00:26:28.740
AUDIENCE: What?

00:26:28.740 --> 00:26:30.420
PROFESSOR: I'm not going to take
your answer because your answer

00:26:30.420 --> 00:26:32.148
is correct, but
it's hard to code.

00:26:32.148 --> 00:26:34.590
AUDIENCE: But isn't that
the same thing [INAUDIBLE]?

00:26:34.590 --> 00:26:36.080
PROFESSOR: She
says, go like this.

00:26:36.080 --> 00:26:36.621
AUDIENCE: Oh.

00:26:36.621 --> 00:26:37.620
Oh.

00:26:37.620 --> 00:26:39.850
PROFESSOR: So, here's how
I'm going to code them.

00:26:39.850 --> 00:26:45.746
4i in 1,2n.

00:26:45.746 --> 00:26:50.695
4j in 1 to m.

00:26:53.360 --> 00:27:01.260
So, I guess, first off, if i
is 1 and j is 1, then d of ij

00:27:01.260 --> 00:27:02.020
is 0, right?

00:27:02.020 --> 00:27:05.490
This is the base case.

00:27:05.490 --> 00:27:12.140
Otherwise, d of ij
equals big bad formula

00:27:12.140 --> 00:27:13.070
that we have up there.

00:27:17.290 --> 00:27:17.790
OK.

00:27:17.790 --> 00:27:20.030
Do we need anything else?

00:27:20.030 --> 00:27:21.464
AUDIENCE: DP.

00:27:21.464 --> 00:27:22.380
PROFESSOR: This is DP.

00:27:22.380 --> 00:27:22.944
We're done.

00:27:22.944 --> 00:27:23.610
AUDIENCE: Is it?

00:27:23.610 --> 00:27:24.220
PROFESSOR: Almost work.

00:27:24.220 --> 00:27:24.860
Yeah, this is--

00:27:24.860 --> 00:27:25.630
AUDIENCE: Over [INAUDIBLE]--

00:27:25.630 --> 00:27:26.826
AUDIENCE: I thought this
was just programming.

00:27:26.826 --> 00:27:27.310
AUDIENCE: --it's a
dictionary, though.

00:27:27.310 --> 00:27:27.910
PROFESSOR: Yeah.

00:27:27.910 --> 00:27:28.400
It's programming.

00:27:28.400 --> 00:27:30.280
So this is the DP
solution to the program

00:27:30.280 --> 00:27:32.400
because, instead of
building the graph,

00:27:32.400 --> 00:27:34.410
you're writing the recursion.

00:27:34.410 --> 00:27:38.060
And you're writing using
this implicit representation

00:27:38.060 --> 00:27:40.284
of the graph.

00:27:40.284 --> 00:27:41.844
AUDIENCE: Oh.

00:27:41.844 --> 00:27:42.760
PROFESSOR: This is it.

00:27:42.760 --> 00:27:44.440
This is DP.

00:27:44.440 --> 00:27:45.940
Most people are
really afraid of it.

00:27:45.940 --> 00:27:47.360
This is the hardest
thing in the course.

00:27:47.360 --> 00:27:49.443
If you get the connection
between graphs and this,

00:27:49.443 --> 00:27:51.318
and if you know how to
model graphs, that it.

00:27:51.318 --> 00:27:52.818
You're one month
in the term, you're

00:27:52.818 --> 00:27:53.960
done with six double six.

00:27:53.960 --> 00:27:57.130
You already know
everything to ace the exam.

00:27:57.130 --> 00:27:57.630
OK.

00:27:57.630 --> 00:27:59.713
AUDIENCE: Aren't graphs
just programming, as well?

00:28:01.467 --> 00:28:02.050
PROFESSOR: Ah.

00:28:02.050 --> 00:28:03.925
But there, you're building
a graph structure.

00:28:03.925 --> 00:28:05.830
Here, we don't need to
build that structure.

00:28:05.830 --> 00:28:07.454
Because we see the
connection directly.

00:28:07.454 --> 00:28:09.740
Like, this code is
much smaller, right?

00:28:09.740 --> 00:28:12.057
It's much easier to look at.

00:28:12.057 --> 00:28:12.640
I mean, sorry.

00:28:12.640 --> 00:28:13.851
It's faster to read.

00:28:13.851 --> 00:28:15.350
But it looks like
black magic if you

00:28:15.350 --> 00:28:18.841
don't see the underlying graph.

00:28:18.841 --> 00:28:19.340
Yes?

00:28:19.340 --> 00:28:20.110
Did you have a question?

00:28:20.110 --> 00:28:20.901
AUDIENCE: Yeah, so.

00:28:20.901 --> 00:28:23.120
What exactly is
dynamic programming?

00:28:23.120 --> 00:28:27.811
Unless they give at least
one or two examples of,

00:28:27.811 --> 00:28:31.789
like, using something that you
had calculated already, or--

00:28:31.789 --> 00:28:32.455
PROFESSOR: Yeah.

00:28:32.455 --> 00:28:33.371
AUDIENCE: --Fibinocci.

00:28:33.371 --> 00:28:33.871
So.

00:28:33.871 --> 00:28:34.537
PROFESSOR: Yeah.

00:28:34.537 --> 00:28:35.040
So--

00:28:35.040 --> 00:28:35.820
AUDIENCE: Ah, so
now you just have

00:28:35.820 --> 00:28:38.017
to have a dictionary to
store the minimum cost.

00:28:38.017 --> 00:28:39.475
AUDIENCE: That's
what d is, though.

00:28:39.475 --> 00:28:40.305
The d of ij.

00:28:40.305 --> 00:28:40.930
AUDIENCE: Wait.

00:28:40.930 --> 00:28:42.100
PROFESSOR: So.

00:28:42.100 --> 00:28:43.340
So I like your question.

00:28:43.340 --> 00:28:45.614
And I'm going to address
all the other ones first.

00:28:45.614 --> 00:28:47.530
And then I'm going to
spend about five minutes

00:28:47.530 --> 00:28:48.600
addressing your question.

00:28:48.600 --> 00:28:51.460
What is dynamic
programming, right?

00:28:51.460 --> 00:28:52.670
What is the point of this?

00:28:52.670 --> 00:29:00.770
Like, what is
dynamic programming?

00:29:00.770 --> 00:29:02.760
We're going to
come back to this.

00:29:02.760 --> 00:29:05.686
So any questions about this?

00:29:05.686 --> 00:29:06.310
AUDIENCE: Wait.

00:29:06.310 --> 00:29:07.351
As you're going through--

00:29:07.351 --> 00:29:10.000
AUDIENCE: Is there a dictionary?

00:29:10.000 --> 00:29:11.320
PROFESSOR: Sure.

00:29:11.320 --> 00:29:12.040
This is an array.

00:29:12.040 --> 00:29:13.580
Or dictionary.

00:29:13.580 --> 00:29:16.628
So, say this is ij.

00:29:16.628 --> 00:29:18.430
If it's an array, or
if it's a dictionary,

00:29:18.430 --> 00:29:21.210
it would be d of the tuple ij.

00:29:24.810 --> 00:29:27.160
So, I can write this
in Python, right?

00:29:27.160 --> 00:29:30.140
This is almost Python.

00:29:30.140 --> 00:29:32.084
What am I missing?

00:29:32.084 --> 00:29:34.995
AUDIENCE: [INAUDIBLE],
or it fits inside.

00:29:34.995 --> 00:29:35.620
PROFESSOR: Yes.

00:29:35.620 --> 00:29:37.411
So, I have some boundary
conditions, right?

00:29:37.411 --> 00:29:40.755
Because this guy would depend
on this guy, which is inside.

00:29:40.755 --> 00:29:42.910
And left to depend on this guy.

00:29:42.910 --> 00:29:45.329
Which doesn't exist.

00:29:45.329 --> 00:29:45.870
AUDIENCE: Oh.

00:29:45.870 --> 00:29:46.766
I wasn't-- OK.

00:29:46.766 --> 00:29:47.589
Sure.

00:29:47.589 --> 00:29:49.380
PROFESSOR: So, we need
a few more ifs here,

00:29:49.380 --> 00:29:50.379
for boundary conditions.

00:29:58.594 --> 00:30:02.340
AUDIENCE: I mean, in theory,
though, you could just

00:30:02.340 --> 00:30:04.342
run through the
new dfs and create

00:30:04.342 --> 00:30:06.120
a topological of the source.

00:30:06.120 --> 00:30:06.620
Right?

00:30:06.620 --> 00:30:07.870
And just run through that.

00:30:07.870 --> 00:30:08.010
PROFESSOR: Yeah.

00:30:08.010 --> 00:30:09.390
But that's so much
code to write.

00:30:09.390 --> 00:30:10.090
Look at this.

00:30:10.090 --> 00:30:11.040
This is five lines.

00:30:11.040 --> 00:30:11.660
AUDIENCE: Well, yeah.

00:30:11.660 --> 00:30:13.520
For this particular
problem, it's five lines.

00:30:13.520 --> 00:30:15.228
PROFESSOR: Well, for
dynamic programming,

00:30:15.228 --> 00:30:17.850
the solutions are 5 to
10 lines in general.

00:30:17.850 --> 00:30:20.750
And the only hard thing
in dynamic programming

00:30:20.750 --> 00:30:24.276
is figuring out what is
the state going to be.

00:30:24.276 --> 00:30:26.650
So, after you get used to
them, after you solve 10 or 20,

00:30:26.650 --> 00:30:28.660
when people come out of
programming contests,

00:30:28.660 --> 00:30:31.240
and someone says, my
solution's dynamic programming.

00:30:31.240 --> 00:30:31.740
Really?

00:30:31.740 --> 00:30:33.073
Wait, you can solve it that way.

00:30:33.073 --> 00:30:33.830
And he says, yeah.

00:30:33.830 --> 00:30:34.580
This is the state.

00:30:34.580 --> 00:30:36.082
And then everything
else is obvious.

00:30:36.082 --> 00:30:38.290
Like, it's pretty easy to
figure out everything else.

00:30:38.290 --> 00:30:39.429
The hard part is the state.

00:30:39.429 --> 00:30:40.970
So, it's enough to
say my solution is

00:30:40.970 --> 00:30:41.803
dynamic programming.

00:30:41.803 --> 00:30:42.742
This is my state.

00:30:42.742 --> 00:30:44.200
You guys are probably
going to have

00:30:44.200 --> 00:30:46.142
to say a bit more
than that on the exam.

00:30:46.142 --> 00:30:47.630
But this is the hard part.

00:30:47.630 --> 00:30:49.199
AUDIENCE: DP.

00:30:49.199 --> 00:30:50.740
PROFESSOR: No, you
can't just say DP.

00:30:50.740 --> 00:30:52.406
You'll definitely
need at least a state.

00:30:56.820 --> 00:30:57.580
OK.

00:30:57.580 --> 00:30:58.080
So.

00:30:58.080 --> 00:30:59.621
AUDIENCE: You're
also missing a state

00:30:59.621 --> 00:31:02.302
for deciding stuff in the
dictionary, though, right?

00:31:02.302 --> 00:31:04.260
PROFESSOR: Before deciding
if my key is already

00:31:04.260 --> 00:31:05.880
in the dictionary?

00:31:05.880 --> 00:31:08.370
Well, so, aside from the
boundary conditions here,

00:31:08.370 --> 00:31:12.810
if I compute this here, it
depends on theses two, right?

00:31:12.810 --> 00:31:16.074
Are they going to be
in the dictionary?

00:31:16.074 --> 00:31:17.050
AUDIENCE: Not yet.

00:31:17.050 --> 00:31:17.920
PROFESSOR: Why?

00:31:17.920 --> 00:31:20.560
If I'm running
this way, so if I'm

00:31:20.560 --> 00:31:23.210
computing all my
values in this order.

00:31:23.210 --> 00:31:24.283
So the first line one.

00:31:24.283 --> 00:31:24.866
Then line two.

00:31:24.866 --> 00:31:26.714
Then line three.

00:31:26.714 --> 00:31:28.630
They're already going
to be in the dictionary.

00:31:28.630 --> 00:31:31.440
So this is because I'm
doing topological sort.

00:31:31.440 --> 00:31:33.170
You don't need
memoization if you're not

00:31:33.170 --> 00:31:35.010
using the topological
sort of the graph.

00:31:35.010 --> 00:31:38.550
You only need
memoization if you don't.

00:31:38.550 --> 00:31:42.877
AUDIENCE: So, why are we doing
boundaries commissions if--

00:31:42.877 --> 00:31:43.710
PROFESSOR: Because--

00:31:43.710 --> 00:31:45.580
AUDIENCE: [INAUDIBLE].

00:31:45.580 --> 00:31:47.810
PROFESSOR: So, I'm doing
a boundary condition

00:31:47.810 --> 00:31:53.500
because if I paste this in if I
paste this thing in, then when

00:31:53.500 --> 00:31:56.380
I am here, this is going
to refer to this guy.

00:31:56.380 --> 00:31:57.420
Which is fine.

00:31:57.420 --> 00:31:59.490
But it's also going
to refer to 2,0.

00:31:59.490 --> 00:32:00.700
Which doesn't exist.

00:32:06.980 --> 00:32:09.200
So the code might be a bit
obfuscated by the boundary

00:32:09.200 --> 00:32:09.699
conditions.

00:32:09.699 --> 00:32:11.140
But it's 10 lines of code.

00:32:11.140 --> 00:32:13.940
It's pretty nice
and straightforward.

00:32:13.940 --> 00:32:15.650
OK, now what is
dynamic programming?

00:32:15.650 --> 00:32:18.300
I like that question.

00:32:18.300 --> 00:32:20.060
PROFESSOR: So, a key
property, I don't

00:32:20.060 --> 00:32:21.280
think it was
mentioned in lecture.

00:32:21.280 --> 00:32:22.530
Guys, correct me if I'm wrong.

00:32:22.530 --> 00:32:24.570
It's called optimal
substructure.

00:32:24.570 --> 00:32:26.249
Does that ring a bell?

00:32:26.249 --> 00:32:28.165
Probably going to hear
about it next time, so.

00:32:32.820 --> 00:32:37.435
Optimal substructure.

00:32:43.560 --> 00:32:45.400
So, the point of
optimal substructure

00:32:45.400 --> 00:32:49.800
is, suppose I have a
shortest path from s to g.

00:32:49.800 --> 00:32:50.300
Right?

00:33:01.810 --> 00:33:11.580
so, suppose I have
shortest path from s to g.

00:33:14.230 --> 00:33:17.130
And that path is called p.

00:33:17.130 --> 00:33:20.660
Now, suppose this
path goes through d.

00:33:20.660 --> 00:33:28.320
So, path from s to g is actually
s making a path through d.

00:33:28.320 --> 00:33:32.470
And then there's another
path going from d to g.

00:33:36.740 --> 00:33:40.430
This path over here, p1.

00:33:40.430 --> 00:33:48.660
p1 is guaranteed to be the
shortest path, or a shortest

00:33:48.660 --> 00:33:50.580
path, from s to d.

00:33:53.920 --> 00:33:56.800
So this is the big solution.

00:33:56.800 --> 00:34:00.200
It's optimal because we say it's
the solution to the problem.

00:34:00.200 --> 00:34:02.910
This is a part of the solution.

00:34:02.910 --> 00:34:05.660
This part of the solution
is optimal for this part

00:34:05.660 --> 00:34:07.300
of the problem.

00:34:07.300 --> 00:34:11.282
So the part of the problem
is getting from s to d.

00:34:11.282 --> 00:34:14.760
The part of the big
optimal solution

00:34:14.760 --> 00:34:18.090
is optimal-- so the small
part of the big solution

00:34:18.090 --> 00:34:20.900
is optimal with respect
to the small problem.

00:34:20.900 --> 00:34:25.270
So p1 has to be a
shortest path from s to d.

00:34:25.270 --> 00:34:27.560
Do you guys want to see
a proof by contradiction?

00:34:27.560 --> 00:34:28.834
Or do take my word for it?

00:34:32.300 --> 00:34:34.339
Does anyone want to?

00:34:34.339 --> 00:34:36.630
So, intuitively, the idea is
that if you had the better

00:34:36.630 --> 00:34:39.360
path here, say that
path would be s3,

00:34:39.360 --> 00:34:42.050
then I could replace
this, sorry. p3.

00:34:42.050 --> 00:34:44.130
I could replace this with p3.

00:34:44.130 --> 00:34:46.594
And I would have a
better path overall.

00:34:46.594 --> 00:34:48.010
And that would
contradict the fact

00:34:48.010 --> 00:34:51.340
that this is the best path.

00:34:51.340 --> 00:34:53.600
So this part of the path
has to be a shortest path

00:34:53.600 --> 00:34:56.310
to get from s to d.

00:34:56.310 --> 00:35:00.250
So I've broken up my
problem to get from s to g,

00:35:00.250 --> 00:35:03.320
into saying, I want to get
from s to d, from s to e.

00:35:03.320 --> 00:35:06.570
Or, from s to f and
then cross one edge.

00:35:06.570 --> 00:35:09.730
And then the ways I get from
s to d from s to e, or from s

00:35:09.730 --> 00:35:13.150
to f, have to be optimal.

00:35:13.150 --> 00:35:15.830
I've already encoded that here.

00:35:15.830 --> 00:35:18.430
And nobody asked me,
yo, is this true?

00:35:18.430 --> 00:35:20.330
Can I take a longer path here?

00:35:20.330 --> 00:35:22.240
And have a better solution?

00:35:22.240 --> 00:35:23.520
The answer is no.

00:35:23.520 --> 00:35:26.007
In some problems,
the answer is yes.

00:35:26.007 --> 00:35:27.465
Those are not
problems that you can

00:35:27.465 --> 00:35:29.790
solve with dynamic programming.

00:35:29.790 --> 00:35:31.450
if, in your problems,
that's the case,

00:35:31.450 --> 00:35:36.522
you probably forgot to account
for some part of the state.

00:35:36.522 --> 00:35:38.494
AUDIENCE: What kind
of problems would it

00:35:38.494 --> 00:35:40.470
be where that wouldn't be true?

00:35:40.470 --> 00:35:42.620
PROFESSOR: Well,
remember the quiz problem

00:35:42.620 --> 00:35:45.220
with the gas stations?

00:35:45.220 --> 00:35:49.280
If you don't account for the
gas, if you do Dijkstra, then,

00:35:49.280 --> 00:35:49.780
well.

00:35:49.780 --> 00:35:51.850
Guess what?

00:35:51.850 --> 00:35:54.700
Shortest path in
the graph, if that

00:35:54.700 --> 00:35:57.070
doesn't account for gas
stops, if you start accounting

00:35:57.070 --> 00:36:00.410
for the cost of
refilling, this path

00:36:00.410 --> 00:36:02.840
might be longer than a
path that goes like this.

00:36:02.840 --> 00:36:05.970
So, it's longer in
terms of road stalls.

00:36:05.970 --> 00:36:11.170
But has fewer, or has cheaper,
gas stations on the way.

00:36:11.170 --> 00:36:13.840
So then, there's no
optimal substructure.

00:36:13.840 --> 00:36:17.850
And that's because you didn't
account for the fuel states.

00:36:17.850 --> 00:36:18.350
OK.

00:36:18.350 --> 00:36:19.640
Probably not the best example.

00:36:19.640 --> 00:36:23.380
Sorry for bringing
up painful memories.

00:36:23.380 --> 00:36:24.900
But the point is,
usually when you

00:36:24.900 --> 00:36:27.483
have this with our problems, you
didn't account for the state.

00:36:27.483 --> 00:36:31.540
All the problems that are
solved with dynamic programming

00:36:31.540 --> 00:36:33.520
have this thing called
optimal substructure.

00:36:33.520 --> 00:36:37.341
And this is sort
of how it works.

00:36:37.341 --> 00:36:37.840
OK.

00:36:37.840 --> 00:36:40.381
I have no idea how much time I
have because my phone crashed.

00:36:40.381 --> 00:36:42.770
So can anyone help me?

00:36:42.770 --> 00:36:43.610
Five minutes.

00:36:43.610 --> 00:36:44.980
10 minutes.

00:36:44.980 --> 00:36:45.480
Sorry.

00:36:45.480 --> 00:36:46.420
AUDIENCE: Seven minutes.

00:36:46.420 --> 00:36:47.003
PROFESSOR: OK.

00:36:49.710 --> 00:36:53.730
What else do you
guys want to see?

00:36:53.730 --> 00:36:55.730
AUDIENCE: Cycles.

00:36:55.730 --> 00:36:58.017
[INAUDIBLE]

00:36:58.017 --> 00:36:58.600
PROFESSOR: OK.

00:36:58.600 --> 00:37:01.800
Is everyone happy with cycles?

00:37:01.800 --> 00:37:02.390
OK.

00:37:02.390 --> 00:37:04.200
Almost everyone, so
that's good enough.

00:37:08.550 --> 00:37:09.050
OK.

00:37:09.050 --> 00:37:09.680
Let's do cycles.

00:37:09.680 --> 00:37:10.596
We have seven minutes.

00:37:25.380 --> 00:37:28.410
So, suppose I have this graph.

00:37:28.410 --> 00:37:35.440
Source going a going
to be going to c.

00:37:38.520 --> 00:37:43.050
And then the costs
are 1 minus 1.

00:37:43.050 --> 00:37:43.940
1.

00:37:43.940 --> 00:37:44.440
1.

00:37:47.100 --> 00:37:49.180
Can I solve it
using that method?

00:37:53.509 --> 00:37:54.050
Probably not.

00:37:54.050 --> 00:37:57.690
Let's try to write
the recursions

00:37:57.690 --> 00:38:00.460
to see what we get
for the formulas.

00:38:00.460 --> 00:38:02.800
So, dsa is--

00:38:02.800 --> 00:38:05.160
AUDIENCE: 1.

00:38:05.160 --> 00:38:06.140
PROFESSOR: --minimum.

00:38:06.140 --> 00:38:06.700
Yeah, it's 1.

00:38:06.700 --> 00:38:14.450
But it's the minimum
of dss plus weight sa.

00:38:19.080 --> 00:38:20.720
ds-- well, almost.

00:38:24.760 --> 00:38:26.240
Actually, it's not 1.

00:38:26.240 --> 00:38:27.640
Likely.

00:38:27.640 --> 00:38:28.922
You're confusing me again.

00:38:28.922 --> 00:38:31.130
There's one more edges that
they have to account for.

00:38:31.130 --> 00:38:33.480
AUDIENCE: Oh.

00:38:33.480 --> 00:38:37.400
PROFESSOR: dsc plus weight.

00:38:37.400 --> 00:38:38.400
I'm going to fail today.

00:38:38.400 --> 00:38:39.220
I'm tired.

00:38:39.220 --> 00:38:41.300
AUDIENCE: ca.

00:38:41.300 --> 00:38:41.910
PROFESSOR: OK.

00:38:41.910 --> 00:38:45.100
So we accounted for both
edges coming in now.

00:38:45.100 --> 00:38:51.300
dsb is minimum of
dsa plus weight ab.

00:38:54.200 --> 00:39:00.710
dsc is minimum of
dsb plus weight bc.

00:39:03.360 --> 00:39:04.330
Right?

00:39:04.330 --> 00:39:07.742
And dss is 0 because we
promised that's how we start.

00:39:10.320 --> 00:39:10.820
OK.

00:39:10.820 --> 00:39:12.900
Now what if I try
evaluate these?

00:39:12.900 --> 00:39:17.600
Is there a sane order in
which I can evaluate them?

00:39:17.600 --> 00:39:18.170
Nope.

00:39:18.170 --> 00:39:19.110
Let's see why.

00:39:19.110 --> 00:39:26.214
If I try to evaluate
sa, this depends on sc.

00:39:26.214 --> 00:39:27.630
AUDIENCE: Which
we don't have yet.

00:39:27.630 --> 00:39:31.810
PROFESSOR: sc is here.
sc depends on sb.

00:39:31.810 --> 00:39:34.080
sb is here.

00:39:34.080 --> 00:39:36.090
And it depends on sa.

00:39:36.090 --> 00:39:38.790
Which was.

00:39:38.790 --> 00:39:42.701
So we have this infinite
recursion, right?

00:39:42.701 --> 00:39:43.950
They all depend on each other.

00:39:43.950 --> 00:39:46.100
There's a loop here.

00:39:46.100 --> 00:39:47.720
There's a negative cycle.

00:39:47.720 --> 00:39:50.450
Can't use this algorithm.

00:39:50.450 --> 00:39:52.570
That's a shame.

00:39:52.570 --> 00:39:54.802
What can we do instead?

00:39:54.802 --> 00:39:56.135
PROFESSOR: Show a negative node.

00:39:56.135 --> 00:39:57.602
A negative weight.

00:39:57.602 --> 00:39:58.312
half.

00:39:58.312 --> 00:39:59.020
PROFESSOR: Sorry?

00:39:59.020 --> 00:40:01.940
AUDIENCE: Can we just get rid
of the negative weight half?

00:40:01.940 --> 00:40:03.090
PROFESSOR: No.

00:40:03.090 --> 00:40:04.020
That's the best edge.

00:40:04.020 --> 00:40:06.353
That's probably going to be
part of the solution, right?

00:40:06.353 --> 00:40:09.184
AUDIENCE: Can we add
1 to all the edges?

00:40:09.184 --> 00:40:11.100
PROFESSOR: That's still
going to have a cycle.

00:40:11.100 --> 00:40:12.570
I still won't be
able to run this.

00:40:12.570 --> 00:40:13.452
AUDIENCE: Oh, yeah.

00:40:13.452 --> 00:40:14.410
AUDIENCE: Bellman-Ford.

00:40:17.020 --> 00:40:18.020
PROFESSOR: Bellman-ford.

00:40:18.020 --> 00:40:20.110
AUDIENCE: That's not dynamic.

00:40:20.110 --> 00:40:20.910
PROFESSOR: OK.

00:40:20.910 --> 00:40:23.136
Well, one way to do it
is Bellman-Ford, right?

00:40:23.136 --> 00:40:25.010
Another way, which we
went through last time,

00:40:25.010 --> 00:40:27.110
is to break the cycle.

00:40:27.110 --> 00:40:29.380
And the way we break
the cycle is we

00:40:29.380 --> 00:40:32.440
add the path length
into the equation.

00:40:39.379 --> 00:40:40.920
So, I'm going to
look at the distance

00:40:40.920 --> 00:40:44.730
from a source to some
node, so the distance

00:40:44.730 --> 00:40:51.310
from a source to some node, as
the distance from the source

00:40:51.310 --> 00:40:56.280
to some other node
plus the edge weight.

00:40:56.280 --> 00:40:57.660
This is what I
had before, right?

00:40:57.660 --> 00:40:59.270
Nothing new here.

00:40:59.270 --> 00:41:05.910
So dsv is the minimum
over all the edges of dsu

00:41:05.910 --> 00:41:08.710
plus weight uv, Right?

00:41:08.710 --> 00:41:11.880
Minimum over all uv.

00:41:11.880 --> 00:41:14.490
That's our edges.

00:41:14.490 --> 00:41:14.990
Right?

00:41:14.990 --> 00:41:15.906
This is the old stuff.

00:41:15.906 --> 00:41:17.970
Now, we're going to
say this instead.

00:41:17.970 --> 00:41:24.150
The distance from s to v,
using a path of length k,

00:41:24.150 --> 00:41:31.280
is the minimum over all the
edges of the distance from s

00:41:31.280 --> 00:41:35.930
to u, using a path
of what length?

00:41:35.930 --> 00:41:40.200
If this path is length k.

00:41:40.200 --> 00:41:41.140
So k edges.

00:41:41.140 --> 00:41:43.001
How many edges do I have here?

00:41:43.001 --> 00:41:43.876
AUDIENCE: k equals 1.

00:41:48.560 --> 00:41:52.310
PROFESSOR: So this is
distance su using k minus 1

00:41:52.310 --> 00:41:57.090
plus the weight of uv.

00:41:57.090 --> 00:42:01.060
AUDIENCE: So what's the
difference between the two?

00:42:01.060 --> 00:42:05.240
PROFESSOR: So, this
will always decrease.

00:42:05.240 --> 00:42:10.770
So I guarantee that they will
not have an infinite recursion.

00:42:10.770 --> 00:42:12.740
This is the magic
that makes it work.

00:42:12.740 --> 00:42:14.870
Now, an equivalent way
of looking at this,

00:42:14.870 --> 00:42:15.780
is building a graph.

00:42:15.780 --> 00:42:17.280
That's what we've
been doing so far.

00:42:17.280 --> 00:42:21.167
So let's build an
equivalent graph to this.

00:42:21.167 --> 00:42:22.042
AUDIENCE: [INAUDIBLE]

00:42:26.770 --> 00:42:29.350
PROFESSOR: It's going to
get to 0 eventually, right?

00:42:29.350 --> 00:42:36.220
So when k is 0, the distance
from the source to itself is 0.

00:42:36.220 --> 00:42:42.875
But the distance from the source
to any other nodes is infinity.

00:42:42.875 --> 00:42:44.250
Because from the
source, we can't

00:42:44.250 --> 00:42:45.921
get to anywhere else in 0 edges.

00:42:45.921 --> 00:42:46.670
We can't teleport.

00:42:50.227 --> 00:42:52.435
So let's build a graph to
get the intuition for this.

00:42:52.435 --> 00:42:54.220
This looks mathy.

00:42:54.220 --> 00:42:56.770
This looks too mathy.

00:42:56.770 --> 00:42:59.391
So, at the first layer,
you only have the source.

00:42:59.391 --> 00:43:01.140
You can only get from
the source to itself

00:43:01.140 --> 00:43:03.850
by not crossing any edges.

00:43:03.850 --> 00:43:06.170
At level one, you potentially
have all the nodes.

00:43:06.170 --> 00:43:08.070
If the source is
connected to everything,

00:43:08.070 --> 00:43:09.278
you might have all the nodes.

00:43:09.278 --> 00:43:15.770
So, s1, a1, b1, c1.

00:43:15.770 --> 00:43:18.656
Where can you get
from the source?

00:43:18.656 --> 00:43:19.600
AUDIENCE: To a.

00:43:19.600 --> 00:43:22.320
PROFESSOR: To a.

00:43:22.320 --> 00:43:23.940
What's the cost of the edge?

00:43:23.940 --> 00:43:24.720
AUDIENCE: 1.

00:43:24.720 --> 00:43:25.910
PROFESSOR: OK.

00:43:25.910 --> 00:43:27.770
Now, let's build a second layer.

00:43:27.770 --> 00:43:35.940
s2, a2, b2, c2.

00:43:35.940 --> 00:43:38.090
So someone tell me the edges.

00:43:38.090 --> 00:43:41.130
So, assuming I can get
to this node using one

00:43:41.130 --> 00:43:44.110
edge, how can I get to this
other node using two edges?

00:43:46.882 --> 00:43:47.810
AUDIENCE: A to b.

00:43:47.810 --> 00:43:48.980
PROFESSOR: OK. a to b.

00:43:48.980 --> 00:43:50.090
a1 to b2.

00:43:50.090 --> 00:43:51.550
AUDIENCE: 2.

00:43:51.550 --> 00:43:53.390
PROFESSOR: OK.

00:43:53.390 --> 00:43:53.890
Cost?

00:43:53.890 --> 00:43:56.030
AUDIENCE: 1 [INAUDIBLE].

00:43:56.030 --> 00:43:57.440
A1 to c--

00:43:57.440 --> 00:43:59.320
AUDIENCE: That's negative 1.

00:43:59.320 --> 00:44:00.410
PROFESSOR: a1 to b2.

00:44:00.410 --> 00:44:00.910
Thank you.

00:44:04.350 --> 00:44:04.850
OK.

00:44:04.850 --> 00:44:05.942
AUDIENCE: [INAUDIBLE].

00:44:05.942 --> 00:44:06.650
PROFESSOR: Sorry?

00:44:06.650 --> 00:44:08.890
AUDIENCE: Are we
doing anything else?

00:44:08.890 --> 00:44:09.940
PROFESSOR: I think so.

00:44:09.940 --> 00:44:14.730
So, if I'm at b using one edge,
I can get to c using two edges.

00:44:14.730 --> 00:44:15.495
Cost?

00:44:15.495 --> 00:44:16.830
AUDIENCE: 1.

00:44:16.830 --> 00:44:17.510
PROFESSOR: OK.

00:44:17.510 --> 00:44:20.320
If I'm at c using one edge--

00:44:20.320 --> 00:44:21.632
AUDIENCE: a.

00:44:21.632 --> 00:44:22.840
PROFESSOR: --using two edges.

00:44:22.840 --> 00:44:23.803
Cost?

00:44:23.803 --> 00:44:25.487
AUDIENCE: 1.

00:44:25.487 --> 00:44:26.070
PROFESSOR: OK.

00:44:26.070 --> 00:44:29.220
And if I'm at s using one edge?

00:44:29.220 --> 00:44:30.150
AUDIENCE: a.

00:44:30.150 --> 00:44:32.940
AUDIENCE: [INAUDIBLE]

00:44:32.940 --> 00:44:33.830
PROFESSOR: Can you?

00:44:33.830 --> 00:44:36.122
AUDIENCE: There's now edge.

00:44:36.122 --> 00:44:37.246
PROFESSOR: There's no edge.

00:44:37.246 --> 00:44:38.892
AUDIENCE: I thought it was
just like an assumed edge.

00:44:38.892 --> 00:44:39.558
PROFESSOR: Nope.

00:44:39.558 --> 00:44:40.600
Nope.

00:44:40.600 --> 00:44:42.000
Not an edge.

00:44:42.000 --> 00:44:44.870
As to a, cost?

00:44:44.870 --> 00:44:45.370
AUDIENCE: 1.

00:44:45.370 --> 00:44:46.041
PROFESSOR: 1.

00:44:46.041 --> 00:44:46.540
OK.

00:44:46.540 --> 00:44:48.380
Let's build a third level.

00:44:48.380 --> 00:44:53.885
s3, a3, b3, c3.

00:44:57.560 --> 00:44:59.896
Someone dictate
the edges please.

00:44:59.896 --> 00:45:03.137
AUDIENCE: S2 to a3.

00:45:03.137 --> 00:45:04.063
With 1.

00:45:04.063 --> 00:45:06.810
I mean, it's going
to be the exact same.

00:45:06.810 --> 00:45:08.740
PROFESSOR: Yep.

00:45:08.740 --> 00:45:12.440
a2 to b3 minus 1.

00:45:12.440 --> 00:45:15.560
b2 to c3 1.

00:45:15.560 --> 00:45:20.580
And c2 to a3 1.

00:45:20.580 --> 00:45:23.420
So these are exactly
the same edges, right?

00:45:23.420 --> 00:45:25.420
Because they're the
original edges in the graph.

00:45:25.420 --> 00:45:28.520
Every edge in the graph
can connect to levels here.

00:45:32.780 --> 00:45:34.585
So, all edges.

00:45:37.200 --> 00:45:39.830
All edges.

00:45:39.830 --> 00:45:45.790
All edges from s.

00:45:45.790 --> 00:45:46.960
How many layers do I need?

00:45:49.816 --> 00:45:52.367
AUDIENCE: e.

00:45:52.367 --> 00:45:52.950
PROFESSOR: OK.

00:45:52.950 --> 00:45:53.730
Pretty close.

00:45:53.730 --> 00:45:56.752
Let's try something smaller.

00:45:56.752 --> 00:45:57.688
AUDIENCE: a.

00:45:57.688 --> 00:45:58.624
AUDIENCE: Oh.

00:45:58.624 --> 00:46:00.030
That makes no sense.

00:46:00.030 --> 00:46:04.120
PROFESSOR: So, what's the
longest path in a graph?

00:46:04.120 --> 00:46:05.210
Graph of v vertices.

00:46:05.210 --> 00:46:06.340
What is the longest path?

00:46:06.340 --> 00:46:08.000
AUDIENCE: The
number [INAUDIBLE].

00:46:08.000 --> 00:46:09.620
PROFESSOR: The
longest shortest path.

00:46:09.620 --> 00:46:10.940
AUDIENCE: v minus 1.

00:46:10.940 --> 00:46:12.330
PROFESSOR: v minus 1.

00:46:12.330 --> 00:46:14.800
That's how Bellman-Ford
has v minus 1 runs, right?

00:46:14.800 --> 00:46:16.540
AUDIENCE: Oh.

00:46:16.540 --> 00:46:18.780
PROFESSOR: So, a shortest
path can't have a cycle.

00:46:18.780 --> 00:46:21.500
If it has a cycle, then it
means it's an infinite cycle.

00:46:21.500 --> 00:46:23.150
So there's no solution.

00:46:23.150 --> 00:46:24.942
Shortest paths have
no cycles therefore,

00:46:24.942 --> 00:46:26.650
even if they go through
the entire graph,

00:46:26.650 --> 00:46:29.300
they're going to
have v minus 1 edges.

00:46:29.300 --> 00:46:31.890
So I'm going to have
v minus 1 layers.

00:46:35.850 --> 00:46:38.060
Here, I drew three
layers, so I'm done.

00:46:38.060 --> 00:46:40.414
That's why I stopped at three.

00:46:40.414 --> 00:46:42.580
So let's see how many nodes
and how many edges we're

00:46:42.580 --> 00:46:44.371
going to have if we do
this transformation.

00:46:46.580 --> 00:46:57.892
v prime is-- so, how many times
am I going to copy the graph?

00:46:57.892 --> 00:46:59.058
AUDIENCE: Two or thee times.

00:46:59.058 --> 00:47:00.020
AUDIENCE: Three times.

00:47:00.020 --> 00:47:00.603
PROFESSOR: OK.

00:47:00.603 --> 00:47:02.082
And in general terms?

00:47:02.082 --> 00:47:03.230
AUDIENCE: v minus 1.

00:47:03.230 --> 00:47:04.367
AUDIENCE: v minus 1 times.

00:47:04.367 --> 00:47:04.950
PROFESSOR: OK.

00:47:04.950 --> 00:47:08.920
So I'm going to copy the
graph v minus 1 times.

00:47:08.920 --> 00:47:12.320
And then I'm going to add
that one source, right?

00:47:12.320 --> 00:47:14.820
Doesn't really matter because
it's order of b squared.

00:47:18.430 --> 00:47:19.267
How many edges?

00:47:21.801 --> 00:47:22.676
AUDIENCE: [INAUDIBLE]

00:47:27.070 --> 00:47:28.732
PROFESSOR: Order of v times e.

00:47:28.732 --> 00:47:30.190
We can do the math
that's whatever.

00:47:30.190 --> 00:47:32.060
Let's say it's
something like this.

00:47:32.060 --> 00:47:35.060
So the running time-- this
graph is acyclic, right?

00:47:35.060 --> 00:47:38.830
All the nodes are going forward.

00:47:38.830 --> 00:47:40.940
The new graph that I have here.

00:47:40.940 --> 00:47:41.904
AUDIENCE: Yeah.

00:47:41.904 --> 00:47:43.695
PROFESSOR: So, I can
use the DAG algorithm.

00:47:46.380 --> 00:47:48.540
So the running time, if
I use the DAG algorithm,

00:47:48.540 --> 00:47:52.220
is v prime plus e prime.

00:47:52.220 --> 00:47:53.140
Which is?

00:47:57.426 --> 00:47:58.905
AUDIENCE: v.

00:47:58.905 --> 00:47:59.780
PROFESSOR: Thank you.

00:47:59.780 --> 00:48:01.580
AUDIENCE: Or is it ve?

00:48:01.580 --> 00:48:04.020
PROFESSOR: So, it's v
squared plus ve, which is ve,

00:48:04.020 --> 00:48:07.370
for most purposes.

00:48:07.370 --> 00:48:07.904
And this is?

00:48:07.904 --> 00:48:08.862
AUDIENCE: Bellman-Ford.

00:48:08.862 --> 00:48:10.450
PROFESSOR: Bellman-Ford.

00:48:10.450 --> 00:48:12.700
So this is Bellman-Ford.

00:48:12.700 --> 00:48:14.060
This is what Bellman-Ford does.

00:48:14.060 --> 00:48:15.530
Except when you're
coding it up, it

00:48:15.530 --> 00:48:18.500
relaxes the edges
in a different way.

00:48:18.500 --> 00:48:20.700
But this is the intuition
behind Bellman-Ford.

00:48:20.700 --> 00:48:23.390
And this is an easy way to
see why Bellman-Ford works.

00:48:30.769 --> 00:48:32.269
AUDIENCE: So,
practically, we really

00:48:32.269 --> 00:48:34.265
wouldn't want to do
dynamic programming.

00:48:34.265 --> 00:48:37.164
We just want to run
Bellman-Ford because that's

00:48:37.164 --> 00:48:39.040
less code, right?

00:48:39.040 --> 00:48:41.450
PROFESSOR: So, this is
the dynamic programming

00:48:41.450 --> 00:48:42.370
view of Bellman-Ford.

00:48:45.400 --> 00:48:46.427
Write Bellman-Ford.

00:48:46.427 --> 00:48:48.760
There's a reason why we taught
you to write it that way.

00:48:48.760 --> 00:48:51.247
It's going to be shorter.

00:48:51.247 --> 00:48:52.705
This just gives
you more intuition.

00:48:52.705 --> 00:48:54.750
And it shows you how
the DAG algorithm

00:48:54.750 --> 00:48:56.740
relates to Bellman-Ford.

00:48:56.740 --> 00:48:59.380
And this is how we handle
cycles, which are removed.

00:48:59.380 --> 00:49:02.870
So, that means I have fulfilled
my promise of covering

00:49:02.870 --> 00:49:06.260
two of the issues that
I had on the board.

00:49:06.260 --> 00:49:06.800
Yes.

00:49:06.800 --> 00:49:08.325
So any questions about this?

00:49:11.440 --> 00:49:14.640
So, we didn't do the
pseudocode for the shortest

00:49:14.640 --> 00:49:17.190
path using DAGs.

00:49:17.190 --> 00:49:19.420
The code that we gave
you in the code handout

00:49:19.420 --> 00:49:22.440
matches the pseudocode
that you'd write.

00:49:22.440 --> 00:49:23.750
Yes?

00:49:23.750 --> 00:49:26.960
AUDIENCE: So, if all edges
were negative 1 here,

00:49:26.960 --> 00:49:30.760
except for the top edge,
looking at this graph over here,

00:49:30.760 --> 00:49:35.151
how would the search go through,
such that it would find,

00:49:35.151 --> 00:49:39.400
lik,e negative two weight half?

00:49:39.400 --> 00:49:41.220
PROFESSOR: So these
edges are minus 1?

00:49:41.220 --> 00:49:43.200
AUDIENCE: Yeah.

00:49:43.200 --> 00:49:45.408
PROFESSOR: Well, do you have
a solution in this case?

00:49:50.164 --> 00:49:51.160
AUDIENCE: It's no.

00:49:51.160 --> 00:49:51.743
PROFESSOR: No.

00:49:54.540 --> 00:49:58.490
But you could have this, right?

00:49:58.490 --> 00:50:00.728
And expect the
whole thing to work.

00:50:00.728 --> 00:50:03.912
AUDIENCE: No, that's still
not, that's not making sense.

00:50:03.912 --> 00:50:04.620
PROFESSOR: Is it?

00:50:04.620 --> 00:50:05.950
AUDIENCE: It's negative 1 cycle.

00:50:05.950 --> 00:50:06.210
PROFESSOR: Oh, yeah.

00:50:06.210 --> 00:50:07.001
That's unfortunate.

00:50:07.001 --> 00:50:07.920
OK.

00:50:07.920 --> 00:50:09.780
Never mind.

00:50:09.780 --> 00:50:10.690
Do like this?

00:50:16.630 --> 00:50:17.500
OK.

00:50:17.500 --> 00:50:19.349
AUDIENCE: So, also,
looking at the graph,

00:50:19.349 --> 00:50:21.375
there's only one natural
path that you can take.

00:50:21.375 --> 00:50:22.000
PROFESSOR: Yep.

00:50:22.000 --> 00:50:28.590
So, if I go from s to
c, like this, sabc,

00:50:28.590 --> 00:50:34.850
this is going to
be s0, a1, b2, c3.

00:50:34.850 --> 00:50:37.247
So, all the paths go ahead.

00:50:37.247 --> 00:50:39.371
AUDIENCE: So, what if I
wanted to find the shortest

00:50:39.371 --> 00:50:41.281
path to s to b?

00:50:41.281 --> 00:50:43.280
Like, in terms of actually
writing an algorithm,

00:50:43.280 --> 00:50:46.450
would it be s0, a1, b2, or s1?

00:50:46.450 --> 00:50:46.967
a2, b3.

00:50:46.967 --> 00:50:47.550
PROFESSOR: OK.

00:50:47.550 --> 00:50:49.675
So, if you actually want
to read the shortest path,

00:50:49.675 --> 00:50:53.910
then the shortest path could
have length 1, length 2,

00:50:53.910 --> 00:50:55.000
or length 3, right?

00:50:55.000 --> 00:50:55.820
I don't know.

00:50:55.820 --> 00:50:58.567
So I would have to
look at all these.

00:50:58.567 --> 00:50:59.108
AUDIENCE: Oh.

00:50:59.108 --> 00:51:01.568
OK.

00:51:01.568 --> 00:51:04.790
So you just run it from
s0 to any b, basically.

00:51:04.790 --> 00:51:08.030
PROFESSOR: So, the algorithm
that we have there computes

00:51:08.030 --> 00:51:10.970
the path from one source
to everything else.

00:51:10.970 --> 00:51:11.790
So I run it.

00:51:11.790 --> 00:51:12.730
It runs.

00:51:12.730 --> 00:51:14.432
Computes all the shortest paths.

00:51:14.432 --> 00:51:15.890
And then I have to
read these ones.

00:51:15.890 --> 00:51:18.280
And get the smallest one.

00:51:18.280 --> 00:51:19.030
That's a question.

00:51:19.030 --> 00:51:21.020
Thank you.

00:51:21.020 --> 00:51:22.840
Yeah, that is a detail
that I left out.

00:51:22.840 --> 00:51:23.339
Thank you.

00:51:27.960 --> 00:51:28.770
So, no more cycles.

00:51:35.011 --> 00:51:35.510
OK.

00:51:35.510 --> 00:51:36.343
Any other questions?

00:51:38.701 --> 00:51:39.200
Yes?

00:51:39.200 --> 00:51:41.699
AUDIENCE: I'm still, like, on
the initial problem and stuff.

00:51:41.699 --> 00:51:43.550
A bit of a disconnect.

00:51:43.550 --> 00:51:46.810
When you were underlining
stuff, like the sa,

00:51:46.810 --> 00:51:49.890
it seemed to me that,
like, in that case,

00:51:49.890 --> 00:51:53.290
when you're going
forward, you're never

00:51:53.290 --> 00:51:57.430
going to stop because
you're doing recursion.

00:51:57.430 --> 00:52:01.330
So you never have a
beginning point, almost.

00:52:01.330 --> 00:52:03.152
Effectively, if you, like--

00:52:03.152 --> 00:52:04.490
PROFESSOR: So, do you mean here?

00:52:04.490 --> 00:52:05.364
AUDIENCE: Well, yeah.

00:52:05.364 --> 00:52:08.614
PROFESSOR: So, in that case,
this is the beginning point.

00:52:08.614 --> 00:52:09.280
AUDIENCE: Right.

00:52:09.280 --> 00:52:11.780
PROFESSOR: If I go through the
nodes in the topological sort

00:52:11.780 --> 00:52:15.070
order, then all I need
is one beginning point.

00:52:15.070 --> 00:52:17.345
Because everything else
will refer back to that.

00:52:17.345 --> 00:52:19.570
There has to be a
topological sort order.

00:52:19.570 --> 00:52:21.660
And the first node in
that order is my source.

00:52:26.180 --> 00:52:32.270
And, if we have cycles, then the
beginning conditions are here.

00:52:32.270 --> 00:52:34.191
So that's why I'm only
drawing this vertex.

00:52:34.191 --> 00:52:36.190
Because these other
vertices wouldn't be useful.

00:52:41.850 --> 00:52:42.810
OK.

00:52:42.810 --> 00:52:45.850
So then, that being said, don't
forget your quizzes and happy

00:52:45.850 --> 00:52:47.400
Thanksgiving.

