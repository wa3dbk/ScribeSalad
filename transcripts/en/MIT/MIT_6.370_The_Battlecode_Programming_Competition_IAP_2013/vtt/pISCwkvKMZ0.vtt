WEBVTT
Kind: captions
Language: en

00:00:00.070 --> 00:00:01.670
The following
content is provided

00:00:01.670 --> 00:00:03.800
under a Creative
Commons license.

00:00:03.800 --> 00:00:06.540
Your support will help MIT
OpenCourseWare continue

00:00:06.540 --> 00:00:10.140
to offer high quality
educational resources for free.

00:00:10.140 --> 00:00:12.680
To make a donation or to
view additional materials

00:00:12.680 --> 00:00:16.590
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.590 --> 00:00:17.297
at ocw.mit.edu.

00:00:27.560 --> 00:00:29.970
CORY: I guess I'll
start now since I think

00:00:29.970 --> 00:00:32.220
this might be the crowd since
most people are probably

00:00:32.220 --> 00:00:36.330
sleeping after the sprint
submission deadline.

00:00:36.330 --> 00:00:39.210
Were most people up at 6:00 AM?

00:00:39.210 --> 00:00:39.960
Most?

00:00:39.960 --> 00:00:41.590
Most if not all.

00:00:41.590 --> 00:00:45.030
Alright, so, my name is Cory.

00:00:45.030 --> 00:00:47.460
I'm from the winning
team last year

00:00:47.460 --> 00:00:49.380
and what I really
want to do today

00:00:49.380 --> 00:00:52.560
is kind of give a
complete information dump.

00:00:52.560 --> 00:00:56.020
So this lecture will almost
seem like a stream of conscious,

00:00:56.020 --> 00:00:59.630
but these are the things
that throughout all

00:00:59.630 --> 00:01:01.830
of our years at battle code
are the things we really

00:01:01.830 --> 00:01:04.989
wish we'd got in lecture
but never actually got.

00:01:04.989 --> 00:01:10.070
So my goal is hopefully to give
the most relevant-- hopefully

00:01:10.070 --> 00:01:12.950
like the most applicable
lecture to the nitty

00:01:12.950 --> 00:01:15.210
gritty details of
the day to day.

00:01:15.210 --> 00:01:16.710
Things that you're
doing battle code

00:01:16.710 --> 00:01:18.376
in order to make your
bot better and try

00:01:18.376 --> 00:01:21.190
to improve your performance
against the other teams.

00:01:21.190 --> 00:01:24.330
So whatever competitive edge you
can glean from this hopefully

00:01:24.330 --> 00:01:27.060
propel yourself to
the top of the ladder.

00:01:27.060 --> 00:01:31.840
So just to give a little bit
of background about myself,

00:01:31.840 --> 00:01:34.730
I've been in three
teams since 2010.

00:01:34.730 --> 00:01:37.270
The first two years
where we're kind of meh.

00:01:37.270 --> 00:01:42.410
But in 2012 we were finally
able to win the entire thing

00:01:42.410 --> 00:01:46.230
with my teammates,
Yanping, Haitao and Justin.

00:01:46.230 --> 00:01:49.727
And in each year was quite
different because of the people

00:01:49.727 --> 00:01:50.310
you work with.

00:01:50.310 --> 00:01:55.210
So what I want to do is give a
lot about our 2012 experiences,

00:01:55.210 --> 00:01:58.100
and kind of explain the
various choices we did.

00:01:58.100 --> 00:02:00.210
The tricks and techniques
we did in order

00:02:00.210 --> 00:02:02.900
to give ourselves an
edge over the other team.

00:02:02.900 --> 00:02:05.890
And I also want to give
special thanks to these four

00:02:05.890 --> 00:02:08.699
teams in particular, Gunface,
My Archon Died Bellmanfording

00:02:08.699 --> 00:02:11.270
the Stream, Drunkasaurus
and Toothless.

00:02:11.270 --> 00:02:13.600
Just know that battle code
is not done in a vacuum,

00:02:13.600 --> 00:02:15.670
and you learned from
all the other teams.

00:02:15.670 --> 00:02:17.820
And so these teams were
particularly helpful

00:02:17.820 --> 00:02:21.090
that our team learned from,
that our team collaborated with.

00:02:21.090 --> 00:02:22.940
That we were able
to share code bases

00:02:22.940 --> 00:02:25.670
and learn from each
other, et cetera.

00:02:25.670 --> 00:02:29.380
So just to preface everything,
we're the one's, fun gamers,

00:02:29.380 --> 00:02:31.650
is the one responsible
for the spec this year.

00:02:31.650 --> 00:02:33.720
So if any of you guys
have problems with it,

00:02:33.720 --> 00:02:37.190
you can't really blame Max or
Stephen, you have to blame us.

00:02:37.190 --> 00:02:41.960
So any cries for like nerfing,
OP, whatever, it comes to us.

00:02:41.960 --> 00:02:43.729
We made a lot of huge
changes this year

00:02:43.729 --> 00:02:46.020
just because we wanted to
mix up the game a little bit.

00:02:46.020 --> 00:02:48.760
And also we wanted to make it
a little bit easier for people

00:02:48.760 --> 00:02:52.345
to start off code bases
and get running players.

00:02:52.345 --> 00:02:53.720
I don't know how
many of you guys

00:02:53.720 --> 00:02:58.060
played in 2010 or even
2011, but the amount

00:02:58.060 --> 00:03:00.770
of code required to get even
a simple bot up and running

00:03:00.770 --> 00:03:02.160
was enormous.

00:03:02.160 --> 00:03:04.710
So in 2010, because
you couldn't actually

00:03:04.710 --> 00:03:07.590
attack a unit until you had
equipped a gun on a robot,

00:03:07.590 --> 00:03:10.320
it took almost one to two
days worth of code base

00:03:10.320 --> 00:03:13.130
before you could even get a
robot moving and attacking

00:03:13.130 --> 00:03:14.490
simultaneously.

00:03:14.490 --> 00:03:16.610
So what we did a
lot was simplify

00:03:16.610 --> 00:03:20.610
a huge number of things to
make it a lot more higher

00:03:20.610 --> 00:03:21.860
level strategic control.

00:03:21.860 --> 00:03:25.040
So no walls, attacking
is completely automatic,

00:03:25.040 --> 00:03:26.124
we removed directionality.

00:03:26.124 --> 00:03:28.248
I don't know how many of
you guys played last year,

00:03:28.248 --> 00:03:29.690
but this one's pretty big.

00:03:29.690 --> 00:03:32.210
There's no robot directionality.

00:03:32.210 --> 00:03:34.500
We added in shared vision,
global broadcasting,

00:03:34.500 --> 00:03:36.150
and a known map.

00:03:36.150 --> 00:03:40.300
So do most people
enjoy these changes?

00:03:40.300 --> 00:03:43.074
Or at least people who have
played it in previous years?

00:03:43.074 --> 00:03:44.770
Yeah?

00:03:44.770 --> 00:03:46.800
We're really excited,
at least, about,

00:03:46.800 --> 00:03:50.280
in particular, having
the map completely known

00:03:50.280 --> 00:03:52.820
and the global broadcasting,
because it allows

00:03:52.820 --> 00:03:55.700
an unprecedented level of
robot communication this year.

00:03:55.700 --> 00:03:58.360
So you can now,
instead of having

00:03:58.360 --> 00:04:00.400
a bunch of almost
completely autonomous robots

00:04:00.400 --> 00:04:02.159
with very limited
broadcasting, you

00:04:02.159 --> 00:04:03.325
can have coordinate attacks.

00:04:03.325 --> 00:04:04.400
You know the map.

00:04:04.400 --> 00:04:07.390
You can design your
strategy based on the map.

00:04:07.390 --> 00:04:10.970
Rather than wandering around
for 100 to 1000 rounds,

00:04:10.970 --> 00:04:15.290
not knowing where to go, getting
stuck behind voids, et cetera.

00:04:15.290 --> 00:04:17.250
The no walls is also
very interesting.

00:04:17.250 --> 00:04:20.360
What we found in previous
years is contestants

00:04:20.360 --> 00:04:23.400
will sometimes, if the math
is really stupid or really

00:04:23.400 --> 00:04:25.480
retarded, what'll end
up happening is you just

00:04:25.480 --> 00:04:28.160
watch for 3,000 rounds
both people stuck

00:04:28.160 --> 00:04:30.600
in their base because of this
really interesting concave

00:04:30.600 --> 00:04:32.740
of walls that prevents
the people from getting

00:04:32.740 --> 00:04:35.030
out and actually
engaging each other.

00:04:35.030 --> 00:04:36.890
So with no walls
you can actually

00:04:36.890 --> 00:04:38.670
basically control
the battlefield.

00:04:38.670 --> 00:04:41.160
You can defuse mines, you
can add your own walls,

00:04:41.160 --> 00:04:43.160
you can prevent your
enemies from attacking.

00:04:43.160 --> 00:04:48.497
You can create kind of--
you can bend the battlefield

00:04:48.497 --> 00:04:51.080
to your will, which we thought
was really exciting, especially

00:04:51.080 --> 00:04:53.431
because you're no longer
completely screwed over

00:04:53.431 --> 00:04:54.930
if the map wasn't
what you expected.

00:04:58.040 --> 00:05:01.520
So to begin, I want to
emphasize that battle code is

00:05:01.520 --> 00:05:02.920
a trade off of time.

00:05:02.920 --> 00:05:07.730
So this is what battle code
ultimately comes down to.

00:05:07.730 --> 00:05:10.805
You have three to four
weeks to basically implement

00:05:10.805 --> 00:05:12.240
an entire bot.

00:05:12.240 --> 00:05:13.790
And in these three
to four weeks,

00:05:13.790 --> 00:05:16.140
you have to decide
what is most important.

00:05:16.140 --> 00:05:18.770
If you spend your time on the
wrong thing you will not win.

00:05:18.770 --> 00:05:21.360
You have to spend your
time where it matters.

00:05:21.360 --> 00:05:24.050
And, in particular, I want
to say that results to effort

00:05:24.050 --> 00:05:26.730
vary very highly
between what you

00:05:26.730 --> 00:05:28.395
choose to spend your time on.

00:05:28.395 --> 00:05:30.770
So one of the most important
things to spend your time on

00:05:30.770 --> 00:05:32.420
is attack micro.

00:05:32.420 --> 00:05:35.070
If you can win every engagement
you will win the game.

00:05:35.070 --> 00:05:37.410
It doesn't matter if they're
higher level strategy,

00:05:37.410 --> 00:05:39.360
if you always win the
engagement you will beat

00:05:39.360 --> 00:05:41.110
their army straight
up, no matter what.

00:05:41.110 --> 00:05:41.930
OK?

00:05:41.930 --> 00:05:43.140
Next is swarm code.

00:05:43.140 --> 00:05:45.400
If you're swarm
moves together you'll

00:05:45.400 --> 00:05:46.602
usually win the engagement.

00:05:46.602 --> 00:05:48.560
If you have better swarm
code your attack micro

00:05:48.560 --> 00:05:50.060
can be a little bit off.

00:05:50.060 --> 00:05:52.370
But you'll still end up
engaging with larger numbers

00:05:52.370 --> 00:05:53.470
and winning the fight.

00:05:53.470 --> 00:05:55.190
And winning fights wins games.

00:05:55.190 --> 00:05:57.350
The navigation code that
allows you to actually get

00:05:57.350 --> 00:05:59.040
to the enemy swarm
and defeat them.

00:05:59.040 --> 00:06:00.810
And then there is some
high level strategy

00:06:00.810 --> 00:06:02.890
that you can't make
completely wrong choices.

00:06:02.890 --> 00:06:05.872
But, once again, if you
have good attack micro,

00:06:05.872 --> 00:06:07.830
you can make questionable
high level strategies

00:06:07.830 --> 00:06:09.854
but still win every engagement.

00:06:09.854 --> 00:06:11.770
So the way I'm going to
structure this lecture

00:06:11.770 --> 00:06:15.520
is I'll have various tags.

00:06:15.520 --> 00:06:18.060
There are certain things
that apply to novices.

00:06:18.060 --> 00:06:21.295
There are certain things that
apply to advanced players.

00:06:21.295 --> 00:06:22.670
And then there
are certain things

00:06:22.670 --> 00:06:24.530
that apply to expert players.

00:06:24.530 --> 00:06:26.480
This also comes down
to a trade off of time.

00:06:26.480 --> 00:06:28.840
If you have four
people, maybe you

00:06:28.840 --> 00:06:31.230
want to consider doing some
of the more advanced tricks

00:06:31.230 --> 00:06:32.110
and tactics.

00:06:32.110 --> 00:06:34.185
But if you only have say,
if you're working solo

00:06:34.185 --> 00:06:36.080
or you only have
two people, you want

00:06:36.080 --> 00:06:38.230
to spend your time
where it matters.

00:06:38.230 --> 00:06:41.470
So don't spend time implementing
things that give you

00:06:41.470 --> 00:06:44.460
very tiny marginal advantages
when you could, say, be

00:06:44.460 --> 00:06:46.270
focusing on your attack micro.

00:06:46.270 --> 00:06:48.740
And win all the battles
rather than saving maybe

00:06:48.740 --> 00:06:50.505
like one or two bite
codes per iteration.

00:06:53.890 --> 00:06:59.800
So first off, to do well
in battle code you really

00:06:59.800 --> 00:07:01.010
have to know the spec.

00:07:01.010 --> 00:07:04.720
And I know we've been really
bad at keeping the specs up

00:07:04.720 --> 00:07:05.990
to date, there've been typos.

00:07:05.990 --> 00:07:09.220
But hopefully by now
everything has mostly

00:07:09.220 --> 00:07:12.300
been standardized and
corrected, and all the typos.

00:07:12.300 --> 00:07:15.220
And then you guys didn't really
like our the diffusion/defusion

00:07:15.220 --> 00:07:15.720
joke.

00:07:15.720 --> 00:07:19.169
So we changed the word
defusion to diffusion

00:07:19.169 --> 00:07:20.960
so that you guys didn't
think it was a typo

00:07:20.960 --> 00:07:22.760
and that we were stupid.

00:07:22.760 --> 00:07:26.270
So quick quiz, what's
the base spawn rate?

00:07:26.270 --> 00:07:28.630
Someone call it out.

00:07:28.630 --> 00:07:29.130
Ten.

00:07:29.130 --> 00:07:30.450
Alright, nice.

00:07:30.450 --> 00:07:33.406
What's the cost for
three suppliers?

00:07:33.406 --> 00:07:33.905
Cumulative?

00:07:37.000 --> 00:07:38.690
What was that?

00:07:38.690 --> 00:07:40.350
I think I heard it over there.

00:07:40.350 --> 00:07:40.850
60.

00:07:40.850 --> 00:07:41.350
Right.

00:07:41.350 --> 00:07:44.390
Because it starts off with
10 for the first supplier,

00:07:44.390 --> 00:07:46.770
then the cost is the additive.

00:07:46.770 --> 00:07:49.430
So 20 and then 30 and
to 60, 60 the total cost

00:07:49.430 --> 00:07:50.590
for three suppliers.

00:07:50.590 --> 00:07:52.515
What is the spawn rate
with three suppliers?

00:07:56.546 --> 00:07:57.940
It's 8.

00:07:57.940 --> 00:08:02.920
So total cost of three suppliers
is-- the spawn rate of three

00:08:02.920 --> 00:08:08.050
suppliers is 8 per round
because it is kind of a curve.

00:08:08.050 --> 00:08:09.932
The first supplier
will get you down to 9.

00:08:09.932 --> 00:08:11.890
The second supplier will
get you down to eight.

00:08:11.890 --> 00:08:14.150
And the third supplier is
actually the first supplier

00:08:14.150 --> 00:08:16.140
that doesn't bring
you down another point

00:08:16.140 --> 00:08:18.870
because it's rounded
to the nearest integer.

00:08:18.870 --> 00:08:19.740
Even.

00:08:19.740 --> 00:08:21.762
So in terms of unit
spawn, at out what round

00:08:21.762 --> 00:08:23.220
does the first
supplier break even?

00:08:28.430 --> 00:08:30.269
So these are all
like critical numbers

00:08:30.269 --> 00:08:31.810
that if you know
you can kind of gain

00:08:31.810 --> 00:08:32.935
the spec to your advantage.

00:08:36.450 --> 00:08:37.909
Close.

00:08:37.909 --> 00:08:41.289
The first supplier breaks
even at what round?

00:08:41.289 --> 00:08:45.570
If I get one supplier,
I have one turn

00:08:45.570 --> 00:08:48.340
spawn reduction, which
means I break even,

00:08:48.340 --> 00:08:50.760
in terms of units,
at what round?

00:08:50.760 --> 00:08:53.330
I sacrifice one unit
to get the supplier,

00:08:53.330 --> 00:08:54.890
so I'll break even
when I get back

00:08:54.890 --> 00:08:56.880
that extra unit,
which is at 90 rounds.

00:09:00.030 --> 00:09:03.530
So the first supplier
breaks even at 90 rounds.

00:09:03.530 --> 00:09:05.796
So these are key numbers.

00:09:05.796 --> 00:09:07.170
They maybe tweaked
in the future,

00:09:07.170 --> 00:09:10.060
but if you always have a
sense of all these numbers,

00:09:10.060 --> 00:09:12.370
you can kind of make
good high level decisions

00:09:12.370 --> 00:09:13.930
about what you
should be building

00:09:13.930 --> 00:09:16.040
and what you
shouldn't be building

00:09:16.040 --> 00:09:18.500
at the beginning of the game.

00:09:18.500 --> 00:09:20.900
So the beginning of
the game is very key.

00:09:20.900 --> 00:09:23.831
What we did was you have
an excess of energy.

00:09:23.831 --> 00:09:26.080
So you have a choice, like
in Max's lecture yesterday,

00:09:26.080 --> 00:09:28.160
whether to build
generators or suppliers.

00:09:28.160 --> 00:09:30.910
And if you know roughly at what
time these things break even,

00:09:30.910 --> 00:09:34.260
or at what time you gain
that the marginal advantage,

00:09:34.260 --> 00:09:37.620
you can decide when to
attack or when not to attack.

00:09:37.620 --> 00:09:42.050
So know the specs,
that's very key.

00:09:42.050 --> 00:09:45.570
Second, I want to say
testing is probably

00:09:45.570 --> 00:09:48.430
the most important thing,
second from spending

00:09:48.430 --> 00:09:50.492
your time in the correct place.

00:09:50.492 --> 00:09:52.200
Because you don't
actually know if you're

00:09:52.200 --> 00:09:53.825
spending your time
in the correct place

00:09:53.825 --> 00:09:56.270
unless you're actually
testing the code.

00:09:56.270 --> 00:10:00.960
So as a high level, you want to
write multiple distinct bots.

00:10:00.960 --> 00:10:04.660
So I know a lot of teams maybe
just have a single bot lineage.

00:10:04.660 --> 00:10:09.340
But our team we wrote like 10
to 12 different bots, each one

00:10:09.340 --> 00:10:11.070
with different strategies.

00:10:11.070 --> 00:10:13.430
And sometimes we wrote bots
completely from scratch

00:10:13.430 --> 00:10:15.570
when we thought we had
a really cool strategy.

00:10:15.570 --> 00:10:18.800
So last year there
were flying units.

00:10:18.800 --> 00:10:21.210
So we thought, well it
would be kind of cool maybe

00:10:21.210 --> 00:10:24.140
if we could have
units that only--

00:10:24.140 --> 00:10:26.890
or if we had a base that
only spawned flying units.

00:10:26.890 --> 00:10:29.340
And we did a little bit of
theory crafting our head

00:10:29.340 --> 00:10:31.710
and it turned out the DPS
was marginally higher.

00:10:31.710 --> 00:10:34.120
But the problem is once
we tried to implement it,

00:10:34.120 --> 00:10:37.500
we found out the actual
problems with the flyer strategy

00:10:37.500 --> 00:10:41.450
was that we couldn't sustain
the units because of the way

00:10:41.450 --> 00:10:43.480
that energy transfer
was done last year.

00:10:43.480 --> 00:10:46.280
And we weren't actually able
to coordinate the attack well

00:10:46.280 --> 00:10:48.870
enough to gain that
theoretical DPS.

00:10:48.870 --> 00:10:51.280
So testing is
extremely important.

00:10:51.280 --> 00:10:53.550
Wins, of course,
beat theory crafting.

00:10:53.550 --> 00:10:56.960
So even knowing the specs and
knowing the break off times,

00:10:56.960 --> 00:10:59.140
you have to be able to
implement them in practice,

00:10:59.140 --> 00:11:00.980
otherwise the theory
doesn't pay off.

00:11:00.980 --> 00:11:03.140
The scrimmage server is
your ally in testing.

00:11:03.140 --> 00:11:05.910
And then you always want to
prioritize writing behaviors

00:11:05.910 --> 00:11:08.219
over spending a lot of
time doing framework code.

00:11:08.219 --> 00:11:09.760
Because the behaviors
are what you're

00:11:09.760 --> 00:11:13.340
actually testing,
not the framework.

00:11:13.340 --> 00:11:17.340
One thing that novices make
the mistake of is they're

00:11:17.340 --> 00:11:19.100
always afraid of ranked games.

00:11:19.100 --> 00:11:22.680
So has everyone in here played
at least one ranked game?

00:11:22.680 --> 00:11:23.430
Yes?

00:11:23.430 --> 00:11:27.290
So what I want to
say is it's really

00:11:27.290 --> 00:11:29.730
a problem more with novices
than with the people who

00:11:29.730 --> 00:11:31.630
have been doing battle
code for a long time.

00:11:31.630 --> 00:11:34.410
And the reason this is,
is because sometimes you

00:11:34.410 --> 00:11:37.430
submit a bot and you're afraid
that it's maybe not so good.

00:11:37.430 --> 00:11:39.010
Or there's some
problems with it.

00:11:39.010 --> 00:11:40.957
Or that your code
is going to do badly

00:11:40.957 --> 00:11:42.290
and you're going to lose points.

00:11:42.290 --> 00:11:45.030
But what it gains you
is by scrimmaging often

00:11:45.030 --> 00:11:47.910
you will always know what
the top teams are up to.

00:11:47.910 --> 00:11:49.480
And the thing is,
if you do unranked,

00:11:49.480 --> 00:11:52.260
top teams actually have no
incentive to accept your match,

00:11:52.260 --> 00:11:54.540
and you'll never know what
they're actually doing.

00:11:54.540 --> 00:11:59.010
So the trade off is a top
team, if they beat you

00:11:59.010 --> 00:12:00.560
in a ranked game,
they'll actually

00:12:00.560 --> 00:12:01.630
gain [? ELOW ?] points.

00:12:01.630 --> 00:12:03.490
But you actually gain
something from that.

00:12:03.490 --> 00:12:07.240
You gain the understanding of
how the top team is micro-ing.

00:12:07.240 --> 00:12:09.840
The kind of high level
strategy the top team is doing.

00:12:09.840 --> 00:12:12.890
And also any tips or
tricks or small things

00:12:12.890 --> 00:12:15.520
that you can glean
from those games

00:12:15.520 --> 00:12:18.370
to perform better in
your next bot iteration.

00:12:18.370 --> 00:12:22.180
Actually if you send an unranked
game to one of the top teams,

00:12:22.180 --> 00:12:24.230
it's actually a lose-lose
situation for them.

00:12:24.230 --> 00:12:26.140
Because A they have
the probability

00:12:26.140 --> 00:12:28.170
of losing a lot
of points to you.

00:12:28.170 --> 00:12:31.030
And B they're also giving away
their high level strategy.

00:12:31.030 --> 00:12:35.532
So for the top five teams,
at least in years past,

00:12:35.532 --> 00:12:36.990
if you sent them
an unranked match,

00:12:36.990 --> 00:12:39.170
they'd cancel it and send
you back a ranked match.

00:12:39.170 --> 00:12:41.040
Because there's almost
no advantage for them

00:12:41.040 --> 00:12:42.810
to accept these
unranked matches.

00:12:42.810 --> 00:12:44.960
So don't be afraid of
sending ranked games,

00:12:44.960 --> 00:12:46.850
especially against top
teams, because that's

00:12:46.850 --> 00:12:49.560
where you're going to
learn the most about how

00:12:49.560 --> 00:12:50.640
you can improve your bot.

00:12:54.440 --> 00:12:57.100
Another thing that sometimes
beginners get wrong

00:12:57.100 --> 00:13:00.520
is that your code base is
actually more than your bot.

00:13:00.520 --> 00:13:03.300
There is a huge
infrastructure that we

00:13:03.300 --> 00:13:05.430
built, at least around
our bot last year,

00:13:05.430 --> 00:13:10.420
that was not just the simple--
that was not just robot player

00:13:10.420 --> 00:13:12.296
and everything
surrounding robot player.

00:13:12.296 --> 00:13:13.920
So one of the easiest
things you can do

00:13:13.920 --> 00:13:15.500
is you can make custom maps.

00:13:15.500 --> 00:13:18.310
Every year when we start
battle code, we always

00:13:18.310 --> 00:13:20.790
make this map on the
right, we call it plains,

00:13:20.790 --> 00:13:23.270
because there's
absolutely nothing on it.

00:13:23.270 --> 00:13:27.310
The plains for this year,
we have a few encampments

00:13:27.310 --> 00:13:30.560
in the middle just to test like
basic encampment capture code.

00:13:30.560 --> 00:13:33.010
But what plains
really allows you

00:13:33.010 --> 00:13:35.770
to do is it allows you to
perfect your attack micro

00:13:35.770 --> 00:13:38.920
and make it so that you're not
worrying about like advance

00:13:38.920 --> 00:13:41.880
path finding, you're just making
sure you can win engagements.

00:13:41.880 --> 00:13:44.160
Because, as I said, attack
micro is so important.

00:13:44.160 --> 00:13:46.740
Winning engagements wins games.

00:13:46.740 --> 00:13:50.079
So spend time, actually,
making custom maps.

00:13:50.079 --> 00:13:52.370
I know we don't really have
a map editor out this year.

00:13:52.370 --> 00:13:55.370
So if you make a
map editor, too,

00:13:55.370 --> 00:13:57.210
make a bunch of custom maps.

00:13:57.210 --> 00:13:59.270
Test your path finding,
test your attack micro.

00:13:59.270 --> 00:14:01.400
There's so many
small things you can

00:14:01.400 --> 00:14:06.120
do to test your bot very fast.

00:14:06.120 --> 00:14:08.560
A few small things that you
guys may have also not known

00:14:08.560 --> 00:14:11.320
is with custom maps
you can actually

00:14:11.320 --> 00:14:14.500
declare units to be
pre-spawned on the map.

00:14:14.500 --> 00:14:17.790
So in the top right you're
allowed to declare symbols.

00:14:17.790 --> 00:14:19.850
You can actually set
up unit formations

00:14:19.850 --> 00:14:22.080
to quickly test
different scenarios.

00:14:22.080 --> 00:14:24.810
And just by hitting play
and repeatedly running it,

00:14:24.810 --> 00:14:26.686
you can tweak
whatever heuristics

00:14:26.686 --> 00:14:29.310
you're running in order to make
sure that your code is actually

00:14:29.310 --> 00:14:30.420
running correctly.

00:14:30.420 --> 00:14:31.890
And then making
custom maps is also

00:14:31.890 --> 00:14:34.040
extremely good for
testing path finding.

00:14:34.040 --> 00:14:37.220
So you can spawn a map with
a unit already in the center,

00:14:37.220 --> 00:14:41.940
and then just hard code
in an endpoint to Nav2.

00:14:41.940 --> 00:14:43.627
And then see if
your navigation is

00:14:43.627 --> 00:14:45.210
running any better
than it was before.

00:14:47.780 --> 00:14:49.930
This is kind of a
little expert thing

00:14:49.930 --> 00:14:54.110
but we spent a lot
last year trying

00:14:54.110 --> 00:14:57.020
to gain the scrimmage
server a little bit.

00:14:57.020 --> 00:15:00.940
So Justin wrote kind
of a scraper that

00:15:00.940 --> 00:15:04.470
scrapes the rankings
every five minutes

00:15:04.470 --> 00:15:08.060
and determines who's
winning to who.

00:15:08.060 --> 00:15:09.510
If you guys are
just starting out

00:15:09.510 --> 00:15:10.843
don't worry about this too much.

00:15:10.843 --> 00:15:12.830
But what this allowed
us to do, actually,

00:15:12.830 --> 00:15:16.860
was it allowed us to know
which teams were actually

00:15:16.860 --> 00:15:20.100
rising quickly, which teams had
maybe changed their strategy.

00:15:20.100 --> 00:15:24.780
And it allowed us to kind of
target our ranked matches.

00:15:24.780 --> 00:15:26.470
Because we would
see oh this team

00:15:26.470 --> 00:15:28.600
won three games in
rapid succession,

00:15:28.600 --> 00:15:30.230
we want to see
what they're doing.

00:15:30.230 --> 00:15:33.170
Or oh this team maybe
dropped four games

00:15:33.170 --> 00:15:35.260
and we probably
don't really need

00:15:35.260 --> 00:15:37.490
to send them a ranked match
because they're probably

00:15:37.490 --> 00:15:39.230
not doing anything
different than what

00:15:39.230 --> 00:15:41.230
they used to be doing.

00:15:41.230 --> 00:15:43.620
But, once again,
this is a custom tool

00:15:43.620 --> 00:15:46.270
that was written outside
of the framework of just

00:15:46.270 --> 00:15:48.390
our eclipse project with
our battle code bot that

00:15:48.390 --> 00:15:51.400
allowed us to gain a small
competitive edge over everyone

00:15:51.400 --> 00:15:53.330
else.

00:15:53.330 --> 00:15:55.770
The current ladder stats
ranking system is actually--

00:15:55.770 --> 00:15:57.550
I think Justin posted
about in the forums,

00:15:57.550 --> 00:15:58.860
he's actually running
it publicly for you

00:15:58.860 --> 00:15:59.850
guys this year.

00:15:59.850 --> 00:16:04.460
So if you want to take a
peek and just use his code--

00:16:04.460 --> 00:16:08.330
Our old one actually recorded
[? ELOW ?] gains and losses.

00:16:08.330 --> 00:16:11.830
So we could see whether
a team gained 1 point

00:16:11.830 --> 00:16:13.090
or whether they gained 10.

00:16:13.090 --> 00:16:15.200
So if a team gained 30
points in a single match,

00:16:15.200 --> 00:16:16.440
that's like a warning
bell, alright?

00:16:16.440 --> 00:16:19.023
Because it means they're doing
something drastically different

00:16:19.023 --> 00:16:21.790
and you want to know
what they're up to.

00:16:21.790 --> 00:16:26.040
This tool was another tool
we borrowed from Gunface

00:16:26.040 --> 00:16:27.820
from 2011.

00:16:27.820 --> 00:16:30.060
It's basically a
mass scrim tester.

00:16:30.060 --> 00:16:33.630
So the scrimmage server
actually is not the only place

00:16:33.630 --> 00:16:34.630
that you can mass scrim.

00:16:34.630 --> 00:16:36.670
You can also build
your own custom mass

00:16:36.670 --> 00:16:39.110
scrimming framework, which
is what Gunface did in 2011

00:16:39.110 --> 00:16:41.479
and what we co-opted
from them in 2012.

00:16:41.479 --> 00:16:43.020
So what this actually
allows us to do

00:16:43.020 --> 00:16:46.410
is it allows us to test
in house our own bots

00:16:46.410 --> 00:16:47.670
against each other.

00:16:47.670 --> 00:16:51.571
So you know how I said we wrote
like 10 to 12 distinct bots?

00:16:51.571 --> 00:16:53.320
Well what we would do
is we could actually

00:16:53.320 --> 00:16:54.820
characterize which
one was strictly

00:16:54.820 --> 00:16:57.800
superior to all the other
bots by pitting them

00:16:57.800 --> 00:16:59.850
against each other in
thousands of matches.

00:16:59.850 --> 00:17:02.310
So if you'll see
here, what this did

00:17:02.310 --> 00:17:05.250
was we had a total win counter.

00:17:05.250 --> 00:17:08.390
So we could submit jobs
to our queue server.

00:17:08.390 --> 00:17:11.609
The queue would run like 50-60
matches on every single known

00:17:11.609 --> 00:17:13.839
map in the scrimmage ranking.

00:17:13.839 --> 00:17:16.430
And then, of course, it
takes some time to compute.

00:17:16.430 --> 00:17:19.369
We actually borrowed a
bunch of xVM machines

00:17:19.369 --> 00:17:21.740
to continuously run
this in the background.

00:17:21.740 --> 00:17:26.119
But you'll see here every single
one of our tagged releases,

00:17:26.119 --> 00:17:28.319
we're actually pitting
it against each other.

00:17:28.319 --> 00:17:30.750
Last year we would
consider a bot good

00:17:30.750 --> 00:17:36.700
if we could beat our older
iterations 90% of the time.

00:17:36.700 --> 00:17:39.240
And until we could get
kind of that 90% mark

00:17:39.240 --> 00:17:41.150
we would consider them
about to be equal.

00:17:41.150 --> 00:17:43.675
Because some small change, in
maybe like the random number

00:17:43.675 --> 00:17:45.050
generator, whatever,
would affect

00:17:45.050 --> 00:17:46.600
the outcome of the match.

00:17:46.600 --> 00:17:48.740
But, again, the most
drastic improvements--

00:17:48.740 --> 00:17:53.300
when you see 31-0,
those are from usually

00:17:53.300 --> 00:17:55.741
from micro improvements
where one bot will just--

00:17:55.741 --> 00:17:58.240
the two armies will collide and
one bot will just obliterate

00:17:58.240 --> 00:18:01.050
the other one, even
with equal numbers.

00:18:01.050 --> 00:18:03.850
But these sort of things,
running the mass scrim,

00:18:03.850 --> 00:18:07.210
you can really,
really get a sense of.

00:18:07.210 --> 00:18:09.330
This is an expert
level kind of thing.

00:18:09.330 --> 00:18:11.080
If you don't have--
if you have one person

00:18:11.080 --> 00:18:12.950
you're not going
to blow your time

00:18:12.950 --> 00:18:15.430
writing a scrimmage
based system.

00:18:15.430 --> 00:18:17.650
But if you have maybe
three or four people

00:18:17.650 --> 00:18:19.840
you could take a
day or so to maybe

00:18:19.840 --> 00:18:22.360
try to repurpose the old
2012 mass scrim tester, which

00:18:22.360 --> 00:18:29.880
is on GitHub, by the way, to get
it working with the 2013 game.

00:18:29.880 --> 00:18:35.770
One thing that hasn't really
been covered ever, I think,

00:18:35.770 --> 00:18:39.560
is kind of the byte
code system in detail,

00:18:39.560 --> 00:18:41.040
I think in battle code.

00:18:41.040 --> 00:18:43.580
And this is a very key
part of battle code

00:18:43.580 --> 00:18:45.870
and yet it's always
kind of glossed over.

00:18:45.870 --> 00:18:49.490
You'll hear the lecturer say
you should use less byte codes.

00:18:49.490 --> 00:18:52.590
Or the less byte codes you use
the more units you can have.

00:18:52.590 --> 00:18:55.170
But what does that
actually mean and how

00:18:55.170 --> 00:18:59.390
does that actually translate
into implementation?

00:18:59.390 --> 00:19:04.630
So I'll skip ahead and just
give a brief overview of the JVM

00:19:04.630 --> 00:19:06.810
for people who are
unfamiliar with it.

00:19:06.810 --> 00:19:09.770
So the Java Virtual Machine
is a stack based system.

00:19:09.770 --> 00:19:12.432
So what it basically means is
if you're familiar with x86

00:19:12.432 --> 00:19:13.890
or whatever, there
are no registers

00:19:13.890 --> 00:19:15.680
is just a giant stack.

00:19:15.680 --> 00:19:20.530
And you can imagine it as
values get pushed on the stack

00:19:20.530 --> 00:19:25.160
and popped off of the stack, and
that's how computation is done.

00:19:25.160 --> 00:19:27.360
Byte codes are-- when
you write your Java

00:19:27.360 --> 00:19:29.470
it gets compiled into
something called byte codes.

00:19:29.470 --> 00:19:31.490
And byte codes are very
similar to assembly,

00:19:31.490 --> 00:19:34.190
except they work on this
stacked based system.

00:19:34.190 --> 00:19:35.580
And the way this
stack is, is you

00:19:35.580 --> 00:19:39.210
have this operand stack which
is your current stack of values.

00:19:39.210 --> 00:19:44.000
So if you imagine like
a prefix operations

00:19:44.000 --> 00:19:45.820
I can push-- or
postfix operations,

00:19:45.820 --> 00:19:48.360
I can push to values on
the stack, I can call add

00:19:48.360 --> 00:19:50.140
and it would pop off
the result, right?

00:19:50.140 --> 00:19:54.010
So if you imagine the JVM is
kind of working like that,

00:19:54.010 --> 00:19:55.740
it's very similar.

00:19:55.740 --> 00:19:59.880
But there's also an array
of local variables up top

00:19:59.880 --> 00:20:03.260
and these are
indexed by a number.

00:20:03.260 --> 00:20:07.930
So, actually, stack operands
can operate directly

00:20:07.930 --> 00:20:12.500
onto the array of variables
that are globally accessible.

00:20:12.500 --> 00:20:14.850
And then there's also
a global constants pool

00:20:14.850 --> 00:20:19.320
that byte codes can operate on.

00:20:19.320 --> 00:20:21.490
So this is just
an example online.

00:20:21.490 --> 00:20:24.200
And if you want to read more
there's a URL down here.

00:20:24.200 --> 00:20:26.510
But what happens is
you compile your Java,

00:20:26.510 --> 00:20:30.060
it gets turned into byte codes,
and each byte code is actually

00:20:30.060 --> 00:20:32.840
stepped through by our
instrumentation engine.

00:20:32.840 --> 00:20:34.990
And that's what you're
getting counted on.

00:20:34.990 --> 00:20:37.140
So when someone says
you're using 10 byte codes,

00:20:37.140 --> 00:20:38.890
it actually means that
the high level Java

00:20:38.890 --> 00:20:41.890
call you made is
being turned into 10

00:20:41.890 --> 00:20:46.650
individual atomic
steps on the JVM.

00:20:46.650 --> 00:20:50.420
And you're getting penalized for
each one of these atomic steps.

00:20:50.420 --> 00:20:53.530
This leads to a lot
of interesting things.

00:20:53.530 --> 00:20:57.210
So there's a very classic
kind of loop structure

00:20:57.210 --> 00:20:58.480
in battle code.

00:20:58.480 --> 00:21:00.150
I hear this is so
classic, actually,

00:21:00.150 --> 00:21:04.010
that Dropbox's code base is
littered with this structure.

00:21:04.010 --> 00:21:06.275
So it looks like kind
of a normal for loop,

00:21:06.275 --> 00:21:08.650
but if you look closely, you'll
notice that we don't even

00:21:08.650 --> 00:21:10.220
have a third parameter.

00:21:10.220 --> 00:21:13.110
What this says is that for
i is equal to the length

00:21:13.110 --> 00:21:16.920
of the ray, decrement until
you're greater than zero.

00:21:16.920 --> 00:21:20.090
And it's reversed from maybe
the way normal computer

00:21:20.090 --> 00:21:21.950
science would teach it to you.

00:21:21.950 --> 00:21:24.630
But there's a particular
reason we do it this way.

00:21:24.630 --> 00:21:27.070
And that's because we're
actually byte code hacking.

00:21:27.070 --> 00:21:35.230
So what happens is Java is
similar-- kind of like there's

00:21:35.230 --> 00:21:39.210
legacy in computers
testing again zero

00:21:39.210 --> 00:21:42.510
is actually an operation
that comes up very often.

00:21:42.510 --> 00:21:47.177
In most branch conditions
you're testing against zero.

00:21:47.177 --> 00:21:49.260
Like Booleans are testing
against zero, et cetera.

00:21:49.260 --> 00:21:50.884
So there's actually
a special byte code

00:21:50.884 --> 00:21:51.940
for testing against zero.

00:21:51.940 --> 00:21:55.230
And then, also, when
you're doing the comparison

00:21:55.230 --> 00:21:56.960
you don't want to
be recomputing,

00:21:56.960 --> 00:21:59.520
say, msgs.length
every single time.

00:21:59.520 --> 00:22:01.850
So this actually
has a net effect

00:22:01.850 --> 00:22:04.011
of saving byte codes
because you can actually

00:22:04.011 --> 00:22:05.510
write the byte codes
out but you can

00:22:05.510 --> 00:22:08.270
predict what the
compiler will spit out.

00:22:08.270 --> 00:22:11.050
And because battle
code is not run as just

00:22:11.050 --> 00:22:12.980
in time compilation,
actually, the byte code

00:22:12.980 --> 00:22:16.330
steps through exactly
as its outputted.

00:22:16.330 --> 00:22:20.370
This ends up with a net
savings of a few byte codes.

00:22:20.370 --> 00:22:22.900
So if you'll see down here,
this is like the classic way

00:22:22.900 --> 00:22:24.441
you would write a
loop that you might

00:22:24.441 --> 00:22:26.090
learn in intro to
computer science.

00:22:26.090 --> 00:22:27.990
For i is equal to
zero, i is less

00:22:27.990 --> 00:22:31.660
than your terminating
condition, increment i.

00:22:31.660 --> 00:22:33.860
What happens here
is because you want

00:22:33.860 --> 00:22:37.390
to compare i every
round to msgs.length.

00:22:37.390 --> 00:22:40.240
Computing msgs.length
is actually

00:22:40.240 --> 00:22:43.950
a separate compare operation
with loading the actual object,

00:22:43.950 --> 00:22:45.840
loading the actual array object.

00:22:45.840 --> 00:22:49.310
Whereas in our initial
version what we've done here

00:22:49.310 --> 00:22:54.970
is we've set the index variable
actually to the final value.

00:22:54.970 --> 00:22:56.510
And we're comparing
against zero,

00:22:56.510 --> 00:22:58.580
which is a single
byte code operation.

00:22:58.580 --> 00:23:01.030
So what happens is that
this is a net savings

00:23:01.030 --> 00:23:03.790
of two byte codes.

00:23:03.790 --> 00:23:06.560
Two byte codes actually
might not seem like a lot,

00:23:06.560 --> 00:23:09.100
but if you're, say,
looping through 100 objects

00:23:09.100 --> 00:23:11.910
that that's 200 byte codes
saved in the entire loop.

00:23:11.910 --> 00:23:13.800
And that's two whole
sense functions.

00:23:13.800 --> 00:23:16.530
So you could send-- that's two
whole global sense functions,

00:23:16.530 --> 00:23:18.780
with the radius
and the location.

00:23:18.780 --> 00:23:20.440
That's actually pretty big.

00:23:20.440 --> 00:23:24.400
So saving 200 byte
codes can mean

00:23:24.400 --> 00:23:27.150
that you might have additional
data on the battlefield.

00:23:27.150 --> 00:23:29.550
Or you can loop through one
additional object when you're

00:23:29.550 --> 00:23:32.490
trying to compute a
heuristic for map locations

00:23:32.490 --> 00:23:33.960
or for army positions.

00:23:33.960 --> 00:23:37.230
And this actually gives you a
small marginal competitive edge

00:23:37.230 --> 00:23:38.300
over the other team.

00:23:38.300 --> 00:23:40.090
Especially this year
when byte codes also

00:23:40.090 --> 00:23:41.690
translates to energy.

00:23:41.690 --> 00:23:45.380
So saving byte codes gives
you back more energy.

00:23:45.380 --> 00:23:47.420
More energy translates
to more units.

00:23:47.420 --> 00:23:50.910
If all your units are saving
500 byte codes per turn

00:23:50.910 --> 00:23:54.480
that adds up over time,
especially with the decay rate.

00:23:57.170 --> 00:24:01.200
So with byte codes
you'll also end up

00:24:01.200 --> 00:24:03.980
wanting to implement
your own data structures.

00:24:03.980 --> 00:24:10.150
So I don't know if you guys
have tried using the native Java

00:24:10.150 --> 00:24:14.130
data structures like hashset,
array q set, et cetera.

00:24:14.130 --> 00:24:17.250
But we actually penalize
you for the internal calls

00:24:17.250 --> 00:24:20.110
that Java makes in
those data sets.

00:24:20.110 --> 00:24:23.250
So if Java-- Java
likes to be very safe.

00:24:23.250 --> 00:24:24.960
So a lot of the
thread safe code we'll

00:24:24.960 --> 00:24:26.770
check to make sure
another thread is not

00:24:26.770 --> 00:24:29.710
trying to mutate the
data, or that there's

00:24:29.710 --> 00:24:31.934
on a lock on the
data, et cetera.

00:24:31.934 --> 00:24:33.600
So the thread safe
code actually ends up

00:24:33.600 --> 00:24:34.850
hurting you a lot,
because there's

00:24:34.850 --> 00:24:36.690
a lot of excess byte
codes that gets called.

00:24:36.690 --> 00:24:40.190
So, for instance, a single
hashset.iterator.getnext

00:24:40.190 --> 00:24:42.500
getting a value from
a hashset, worst case

00:24:42.500 --> 00:24:46.300
is 2k byte codes for a
single call, which is absurd.

00:24:46.300 --> 00:24:48.980
Because you can implement a
hashset yourself with an array

00:24:48.980 --> 00:24:52.947
and maybe like 200-300 byte
codes if you custom write it.

00:24:52.947 --> 00:24:54.780
So what ends up happening
is a lot of people

00:24:54.780 --> 00:24:56.404
will make what's
called fast data sets.

00:24:56.404 --> 00:25:00.690
So we wrote a fast
hashset, a fast arraylist.

00:25:00.690 --> 00:25:03.360
And these are all
custom based on arrays

00:25:03.360 --> 00:25:05.920
that we could index
directly into and pay

00:25:05.920 --> 00:25:08.060
a very minimal byte
code cost in order

00:25:08.060 --> 00:25:12.060
to get very complex
data structures back.

00:25:12.060 --> 00:25:15.620
Same thing goes for algorithms.

00:25:15.620 --> 00:25:19.877
You may think that--
a lot of beginners

00:25:19.877 --> 00:25:21.710
will start off trying
to implement something

00:25:21.710 --> 00:25:26.310
like [? astar ?] or a flood
fill algorithm just to do

00:25:26.310 --> 00:25:26.860
navigation.

00:25:26.860 --> 00:25:27.360
Yes?

00:25:30.236 --> 00:25:33.640
Right, this is an example from--

00:25:33.640 --> 00:25:35.840
I'll explain what
exactly this one is.

00:25:35.840 --> 00:25:40.134
But just an overview,
most n squared

00:25:40.134 --> 00:25:42.300
algorithms are completely
untenable in the byte code

00:25:42.300 --> 00:25:43.060
system.

00:25:43.060 --> 00:25:44.670
So if you see an n
squared algorithm

00:25:44.670 --> 00:25:47.110
it's not going to work unless
you do something to it.

00:25:47.110 --> 00:25:48.830
So there are multiple ways.

00:25:48.830 --> 00:25:51.150
You can distribute it
among multiple robots,

00:25:51.150 --> 00:25:53.100
which is actually very hard.

00:25:53.100 --> 00:25:56.910
You can break up the
computation into multiple steps

00:25:56.910 --> 00:25:59.410
and run a piece each
turn, which is hard

00:25:59.410 --> 00:26:01.050
depending on the algorithm.

00:26:01.050 --> 00:26:06.752
And then you can also just run a
completely different algorithm.

00:26:06.752 --> 00:26:08.210
So the one I actually
have up here,

00:26:08.210 --> 00:26:11.470
this is a cute little example
from our old code base.

00:26:11.470 --> 00:26:13.190
It's not the actual
implementation

00:26:13.190 --> 00:26:14.830
but it's the algorithm itself.

00:26:14.830 --> 00:26:17.150
This is called a
multiply with carry.

00:26:17.150 --> 00:26:20.870
It's actually a pseudo
random number generator.

00:26:20.870 --> 00:26:24.392
There's a period-- there's
like a period of 2 to the 60th.

00:26:24.392 --> 00:26:25.850
But for all intents
and purposes it

00:26:25.850 --> 00:26:27.650
is a random number generator.

00:26:27.650 --> 00:26:29.920
We actually implemented
this because we

00:26:29.920 --> 00:26:33.890
noticed that math.random on
seeding pays 144 byte codes.

00:26:33.890 --> 00:26:37.870
And then each subsequent
getnextinteger call is 80.

00:26:37.870 --> 00:26:40.370
And we actually wrote our own
custom random number generator

00:26:40.370 --> 00:26:44.820
to save 40 byte codes
per call to get nextint.

00:26:44.820 --> 00:26:47.980
And so this is the algorithm
actually pulled from Wikipedia,

00:26:47.980 --> 00:26:49.450
we changed a little bit.

00:26:49.450 --> 00:26:52.019
But, in essence, it's a
bunch of bit operators

00:26:52.019 --> 00:26:53.560
that gives you a
pseudo random number

00:26:53.560 --> 00:26:55.540
generator to save on byte codes.

00:26:55.540 --> 00:26:58.250
And if you have
an algorithm that

00:26:58.250 --> 00:27:00.580
relies on a lot
of random numbers

00:27:00.580 --> 00:27:03.440
the 40 per getnextinteger
actually adds up.

00:27:06.560 --> 00:27:08.870
There's actually a tool,
a really nice tool,

00:27:08.870 --> 00:27:12.505
that we used a lot last year
call doctor garbage visualizer.

00:27:12.505 --> 00:27:14.880
I don't know why it's called
doctor garbage, because it's

00:27:14.880 --> 00:27:16.360
one of the best tools ever.

00:27:16.360 --> 00:27:21.460
But what it does is it
actually decompiles your class

00:27:21.460 --> 00:27:23.260
into the actual byte codes.

00:27:23.260 --> 00:27:25.682
And then it shows the control
flow graph on the right.

00:27:25.682 --> 00:27:28.140
So the control flow graph will
actually allow you to reason

00:27:28.140 --> 00:27:30.100
about where your short
circuits are happening,

00:27:30.100 --> 00:27:31.850
because if you short
circuit a code block,

00:27:31.850 --> 00:27:33.230
you're not actually paying
the byte code for what

00:27:33.230 --> 00:27:34.385
you don't execute, right?

00:27:34.385 --> 00:27:35.760
So you'll want to
terminate loops

00:27:35.760 --> 00:27:38.330
end-- you'll want to
terminate loops early.

00:27:38.330 --> 00:27:42.910
You'll want to try
to avoid code that

00:27:42.910 --> 00:27:45.140
doesn't have to be
computed multiple times

00:27:45.140 --> 00:27:48.060
in order to reduce your
total byte code count.

00:27:48.060 --> 00:27:50.636
So by having the control
flow graph on the right,

00:27:50.636 --> 00:27:52.010
it's actually very
easy to reason

00:27:52.010 --> 00:27:55.010
about how to save byte
codes, especially when

00:27:55.010 --> 00:27:57.780
you'll see the control flow
graph, plus the instruction,

00:27:57.780 --> 00:28:00.910
plus kind of a small comment
about what the variable is

00:28:00.910 --> 00:28:03.470
or what the method call is
or what the constant is.

00:28:09.970 --> 00:28:14.140
So that's enough for-- So,
ultimately, with byte codes,

00:28:14.140 --> 00:28:17.910
the last thing I'll say is
if you're not sure, test it.

00:28:17.910 --> 00:28:21.030
We give you a function
called getbytecodesnum

00:28:21.030 --> 00:28:22.980
and this allows you
to see what byte

00:28:22.980 --> 00:28:25.190
code number you're
currently executing.

00:28:25.190 --> 00:28:27.690
So if I want to profile
a particular function

00:28:27.690 --> 00:28:29.290
call or a particular
algorithm, just

00:28:29.290 --> 00:28:32.830
surround it with two system.out
print line getbytecodenum.

00:28:32.830 --> 00:28:35.150
And this will tell you the
total number of byte codes

00:28:35.150 --> 00:28:36.960
that your algorithm
took to execute.

00:28:36.960 --> 00:28:38.960
And you can use this to
kind of profile it down.

00:28:38.960 --> 00:28:40.590
You can try different
things but ultimately

00:28:40.590 --> 00:28:42.030
whatever gets that
number smallest

00:28:42.030 --> 00:28:46.910
is what helps you bot when
you're optimizing algorithms.

00:28:46.910 --> 00:28:51.222
We actually, at the bottom,
this is a little loop

00:28:51.222 --> 00:28:52.680
that-- or this is
a little function

00:28:52.680 --> 00:28:55.810
call that I've added
at least every year.

00:28:55.810 --> 00:28:57.215
At the end of
every robot's round

00:28:57.215 --> 00:28:58.674
it actually checks
the round number

00:28:58.674 --> 00:29:00.298
and the current byte
code number to see

00:29:00.298 --> 00:29:01.650
if it went over byte codes.

00:29:01.650 --> 00:29:05.950
And it will actually emit a
warning to the system console

00:29:05.950 --> 00:29:07.180
that it went over byte codes.

00:29:07.180 --> 00:29:09.780
So actually it's really
annoying but it's really helpful

00:29:09.780 --> 00:29:11.950
that if every time a
robot goes over byte codes

00:29:11.950 --> 00:29:13.020
it yells at you.

00:29:13.020 --> 00:29:16.382
Because then you can play
match if you're not actually

00:29:16.382 --> 00:29:18.340
profiling something-- or
if you're not actually

00:29:18.340 --> 00:29:20.210
explicitly saying
that, you can sometimes

00:29:20.210 --> 00:29:22.415
ignore it because the
byte code number is just

00:29:22.415 --> 00:29:24.790
in the top right of the client
and you'll kind of miss it

00:29:24.790 --> 00:29:25.730
sometimes.

00:29:25.730 --> 00:29:28.190
You'll see like, oh, maybe
it's like 10k or whatever.

00:29:28.190 --> 00:29:32.500
But if your robot is yelling at
you every time it goes over 10k

00:29:32.500 --> 00:29:34.231
and your entire
army just screens

00:29:34.231 --> 00:29:35.980
in the middle of battle,
there's something

00:29:35.980 --> 00:29:39.210
that has to be changed in order
to make it so that you're not

00:29:39.210 --> 00:29:40.700
missing an attack--
or you're not

00:29:40.700 --> 00:29:43.890
missing a movement every turn
that you could be moving.

00:29:43.890 --> 00:29:46.080
So this year, actually,
it's even more critical

00:29:46.080 --> 00:29:47.413
because there are no cool downs.

00:29:47.413 --> 00:29:49.450
Every robot, every
turn, can move.

00:29:49.450 --> 00:29:51.550
So if you go over
byte codes once,

00:29:51.550 --> 00:29:53.100
that's a lost
movement, which could

00:29:53.100 --> 00:29:55.360
translate to a lost attack.

00:29:55.360 --> 00:29:57.510
So it's very critical
in battle situations

00:29:57.510 --> 00:29:59.210
that you do not
go over byte code

00:29:59.210 --> 00:30:01.740
so you can get your movement.

00:30:01.740 --> 00:30:05.730
And I'll show you why in a bit
especially in micro situations.

00:30:05.730 --> 00:30:08.350
So micro is really
important, attack micro,

00:30:08.350 --> 00:30:10.320
I've been emphasizing
this over and over.

00:30:10.320 --> 00:30:13.000
You should know the execution
order of the robots.

00:30:13.000 --> 00:30:14.900
But you should know
what happens when.

00:30:14.900 --> 00:30:16.440
So when do attacks happen.

00:30:16.440 --> 00:30:19.030
So when do attacks happen?

00:30:19.030 --> 00:30:21.000
At the end of the round, right.

00:30:21.000 --> 00:30:24.279
You should understand the
discrete nature of the map

00:30:24.279 --> 00:30:26.820
and you should know that micro's
better than everything else.

00:30:26.820 --> 00:30:28.486
So I don't know if
Max has covered this,

00:30:28.486 --> 00:30:31.731
but in two robots which robot
actually wins the one v one

00:30:31.731 --> 00:30:32.230
engagement?

00:30:37.140 --> 00:30:42.400
It is-- yes, it's the one
who closes the gap first,

00:30:42.400 --> 00:30:44.430
is the one who wins
the engagement.

00:30:44.430 --> 00:30:48.070
So if I have two robots,
two squares apart, right now

00:30:48.070 --> 00:30:49.660
it's a stalemate.

00:30:49.660 --> 00:30:53.390
But if red makes the mistake to
move in, what happens is blue

00:30:53.390 --> 00:30:56.610
closes the distance and
gets the attack off first.

00:30:56.610 --> 00:31:00.060
And, all things being equal,
red will attack second.

00:31:00.060 --> 00:31:02.780
But blue has already done
the initial damage, which

00:31:02.780 --> 00:31:05.752
means on blue's turn
where he kills red,

00:31:05.752 --> 00:31:07.710
red will not deal back
the corresponding damage

00:31:07.710 --> 00:31:08.251
to kill blue.

00:31:08.251 --> 00:31:09.420
Blue will win.

00:31:09.420 --> 00:31:11.670
So blue will have one more
robot in the next upcoming

00:31:11.670 --> 00:31:13.320
engagement and
therefore higher DPS

00:31:13.320 --> 00:31:15.650
and will win the next battle.

00:31:15.650 --> 00:31:17.380
This situation is
also particularly bad

00:31:17.380 --> 00:31:19.600
because red can't
actually retreat.

00:31:19.600 --> 00:31:24.810
If red moves back, blue can
still close the gap next turn.

00:31:24.810 --> 00:31:28.070
So understanding how the
micro works in this game

00:31:28.070 --> 00:31:30.950
is actually very key
to winning engagements.

00:31:30.950 --> 00:31:34.220
So in a one v one
situation the gap closer

00:31:34.220 --> 00:31:37.150
always has the advantage.

00:31:37.150 --> 00:31:38.960
Just a straight up.

00:31:38.960 --> 00:31:42.460
So you will want to write code
that takes this into account,

00:31:42.460 --> 00:31:45.460
so that you can actually
win engagements.

00:31:45.460 --> 00:31:48.050
In a two v two situation, it's
a little bit more complex.

00:31:48.050 --> 00:31:49.880
So what happens in two v two?

00:31:49.880 --> 00:31:51.900
So red can move forward.

00:31:51.900 --> 00:31:54.825
Blue can close the gap,
but red can close the gap

00:31:54.825 --> 00:31:55.700
with the second unit.

00:31:55.700 --> 00:31:57.530
And now he's dealing
twice DPS that blue

00:31:57.530 --> 00:32:00.370
has and will eventually win.

00:32:00.370 --> 00:32:02.970
Blue can actually--
if blue is clever,

00:32:02.970 --> 00:32:05.750
blue can actually micro to
focus fire on a single unit,

00:32:05.750 --> 00:32:09.560
because damage is split evenly
across all enemy robots.

00:32:09.560 --> 00:32:11.570
So blue can actually
try to micro little bit

00:32:11.570 --> 00:32:16.810
to kill the bottom red unit,
if red makes a mistake.

00:32:16.810 --> 00:32:22.610
But red will actually-- can
move down and continuously

00:32:22.610 --> 00:32:26.310
attack blue until the
blue robot is dead.

00:32:26.310 --> 00:32:27.790
And the two v one will win.

00:32:27.790 --> 00:32:32.600
And if red micros correctly
he won't lose a single unit.

00:32:32.600 --> 00:32:35.500
So in a large flight--
in larger fights,

00:32:35.500 --> 00:32:37.190
the larger army
has the advantage

00:32:37.190 --> 00:32:39.130
given correct positioning.

00:32:39.130 --> 00:32:43.040
Because you could assume in
this sort of scenario blue

00:32:43.040 --> 00:32:45.510
can actually reduce this
to a one v one flight

00:32:45.510 --> 00:32:50.560
if red does not make the correct
choices in the subsequent five

00:32:50.560 --> 00:32:51.760
or six moves.

00:32:51.760 --> 00:32:55.580
So blue ball will move up
and attack red and reduce it

00:32:55.580 --> 00:32:59.370
to a one v one scenario
unless the red robot can

00:32:59.370 --> 00:33:02.800
retreat backwards while
still attacking blue

00:33:02.800 --> 00:33:07.080
towards the bottom red unit and
continue fighting so that they

00:33:07.080 --> 00:33:10.910
can turn the one v one into
a two v one engagement.

00:33:10.910 --> 00:33:15.030
But these small, discrete steps
are what you should actually

00:33:15.030 --> 00:33:17.030
be thinking about when
you're writing microcode.

00:33:17.030 --> 00:33:21.600
It's very critical that you
don't get indefinitely kited.

00:33:21.600 --> 00:33:25.480
It's very critical you do
not write code that ends up

00:33:25.480 --> 00:33:27.114
in this scenario
where you're attacking

00:33:27.114 --> 00:33:29.030
and you try to retreat,
but you can't actually

00:33:29.030 --> 00:33:31.860
retreat in this game,
because the opponent will

00:33:31.860 --> 00:33:32.800
close the distance.

00:33:32.800 --> 00:33:34.930
So there's only two scenarios
in which you can retreat.

00:33:34.930 --> 00:33:36.700
You can retreat if
there's an army behind you

00:33:36.700 --> 00:33:37.680
willing to back you up.

00:33:37.680 --> 00:33:39.821
Or you can treat if you're
retreating over a mine.

00:33:39.821 --> 00:33:40.820
That gives you more DPS.

00:33:45.600 --> 00:33:48.217
So there's some
team dynamics things

00:33:48.217 --> 00:33:49.300
that I just want to cover.

00:33:49.300 --> 00:33:52.300
This is mostly geared towards
the novices in the room.

00:33:52.300 --> 00:33:54.850
But make sure you guys are
using source control management.

00:33:54.850 --> 00:33:56.380
I think this goes
without saying,

00:33:56.380 --> 00:33:58.880
every MIT class now
emphasizes the importance

00:33:58.880 --> 00:34:00.160
of source control management.

00:34:00.160 --> 00:34:02.640
And I'll even say you should
just use hosted source control

00:34:02.640 --> 00:34:03.440
management.

00:34:03.440 --> 00:34:05.970
So if you're using Git,
if you're using Mercurial,

00:34:05.970 --> 00:34:11.750
you should just throw it up on
one of these free hosted SCMs

00:34:11.750 --> 00:34:13.320
just because you
don't want to deal

00:34:13.320 --> 00:34:14.445
with the server going down.

00:34:14.445 --> 00:34:17.780
So my first year we made
the terrible mistake

00:34:17.780 --> 00:34:22.989
of hosting our own SVN
server on an xVM machine

00:34:22.989 --> 00:34:24.040
from [INAUDIBLE].

00:34:24.040 --> 00:34:27.760
And then randomly there was some
down time that was uncontrolled

00:34:27.760 --> 00:34:31.060
and we didn't have access to
our code base for like two days.

00:34:31.060 --> 00:34:32.170
So it was terrible.

00:34:32.170 --> 00:34:36.510
So just-- GitHub, these guys
are paid to keep your source up,

00:34:36.510 --> 00:34:37.280
OK?

00:34:37.280 --> 00:34:40.699
So [INAUDIBLE] is not paid to
maintain that your battle code

00:34:40.699 --> 00:34:42.250
source does not go down.

00:34:42.250 --> 00:34:44.845
So trust these large
source control guys.

00:34:44.845 --> 00:34:47.379
And especially trust
distributed source control,

00:34:47.379 --> 00:34:48.420
if you guys are familiar.

00:34:48.420 --> 00:34:53.739
I think Max gave a lecture on
Git, so use it effectively.

00:34:53.739 --> 00:34:56.940
And also figure out your SCM--
your source control strategy.

00:34:56.940 --> 00:34:58.510
So this is actually a big one.

00:34:58.510 --> 00:35:02.584
Every team does they're kind of
release cycle or, I would say,

00:35:02.584 --> 00:35:05.000
release cycle but you're like
releasing bots, a little bit

00:35:05.000 --> 00:35:05.830
differently.

00:35:05.830 --> 00:35:07.680
So I'll explain
the way we did it.

00:35:07.680 --> 00:35:09.470
We had a single
package called Ducks,

00:35:09.470 --> 00:35:11.470
just because we
really like ducks.

00:35:11.470 --> 00:35:12.480
Don't ask.

00:35:12.480 --> 00:35:16.700
We forked off a bot
every time we release it.

00:35:16.700 --> 00:35:19.190
So in our mainline
Ducks package,

00:35:19.190 --> 00:35:22.022
when we get to a state, we're
saying this bot's reasonable.

00:35:22.022 --> 00:35:23.480
We want to submit
it to the server.

00:35:23.480 --> 00:35:25.590
We'll actually copy
the Ducks package,

00:35:25.590 --> 00:35:27.920
rename it to our kind of
bot naming scheme, which

00:35:27.920 --> 00:35:32.780
is based on SC2AI levels,
if you guys play Starcraft.

00:35:32.780 --> 00:35:35.380
And so we started off
with a medium player.

00:35:35.380 --> 00:35:39.510
So we'll copy the Duck's package
into the medium player package.

00:35:39.510 --> 00:35:41.340
And what this allows
you to do is always

00:35:41.340 --> 00:35:44.040
have a copy of the medium
player in your repository.

00:35:44.040 --> 00:35:46.490
So you can always
pit your mainline bot

00:35:46.490 --> 00:35:48.070
against any of the
other heads you've

00:35:48.070 --> 00:35:50.504
cut off from the repository.

00:35:50.504 --> 00:35:52.170
So some teams like
to do it differently.

00:35:52.170 --> 00:35:58.482
I know Gunface in 2011 liked
to use source control tagging.

00:35:58.482 --> 00:35:59.940
So what this allowed
them to do was

00:35:59.940 --> 00:36:02.740
they could update to any
version in the source control.

00:36:02.740 --> 00:36:03.920
And they could recompile it.

00:36:03.920 --> 00:36:05.490
But the issue with
that is if you

00:36:05.490 --> 00:36:08.150
update you have to update
your entire mainline package

00:36:08.150 --> 00:36:08.845
backwards.

00:36:08.845 --> 00:36:10.220
You have to
recompile it, and you

00:36:10.220 --> 00:36:13.386
have to keep the class files
around so that you can pit them

00:36:13.386 --> 00:36:14.760
against your
current bot once you

00:36:14.760 --> 00:36:16.727
re-update to the current head.

00:36:16.727 --> 00:36:18.060
This gets a little bit annoying.

00:36:18.060 --> 00:36:20.480
And for us it was just
simpler to persist

00:36:20.480 --> 00:36:23.250
like 30-40 copies of
the same file just

00:36:23.250 --> 00:36:24.480
in different packages.

00:36:24.480 --> 00:36:26.210
Because it saves on time.

00:36:26.210 --> 00:36:28.690
It's not elegant, but
elegance doesn't really

00:36:28.690 --> 00:36:30.300
matter that much
when you're trying

00:36:30.300 --> 00:36:34.484
to finish a bot in the short
amount of time that you have.

00:36:34.484 --> 00:36:35.900
We actually went
one step further.

00:36:35.900 --> 00:36:37.774
This is technically part
of the custom tools,

00:36:37.774 --> 00:36:39.980
but we actually had One
touch deploy system.

00:36:39.980 --> 00:36:41.680
So we had a single
script that was

00:36:41.680 --> 00:36:44.840
responsible for building the
release, tagging the release,

00:36:44.840 --> 00:36:47.982
testing the release on our
automated mass testing system.

00:36:47.982 --> 00:36:49.690
And then cutting the
branch from mainline

00:36:49.690 --> 00:36:51.820
and pushing it back
to the repository.

00:36:51.820 --> 00:36:53.970
This is very key,
actually, if you're

00:36:53.970 --> 00:36:56.060
doing what some of you
guys may have been doing

00:36:56.060 --> 00:36:58.280
last night in trying to
submit like 20 seconds

00:36:58.280 --> 00:36:59.470
before the deadline.

00:36:59.470 --> 00:37:03.460
Because if something goes wrong
you're completely screwed.

00:37:03.460 --> 00:37:06.230
So if you have a tool
that you know works

00:37:06.230 --> 00:37:08.230
and you know roughly the
amount of time it takes

00:37:08.230 --> 00:37:10.130
for it to work,
it's standardized

00:37:10.130 --> 00:37:12.560
and you're less
prone to human error.

00:37:12.560 --> 00:37:13.660
So we ran the script.

00:37:13.660 --> 00:37:14.450
Everything's done.

00:37:14.450 --> 00:37:15.160
We have a jar.

00:37:15.160 --> 00:37:15.910
We upload the jar.

00:37:15.910 --> 00:37:16.960
We're done.

00:37:16.960 --> 00:37:19.371
And this is reliable
that we're not manually

00:37:19.371 --> 00:37:20.620
trying to create the zip file.

00:37:20.620 --> 00:37:22.560
I know some people
have been having

00:37:22.560 --> 00:37:24.670
issues with bots
randomly exploding.

00:37:24.670 --> 00:37:27.159
Or sometimes a submission
works or sometimes a submission

00:37:27.159 --> 00:37:27.700
doesn't work.

00:37:27.700 --> 00:37:29.230
If the whole thing
is automated it's

00:37:29.230 --> 00:37:31.640
going to work barring
some catastrophic failure.

00:37:34.760 --> 00:37:36.762
This is also a random
cute little tip.

00:37:36.762 --> 00:37:38.220
Sorry for this
stream of conscious,

00:37:38.220 --> 00:37:41.120
but I'm just trying to mind
up as much useful information

00:37:41.120 --> 00:37:43.320
on to you.

00:37:43.320 --> 00:37:45.160
This one I'm actually
really surprised,

00:37:45.160 --> 00:37:47.170
I couldn't figure this
out for like three years.

00:37:47.170 --> 00:37:49.080
How to deal with
shared debugging.

00:37:49.080 --> 00:37:51.350
So for those of you
guys working in teams,

00:37:51.350 --> 00:37:53.600
you'll have print lines,
you'll have indicator strings

00:37:53.600 --> 00:37:56.015
that one day you'll
be testing something

00:37:56.015 --> 00:37:58.340
and you'll merge in
someone else's pull.

00:37:58.340 --> 00:38:01.267
And then you'll be like who
overwrote my indicator strings?

00:38:01.267 --> 00:38:03.100
Because now I don't
know what I'm debugging.

00:38:03.100 --> 00:38:05.480
Have any of you
guys had this issue?

00:38:05.480 --> 00:38:08.456
So you'll have--
you're debugging nav

00:38:08.456 --> 00:38:10.080
and you're printing
out the current Nav

00:38:10.080 --> 00:38:12.857
state-- your current state
machine's navigation position,

00:38:12.857 --> 00:38:14.940
and all the sudden the guy
working on attack micro

00:38:14.940 --> 00:38:17.740
has overwrote your indicator
strings with current number

00:38:17.740 --> 00:38:20.070
of robots attacking
you, or whatever.

00:38:20.070 --> 00:38:22.460
And this gets really
frustrating really fast.

00:38:22.460 --> 00:38:24.622
Because then you end up
with merge conflicts,

00:38:24.622 --> 00:38:26.830
when people try change each
others indicator strings.

00:38:26.830 --> 00:38:29.413
The guy working on nav will con
out the attack guy's indicator

00:38:29.413 --> 00:38:29.940
strings.

00:38:29.940 --> 00:38:31.270
And then you'll end up
with a merge conflict

00:38:31.270 --> 00:38:32.590
and then you guys will
screw up the merge conflict.

00:38:32.590 --> 00:38:34.580
And stuff will just go to hell.

00:38:34.580 --> 00:38:40.120
So what we did was
the bots can actually

00:38:40.120 --> 00:38:45.630
read from the Java bc.config.

00:38:45.630 --> 00:38:48.570
And actually what we built was
this custom system, this custom

00:38:48.570 --> 00:38:52.290
debug system, that
allowed us to specify

00:38:52.290 --> 00:38:55.720
who was running the bot based
on the current eclipse launch

00:38:55.720 --> 00:38:57.890
profile, and only print
out indicator strings

00:38:57.890 --> 00:39:00.820
from the person watching it.

00:39:00.820 --> 00:39:04.320
So you'll see on the left
we made four custom launch

00:39:04.320 --> 00:39:04.820
profiles.

00:39:04.820 --> 00:39:07.380
One for me, one for Justin,
one for Haitao, one for YP.

00:39:07.380 --> 00:39:09.610
And when you ran your
custom launch profile,

00:39:09.610 --> 00:39:12.846
it would only display debug
information from your bot.

00:39:12.846 --> 00:39:14.470
So you'd only see
your own print lines.

00:39:14.470 --> 00:39:15.810
You'd only see your
own indicator strings.

00:39:15.810 --> 00:39:17.515
And then we never
had a merge conflict.

00:39:17.515 --> 00:39:18.890
Well, we did have
merge conflicts

00:39:18.890 --> 00:39:22.010
but not related to
indicator string setting.

00:39:22.010 --> 00:39:24.340
So this is just a
small little trick

00:39:24.340 --> 00:39:26.610
that just saves a lot of time.

00:39:26.610 --> 00:39:32.622
Because stuff will add up
across your total bot's

00:39:32.622 --> 00:39:33.330
development time.

00:39:33.330 --> 00:39:37.780
You don't want to spend
time arguing about people--

00:39:37.780 --> 00:39:39.324
I know some teams
will say, OK, you

00:39:39.324 --> 00:39:40.740
can only use
indicator string one.

00:39:40.740 --> 00:39:42.920
I'll only use
indicator string two.

00:39:42.920 --> 00:39:45.610
But someone will need
two lines of information.

00:39:45.610 --> 00:39:49.430
Then you guys will fight over
it and it's really stupid.

00:39:49.430 --> 00:39:52.780
Other general, useful advice.

00:39:52.780 --> 00:39:56.510
All the past teams have actually
put a lot of information on.

00:39:56.510 --> 00:39:59.430
So there's a lot of stuff that
I don't need to reiterate.

00:39:59.430 --> 00:40:02.000
So how many of you guys
actually read the blog post

00:40:02.000 --> 00:40:04.420
that I put on hacker news?

00:40:04.420 --> 00:40:07.630
Yeah, nice.

00:40:07.630 --> 00:40:12.110
From 2012 to 2009, actually,
all the old strategy reports,

00:40:12.110 --> 00:40:14.550
all the winning teams,
are actually online.

00:40:14.550 --> 00:40:16.920
So I have the bug
post from our team,

00:40:16.920 --> 00:40:18.360
but there's also
a strategy report

00:40:18.360 --> 00:40:21.490
that corresponds to that, to our
bot, that's in our repository.

00:40:21.490 --> 00:40:23.850
The 2011 post-mortem is
actually an excellent

00:40:23.850 --> 00:40:27.380
write up by Steve Arcangeli,
who wrote the massive scrim

00:40:27.380 --> 00:40:29.870
tester about
various other tricks

00:40:29.870 --> 00:40:32.640
you can do to save byte codes.

00:40:32.640 --> 00:40:36.500
2010 is by Spencer Skates
on finding the shortest

00:40:36.500 --> 00:40:37.190
path to victory.

00:40:37.190 --> 00:40:40.830
It's kind of their whole like
Bellman Ford pun team thing

00:40:40.830 --> 00:40:42.210
that they had going on.

00:40:42.210 --> 00:40:45.010
They detail a lot of
high level mechanics

00:40:45.010 --> 00:40:48.390
that help you when
you're in combat.

00:40:48.390 --> 00:40:51.230
They also-- Spencer Skates
and Steve Bartell also won

00:40:51.230 --> 00:40:55.980
in '09 and they were called
G2G Ice Skating Lessons,

00:40:55.980 --> 00:40:59.560
which was-- it was like an
inside joke that none of us

00:40:59.560 --> 00:41:00.200
got.

00:41:00.200 --> 00:41:04.880
But they wrote about their
2009 experiences as well.

00:41:04.880 --> 00:41:08.650
They actually set the trend of
the winning team usually ending

00:41:08.650 --> 00:41:11.300
up writing the best
strategy reports, which

00:41:11.300 --> 00:41:12.940
is a trend you guys
should continue.

00:41:15.670 --> 00:41:17.280
Some other random tips.

00:41:17.280 --> 00:41:18.420
Messaging.

00:41:18.420 --> 00:41:20.680
I'm really excited about
the new changes this year,

00:41:20.680 --> 00:41:22.630
because messaging is global.

00:41:22.630 --> 00:41:25.720
So what this allows you
to do is you no longer

00:41:25.720 --> 00:41:27.800
have to have robots
really close together.

00:41:27.800 --> 00:41:30.005
So if you guys are familiar
with the 2011 game, what

00:41:30.005 --> 00:41:32.630
you would have to do is, because
you could only broadcast eight

00:41:32.630 --> 00:41:38.580
squares away, you had to set up
a relay network of robots that

00:41:38.580 --> 00:41:40.302
would propagate
information outwards.

00:41:40.302 --> 00:41:42.510
And it was a whole amount
of overhead just associated

00:41:42.510 --> 00:41:44.210
with writing the
relay network that

00:41:44.210 --> 00:41:47.630
could get a message from
robot a to your entire army.

00:41:47.630 --> 00:41:49.470
That was at least a
day's worth of work.

00:41:49.470 --> 00:41:51.000
Setting up the re-broadcasting.

00:41:51.000 --> 00:41:52.340
Setting up the hashing.

00:41:52.340 --> 00:41:54.090
Setting up all that code.

00:41:54.090 --> 00:41:58.270
This year, because everything
is a global message board,

00:41:58.270 --> 00:42:01.490
it makes it easier to broadcast
very important information very

00:42:01.490 --> 00:42:02.710
fast to all your robots.

00:42:02.710 --> 00:42:04.750
But what this also
does is battle code

00:42:04.750 --> 00:42:07.750
has a huge history of
message based attacks.

00:42:07.750 --> 00:42:09.380
So it also makes
the message based

00:42:09.380 --> 00:42:12.940
attacks more interesting because
now the enemy very easily can

00:42:12.940 --> 00:42:17.370
see everything you're
writing to the board.

00:42:17.370 --> 00:42:19.220
So some of the more
famous message attacks

00:42:19.220 --> 00:42:25.220
have been one year-- you guys
are familiar that the robot VM

00:42:25.220 --> 00:42:26.835
limit is eight megs, right?

00:42:26.835 --> 00:42:28.460
So if you exceed
eight megs, your robot

00:42:28.460 --> 00:42:29.910
actually automatically uploads.

00:42:29.910 --> 00:42:32.410
So one year, a team went around
just broadcasting eight megs

00:42:32.410 --> 00:42:33.360
arrays.

00:42:33.360 --> 00:42:36.250
So the enemy team would
either get it, try to process,

00:42:36.250 --> 00:42:37.605
and completely freeze.

00:42:37.605 --> 00:42:38.980
They'd get it,
try to process it,

00:42:38.980 --> 00:42:40.680
and explode immediately,
because they

00:42:40.680 --> 00:42:42.820
loaded into memory or
something stupid like that.

00:42:42.820 --> 00:42:46.390
Or they would just stop
moving because they constantly

00:42:46.390 --> 00:42:49.300
exceed their byte code limit.

00:42:49.300 --> 00:42:54.060
Then, I think in like '07,
teams were trying to exploit

00:42:54.060 --> 00:42:56.870
the fixed cost of
array.hashcode.

00:42:56.870 --> 00:43:00.340
So array.hashcode used
to be a single byte code.

00:43:00.340 --> 00:43:05.130
We used to-- there is a package
in your distributable battle

00:43:05.130 --> 00:43:07.630
code installer
called method costs,

00:43:07.630 --> 00:43:12.480
and that explains the cost of
every single method that we

00:43:12.480 --> 00:43:14.040
don't explicitly
list a cost for--

00:43:14.040 --> 00:43:15.900
Or if a method is
not listed in there

00:43:15.900 --> 00:43:19.800
it's free unless it's in one
of the restricted packages.

00:43:19.800 --> 00:43:22.364
But what happened was
array.hashcodes was free.

00:43:22.364 --> 00:43:24.280
So teams thought they
were being really clever

00:43:24.280 --> 00:43:28.200
by using the o of
one hashcode cost

00:43:28.200 --> 00:43:30.640
to basically do an
o of n algorithm

00:43:30.640 --> 00:43:33.860
to get entire hashcode and
secure their messages that way.

00:43:33.860 --> 00:43:36.290
But then one team
just took the fact

00:43:36.290 --> 00:43:38.590
that every team was
using array.hashcode

00:43:38.590 --> 00:43:41.030
and he could mutate the
array without changing

00:43:41.030 --> 00:43:43.960
the value of the final hash.

00:43:43.960 --> 00:43:46.350
And then he would send
that back to the robot

00:43:46.350 --> 00:43:48.551
and all their robots would
just completely mess up.

00:43:48.551 --> 00:43:50.300
Because they thought
the hash was correct,

00:43:50.300 --> 00:43:52.420
but the data was
completely garbled,

00:43:52.420 --> 00:43:56.120
which which was a really
interesting messaging attack.

00:43:56.120 --> 00:44:01.690
So you need to make sure
when your messaging to check

00:44:01.690 --> 00:44:06.010
the integrity of the data and
make sure that the data-- check

00:44:06.010 --> 00:44:07.389
the validity of
the data and also

00:44:07.389 --> 00:44:08.930
make sure that the
data actually gets

00:44:08.930 --> 00:44:11.060
to where it's supposed to go.

00:44:11.060 --> 00:44:14.220
So, this year the most
obvious attack, of course,

00:44:14.220 --> 00:44:16.090
is to wipe the entire board.

00:44:16.090 --> 00:44:19.660
And you can do this every round
if you have some obscene number

00:44:19.660 --> 00:44:21.830
of generators, like 30 or so.

00:44:21.830 --> 00:44:23.990
But the thing is, you can
pool energy this year.

00:44:23.990 --> 00:44:26.050
So actually a team
that, say, just wants

00:44:26.050 --> 00:44:28.640
to wipe the message board
during critical situations,

00:44:28.640 --> 00:44:32.250
like during an engagement, can
actually pool enough energy

00:44:32.250 --> 00:44:35.170
so that they can wipe the
entire message board in one go.

00:44:35.170 --> 00:44:37.150
So you can't actually
assume that what

00:44:37.150 --> 00:44:38.850
you wrote into the message
board one round will actually

00:44:38.850 --> 00:44:40.930
be their the next round,
or even between rounds.

00:44:40.930 --> 00:44:43.650
Because a robot-- The enemy
robot who executed between you

00:44:43.650 --> 00:44:46.330
could have wiped it.

00:44:46.330 --> 00:44:50.730
So make sure that whatever
messaging scheme you use,

00:44:50.730 --> 00:44:52.910
there's a way to check
the validity either

00:44:52.910 --> 00:44:56.930
by hashing and storing maybe
the top four bytes as your hash.

00:44:56.930 --> 00:44:59.440
Or by duplicating the
information in multiple places

00:44:59.440 --> 00:45:02.390
and checking that all
the information matches

00:45:02.390 --> 00:45:04.280
with each other.

00:45:04.280 --> 00:45:08.690
But as long as you can reliably
get important information over.

00:45:08.690 --> 00:45:11.960
Like if you had a retreat
signal, or an all out attack

00:45:11.960 --> 00:45:13.830
signal, just make
sure it's secured

00:45:13.830 --> 00:45:16.700
and it's safely propagated
to all your robots.

00:45:19.550 --> 00:45:21.980
Here's a random piece of advice.

00:45:21.980 --> 00:45:24.060
Keep your frameworks
lean, especially

00:45:24.060 --> 00:45:25.640
with the byte code limit.

00:45:25.640 --> 00:45:29.860
You don't want to create
this beautiful hierarchy

00:45:29.860 --> 00:45:32.750
of abstract interfaces
that just has

00:45:32.750 --> 00:45:36.020
a ton of intermediate
layers before you actually

00:45:36.020 --> 00:45:37.740
get to the nitty gritty code.

00:45:37.740 --> 00:45:40.520
Because for every additional
layer of abstraction,

00:45:40.520 --> 00:45:42.160
you're increasing
the byte code cost.

00:45:42.160 --> 00:45:45.110
So actually one of the cool
things that the byte code

00:45:45.110 --> 00:45:49.490
limitation actually enforces is
it enforces really lean code,

00:45:49.490 --> 00:45:52.140
which is not something
you typically see in Java.

00:45:52.140 --> 00:45:54.880
So if you'll actually look
at our class structure,

00:45:54.880 --> 00:45:58.460
this is from our 2012 bot, we
have a very, very flat class

00:45:58.460 --> 00:45:59.020
hierarchy.

00:45:59.020 --> 00:46:01.686
One, because we just didn't want
to deal with extra subpackages.

00:46:03.590 --> 00:46:05.610
And two, because
there's really not

00:46:05.610 --> 00:46:08.950
too much to be gained from
really elegant architecture

00:46:08.950 --> 00:46:10.690
other than just wasting time.

00:46:10.690 --> 00:46:13.330
Because the behavior code
is ultimately what matters.

00:46:13.330 --> 00:46:16.230
So we wrote extremely
lean frameworks.

00:46:16.230 --> 00:46:18.550
So this is actually
our main run loop.

00:46:18.550 --> 00:46:22.880
You'll see here all we do is
we reset our internal timers.

00:46:22.880 --> 00:46:25.500
We update a few key
round variables,

00:46:25.500 --> 00:46:27.950
like the current time,
and my current energy,

00:46:27.950 --> 00:46:32.460
and the current position
of all the bases.

00:46:32.460 --> 00:46:34.660
And then we run
our message system.

00:46:34.660 --> 00:46:40.030
We actually run the main run
call, which would basically

00:46:40.030 --> 00:46:42.210
be a giant state
machine, probably like

00:46:42.210 --> 00:46:44.124
500, 600 to 1,000
lines long of just

00:46:44.124 --> 00:46:46.540
completely messy code that
determines what the robot wants

00:46:46.540 --> 00:46:48.110
to do and does it.

00:46:48.110 --> 00:46:51.447
And then we actually
abstracted movement out.

00:46:51.447 --> 00:46:53.530
This was probably the
biggest piece of abstraction

00:46:53.530 --> 00:46:55.220
that we did, was we
moved a movement out

00:46:55.220 --> 00:46:59.330
to a separate position where
we knew that each robot was

00:46:59.330 --> 00:47:01.450
reliably moving
every single round,

00:47:01.450 --> 00:47:04.790
because it's very key that
you always move because that

00:47:04.790 --> 00:47:08.050
is an impact on your
total damage per second.

00:47:08.050 --> 00:47:10.050
And then we did
some generic things.

00:47:10.050 --> 00:47:12.190
And we also have this cute
little thing down here

00:47:12.190 --> 00:47:15.150
at the bottom which is if we had
some spare byte codes we would

00:47:15.150 --> 00:47:17.620
use the extra byte
codes for computation.

00:47:17.620 --> 00:47:20.080
So navigation last year
was-- because there

00:47:20.080 --> 00:47:21.512
were walls, the
algorithms you had

00:47:21.512 --> 00:47:23.470
to use last year were
actually quite different.

00:47:26.580 --> 00:47:29.140
Most teams would write
something called bugnav,

00:47:29.140 --> 00:47:33.370
which-- you guys from
the navigation lecture,

00:47:33.370 --> 00:47:36.062
I suppose you discussed a little
bit, where you see an obstacle,

00:47:36.062 --> 00:47:38.520
you hit the obstacle, you try
to trace around the obstacle,

00:47:38.520 --> 00:47:41.340
and then once you're free of
the obstacle you keep moving.

00:47:41.340 --> 00:47:43.757
But the more advanced
teams would actually

00:47:43.757 --> 00:47:45.590
write a more complex
version of bugnav which

00:47:45.590 --> 00:47:48.570
is called tangentbug, which
is-- you basically can project

00:47:48.570 --> 00:47:51.510
a virtual bug and if you
see you've rounded a corner,

00:47:51.510 --> 00:47:53.750
instead of going forward,
hitting the wall,

00:47:53.750 --> 00:47:56.310
and going around it, you
can just cut the corner.

00:47:56.310 --> 00:47:58.440
And we actually used
our extra byte codes

00:47:58.440 --> 00:48:01.750
to pre-compute steps
of tangentbug in order

00:48:01.750 --> 00:48:05.970
to make our navigation maybe
five or six squares better.

00:48:05.970 --> 00:48:09.770
But that better means you get
to the enemy two rounds faster

00:48:09.770 --> 00:48:11.250
because you cut a corner.

00:48:11.250 --> 00:48:15.320
And then two rounds faster means
you have extra DPS on the enemy

00:48:15.320 --> 00:48:19.460
and so you win that
initial engagement.

00:48:19.460 --> 00:48:23.360
This year because there
are no permanent walls,

00:48:23.360 --> 00:48:25.590
bugnav and tangentbug
may not actually

00:48:25.590 --> 00:48:28.060
be some of the best algorithms.

00:48:28.060 --> 00:48:30.450
Haitao and I have kind
of a little bet running

00:48:30.450 --> 00:48:33.184
on what the best nav will be.

00:48:33.184 --> 00:48:34.600
We're thinking
it's probably going

00:48:34.600 --> 00:48:37.830
to be some sort of very
discretized floodfill algorithm

00:48:37.830 --> 00:48:41.280
or Astar algorithm that doesn't
try to compute every square

00:48:41.280 --> 00:48:44.130
but actually breaks everything
up into discrete segments.

00:48:44.130 --> 00:48:46.310
So you want to be able
to rush to the enemy base

00:48:46.310 --> 00:48:48.430
if they're just a
straight up nuke bot.

00:48:48.430 --> 00:48:51.750
We guarantee you a
round-- we guarantee you

00:48:51.750 --> 00:48:54.144
a minimum of 200 rounds if
you follow the optimal path.

00:48:54.144 --> 00:48:56.060
But you have to know
what that optimal path is

00:48:56.060 --> 00:48:58.510
or you won't get there in time.

00:48:58.510 --> 00:49:00.530
Maximum of 200 rounds.

00:49:00.530 --> 00:49:05.440
So our bets are actually
on the most advanced teams

00:49:05.440 --> 00:49:07.980
writing kind of
an Astar algorithm

00:49:07.980 --> 00:49:10.170
or a floodfill algorithm
that takes the map,

00:49:10.170 --> 00:49:12.490
divides it into discrete
chunks so it doesn't consider

00:49:12.490 --> 00:49:15.230
every individual square,
and then it kind of picks

00:49:15.230 --> 00:49:18.490
sort of roughly the
best path to take.

00:49:18.490 --> 00:49:21.160
So you can avoid areas
with more or less mines

00:49:21.160 --> 00:49:22.625
than the other areas.

00:49:22.625 --> 00:49:25.250
And then this will still get you
to the nuke bot in enough time

00:49:25.250 --> 00:49:27.300
without having to
blow the entire cost

00:49:27.300 --> 00:49:30.940
of the complete Astar algorithm.

00:49:30.940 --> 00:49:34.140
So Astar, in maybe like an
eight by eight or ten by ten

00:49:34.140 --> 00:49:36.010
is tenable, but it's
not tenable in twenty

00:49:36.010 --> 00:49:39.740
by twenty or a hundred
by a hundred situations.

00:49:42.830 --> 00:49:44.420
This is kind of a big one.

00:49:44.420 --> 00:49:45.990
Don't be afraid to
write messy code.

00:49:48.866 --> 00:49:52.020
I think it speaks for
itself, but in case

00:49:52.020 --> 00:49:54.880
you guys are like spending
a lot of time trying

00:49:54.880 --> 00:49:56.440
to make beautiful
code, the thing

00:49:56.440 --> 00:49:59.350
is what you ship is
ultimately-- what

00:49:59.350 --> 00:50:01.980
you ship that changes your
bot's performance is ultimately

00:50:01.980 --> 00:50:02.847
what matters.

00:50:02.847 --> 00:50:04.430
And a lot of beginners
have this issue

00:50:04.430 --> 00:50:06.430
where they're afraid
to just hack something

00:50:06.430 --> 00:50:09.510
together, or hack a
one off bot to test.

00:50:09.510 --> 00:50:12.590
But it's so key that you
kind of overcome this fear

00:50:12.590 --> 00:50:15.160
to write messy code,
write stuff that works,

00:50:15.160 --> 00:50:18.780
just get something hacked
out that's working.

00:50:18.780 --> 00:50:20.710
And then use that
to gain yourself

00:50:20.710 --> 00:50:22.340
an advantage in
what matters, which

00:50:22.340 --> 00:50:25.280
is the actual scrimmage, the
tournament matches, et cetera.

00:50:25.280 --> 00:50:28.070
So we actually have
code that's terrible.

00:50:28.070 --> 00:50:30.880
Our navigation code
actually is completely--

00:50:30.880 --> 00:50:33.950
is not understandable by the
person who wrote it anymore

00:50:33.950 --> 00:50:36.270
because it's so messy.

00:50:36.270 --> 00:50:38.400
Like you can imagine,
bugnav, for anyone

00:50:38.400 --> 00:50:41.194
who's tried to implement
bugnav it sounds really simple,

00:50:41.194 --> 00:50:43.360
but there are actually like
100s or so of edge cases

00:50:43.360 --> 00:50:45.130
that you have to account for.

00:50:45.130 --> 00:50:48.150
So if you end up bugging around
another robot or you end up

00:50:48.150 --> 00:50:49.853
in some sort of
infinite loop bug,

00:50:49.853 --> 00:50:52.910
there's a lot of extra edge
conditions that you have

00:50:52.910 --> 00:50:55.950
to account for that none of
the previous lecturers have

00:50:55.950 --> 00:51:02.100
actually talked about
from '09 or 2010 or 2011.

00:51:02.100 --> 00:51:04.040
They'll just say oh
yeah, it's bugnav,

00:51:04.040 --> 00:51:05.290
just go around the thing.

00:51:05.290 --> 00:51:07.550
But what happens if you
have two units bugging

00:51:07.550 --> 00:51:10.420
around the same wall and
then they hit each other,

00:51:10.420 --> 00:51:12.000
then one unit has to go around.

00:51:12.000 --> 00:51:14.606
But if one unit goes around
and the unit on top moves,

00:51:14.606 --> 00:51:15.980
all of the sudden
you have a unit

00:51:15.980 --> 00:51:17.560
who's no longer next
to a wall but though he

00:51:17.560 --> 00:51:18.643
was bugging around a wall.

00:51:18.643 --> 00:51:20.685
But he doesn't see any
walls next to him anymore.

00:51:20.685 --> 00:51:22.226
And then you're
states get messed up.

00:51:22.226 --> 00:51:23.750
And everything
just goes to hell.

00:51:23.750 --> 00:51:26.090
So don't be afraid to
just write edge case

00:51:26.090 --> 00:51:28.240
code that deals with
that, gets your bot up

00:51:28.240 --> 00:51:31.340
and running so you can test the
frameworks, and the strategies,

00:51:31.340 --> 00:51:34.350
and everything that matters.

00:51:34.350 --> 00:51:38.630
There's also-- last minute
hacks actually win games.

00:51:38.630 --> 00:51:41.070
So I don't know if you guys
are familiar with our 2011--

00:51:41.070 --> 00:51:43.390
or 2012 championship.

00:51:43.390 --> 00:51:45.870
But what we did was
on the very last day

00:51:45.870 --> 00:51:47.510
we were scrimmaging
on the server

00:51:47.510 --> 00:51:53.910
and we found out that the second
place scrim team, team 16,

00:51:53.910 --> 00:51:56.157
had modified his attack
code, that it was actually

00:51:56.157 --> 00:51:57.240
slightly better than ours.

00:51:57.240 --> 00:51:59.770
And because having
better attack code

00:51:59.770 --> 00:52:04.430
means you win the engagement, it
means he beat our bot actually

00:52:04.430 --> 00:52:06.740
three times out of four.

00:52:06.740 --> 00:52:10.030
So we got, actually,
really scared about this.

00:52:10.030 --> 00:52:11.730
And don't forget
we scrimmed this

00:52:11.730 --> 00:52:13.550
the day of the
final submissions.

00:52:13.550 --> 00:52:16.350
So an hour before the
deadline, me, Haitao, and YP

00:52:16.350 --> 00:52:18.790
are just thinking about well
what should we actually do?

00:52:18.790 --> 00:52:23.010
So our ultimate hack was
we actually figure out

00:52:23.010 --> 00:52:25.870
what the team is by the
characteristic of their message

00:52:25.870 --> 00:52:26.865
broadcasting.

00:52:26.865 --> 00:52:28.740
So you're not actually
given the team number.

00:52:28.740 --> 00:52:30.390
But if you look at what kind
of messages they're sending,

00:52:30.390 --> 00:52:32.060
you can kind of guess, right?

00:52:32.060 --> 00:52:37.150
And throughout the
whole battle code 2012

00:52:37.150 --> 00:52:40.060
we had been kind of on
the side just curious,

00:52:40.060 --> 00:52:42.680
looking at the structure
of other teams messages.

00:52:42.680 --> 00:52:46.200
And so an hour before
the deadline submission

00:52:46.200 --> 00:52:47.910
we wrote something
that determined

00:52:47.910 --> 00:52:50.750
whether the team we were
playing against was team 16.

00:52:50.750 --> 00:52:52.990
And we would change
our strategy.

00:52:52.990 --> 00:52:54.310
And this was an hour before.

00:52:54.310 --> 00:52:55.891
And it was completely
untested code.

00:52:55.891 --> 00:52:57.640
But we had been thinking
about it, kind of

00:52:57.640 --> 00:53:00.130
in the back of our mind, and
we just threw this together.

00:53:00.130 --> 00:53:01.330
We uploaded it.

00:53:01.330 --> 00:53:04.570
And if you were at the finals
it was a pretty tense match

00:53:04.570 --> 00:53:07.280
where we actually had
a bug in that code that

00:53:07.280 --> 00:53:10.380
triggered once and would
not trigger a second time.

00:53:10.380 --> 00:53:14.840
But the one time it did trigger
was the very last match,

00:53:14.840 --> 00:53:17.840
and so we ultimately won
the final tournament.

00:53:17.840 --> 00:53:22.880
But this is like a piece of
code, incredibly critical.

00:53:22.880 --> 00:53:25.459
It's like three or
four lines, but it

00:53:25.459 --> 00:53:27.500
was the difference between
first or second place.

00:53:27.500 --> 00:53:31.240
So once again, spending time
where it matters is really key.

00:53:31.240 --> 00:53:33.970
You can probably do these
sort of hacks this year.

00:53:33.970 --> 00:53:36.460
Determining what the team is
based on the message structure

00:53:36.460 --> 00:53:37.550
is a little bit harder.

00:53:37.550 --> 00:53:40.305
Because last year people would
send discrete message objects.

00:53:40.305 --> 00:53:41.930
And so you could
count the total number

00:53:41.930 --> 00:53:44.159
of integers, the total
number of map locations.

00:53:44.159 --> 00:53:45.700
Whether there's a
secret key and then

00:53:45.700 --> 00:53:48.010
you could correlate
the secret keys.

00:53:48.010 --> 00:53:51.099
This year you'll have to
see how they channel hop

00:53:51.099 --> 00:53:52.890
or what they store on
the various channels,

00:53:52.890 --> 00:53:57.260
or the channel distribution
of the different messages.

00:53:57.260 --> 00:53:58.720
But it's still possible.

00:53:58.720 --> 00:54:01.289
So last minute
hacks do win games.

00:54:01.289 --> 00:54:02.580
This is also another small one.

00:54:02.580 --> 00:54:05.073
You guys should all-- if
you're not already using IRC,

00:54:05.073 --> 00:54:07.830
you should use IRC, because
all the devs are on IRC,

00:54:07.830 --> 00:54:11.120
especially us who are remote.

00:54:11.120 --> 00:54:14.830
I was the only person working
on engine who was actually

00:54:14.830 --> 00:54:17.700
willing to fly out six
hours to give this talk.

00:54:17.700 --> 00:54:18.894
So everyone else is on IRC.

00:54:18.894 --> 00:54:20.810
If you have any questions
you should go on IRC

00:54:20.810 --> 00:54:23.480
and you should actually
ask your question.

00:54:23.480 --> 00:54:26.230
So, for those of you who don't
know, there's a web client.

00:54:26.230 --> 00:54:28.160
Just use the
freenode web client,

00:54:28.160 --> 00:54:30.140
connect to channel
battle code, ask

00:54:30.140 --> 00:54:31.680
whatever questions you have.

00:54:31.680 --> 00:54:35.760
We'll answer them pretty fast.

00:54:35.760 --> 00:54:37.760
If you guys are feeling
a little more advanced,

00:54:37.760 --> 00:54:39.230
you should use IRC better.

00:54:39.230 --> 00:54:41.000
If you actually
parsesys in the channel

00:54:41.000 --> 00:54:44.425
there's a lot of banter that
goes on regarding game balance.

00:54:44.425 --> 00:54:46.770
Or teams will discuss
strategies or whatever.

00:54:46.770 --> 00:54:49.090
So if you actually
get a good IRC client

00:54:49.090 --> 00:54:52.410
and stay in the channel,
you'll actually learn a lot.

00:54:52.410 --> 00:54:56.520
Because sometimes some of
the old battle code champions

00:54:56.520 --> 00:54:58.984
will just come in, just talk
a little bit about strategy.

00:54:58.984 --> 00:55:00.650
Or people will just
discuss what they've

00:55:00.650 --> 00:55:02.066
been doing on the
bots, et cetera.

00:55:02.066 --> 00:55:05.120
And so just use a
good IRC chat client.

00:55:05.120 --> 00:55:06.520
If you were to
use pigeon, pigeon

00:55:06.520 --> 00:55:07.603
has a built-in IRC client.

00:55:07.603 --> 00:55:10.110
There's no reason to
not connect to it.

00:55:10.110 --> 00:55:12.660
Talk to the devs, ask questions.

00:55:12.660 --> 00:55:15.220
There's just been a lot
of very simple questions,

00:55:15.220 --> 00:55:17.380
but we're more than
happy to answer.

00:55:17.380 --> 00:55:19.870
So questions about
round number, or if you

00:55:19.870 --> 00:55:21.340
have an issue with
your bot, it's

00:55:21.340 --> 00:55:23.089
much faster than the
forums, because we'll

00:55:23.089 --> 00:55:25.640
answer the IRC
probably in minutes

00:55:25.640 --> 00:55:29.110
rather than hours on the forum.

00:55:29.110 --> 00:55:31.530
And, most of all, you
guys should just have fun.

00:55:31.530 --> 00:55:35.370
Battle code, at least for us,
was a very fun experience.

00:55:35.370 --> 00:55:37.180
We worked hard on it.

00:55:37.180 --> 00:55:40.100
But we also-- we
goofed off a lot.

00:55:40.100 --> 00:55:44.506
We probably spent more than
40 hours playing Civ 5.

00:55:44.506 --> 00:55:45.880
And before the
sprint tournament,

00:55:45.880 --> 00:55:50.320
or before the Qualls tournament,
this is usually a bad idea.

00:55:50.320 --> 00:55:53.450
But it's about-- this is
IP, it's about having fun.

00:55:53.450 --> 00:55:56.220
So work hard, but also have fun.

00:55:56.220 --> 00:55:58.370
And also I have a few requests.

00:55:58.370 --> 00:56:03.420
So there may potentially be
the 2013 winner in this group.

00:56:03.420 --> 00:56:07.190
So, if it is one of you
guys, just a few requests.

00:56:07.190 --> 00:56:09.107
You guys should write
a good strategy report,

00:56:09.107 --> 00:56:10.940
because battle code is
not done in a vacuum.

00:56:10.940 --> 00:56:12.440
We learned from the
teams before us.

00:56:12.440 --> 00:56:15.280
The teams before us learned
from the teams before them.

00:56:15.280 --> 00:56:17.949
This information really needs
to be more out and open,

00:56:17.949 --> 00:56:19.740
which is why I'm giving
you kind of a brain

00:56:19.740 --> 00:56:22.386
dump of a lot of the
very small tricks

00:56:22.386 --> 00:56:24.760
and tips that we did in order
to gain a competitive edge.

00:56:24.760 --> 00:56:27.630
So write a good strategy report,
help your fellow competitors.

00:56:27.630 --> 00:56:30.860
This is a friendly competition,
it's not cutthroat.

00:56:30.860 --> 00:56:33.350
You guys can make fun of all
the other lesser competitions,

00:56:33.350 --> 00:56:36.120
but within battle code
keep it a good family.

00:56:36.120 --> 00:56:39.730
And then join the
devs if you guys win,

00:56:39.730 --> 00:56:41.440
because we need good desks.

00:56:41.440 --> 00:56:43.154
So thanks.

00:56:43.154 --> 00:56:52.420
[APPLAUSE]

00:56:52.420 --> 00:56:56.440
CORY: So any general
questions or whatever?

00:56:56.440 --> 00:56:59.360
Once again, yeah, it's our
fault if you guys really

00:56:59.360 --> 00:57:04.580
hate nuke you should say it now.

00:57:04.580 --> 00:57:06.950
Yes?

00:57:06.950 --> 00:57:08.581
[INAUDIBLE]

00:57:08.581 --> 00:57:10.205
AUDIENCE: It changes
from year to year.

00:57:10.205 --> 00:57:14.250
So how did you choose your team?

00:57:14.250 --> 00:57:16.472
CORY: The 2012 team was
all Star League people.

00:57:16.472 --> 00:57:18.180
So there's also another
Star League team.

00:57:18.180 --> 00:57:21.850
I have some high hopes
for the Star League guys.

00:57:21.850 --> 00:57:24.840
First year I did it with
people from my high school.

00:57:24.840 --> 00:57:27.260
Second year I did it, I did
it with Star League people.

00:57:27.260 --> 00:57:29.870
The third year was also all
Star League people as well.

00:57:29.870 --> 00:57:32.203
You guys should go to Star
League if you like Starcraft.

00:57:32.203 --> 00:57:32.930
That's a pitch.

00:57:32.930 --> 00:57:37.270
Every Friday at 7:00
o'clock for 253.

00:57:37.270 --> 00:57:38.750
Go play Starcraft

00:57:38.750 --> 00:57:41.960
It'll make your meta
game analysis better.

00:57:44.817 --> 00:57:45.650
Any other questions?

00:57:45.650 --> 00:57:47.370
Balance?

00:57:47.370 --> 00:57:50.320
General comments?

00:57:50.320 --> 00:57:52.187
So I'll be here
afterwards if you guys

00:57:52.187 --> 00:57:53.270
want to ask any questions.

00:57:53.270 --> 00:57:54.936
If you want to look
through our old bot.

00:57:54.936 --> 00:57:57.400
At some point I will
write out a code

00:57:57.400 --> 00:57:59.770
walk through of our 2012 bot.

00:57:59.770 --> 00:58:02.280
But until then
just ask, or we'll

00:58:02.280 --> 00:58:03.960
be in the IRC
channel or whatever.

00:58:03.960 --> 00:58:06.566
So hopefully this was
useful to you guys.

00:58:06.566 --> 00:58:08.420
So thanks.

00:58:08.420 --> 00:58:09.970
[APPLAUSE]

