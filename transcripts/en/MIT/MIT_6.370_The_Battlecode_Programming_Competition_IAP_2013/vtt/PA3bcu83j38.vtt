WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:01.660
The following
content is provided

00:00:01.660 --> 00:00:03.800
under a Creative
Commons license.

00:00:03.800 --> 00:00:06.540
Your support will help MIT
OpenCourseWare continue

00:00:06.540 --> 00:00:10.150
to offer high quality
educational resources for free.

00:00:10.150 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.531
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.531 --> 00:00:17.156
at ocw.mit.edu.

00:00:24.030 --> 00:00:27.500
PROFESSOR: So today's
lecture is supposed

00:00:27.500 --> 00:00:29.430
to be about navigation,
but in many ways,

00:00:29.430 --> 00:00:31.090
that can be a
pretty dry subject.

00:00:31.090 --> 00:00:34.080
So what I've done is I've made
it very graphical and sort

00:00:34.080 --> 00:00:35.277
of active and animated.

00:00:35.277 --> 00:00:36.360
No, this is just a folder.

00:00:36.360 --> 00:00:42.370
This isn't the-- Anyway, so a
couple of administration pieces

00:00:42.370 --> 00:00:44.690
is the Sprint
submission deadline.

00:00:44.690 --> 00:00:47.650
The Sprint Tournament
will be held on Wednesday,

00:00:47.650 --> 00:00:51.032
but you need to submit your
code by Monday at midnight.

00:00:51.032 --> 00:00:52.490
There's a little
bit of wiggle room

00:00:52.490 --> 00:00:55.440
where you can submit it like
a few hours after midnight,

00:00:55.440 --> 00:00:57.050
but don't plan on that.

00:00:57.050 --> 00:00:57.550
Yeah.

00:00:57.550 --> 00:01:00.540
And you submit your code
to the Sprint Tournament

00:01:00.540 --> 00:01:03.750
and that makes you
eligible to win prizes.

00:01:03.750 --> 00:01:06.210
And it also helps you
with your seeding,

00:01:06.210 --> 00:01:09.080
so that you'll be seeded into
a higher part of the tournament

00:01:09.080 --> 00:01:10.920
bracket for the next tournament.

00:01:10.920 --> 00:01:14.130
So yeah, you've got
to get started early.

00:01:14.130 --> 00:01:16.560
We'll also be offering
another source of money

00:01:16.560 --> 00:01:19.270
for you, as if you didn't
have enough sources of money

00:01:19.270 --> 00:01:22.827
with the Sprint Tournament,
and all of those special prizes

00:01:22.827 --> 00:01:24.660
we're giving out, and
the tournament itself.

00:01:24.660 --> 00:01:26.950
We're also offering
an extra prize

00:01:26.950 --> 00:01:29.800
for the team that is most
helpful to other teams

00:01:29.800 --> 00:01:31.390
and people.

00:01:31.390 --> 00:01:33.380
So that means that now
you have an incentive,

00:01:33.380 --> 00:01:36.370
beyond just being a good
person, to help other teams out.

00:01:36.370 --> 00:01:39.540
We'll have a survey that
goes out in the last week.

00:01:39.540 --> 00:01:42.310
And so if you've
gangstered everybody

00:01:42.310 --> 00:01:44.550
into voting you as
helpful, then you'll

00:01:44.550 --> 00:01:47.490
win the prize without
being helpful.

00:01:47.490 --> 00:01:50.461
So just keep that in mind.

00:01:50.461 --> 00:01:50.960
All right.

00:01:50.960 --> 00:01:54.100
So today we're supposed
to talk about navigation.

00:01:54.100 --> 00:01:56.390
Let's have a look at this thing.

00:01:56.390 --> 00:01:58.120
Here is a program that
I wrote that makes

00:01:58.120 --> 00:01:59.894
a maze, piece by piece.

00:01:59.894 --> 00:02:01.560
There's probably a
smarter way to do it,

00:02:01.560 --> 00:02:03.450
but I just built
random walks that self

00:02:03.450 --> 00:02:06.402
avoid onto one another
to make a maze.

00:02:06.402 --> 00:02:08.610
And what I've done here is
I've got a variable called

00:02:08.610 --> 00:02:12.560
delay that lets me change the
speed at which a computation is

00:02:12.560 --> 00:02:13.060
performed.

00:02:13.060 --> 00:02:15.220
So you can see here,
if I set it to 0.5,

00:02:15.220 --> 00:02:17.889
then we'll be here all day,
because each one of these paths

00:02:17.889 --> 00:02:19.930
is going to take a half
a second to put together.

00:02:19.930 --> 00:02:23.490
But this is helpful, because a
lot of times a pathing routine

00:02:23.490 --> 00:02:24.830
will happen instantly.

00:02:24.830 --> 00:02:28.080
Or in compute time,
it'll happen fast,

00:02:28.080 --> 00:02:30.300
and you won't really
notice what's going on.

00:02:30.300 --> 00:02:34.010
So let's go ahead and set
this to a small number.

00:02:34.010 --> 00:02:38.260
Now we've got a map that has a
bottom left and an upper right.

00:02:38.260 --> 00:02:40.710
And we're going to use
this map to demonstrate

00:02:40.710 --> 00:02:42.550
a bunch of pathing techniques.

00:02:42.550 --> 00:02:45.320
So we're trying to get from the
bottom left to the upper right.

00:02:45.320 --> 00:02:48.940
The first method we're going
to use is depth first search.

00:02:48.940 --> 00:02:50.250
So I'm going to run this.

00:02:50.250 --> 00:02:51.160
Oh, it finished.

00:02:51.160 --> 00:02:52.260
That was dumb.

00:02:52.260 --> 00:02:56.190
Let's make the delay 0.1.

00:02:56.190 --> 00:02:56.880
Yeah.

00:02:56.880 --> 00:02:59.060
So now, you can see I'm
starting from the left

00:02:59.060 --> 00:03:02.800
and I'm going along in a
depth first search, which

00:03:02.800 --> 00:03:06.300
means that I'm looking
toward the end first.

00:03:06.300 --> 00:03:09.800
And then after I have
investigated everything,

00:03:09.800 --> 00:03:11.715
I'll start again at
the next branch point.

00:03:11.715 --> 00:03:13.920
So I haven't even
looked at this.

00:03:13.920 --> 00:03:17.271
I've gone along and, yeah,
so I check that-- oh, done.

00:03:17.271 --> 00:03:17.770
OK.

00:03:17.770 --> 00:03:19.334
So now you can see it finished.

00:03:19.334 --> 00:03:20.750
But I'm going to
run it once more,

00:03:20.750 --> 00:03:23.110
and I want you to keep
your eye on the colors that

00:03:23.110 --> 00:03:25.490
are displayed on the right here.

00:03:25.490 --> 00:03:28.320
The color indicates how
far it thinks something is.

00:03:28.320 --> 00:03:30.250
And it's scaled
from white to black.

00:03:30.250 --> 00:03:32.220
So when it finds
something that's darker,

00:03:32.220 --> 00:03:35.490
it will brighten
up this other area.

00:03:35.490 --> 00:03:40.270
So pathing systems are
basically just a way

00:03:40.270 --> 00:03:44.510
of trying all the
possible combinations.

00:03:44.510 --> 00:03:47.380
But there are little tricks
of making that smarter.

00:03:47.380 --> 00:03:48.740
I'll show it one last time.

00:03:48.740 --> 00:03:51.290
The point is to make
it smarter than trying

00:03:51.290 --> 00:03:52.620
every possible combination.

00:03:52.620 --> 00:03:55.900
Like for example, if you've
visited an area before,

00:03:55.900 --> 00:03:57.520
then don't try that again.

00:03:57.520 --> 00:04:01.720
Or if you visited
an area before,

00:04:01.720 --> 00:04:04.080
and you got there closer
than you currently are,

00:04:04.080 --> 00:04:06.860
then don't try that again.

00:04:06.860 --> 00:04:08.780
So there you have it.

00:04:08.780 --> 00:04:11.340
There is an example
of depth first search.

00:04:11.340 --> 00:04:13.760
And we're going to move on
and show an example of breadth

00:04:13.760 --> 00:04:16.260
first search to show
how different it is.

00:04:16.260 --> 00:04:19.230
They're going to look pretty
similar for this example,

00:04:19.230 --> 00:04:22.260
but the next example I give
won't be pathing in a maze.

00:04:22.260 --> 00:04:24.620
It'll be pathing in
something that's more open.

00:04:24.620 --> 00:04:27.240
So here's a breadth
first search.

00:04:27.240 --> 00:04:30.632
And you can see, it's sort
of parallel pursuing paths.

00:04:30.632 --> 00:04:33.090
Like it's doing a little down
here and a little down there.

00:04:33.090 --> 00:04:35.640
And it's jumping back
and forth between things

00:04:35.640 --> 00:04:36.914
that have the same depth.

00:04:36.914 --> 00:04:39.330
I'm going to show it again and
I want you to pay attention

00:04:39.330 --> 00:04:42.550
to the colors, specifically
white and black.

00:04:42.550 --> 00:04:47.820
You see that it never goes
back and updates a point

00:04:47.820 --> 00:04:48.590
all at once.

00:04:48.590 --> 00:04:50.000
It does it bit by bit.

00:04:50.000 --> 00:04:52.980
So you see areas are gradually
lightening, rather than

00:04:52.980 --> 00:04:54.810
lightening all at once.

00:04:54.810 --> 00:04:56.140
So I show this one more time.

00:04:56.140 --> 00:05:01.770
This is breadth first
search on this maze computed

00:05:01.770 --> 00:05:02.770
in real time.

00:05:02.770 --> 00:05:06.190
I can change this maze
and it'll come out again.

00:05:06.190 --> 00:05:09.597
For the explicit purpose of
demonstrating the concept,

00:05:09.597 --> 00:05:11.930
I actually had to go to the
trouble of writing a breadth

00:05:11.930 --> 00:05:12.860
first search.

00:05:12.860 --> 00:05:15.120
It's not that hard, at
least in Mathematica,

00:05:15.120 --> 00:05:17.600
and I'm pretty sure it's
not hard in any language

00:05:17.600 --> 00:05:19.640
to write something that works.

00:05:19.640 --> 00:05:21.940
And we'll talk more
about that later.

00:05:21.940 --> 00:05:23.930
But I know a lot
of you have already

00:05:23.930 --> 00:05:26.640
heard of a lot of
concepts in navigation.

00:05:26.640 --> 00:05:28.850
And you've also got Wikipedia.

00:05:28.850 --> 00:05:31.150
You could just go online
and find, oh, I see.

00:05:31.150 --> 00:05:34.440
These are the things that
are important for that.

00:05:34.440 --> 00:05:35.650
So let's move on.

00:05:35.650 --> 00:05:38.440
Now we have a bug navigation.

00:05:38.440 --> 00:05:43.530
Bugs apparently find their
way round rooms and things

00:05:43.530 --> 00:05:46.590
by walking until they hit
an object, like a wall,

00:05:46.590 --> 00:05:48.840
and then they just
follow along the wall.

00:05:48.840 --> 00:05:53.360
There's also a well known
truth, or truism, or something

00:05:53.360 --> 00:05:55.372
like that, where if
you're in a maze,

00:05:55.372 --> 00:05:56.959
and you put your
hand on one wall,

00:05:56.959 --> 00:05:58.500
and you follow that
wall, then you'll

00:05:58.500 --> 00:05:59.541
find the end of the maze.

00:05:59.541 --> 00:06:01.650
So let's try to
watch that at work.

00:06:01.650 --> 00:06:04.220
Actually, let's
make the speed 0.05.

00:06:04.220 --> 00:06:08.760
So here we've got a bug,
and he's walking along.

00:06:08.760 --> 00:06:12.960
The yellow represents
his left hand.

00:06:12.960 --> 00:06:14.750
No, the yellow is
his right hand,

00:06:14.750 --> 00:06:17.530
and he's following
the left wall.

00:06:17.530 --> 00:06:19.530
So you can see he's going
to round to the left.

00:06:19.530 --> 00:06:21.380
He's really not finding
the fastest path

00:06:21.380 --> 00:06:23.580
from the bottom left
to the upper right.

00:06:23.580 --> 00:06:25.534
But the point is,
he'll get there.

00:06:25.534 --> 00:06:26.200
So there you go.

00:06:26.200 --> 00:06:27.210
He found his way there.

00:06:27.210 --> 00:06:31.230
Let's show that
again a bit slower.

00:06:31.230 --> 00:06:36.550
So the goal here is when you
program a bug pathing system,

00:06:36.550 --> 00:06:39.240
it's that the guy
has to remember

00:06:39.240 --> 00:06:42.090
what direction he
has been going.

00:06:42.090 --> 00:06:45.080
Because if he is just
in a position, just

00:06:45.080 --> 00:06:48.720
any given position-- so
I'll pause it at some point,

00:06:48.720 --> 00:06:50.120
say here.

00:06:50.120 --> 00:06:52.490
So maybe he's here.

00:06:52.490 --> 00:06:56.320
How is he going to know whether
he was going down or up?

00:06:56.320 --> 00:06:58.920
That's the way that he
remembers his current state is

00:06:58.920 --> 00:06:59.630
the direction.

00:06:59.630 --> 00:07:02.110
Now, that's like a
big thing about bug

00:07:02.110 --> 00:07:04.940
is that it doesn't
need any memory at all.

00:07:04.940 --> 00:07:08.920
Its memory is sort of encoded in
its position and its direction.

00:07:08.920 --> 00:07:11.980
And that's all it needs.

00:07:11.980 --> 00:07:13.720
Whereas other forms
of pathing, you've

00:07:13.720 --> 00:07:16.740
got to store these lists,
and how long they are,

00:07:16.740 --> 00:07:20.790
and where they go, and which
lists are their parent lists

00:07:20.790 --> 00:07:22.370
or parent nodes.

00:07:22.370 --> 00:07:23.900
But bug is very simple.

00:07:23.900 --> 00:07:27.090
Again, it's not really that
fantastic at getting you

00:07:27.090 --> 00:07:28.460
where you need to go.

00:07:28.460 --> 00:07:30.140
And you might also
ask the question,

00:07:30.140 --> 00:07:32.430
what do you do when
you're not in a maze?

00:07:32.430 --> 00:07:35.260
So let's go ahead and
answer that question

00:07:35.260 --> 00:07:37.200
of what you do when
you're not in a maze.

00:07:37.200 --> 00:07:40.820
And we can go over the details
of how to implement bug

00:07:40.820 --> 00:07:43.170
if we have time at the end.

00:07:43.170 --> 00:07:45.600
But you can look
all that stuff up.

00:07:45.600 --> 00:07:50.020
So just in brief summary, we've
looked at depth first search,

00:07:50.020 --> 00:07:52.590
breadth first search,
and bug pathing.

00:07:52.590 --> 00:07:54.540
I'll talk more about
the details of each one,

00:07:54.540 --> 00:07:57.000
but I like to just sort
of go through once,

00:07:57.000 --> 00:07:59.610
and go through again
with more detail.

00:07:59.610 --> 00:08:01.360
So let's change it to
an alternative maze.

00:08:01.360 --> 00:08:03.568
This isn't what you're going
to have for battle code.

00:08:03.568 --> 00:08:04.880
That would be terrible.

00:08:04.880 --> 00:08:09.370
Mazes are not that exciting
in terms of video games.

00:08:09.370 --> 00:08:12.066
Here is an example
of the kind of map

00:08:12.066 --> 00:08:13.190
you'd have for battle code.

00:08:13.190 --> 00:08:15.260
And what depth first
search is trying

00:08:15.260 --> 00:08:18.360
to do to locate
the shortest path.

00:08:18.360 --> 00:08:19.920
So first it's going deep.

00:08:19.920 --> 00:08:23.740
It's going to keep going on its
path until it finds the end.

00:08:23.740 --> 00:08:27.280
Now, there are ways of making
depth first search where

00:08:27.280 --> 00:08:30.320
it won't do what it's doing
now, which is kind of silly.

00:08:30.320 --> 00:08:31.850
What is it doing?

00:08:31.850 --> 00:08:34.289
Filling space with this line.

00:08:34.289 --> 00:08:36.130
And all these
possible combinations

00:08:36.130 --> 00:08:37.559
of filling space with this line.

00:08:37.559 --> 00:08:39.549
It's just wasting our time here.

00:08:39.549 --> 00:08:41.220
It wants to go from
there to there.

00:08:41.220 --> 00:08:43.870
What's it doing over here?

00:08:43.870 --> 00:08:45.230
So that's an example.

00:08:45.230 --> 00:08:49.990
We're going to make this
run as fast as it can run.

00:08:49.990 --> 00:08:54.650
So let's pause the
evaluation and run it again.

00:08:54.650 --> 00:08:56.690
As so you can see
now it's faster,

00:08:56.690 --> 00:09:00.590
but it's still trying a
whole bunch of combinations

00:09:00.590 --> 00:09:03.250
that just don't make any sense.

00:09:03.250 --> 00:09:04.510
Here it goes along the left.

00:09:04.510 --> 00:09:05.970
Here it goes along this side.

00:09:05.970 --> 00:09:07.166
It's going to try verticals.

00:09:07.166 --> 00:09:08.540
OK, now it's going
try all these.

00:09:08.540 --> 00:09:09.040
OK.

00:09:09.040 --> 00:09:11.520
Sweep, sweep, sweep,
sweep, sweep, sweep.

00:09:11.520 --> 00:09:13.870
Now, let's hope, for
God's sake, don't

00:09:13.870 --> 00:09:15.440
try-- oh god, it tried there.

00:09:15.440 --> 00:09:17.117
[LAUGHTER]

00:09:17.117 --> 00:09:17.950
PROFESSOR: Well, OK.

00:09:17.950 --> 00:09:19.658
Now that it's tried
this area, let's hope

00:09:19.658 --> 00:09:21.730
it doesn't go keep trying
these different things.

00:09:21.730 --> 00:09:23.813
Like up here, let's hope
it doesn't go back there.

00:09:23.813 --> 00:09:25.277
That'd been such
a waste of time.

00:09:25.277 --> 00:09:26.860
So here it's going--
oh, what is this?

00:09:26.860 --> 00:09:27.359
It's going--

00:09:27.359 --> 00:09:28.090
[LAUGHTER]

00:09:28.090 --> 00:09:30.350
PROFESSOR: It's looping
around and spinning.

00:09:30.350 --> 00:09:33.330
And now, it's-- oh, finally.

00:09:33.330 --> 00:09:33.830
Man.

00:09:33.830 --> 00:09:37.464
I'm going to fire that guy.

00:09:37.464 --> 00:09:39.630
Let's see if breadth first
search can do any better.

00:09:39.630 --> 00:09:43.202
Let's keep the delay at
0.1 and see what happens.

00:09:43.202 --> 00:09:44.120
Oh, let's see.

00:09:44.120 --> 00:09:46.630
It's searching the
nearby paths rather

00:09:46.630 --> 00:09:48.610
than going down one that's deep.

00:09:48.610 --> 00:09:49.600
I see.

00:09:49.600 --> 00:09:52.990
Doesn't seem to be crossing
over old ground too much.

00:09:52.990 --> 00:09:54.540
So if it's located
this point, it's

00:09:54.540 --> 00:09:57.332
not going to try 10 different
ways of getting to this point.

00:09:57.332 --> 00:09:59.280
One of the features of
breadth first search

00:09:59.280 --> 00:10:02.920
is that if the
distance between nodes

00:10:02.920 --> 00:10:06.160
is uniform, like every
square is the same distance

00:10:06.160 --> 00:10:09.240
from every other square, then
as soon as you find the end,

00:10:09.240 --> 00:10:13.319
you've found the shortest
path to get to the end.

00:10:13.319 --> 00:10:15.110
So what we're going to
see is that it's not

00:10:15.110 --> 00:10:18.540
going to keep looking
after it finds this tile.

00:10:18.540 --> 00:10:20.320
It's just going to stop.

00:10:20.320 --> 00:10:20.820
Bing.

00:10:20.820 --> 00:10:21.320
OK.

00:10:21.320 --> 00:10:23.970
And it's all done once
it looked at that depth.

00:10:23.970 --> 00:10:26.150
Wow, that was pretty convenient.

00:10:26.150 --> 00:10:28.530
Let's see how bug
does on the same map.

00:10:28.530 --> 00:10:31.980
Now, this is just
showing the last result.

00:10:31.980 --> 00:10:33.350
Let's see what result bug gets.

00:10:33.350 --> 00:10:35.150
It's not going to
look like this.

00:10:35.150 --> 00:10:36.000
So there it is.

00:10:36.000 --> 00:10:38.600
It moved along and
followed this wall.

00:10:38.600 --> 00:10:40.619
And then it stopped
bugging along the wall,

00:10:40.619 --> 00:10:41.910
and then it followed this wall.

00:10:41.910 --> 00:10:43.410
And now it's bugging
along that way.

00:10:43.410 --> 00:10:44.721
Are we in a loop?

00:10:44.721 --> 00:10:45.220
Nope.

00:10:45.220 --> 00:10:46.220
No, we're not in a loop.

00:10:46.220 --> 00:10:47.660
It's following along this way.

00:10:47.660 --> 00:10:48.860
And bing.

00:10:48.860 --> 00:10:50.130
It got to the result.

00:10:50.130 --> 00:10:51.000
Pretty exciting.

00:10:51.000 --> 00:10:53.270
Let's show that one
or two more times

00:10:53.270 --> 00:10:56.960
to explain what's going on
when it's trying to do this.

00:10:56.960 --> 00:10:59.360
As soon as it hits
a wall, bug has

00:10:59.360 --> 00:11:01.550
to decide if it's going
to go left or right.

00:11:01.550 --> 00:11:03.620
Later on I'm going
to talk about why

00:11:03.620 --> 00:11:05.660
that can end up
being a huge problem.

00:11:05.660 --> 00:11:07.870
You'll see it left the
yellow ball behind.

00:11:07.870 --> 00:11:10.210
I only update the position
of the yellow ball

00:11:10.210 --> 00:11:11.950
when I'm in bug mode.

00:11:11.950 --> 00:11:14.430
So the point of bugging
in an open terrain

00:11:14.430 --> 00:11:16.990
is that you have to be
able to leave the bugging.

00:11:16.990 --> 00:11:19.260
You have to be able to
stop bugging at one point

00:11:19.260 --> 00:11:21.520
and start just branching off.

00:11:21.520 --> 00:11:24.240
Or else, for example, if
the goal were somewhere away

00:11:24.240 --> 00:11:26.330
from a wall, you'd
never get to it.

00:11:26.330 --> 00:11:30.590
Generally, a criteria for
leaving the bugging condition

00:11:30.590 --> 00:11:34.440
is if you are closer
to the goal than you

00:11:34.440 --> 00:11:36.110
were when you started bugging.

00:11:36.110 --> 00:11:37.200
I see a question.

00:11:37.200 --> 00:11:40.060
AUDIENCE: Why at the
very end, and also

00:11:40.060 --> 00:11:42.609
before it turns on the second
wall, does it turn inward?

00:11:42.609 --> 00:11:43.650
PROFESSOR: This one here?

00:11:43.650 --> 00:11:44.740
AUDIENCE: Yeah.

00:11:44.740 --> 00:11:48.510
PROFESSOR: Right now, when the
bug is not connected to a wall,

00:11:48.510 --> 00:11:52.810
I have it going in the direction
that is toward the goal.

00:11:52.810 --> 00:11:54.880
So here, this is like
the worst possible map,

00:11:54.880 --> 00:11:58.220
because just when it wanted
to go toward the goal,

00:11:58.220 --> 00:11:59.610
it hit another wall.

00:11:59.610 --> 00:12:00.910
So that's why it turned inward.

00:12:00.910 --> 00:12:02.410
And that's also
why it turns inward

00:12:02.410 --> 00:12:04.630
over here and over there.

00:12:04.630 --> 00:12:08.150
So that's a very good question.

00:12:08.150 --> 00:12:09.210
So let's watch it again.

00:12:09.210 --> 00:12:11.180
And what I want to
point out as well

00:12:11.180 --> 00:12:14.620
is that the yellow is
places it wants to turn.

00:12:14.620 --> 00:12:17.440
So here it wants to
make a right turn.

00:12:17.440 --> 00:12:19.320
And here it leaves
bugging because it

00:12:19.320 --> 00:12:21.870
was closer to the
destination here than it

00:12:21.870 --> 00:12:26.360
was when it was
farther back over here.

00:12:26.360 --> 00:12:29.360
So once again, it's moving
along, and it'll go around

00:12:29.360 --> 00:12:31.000
and it'll find the answer.

00:12:31.000 --> 00:12:33.830
So it's not very good
looking, but if your obstacles

00:12:33.830 --> 00:12:35.570
don't connect with
the edge of the wall,

00:12:35.570 --> 00:12:38.030
it find you sometimes
the same result

00:12:38.030 --> 00:12:39.930
that you would get otherwise.

00:12:39.930 --> 00:12:43.580
So I'm going to open
up something like Word,

00:12:43.580 --> 00:12:45.307
and I'm going to
make some notes.

00:12:45.307 --> 00:12:47.640
Because I can type faster
than I can write on the board,

00:12:47.640 --> 00:12:49.040
and that makes a lot of sense.

00:12:49.040 --> 00:12:54.330
Let's talk about metrics
of success in pathing.

00:12:54.330 --> 00:12:56.210
There's the time to arrive.

00:12:56.210 --> 00:12:59.260
You want to have a narrow
distribution of times

00:12:59.260 --> 00:13:03.414
to arrive if you were
pathing a group of units.

00:13:03.414 --> 00:13:05.330
Like if you're trying
to get to the other side

00:13:05.330 --> 00:13:06.705
and you really
want them arriving

00:13:06.705 --> 00:13:09.440
in a conga line,
that's potentially

00:13:09.440 --> 00:13:11.790
going to get them
killed one by one.

00:13:11.790 --> 00:13:14.140
You sometimes want to
explore the map as well.

00:13:14.140 --> 00:13:16.310
And there are ways of
manually working out

00:13:16.310 --> 00:13:17.280
some of these things.

00:13:17.280 --> 00:13:20.810
What's the best path to
explore the map, and so on.

00:13:20.810 --> 00:13:23.480
But these are just
things to keep in mind.

00:13:23.480 --> 00:13:27.160
And let's look at
sort of a comparison

00:13:27.160 --> 00:13:32.750
between bug a and depth first
and breadth first search.

00:13:32.750 --> 00:13:39.515
So the bug system is
computationally fast.

00:13:39.515 --> 00:13:41.640
But at the same time, you've
got your own trade off

00:13:41.640 --> 00:13:43.960
between byte codes
and compute time.

00:13:43.960 --> 00:13:48.120
It uses the unit turn, and
you can do that in two ways

00:13:48.120 --> 00:13:50.640
with battle code.

00:13:50.640 --> 00:13:54.450
You can do it with
Direction.rotateRight,

00:13:54.450 --> 00:13:58.050
which will rotate that
direction 45 degrees.

00:13:58.050 --> 00:14:01.590
Or you can do it by using, as
we did in the example yesterday,

00:14:01.590 --> 00:14:05.290
Direction.values, which gets you
eight direction values starting

00:14:05.290 --> 00:14:07.980
with north and going all
the way around to northwest.

00:14:07.980 --> 00:14:11.050
And then you can
increment this index.

00:14:11.050 --> 00:14:14.370
So if you're starting
it direction east,

00:14:14.370 --> 00:14:18.830
that would be two, because
it's north, northeast, east.

00:14:18.830 --> 00:14:19.920
So that would be two.

00:14:19.920 --> 00:14:24.230
And then you can just add one
to rotate right, add another one

00:14:24.230 --> 00:14:28.010
to rotate right
again, and so on.

00:14:28.010 --> 00:14:32.620
It's pretty interesting that bug
can work blind in battle code.

00:14:32.620 --> 00:14:34.770
Usually when you do
pathing, you want

00:14:34.770 --> 00:14:37.390
to do something like
senseGameObjects

00:14:37.390 --> 00:14:39.410
so that you could
say, all right,

00:14:39.410 --> 00:14:42.680
I want to senseGameObjects
of robot.class.

00:14:42.680 --> 00:14:45.210
I want to sense that
type of game object.

00:14:45.210 --> 00:14:47.692
And I want all of
them, because I

00:14:47.692 --> 00:14:49.650
want to make sure I don't
run into any of them.

00:14:49.650 --> 00:14:51.233
In previous years,
you would have also

00:14:51.233 --> 00:14:52.400
had to do senseTerrainTile.

00:14:55.580 --> 00:15:00.370
Yeah, it would be something
like for a given map location,

00:15:00.370 --> 00:15:02.710
you could sense--
yeah, it would be

00:15:02.710 --> 00:15:06.900
like rc for robot controller
dot senseTerrainTile.

00:15:06.900 --> 00:15:11.640
And it would be a given map
location and a or something.

00:15:11.640 --> 00:15:14.890
And you'd put it, and
you'd say, is this equal

00:15:14.890 --> 00:15:21.380
to
TerrainTile.terrainType.OFF_MAP,

00:15:21.380 --> 00:15:27.590
or it would be VOID, or
it would be like OPEN,

00:15:27.590 --> 00:15:28.770
or something like that.

00:15:28.770 --> 00:15:30.000
And it was a huge bother.

00:15:30.000 --> 00:15:32.290
So we got rid of void spaces.

00:15:32.290 --> 00:15:35.010
So now you're basically
trying to say,

00:15:35.010 --> 00:15:37.370
I need to use the
enemy mine locations.

00:15:37.370 --> 00:15:40.550
And I believe there's a
senseEnemyMineLocations

00:15:40.550 --> 00:15:42.440
or some method like that.

00:15:42.440 --> 00:15:43.760
But you don't need those.

00:15:43.760 --> 00:15:45.990
Because I said the bug is blind.

00:15:45.990 --> 00:15:48.130
You could just get
by with canMove.

00:15:48.130 --> 00:15:50.780
And that can be pretty nice.

00:15:50.780 --> 00:15:54.060
If we're not making giant
mazes, you can probably just

00:15:54.060 --> 00:15:55.280
get by using canMove.

00:15:55.280 --> 00:15:59.360
If you can't move, then
rotate in some direction.

00:15:59.360 --> 00:16:02.570
That may also end up being
cheaper computationally

00:16:02.570 --> 00:16:05.730
than using these methods
for the same bugging.

00:16:05.730 --> 00:16:08.590
I'm saying bugging
with canMove or bugging

00:16:08.590 --> 00:16:10.580
with senseGameObjects.

00:16:10.580 --> 00:16:12.180
For this kind of
stuff, I always find

00:16:12.180 --> 00:16:15.690
it useful to go into the release
where I've got the folder where

00:16:15.690 --> 00:16:18.430
I've installed battle code,
check my method costs.

00:16:18.430 --> 00:16:21.010
I say, all right, let's
see here, canMove.

00:16:21.010 --> 00:16:21.720
Here it is.

00:16:21.720 --> 00:16:23.760
Costs me 25 byte codes.

00:16:23.760 --> 00:16:27.760
How much does it cost
for me to senseRobotInfo?

00:16:27.760 --> 00:16:29.310
Because I'm going
to get robots, I'm

00:16:29.310 --> 00:16:30.670
going to have to sense
their info in order

00:16:30.670 --> 00:16:31.770
to get their location.

00:16:31.770 --> 00:16:35.450
That also costs me 25,
but that's after the costs

00:16:35.450 --> 00:16:39.650
associated with sensing
all NearbyGameObjects,

00:16:39.650 --> 00:16:42.310
which costs me 100, plus all
that other stuff I've got to do

00:16:42.310 --> 00:16:47.000
to sort of set up a loop
with checking, and savings. .

00:16:47.000 --> 00:16:48.830
No wait, that's a
different thing.

00:16:48.830 --> 00:16:52.310
So yeah, we've got a
blind-- it's blind.

00:16:52.310 --> 00:16:56.010
You should check your
leave-bugging criterion.

00:16:56.010 --> 00:16:59.254
Can be something
like patience-- just

00:16:59.254 --> 00:17:00.920
after a certain amount
of time, give up.

00:17:00.920 --> 00:17:04.180
Distance-- are you closer
than you were before?

00:17:04.180 --> 00:17:07.520
Direction-- how many times
have you turned left and right?

00:17:07.520 --> 00:17:09.312
If you keep track of
that, then it can say,

00:17:09.312 --> 00:17:10.895
all right, I've gone
around a barrier.

00:17:10.895 --> 00:17:13.220
I know that cause of the
number of times I've turned.

00:17:13.220 --> 00:17:18.119
So now I can be intelligent
about leaving that bugging.

00:17:18.119 --> 00:17:22.500
So finally, with mass
pathing using bug,

00:17:22.500 --> 00:17:25.670
you should consider
distinguishing

00:17:25.670 --> 00:17:30.150
between off-map,
void, friend, and foe.

00:17:30.150 --> 00:17:32.880
And here, void is more
realistically said

00:17:32.880 --> 00:17:35.620
to be neutral mines.

00:17:35.620 --> 00:17:37.290
I've said before
but I'll remind you

00:17:37.290 --> 00:17:40.190
that you don't know
where enemy mines are

00:17:40.190 --> 00:17:41.580
until you've stepped on them.

00:17:41.580 --> 00:17:43.920
So that's sort of a difficulty.

00:17:43.920 --> 00:17:46.360
Neutral mines are more
realistic to path around.

00:17:46.360 --> 00:17:49.290
And you could consider
writing a rush player, which

00:17:49.290 --> 00:17:52.010
locates the optimal way to
get from one base to another.

00:17:52.010 --> 00:17:53.400
Because you know the bases.

00:17:53.400 --> 00:17:53.690
You know where they are.

00:17:53.690 --> 00:17:56.250
You know where the neutral
mines are to begin with.

00:17:56.250 --> 00:17:57.980
So if you have some
of your robots,

00:17:57.980 --> 00:18:00.220
for the headquarters
for example,

00:18:00.220 --> 00:18:02.830
compute the optimal path between
your main base and the enemy

00:18:02.830 --> 00:18:04.700
base, you could rush
there more quickly

00:18:04.700 --> 00:18:05.750
than you would otherwise.

00:18:05.750 --> 00:18:07.666
It's not really going
to work with enemy mines

00:18:07.666 --> 00:18:10.170
though, because as I
said, you don't see them.

00:18:10.170 --> 00:18:12.980
So you might want to distinguish
between these different types

00:18:12.980 --> 00:18:14.850
of obstacle.

00:18:14.850 --> 00:18:18.810
Because if a foe is in the way,
do you want to path around him,

00:18:18.810 --> 00:18:20.850
or do you want to just
stop and start shooting?

00:18:20.850 --> 00:18:22.850
I mean, of course,
in this battle code,

00:18:22.850 --> 00:18:24.570
you don't have to
explicitly shoot.

00:18:24.570 --> 00:18:27.940
And you move and you
shoot simultaneously.

00:18:27.940 --> 00:18:32.750
It's worth mentioning here
that you shoot after you move.

00:18:32.750 --> 00:18:34.810
That's something that
isn't entirely obvious.

00:18:34.810 --> 00:18:35.900
You might say, OK,
it doesn't matter

00:18:35.900 --> 00:18:37.340
whether you shoot
before or after.

00:18:37.340 --> 00:18:39.010
That's just a little detail.

00:18:39.010 --> 00:18:41.400
But it ends up being super
important, especially what

00:18:41.400 --> 00:18:42.740
we're going to see later.

00:18:42.740 --> 00:18:45.960
What we'll see is that, let's
say one robot of yours and one

00:18:45.960 --> 00:18:48.900
robot of the enemy's are nearby.

00:18:48.900 --> 00:18:51.680
If the enemy moves
toward you, then it

00:18:51.680 --> 00:18:53.130
will immediately do damage.

00:18:53.130 --> 00:18:56.090
Let's say that you subsequently
move away from the enemy

00:18:56.090 --> 00:18:58.420
because you want to,
say, rejoin your group.

00:18:58.420 --> 00:19:00.460
Well, you will move away
and then not do damage.

00:19:00.460 --> 00:19:03.610
So the two of your robots will
move along in some direction,

00:19:03.610 --> 00:19:05.490
and you'll take
damage every time,

00:19:05.490 --> 00:19:07.800
and he won't take any
damage at any time.

00:19:07.800 --> 00:19:09.590
It'll be no good.

00:19:09.590 --> 00:19:12.180
Another thing is that if you
have neutral mines to path

00:19:12.180 --> 00:19:15.310
around, well, those
aren't going anywhere so

00:19:15.310 --> 00:19:16.480
you better path around them.

00:19:16.480 --> 00:19:18.574
But if you have friends
to path around, maybe

00:19:18.574 --> 00:19:20.740
you should just wait for
them to get out of the way.

00:19:20.740 --> 00:19:23.850
Because presumably, they
are also pathing somewhere,

00:19:23.850 --> 00:19:25.890
and so there's probably
just a traffic jam.

00:19:25.890 --> 00:19:27.400
And does it make
more sense for you

00:19:27.400 --> 00:19:29.062
to go running off in
another direction,

00:19:29.062 --> 00:19:31.520
or to just have some patience
and wait there for the friend

00:19:31.520 --> 00:19:32.540
to move?

00:19:32.540 --> 00:19:35.770
At the same time, the thing
that I described the other day

00:19:35.770 --> 00:19:37.560
surely applies
here, where you have

00:19:37.560 --> 00:19:41.330
a wall of enemy units here.

00:19:41.330 --> 00:19:43.450
And you've got me.

00:19:43.450 --> 00:19:47.490
And you've got a
bunch of allies here.

00:19:47.490 --> 00:19:51.714
And I want to be
here at my ice cream.

00:19:51.714 --> 00:19:53.880
But I can't get there because
allies are in the way.

00:19:53.880 --> 00:19:55.000
And I'm waiting
for them to move,

00:19:55.000 --> 00:19:56.833
and they're waiting for
me to move, together

00:19:56.833 --> 00:19:59.590
with all these other guys
that are all boxed up

00:19:59.590 --> 00:20:02.390
behind this chunk of mines.

00:20:02.390 --> 00:20:04.890
So yeah, you could realize
you'd get in some trouble.

00:20:04.890 --> 00:20:08.130
This beautiful
diagram, by the way.

00:20:08.130 --> 00:20:10.010
I save so much chalk that way.

00:20:10.010 --> 00:20:10.860
I tell you.

00:20:10.860 --> 00:20:11.360
Let's see.

00:20:11.360 --> 00:20:14.470
So now we talked a little
bit about mass pathing.

00:20:14.470 --> 00:20:16.960
I'd like to mention one
or two other aspects.

00:20:16.960 --> 00:20:19.700
You could leave room for a bend.

00:20:19.700 --> 00:20:21.220
And one way you
could do that is you

00:20:21.220 --> 00:20:25.080
could say, all right, I
realize there's a corner here.

00:20:25.080 --> 00:20:27.150
And the first guy that
goes around that way

00:20:27.150 --> 00:20:29.920
will mark this as the waypoint.

00:20:29.920 --> 00:20:32.290
Then other guys can go
straight to the waypoint.

00:20:32.290 --> 00:20:33.820
Or if they're even
smarter, they'll

00:20:33.820 --> 00:20:35.330
try to go around the waypoint.

00:20:35.330 --> 00:20:37.330
So for example,
this guy could say,

00:20:37.330 --> 00:20:41.140
he could mark all of these
positions as undesirable.

00:20:41.140 --> 00:20:45.370
And they could radiate a force
outward so that every other

00:20:45.370 --> 00:20:48.584
robot is being
repulsed by these x's.

00:20:48.584 --> 00:20:50.000
And at that point,
you might start

00:20:50.000 --> 00:20:52.940
to have the situation which
would be emergent behavior,

00:20:52.940 --> 00:20:56.850
where your robots are starting
to intelligently sort of have

00:20:56.850 --> 00:20:59.550
multiple lanes
around the obstacle,

00:20:59.550 --> 00:21:02.050
rather than having just
one lane and getting

00:21:02.050 --> 00:21:03.744
backed up behind one another.

00:21:03.744 --> 00:21:05.160
So here they're
getting backed up.

00:21:05.160 --> 00:21:07.360
And here they would
be sort of fanning out

00:21:07.360 --> 00:21:10.110
in a sort of pretty way.

00:21:10.110 --> 00:21:10.610
Yeah.

00:21:10.610 --> 00:21:13.180
And you're going to see later
the effect of fanning out.

00:21:13.180 --> 00:21:14.554
I mean, of course
you've seen it,

00:21:14.554 --> 00:21:16.510
and you can imagine
how strong it

00:21:16.510 --> 00:21:18.447
would be on the
outcome of a battle.

00:21:18.447 --> 00:21:20.280
But that's going to be
really important when

00:21:20.280 --> 00:21:23.810
we talk about the emergent
behavior of your army

00:21:23.810 --> 00:21:27.090
when you take into account local
information about where people

00:21:27.090 --> 00:21:27.940
are standing.

00:21:27.940 --> 00:21:30.760
I hope you guys like the
analogy that I sent in my email.

00:21:30.760 --> 00:21:33.570
I thought it was a little
bit contrived, but not too

00:21:33.570 --> 00:21:34.280
terrible.

00:21:34.280 --> 00:21:37.510
Not too-- OK, it
was pretty terrible.

00:21:37.510 --> 00:21:38.010
OK.

00:21:38.010 --> 00:21:41.580
So in mass pathing, also
consider your execute order.

00:21:41.580 --> 00:21:46.970
As we've mentioned before,
if you have guys in a line,

00:21:46.970 --> 00:21:50.780
and their robot IDs
are 1 and then 2

00:21:50.780 --> 00:21:55.970
and then 3 and then 4-- yeah,
this is real pretty-- then

00:21:55.970 --> 00:21:59.350
they can move left because
they'll execute in this order.

00:21:59.350 --> 00:21:59.950
Oh, man.

00:21:59.950 --> 00:22:01.595
It's like it's animated.

00:22:01.595 --> 00:22:02.920
Ah, jeez.

00:22:02.920 --> 00:22:04.380
But they can't
move to the right,

00:22:04.380 --> 00:22:05.540
because this guy's in the way.

00:22:05.540 --> 00:22:07.470
So number 1 will be like,
I don't know where to go.

00:22:07.470 --> 00:22:08.386
I'm going to go there.

00:22:08.386 --> 00:22:10.570
Number 2 is like, uh, I
can't go here or here.

00:22:10.570 --> 00:22:11.710
Maybe I'll go up there.

00:22:11.710 --> 00:22:12.460
And he gets lost.

00:22:12.460 --> 00:22:14.170
His head's cut off.

00:22:14.170 --> 00:22:15.930
AUDIENCE: Can 2 move diagonally?

00:22:15.930 --> 00:22:17.695
PROFESSOR: Yes, 2
can move down here.

00:22:17.695 --> 00:22:19.320
There is diagonal
directional movement.

00:22:19.320 --> 00:22:19.650
Yeah.

00:22:19.650 --> 00:22:20.816
And 3 could move down there.

00:22:20.816 --> 00:22:22.780
And then I guess
4 could move here,

00:22:22.780 --> 00:22:24.290
because he doesn't know
that the others-- it'd be

00:22:24.290 --> 00:22:25.380
kind of cool if they did that.

00:22:25.380 --> 00:22:27.171
And then they would
just like shimmy along.

00:22:27.171 --> 00:22:28.310
It'd be like an inch worm.

00:22:28.310 --> 00:22:29.390
That'd be pretty cool.

00:22:29.390 --> 00:22:30.050
Oh, gosh.

00:22:30.050 --> 00:22:31.770
Paint, don't do this to me.

00:22:31.770 --> 00:22:32.894
There, that's much better.

00:22:32.894 --> 00:22:34.310
So they could do
this, but 4 would

00:22:34.310 --> 00:22:35.518
have to be pretty darn smart.

00:22:35.518 --> 00:22:38.130
It's more likely that by now
these guys are inch-worming

00:22:38.130 --> 00:22:39.500
along, and 4 is over there.

00:22:39.500 --> 00:22:41.350
And eventually, 3 gets
sort of spread out.

00:22:41.350 --> 00:22:43.482
And I don't know,
1 just goes and he

00:22:43.482 --> 00:22:45.190
gets tired of the
whole deal because he's

00:22:45.190 --> 00:22:47.700
been looking at 2's
behind the whole game.

00:22:47.700 --> 00:22:50.320
So yeah, you definitely want
to keep in mind the execution

00:22:50.320 --> 00:22:50.820
order.

00:22:50.820 --> 00:22:52.278
And when I say keep
in mind, I mean

00:22:52.278 --> 00:22:55.530
you could actually do sort
of like a bubble sort, where

00:22:55.530 --> 00:22:59.920
if your ID is different from
the guy who's behind you,

00:22:59.920 --> 00:23:02.470
you could switch places with
him and try to get behind him.

00:23:02.470 --> 00:23:07.520
Because you can use the function
my robot controller dot getID,

00:23:07.520 --> 00:23:09.880
and you'll have your ID.

00:23:09.880 --> 00:23:12.670
Remember when we
did robot, and we

00:23:12.670 --> 00:23:16.700
said, all allied robots,
or something, equals

00:23:16.700 --> 00:23:21.000
rc.senseNearbyGameObjects,
the most helpful function

00:23:21.000 --> 00:23:23.556
name in the world, and
we said robot.class?

00:23:23.556 --> 00:23:24.930
You could say,
all right, all I'm

00:23:24.930 --> 00:23:26.450
interested in is
the guy behind me.

00:23:26.450 --> 00:23:28.527
Please give me the
ally guy behind me.

00:23:28.527 --> 00:23:30.860
Well, you don't need to get
all the nearby game objects.

00:23:30.860 --> 00:23:33.610
You could say, all right, I want
the one who is adjacent to me.

00:23:33.610 --> 00:23:35.990
So he's within a
distance of one,

00:23:35.990 --> 00:23:38.439
or say two if you want
to include diagonals.

00:23:38.439 --> 00:23:40.730
And then I also want to make
sure that he's on my team.

00:23:40.730 --> 00:23:42.200
So I do rc.getTeam.

00:23:42.200 --> 00:23:45.430
So now immediately, I've got
a nice list of allied robots

00:23:45.430 --> 00:23:46.410
that are nearby.

00:23:46.410 --> 00:23:48.520
If I want to get
their ID numbers,

00:23:48.520 --> 00:23:51.502
it's as simple as
rc.senseRobotInfo.

00:23:51.502 --> 00:23:52.835
And I sense one of their info's.

00:23:52.835 --> 00:23:55.270
This is aRobot, which I
can pull out of the list

00:23:55.270 --> 00:23:59.640
by doing something simple
like I'll locate the closest

00:23:59.640 --> 00:24:01.810
one in the ordinary way
that you would expect.

00:24:01.810 --> 00:24:03.740
So now I've got the robot
info, and robot info

00:24:03.740 --> 00:24:05.531
includes-- Actually,
I think you might even

00:24:05.531 --> 00:24:07.270
be able to get ID from robot.

00:24:07.270 --> 00:24:08.420
Where would I go to check?

00:24:08.420 --> 00:24:10.300
I would just simply go
to the documentation

00:24:10.300 --> 00:24:13.190
in the release,
all classes-frame.

00:24:13.190 --> 00:24:15.610
I would see robot
info, just try to see.

00:24:15.610 --> 00:24:18.309
Or maybe let's see if the robot
has-- oh, robot has getID.

00:24:18.309 --> 00:24:18.850
Look at that.

00:24:18.850 --> 00:24:22.620
So I don't even have
to senseRobotInfo.

00:24:22.620 --> 00:24:24.100
I can just go straight.

00:24:24.100 --> 00:24:26.200
So here I can just
say, ah, I'm just

00:24:26.200 --> 00:24:29.751
going to aRobot.get--
what was it?

00:24:29.751 --> 00:24:30.250
Get ID?

00:24:30.250 --> 00:24:31.470
I think it was
either get ID, or ID.

00:24:31.470 --> 00:24:33.886
And now I'll have that ID, and
I can compare it to my own,

00:24:33.886 --> 00:24:35.410
and so on, as I said.

00:24:35.410 --> 00:24:39.390
So this is all about bugging and
mass pathing in a simple way.

00:24:39.390 --> 00:24:41.697
If you want to do it
smarter, you can use a*,

00:24:41.697 --> 00:24:43.030
which is a breadth first search.

00:24:43.030 --> 00:24:44.550
You can look up all Wikipedia.

00:24:44.550 --> 00:24:48.130
And it's making a list
of where you can go.

00:24:48.130 --> 00:24:49.477
That's as simple as it is.

00:24:49.477 --> 00:24:51.810
You're making lists, and
you're keeping that list pruned

00:24:51.810 --> 00:24:54.580
down so that it hasn't got
all these extra places for you

00:24:54.580 --> 00:24:55.320
to look at.

00:24:55.320 --> 00:24:59.630
So it's shorter to
get to your goal.

00:24:59.630 --> 00:25:04.610
And what it can also do
is incorporate heuristics.

00:25:04.610 --> 00:25:06.970
We'll be talking a little
bit about heuristics today,

00:25:06.970 --> 00:25:10.270
where we're saying it's a fancy
word that, to the extent I

00:25:10.270 --> 00:25:13.260
understand it, it just means
that the distance between one

00:25:13.260 --> 00:25:15.770
square and another is
not necessarily one.

00:25:15.770 --> 00:25:18.710
Or the goodness of being
in one square or another

00:25:18.710 --> 00:25:20.760
is not necessarily the same.

00:25:20.760 --> 00:25:24.900
So maybe you want a path
from point A to point B,

00:25:24.900 --> 00:25:27.960
but you don't want to cross
a particular obstacle.

00:25:27.960 --> 00:25:30.630
I saw once that somebody
did a giant paper.

00:25:30.630 --> 00:25:33.930
I think they did a Ph.D. Thesis
on the traveling salesman

00:25:33.930 --> 00:25:34.800
problem.

00:25:34.800 --> 00:25:37.020
And they had solved the
traveling salesman problem

00:25:37.020 --> 00:25:39.640
under the condition that they
were traveling in the United

00:25:39.640 --> 00:25:43.080
States, and they did not want
to cross the Mississippi River.

00:25:43.080 --> 00:25:44.870
That's so beyond--
why would you--

00:25:44.870 --> 00:25:48.380
I love crossing the
Mississippi River.

00:25:48.380 --> 00:25:50.810
But anyway, he didn't
want to, so he did that.

00:25:50.810 --> 00:25:54.119
And I think he went ahead and
got-- now that I remember it,

00:25:54.119 --> 00:25:55.910
it was actually a high
school science fair.

00:25:55.910 --> 00:25:58.524
Ph.D., science fair, same thing.

00:25:58.524 --> 00:26:00.190
So you can incorporate
these heuristics,

00:26:00.190 --> 00:26:03.140
and it's just a
way of saying, here

00:26:03.140 --> 00:26:06.240
I've got this list of
locations that I'm going to.

00:26:06.240 --> 00:26:09.359
And I'm just going to associate
goodness or badness with them.

00:26:09.359 --> 00:26:11.150
And at the end, instead
of saying distance,

00:26:11.150 --> 00:26:12.620
I'll just say
goodness or badness.

00:26:12.620 --> 00:26:13.960
It's as simple as that.

00:26:13.960 --> 00:26:18.080
And that's how those things
end up getting done, and so on.

00:26:18.080 --> 00:26:21.280
There's also d* and a whole
plethora of other things.

00:26:21.280 --> 00:26:23.970
This is like start
from the destination

00:26:23.970 --> 00:26:27.040
and go to the start.

00:26:27.040 --> 00:26:28.770
There's various
reasons to do this.

00:26:28.770 --> 00:26:31.890
There's tangent bug, where
you're saying, all right,

00:26:31.890 --> 00:26:35.390
I recognize a certain
pattern to a* and d*.

00:26:35.390 --> 00:26:40.460
If I start at this location
and I end here at e,

00:26:40.460 --> 00:26:43.326
and the obstacles sort
of look like this,

00:26:43.326 --> 00:26:44.950
well, the only
reasonable places for me

00:26:44.950 --> 00:26:47.360
to go in this open
continuous terrain

00:26:47.360 --> 00:26:49.690
is tangents between
the two things.

00:26:49.690 --> 00:26:51.670
So I can draw a tangent there.

00:26:51.670 --> 00:26:52.796
I can draw a tangent there.

00:26:52.796 --> 00:26:55.003
From my starting position,
I draw a tangent to there.

00:26:55.003 --> 00:26:56.055
You see these tangents?

00:26:56.055 --> 00:26:56.930
They're right angles.

00:26:56.930 --> 00:26:57.880
It's beautiful.

00:26:57.880 --> 00:26:59.250
There's one here.

00:26:59.250 --> 00:27:00.877
OK, that's a right angle.

00:27:00.877 --> 00:27:03.460
This guy's got a tangent here,
and he's got another one there.

00:27:03.460 --> 00:27:06.120
There's some arbitrary
dumb ones that never apply,

00:27:06.120 --> 00:27:08.190
such as this one.

00:27:08.190 --> 00:27:09.036
Or like this one.

00:27:09.036 --> 00:27:10.410
Well, in any case,
there are ways

00:27:10.410 --> 00:27:12.500
of pruning it so that you've
got just the right tangents.

00:27:12.500 --> 00:27:14.791
And then you've really only
got like six paths to look.

00:27:14.791 --> 00:27:16.820
You can go here, and then
there, and then there.

00:27:16.820 --> 00:27:19.710
Or you can go here, and then
you can go from-- ah, yeah.

00:27:19.710 --> 00:27:20.210
There's one.

00:27:20.210 --> 00:27:21.760
You can go here
from there to there.

00:27:21.760 --> 00:27:24.930
And then that's like a
really dumb way to go there.

00:27:24.930 --> 00:27:27.190
So it's really easy once
you have tangent bug.

00:27:27.190 --> 00:27:29.940
And there's a way to
generalize that so that it's

00:27:29.940 --> 00:27:32.760
not just vector
geometry in open space,

00:27:32.760 --> 00:27:35.260
but is down to the level
where you're like, OK,

00:27:35.260 --> 00:27:37.110
these are individuals squares.

00:27:37.110 --> 00:27:39.130
I zoomed in to indicate--
that was really smart.

00:27:39.130 --> 00:27:40.130
It worked really well.

00:27:40.130 --> 00:27:41.750
I was happy with it.

00:27:41.750 --> 00:27:44.110
So there's tangent bug,
which you can use there.

00:27:44.110 --> 00:27:50.100
And you could consider having--
in tangent bug especially,

00:27:50.100 --> 00:27:52.510
you could imagine that a
headquarters could help out.

00:27:52.510 --> 00:27:56.500
Where you have these things
that you need to get around.

00:27:56.500 --> 00:27:58.020
Oh my goodness.

00:27:58.020 --> 00:27:58.720
Anyway.

00:27:58.720 --> 00:28:00.480
You want to get around
them so that you

00:28:00.480 --> 00:28:02.150
could have the
headquarters indicate

00:28:02.150 --> 00:28:04.220
what is the tangent spot.

00:28:04.220 --> 00:28:06.280
And he doesn't have to
tell you all the places.

00:28:06.280 --> 00:28:09.260
They're just like waypoints
to go to on your way

00:28:09.260 --> 00:28:10.390
to the destination.

00:28:10.390 --> 00:28:12.170
And it could work pretty well.

00:28:12.170 --> 00:28:14.020
It could.

00:28:14.020 --> 00:28:15.160
So keep in mind.

00:28:15.160 --> 00:28:17.580
There are some
undesirable behaviors

00:28:17.580 --> 00:28:21.220
to watch out for when you
do something like this.

00:28:21.220 --> 00:28:25.190
Sometimes allied units that
bug in the opposite direction,

00:28:25.190 --> 00:28:27.640
that makes a lot of sense if
you have a little obstacle

00:28:27.640 --> 00:28:28.740
to get around.

00:28:28.740 --> 00:28:32.390
But if the obstacle is
big, sometimes your robots

00:28:32.390 --> 00:28:34.630
will come at one another
from opposite directions

00:28:34.630 --> 00:28:36.020
when pathing.

00:28:36.020 --> 00:28:38.310
So you'll have--
here is the obstacle,

00:28:38.310 --> 00:28:42.080
and Robot a hits the obstacle
and starts going this way.

00:28:42.080 --> 00:28:44.660
Robot b hits the obstacle
and starts going this way.

00:28:44.660 --> 00:28:47.840
Robot b is here and a
tries to go around him.

00:28:47.840 --> 00:28:49.870
b keeps going this
way, and a now

00:28:49.870 --> 00:28:51.450
is like, I don't
know where I am.

00:28:51.450 --> 00:28:53.390
I'm just going to
spin around in midair.

00:28:53.390 --> 00:28:57.830
Because I thought I was bugging,
but then the wall changed.

00:28:57.830 --> 00:29:00.660
I know that there's like a
million movies about how people

00:29:00.660 --> 00:29:02.910
are in mazes, and then like
the big kicker is supposed

00:29:02.910 --> 00:29:05.710
to be that the maze
is shifting over time.

00:29:05.710 --> 00:29:08.230
Well, by now we're used to it,
and it's boring in a movie.

00:29:08.230 --> 00:29:11.070
But when it happens in battle
code, it hits close to home.

00:29:14.110 --> 00:29:16.200
Another undesirable
behavior could

00:29:16.200 --> 00:29:18.770
be that you bug
around the whole map.

00:29:18.770 --> 00:29:22.130
And one thing you can try to
do sense if the terrain is off

00:29:22.130 --> 00:29:22.630
map.

00:29:22.630 --> 00:29:25.338
Again, that would be
 TerrainTile.TerrainType=TerrainType.offMap.

00:29:27.240 --> 00:29:31.400
And you could check that, but
sometimes there'll be like,

00:29:31.400 --> 00:29:32.836
maybe we'll put
neutral mine's all

00:29:32.836 --> 00:29:34.294
the way around the
edge of the map.

00:29:34.294 --> 00:29:35.970
And then you won't
really know if you're

00:29:35.970 --> 00:29:37.386
bugging around the
edge of the map

00:29:37.386 --> 00:29:39.290
because it'll just look
like neutral mines.

00:29:39.290 --> 00:29:43.170
So there is another
thing to worry about it.

00:29:43.170 --> 00:29:47.110
You could turn around
a transient obstacle,

00:29:47.110 --> 00:29:49.530
like an ally, as we
mentioned before.

00:29:49.530 --> 00:29:52.900
There's insufficient
information for a lot of things.

00:29:52.900 --> 00:29:55.270
Like maybe you've got
the perfect a* algorithm

00:29:55.270 --> 00:29:56.940
that's going to find everything.

00:29:56.940 --> 00:29:59.000
That's the best
technical term for it.

00:29:59.000 --> 00:30:01.120
And you're going
to find everything,

00:30:01.120 --> 00:30:03.270
but you don't have
that much information.

00:30:03.270 --> 00:30:05.420
Like you don't know where
the enemy mines are.

00:30:05.420 --> 00:30:06.961
You don't know where
the enemy robots

00:30:06.961 --> 00:30:09.720
are until you get close to them.

00:30:09.720 --> 00:30:12.950
And so that I think that's
fairly well explained.

00:30:12.950 --> 00:30:17.020
We've got everything laid out
on the table here and there.

00:30:17.020 --> 00:30:21.330
I would mention that here's
another use for radio, is not

00:30:21.330 --> 00:30:24.580
every robot can tell that
another robot is stuck.

00:30:24.580 --> 00:30:28.380
So you might consider
radioing information

00:30:28.380 --> 00:30:33.700
about robots that are stuck so
that the other robots, allied

00:30:33.700 --> 00:30:37.790
of course, behind them
can get out of the way.

00:30:37.790 --> 00:30:40.380
And you can make this
playful in your own way

00:30:40.380 --> 00:30:43.550
by coming up with
your own comments

00:30:43.550 --> 00:30:47.460
on what-- anyway, that
made a lot of sense.

00:30:47.460 --> 00:30:49.920
So they can get out of the way.

00:30:49.920 --> 00:30:52.930
So let's consider
the following case.

00:30:52.930 --> 00:30:57.060
You have this radio system which
consists of these integers.

00:30:57.060 --> 00:31:00.720
And you need to be able to
post map locations to integers.

00:31:00.720 --> 00:31:02.080
How are you going to do that?

00:31:02.080 --> 00:31:03.496
Well, I've got a
good idea for you

00:31:03.496 --> 00:31:05.037
if you haven't
thought of it already.

00:31:05.037 --> 00:31:08.980
An integer in Java can go from
something like minus 2 billion

00:31:08.980 --> 00:31:10.770
to 2 billion.

00:31:10.770 --> 00:31:14.210
So here we're radioing integers.

00:31:14.210 --> 00:31:15.470
And it has to be an integer.

00:31:15.470 --> 00:31:17.940
Well, I know a certain
thing about 2 billion.

00:31:17.940 --> 00:31:22.370
2 billion has this many numbers
in it-- 1, 2, 3, 1, 2, 3, 1, 2,

00:31:22.370 --> 00:31:23.280
3-- that's a billion.

00:31:23.280 --> 00:31:24.169
Yeah, I got it.

00:31:24.169 --> 00:31:25.210
I think that's 2 billion.

00:31:25.210 --> 00:31:28.150
I think it has 2 billion
because it's 2 the 32.

00:31:28.150 --> 00:31:29.640
Yeah, something like that.

00:31:29.640 --> 00:31:31.640
Well, I know what
this can contain.

00:31:31.640 --> 00:31:36.200
All I have to do, since
a map location starts--

00:31:36.200 --> 00:31:39.950
it has x and y values
starting at 0, 0

00:31:39.950 --> 00:31:43.720
and going to, at most, 100, 100.

00:31:43.720 --> 00:31:45.970
And something tells me that
the final maps we give out

00:31:45.970 --> 00:31:46.670
won't be that big.

00:31:46.670 --> 00:31:47.450
But maybe they will.

00:31:47.450 --> 00:31:47.991
I don't know.

00:31:47.991 --> 00:31:49.000
They might be.

00:31:49.000 --> 00:31:49.900
Well, look at that.

00:31:49.900 --> 00:31:54.040
0 and 100 only take up three of
these positions in the number.

00:31:54.040 --> 00:31:55.530
I mean, you could
do it in binary

00:31:55.530 --> 00:31:57.890
and encode the information
even more efficiently.

00:31:57.890 --> 00:31:59.760
But this will do just fine.

00:31:59.760 --> 00:32:01.180
So here's a thought.

00:32:01.180 --> 00:32:03.100
Put the round number
in the first three,

00:32:03.100 --> 00:32:06.050
put to the x-coordinate
in the second three,

00:32:06.050 --> 00:32:08.290
and put the y-coordinate
in the third three.

00:32:08.290 --> 00:32:11.300
And now you can tell when
you look at a single integer

00:32:11.300 --> 00:32:12.640
if it is up to date.

00:32:12.640 --> 00:32:20.642
So here, we'll have 2,
roundNum, xval, yval.

00:32:20.642 --> 00:32:22.600
And all you would do for
that is you would say,

00:32:22.600 --> 00:32:26.650
my integer equals round-- it
would be-- let's be explicit.

00:32:26.650 --> 00:32:39.540
Clock.getRoundNum()*1000000+xval--
 it'll be my map location,

00:32:39.540 --> 00:32:46.185
which I'll call m.x*1000+m.y*1.

00:32:46.185 --> 00:32:46.730
There you go.

00:32:46.730 --> 00:32:49.117
And that would encode
everything into my integer.

00:32:49.117 --> 00:32:50.700
And then I could
make another function

00:32:50.700 --> 00:32:53.185
that sort of unpacks
things into a map location.

00:32:53.185 --> 00:32:53.810
Oh my goodness.

00:32:53.810 --> 00:32:54.893
What would that look like?

00:32:54.893 --> 00:32:57.139
Well, it would be something
like public static,

00:32:57.139 --> 00:32:58.930
and it returns a map
location, because that

00:32:58.930 --> 00:33:00.680
would be really useful.

00:33:00.680 --> 00:33:05.040
Public static MapLocation,
we'll say intToMapLocation.

00:33:05.040 --> 00:33:05.595
Yes.

00:33:05.595 --> 00:33:06.720
That will be really useful.

00:33:06.720 --> 00:33:09.410
And it takes an
integer, myInteger.

00:33:09.410 --> 00:33:11.050
Yes.

00:33:11.050 --> 00:33:13.160
I'm coding in Microsoft Word.

00:33:13.160 --> 00:33:14.660
I wonder if everybody
has done that.

00:33:14.660 --> 00:33:17.201
And if you're going to tell me
it's Open Office, that's true.

00:33:17.201 --> 00:33:17.960
That's true.

00:33:17.960 --> 00:33:20.306
I acknowledge that.

00:33:20.306 --> 00:33:20.930
Let's see here.

00:33:20.930 --> 00:33:23.420
So let's get the
other values on out.

00:33:23.420 --> 00:33:28.670
Let's say that our x val, which
is going to be an integer,

00:33:28.670 --> 00:33:35.340
equals myInteger at-- ooh,
what am I going to do here?

00:33:35.340 --> 00:33:41.470
I'm going to say, I'm going
to take modulo 1 billion.

00:33:41.470 --> 00:33:42.581
Is that going to do it?

00:33:42.581 --> 00:33:44.580
I'm going to put spaces
in so that I can see it.

00:33:44.580 --> 00:33:46.329
But I think if you
actually put spaces in,

00:33:46.329 --> 00:33:47.430
it isn't going to work.

00:33:47.430 --> 00:33:47.930
Yes.

00:33:47.930 --> 00:33:49.795
So is that my x val?

00:33:49.795 --> 00:33:50.629
No, that's my y val.

00:33:50.629 --> 00:33:52.211
So I am going to do
this in this order

00:33:52.211 --> 00:33:53.340
because it'll make it easy.

00:33:53.340 --> 00:34:01.310
int xval=myInteger%1-- you
guys got to pay attention.

00:34:01.310 --> 00:34:02.840
This is the 1 billion, isn't it?

00:34:02.840 --> 00:34:04.740
Yeah, I've got to
make it this way.

00:34:04.740 --> 00:34:06.900
Actually, I think they
might be identical.

00:34:06.900 --> 00:34:09.010
Anyway, if I do it-- yeah.

00:34:09.010 --> 00:34:09.741
Uh, no.

00:34:09.741 --> 00:34:10.699
This has to be billion.

00:34:10.699 --> 00:34:12.032
Sorry, that has to be a billion.

00:34:12.032 --> 00:34:13.870
Because if I do
modulo a billion,

00:34:13.870 --> 00:34:16.060
then any numbers that
are over here sort of

00:34:16.060 --> 00:34:17.880
roll off from the 2 billion.

00:34:17.880 --> 00:34:18.940
Yeah, that'll be fine.

00:34:18.940 --> 00:34:22.527
And I'll just subtract from
the millions category--

00:34:22.527 --> 00:34:23.360
would that be 1,000?

00:34:23.360 --> 00:34:24.360
It'll be a million.

00:34:24.360 --> 00:34:26.150
And I'll subtract
off the y value.

00:34:26.150 --> 00:34:27.429
And now I have an x val.

00:34:27.429 --> 00:34:30.170
And finally-- I mean, maybe
the first thing I should do

00:34:30.170 --> 00:34:34.949
is I should check to see if
my very first number, like

00:34:34.949 --> 00:34:36.880
if these very first
three numbers,

00:34:36.880 --> 00:34:40.182
I should check to see
if those are decent.

00:34:40.182 --> 00:34:42.530
I here some whispers,
but I'm sure that they're

00:34:42.530 --> 00:34:44.890
talking about how amazing
this is going to end up being.

00:34:44.890 --> 00:34:46.820
We'll make a new map
location by saying,

00:34:46.820 --> 00:34:52.610
the output map location-- well,
I'll just call it outputLoc--

00:34:52.610 --> 00:34:56.510
MapLocation outputLoc equals--
now this is a constructor--

00:34:56.510 --> 00:35:00.141
new MapLocation-- this is the
same thing we did yesterday--

00:35:00.141 --> 00:35:01.809
(xval,yval).

00:35:01.809 --> 00:35:03.350
And I could have a
check in here that

00:35:03.350 --> 00:35:06.650
verifies that it was set
at the previous roundNum,

00:35:06.650 --> 00:35:08.160
so that it's not out of date.

00:35:08.160 --> 00:35:09.680
That'd be really useful.

00:35:09.680 --> 00:35:12.570
So that's a pretty useful
thing to have right there.

00:35:12.570 --> 00:35:16.950
That's just one of
many byte code tricks.

00:35:16.950 --> 00:35:22.640
So this is going to be packing
a map location into an integer.

00:35:22.640 --> 00:35:23.790
What's another one?

00:35:23.790 --> 00:35:29.250
Let's consider that you have
a whole stockpile of energy

00:35:29.250 --> 00:35:31.290
that your robots are using.

00:35:31.290 --> 00:35:35.150
But early on in the game, you're
wasting a lot of that energy

00:35:35.150 --> 00:35:37.690
because it's just
decaying in your inbox.

00:35:37.690 --> 00:35:39.610
It's just sort of
floating around,

00:35:39.610 --> 00:35:41.250
and then it's going down.

00:35:41.250 --> 00:35:45.230
So why don't you
consider spend byte codes

00:35:45.230 --> 00:35:48.740
when the number of
allied bots is low?

00:35:48.740 --> 00:35:58.030
Or equivalently, when there's
a lot of rc.getTeamPower.

00:35:58.030 --> 00:35:59.310
Question.

00:35:59.310 --> 00:36:01.210
AUDIENCE: For the
20% loss every round,

00:36:01.210 --> 00:36:03.585
is that your total
stockpile of power,

00:36:03.585 --> 00:36:05.970
or is it the total increase?

00:36:05.970 --> 00:36:07.720
PROFESSOR: It will be
the total stockpile.

00:36:07.720 --> 00:36:08.261
That's right.

00:36:08.261 --> 00:36:10.031
AUDIENCE: So [INAUDIBLE]?

00:36:10.031 --> 00:36:11.030
PROFESSOR: That's right.

00:36:11.030 --> 00:36:11.950
You'll lose it.

00:36:11.950 --> 00:36:15.060
So that's-- what's
the common saying?

00:36:15.060 --> 00:36:16.360
It's use it or lose it.

00:36:16.360 --> 00:36:17.380
Yeah.

00:36:17.380 --> 00:36:20.080
So if you're using
it, you don't lose it.

00:36:20.080 --> 00:36:23.170
I guess that was not
necessary to explain.

00:36:23.170 --> 00:36:27.630
I made a program here that
may be useful on this effect.

00:36:27.630 --> 00:36:29.020
I call it stockpiling.

00:36:29.020 --> 00:36:30.560
And I made it in
Mathematica just

00:36:30.560 --> 00:36:32.120
because it's nice and visual.

00:36:32.120 --> 00:36:36.310
So here's an example of
stockpiling resources.

00:36:36.310 --> 00:36:41.160
Let's go ahead and we'll
simulate 400 rounds.

00:36:41.160 --> 00:36:44.570
We'll simulate the case where
the decay multiplier is 0.8.

00:36:44.570 --> 00:36:49.096
And we'll start with zero
bots, using zero byte codes.

00:36:49.096 --> 00:36:50.470
So you can see
here, this is what

00:36:50.470 --> 00:36:53.894
you should expect your
number of bots to be.

00:36:53.894 --> 00:36:55.560
You're building them
constantly, and you

00:36:55.560 --> 00:36:58.190
finish building them
around turn 300.

00:36:58.190 --> 00:37:00.470
And you hit a
maximum of 40 bots.

00:37:00.470 --> 00:37:02.630
If you're using
more like-- let's

00:37:02.630 --> 00:37:05.680
do a little bit more realistic--
you're using 2,000 byte codes,

00:37:05.680 --> 00:37:09.070
well now, you're
maxing out at 34 bots.

00:37:09.070 --> 00:37:11.230
And you can see here that
you quickly decay upward

00:37:11.230 --> 00:37:13.420
to your maximum
near 200, and then

00:37:13.420 --> 00:37:17.090
you only go down bit by bit
as you build more robots.

00:37:17.090 --> 00:37:19.760
You may, for example,
have-- I mean,

00:37:19.760 --> 00:37:21.450
we can look at
more examples here.

00:37:21.450 --> 00:37:23.660
And I'll probably talk about
this more on a strategy

00:37:23.660 --> 00:37:26.330
lecture, but let's say that
you got the fusion upgrade, so

00:37:26.330 --> 00:37:29.750
that the decay multiplier
went from 0.8 to 0.99.

00:37:29.750 --> 00:37:31.430
So now we've got 0.99 there.

00:37:31.430 --> 00:37:34.620
Well, now you can see that
you got up to 44 robots

00:37:34.620 --> 00:37:36.930
because the decay
was much slower.

00:37:36.930 --> 00:37:38.500
So you got up to a
really big number

00:37:38.500 --> 00:37:41.020
as you were massing
up these robots.

00:37:41.020 --> 00:37:45.330
And so for about
70 rounds, you were

00:37:45.330 --> 00:37:49.650
able to maintain an increase
of four robots over the enemy.

00:37:49.650 --> 00:37:52.330
Not a huge benefit,
if you ask me.

00:37:52.330 --> 00:37:54.000
Now, if you
stockpile for longer,

00:37:54.000 --> 00:37:55.700
let's see what effect
that would have.

00:37:55.700 --> 00:37:57.620
I guess this is a
bit of a tangent,

00:37:57.620 --> 00:38:00.190
but we just did tangent
bug, so it's relevant.

00:38:00.190 --> 00:38:01.725
Ba-dum!

00:38:01.725 --> 00:38:02.350
Let's see here.

00:38:02.350 --> 00:38:05.032
So where's the-- oh, yeah.

00:38:05.032 --> 00:38:05.740
Number of rounds.

00:38:05.740 --> 00:38:06.656
Round is greater than.

00:38:06.656 --> 00:38:09.030
So we're only going to start
building robots at round,

00:38:09.030 --> 00:38:11.214
say 200.

00:38:11.214 --> 00:38:12.880
Now we can't really
see what's going on.

00:38:12.880 --> 00:38:15.088
Let's increase the number
of rounds in the simulation

00:38:15.088 --> 00:38:16.360
to 1,000.

00:38:16.360 --> 00:38:20.720
So now we can see here
that we are maintaining--

00:38:20.720 --> 00:38:24.250
we're having five extra
robots for slightly longer.

00:38:24.250 --> 00:38:25.240
It's not that great.

00:38:25.240 --> 00:38:26.710
It's just not that great.

00:38:26.710 --> 00:38:28.380
Let's wait a little
bit longer before we

00:38:28.380 --> 00:38:30.140
start building so we
can try to stockpile.

00:38:30.140 --> 00:38:30.290
OK.

00:38:30.290 --> 00:38:32.010
We've stockpiled as
much as possible.

00:38:32.010 --> 00:38:34.185
We've still only got
five extra robots.

00:38:34.185 --> 00:38:36.240
Oh, actually it's more
than five extra robots.

00:38:36.240 --> 00:38:38.470
Let's go down to zero
so we can make sure.

00:38:38.470 --> 00:38:40.800
Yeah, it's 12 extra
robots on top of 40,

00:38:40.800 --> 00:38:46.200
so it's 12 over 40
times 100 is 30% more.

00:38:46.200 --> 00:38:50.260
30% bonus, but you did it
at the price of stockpiling

00:38:50.260 --> 00:38:51.310
for 500 turns.

00:38:51.310 --> 00:38:54.170
And by then, you'll
certainly be dead.

00:38:54.170 --> 00:38:56.370
That's a quick look
at stockpiling.

00:38:56.370 --> 00:38:57.232
Question.

00:38:57.232 --> 00:38:58.618
AUDIENCE: Is power used
for anything except for

00:38:58.618 --> 00:38:59.117
[INAUDIBLE]?

00:38:59.117 --> 00:39:01.530
PROFESSOR: Yes, power is
also used for capturing.

00:39:01.530 --> 00:39:04.030
In my handy dandy unit
spec sheet-- gosh,

00:39:04.030 --> 00:39:05.950
I did use that term.

00:39:05.950 --> 00:39:07.550
Handy dandy.

00:39:07.550 --> 00:39:16.451
In the spec sheet, which I put
over here on this place, which

00:39:16.451 --> 00:39:17.700
you can get it on the website.

00:39:17.700 --> 00:39:19.510
I could be going to the website.

00:39:19.510 --> 00:39:21.950
I'm sure all of you
have been there by now.

00:39:21.950 --> 00:39:24.710
And if you haven't,
then you're missing out.

00:39:24.710 --> 00:39:26.560
This useful battle
code data sheet,

00:39:26.560 --> 00:39:29.650
which updates from time to time,
indicates what takes power.

00:39:29.650 --> 00:39:31.930
So if I just do Control-F
and the word power,

00:39:31.930 --> 00:39:34.510
we can see here,
the headquarters

00:39:34.510 --> 00:39:35.370
generates 40 power.

00:39:35.370 --> 00:39:36.340
OK, we know that.

00:39:36.340 --> 00:39:38.660
Soldiers upkeep to one
to two power per turn.

00:39:38.660 --> 00:39:39.550
OK.

00:39:39.550 --> 00:39:41.010
Attack power, that's irrelevant.

00:39:41.010 --> 00:39:42.390
The generator
generates 10 power.

00:39:42.390 --> 00:39:43.920
OK, I see that.

00:39:43.920 --> 00:39:46.060
And then it should
also say somewhere

00:39:46.060 --> 00:39:51.290
that you capture encampments at
a cost of 20, plus this number,

00:39:51.290 --> 00:39:52.230
of units of power.

00:39:52.230 --> 00:39:56.790
So if you own one
encampment and you

00:39:56.790 --> 00:39:59.490
are capturing one encampment,
then the next encampment

00:39:59.490 --> 00:40:02.400
you go to capture
will cost three times

00:40:02.400 --> 00:40:05.415
the ordinary encampment
cost, which is right now 20.

00:40:05.415 --> 00:40:06.290
So there you have it.

00:40:06.290 --> 00:40:08.037
That's another use
for your power.

00:40:08.037 --> 00:40:10.620
And it's certainly interesting
to consider that you might need

00:40:10.620 --> 00:40:13.270
to call suicide on some of
your robots so that you'll get

00:40:13.270 --> 00:40:16.050
enough money to buy some
of those encampments. .

00:40:16.050 --> 00:40:17.410
Because that's a one time cost.

00:40:17.410 --> 00:40:20.780
So you might suicide some
robots, build an encampment,

00:40:20.780 --> 00:40:22.480
and then build those
robots back again.

00:40:22.480 --> 00:40:25.067
Because it is not a
continuing upkeep.

00:40:25.067 --> 00:40:26.650
Although I do believe
that encampments

00:40:26.650 --> 00:40:29.190
count as robots to
the extent that they

00:40:29.190 --> 00:40:31.910
do require upkeep themselves.

00:40:31.910 --> 00:40:35.750
Let's go back and see how
much we have time for.

00:40:35.750 --> 00:40:37.500
I'm sure everybody's
mouth is already

00:40:37.500 --> 00:40:41.300
watering as much as mine
is about the chicken curry,

00:40:41.300 --> 00:40:43.060
among other things.

00:40:43.060 --> 00:40:45.990
I was over here putting
down byte code tricks,

00:40:45.990 --> 00:40:47.500
and I got sort of sidetracked.

00:40:47.500 --> 00:40:49.890
Let's talk about more
byte code tricks.

00:40:49.890 --> 00:40:55.820
So let's think about how
it might be cheaper--

00:40:55.820 --> 00:41:02.470
oh, my goodness-- to
broadcast an enemy's location

00:41:02.470 --> 00:41:04.670
than to sense it.

00:41:04.670 --> 00:41:05.900
Let's answer that question.

00:41:05.900 --> 00:41:09.370
The method cost for
read broadcast is one.

00:41:09.370 --> 00:41:16.310
And for making a
broadcast is also one.

00:41:16.310 --> 00:41:17.910
Now, that's pretty
small compared

00:41:17.910 --> 00:41:20.630
to sensing an enemy
location, where,

00:41:20.630 --> 00:41:22.810
let's see, sensing
an enemy location.

00:41:22.810 --> 00:41:24.920
Sensing an object is 25.

00:41:24.920 --> 00:41:27.580
Sensing a bunch of
game objects is 100.

00:41:27.580 --> 00:41:31.080
I mean, 1 is less
than 25 oftentimes.

00:41:31.080 --> 00:41:35.630
So let's check if there any
other costs associated with it

00:41:35.630 --> 00:41:40.030
by going into the specs
here under constant values.

00:41:40.030 --> 00:41:42.540
So here in the Java
Docs, we can see

00:41:42.540 --> 00:41:45.620
that there is also a
broadcast read cost.

00:41:45.620 --> 00:41:48.580
So that also answers
this gentleman's question

00:41:48.580 --> 00:41:50.730
that there's also
another cost in power.

00:41:50.730 --> 00:41:54.830
This read cost is a power cost
for reading and broadcasting.

00:41:54.830 --> 00:41:57.090
So this is going
to use 0.05 power.

00:41:57.090 --> 00:42:01.080
It's relatively small compared
to your one upkeep [INAUDIBLE]

00:42:01.080 --> 00:42:01.840
positions.

00:42:01.840 --> 00:42:05.890
Well, then all of a sudden-- or
read 20 positions would be 0.2,

00:42:05.890 --> 00:42:08.860
and that would be equivalent
to using 2,000 byte code.

00:42:08.860 --> 00:42:11.620
So that starts to
say that that's

00:42:11.620 --> 00:42:14.500
a pretty high cost for
reading in terms of byte code.

00:42:14.500 --> 00:42:17.210
Which suggests that if you
want to send things on messages

00:42:17.210 --> 00:42:20.690
and be byte code efficient, that
it makes the most sense to send

00:42:20.690 --> 00:42:22.610
the results of a
large computation

00:42:22.610 --> 00:42:25.280
rather than the base data
on which that computation is

00:42:25.280 --> 00:42:27.390
performed.

00:42:27.390 --> 00:42:28.430
Let's see here.

00:42:28.430 --> 00:42:31.710
It's already 5:49, and
I haven't showed you

00:42:31.710 --> 00:42:34.960
as many awesome matches
as I was expecting to.

00:42:34.960 --> 00:42:38.060
I'll blast through a few
more byte code tricks

00:42:38.060 --> 00:42:39.410
and then we'll get right there.

00:42:39.410 --> 00:42:43.670
Make sure to check the byte
code cost of your functions.

00:42:43.670 --> 00:42:48.840
I find it very helpful
to put in my code

00:42:48.840 --> 00:42:52.169
a little block comment that
says what the byte code cost is.

00:42:52.169 --> 00:42:53.960
And I'll put it right
next to the function,

00:42:53.960 --> 00:42:56.640
so I can say, all right, that's
the price of that function.

00:42:56.640 --> 00:42:57.990
And how many times can I use it?

00:42:57.990 --> 00:42:58.880
Do I want to use it?

00:42:58.880 --> 00:42:59.930
Is it worthwhile?

00:42:59.930 --> 00:43:01.320
Am I improving it?

00:43:01.320 --> 00:43:03.220
One way to do it is
to run the match with

00:43:03.220 --> 00:43:06.050
and without that function
installed on your robot,

00:43:06.050 --> 00:43:07.429
and just do the math yourself.

00:43:07.429 --> 00:43:08.720
But another way is very simple.

00:43:08.720 --> 00:43:10.802
You can just use
Clock.getBytecodes,

00:43:10.802 --> 00:43:11.760
or something like that.

00:43:11.760 --> 00:43:12.920
There's a function there.

00:43:12.920 --> 00:43:15.680
And you can just do it before
and after a certain operation

00:43:15.680 --> 00:43:17.380
and then check it out.

00:43:17.380 --> 00:43:22.290
You should also try computing
only relevant directions.

00:43:22.290 --> 00:43:25.590
Later on I'm going to show
you a little example of how

00:43:25.590 --> 00:43:31.170
you can write code where a robot
is doing something in two ways,

00:43:31.170 --> 00:43:33.590
and it's trying to find
out who's adjacent.

00:43:33.590 --> 00:43:36.430
So it's like, all right,
I can move forward

00:43:36.430 --> 00:43:38.480
and that would put me
next to this many enemies

00:43:38.480 --> 00:43:39.590
and this many allies.

00:43:39.590 --> 00:43:41.230
I could move to the
left and it would

00:43:41.230 --> 00:43:43.920
be this many enemies
and this many allies.

00:43:43.920 --> 00:43:46.690
You kind of want to be next to
a lot of allies and just one

00:43:46.690 --> 00:43:48.500
enemy so you can gang up on him.

00:43:48.500 --> 00:43:53.220
That was the whole idea of being
intelligent about your stance

00:43:53.220 --> 00:43:53.990
and where you are.

00:43:53.990 --> 00:43:55.670
Because you want
gang up on the enemy.

00:43:55.670 --> 00:43:58.100
And that's a very
local decision when

00:43:58.100 --> 00:44:00.250
it comes right down
to it sometimes.

00:44:00.250 --> 00:44:03.420
But if you can't move
in a certain direction,

00:44:03.420 --> 00:44:05.350
don't compute anything
about that direction

00:44:05.350 --> 00:44:07.130
because you're not
going there anyway.

00:44:07.130 --> 00:44:07.860
That's a thought.

00:44:07.860 --> 00:44:10.330
I mean, of course, you may
compute it anyway, and then

00:44:10.330 --> 00:44:14.260
try to move in that direction,
and move in the next closest.

00:44:14.260 --> 00:44:15.490
But you could consider that.

00:44:15.490 --> 00:44:18.880
And I'll show a little bit.

00:44:18.880 --> 00:44:25.200
So you could consider spending
things only when it's low.

00:44:25.200 --> 00:44:29.980
Cheaper to broadcast the
enemy using that, and so on.

00:44:29.980 --> 00:44:33.350
I have another useful thing
when we're looking at pathing.

00:44:33.350 --> 00:44:36.820
And I'll show it
by running a match.

00:44:36.820 --> 00:44:39.170
I'll run the match
of Cold War, which

00:44:39.170 --> 00:44:41.580
is my player, versus Hard Bot.

00:44:41.580 --> 00:44:44.570
I have the Cold War
player, does something

00:44:44.570 --> 00:44:47.820
that's similar to the
realistic Cold War.

00:44:47.820 --> 00:44:49.739
But I'll do it on
slightly smaller maps

00:44:49.739 --> 00:44:51.030
so you can see what's going on.

00:44:51.030 --> 00:44:51.920
Let's see here.

00:44:51.920 --> 00:44:53.180
Let's go on tiny.

00:44:53.180 --> 00:44:55.350
So I made these maps
that are free of mines

00:44:55.350 --> 00:44:57.570
just so I don't have
to worry about it.

00:44:57.570 --> 00:45:00.300
So here we've got
Cold War in blue.

00:45:00.300 --> 00:45:03.110
And his goal is
to nuke the enemy.

00:45:03.110 --> 00:45:07.200
And what he does is he
paths around over here

00:45:07.200 --> 00:45:10.410
around the med bay to
defend against the enemy.

00:45:10.410 --> 00:45:13.000
And the enemy will be just
building these shields

00:45:13.000 --> 00:45:14.140
and then attacking.

00:45:14.140 --> 00:45:17.290
And they attack my med
bays, but they get nowhere.

00:45:17.290 --> 00:45:19.140
I don't think I eve
lose a single guy.

00:45:19.140 --> 00:45:21.340
So the Cold War
is going to finish

00:45:21.340 --> 00:45:23.080
massing up a bunch of troops.

00:45:23.080 --> 00:45:25.504
And when he's done, he's going
to build a nuclear missile.

00:45:25.504 --> 00:45:27.170
There you can see the
projects going on.

00:45:27.170 --> 00:45:28.450
Hello, and thank you.

00:45:28.450 --> 00:45:28.950
Yeah.

00:45:28.950 --> 00:45:32.320
And so he's building
along the nuclear missile.

00:45:32.320 --> 00:45:37.006
And when he's done, it will
be curtains for the other guy.

00:45:37.006 --> 00:45:37.880
Curtains, as it were.

00:45:37.880 --> 00:45:39.300
We will bury them.

00:45:39.300 --> 00:45:42.000
But you might ask,
I can't really

00:45:42.000 --> 00:45:45.210
tell if these guys can
see those guys or what.

00:45:45.210 --> 00:45:47.170
You can push the letter
A, which gives you

00:45:47.170 --> 00:45:49.040
site range and attack range.

00:45:49.040 --> 00:45:51.720
So that's a pretty useful
thing to have there.

00:45:51.720 --> 00:45:53.560
So that's A in
the client viewer.

00:45:53.560 --> 00:45:55.270
There's also another
list of commands,

00:45:55.270 --> 00:45:58.100
like B will turn off
the broadcast range.

00:45:58.100 --> 00:46:00.560
Let's look at some more options.

00:46:00.560 --> 00:46:03.630
I would have liked
to go into a way

00:46:03.630 --> 00:46:06.580
to store-- here's
another byte code trick.

00:46:06.580 --> 00:46:13.020
Store the locations of other
units in an integer array,

00:46:13.020 --> 00:46:17.500
so that instead of having to
loop through all enemy bots

00:46:17.500 --> 00:46:19.730
and check if they're
adjacent, for example,

00:46:19.730 --> 00:46:21.730
you can just store their
locations into an array

00:46:21.730 --> 00:46:23.063
so that you know where they are.

00:46:23.063 --> 00:46:24.832
Then you can just
index into that array.

00:46:24.832 --> 00:46:26.790
And you say, all right,
this is where they are.

00:46:26.790 --> 00:46:30.090
So you're indexing into
a two dimensional array.

00:46:30.090 --> 00:46:32.590
And I can talk to you
about how to set those up

00:46:32.590 --> 00:46:35.160
at another time,
but the result is

00:46:35.160 --> 00:46:38.050
that you can perform
significantly better

00:46:38.050 --> 00:46:40.120
than you otherwise would.

00:46:40.120 --> 00:46:42.090
So here, Player 3 kind of works.

00:46:42.090 --> 00:46:46.820
I'm going to show it where doing
this calculation, where you

00:46:46.820 --> 00:46:52.850
find the number of adjacent
units can be pretty helpful.

00:46:52.850 --> 00:46:55.230
So here's what I'm showing.

00:46:55.230 --> 00:46:59.690
On the upper left and the
bottom right are the same robot.

00:46:59.690 --> 00:47:02.220
But what I've done is I've
done, if your team is A,

00:47:02.220 --> 00:47:03.580
then run the code this way.

00:47:03.580 --> 00:47:05.710
If your team is B, then
run the code the other way.

00:47:05.710 --> 00:47:07.230
And this is demonstration.

00:47:07.230 --> 00:47:08.770
So let's back up just a bit.

00:47:08.770 --> 00:47:10.460
I'll zoom in as
much as possible,

00:47:10.460 --> 00:47:12.310
but that's as good
as it's going to get.

00:47:12.310 --> 00:47:14.440
So let's go until
they're touching.

00:47:14.440 --> 00:47:17.250
So this guy is computing
adjacent robots,

00:47:17.250 --> 00:47:19.470
and he's printing out the
number of adjacent robots

00:47:19.470 --> 00:47:22.067
that are allied.

00:47:22.067 --> 00:47:23.650
In fact, I think
this might be-- yeah,

00:47:23.650 --> 00:47:25.240
this is the number of allies.

00:47:25.240 --> 00:47:27.400
Starting with north
and going around .

00:47:27.400 --> 00:47:30.270
And this guy is printing
out different numbers

00:47:30.270 --> 00:47:31.350
that are heuristics.

00:47:31.350 --> 00:47:35.250
So for each of the
positions around him,

00:47:35.250 --> 00:47:37.170
he is computing how
many allies there are

00:47:37.170 --> 00:47:38.770
and how many enemies there are.

00:47:38.770 --> 00:47:42.550
And he's going to try to
move in the direction that

00:47:42.550 --> 00:47:43.790
has the most enemies.

00:47:43.790 --> 00:47:47.010
So he'll either stay put if his
current location has the best

00:47:47.010 --> 00:47:50.660
heuristic value, or he'll
go toward the best position.

00:47:50.660 --> 00:47:53.220
Like if he's going to
try to flank the enemy,

00:47:53.220 --> 00:47:56.780
or get to a position where
he'll gang up on the enemy.

00:47:56.780 --> 00:47:58.630
And you can see here
that the red player

00:47:58.630 --> 00:48:01.590
is able to make significant
advances against what

00:48:01.590 --> 00:48:03.260
was previously Awesome Bot.

00:48:03.260 --> 00:48:06.490
So you can see, I'll show
again, it's very hard to tell.

00:48:06.490 --> 00:48:08.630
Because it's a subtle
thing that takes

00:48:08.630 --> 00:48:12.950
place where it's trying
to do an optimization

00:48:12.950 --> 00:48:14.310
at a very local scale.

00:48:14.310 --> 00:48:18.500
So you're taking good decisions
on a robot by robot basis

00:48:18.500 --> 00:48:21.070
and having them translate
into good decisions

00:48:21.070 --> 00:48:23.930
on a global basis
for the whole team.

00:48:23.930 --> 00:48:25.760
It was a bit of a
close race, though.

00:48:25.760 --> 00:48:28.450
So let's consider
making global decisions.

00:48:28.450 --> 00:48:31.090
Here's another
pathing idea where

00:48:31.090 --> 00:48:33.950
you would be using the
local data from each robot

00:48:33.950 --> 00:48:37.640
to decide that you
might want to form

00:48:37.640 --> 00:48:39.620
a concave around the enemy.

00:48:39.620 --> 00:48:41.890
So let's do that example.

00:48:41.890 --> 00:48:45.510
And then I'll end with
one final example.

00:48:45.510 --> 00:48:46.950
So this one is a concave.

00:48:46.950 --> 00:48:49.440
I have them just build up
robots until round 200,

00:48:49.440 --> 00:48:50.700
so I'll skip until there.

00:48:50.700 --> 00:48:52.440
And you'll see
that the blue team

00:48:52.440 --> 00:48:54.992
is going to sort of back away.

00:48:54.992 --> 00:48:55.950
Here I'm going forward.

00:48:55.950 --> 00:48:57.324
He's backing away
from the enemy.

00:48:57.324 --> 00:49:00.070
And then when the moment
is right, he comes in.

00:49:00.070 --> 00:49:01.430
Boom.

00:49:01.430 --> 00:49:02.930
He comes in and
surrounds the enemy.

00:49:02.930 --> 00:49:05.260
And they started with
the same number of units,

00:49:05.260 --> 00:49:06.790
and look at how
many he has left.

00:49:06.790 --> 00:49:09.270
Look at the difference
that that makes.

00:49:09.270 --> 00:49:12.790
So you should really consider
having your robots think

00:49:12.790 --> 00:49:16.300
about what's close to them,
nearby, and path with respect

00:49:16.300 --> 00:49:16.910
to that.

00:49:16.910 --> 00:49:20.890
I know it's not exactly
a* or d* or whatever,

00:49:20.890 --> 00:49:23.752
but it's something
that's worth doing.

00:49:23.752 --> 00:49:25.210
At this point, the
other guy really

00:49:25.210 --> 00:49:27.312
can't return from that problem.

00:49:27.312 --> 00:49:28.770
I'm just going to
show you one more

00:49:28.770 --> 00:49:31.760
example of how things
can get interesting.

00:49:31.760 --> 00:49:34.310
I've changed the constant
values all around a little bit,

00:49:34.310 --> 00:49:37.920
just to show how things would
look if both players were

00:49:37.920 --> 00:49:39.920
the player that tries to
avoid the other player.

00:49:39.920 --> 00:49:41.545
Now of course, when
you write your own,

00:49:41.545 --> 00:49:44.500
you write it in your own way
and it will behave in that way.

00:49:44.500 --> 00:49:46.810
So it won't necessarily
look like this.

00:49:46.810 --> 00:49:49.444
And there are things about this
that are just downright stupid.

00:49:49.444 --> 00:49:50.860
But you're going
to see it happen,

00:49:50.860 --> 00:49:54.250
and I believe it will be as
fun for you is it was for me.

00:49:54.250 --> 00:49:55.760
So here we're on round 200.

00:49:55.760 --> 00:49:59.370
I wish I could slow this down,
so I'll just click forward.

00:49:59.370 --> 00:50:01.210
You see they're both
avoiding one another.

00:50:01.210 --> 00:50:04.140
And just there, the
whole enemy team

00:50:04.140 --> 00:50:05.710
was backing away from one guy.

00:50:05.710 --> 00:50:06.210
[LAUGHTER]

00:50:06.210 --> 00:50:07.860
PROFESSOR: Why?

00:50:07.860 --> 00:50:09.840
That guy was moving
toward the enemy

00:50:09.840 --> 00:50:11.990
I think because he
doesn't see them.

00:50:11.990 --> 00:50:14.180
They move first
and then he moved.

00:50:14.180 --> 00:50:15.315
So he can't even see them.

00:50:15.315 --> 00:50:16.690
He doesn't think
he's that close,

00:50:16.690 --> 00:50:17.940
but they think they're close.

00:50:17.940 --> 00:50:21.289
Because this guy is Robot 138,
and this guy is Robot 139.

00:50:21.289 --> 00:50:22.080
Can you believe it?

00:50:22.080 --> 00:50:23.080
They're that close.

00:50:23.080 --> 00:50:23.900
Oh, my goodness.

00:50:23.900 --> 00:50:25.835
So they're going to
run away from one guy.

00:50:25.835 --> 00:50:27.460
Meanwhile, these guys
are running away,

00:50:27.460 --> 00:50:29.267
but they're also sort
of edging that way.

00:50:29.267 --> 00:50:31.100
Because they figure
that's where the enemies

00:50:31.100 --> 00:50:32.680
are because it's the
enemy headquarters.

00:50:32.680 --> 00:50:33.800
These guys are running away.

00:50:33.800 --> 00:50:35.300
And there's sort
of self-segregating

00:50:35.300 --> 00:50:37.000
into these separate packs.

00:50:37.000 --> 00:50:39.470
I don't think a single
bloodshed has been spawned.

00:50:39.470 --> 00:50:41.610
That was the right
way of putting it.

00:50:41.610 --> 00:50:43.510
And they're like wrapping
around one another.

00:50:43.510 --> 00:50:45.176
They're going to trade
sides of the map.

00:50:45.176 --> 00:50:47.487
This is absolutely bonkers.

00:50:47.487 --> 00:50:49.695
So you can see here that
the red is pretty much going

00:50:49.695 --> 00:50:51.028
to abandon his own headquarters.

00:50:51.028 --> 00:50:52.530
Blue is going to abandon his.

00:50:52.530 --> 00:50:56.085
Because they just-- it
got smelly, tiresome.

00:50:56.085 --> 00:50:57.710
They want something
new in their lives.

00:50:57.710 --> 00:51:00.000
And when we continue on
to the end of the match,

00:51:00.000 --> 00:51:02.040
it's just a question
of which one

00:51:02.040 --> 00:51:05.120
is going to be able to
deal the damage sooner.

00:51:05.120 --> 00:51:09.430
Like this guy is saving himself
on the basis of producing units

00:51:09.430 --> 00:51:10.420
bit by bit.

00:51:10.420 --> 00:51:12.950
He's like, oh, if I stop
building units for one second,

00:51:12.950 --> 00:51:13.650
I am dead.

00:51:13.650 --> 00:51:14.606
I am totally gone.

00:51:14.606 --> 00:51:15.105
[LAUGHTER]

00:51:15.105 --> 00:51:16.130
PROFESSOR: Keep building units.

00:51:16.130 --> 00:51:16.890
Wait, no.

00:51:16.890 --> 00:51:18.720
These guys are eating
up all the resources,

00:51:18.720 --> 00:51:22.080
and these are dying because
of the end of the round.

00:51:22.080 --> 00:51:23.780
That is, they don't
have enough power.

00:51:23.780 --> 00:51:25.450
No, please don't
eat all my units.

00:51:25.450 --> 00:51:26.700
Please don't eat my resources.

00:51:26.700 --> 00:51:28.270
You guys should suicide.

00:51:28.270 --> 00:51:29.330
Protect the headquarters.

00:51:29.330 --> 00:51:30.490
You're doing it wrong.

00:51:30.490 --> 00:51:32.220
I swear, you're doing it wrong.

00:51:32.220 --> 00:51:33.395
No, no, no.

00:51:33.395 --> 00:51:35.270
You've got it all, but
now we're killing his.

00:51:35.270 --> 00:51:37.850
And we're doing a lot, but oh,
we've taken a lot of damage.

00:51:37.850 --> 00:51:39.270
Ahh, and then it's over.

00:51:39.270 --> 00:51:40.355
And so there you have it.

00:51:40.355 --> 00:51:42.980
A little bit of exciting stuff
happening with direction.

00:51:42.980 --> 00:51:44.050
Thank you for coming.

00:51:44.050 --> 00:51:47.680
But let me say that
one of these dishes,

00:51:47.680 --> 00:51:50.010
I believe it's the
redder looking one, yeah,

00:51:50.010 --> 00:51:53.540
the one in the middle, chicken
vindaloo, this time is spicy.

00:51:53.540 --> 00:51:54.320
All right?

00:51:54.320 --> 00:51:56.780
So beware that one.

00:51:56.780 --> 00:51:58.880
Don't take too much of it,
because these guys know

00:51:58.880 --> 00:52:00.338
what they mean when
they say spicy.

00:52:00.338 --> 00:52:02.230
Thank you very much.

