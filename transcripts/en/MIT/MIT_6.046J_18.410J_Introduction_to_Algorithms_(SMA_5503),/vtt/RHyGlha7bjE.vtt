WEBVTT
Kind: captions
Language: en

00:00:08.000 --> 00:00:14.000
Good morning.
Today we're going to talk about

00:00:14.000 --> 00:00:18.000
augmenting data structures.

00:00:27.000 --> 00:00:33.000
And this is a --
Normally, rather than designing

00:00:33.000 --> 00:00:37.000
data structures from scratch,
you tend to take existing data

00:00:37.000 --> 00:00:40.000
structures and build your
functionality into them.

00:00:40.000 --> 00:00:44.000
And that is a process we call
data-structure augmentation.

00:00:44.000 --> 00:00:48.000
And this also today marks sort
of the start of the design phase

00:00:48.000 --> 00:00:51.000
of the class.
We spent a lot of time doing

00:00:51.000 --> 00:00:54.000
analysis up to this point.
And now we're still going to

00:00:54.000 --> 00:00:58.000
learn some new analytical
techniques.

00:00:58.000 --> 00:01:01.000
But we're going to start
turning our focus more toward

00:01:01.000 --> 00:01:05.000
how is it that you design
efficient data structures,

00:01:05.000 --> 00:01:08.000
efficient algorithms for
various problems?

00:01:08.000 --> 00:01:11.000
So this is a good example of
the design phase.

00:01:11.000 --> 00:01:14.000
It is a really good idea,
at this point,

00:01:14.000 --> 00:01:18.000
if you have not done so,
to review the textbook Appendix

00:01:18.000 --> 00:01:20.000
B.
You should take that as

00:01:20.000 --> 00:01:24.000
additional reading to make sure
that you are familiar,

00:01:24.000 --> 00:01:29.000
because over the next few weeks
we're going to hit almost every

00:01:29.000 --> 00:01:33.000
topic in Appendix B.
It is going to be brought to

00:01:33.000 --> 00:01:37.000
bear on the subjects that we're
talking about.

00:01:37.000 --> 00:01:41.000
If you're going to go scramble
to learn that while you're also

00:01:41.000 --> 00:01:45.000
trying to learn the material,
it will be more onerous than if

00:01:45.000 --> 00:01:48.000
you just simply review the
material now.

00:01:48.000 --> 00:01:52.000
We're going to start with an
illustration of the problem of

00:01:52.000 --> 00:01:55.000
dynamic order statistics.

00:02:00.000 --> 00:02:03.000
We are familiar with finding
things like the median or the

00:02:03.000 --> 00:02:08.000
kth order statistic or whatever.
Now we want to do the same

00:02:08.000 --> 00:02:11.000
thing but we want to do it with
a dynamic set.

00:02:11.000 --> 00:02:14.000
Rather than being given all the
data upfront,

00:02:14.000 --> 00:02:18.000
we're going to have a set.
And then at some point somebody

00:02:18.000 --> 00:02:21.000
is going to be doing typically
insert and delete.

00:02:21.000 --> 00:02:24.000
And at some point somebody is
going to say OK,

00:02:24.000 --> 00:02:30.000
select for me the ith largest
guy or the ith smallest guy --

00:02:41.000 --> 00:02:58.000
-- in the dynamic set.
Or, something like OS-Rank of

00:02:58.000 --> 00:03:05.000
x.
The rank of x in the sorted

00:03:05.000 --> 00:03:09.000
order of the set.

00:03:14.000 --> 00:03:16.000
So either I want to just say,
for example,

00:03:16.000 --> 00:03:19.000
if I gave n over 2,
if I had n elements in the set

00:03:19.000 --> 00:03:22.000
and I said n over 2,
I am asking for the median.

00:03:22.000 --> 00:03:25.000
I could be asking for the mean.
I could be asking for quartile.

00:03:25.000 --> 00:03:29.000
Here I take an element and say,
OK, so where does that element

00:03:29.000 --> 00:03:33.000
fall among all of the other
elements in the set?

00:03:33.000 --> 00:03:37.000
And, in addition,
these are dynamic sets so I

00:03:37.000 --> 00:03:45.000
want to be able to do insert and
delete, I want to be able to add

00:03:45.000 --> 00:03:50.000
and remove elements.
The solution we are going to

00:03:50.000 --> 00:03:56.000
look at for this one,
the basic idea is to keep the

00:03:56.000 --> 00:04:03.000
sizes of subtrees in the nodes
of a red-black tree.

00:04:08.000 --> 00:04:12.000
Let me draw a picture as an
example.

00:04:30.000 --> 00:04:32.000
In this tree --

00:04:37.000 --> 00:04:39.000
I didn't draw the NILs for
this.

00:04:39.000 --> 00:04:44.000
I am going to keep two values.
I am going to keep the key.

00:04:44.000 --> 00:04:48.000
And so for the keys,
what I will do is just use

00:04:48.000 --> 00:04:51.000
letters of the alphabet.

00:05:06.000 --> 00:05:11.000
And this is a red-black tree.
Just for practice,

00:05:11.000 --> 00:05:16.000
how can I label this tree so
it's a red-black tree?

00:05:16.000 --> 00:05:21.000
I haven't shown the NILs.
Remember the NILs are all

00:05:21.000 --> 00:05:24.000
black.
How can I label this,

00:05:24.000 --> 00:05:29.000
red and black?
Make sure it is a red-black

00:05:29.000 --> 00:05:33.000
tree.
Not every tree can be labeled

00:05:33.000 --> 00:05:36.000
as a red-black tree,
right?

00:05:36.000 --> 00:05:42.000
This is good practice because
this sort of thing shows up on

00:05:42.000 --> 00:05:45.000
quizzes.
Make F red, good,

00:05:45.000 --> 00:05:51.000
and everything else black,
that is certainly a solution.

00:05:51.000 --> 00:05:57.000
Because then that basically
brings the level of this guy up

00:05:57.000 --> 00:06:01.000
to here.
Actually, I had a more

00:06:01.000 --> 00:06:06.000
complicated one because it
seemed like more fun.

00:06:06.000 --> 00:06:12.000
What I did was I made this guy
black and then these two guys

00:06:12.000 --> 00:06:16.000
red and black and red,
black and red,

00:06:16.000 --> 00:06:21.000
black and black.
But your solution is perfectly

00:06:21.000 --> 00:06:25.000
good as well.
So we don't have any two reds

00:06:25.000 --> 00:06:31.000
in a row on any path.
And all the black height from

00:06:31.000 --> 00:06:36.000
any particular point going down
we get the same number of blacks

00:06:36.000 --> 00:06:38.000
whichever way we go.
Good.

00:06:38.000 --> 00:06:42.000
The idea here now is that,
we're going to keep the subtree

00:06:42.000 --> 00:06:47.000
sizes, these are the keys that
are stored in our dynamic set,

00:06:47.000 --> 00:06:52.000
we're going to keep the subtree
sizes in the red-black tree.

00:06:52.000 --> 00:06:55.000
For example,
this guy has size one.

00:06:55.000 --> 00:07:00.000
These guys have size one
because they're leaves.

00:07:00.000 --> 00:07:08.000
And then we can just work up.
So this has size three,

00:07:08.000 --> 00:07:16.000
this guy has size five,
this guy has size three,

00:07:16.000 --> 00:07:25.000
and this guy has five plus
three plus one is nine.

00:07:25.000 --> 00:07:35.000
In general, we will have size
of x is equal to size of left of

00:07:35.000 --> 00:07:45.000
x plus the size of the right
child of x plus one.

00:07:45.000 --> 00:07:48.000
That is how I compute it
recursively.

00:07:48.000 --> 00:07:52.000
A very simple formula for what
the size is.

00:07:52.000 --> 00:07:58.000
It turns out that for the code
that we're going to want to

00:07:58.000 --> 00:08:03.000
write to implement these
operations, it is going to be

00:08:03.000 --> 00:08:09.000
convenient to be talking about
the size of NIL.

00:08:09.000 --> 00:08:12.000
So what is the size of NIL?
Zero.

00:08:12.000 --> 00:08:16.000
Size of NIL,
there are no elements there.

00:08:16.000 --> 00:08:22.000
However, in most program
languages, if I take size of

00:08:22.000 --> 00:08:26.000
NIL, what will happen?
You get an error.

00:08:26.000 --> 00:08:33.000
That is kind of inconvenient.
What I have to do in my code is

00:08:33.000 --> 00:08:37.000
that everywhere that I might
want to take size of NIL,

00:08:37.000 --> 00:08:41.000
or take the size of anything,
I have to say,

00:08:41.000 --> 00:08:46.000
well, if it's NIL then return
zero, otherwise return the size

00:08:46.000 --> 00:08:49.000
field, etc.
There is an implementation

00:08:49.000 --> 00:08:52.000
trick that we're going to use to
simplify that.

00:08:52.000 --> 00:08:56.000
It's called using a sentinel.

00:09:01.000 --> 00:09:05.000
A sentinel is nothing more than
a dummy record.

00:09:05.000 --> 00:09:10.000
Instead of using a NIL,
we will actually use a NIL

00:09:10.000 --> 00:09:14.000
sentinel.
We will use a dummy record for

00:09:14.000 --> 00:09:18.000
NIL such that size of NIL is
equal to zero.

00:09:18.000 --> 00:09:24.000
Instead of any place I would
have used NIL in the tree,

00:09:24.000 --> 00:09:31.000
instead I will have a special
record that I will call NIL.

00:09:31.000 --> 00:09:35.000
But it will be a whole record.
And that way I can set its size

00:09:35.000 --> 00:09:38.000
field to be zero,
and then I don't have to check

00:09:38.000 --> 00:09:42.000
that as a special case.
That is a very common type of

00:09:42.000 --> 00:09:46.000
programming trick to use,
is to use sentinels to simplify

00:09:46.000 --> 00:09:51.000
code so you don't have all these
boundary cases or you don't have

00:09:51.000 --> 00:09:55.000
to write an extra function when
all I want to do is just index

00:09:55.000 --> 00:10:00.000
the size of something.
Everybody with me on that?

00:10:00.000 --> 00:10:06.000
So let's write the code for
OS-Select given this

00:10:06.000 --> 00:10:09.000
representation.

00:10:17.000 --> 00:10:30.000
And this is going to basically
give us the ith smallest in the

00:10:30.000 --> 00:10:37.000
subtree rooted at x.
It's actually going to be a

00:10:37.000 --> 00:10:42.000
little bit more general.
If I want to implement the

00:10:42.000 --> 00:10:47.000
OS-Select i of up there,
I basically give it the root

00:10:47.000 --> 00:10:50.000
n_i.
But we're going to build this

00:10:50.000 --> 00:10:55.000
recursively so it's going to be
helpful to have the node in

00:10:55.000 --> 00:10:59.000
which we're trying to find the
subtree.

00:10:59.000 --> 00:11:02.000
Here is the code.

00:12:22.000 --> 00:12:28.000
This is the code.
And let's just see how it works

00:12:28.000 --> 00:12:34.000
and then we will argue why it
works.

00:12:34.000 --> 00:12:41.000
As an example,
let's do OS-Select of the root

00:12:41.000 --> 00:12:46.000
and 5.
We're going to find the fifth

00:12:46.000 --> 00:12:54.000
largest in the set.
We have OS-Select of the root

00:12:54.000 --> 00:13:00.000
and 5.
This is inconvenient.

00:13:00.000 --> 00:13:08.000
We start out at the top,
well, let's just switch the

00:13:08.000 --> 00:13:11.000
boards.
Here we go.

00:13:11.000 --> 00:13:17.000
We start at the top,
and i is the root.

00:13:17.000 --> 00:13:23.000
Excuse me, i is 5,
sorry, and the root.

00:13:23.000 --> 00:13:28.000
i=5.
We want to five the fifth

00:13:28.000 --> 00:13:35.000
largest.
We first compute this value k.
147
00:13:35 --&gt; 1.
k is the size of left of x plus
148
1. --&gt; 00:13:39

00:13:39.000 --> 00:13:44.000
What is that value?
What is k anyway?

00:13:44.000 --> 00:13:50.000
What is it?
Well, in this case it is 6.

00:13:50.000 --> 00:13:56.000
Good.
But what is the meaning of k?

00:14:02.000 --> 00:14:03.000
The order.
The rank.

00:14:03.000 --> 00:14:07.000
Good, the rank of the current
node.

00:14:07.000 --> 00:14:10.000
This is the rank of the current
node.

00:14:10.000 --> 00:14:15.000
k is always the size of the
left subtree plus 1.

00:14:15.000 --> 00:14:19.000
That is just the rank of the
current node.

00:14:19.000 --> 00:14:23.000
We look here and we say,
well, the rank is k.

00:14:23.000 --> 00:14:30.000
Now, if it is equal then we
found the element we want.

00:14:30.000 --> 00:14:32.000
But, otherwise,
if i is less,

00:14:32.000 --> 00:14:36.000
we know it's going to be in the
left subtree.

00:14:36.000 --> 00:14:42.000
All we're doing then is
recursing in the left subtree.

00:14:42.000 --> 00:14:47.000
And here we will recurse.
We will want the fifth largest

00:14:47.000 --> 00:14:50.000
one.
And now this time k is going to

00:14:50.000 --> 00:14:52.000
be equal to what?
Two.

00:14:52.000 --> 00:14:56.000
Now here we say,
OK, this is bigger,

00:14:56.000 --> 00:15:01.000
so therefore the element we
want is going to be in the right

00:15:01.000 --> 00:15:06.000
subtree.
But we don't want the ith

00:15:06.000 --> 00:15:11.000
largest guy in the right
subtree, because we already know

00:15:11.000 --> 00:15:15.000
there are going to be two guys
over here.

00:15:15.000 --> 00:15:19.000
We want the third largest guy
in this subtree.

00:15:19.000 --> 00:15:24.000
We have i equals 3 as we
recurse into this subtree.

00:15:24.000 --> 00:15:30.000
And now we compute k for here.
This plus 1 is 2.

00:15:30.000 --> 00:15:34.000
And that says we recursed right
here.

00:15:34.000 --> 00:15:39.000
And then we have i=1,
k=1, and we return in this code

00:15:39.000 --> 00:15:43.000
a pointer to this node.

00:15:55.000 --> 00:16:04.000
So this returns a pointer to
the node containing H whose key

00:16:04.000 --> 00:16:10.000
is H.
Just to make a comment here,

00:16:10.000 --> 00:16:15.000
we discovered k is equal to the
rank of x.

00:16:15.000 --> 00:16:22.000
Any questions about what is
going on in this code?

00:16:22.000 --> 00:16:27.000
OK.
It's basically just finding its

00:16:27.000 --> 00:16:33.000
way down.
The subtree sizes help it make

00:16:33.000 --> 00:16:39.000
the decision as to which way it
should go to find which is the

00:16:39.000 --> 00:16:43.000
ith largest.
We can do a quick analysis.

00:16:43.000 --> 00:16:49.000
On our red-black tree,
how long does OS-Select take to

00:16:49.000 --> 00:16:50.000
run?
Yeah?

00:16:50.000 --> 00:16:57.000
Yeah, order log n if there are
n elements in the tree.

00:16:57.000 --> 00:17:01.000
Because the red-black tree is a
balance tree.

00:17:01.000 --> 00:17:07.000
Its height is order log n.
In fact, this code will work on

00:17:07.000 --> 00:17:12.000
any tree that has order log n
the height of the tree.

00:17:12.000 --> 00:17:19.000
And so if you have a guaranteed
height, the way that red-black

00:17:19.000 --> 00:17:25.000
trees do, you're in good shape.
OS-Rank, we won't do but it is

00:17:25.000 --> 00:17:30.000
in the book, also gets order log
n.

00:17:30.000 --> 00:17:35.000
Here is a question I want to
pose.

00:17:35.000 --> 00:17:42.000
Why not just keep the ranks
themselves?

00:17:58.000 --> 00:18:01.000
Yeah?
It's the node itself.

00:18:01.000 --> 00:18:04.000
Otherwise, you cannot take left
of it.

00:18:04.000 --> 00:18:07.000
I mean, if we were doing this
in a decent language,

00:18:07.000 --> 00:18:11.000
strongly typed language there
would be no confusion.

00:18:11.000 --> 00:18:15.000
But we're writing in this
pseudocode that is good because

00:18:15.000 --> 00:18:18.000
it's compact,
which lets you focus on the

00:18:18.000 --> 00:18:19.000
algorithm.
But, of course,

00:18:19.000 --> 00:18:24.000
it doesn't have a lot of the
things you would really want if

00:18:24.000 --> 00:18:28.000
you were programming things of
scale like type safety and so

00:18:28.000 --> 00:18:33.000
forth.
Yeah?

00:18:41.000 --> 00:18:44.000
It is basically hard to
maintain when you modify it.

00:18:44.000 --> 00:18:48.000
For example,
if we actually kept the ranks

00:18:48.000 --> 00:18:51.000
in the nodes,
certainly it would be easy to

00:18:51.000 --> 00:18:53.000
find the element of a given
rank.

00:18:53.000 --> 00:18:57.000
But all I have to do is insert
the smallest element,

00:18:57.000 --> 00:19:03.000
an element that is smaller than
all of the other elements.

00:19:03.000 --> 00:19:06.000
And what happens?
All the ranks have to be

00:19:06.000 --> 00:19:10.000
changed.
Order n changes have to be made

00:19:10.000 --> 00:19:14.000
if that's what I was
maintaining, whereas with

00:19:14.000 --> 00:19:18.000
subtree sizes that's a lot
easier.

00:19:18.000 --> 00:19:22.000
Because it's hard to maintain
--

00:19:27.000 --> 00:19:33.000
-- when the red-black tree is
modified.

00:19:33.000 --> 00:19:38.000
And that is the other sort of
tricky thing when you're

00:19:38.000 --> 00:19:43.000
augmenting a data structure.
You want to put in the things

00:19:43.000 --> 00:19:49.000
that your operations go fast,
but you cannot forget that

00:19:49.000 --> 00:19:55.000
there are already underlying
operations on the data structure

00:19:55.000 --> 00:20:00.000
that have to be maintained in
some way.

00:20:00.000 --> 00:20:03.000
Can we close this door,
please?

00:20:03.000 --> 00:20:08.000
Thank you.
We have to look at what are the

00:20:08.000 --> 00:20:14.000
modifying operations and how do
we maintain them.

00:20:14.000 --> 00:20:21.000
The modifying operations for
red-black trees are insert and

00:20:21.000 --> 00:20:25.000
delete.
If I were augmenting a binary

00:20:25.000 --> 00:20:33.000
heap, what operations would I
have to worry about?

00:20:38.000 --> 00:20:44.000
If I were augmenting a heap,
what are the modifying

00:20:44.000 --> 00:20:47.000
operations?
Binary min heap,

00:20:47.000 --> 00:20:52.000
for example,
classic priority queue?

00:20:52.000 --> 00:20:58.000
Who remembers heaps?
What are the operations on a

00:20:58.000 --> 00:21:04.000
heap?
There's a good final question.

00:21:04.000 --> 00:21:09.000
Take-home exam,
don't worry about it.

00:21:09.000 --> 00:21:16.000
Final, worry about it.
What are the operations on a

00:21:16.000 --> 00:21:20.000
heap?
Just look it up on Books24 or

00:21:20.000 --> 00:21:23.000
whatever it is,
right?

00:21:23.000 --> 00:21:30.000
AnswerMan?
What does AnswerMan say?

00:21:30.000 --> 00:21:31.000
OK.
And?

00:21:30.000 --> 00:21:36.000
If it's a min heap.
It's min, extract min,

00:21:36.000 --> 00:21:43.000
typical operations and insert.
And of those which are

00:21:43.000 --> 00:21:47.000
modifying?
Insert and extract min,

00:21:47.000 --> 00:21:50.000
OK?
So, min is not.

00:21:50.000 --> 00:21:57.000
You don't have to worry about
min because all that is is a

00:21:57.000 --> 00:22:01.000
query.
You want to distinguish

00:22:01.000 --> 00:22:06.000
operations on a dynamic data
structure those that modify and

00:22:06.000 --> 00:22:09.000
those that don't,
because the ones that don't

00:22:09.000 --> 00:22:14.000
modify the data structure are
all perfectly fine as long as

00:22:14.000 --> 00:22:16.000
you haven't destroyed
information.

00:22:16.000 --> 00:22:18.000
The queries,
those are easy.

00:22:18.000 --> 00:22:22.000
But the operations that modify
the data structure,

00:22:22.000 --> 00:22:26.000
those we're very concerned
about in making sure we can

00:22:26.000 --> 00:22:29.000
maintain.
Our strategy for dealing with

00:22:29.000 --> 00:22:34.000
insert and delete in this case
is to update the subtree sizes

00:22:34.000 --> 00:22:36.000
--

00:22:43.000 --> 00:22:51.000
-- when inserting or deleting.
For example,

00:22:51.000 --> 00:23:00.000
let's look at what happens when
I insert k.

00:23:00.000 --> 00:23:07.000
Element key k.
I am going to want to insert it

00:23:07.000 --> 00:23:14.000
in here, right?
What is going to happen to this

00:23:14.000 --> 00:23:20.000
subtree size if I am inserting k
in here?
267
00:23:20 --&gt; 10.
This is going to increase to
268
10. --&gt; 00:23:25

00:23:25.000 --> 00:23:35.000
And then I go left.
This one is going to increase

00:23:35.000 --> 00:23:41.000
to 6.
Here it is going to increase to
271
00:23:41 --&gt; 4.
272
4. --&gt; 00:23:42
Here 2.

00:23:42.000 --> 00:23:50.000
And then I will put my k down
there with a 1.

00:23:50.000 --> 00:23:56.000
So I just updated on the way
down.

00:23:56.000 --> 00:24:00.000
Pretty easy.
Yeah?

00:24:00.000 --> 00:24:04.000
But now it's not a red-black
tree anymore.

00:24:04.000 --> 00:24:09.000
You have to rebalance,
so you must also handle

00:24:09.000 --> 00:24:12.000
rebalancing.
Because, remember,

00:24:12.000 --> 00:24:17.000
and this is something that
people tend to forget so it's

00:24:17.000 --> 00:24:22.000
always, I think,
helpful when I see patterns

00:24:22.000 --> 00:24:28.000
going on to tell everybody what
the pattern is so that you can

00:24:28.000 --> 00:24:34.000
be sure of it in your work that
you're not falling into that

00:24:34.000 --> 00:24:39.000
pattern.
What people tend to forget when

00:24:39.000 --> 00:24:43.000
they're doing red-black trees is
they tend to remember the tree

00:24:43.000 --> 00:24:46.000
insert part of it,
but red-black insert,

00:24:46.000 --> 00:24:50.000
that RB insert procedure
actually has two parts to it.

00:24:50.000 --> 00:24:54.000
First you call tree insert and
then you have to rebalance.

00:24:54.000 --> 00:24:58.000
And so you've got to make sure
you do the whole of the

00:24:58.000 --> 00:25:02.000
red-black insert.
Not just the tree insert part.

00:25:02.000 --> 00:25:05.000
We just did the tree insert
part.

00:25:05.000 --> 00:25:09.000
That was easy.
We also have to handle

00:25:09.000 --> 00:25:12.000
rebalancing.
So there are two types of

00:25:12.000 --> 00:25:18.000
things we have to worry about.
One is red-black color changes.

00:25:18.000 --> 00:25:23.000
Well, unfortunately those have
no effect on subtree sizes.

00:25:23.000 --> 00:25:27.000
If I change the colors of
things, no effect,

00:25:27.000 --> 00:25:34.000
no problem.
But also the interesting one is

00:25:34.000 --> 00:25:39.000
rotations.
Rotations, it turns out,

00:25:39.000 --> 00:25:46.000
are fairly easy to fix up.
Because when I do a rotation,

00:25:46.000 --> 00:25:52.000
I can update the nodes based on
the children.

00:25:52.000 --> 00:25:59.000
I will show you that.
You basically look at children

00:25:59.000 --> 00:26:09.000
and fix up, in this case,
in order one time per rotation.

00:26:09.000 --> 00:26:12.000
For example,
imagine that I had a piece of

00:26:12.000 --> 00:26:16.000
my tree that looked like this.

00:26:23.000 --> 00:26:26.000
And let's say it was 7,
3, 4, the subtree sizes.

00:26:26.000 --> 00:26:30.000
I'm not going to put the values
in here.

00:26:30.000 --> 00:26:36.000
And I did a right rotation on
that edge to put them the other

00:26:36.000 --> 00:26:40.000
way.
And so these guys get hooked up

00:26:40.000 --> 00:26:45.000
this way.
Always the three children stay

00:26:45.000 --> 00:26:50.000
as three children.
We just swing this guy over to

00:26:50.000 --> 00:26:58.000
there and make this guy be the
parent of the other one.

00:26:58.000 --> 00:27:03.000
And so now the point is that I
can just simply update this guy

00:27:03.000 --> 00:27:08.000
to be, well, he's got 8,
3 plus 4 plus 1 using our

00:27:08.000 --> 00:27:13.000
formula for what the size is.
And now, for this one,

00:27:13.000 --> 00:27:19.000
it's going to be 8 plus 7 plus
1 is 16, or, if I think about

00:27:19.000 --> 00:27:24.000
it, it's going to be whatever
that was before because I

00:27:24.000 --> 00:27:30.000
haven't changed this subtree
size with a rotation.

00:27:30.000 --> 00:27:33.000
Everything beneath this edge is
still beneath this edge.

00:27:33.000 --> 00:27:36.000
And so I fixed it up in order
one time.

00:27:36.000 --> 00:27:40.000
There are certain other types
of operations sometimes that

00:27:40.000 --> 00:27:42.000
occur where this isn't the
value.

00:27:42.000 --> 00:27:46.000
If I wasn't doing subtree sizes
but was doing some other

00:27:46.000 --> 00:27:50.000
property of the subtree,
it could be that this was no

00:27:50.000 --> 00:27:53.000
longer 16 in which case the
effect might propagate up

00:27:53.000 --> 00:27:58.000
towards the root.
There is a nice little lemma in

00:27:58.000 --> 00:28:03.000
the book that shows the
conditions under which you can

00:28:03.000 --> 00:28:08.000
make sure that the re-balancing
doesn't cost you too much.

00:28:08.000 --> 00:28:13.000
So that was pretty good.
Now, insert and delete,

00:28:13.000 --> 00:28:18.000
that is all we have to do for
rotations, are therefore still

00:28:18.000 --> 00:28:22.000
order log n time,
because a red-black tree only

00:28:22.000 --> 00:28:28.000
has to do order one rotations.
Do they normally take constant

00:28:28.000 --> 00:28:32.000
time?
Well, they still take constant

00:28:32.000 --> 00:28:35.000
time.
They just take a little bit

00:28:35.000 --> 00:28:39.000
bigger constant.
And so now we've been able to

00:28:39.000 --> 00:28:45.000
build this great data structure
that supports dynamic order

00:28:45.000 --> 00:28:50.000
statistic queries and it works
in order log n time for insert,

00:28:50.000 --> 00:28:54.000
delete and the various queries.
OS-Select.

00:28:54.000 --> 00:28:59.000
I can also just search for an
element.

00:28:59.000 --> 00:29:05.000
I have taken the basic data
structure and have added some

00:29:05.000 --> 00:29:11.000
new operations on it.
Any questions about what we did

00:29:11.000 --> 00:29:14.000
here?
Do people understand this

00:29:14.000 --> 00:29:16.000
reasonably well?
OK.

00:29:16.000 --> 00:29:23.000
Then let's generalize,
always a dangerous thing.

00:29:37.000 --> 00:29:42.000
Augmenting data structures.
What I would like to do is give

00:29:42.000 --> 00:29:47.000
you a little methodology for how
you go about doing this safely

00:29:47.000 --> 00:29:52.000
so you don't forget things.
The most common thing,

00:29:52.000 --> 00:29:56.000
by the way, if there is an
augmentation problem on the

00:29:56.000 --> 00:30:01.000
take-home or if there is one on
the final, I guarantee that

00:30:01.000 --> 00:30:07.000
probably a quarter of the class
will forget the rotations if

00:30:07.000 --> 00:30:12.000
they augmented red-black tree.
I guarantee it.

00:30:12.000 --> 00:30:16.000
Anyway, here is a little
methodology to check yourself.

00:30:16.000 --> 00:30:19.000
As I mentioned,
the reason why this is so

00:30:19.000 --> 00:30:22.000
important is because this is,
in practice,

00:30:22.000 --> 00:30:25.000
the thing that you do most of
the time.

00:30:25.000 --> 00:30:30.000
You don't just use a data
structure as given.

00:30:30.000 --> 00:30:34.000
You take a data structure.
You say I have my own

00:30:34.000 --> 00:30:37.000
operations I want to layer onto
this.

00:30:37.000 --> 00:30:40.000
We're going to give a
methodology.

00:30:40.000 --> 00:30:43.000
And what I will do,
as I go along,

00:30:43.000 --> 00:30:48.000
is will use the example of
order statistics trees to

00:30:48.000 --> 00:30:52.000
illustrate the methodology.
It is four steps.

00:30:52.000 --> 00:30:58.000
The first is choose an
underlying data structure.

00:31:04.000 --> 00:31:09.000
Which in the case of order
statistics tree was what?

00:31:09.000 --> 00:31:11.000
Red-black tree.

00:31:19.000 --> 00:31:23.000
And the second thing we do is
we figure out what additional

00:31:23.000 --> 00:31:27.000
information we wish to maintain
in that data structure.

00:31:38.000 --> 00:31:43.000
Which in this case is the
subtree sizes.

00:31:43.000 --> 00:31:49.000
Subtree sizes is what we keep
for this one.

00:31:49.000 --> 00:31:55.000
And when we did this we could
make mistakes,

00:31:55.000 --> 00:31:58.000
right?
We could have said,

00:31:58.000 --> 00:32:05.000
oh, let's keep the rank.
And we start playing with it

00:32:05.000 --> 00:32:09.000
and discover we can do that.
It just goes really slowly.

00:32:09.000 --> 00:32:14.000
It takes some creativity to
figure out what is the

00:32:14.000 --> 00:32:18.000
information that you're going to
be able to keep,

00:32:18.000 --> 00:32:22.000
but also to maintain the other
properties that you want.

00:32:22.000 --> 00:32:26.000
The third step is verify that
the information can be

00:32:26.000 --> 00:32:29.000
maintained --

00:32:34.000 --> 00:32:38.000
-- for the modifying operations
on the data structure.

00:32:45.000 --> 00:32:50.000
And so in this case,
for OS trees,

00:32:50.000 --> 00:32:59.000
the modifying operations were
insert and delete.

00:32:59.000 --> 00:33:01.000
And, of course,
we had to make sure we dealt

00:33:01.000 --> 00:33:03.000
with rotations.

00:33:10.000 --> 00:33:14.000
And because rotations are part
of that we could break it down

00:33:14.000 --> 00:33:17.000
into the tree insert,
the tree delete and rotations.

00:33:17.000 --> 00:33:20.000
And once we've did that
everything was fine.

00:33:20.000 --> 00:33:24.000
We didn't, for this particular
problem, have to worry about

00:33:24.000 --> 00:33:27.000
color changes.
But that's another thing that

00:33:27.000 --> 00:33:32.000
under some things you might have
to worry about.

00:33:32.000 --> 00:33:35.000
For some reason the color made
a difference.

00:33:35.000 --> 00:33:38.000
Usually that doesn't make a
difference.

00:33:38.000 --> 00:33:43.000
And then the fourth step is to
develop new operations.

00:33:50.000 --> 00:33:56.000
Presumably that use the info
that you have now stored.

00:33:56.000 --> 00:34:02.000
And this was OS-Select and
OS-Rank, which we didn't give

00:34:02.000 --> 00:34:07.000
but which is there.
And also it's a nice little

00:34:07.000 --> 00:34:12.000
puzzle to figure out yourself,
how you would build OS-Rank.

00:34:12.000 --> 00:34:17.000
Not a hard piece of code.
This methodology is not

00:34:17.000 --> 00:34:22.000
actually the way you do this.
This is one of these things

00:34:22.000 --> 00:34:27.000
that's more like a checklist,
because you see whether or not

00:34:27.000 --> 00:34:31.000
you've got --
When you're actually doing this

00:34:31.000 --> 00:34:34.000
maybe you developed the new
operations first.

00:34:34.000 --> 00:34:37.000
You've got to keep in mind the
new operations while you're

00:34:37.000 --> 00:34:40.000
verifying that the information
you're storing can be here.

00:34:40.000 --> 00:34:44.000
Maybe you will then go back and
change this and sort of sort

00:34:44.000 --> 00:34:46.000
through it.
This is more a checklist that

00:34:46.000 --> 00:34:49.000
when you're done this is how you
write it up.

00:34:49.000 --> 00:34:52.000
This is how you document that
what you've done is,

00:34:52.000 --> 00:34:54.000
in fact, a good thing.
You have a checklist.

00:34:54.000 --> 00:34:56.000
Here is my underlying data
structure.

00:34:56.000 --> 00:35:00.000
Here is the addition
information I need.

00:35:00.000 --> 00:35:03.000
See, I can still support the
modifying operations that the

00:35:03.000 --> 00:35:07.000
data structure used to have and
now here are my new operations

00:35:07.000 --> 00:35:10.000
and see what those are.
It's really a checklist.

00:35:10.000 --> 00:35:13.000
Not a prescription for the
order in which you do things.

00:35:13.000 --> 00:35:16.000
You must do all these steps,
not necessarily in this order.

00:35:16.000 --> 00:35:19.000
This is a guide for your
documentation.

00:35:19.000 --> 00:35:22.000
When we ask for you to augment
a data structure,

00:35:22.000 --> 00:35:25.000
generally we're asking you to
tell us what the four steps are.

00:35:25.000 --> 00:35:29.000
It will help you organize your
things.

00:35:29.000 --> 00:35:33.000
It will also help make sure you
don't forget some step along the

00:35:33.000 --> 00:35:36.000
way.
I've seen people who have added

00:35:36.000 --> 00:35:40.000
the information and developed
new operations but completely

00:35:40.000 --> 00:35:44.000
forgot to verify that the
information could be maintained.

00:35:44.000 --> 00:35:48.000
So you want to make sure that
you've done all those.

00:35:48.000 --> 00:35:51.000
Usually you have to play --

00:35:56.000 --> 00:35:59.000
-- with interactions --

00:36:04.000 --> 00:36:07.000
-- between steps.
It's not just a do this,

00:36:07.000 --> 00:36:12.000
do this, do this.
We're going to do now a more

00:36:12.000 --> 00:36:17.000
complicated data structure.
It's not that much more

00:36:17.000 --> 00:36:24.000
complicated, but its correctness
is actually kind of challenging.

00:36:33.000 --> 00:36:36.000
And it is actually a very
practical and useful data

00:36:36.000 --> 00:36:40.000
structure.
I am amazed at how many people

00:36:40.000 --> 00:36:45.000
aren't aware that there are data
structures of this nature that

00:36:45.000 --> 00:36:49.000
are useful for them when I see
people writing really slow code.

00:36:49.000 --> 00:36:55.000
And so the example we're going
to do is interval trees.

00:37:00.000 --> 00:37:08.000
And the idea of this is that we
want to maintain a set of

00:37:08.000 --> 00:37:11.000
intervals.
For example,

00:37:11.000 --> 00:37:18.000
time intervals.
I have a whole database of time

00:37:18.000 --> 00:37:24.000
intervals that I'm trying to
maintain.

00:37:24.000 --> 00:37:30.000
Let's just do an example here.

00:38:00.000 --> 00:38:08.000
This is going from 7 to 10,
5 to 11 and 4 to 8,

00:38:08.000 --> 00:38:14.000
from 15 to 18,
17 to 19 and 21 to 23.

00:38:14.000 --> 00:38:24.000
This is a set of intervals.
And if we have an interval i,

00:38:24.000 --> 00:38:34.000
let's say this is interval i,
which is 7,10.

00:38:34.000 --> 00:38:38.000
We're going to call this
endpoint the low endpoint of i

00:38:38.000 --> 00:38:41.000
and this we're going to call the
high endpoint of i.

00:38:41.000 --> 00:38:46.000
The reason I use low and high
rather than left or right is

00:38:46.000 --> 00:38:50.000
because we're going to have a
tree, and we're going to want

00:38:50.000 --> 00:38:53.000
the left subtree and the right
subtree.

00:38:53.000 --> 00:38:58.000
So if I start saying left and
right for intervals and left and

00:38:58.000 --> 00:39:03.000
right for tree we're going to
get really confused.

00:39:03.000 --> 00:39:05.000
This is also a tip.
Let me say when you're coding,

00:39:05.000 --> 00:39:09.000
you really have to think hard
sometimes about the words that

00:39:09.000 --> 00:39:12.000
you're using for things,
especially things like left and

00:39:12.000 --> 00:39:15.000
right because they get so
overused throughout programming.

00:39:15.000 --> 00:39:18.000
It's a good idea to come up
with a whole wealth of synonyms

00:39:18.000 --> 00:39:22.000
for different situations so that
it is clear in any piece of code

00:39:22.000 --> 00:39:24.000
when you're talking,
for example,

00:39:24.000 --> 00:39:27.000
about the intervals versus the
tree, because we're going to

00:39:27.000 --> 00:39:33.000
have both going on here.
And what we're going to do is

00:39:33.000 --> 00:39:41.000
we want to support insertion and
deletion of intervals here.

00:39:41.000 --> 00:39:49.000
And we're going to have a
query, which is going to be the

00:39:49.000 --> 00:39:57.000
new operation we're going to
develop, which is going to be to

00:39:57.000 --> 00:40:03.000
find an interval,
any interval in the set that

00:40:03.000 --> 00:40:09.000
overlaps a given query interval.

00:40:15.000 --> 00:40:23.000
So I give you a query interval
like say 6, 14 and you can

00:40:23.000 --> 00:40:31.000
return this guy or this guy,
this guy, couldn't return any

00:40:31.000 --> 00:40:38.000
of these because these are all
less than 14.

00:40:38.000 --> 00:40:41.000
So I can return any one of
those.

00:40:41.000 --> 00:40:47.000
I only have to return one.
I just have to find one guy

00:40:47.000 --> 00:40:52.000
that overlaps.
Any question about what we're

00:40:52.000 --> 00:40:55.000
going to be setting up here?
OK.

00:40:55.000 --> 00:41:01.000
Our methodology is we're going
to pick, first of all,

00:41:01.000 --> 00:41:06.000
step one.
And here is our methodology.

00:41:06.000 --> 00:41:12.000
Step one is we're going chose
underlying data structure.

00:41:12.000 --> 00:41:18.000
Does anybody have a suggestion
as to what data structure we

00:41:18.000 --> 00:41:24.000
ought to use here to support
interval trees?

00:41:32.000 --> 00:41:38.000
What data structure should we
try to start here to support

00:41:38.000 --> 00:41:41.000
interval trees?
Anybody have any idea?

00:41:41.000 --> 00:41:45.000
A red-black tree.
A binary search tree.

00:41:45.000 --> 00:41:50.000
Red-black tree.
We're going to use a red-black

00:41:50.000 --> 00:41:52.000
tree.

00:41:57.000 --> 00:42:02.000
Oh, I've got to say what it is
keyed on.

00:42:02.000 --> 00:42:06.000
What is going to be the key for
my red-black tree?

00:42:06.000 --> 00:42:10.000
For each interval,
what should I use for a key?

00:42:10.000 --> 00:42:14.000
This is where there are a bunch
of options, right?

00:42:14.000 --> 00:42:19.000
Throw out some ideas.
It's always better to branch

00:42:19.000 --> 00:42:23.000
than it is to prune.
You can always prune later,

00:42:23.000 --> 00:42:28.000
but if you don't branch you
will never get the chance to

00:42:28.000 --> 00:42:32.000
prune.
So generation of ideas.

00:42:32.000 --> 00:42:37.000
You'll need that when you're
doing the design phase and doing

00:42:37.000 --> 00:42:40.000
the take-home exam.
Yeah?

00:42:40.000 --> 00:42:43.000
We're calling that the low
endpoint.

00:42:43.000 --> 00:42:48.000
OK, you could do low endpoint.
What other ideas are there?

00:42:48.000 --> 00:42:52.000
High end point.
Now you can look at low

00:42:52.000 --> 00:42:57.000
endpoint, high endpoint.
Well, between low and high

00:42:57.000 --> 00:43:02.000
which is better?
That one is not going to

00:43:02.000 --> 00:43:06.000
matter, right?
So doing high versus low,

00:43:06.000 --> 00:43:13.000
we don't have to consider that,
but there is another natural

00:43:13.000 --> 00:43:18.000
point you want to think about
using like the median,

00:43:18.000 --> 00:43:23.000
the middle point.
At least that is symmetric.

00:43:23.000 --> 00:43:27.000
What do you think?
What else might I use?

00:43:27.000 --> 00:43:32.000
The length?
I think the length doesn't feel

00:43:32.000 --> 00:43:36.000
to me productive.
This is just purely a matter of

00:43:36.000 --> 00:43:39.000
intuition.
It doesn't feel productive,

00:43:39.000 --> 00:43:43.000
because if I know the length I
don't know where it is so it's

00:43:43.000 --> 00:43:48.000
going to be hard to maintain
information about where it is

00:43:48.000 --> 00:43:51.000
for queries.
It turns out we're going to use

00:43:51.000 --> 00:43:55.000
the low left endpoint,
but I think to me that was sort

00:43:55.000 --> 00:44:02.000
of a surprise that you'd want to
use that and not the middle one.

00:44:02.000 --> 00:44:06.000
Because you're favoring one
endpoint over the other.

00:44:06.000 --> 00:44:11.000
It turns out that's the right
thing to do, surprisingly.

00:44:11.000 --> 00:44:16.000
There is another strategy.
Actually, there's another type

00:44:16.000 --> 00:44:22.000
of tree called a segment tree.
Actually, what you do is you

00:44:22.000 --> 00:44:27.000
store both the left and right
endpoints separately in the

00:44:27.000 --> 00:44:30.000
tree.
And then you maintain a data

00:44:30.000 --> 00:44:35.000
structure where the line
segments go up through the tree

00:44:35.000 --> 00:44:40.000
on to the other.
There are lots of things you

00:44:40.000 --> 00:44:45.000
can do, but we're just going to
keep it keyed on the low

00:44:45.000 --> 00:44:47.000
endpoint.
That's why this is a more

00:44:47.000 --> 00:44:50.000
clever data structure in some
ways.

00:44:50.000 --> 00:44:54.000
Now, this is harder.
That is why this is a clever

00:44:54.000 --> 00:44:58.000
data structure.
What are we going to store in

00:44:58.000 --> 00:45:03.000
the --
I think any of those ideas are

00:45:03.000 --> 00:45:08.000
good ideas to throw out and look
at.

00:45:08.000 --> 00:45:14.000
You don't know which one is
going to work until you play

00:45:14.000 --> 00:45:17.000
with it.
This one, though,

00:45:17.000 --> 00:45:22.000
is, I think,
much harder to guess.

00:45:22.000 --> 00:45:28.000
You're going to store in a node
the largest value,

00:45:28.000 --> 00:45:33.000
I will call it m,
in the subtree rooted at that

00:45:33.000 --> 00:45:36.000
node.

00:45:45.000 --> 00:45:48.000
We'll draw it like this,
a node like this.

00:45:48.000 --> 00:45:52.000
We will put the interval here
and we will put the m value

00:45:52.000 --> 00:45:53.000
here.

00:46:02.000 --> 00:46:04.000
Let's draw a picture.

00:46:38.000 --> 00:46:42.000
Once again, I am not drawing
the NILs.

00:47:00.000 --> 00:47:05.000
I hope that that is a search
tree that is keyed on the low

00:47:05.000 --> 00:47:08.000
left endpoint.
4, 5, 7, 15,

00:47:08.000 --> 00:47:11.000
17, 21.
It is keyed on the low left

00:47:11.000 --> 00:47:15.000
endpoint.
If this a red-black tree,

00:47:15.000 --> 00:47:21.000
let's just do another practice.
How can I color this so that it

00:47:21.000 --> 00:47:27.000
is a legal red-black tree?
Not too relevant to what we're

00:47:27.000 --> 00:47:32.000
doing right now
But a little drill doesn't hurt

00:47:32.000 --> 00:47:35.000
sometimes.
Remember, the NILs are not

00:47:35.000 --> 00:47:39.000
there and they are all black.
And the root is black.

00:47:39.000 --> 00:47:42.000
I will give that one to you.

00:47:52.000 --> 00:47:54.000
Good.
This will work.

00:47:54.000 --> 00:48:00.000
You sort of go through a little
puzzle.

00:48:00.000 --> 00:48:03.000
A logic puzzle.
Because this is really short so

00:48:03.000 --> 00:48:06.000
it better not have any reds in
it.

00:48:06.000 --> 00:48:11.000
This has got to be black.
Now, if I'm going to balance

00:48:11.000 --> 00:48:15.000
the height, I have got to have a
layer of black here.

00:48:15.000 --> 00:48:19.000
It couldn't be that one.
It's got to be these two.

00:48:19.000 --> 00:48:22.000
Good.
Now let's compute the m value

00:48:22.000 --> 00:48:26.000
for each of these.
It's the largest value in the

00:48:26.000 --> 00:48:36.000
subtree rooted at that node.
What's the largest value in the
577
00:48:36 --&gt; 10.
subtree rooted at this node?
578
10. --&gt; 00:48:43
579
00:48:43 --&gt; 18.
And in this one?
580
18. --&gt; 00:48:47
581
00:48:47 --&gt; 8.
In this one?
582
8. --&gt; 00:48:50
583
00:48:50 --&gt; 18.
584
18. --&gt; 00:49:00
That one is 23 and that is 23.

00:49:00.000 --> 00:49:12.000
In general, m is going to be
the maximum of three possible

00:49:12.000 --> 00:49:20.000
values.
Either the high point of the

00:49:20.000 --> 00:49:34.000
interval at x or m of the left
of x or m of the right of x.

00:49:40.000 --> 00:49:44.000
Does everybody see that?
It is going to be m of x for

00:49:44.000 --> 00:49:46.000
any node.
I just have to look,

00:49:46.000 --> 00:49:50.000
what is the maximum here,
what is the maximum here and

00:49:50.000 --> 00:49:53.000
what is the high point of the
interval.

00:49:53.000 --> 00:49:58.000
Whichever one of those is
largest, that's the largest for

00:49:58.000 --> 00:50:00.000
that subtree.

00:50:15.000 --> 00:50:19.000
The modifying operations.

00:50:29.000 --> 00:50:33.000
Let's first do insert.
How can I do insert?

00:50:33.000 --> 00:50:38.000
There are two parts.
The first part is to do the

00:50:38.000 --> 00:50:44.000
tree insert, just a normal
insert into a binary search

00:50:44.000 --> 00:50:46.000
tree.

00:50:55.000 --> 00:51:03.000
What do I do?
Insert a new interval?

00:51:20.000 --> 00:51:23.000
Insert a new interval here?
How can I fix up the m's?

00:51:33.000 --> 00:51:35.000
That's right.
You just go down the tree and

00:51:35.000 --> 00:51:39.000
look at my current interval.
And if it's got a bigger max,

00:51:39.000 --> 00:51:43.000
this is something that is going
into that subtree.

00:51:43.000 --> 00:51:46.000
If its high endpoint is bigger
than the current max,

00:51:46.000 --> 00:51:50.000
update the current max.
I just do that as I'm going

00:51:50.000 --> 00:51:54.000
through the insertion,
wherever it happens to land up

00:51:54.000 --> 00:51:58.000
in every subtree that it hits,
every node that it hits on the

00:51:58.000 --> 00:52:04.000
way down.
I just update it with the

00:52:04.000 --> 00:52:11.000
maximum wherever it happens to
fall.

00:52:11.000 --> 00:52:17.000
Good.
You just fix them on the way

00:52:17.000 --> 00:52:19.000
down.

00:52:25.000 --> 00:52:30.000
But we also have to do the
other section.

00:52:30.000 --> 00:52:37.000
Also need to handle rotations.

00:52:45.000 --> 00:52:51.000
So let's just see how we might
do rotations as an example.

00:53:00.000 --> 00:53:03.000
Let's say this is 11, 15, 30.

00:53:14.000 --> 00:53:16.000
Let's say I'm doing a right
rotation.

00:53:16.000 --> 00:53:19.000
This is coming off from
somewhere.

00:53:32.000 --> 00:53:37.000
That is coming off.
This is still going to be the

00:53:37.000 --> 00:53:43.000
child that has 30,
the one that 14 and the one

00:53:43.000 --> 00:53:48.000
that has 19.
And so now we've rotated this

00:53:48.000 --> 00:53:53.000
way, so this is the 11,
15 and this is the 6,
633
00:53:53 --&gt; 20.
634
20. --&gt; 00:53:55
For this one,

00:53:55.000 --> 00:54:02.000
I just use my formula here.
I just look here and say which

00:54:02.000 --> 00:54:04.000
is the biggest,
14, 15 or 19?
637
00:54:04 --&gt; 19.
638
19. --&gt; 00:54:06
And I look here.

00:54:06.000 --> 00:54:08.000
Which is the biggest?
30, 19 or 20?
640
00:54:08 --&gt; 30.
641
30. --&gt; 00:54:10
Or, once again,

00:54:10.000 --> 00:54:12.000
it turns out,
not too hard to show,

00:54:12.000 --> 00:54:17.000
that it's always whatever was
there, because we're talking

00:54:17.000 --> 00:54:20.000
about the biggest thing in the
subtree.

00:54:20.000 --> 00:54:24.000
And the membership of the
subtree hasn't changed when we

00:54:24.000 --> 00:54:28.000
do the rotation.
That just took me order one

00:54:28.000 --> 00:54:31.000
time to fix up.

00:54:51.000 --> 00:55:08.000
Fixing up the m's during
rotation takes O(1) time.

00:55:08.000 --> 00:55:19.000
So the total insert time is
O(lg n).

00:55:25.000 --> 00:55:27.000
Once I figured out that this is
the right information,

00:55:27.000 --> 00:55:29.000
of course we don't know what
we're using this information for

00:55:29.000 --> 00:55:32.000
yet.
But once I know that that is

00:55:32.000 --> 00:55:36.000
the information,
showing you that it works in

00:55:36.000 --> 00:55:41.000
certain delete continuing work
in order log n time is easy.

00:55:41.000 --> 00:55:46.000
Now, delete is actually a
little bit trickier but I will

00:55:46.000 --> 00:55:50.000
just say it is similar.
Because in delete you go

00:55:50.000 --> 00:55:56.000
through and you find something,
you may have to go through the

00:55:56.000 --> 00:56:02.000
whole business of swapping it.
If it's an internal node you've

00:56:02.000 --> 00:56:05.000
got to swap it with its
successor or predecessor.

00:56:05.000 --> 00:56:08.000
And so there are a bunch of
things that have to be dealt

00:56:08.000 --> 00:56:12.000
with, but it is all stuff where
you can update the information

00:56:12.000 --> 00:56:15.000
using this thing.
And it's all essentially local

00:56:15.000 --> 00:56:19.000
changes when you're updating
this information because you can

00:56:19.000 --> 00:56:23.000
do it essentially only on a path
up from the root and most of the

00:56:23.000 --> 00:56:27.000
tree is never dealt with.
I will leave that for you folks

00:56:27.000 --> 00:56:32.000
to work out.
It's also in the book if you

00:56:32.000 --> 00:56:36.000
want to cheat,
but it is a good exercise.

00:56:36.000 --> 00:56:41.000
Any questions about the first
three steps?

00:56:41.000 --> 00:56:45.000
Fourth step is new operations.

00:57:18.000 --> 00:57:28.000
Interval search of i is going
to find an interval that

00:57:28.000 --> 00:57:35.000
overlaps the interval i.
So i here is an interval.

00:57:35.000 --> 00:57:39.000
It's got two coordinates.
And this, rather than writing

00:57:39.000 --> 00:57:43.000
recursively, we're going to
write as, it's sort of going to

00:57:43.000 --> 00:57:46.000
be recursive,
but we're going to write it

00:57:46.000 --> 00:57:49.000
with a while loop.
You could write it recursively.

00:57:49.000 --> 00:57:53.000
The other one that we wrote,
we could have written as a

00:57:53.000 --> 00:57:57.000
while loop as well and not had
the recursive call.

00:57:57.000 --> 00:58:02.000
Here we're going to basically
just start x gets the root.

00:58:02.000 --> 00:58:05.000
And then while --

00:59:47.000 --> 00:59:56.000
That is the code.
Let's just see how it works.

00:59:56.000 --> 01:00:05.000
Let's search for the interval
14, 16 --

01:00:12.000 --> 01:00:15.202
-- in this tree.
Let's see.

01:00:15.202 --> 01:00:21.239
x starts out at the root.
And while it is not NIL,

01:00:21.239 --> 01:00:29.000
and it's not NIL because it's
the root, what is this doing?

01:00:29.000 --> 01:00:31.000
Somebody tell me what that code
does.

01:00:50.000 --> 01:00:56.000
Well, what is this doing?
This is testing something

01:00:56.000 --> 01:01:01.952
between i and int of x.
Int of x is the interval stored

01:01:01.952 --> 01:01:05.000
at x.
What is this testing for?

01:01:17.000 --> 01:01:19.000
I hope I got it right.

01:01:30.000 --> 01:01:34.000
What is this testing for? Yeah?

01:01:41.000 --> 01:01:46.333
Above or below?
I need just simple words.

01:01:46.333 --> 01:01:52.866
Test for overlaps.
In particular test whether they

01:01:52.866 --> 01:01:55.000
do or don't?

01:02:00.000 --> 01:02:01.778
Do?
Don't?

01:02:01.778 --> 01:02:12.251
If I get to this point,
what do I know about i and int

01:02:12.251 --> 01:02:16.005
of x?
Don't overlap.

01:02:16.005 --> 01:02:28.059
They don't overlap because the
high of one is smaller than the

01:02:28.059 --> 01:02:35.417
low of the other.
The high of one is smaller than

01:02:35.417 --> 01:02:39.239
the low of the other.
They don't overlap that way.

01:02:39.239 --> 01:02:41.735
Could they overlap the other
way?

01:02:41.735 --> 01:02:46.259
No because we're testing also
whether the low of the one is

01:02:46.259 --> 01:02:48.832
bigger than the high of the
other.

01:02:48.832 --> 01:02:52.654
They're saying it's either like
this or like this.

01:02:52.654 --> 01:02:56.554
This is testing not overlap.
That makes it simpler.

01:02:56.554 --> 01:03:01.000
When I'm searching for 14,
16, I check here.

01:03:01.000 --> 01:03:04.340
And I say do they overlap?
And the answer is,

01:03:04.340 --> 01:03:08.591
now we can understand it
without having to go through all

01:03:08.591 --> 01:03:12.387
the arithmetic calculations,
no they don't overlap.

01:03:12.387 --> 01:03:15.424
If they did overlap,
I found what I want.

01:03:15.424 --> 01:03:19.675
And what's going to happen?
I am going to drop out of the

01:03:19.675 --> 01:03:24.230
while loop and just return x,
because I will return something

01:03:24.230 --> 01:03:26.507
that overlaps.
That is my goal.

01:03:26.507 --> 01:03:30.000
Here it says they don't
overlap.

01:03:30.000 --> 01:03:34.731
So then I say,
well, if left of x is not NIL,

01:03:34.731 --> 01:03:39.462
in other words,
I've got a left child and low

01:03:39.462 --> 01:03:44.193
of i is less than or equal to m
of left of x,

01:03:44.193 --> 01:03:48.924
then we go left.
What happens in this case if

01:03:48.924 --> 01:03:51.505
I'm searching for 14,
16?

01:03:51.505 --> 01:03:57.096
Is the low of i less than or
equal to m of left of x?

01:03:57.096 --> 01:04:03.181
Low of i is 14.
And I am searching.

01:04:03.181 --> 01:04:07.702
And is it less than 18?
Yes.

01:04:07.702 --> 01:04:16.576
Therefore, what do I do?
I go left and make x point to

01:04:16.576 --> 01:04:20.093
this guy.
Now I check.

01:04:20.093 --> 01:04:23.274
Does it overlap?
No.

01:04:23.274 --> 01:04:29.637
I take a look at the left guy.
It is 8.

01:04:29.637 --> 01:04:36.000
I compare 8 with 14,
right?

01:04:36.000 --> 01:04:40.508
And is it lower?
No, so I go right.

01:04:40.508 --> 01:04:48.729
And now I discover that I have
an overlap here and it overlaps.

01:04:48.729 --> 01:04:55.093
It returns then the 15,
18 as an overlapping one.
740
1:04:55.093 --&gt; 14.
If I were searching for 12,
741
14. --&gt; 1:05:00

01:05:12.000 --> 01:05:16.556
I would go up to the top.
And I look, 12,

01:05:16.556 --> 01:05:22.708
14, it doesn't overlap here.
I look at the 18 and it is

01:05:22.708 --> 01:05:27.037
greater so I go left.
I then look here.

01:05:27.037 --> 01:05:30.000
Does it overlap?
No.

01:05:30.000 --> 01:05:34.740
So then what happens?
I look at the left.

01:05:34.740 --> 01:05:38.414
It says I go right.
I look here.

01:05:38.414 --> 01:05:42.207
Then I go and I look at the
left.

01:05:42.207 --> 01:05:44.696
It says, no,
go right.

01:05:44.696 --> 01:05:49.674
I go here, which is NIL,
and now it is NIL.

01:05:49.674 --> 01:05:52.637
I return NIL.
And does 12,

01:05:52.637 --> 01:05:56.666
14 overlap anything in the set?
No.

01:05:56.666 --> 01:06:02.000
So, therefore,
it always works.

01:06:02.000 --> 01:06:02.971
OK?
OK.

01:06:02.971 --> 01:06:12.520
We're going to do correctness
in a minute, but let's just do

01:06:12.520 --> 01:06:21.421
our analysis first so we don't
have to do it because the

01:06:21.421 --> 01:06:30.000
correctness is going to be a
little bit tricky.

01:06:30.000 --> 01:06:36.095
Time = O(lg n) because all I am
doing is going down the tree.

01:06:36.095 --> 01:06:41.377
It takes time proportional to
the height of the tree.

01:06:41.377 --> 01:06:46.457
That's pretty easy.
If I need to list all overlaps,

01:06:46.457 --> 01:06:52.552
suppose I want to list all the
overlaps, how quickly can I do

01:06:52.552 --> 01:06:55.701
that?
Can somebody suggest how I

01:06:55.701 --> 01:07:02.000
could use this as a subroutine
to list all overlaps?

01:07:13.000 --> 01:07:16.840
Suppose I have k overlaps,
k intervals that overlap my

01:07:16.840 --> 01:07:21.043
query interval and I want to
find every single one of them,

01:07:21.043 --> 01:07:23.000
how fast can I do that?

01:07:31.000 --> 01:07:33.000
How do I do it?

01:07:44.000 --> 01:07:49.271
How do I do it?
If I search a second time,

01:07:49.271 --> 01:07:53.000
I might get the same value.

01:08:02.000 --> 01:08:04.400
Yeah, there you go.
Do what?

01:08:04.400 --> 01:08:08.933
When you find it delete it.
Put it over to the side.

01:08:08.933 --> 01:08:13.199
Find the next one,
delete it until there are none

01:08:13.199 --> 01:08:16.133
left.
And then, if I don't want to

01:08:16.133 --> 01:08:20.577
modify the data structure,
insert them all back in.

01:08:20.577 --> 01:08:24.222
It costs me k lg n if they are
k overlaps.

01:08:24.222 --> 01:08:30.000
That's actually called an
output sensitive algorithm.

01:08:30.000 --> 01:08:34.064
Because the running time of it
depends upon how much it

01:08:34.064 --> 01:08:37.000
outputs, so this is output
sensitive.

01:08:42.000 --> 01:08:47.357
The best to date for this
problem, by the way,

01:08:47.357 --> 01:08:54.380
of listing all is O(k+lg n)
with a different data structure.

01:08:54.380 --> 01:08:59.738
And, actually,
that was open for a while as an

01:08:59.738 --> 01:09:07.000
open problem.
OK. Correctness.

01:09:12.000 --> 01:09:16.697
Why does this algorithm always
work correctly?

01:09:16.697 --> 01:09:22.126
The key issue of the
correctness is that I am picking

01:09:22.126 --> 01:09:25.049
one way to go,
left or right.

01:09:25.049 --> 01:09:29.329
And that's great,
as long as it is in that

01:09:29.329 --> 01:09:33.636
subtree.
But how do I know that when I

01:09:33.636 --> 01:09:39.181
pick I decide I'm going to go
left that it might not be in the

01:09:39.181 --> 01:09:42.636
right subtree and I went the
wrong way?

01:09:42.636 --> 01:09:47.000
Or, if I went right,
that I accidentally left one

01:09:47.000 --> 01:09:51.363
out on the left side?
We're always going just one

01:09:51.363 --> 01:09:54.272
direction.
And that's sort of the

01:09:54.272 --> 01:09:59.000
cleverness of the code.
The theorem is let's let L be

01:09:59.000 --> 01:10:05.000
the set of intervals i prime in
the left of a node x.

01:10:05.000 --> 01:10:14.106
And R be the set of i primes in
the right of x.

01:10:14.106 --> 01:10:23.213
And now there are two parts I
am going to show.

01:10:23.213 --> 01:10:33.705
If the search goes right then
the set of i prime in L,

01:10:33.705 --> 01:10:44.000
such that i prime overlaps i is
the empty set.

01:10:44.000 --> 01:10:48.833
That's the first thing I do.
If it goes right then there is

01:10:48.833 --> 01:10:52.250
nothing in the left subtree that
overlaps.

01:10:52.250 --> 01:10:55.666
It's always,
whenever the code goes right,

01:10:55.666 --> 01:11:00.583
no problem, because there was
nothing in the left subtree to

01:11:00.583 --> 01:11:03.783
be found.
Does everybody understand what

01:11:03.783 --> 01:11:05.982
that says?
We are going to prove this,

01:11:05.982 --> 01:11:08.419
but I want to make sure people
understand.

01:11:08.419 --> 01:11:11.986
Because the second one is going
to be harder to understand so

01:11:11.986 --> 01:11:15.136
you've got to make sure you
understand this one first.

01:11:15.136 --> 01:11:16.800
Any questions about this?
OK.

01:11:16.800 --> 01:11:19.000
If the search goes left --

01:11:27.000 --> 01:11:40.808
-- then the set of i prime in L
such that i prime overlaps i

01:11:40.808 --> 01:11:49.000
empty set implies that i prime
--

01:12:00.000 --> 01:12:02.329
OK.
What is this saying?

01:12:02.329 --> 01:12:06.987
If the search goes left,
if the left was empty,

01:12:06.987 --> 01:12:10.936
in other words,
if you went left and you

01:12:10.936 --> 01:12:16.000
discovered that there was
nothing in there to find,

01:12:16.000 --> 01:12:21.569
no overlapping interval to find
then it is OK because it

01:12:21.569 --> 01:12:27.443
wouldn't have helped me to go
right anyway because there is

01:12:27.443 --> 01:12:32.000
nothing in the right to be
found.

01:12:32.000 --> 01:12:37.809
So it is not guaranteeing that
there is nothing to be found in

01:12:37.809 --> 01:12:43.333
the left, but if there happens
to be nothing to find in the

01:12:43.333 --> 01:12:49.333
left it is OK because there was
nothing to be found in the right

01:12:49.333 --> 01:12:52.571
either.
That is what the second one

01:12:52.571 --> 01:12:54.476
says.
In either case,

01:12:54.476 --> 01:13:00.000
you're OK to go the way.
So let's do this proof.

01:13:05.000 --> 01:13:09.090
Does everybody understand what
the proof says?

01:13:09.090 --> 01:13:12.090
Understanding the proof is
tricky.

01:13:12.090 --> 01:13:14.545
It's logic.
Logic is tricky.

01:13:14.545 --> 01:13:20.000
Suppose the search goes right.
We'll do the first one.

01:13:27.000 --> 01:13:37.275
If left of x is NIL then we are
done since we proved what we

01:13:37.275 --> 01:13:44.938
wanted to prove.
If we go right there are two

01:13:44.938 --> 01:13:52.775
possibilities,
either we have left of x be NIL

01:13:52.775 --> 01:14:00.389
or left of x is not NIL.
So if it is NIL we are OK

01:14:00.389 --> 01:14:05.455
because we said if it goes right
I want to prove this,

01:14:05.455 --> 01:14:10.904
that the things in the left
subtree that overlap is empty.

01:14:10.904 --> 01:14:16.257
If there is nothing there,
there is clearly nothing there

01:14:16.257 --> 01:14:20.080
that overlaps.
Otherwise, the low of i is

01:14:20.080 --> 01:14:24.000
greater than m of the left of x.

01:14:29.000 --> 01:14:34.775
If I look at x here,
either x was NIL in the while

01:14:34.775 --> 01:14:41.847
statement here or this is true.
We just said it is not NIL so

01:14:41.847 --> 01:14:45.501
let's take a look at,
excuse me.

01:14:45.501 --> 01:14:50.216
I'm on the wrong line.
I am in this loop.

01:14:50.216 --> 01:14:55.756
Left of x was not NIL and the
low of i was this.

01:14:55.756 --> 01:15:01.530
Which way am I going here?
I am going right.

01:15:01.530 --> 01:15:06.572
Therefore, this was not true.
So either left of x was not

01:15:06.572 --> 01:15:11.794
NIL, which was the first one,
or low of i is greater than m

01:15:11.794 --> 01:15:14.675
of left of x if I am going
right.

01:15:14.675 --> 01:15:19.176
If I'm going right one of those
two had to be true.

01:15:19.176 --> 01:15:23.408
The first one was easy.
Otherwise, we have this,

01:15:23.408 --> 01:15:28.000
low of i is greater than m of
left of x.

01:15:28.000 --> 01:15:31.798
Now this has got to be that
value.

01:15:31.798 --> 01:15:38.359
m of left of x is the right
endpoint, is the high endpoint

01:15:38.359 --> 01:15:42.043
of some interval in that
subtree.

01:15:42.043 --> 01:15:47.338
This is equal to the high of j
for some j in L.

01:15:47.338 --> 01:15:54.129
So m of left of x must be equal
to the high of some endpoint

01:15:54.129 --> 01:16:00.000
because that's how we're picking
the m's.

01:16:00.000 --> 01:16:13.863
For some j in the left subtree.
And no other interval in L has

01:16:13.863 --> 01:16:20.000
a larger high endpoint --

01:16:27.000 --> 01:16:33.456
-- than high of j.
If I draw a picture here,

01:16:33.456 --> 01:16:39.400
I have over here i and this is
the low of i.

01:16:39.400 --> 01:16:47.557
And I have j where we say its
high endpoint is less than the

01:16:47.557 --> 01:16:53.087
low of i.
This is j, and I don't know how

01:16:53.087 --> 01:17:00.000
far over it goes.
And this has high of j --

01:17:08.000 --> 01:17:12.575
-- which is the highest one in
the left subtree.

01:17:12.575 --> 01:17:18.026
There is nobody else who has
got a higher right endpoint.

01:17:18.026 --> 01:17:23.283
There is nobody else in this
subtree who could possibly

01:17:23.283 --> 01:17:30.000
overlap I, because all of them
end somewhere before this point.

01:17:30.000 --> 01:17:38.076
This point is the highest one
in a subtree.

01:17:38.076 --> 01:17:49.230
Therefore, i prime in L such
that i prime overlaps i is the

01:17:49.230 --> 01:17:55.384
empty set.
And now the hard case.

01:17:55.384 --> 01:18:00.786
Everybody stretch.
Hard case.

01:18:00.786 --> 01:18:05.266
Does everybody follow this?
The point is that because this

01:18:05.266 --> 01:18:09.039
is the highest guy everybody
else has to be left,

01:18:09.039 --> 01:18:13.676
so if you didn't overlap the
highest guy you're not going to

01:18:13.676 --> 01:18:18.000
overlap anybody.
Suppose the search goes left --

01:18:24.000 --> 01:18:34.000
-- and that there is nothing to
overlap in the left subtree.

01:18:34.000 --> 01:18:38.777
I went left here but I am not
going to find anything.

01:18:38.777 --> 01:18:43.922
Now I want to prove that it
wouldn't have helped me to go

01:18:43.922 --> 01:18:46.954
right.
That's essentially what the

01:18:46.954 --> 01:18:50.812
theorem here says.
That if I assume this it

01:18:50.812 --> 01:18:53.752
wouldn't have helped to go
right.

01:18:53.752 --> 01:19:00.000
I want to show that there is
nothing in the right subtree.

01:19:00.000 --> 01:19:07.277
So going left was OK because I
wasn't going to find anything

01:19:07.277 --> 01:19:11.348
anyway.
Similarly, we go through a

01:19:11.348 --> 01:19:17.145
similar analysis.
Low of i is less than or equal

01:19:17.145 --> 01:19:23.312
to m of the left of x,
which once again is equal to

01:19:23.312 --> 01:19:34.053
the high of j for some j in L.
We are just saying if I go left

01:19:34.053 --> 01:19:41.473
these things must be true.
I went left.

01:19:41.473 --> 01:19:52.213
Since j is in L it doesn't
overlap i, because the set of

01:19:52.213 --> 01:20:01.000
things that overlap i in L is
empty set.

01:20:01.000 --> 01:20:14.022
Since j doesn't overlap i that
implies that the high of i must

01:20:14.022 --> 01:20:20.000
be less than the low of j.

01:20:25.000 --> 01:20:31.913
Since j is in L and it doesn't
overlap i, what are the

01:20:31.913 --> 01:20:38.145
possibilities?
We essentially have here,

01:20:38.145 --> 01:20:45.939
if I draw a picture,
I have j and L and I have i

01:20:45.939 --> 01:20:51.412
here.
The point is that it doesn't

01:20:51.412 --> 01:21:00.035
overlap it, therefore,
it must be to the left because

01:21:00.035 --> 01:21:07.000
its low endpoint is less than
this.

01:21:07.000 --> 01:21:11.659
But it doesn't overlap it,
therefore its high endpoint

01:21:11.659 --> 01:21:15.000
must be left of the low of this
one.

01:21:28.000 --> 01:21:30.000
Now we will use the binary
search tree property.

01:21:37.000 --> 01:21:44.576
That implies that for all i
prime in R, everything in the

01:21:44.576 --> 01:21:50.664
right subtree,
we have a low of j is less than

01:21:50.664 --> 01:21:57.835
or equal to low of i prime,
so we're sorted on the low

01:21:57.835 --> 01:22:02.439
endpoints.
Everything in the right subtree

01:22:02.439 --> 01:22:07.081
must have a low endpoint that
starts to the right of the low

01:22:07.081 --> 01:22:10.464
endpoint of j because j in the
left subtree.

01:22:10.464 --> 01:22:15.106
And everything in the whole
tree is sorted by low endpoints,

01:22:15.106 --> 01:22:19.355
so anything in the right
subtree is going to start over

01:22:19.355 --> 01:22:21.558
here.
Those are other things.

01:22:21.558 --> 01:22:25.964
These are the i primes in R.
We don't know how many there

01:22:25.964 --> 01:22:31.000
are, but they all start to the
right of this point.

01:22:31.000 --> 01:22:40.333
So they cannot overlap i
either, therefore,

01:22:40.333 --> 01:22:50.555
there is nothing.
All the i primes in R is also

01:22:50.555 --> 01:22:53.000
nobody.

01:22:57.000 --> 01:23:02.942
Just to go back again,
the basic idea is that since

01:23:02.942 --> 01:23:10.547
this guy doesn't overlap the guy
who is in the left and everybody

01:23:10.547 --> 01:23:16.252
to the right is going to be
further to the right,

01:23:16.252 --> 01:23:23.144
if I go left and don't find
anything that's OK because I am

01:23:23.144 --> 01:23:28.255
not going to find anything over
here anyway.

01:23:28.255 --> 01:23:35.147
They are not going to overlap.
Data-structure augmentation,

01:23:35.147 --> 01:23:41.652
great stuff.
It will give you a lot of rich,

01:23:41.652 --> 01:23:47.189
rich data structures built on
any ones you know,

01:23:47.189 --> 01:23:52.137
hash tables,
heaps, binary search trees and

01:23:52.137 --> 01:23:55.000
so forth.

